begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  * Copyright (c) 2012, Joyent, Inc. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_onexit.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deadlist.h>
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dsl_reaper
init|=
literal|"the grim reaper"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_checkfunc_t
name|dsl_dataset_destroy_begin_check
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_destroy_begin_sync
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dsl_syncfunc_t
name|dsl_dataset_set_reservation_sync
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SWITCH64
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|{ \ 		uint64_t __tmp = (x); \ 		(x) = (y); \ 		(y) = __tmp; \ 	}
end_define

begin_define
define|#
directive|define
name|DS_REF_MAX
value|(1ULL<< 62)
end_define

begin_define
define|#
directive|define
name|DSL_DEADLIST_BLOCKSIZE
value|SPA_MAXBLOCKSIZE
end_define

begin_define
define|#
directive|define
name|DSL_DATASET_IS_DESTROYED
parameter_list|(
name|ds
parameter_list|)
value|((ds)->ds_owner == dsl_reaper)
end_define

begin_comment
comment|/*  * Figure out how much of this delta should be propogated to the dsl_dir  * layer.  If there's a refreservation, that space has already been  * partially accounted for in our ancestors.  */
end_comment

begin_function
specifier|static
name|int64_t
name|parent_delta
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|int64_t
name|delta
parameter_list|)
block|{
name|uint64_t
name|old_bytes
decl_stmt|,
name|new_bytes
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|==
literal|0
condition|)
return|return
operator|(
name|delta
operator|)
return|;
name|old_bytes
operator|=
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|new_bytes
operator|=
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+
name|delta
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ABS
argument_list|(
call|(
name|int64_t
call|)
argument_list|(
name|new_bytes
operator|-
name|old_bytes
argument_list|)
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|ABS
argument_list|(
name|delta
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_bytes
operator|-
name|old_bytes
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_block_born
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|used
init|=
name|bp_get_dsize_sync
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"ds=%p"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It could have been compressed away to nothing */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_pool_mos_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
name|used
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
return|return;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|delta
operator|=
name|parent_delta
argument_list|(
name|ds
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+=
name|used
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+=
name|compressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+=
name|uncompressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|delta
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
operator|-
name|delta
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_block_kill
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|async
parameter_list|)
block|{
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|<=
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|int
name|used
init|=
name|bp_get_dsize_sync
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|used
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_free
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dsl_pool_mos_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|)
expr_stmt|;
return|return
operator|(
name|used
operator|)
return|;
block|}
name|ASSERT3P
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|int64_t
name|delta
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"freeing ds=%llu"
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_free
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|>=
name|used
operator|||
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|parent_delta
argument_list|(
name|ds
argument_list|,
operator|-
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|-=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|delta
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|-
name|used
operator|-
name|delta
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"putting on dead list: %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|async
condition|)
block|{
comment|/* 			 * We are here as part of zio's write done callback, 			 * which means we're a zio interrupt thread.  We can't 			 * call dsl_deadlist_insert() now because it may block 			 * waiting for I/O.  Instead, put bp on the deferred 			 * queue and let dsl_pool_sync() finish the job. 			 */
name|bplist_append
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_deadlist_insert
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* if (bp->blk_birth> prev prev snap txg) prev unique += bs */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|&&
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
condition|)
block|{
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
argument_list|,
operator|>=
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|-=
name|used
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
operator|>=
argument_list|,
name|compressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|-=
name|compressed
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
operator|>=
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|-=
name|uncompressed
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|used
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_prev_snap_txg
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|uint64_t
name|trysnap
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The snapshot creation could fail, but that would cause an 	 * incorrect FALSE return, which would only result in an 	 * overestimation of the amount of space that an operation would 	 * consume, which is OK. 	 * 	 * There's also a small window where we could miss a pending 	 * snapshot, because we could set the sync task in the quiescing 	 * phase.  So this should only be used as a guess. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_trysnap_txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
condition|)
name|trysnap
operator|=
name|ds
operator|->
name|ds_trysnap_txg
expr_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|trysnap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_block_freeable
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|blk_birth
parameter_list|)
block|{
if|if
condition|(
name|blk_birth
operator|<=
name|dsl_dataset_prev_snap_txg
argument_list|(
name|ds
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|ddt_prefetch
argument_list|(
name|dsl_dataset_get_spa
argument_list|(
name|ds
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_evict
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|dsv
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsv
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_owner
operator|==
name|NULL
operator|||
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|unique_remove
argument_list|(
name|ds
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_objset
operator|!=
name|NULL
condition|)
name|dmu_objset_evict
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|dsl_dataset_drop_ref
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
block|}
name|bplist_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|db
operator|!=
name|NULL
condition|)
block|{
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_deadlist
operator|.
name|dl_dbuf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|ds
operator|->
name|ds_deadlist
operator|.
name|dl_oldfmt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_dir
condition|)
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_recvlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_get_snapname
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_dataset_phys_t
modifier|*
name|headphys
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_buf_t
modifier|*
name|headdbuf
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|headdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|headphys
operator|=
name|headdbuf
operator|->
name|db_data
expr_stmt|;
name|err
operator|=
name|zap_value_search
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|headphys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
literal|0
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|headdbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snap_lookup
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|snapobj
init|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
decl_stmt|;
name|matchtype_t
name|mt
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_CI_DATASET
condition|)
name|mt
operator|=
name|MT_FIRST
expr_stmt|;
else|else
name|mt
operator|=
name|MT_EXACT
expr_stmt|;
name|err
operator|=
name|zap_lookup_norm
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|,
name|mt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOTSUP
operator|&&
name|mt
operator|==
name|MT_FIRST
condition|)
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snap_remove
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|snapobj
init|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
decl_stmt|;
name|matchtype_t
name|mt
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_dir_snap_cmtime_update
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_CI_DATASET
condition|)
name|mt
operator|=
name|MT_FIRST
expr_stmt|;
else|else
name|mt
operator|=
name|MT_EXACT
expr_stmt|;
name|err
operator|=
name|zap_remove_norm
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
name|mt
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOTSUP
operator|&&
name|mt
operator|==
name|MT_FIRST
condition|)
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_get_ref
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|||
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
operator|&
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Make sure dsobj has the correct object type. */
name|dmu_object_info_from_db
argument_list|(
name|dbuf
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|doi
operator|.
name|doi_type
operator|!=
name|DMU_OT_DSL_DATASET
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|ds
operator|=
name|dmu_buf_get_user
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|winner
decl_stmt|;
name|ds
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dbuf
operator|=
name|dbuf
expr_stmt|;
name|ds
operator|->
name|ds_object
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_recvlock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_sendstream_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bplist_create
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|ds
operator|->
name|ds_sendstreams
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_sendarg_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_sendarg_t
argument_list|,
name|dsa_link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_recvlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
condition|)
block|{
name|err
operator|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_SNAPNAMES
condition|)
name|err
operator|=
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|zap_count
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
argument_list|,
operator|&
name|ds
operator|->
name|ds_userrefs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* 			 * In sync context, we're called with either no lock 			 * or with the write lock.  If we're not syncing, 			 * we're always called with the read lock held. 			 */
name|boolean_t
name|need_lock
init|=
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|&&
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
decl_stmt|;
if|if
condition|(
name|need_lock
condition|)
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
literal|"refreservation"
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_reserved
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_get_ds
argument_list|(
name|ds
argument_list|,
literal|"refquota"
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_quota
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|need_lock
condition|)
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_reserved
operator|=
name|ds
operator|->
name|ds_quota
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|winner
operator|=
name|dmu_buf_set_user_ie
argument_list|(
name|dbuf
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
argument_list|,
name|dsl_dataset_evict
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
name|winner
condition|)
block|{
name|bplist_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_recvlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ds
operator|=
name|winner
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_fsid_guid
operator|=
name|unique_insert
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
operator|==
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_phys
argument_list|,
operator|==
argument_list|,
name|dbuf
operator|->
name|db_data
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
operator|||
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_ORIGIN
operator|||
name|dp
operator|->
name|dp_origin_snap
operator|==
name|NULL
operator|||
name|ds
operator|==
name|dp
operator|->
name|dp_origin_snap
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
operator|&&
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|ds
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_hold_ref
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
comment|/* 	 * In syncing context we don't want the rwlock lock: there 	 * may be an existing writer waiting for sync phase to 	 * finish.  We don't need to worry about such writers, since 	 * sync phase is single-threaded, so the writer can't be 	 * doing anything while we are active. 	 */
if|if
condition|(
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Normal users will hold the ds_rwlock as a READER until they 	 * are finished (i.e., call dsl_dataset_rele()).  "Owners" will 	 * drop their READER lock after they set the ds_owner field. 	 * 	 * If the dataset is being destroyed, the destroy thread will 	 * obtain a WRITER lock for exclusive access after it's done its 	 * open-context work and then change the ds_owner to 	 * dsl_reaper once destruction is assured.  So threads 	 * may block here temporarily, until the "destructability" of 	 * the dataset is determined. 	 */
name|ASSERT
argument_list|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|,
name|RW_READER
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|,
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dataset_drop_ref
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
comment|/* 		 * The dp_config_rwlock lives above the ds_lock. And 		 * we need to check DSL_DATASET_IS_DESTROYED() while 		 * holding the ds_lock, so we have to drop and reacquire 		 * the ds_lock here. 		 */
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_hold_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|dsl_dataset_hold_ref
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_own_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|boolean_t
name|inconsistentok
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
name|dsl_dataset_tryown
argument_list|(
operator|*
name|dsp
argument_list|,
name|inconsistentok
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_hold
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|dsl_dir_open_spa
argument_list|(
name|NULL
argument_list|,
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dp
operator|=
name|dd
operator|->
name|dd_pool
expr_stmt|;
name|obj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
condition|)
name|err
operator|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dataset_hold_ref
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* we may be looking for a snapshot */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|snapname
operator|!=
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|snapname
operator|++
operator|!=
literal|'@'
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|err
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dprintf
argument_list|(
literal|"looking for snapshot '%s'\n"
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
operator|*
name|dsp
argument_list|,
name|snapname
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|err
operator|==
literal|0
operator|)
argument_list|,
operator|==
argument_list|,
operator|(
name|ds
operator|!=
name|NULL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_hold_ref
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|err
condition|?
name|NULL
else|:
name|ds
expr_stmt|;
block|}
block|}
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_own
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|boolean_t
name|inconsistentok
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_hold
argument_list|(
name|name
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
name|dsl_dataset_tryown
argument_list|(
operator|*
name|dsp
argument_list|,
name|inconsistentok
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_name
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"mos"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dir_name
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
comment|/* 			 * We use a "recursive" mutex so that we 			 * can call dprintf_ds() with ds_lock held. 			 */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_namelen
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|int
name|result
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|result
operator|=
literal|3
expr_stmt|;
comment|/* "mos" */
block|}
else|else
block|{
name|result
operator|=
name|dsl_dir_namelen
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
block|{
operator|++
name|result
expr_stmt|;
comment|/* adding one for the @-sign */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|result
operator|+=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|result
operator|+=
name|strlen
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_drop_ref
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_rele
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dsl_pool_sync_context
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_drop_ref
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_disown
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
name|ds
operator|->
name|ds_owner
operator|==
name|tag
operator|&&
name|ds
operator|->
name|ds_dbuf
operator|)
operator|||
operator|(
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
operator|&&
name|ds
operator|->
name|ds_dbuf
operator|==
name|NULL
operator|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_owner
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dbuf
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
else|else
name|dsl_dataset_evict
argument_list|(
name|NULL
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_tryown
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|boolean_t
name|inconsistentok
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|boolean_t
name|gotit
init|=
name|FALSE
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_owner
operator|==
name|NULL
operator|&&
operator|(
operator|!
name|DS_IS_INCONSISTENT
argument_list|(
name|ds
argument_list|)
operator|||
name|inconsistentok
operator|)
condition|)
block|{
name|ds
operator|->
name|ds_owner
operator|=
name|tag
expr_stmt|;
if|if
condition|(
operator|!
name|dsl_pool_sync_context
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
condition|)
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|gotit
operator|=
name|TRUE
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|gotit
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_make_exclusive
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|)
block|{
name|ASSERT3P
argument_list|(
name|owner
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|)
condition|)
name|rw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_create_sync_dd
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dd
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
name|origin
operator|=
name|dp
operator|->
name|dp_origin_snap
expr_stmt|;
name|ASSERT
argument_list|(
name|origin
operator|==
name|NULL
operator|||
name|origin
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|==
name|dp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|origin
operator|==
name|NULL
operator|||
name|origin
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|dsphys
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator|=
name|flags
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_snapnames_zapobj
operator|=
name|zap_create_norm
argument_list|(
name|mos
argument_list|,
name|U8_TEXTPREP_TOUPPER
argument_list|,
name|DMU_OT_DSL_DS_SNAP_MAP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|tx
operator|->
name|tx_txg
operator|==
name|TXG_INITIAL
condition|?
literal|1
else|:
name|tx
operator|->
name|tx_txg
expr_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
block|{
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|dsl_deadlist_alloc
argument_list|(
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dataset_t
modifier|*
name|ohds
decl_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|origin
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_referenced_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator||=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|++
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ohds
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|dsl_deadlist_clone
argument_list|(
operator|&
name|ohds
operator|->
name|ds_deadlist
argument_list|,
name|dsphys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|dsphys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ohds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_NEXT_CLONES
condition|)
block|{
if|if
condition|(
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|==
literal|0
condition|)
block|{
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_NEXT_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|origin
operator|->
name|ds_object
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
if|if
condition|(
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|dsphys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
name|dsobj
expr_stmt|;
return|return
operator|(
name|dsobj
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_create_sync
parameter_list|(
name|dsl_dir_t
modifier|*
name|pdd
parameter_list|,
specifier|const
name|char
modifier|*
name|lastname
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|pdd
operator|->
name|dd_pool
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|ddobj
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|ASSERT
argument_list|(
name|lastname
index|[
literal|0
index|]
operator|!=
literal|'@'
argument_list|)
expr_stmt|;
name|ddobj
operator|=
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|pdd
argument_list|,
name|lastname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|ddobj
argument_list|,
name|lastname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dsl_dataset_create_sync_dd
argument_list|(
name|dd
argument_list|,
name|origin
argument_list|,
name|flags
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_deleg_set_create_perms
argument_list|(
name|dd
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * If we are creating a clone, make sure we zero out any stale 	 * data from the origin snapshots zil header. 	 */
if|if
condition|(
name|origin
operator|!=
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|os
operator|->
name|os_zil_header
argument_list|,
sizeof|sizeof
argument_list|(
name|os
operator|->
name|os_zil_header
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dsobj
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The snapshots must all be in the same pool.  */
end_comment

begin_function
name|int
name|dmu_snapshots_destroy_nvl
parameter_list|(
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|boolean_t
name|defer
parameter_list|,
name|nvlist_t
modifier|*
name|errlist
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|nvpair_t
modifier|*
name|pair
decl_stmt|;
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|spa_open
argument_list|(
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|err
operator|=
name|dsl_dataset_own
argument_list|(
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|B_TRUE
argument_list|,
name|dstg
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|struct
name|dsl_ds_destroyarg
modifier|*
name|dsda
decl_stmt|;
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|dstg
argument_list|)
expr_stmt|;
name|dsda
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_destroyarg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dsda
operator|->
name|ds
operator|=
name|ds
expr_stmt|;
name|dsda
operator|->
name|defer
operator|=
name|defer
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|dstg
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
name|dsda
argument_list|,
name|dstg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fnvlist_add_int32
argument_list|(
name|errlist
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
name|err
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|struct
name|dsl_ds_destroyarg
modifier|*
name|dsda
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsda
operator|->
name|ds
decl_stmt|;
comment|/* 		 * Return the snapshots that triggered the error. 		 */
if|if
condition|(
name|dst
operator|->
name|dst_err
operator|!=
literal|0
condition|)
block|{
name|char
name|name
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fnvlist_add_int32
argument_list|(
name|errlist
argument_list|,
name|name
argument_list|,
name|dst
operator|->
name|dst_err
argument_list|)
expr_stmt|;
block|}
name|ASSERT3P
argument_list|(
name|dsda
operator|->
name|rm_origin
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|dstg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dsda
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_destroyarg
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_sync_task_group_destroy
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|dsl_dataset_might_destroy_origin
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|boolean_t
name|might_destroy
init|=
name|B_FALSE
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|==
literal|2
operator|&&
name|ds
operator|->
name|ds_userrefs
operator|==
literal|0
operator|&&
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds
argument_list|)
condition|)
name|might_destroy
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|might_destroy
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we're removing a clone, and these three conditions are true:  *	1) the clone's origin has no other children  *	2) the clone's origin has no user references  *	3) the clone's origin has been marked for deferred destruction  * Then, prepare to remove the origin as part of this sync task group.  */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_origin_rm_prep
parameter_list|(
name|struct
name|dsl_ds_destroyarg
modifier|*
name|dsda
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsda
operator|->
name|ds
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin
init|=
name|ds
operator|->
name|ds_prev
decl_stmt|;
if|if
condition|(
name|dsl_dataset_might_destroy_origin
argument_list|(
name|origin
argument_list|)
condition|)
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|namelen
operator|=
name|dsl_dataset_namelen
argument_list|(
name|origin
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|kmem_alloc
argument_list|(
name|namelen
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|origin
argument_list|,
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|error
operator|=
name|zfs_unmount_snap
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
name|error
operator|=
name|dsl_dataset_own
argument_list|(
name|name
argument_list|,
name|B_TRUE
argument_list|,
name|tag
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dsda
operator|->
name|rm_origin
operator|=
name|origin
expr_stmt|;
name|dsl_dataset_make_exclusive
argument_list|(
name|origin
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ds must be opened as OWNER.  On return (whether successful or not),  * ds will be closed and caller can no longer dereference it.  */
end_comment

begin_function
name|int
name|dsl_dataset_destroy
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|boolean_t
name|defer
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|struct
name|dsl_ds_destroyarg
name|dsda
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dsda
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* Destroying a snapshot is simpler */
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dsda
operator|.
name|defer
operator|=
name|defer
expr_stmt|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
operator|&
name|dsda
argument_list|,
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dsda
operator|.
name|rm_origin
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|defer
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|dd
operator|=
name|ds
operator|->
name|ds_dir
expr_stmt|;
if|if
condition|(
operator|!
name|spa_feature_is_enabled
argument_list|(
name|dsl_dataset_get_spa
argument_list|(
name|ds
argument_list|)
argument_list|,
operator|&
name|spa_feature_table
index|[
name|SPA_FEATURE_ASYNC_DESTROY
index|]
argument_list|)
condition|)
block|{
comment|/* 		 * Check for errors and mark this ds as inconsistent, in 		 * case we crash while freeing the objects. 		 */
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_destroy_begin_check
argument_list|,
name|dsl_dataset_destroy_begin_sync
argument_list|,
name|ds
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Remove all objects while in the open context so that 		 * there is less work to do in the syncing context. 		 */
for|for
control|(
name|obj
operator|=
literal|0
init|;
name|err
operator|==
literal|0
condition|;
name|err
operator|=
name|dmu_object_next
argument_list|(
name|os
argument_list|,
operator|&
name|obj
argument_list|,
name|FALSE
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|)
control|)
block|{
comment|/* 			 * Ignore errors, if there is not enough disk space 			 * we will deal with it in dsl_dataset_destroy_sync(). 			 */
operator|(
name|void
operator|)
name|dmu_free_object
argument_list|(
name|os
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
name|ESRCH
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Sync out all in-flight IO. 		 */
name|txg_wait_synced
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If we managed to free all the objects in open 		 * context, the user space accounting should be zero. 		 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_fill
operator|==
literal|0
operator|&&
name|dmu_objset_userused_enabled
argument_list|(
name|os
argument_list|)
condition|)
block|{
name|uint64_t
name|count
decl_stmt|;
name|ASSERT
argument_list|(
name|zap_count
argument_list|(
name|os
argument_list|,
name|DMU_USERUSED_OBJECT
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
operator|||
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zap_count
argument_list|(
name|os
argument_list|,
name|DMU_GROUPUSED_OBJECT
argument_list|,
operator|&
name|count
argument_list|)
operator|!=
literal|0
operator|||
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|rw_enter
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dd
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Blow away the dsl_dir + head dataset. 	 */
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* 	 * If we're removing a clone, we might also need to remove its 	 * origin. 	 */
do|do
block|{
name|dsda
operator|.
name|need_prep
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|dsl_dir_is_clone
argument_list|(
name|dd
argument_list|)
condition|)
block|{
name|err
operator|=
name|dsl_dataset_origin_rm_prep
argument_list|(
operator|&
name|dsda
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|dstg
argument_list|,
name|dsl_dataset_destroy_check
argument_list|,
name|dsl_dataset_destroy_sync
argument_list|,
operator|&
name|dsda
argument_list|,
name|tag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|dstg
argument_list|,
name|dsl_dir_destroy_check
argument_list|,
name|dsl_dir_destroy_sync
argument_list|,
name|dd
argument_list|,
name|FTAG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|dstg
argument_list|)
expr_stmt|;
comment|/* 		 * We could be racing against 'zfs release' or 'zfs destroy -d' 		 * on the origin snap, in which case we can get EBUSY if we 		 * needed to destroy the origin snap but were not ready to 		 * do so. 		 */
if|if
condition|(
name|dsda
operator|.
name|need_prep
condition|)
block|{
name|ASSERT
argument_list|(
name|err
operator|==
name|EBUSY
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_dir_is_clone
argument_list|(
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsda
operator|.
name|rm_origin
operator|==
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dsda
operator|.
name|need_prep
condition|)
do|;
if|if
condition|(
name|dsda
operator|.
name|rm_origin
operator|!=
name|NULL
condition|)
name|dsl_dataset_disown
argument_list|(
name|dsda
operator|.
name|rm_origin
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* if it is successful, dsl_dir_destroy_sync will close the dd */
if|if
condition|(
name|err
condition|)
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|out
label|:
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|blkptr_t
modifier|*
name|dsl_dataset_get_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_set_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's the meta-objset, set dp_meta_rootbp */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|tx
operator|->
name|tx_pool
operator|->
name|dp_meta_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|spa_t
modifier|*
name|dsl_dataset_get_spa
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_dirty
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
comment|/* this is the meta-objset */
return|return;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_objset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"dirtying snapshot!"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
if|if
condition|(
name|txg_list_add
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|ds
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* up the hold count until we can be written out */
name|dmu_buf_add_ref
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_is_dirty
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|txg_list_member
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_dirty_datasets
argument_list|,
name|ds
argument_list|,
name|t
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The unique space in the head dataset can be calculated by subtracting  * the space used in the most recent snapshot, that is still being used  * in this file system, from the space currently in use.  To figure out  * the space in the most recent snapshot still in use, we need to take  * the total space used in the snapshot and subtract out the space that  * has been freed up since the snapshot was taken.  */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_recalc_head_uniq
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|uint64_t
name|mrs_used
decl_stmt|;
name|uint64_t
name|dlused
decl_stmt|,
name|dlcomp
decl_stmt|,
name|dluncomp
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
name|mrs_used
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
else|else
name|mrs_used
operator|=
literal|0
expr_stmt|;
name|dsl_deadlist_space
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dlused
argument_list|,
operator|&
name|dlcomp
argument_list|,
operator|&
name|dluncomp
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dlused
argument_list|,
operator|<=
argument_list|,
name|mrs_used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|-
operator|(
name|mrs_used
operator|-
name|dlused
operator|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|killarg
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|kill_blkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|killarg
modifier|*
name|ka
init|=
name|arg
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|ka
operator|->
name|tx
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zb
operator|->
name|zb_level
operator|==
name|ZB_ZIL_LEVEL
condition|)
block|{
name|ASSERT
argument_list|(
name|zilog
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * It's a block in the intent log.  It has no 		 * accounting, so just free it. 		 */
name|dsl_free
argument_list|(
name|ka
operator|->
name|tx
operator|->
name|tx_pool
argument_list|,
name|ka
operator|->
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zilog
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|bp
operator|->
name|blk_birth
argument_list|,
operator|>
argument_list|,
name|ka
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_dataset_block_kill
argument_list|(
name|ka
operator|->
name|ds
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_destroy_begin_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * Can't delete a head dataset if there are snapshots of it. 	 * (Except if the only snapshots are from the branch we cloned 	 * from.) 	 */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * This is really a dsl_dir thing, but check it here so that 	 * we'll be less likely to leave this dataset inconsistent& 	 * nearly destroyed. 	 */
name|err
operator|=
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|,
operator|&
name|count
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|count
operator|!=
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_destroy_begin_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
comment|/* Mark it as inconsistent on-disk, in case we crash */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_INCONSISTENT
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"destroy begin"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_origin_check
parameter_list|(
name|struct
name|dsl_ds_destroyarg
modifier|*
name|dsda
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsda
operator|->
name|ds
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_prev
init|=
name|ds
operator|->
name|ds_prev
decl_stmt|;
if|if
condition|(
name|dsl_dataset_might_destroy_origin
argument_list|(
name|ds_prev
argument_list|)
condition|)
block|{
name|struct
name|dsl_ds_destroyarg
name|ndsda
init|=
block|{
literal|0
block|}
decl_stmt|;
comment|/* 		 * If we're not prepared to remove the origin, don't remove 		 * the clone either. 		 */
if|if
condition|(
name|dsda
operator|->
name|rm_origin
operator|==
name|NULL
condition|)
block|{
name|dsda
operator|->
name|need_prep
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|ndsda
operator|.
name|ds
operator|=
name|ds_prev
expr_stmt|;
name|ndsda
operator|.
name|is_origin_rm
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|dsl_dataset_destroy_check
argument_list|(
operator|&
name|ndsda
argument_list|,
name|tag
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If we're not going to remove the origin after all, 	 * undo the open context setup. 	 */
if|if
condition|(
name|dsda
operator|->
name|rm_origin
operator|!=
name|NULL
condition|)
block|{
name|dsl_dataset_disown
argument_list|(
name|dsda
operator|->
name|rm_origin
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dsda
operator|->
name|rm_origin
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If you add new checks here, you may need to add  * additional checks to the "temporary" case in  * snapshot_check() in dmu_objset.c.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dsl_dataset_destroy_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|dsl_ds_destroyarg
modifier|*
name|dsda
init|=
name|arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsda
operator|->
name|ds
decl_stmt|;
comment|/* we have an owner hold, so noone else can destroy us */
name|ASSERT
argument_list|(
operator|!
name|DSL_DATASET_IS_DESTROYED
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Only allow deferred destroy on pools that support it. 	 * NOTE: deferred destroy is only supported on snapshots. 	 */
if|if
condition|(
name|dsda
operator|->
name|defer
condition|)
block|{
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_USERREFS
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|ASSERT
argument_list|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Can't delete a head dataset if there are snapshots of it. 	 * (Except if the only snapshots are from the branch we cloned 	 * from.) 	 */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
comment|/* 	 * If we made changes this txg, traverse_dsl_dataset won't find 	 * them.  Try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
comment|/* 		 * If this snapshot has an elevated user reference count, 		 * we can't destroy it yet. 		 */
if|if
condition|(
name|ds
operator|->
name|ds_userrefs
operator|>
literal|0
operator|&&
operator|!
name|dsda
operator|->
name|releasing
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Can't delete a branch point. However, if we're destroying 		 * a clone and removing its origin due to it having a user 		 * hold count of 0 and having been marked for deferred destroy, 		 * it's OK for the origin to have a single clone. 		 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
operator|(
name|dsda
operator|->
name|is_origin_rm
condition|?
literal|2
else|:
literal|1
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|EEXIST
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
condition|)
block|{
return|return
operator|(
name|dsl_dataset_origin_check
argument_list|(
name|dsda
argument_list|,
name|arg2
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
comment|/* XXX we should do some i/o error checking... */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|refsarg
block|{
name|kmutex_t
name|lock
decl_stmt|;
name|boolean_t
name|gone
decl_stmt|;
name|kcondvar_t
name|cv
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_refs_gone
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|refsarg
modifier|*
name|arg
init|=
name|argv
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arg
operator|->
name|lock
argument_list|)
expr_stmt|;
name|arg
operator|->
name|gone
operator|=
name|TRUE
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|arg
operator|->
name|cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arg
operator|->
name|lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_drain_refs
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|struct
name|refsarg
name|arg
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|arg
operator|.
name|cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|arg
operator|.
name|gone
operator|=
name|FALSE
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_buf_update_user
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|,
operator|&
name|arg
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
argument_list|,
name|dsl_dataset_refs_gone
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|arg
operator|.
name|gone
condition|)
name|cv_wait
argument_list|(
operator|&
name|arg
operator|.
name|cv
argument_list|,
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arg
operator|.
name|gone
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dbuf
operator|=
name|NULL
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|=
name|NULL
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|arg
operator|.
name|lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|arg
operator|.
name|cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|remove_from_next_clones
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_remove_int
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * The err should not be ENOENT, but a bug in a previous version 	 * of the code could cause upgrade_clones_cb() to not set 	 * ds_next_snap_obj when it should, leading to a missing entry. 	 * If we knew that the pool was created after 	 * SPA_VERSION_NEXT_CLONES, we could assert that it isn't 	 * ENOENT.  However, at least we can check that we don't have 	 * too many entries in the next_clones_obj even after failing to 	 * remove this one. 	 */
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
block|{
name|VERIFY0
argument_list|(
name|err
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
operator|&
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|count
argument_list|,
operator|<=
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_remove_clones_key
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
comment|/* 	 * If it is the old version, dd_clones doesn't exist so we can't 	 * find the clones, but deadlist_remove_key() is a no-op so it 	 * doesn't matter. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|==
literal|0
condition|)
return|return;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|clone
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|clone
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
operator|>
name|mintxg
condition|)
block|{
name|dsl_deadlist_remove_key
argument_list|(
operator|&
name|clone
operator|->
name|ds_deadlist
argument_list|,
name|mintxg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_remove_clones_key
argument_list|(
name|clone
argument_list|,
name|mintxg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|clone
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|process_old_arg
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_prev
decl_stmt|;
name|boolean_t
name|after_branch_point
decl_stmt|;
name|zio_t
modifier|*
name|pio
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|process_old_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|process_old_arg
modifier|*
name|poa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|poa
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|<=
name|poa
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|dsl_deadlist_insert
argument_list|(
operator|&
name|poa
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|poa
operator|->
name|ds_prev
operator|&&
operator|!
name|poa
operator|->
name|after_branch_point
operator|&&
name|bp
operator|->
name|blk_birth
operator|>
name|poa
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|poa
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|bp_get_dsize_sync
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|poa
operator|->
name|used
operator|+=
name|bp_get_dsize_sync
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|poa
operator|->
name|comp
operator|+=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|poa
operator|->
name|uncomp
operator|+=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|dsl_free_sync
argument_list|(
name|poa
operator|->
name|pio
argument_list|,
name|dp
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|process_old_deadlist
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds_prev
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds_next
parameter_list|,
name|boolean_t
name|after_branch_point
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|process_old_arg
name|poa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_deadlist
operator|.
name|dl_oldfmt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds_next
operator|->
name|ds_deadlist
operator|.
name|dl_oldfmt
argument_list|)
expr_stmt|;
name|poa
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|poa
operator|.
name|ds_prev
operator|=
name|ds_prev
expr_stmt|;
name|poa
operator|.
name|after_branch_point
operator|=
name|after_branch_point
expr_stmt|;
name|poa
operator|.
name|pio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_iterate
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
operator|.
name|dl_bpobj
argument_list|,
name|process_old_cb
argument_list|,
operator|&
name|poa
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zio_wait
argument_list|(
name|poa
operator|.
name|pio
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|poa
operator|.
name|used
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
comment|/* change snapused */
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_SNAP
argument_list|,
operator|-
name|poa
operator|.
name|used
argument_list|,
operator|-
name|poa
operator|.
name|comp
argument_list|,
operator|-
name|poa
operator|.
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* swap next's deadlist to our deadlist */
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|old_synchronous_dataset_destroy
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|killarg
name|ka
decl_stmt|;
comment|/* 	 * Free everything that we point to (that's born after 	 * the previous snapshot, if we are a clone) 	 * 	 * NB: this should be very quick, because we already 	 * freed all the objects in open context. 	 */
name|ka
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|ka
operator|.
name|tx
operator|=
name|tx
expr_stmt|;
name|err
operator|=
name|traverse_dataset
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|TRAVERSE_POST
argument_list|,
name|kill_blkptr
argument_list|,
operator|&
name|ka
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_destroy_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|dsl_ds_destroyarg
modifier|*
name|dsda
init|=
name|arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsda
operator|->
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|int
name|after_branch_point
init|=
name|FALSE
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds_prev
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|wont_destroy
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|wont_destroy
operator|=
operator|(
name|dsda
operator|->
name|defer
operator|&&
operator|(
name|ds
operator|->
name|ds_userrefs
operator|>
literal|0
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
operator|)
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_owner
operator|||
name|wont_destroy
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsda
operator|->
name|defer
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|<=
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
operator|||
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
argument_list|,
operator|<=
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|wont_destroy
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_USERREFS
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_DEFER_DESTROY
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"defer_destroy"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* We need to log before removing it from the namespace. */
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"destroy"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* signal any waiters that this dataset is going away */
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_owner
operator|=
name|dsl_reaper
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|ds
operator|->
name|ds_exclusive_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
comment|/* Remove our reservation */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|!=
literal|0
condition|)
block|{
name|dsl_prop_setarg_t
name|psa
decl_stmt|;
name|uint64_t
name|value
init|=
literal|0
decl_stmt|;
name|dsl_prop_setarg_init_uint64
argument_list|(
operator|&
name|psa
argument_list|,
literal|"refreservation"
argument_list|,
operator|(
name|ZPROP_SRC_NONE
operator||
name|ZPROP_SRC_LOCAL
operator||
name|ZPROP_SRC_RECEIVED
operator|)
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|psa
operator|.
name|psa_effective_value
operator|=
literal|0
expr_stmt|;
comment|/* predict default value */
name|dsl_dataset_set_reservation_sync
argument_list|(
name|ds
argument_list|,
operator|&
name|psa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_scan_ds_destroyed
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|ds_prev
operator|=
name|ds
operator|->
name|ds_prev
expr_stmt|;
block|}
else|else
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|after_branch_point
operator|=
operator|(
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|obj
operator|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|after_branch_point
operator|&&
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|remove_from_next_clones
argument_list|(
name|ds_prev
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|after_branch_point
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
block|{
comment|/* This clone is toast. */
name|ASSERT
argument_list|(
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
argument_list|)
expr_stmt|;
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|--
expr_stmt|;
comment|/* 			 * If the clone's origin has no other clones, no 			 * user holds, and has been marked for deferred 			 * deletion, then we should have done the necessary 			 * destroy setup for it. 			 */
if|if
condition|(
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|==
literal|1
operator|&&
name|ds_prev
operator|->
name|ds_userrefs
operator|==
literal|0
operator|&&
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds_prev
argument_list|)
condition|)
block|{
name|ASSERT3P
argument_list|(
name|dsda
operator|->
name|rm_origin
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3P
argument_list|(
name|dsda
operator|->
name|rm_origin
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|after_branch_point
condition|)
block|{
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds_next
decl_stmt|;
name|uint64_t
name|old_unique
decl_stmt|;
name|uint64_t
name|used
init|=
literal|0
decl_stmt|,
name|comp
init|=
literal|0
decl_stmt|,
name|uncomp
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_next
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|old_unique
operator|=
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds_next
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds_prev
condition|?
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds_next
operator|->
name|ds_deadlist
operator|.
name|dl_oldfmt
condition|)
block|{
name|process_old_deadlist
argument_list|(
name|ds
argument_list|,
name|ds_prev
argument_list|,
name|ds_next
argument_list|,
name|after_branch_point
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Adjust prev's unique space. */
if|if
condition|(
name|ds_prev
operator|&&
operator|!
name|after_branch_point
condition|)
block|{
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
block|}
comment|/* Adjust snapused. */
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_SNAP
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|comp
argument_list|,
operator|-
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Move blocks to be freed to pool's free list. */
name|dsl_deadlist_move_bpobj
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_free_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|used
argument_list|,
name|comp
argument_list|,
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Merge our deadlist into next's and free it. */
name|dsl_deadlist_merge
argument_list|(
operator|&
name|ds_next
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_free
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Collapse range in clone heads */
name|dsl_dataset_remove_clones_key
argument_list|(
name|ds
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds_next
argument_list|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds_nextnext
decl_stmt|;
comment|/* 			 * Update next's unique to include blocks which 			 * were previously shared by only this snapshot 			 * and it.  Those blocks will be born after the 			 * prev snap and before this snap, and will have 			 * died after the next snap and before the one 			 * after that (ie. be on the snap after next's 			 * deadlist). 			 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_nextnext
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds_nextnext
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds_nextnext
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Collapse range in this head. */
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_deadlist_remove_key
argument_list|(
operator|&
name|hds
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3P
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_drop_ref
argument_list|(
name|ds_next
operator|->
name|ds_prev
argument_list|,
name|ds_next
argument_list|)
expr_stmt|;
name|ds_next
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ds_prev
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds_next
argument_list|,
operator|&
name|ds_next
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_recalc_head_uniq
argument_list|(
name|ds_next
argument_list|)
expr_stmt|;
comment|/* 			 * Reduce the amount of our unconsmed refreservation 			 * being charged to our parent by the amount of 			 * new unique data we have gained. 			 */
if|if
condition|(
name|old_unique
operator|<
name|ds_next
operator|->
name|ds_reserved
condition|)
block|{
name|int64_t
name|mrsdelta
decl_stmt|;
name|uint64_t
name|new_unique
init|=
name|ds_next
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
decl_stmt|;
name|ASSERT
argument_list|(
name|old_unique
operator|<=
name|new_unique
argument_list|)
expr_stmt|;
name|mrsdelta
operator|=
name|MIN
argument_list|(
name|new_unique
operator|-
name|old_unique
argument_list|,
name|ds_next
operator|->
name|ds_reserved
operator|-
name|old_unique
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
operator|-
name|mrsdelta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dataset_rele
argument_list|(
name|ds_next
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfeature_info_t
modifier|*
name|async_destroy
init|=
operator|&
name|spa_feature_table
index|[
name|SPA_FEATURE_ASYNC_DESTROY
index|]
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
comment|/* 		 * There's no next snapshot, so this is a head dataset. 		 * Destroy the deadlist.  Unless it's a clone, the 		 * deadlist should be empty.  (If it's a clone, it's 		 * safe to ignore the deadlist contents.) 		 */
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_free
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
literal|0
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spa_feature_is_enabled
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|async_destroy
argument_list|)
condition|)
block|{
name|err
operator|=
name|old_synchronous_dataset_destroy
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Move the bptree into the pool's list of trees to 			 * clean up and update space accounting information. 			 */
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|zil_destroy_sync
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spa_feature_is_active
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|async_destroy
argument_list|)
condition|)
block|{
name|spa_feature_incr
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|async_destroy
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_bptree_obj
operator|=
name|bptree_alloc
argument_list|(
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_BPTREE_OBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_bptree_obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|used
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_used_bytes
expr_stmt|;
name|comp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_compressed_bytes
expr_stmt|;
name|uncomp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_uncompressed_bytes
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|==
name|used
argument_list|)
expr_stmt|;
name|bptree_add
argument_list|(
name|mos
argument_list|,
name|dp
operator|->
name|dp_bptree_obj
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|used
argument_list|,
name|comp
argument_list|,
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|comp
argument_list|,
operator|-
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dp
operator|->
name|dp_free_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|used
argument_list|,
name|comp
argument_list|,
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove_int
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|=
name|ds_prev
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* 	 * This must be done after the dsl_traverse(), because it will 	 * re-open the objset. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_objset
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
comment|/* Erase the link in the dir */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* remove from snapshot namespace */
name|dsl_dataset_t
modifier|*
name|ds_head
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds_head
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
block|{
name|uint64_t
name|val
decl_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|ds_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|val
argument_list|,
operator|==
argument_list|,
name|obj
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|err
operator|=
name|dsl_dataset_snap_remove
argument_list|(
name|ds_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds_head
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds_prev
operator|&&
name|ds
operator|->
name|ds_prev
operator|!=
name|ds_prev
condition|)
name|dsl_dataset_rele
argument_list|(
name|ds_prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_prop_clear_bootfs
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|count
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|==
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
operator|&
name|count
argument_list|)
operator|&&
name|count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
operator|!=
literal|0
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_props_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
operator|!=
literal|0
condition|)
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_destroy
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|=
name|NULL
expr_stmt|;
name|dsl_dataset_drain_refs
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_object_free
argument_list|(
name|mos
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsda
operator|->
name|rm_origin
condition|)
block|{
comment|/* 		 * Remove the origin of the clone we just destroyed. 		 */
name|struct
name|dsl_ds_destroyarg
name|ndsda
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ndsda
operator|.
name|ds
operator|=
name|dsda
operator|->
name|rm_origin
expr_stmt|;
name|dsl_dataset_destroy_sync
argument_list|(
operator|&
name|ndsda
argument_list|,
name|tag
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_reserve_space
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|asize
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If there's an fs-only reservation, any blocks that might become 	 * owned by the snapshot dataset must be accommodated by space 	 * outside of the reservation. 	 */
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_reserved
operator|==
literal|0
operator|||
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|asize
operator|=
name|MIN
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
if|if
condition|(
name|asize
operator|>
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Propagate any reserved space for this snapshot to other 	 * snapshot checks in this sync group. 	 */
if|if
condition|(
name|asize
operator|>
literal|0
condition|)
name|dsl_dir_willuse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|asize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_snapshot_check
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
comment|/* 	 * We don't allow multiple snapshots of the same txg.  If there 	 * is already one, try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
comment|/* 	 * Check for conflicting snapshot name. 	 */
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|ds
argument_list|,
name|snapname
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
return|return
operator|(
name|EEXIST
operator|)
return|;
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Check that the dataset's name is not too long.  Name consists 	 * of the dataset's length + 1 for the @-sign + snapshot name's length 	 */
if|if
condition|(
name|dsl_dataset_namelen
argument_list|(
name|ds
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|snapname
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
name|err
operator|=
name|dsl_dataset_snapshot_reserve_space
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ds
operator|->
name|ds_trysnap_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_snapshot_sync
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|crtxg
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The origin's ds_creation_txg has to be< TXG_INITIAL 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|snapname
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|)
operator|==
literal|0
condition|)
name|crtxg
operator|=
literal|1
expr_stmt|;
else|else
name|crtxg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|dsphys
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_next_snap_obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_num_children
operator|=
literal|1
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|crtxg
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_referenced_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|!=
literal|0
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|uint64_t
name|next_clones_obj
init|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|||
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|dsobj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|remove_from_next_clones
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|dsphys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|next_clones_obj
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we have a reference-reservation on this dataset, we will 	 * need to increase the amount of refreservation being charged 	 * since our unique space is going to zero. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
condition|)
block|{
name|int64_t
name|delta
decl_stmt|;
name|ASSERT
argument_list|(
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|MIN
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_dbgmsg
argument_list|(
literal|"taking snapshot %s@%s/%llu; newkey=%llu"
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_myname
argument_list|,
name|snapname
argument_list|,
name|dsobj
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|dsl_deadlist_clone
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|UINT64_MAX
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_add_key
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|<
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|crtxg
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
name|err
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dsobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_ref
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_scan_ds_snapshotted
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_snap_cmtime_update
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
literal|"snapshot"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_sync
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_objset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * in case we had to change ds_fsid_guid when we opened it, 	 * sync it out now. 	 */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
operator|=
name|ds
operator|->
name|ds_fsid_guid
expr_stmt|;
name|dmu_objset_sync
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_clones_stat
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|count
init|=
literal|0
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|nvlist_t
modifier|*
name|val
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|val
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * There may me missing entries in ds_next_clones_obj 	 * due to a bug in a previous version of the code. 	 * Only trust it if it has the right number of entries. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
operator|&
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|1
condition|)
block|{
goto|goto
name|fail
goto|;
block|}
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|clone
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
comment|/* 		 * Even though we hold the dp_config_rwlock, the dataset 		 * may fail to open, returning ENOENT.  If there is a 		 * thread concurrently attempting to destroy this 		 * dataset, it will have the ds_rwlock held for 		 * RW_WRITER.  Our call to dsl_dataset_hold_obj() -> 		 * dsl_dataset_hold_ref() will fail its 		 * rw_tryenter(&ds->ds_rwlock, RW_READER), drop the 		 * dp_config_rwlock, and wait for the destroy progress 		 * and signal ds_exclusive_cv.  If the destroy was 		 * successful, we will see that 		 * DSL_DATASET_IS_DESTROYED(), and return ENOENT. 		 */
if|if
condition|(
name|dsl_dataset_hold_obj
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|clone
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|dsl_dir_name
argument_list|(
name|clone
operator|->
name|ds_dir
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|val
argument_list|,
name|buf
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|clone
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|val
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CLONES
argument_list|)
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|fail
label|:
name|nvlist_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_stats
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|uobjs
decl_stmt|,
name|aobjs
decl_stmt|,
name|ratio
decl_stmt|;
name|ratio
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|==
literal|0
condition|?
literal|100
else|:
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|*
literal|100
operator|/
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFRATIO
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_COMPRESSRATIO
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_USED
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
name|get_clones_stat
argument_list|(
name|ds
argument_list|,
name|nv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dir_stats
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|nv
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_space
argument_list|(
name|ds
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|uobjs
argument_list|,
operator|&
name|aobjs
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_AVAILABLE
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFERENCED
argument_list|,
name|refd
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATION
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_time
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFQUOTA
argument_list|,
name|ds
operator|->
name|ds_quota
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFRESERVATION
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_GUID
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_guid
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_UNIQUE
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_OBJSETID
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_USERREFS
argument_list|,
name|ds
operator|->
name|ds_userrefs
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_DEFER_DESTROY
argument_list|,
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|written
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|int
name|err
init|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
decl_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_space_written
argument_list|(
name|prev
argument_list|,
name|ds
argument_list|,
operator|&
name|written
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_WRITTEN
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|dsl_dataset_fast_stat
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
block|{
name|stat
operator|->
name|dds_creation_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|stat
operator|->
name|dds_inconsistent
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_INCONSISTENT
expr_stmt|;
name|stat
operator|->
name|dds_guid
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_guid
expr_stmt|;
name|stat
operator|->
name|dds_origin
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|stat
operator|->
name|dds_is_snapshot
operator|=
name|B_TRUE
expr_stmt|;
name|stat
operator|->
name|dds_num_clones
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|stat
operator|->
name|dds_is_snapshot
operator|=
name|B_FALSE
expr_stmt|;
name|stat
operator|->
name|dds_num_clones
operator|=
literal|0
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ods
decl_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_ref
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ods
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ods
argument_list|,
name|stat
operator|->
name|dds_origin
argument_list|)
expr_stmt|;
name|dsl_dataset_drop_ref
argument_list|(
name|ods
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_fsid_guid
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_fsid_guid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_space
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
block|{
operator|*
name|refdbytesp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
operator|*
name|availbytesp
operator|=
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
condition|)
operator|*
name|availbytesp
operator|+=
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_quota
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Adjust available bytes according to refquota 		 */
if|if
condition|(
operator|*
name|refdbytesp
operator|<
name|ds
operator|->
name|ds_quota
condition|)
operator|*
name|availbytesp
operator|=
name|MIN
argument_list|(
operator|*
name|availbytesp
argument_list|,
name|ds
operator|->
name|ds_quota
operator|-
operator|*
name|refdbytesp
argument_list|)
expr_stmt|;
else|else
operator|*
name|availbytesp
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|usedobjsp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_fill
expr_stmt|;
operator|*
name|availobjsp
operator|=
name|DN_MAX_OBJECT
operator|-
operator|*
name|usedobjsp
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_modified_since_lastsnap
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|||
name|dsl_pool_sync_context
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|,
modifier|*
name|os_prev
decl_stmt|;
comment|/* 		 * It may be that only the ZIL differs, because it was 		 * reset in the head.  Don't count that as being 		 * modified. 		 */
if|if
condition|(
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|dmu_objset_from_ds
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
operator|&
name|os_prev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|bcmp
argument_list|(
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|,
operator|&
name|os_prev
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|,
sizeof|sizeof
argument_list|(
name|os
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_rename_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|char
modifier|*
name|newsnapname
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* new name better not be in use */
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|newsnapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|EEXIST
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
comment|/* dataset name + 1 for the "@" + the new snapshot name must fit */
if|if
condition|(
name|dsl_dir_namelen
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|newsnapname
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
name|err
operator|=
name|ENAMETOOLONG
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_snapshot_rename_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
specifier|const
name|char
modifier|*
name|newsnapname
init|=
name|arg2
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|ds
operator|->
name|ds_dir
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dd
operator|->
name|dd_pool
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_remove
argument_list|(
name|hds
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|newsnapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"rename"
argument_list|,
name|tx
argument_list|,
literal|"-> @%s"
argument_list|,
name|newsnapname
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|renamesnaparg
block|{
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|char
name|failed
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
name|char
modifier|*
name|oldsnap
decl_stmt|;
name|char
modifier|*
name|newsnap
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dsl_snapshot_rename_one
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|renamesnaparg
modifier|*
name|ra
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|snapname
decl_stmt|;
name|int
name|err
decl_stmt|;
name|snapname
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s@%s"
argument_list|,
name|name
argument_list|,
name|ra
operator|->
name|oldsnap
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|ra
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * For recursive snapshot renames the parent won't be changing 	 * so we just pass name for both the to/from argument. 	 */
name|err
operator|=
name|zfs_secpolicy_rename_perms
argument_list|(
name|snapname
argument_list|,
name|snapname
argument_list|,
name|CRED
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|strfree
argument_list|(
name|snapname
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|==
name|ENOENT
condition|?
literal|0
else|:
name|err
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * For all filesystems undergoing rename, we'll need to unmount it. 	 */
operator|(
name|void
operator|)
name|zfs_unmount_snap
argument_list|(
name|snapname
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|snapname
argument_list|,
name|ra
operator|->
name|dstg
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|==
name|ENOENT
condition|?
literal|0
else|:
name|err
operator|)
return|;
name|dsl_sync_task_create
argument_list|(
name|ra
operator|->
name|dstg
argument_list|,
name|dsl_dataset_snapshot_rename_check
argument_list|,
name|dsl_dataset_snapshot_rename_sync
argument_list|,
name|ds
argument_list|,
name|ra
operator|->
name|newsnap
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_recursive_rename
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|struct
name|renamesnaparg
modifier|*
name|ra
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|fsname
init|=
name|spa_strdup
argument_list|(
name|oldname
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
literal|1
decl_stmt|;
comment|/* truncate the snapshot name to get the fsname */
name|cp
operator|=
name|strchr
argument_list|(
name|fsname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|fsname
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ra
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|renamesnaparg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ra
operator|->
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ra
operator|->
name|oldsnap
operator|=
name|strchr
argument_list|(
name|oldname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|ra
operator|->
name|newsnap
operator|=
name|strchr
argument_list|(
name|newname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|ra
operator|->
name|failed
operator|=
literal|'\0'
expr_stmt|;
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|fsname
argument_list|,
name|dsl_snapshot_rename_one
argument_list|,
name|ra
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|fsname
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|ra
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|ra
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
block|{
name|dsl_dir_name
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ra
operator|->
name|failed
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
literal|"@"
argument_list|,
sizeof|sizeof
argument_list|(
name|ra
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcat
argument_list|(
name|ra
operator|->
name|failed
argument_list|,
name|ra
operator|->
name|newsnap
argument_list|,
sizeof|sizeof
argument_list|(
name|ra
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|oldname
argument_list|,
name|ra
operator|->
name|failed
argument_list|,
sizeof|sizeof
argument_list|(
name|ra
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|ra
operator|->
name|dstg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ra
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|renamesnaparg
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_valid_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|int
name|delta
init|=
operator|*
operator|(
name|int
operator|*
operator|)
name|arg
decl_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|oldname
argument_list|)
operator|+
name|delta
operator|>=
name|MAXNAMELEN
condition|)
return|return
operator|(
name|ENAMETOOLONG
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_pragma
pragma|#
directive|pragma
name|weak
name|dmu_objset_rename
name|=
name|dsl_dataset_rename
end_pragma

begin_function
name|int
name|dsl_dataset_rename
parameter_list|(
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
specifier|const
name|char
modifier|*
name|tail
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dir_open
argument_list|(
name|oldname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|tail
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
block|{
name|int
name|delta
init|=
name|strlen
argument_list|(
name|newname
argument_list|)
operator|-
name|strlen
argument_list|(
name|oldname
argument_list|)
decl_stmt|;
comment|/* if we're growing, validate child name lengths */
if|if
condition|(
name|delta
operator|>
literal|0
condition|)
name|err
operator|=
name|dmu_objset_find
argument_list|(
name|oldname
argument_list|,
name|dsl_valid_rename
argument_list|,
operator|&
name|delta
argument_list|,
name|DS_FIND_CHILDREN
operator||
name|DS_FIND_SNAPSHOTS
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_dir_rename
argument_list|(
name|dd
argument_list|,
name|newname
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|tail
index|[
literal|0
index|]
operator|!=
literal|'@'
condition|)
block|{
comment|/* the name ended in a nonexistent component */
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* new name must be snapshot in same filesystem */
name|tail
operator|=
name|strchr
argument_list|(
name|newname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|tail
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|tail
operator|++
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|,
name|tail
operator|-
name|newname
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EXDEV
operator|)
return|;
if|if
condition|(
name|recursive
condition|)
block|{
name|err
operator|=
name|dsl_recursive_rename
argument_list|(
name|oldname
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|oldname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_snapshot_rename_check
argument_list|,
name|dsl_dataset_snapshot_rename_sync
argument_list|,
name|ds
argument_list|,
operator|(
name|char
operator|*
operator|)
name|tail
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|promotenode
block|{
name|list_node_t
name|link
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|promotearg
block|{
name|list_t
name|shared_snaps
decl_stmt|,
name|origin_snaps
decl_stmt|,
name|clone_snaps
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_origin
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|,
name|unique
decl_stmt|,
name|cloneusedsnap
decl_stmt|,
name|originusedsnap
decl_stmt|;
name|char
modifier|*
name|err_ds
decl_stmt|;
block|}
struct|;
end_struct

begin_function_decl
specifier|static
name|int
name|snaplist_space
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|snaplist_unstable
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|dsl_dataset_promote_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|hds
init|=
name|arg1
decl_stmt|;
name|struct
name|promotearg
modifier|*
name|pa
init|=
name|arg2
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
init|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|unused
decl_stmt|;
comment|/* Check that it is a real clone */
if|if
condition|(
operator|!
name|dsl_dir_is_clone
argument_list|(
name|hds
operator|->
name|ds_dir
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* Since this is so expensive, don't do the preliminary check */
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
condition|)
return|return
operator|(
name|EXDEV
operator|)
return|;
comment|/* compute origin's new unique space */
name|snap
operator|=
name|list_tail
argument_list|(
operator|&
name|pa
operator|->
name|clone_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|snap
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|pa
operator|->
name|unique
argument_list|,
operator|&
name|unused
argument_list|,
operator|&
name|unused
argument_list|)
expr_stmt|;
comment|/* 	 * Walk the snapshots that we are moving 	 * 	 * Compute space to transfer.  Consider the incremental changes 	 * to used for each snapshot: 	 * (my used) = (prev's used) + (blocks born) - (blocks killed) 	 * So each snapshot gave birth to: 	 * (blocks born) = (my used) - (prev's used) + (blocks killed) 	 * So a sequence would look like: 	 * (uN - u(N-1) + kN) + ... + (u1 - u0 + k1) + (u0 - 0 + k0) 	 * Which simplifies to: 	 * uN + kN + kN-1 + ... + k1 + k0 	 * Note however, if we stop before we reach the ORIGIN we get: 	 * uN + kN + kN-1 + ... + kM - uM-1 	 */
name|pa
operator|->
name|used
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|pa
operator|->
name|comp
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|uint64_t
name|val
decl_stmt|,
name|dlused
decl_stmt|,
name|dlcomp
decl_stmt|,
name|dluncomp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
comment|/* Check that the snapshot name does not conflict */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EEXIST
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
goto|goto
name|out
goto|;
comment|/* The very first snapshot does not have a deadlist */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|==
literal|0
condition|)
continue|continue;
name|dsl_deadlist_space
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dlused
argument_list|,
operator|&
name|dlcomp
argument_list|,
operator|&
name|dluncomp
argument_list|)
expr_stmt|;
name|pa
operator|->
name|used
operator|+=
name|dlused
expr_stmt|;
name|pa
operator|->
name|comp
operator|+=
name|dlcomp
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|+=
name|dluncomp
expr_stmt|;
block|}
comment|/* 	 * If we are a clone of a clone then we never reached ORIGIN, 	 * so we need to subtract out the clone origin's used space. 	 */
if|if
condition|(
name|pa
operator|->
name|origin_origin
condition|)
block|{
name|pa
operator|->
name|used
operator|-=
name|pa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|pa
operator|->
name|comp
operator|-=
name|pa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|pa
operator|->
name|uncomp
operator|-=
name|pa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
block|}
comment|/* Check that there is enough space here */
name|err
operator|=
name|dsl_dir_transfer_possible
argument_list|(
name|origin_ds
operator|->
name|ds_dir
argument_list|,
name|hds
operator|->
name|ds_dir
argument_list|,
name|pa
operator|->
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Compute the amounts of space that will be used by snapshots 	 * after the promotion (for both origin and clone).  For each, 	 * it is the amount of space that will be on all of their 	 * deadlists (that was not born before their new origin). 	 */
if|if
condition|(
name|hds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_flags
operator|&
name|DD_FLAG_USED_BREAKDOWN
condition|)
block|{
name|uint64_t
name|space
decl_stmt|;
comment|/* 		 * Note, typically this will not be a clone of a clone, 		 * so dd_origin_txg will be< TXG_INITIAL, so 		 * these snaplist_space() -> dsl_deadlist_space_range() 		 * calls will be fast because they do not have to 		 * iterate over all bps. 		 */
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|origin_snaps
argument_list|)
expr_stmt|;
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
operator|&
name|pa
operator|->
name|cloneusedsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|pa
operator|->
name|clone_snaps
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|pa
operator|->
name|cloneusedsnap
operator|+=
name|space
expr_stmt|;
block|}
if|if
condition|(
name|origin_ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_flags
operator|&
name|DD_FLAG_USED_BREAKDOWN
condition|)
block|{
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|pa
operator|->
name|origin_snaps
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|pa
operator|->
name|originusedsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|out
label|:
name|pa
operator|->
name|err_ds
operator|=
name|snap
operator|->
name|ds
operator|->
name|ds_snapname
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_promote_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|hds
init|=
name|arg1
decl_stmt|;
name|struct
name|promotearg
modifier|*
name|pa
init|=
name|arg2
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
init|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_head
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
init|=
name|hds
operator|->
name|ds_dir
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|hds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dsl_dir_t
modifier|*
name|odd
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|oldnext_obj
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|ASSERT
argument_list|(
literal|0
operator|==
operator|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
operator|)
argument_list|)
expr_stmt|;
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|origin_snaps
argument_list|)
expr_stmt|;
name|origin_head
operator|=
name|snap
operator|->
name|ds
expr_stmt|;
comment|/* 	 * We need to explicitly open odd, since origin_ds's dd will be 	 * changing. 	 */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|origin_ds
operator|->
name|ds_dir
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|odd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* change origin's next snap */
name|dmu_buf_will_dirty
argument_list|(
name|origin_ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|oldnext_obj
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
name|snap
operator|=
name|list_tail
argument_list|(
operator|&
name|pa
operator|->
name|clone_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|snap
operator|->
name|ds
operator|->
name|ds_object
expr_stmt|;
comment|/* change the origin's next clone */
if|if
condition|(
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
condition|)
block|{
name|remove_from_next_clones
argument_list|(
name|origin_ds
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|oldnext_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* change origin */
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|odd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
expr_stmt|;
name|dd
operator|->
name|dd_origin_txg
operator|=
name|origin_head
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|odd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|odd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|origin_ds
operator|->
name|ds_object
expr_stmt|;
name|origin_head
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
comment|/* change dd_clone entries */
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|odd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|hds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|pa
operator|->
name|origin_origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|hds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|pa
operator|->
name|origin_origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|origin_head
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|==
literal|0
condition|)
block|{
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|=
name|zap_create
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_OT_DSL_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|origin_head
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* move snapshots to this dir */
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
operator|&
name|pa
operator|->
name|shared_snaps
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
comment|/* unregister props as dsl_dir is changing */
if|if
condition|(
name|ds
operator|->
name|ds_objset
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* move snap name entry */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_snap_remove
argument_list|(
name|origin_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* change containing dsl_dir */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
operator|==
argument_list|,
name|odd
operator|->
name|dd_object
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|==
argument_list|,
name|odd
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move any clone references */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|&&
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|cnds
decl_stmt|;
name|uint64_t
name|o
decl_stmt|;
if|if
condition|(
name|za
operator|.
name|za_first_integer
operator|==
name|oldnext_obj
condition|)
block|{
comment|/* 					 * We've already moved the 					 * origin's reference. 					 */
continue|continue;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|cnds
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|cnds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
expr_stmt|;
name|VERIFY3U
argument_list|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|odd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|o
argument_list|,
name|tx
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|o
argument_list|,
name|tx
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|cnds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
name|ASSERT0
argument_list|(
name|dsl_prop_numcb
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Change space accounting. 	 * Note, pa->*usedsnap and dd_used_breakdown[SNAP] will either 	 * both be valid, or both be 0 (resulting in delta == 0).  This 	 * is true for each of {clone,origin} independently. 	 */
name|delta
operator|=
name|pa
operator|->
name|cloneusedsnap
operator|-
name|dd
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|delta
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|pa
operator|->
name|used
argument_list|,
operator|>=
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dd
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dd
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|pa
operator|->
name|used
operator|-
name|delta
argument_list|,
name|pa
operator|->
name|comp
argument_list|,
name|pa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|delta
operator|=
name|pa
operator|->
name|originusedsnap
operator|-
name|odd
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|delta
argument_list|,
operator|<=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|pa
operator|->
name|used
argument_list|,
operator|>=
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|odd
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|odd
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|pa
operator|->
name|used
operator|-
name|delta
argument_list|,
operator|-
name|pa
operator|->
name|comp
argument_list|,
operator|-
name|pa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
name|pa
operator|->
name|unique
expr_stmt|;
comment|/* log history record */
name|spa_history_log_internal_ds
argument_list|(
name|hds
argument_list|,
literal|"promote"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dsl_dir_close
argument_list|(
name|odd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
modifier|*
name|snaplist_tag
init|=
literal|"snaplist"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Make a list of dsl_dataset_t's for the snapshots between first_obj  * (exclusive) and last_obj (inclusive).  The list will be in reverse  * order (last_obj will be the list_head()).  If first_obj == 0, do all  * snapshots back to this dataset's origin.  */
end_comment

begin_function
specifier|static
name|int
name|snaplist_make
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|boolean_t
name|own
parameter_list|,
name|uint64_t
name|first_obj
parameter_list|,
name|uint64_t
name|last_obj
parameter_list|,
name|list_t
modifier|*
name|l
parameter_list|)
block|{
name|uint64_t
name|obj
init|=
name|last_obj
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|promotenode
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|promotenode
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|obj
operator|!=
name|first_obj
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|own
condition|)
block|{
name|err
operator|=
name|dsl_dataset_own_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|snaplist_tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|snaplist_tag
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|snaplist_tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
block|{
comment|/* lost race with snapshot destroy */
name|struct
name|promotenode
modifier|*
name|last
init|=
name|list_tail
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|last
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|obj
operator|=
name|last
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|err
condition|)
block|{
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|first_obj
operator|==
literal|0
condition|)
name|first_obj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
expr_stmt|;
name|snap
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|promotenode
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|snap
operator|->
name|ds
operator|=
name|ds
expr_stmt|;
name|list_insert_tail
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snaplist_space
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
block|{
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
operator|*
name|spacep
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
name|l
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|snap
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mintxg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
operator|*
name|spacep
operator|+=
name|used
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|snaplist_destroy
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|boolean_t
name|own
parameter_list|)
block|{
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
if|if
condition|(
operator|!
name|l
operator|||
operator|!
name|list_link_active
argument_list|(
operator|&
name|l
operator|->
name|list_head
argument_list|)
condition|)
return|return;
while|while
condition|(
operator|(
name|snap
operator|=
name|list_tail
argument_list|(
name|l
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
expr_stmt|;
if|if
condition|(
name|own
condition|)
name|dsl_dataset_disown
argument_list|(
name|snap
operator|->
name|ds
argument_list|,
name|snaplist_tag
argument_list|)
expr_stmt|;
else|else
name|dsl_dataset_rele
argument_list|(
name|snap
operator|->
name|ds
argument_list|,
name|snaplist_tag
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|snap
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|promotenode
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Promote a clone.  Nomenclature note:  * "clone" or "cds": the original clone which is being promoted  * "origin" or "ods": the snapshot which is originally clone's origin  * "origin head" or "ohds": the dataset which is the head  * (filesystem/volume) for the origin  * "origin origin": the origin of the origin's filesystem (typically  * NULL, indicating that the clone is not a clone of a clone).  */
end_comment

begin_function
name|int
name|dsl_dataset_promote
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|conflsnap
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|struct
name|promotearg
name|pa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|dd
operator|=
name|ds
operator|->
name|ds_dir
expr_stmt|;
name|dp
operator|=
name|dd
operator|->
name|dd_pool
expr_stmt|;
name|err
operator|=
name|dmu_object_info
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
operator|||
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * We are going to inherit all the snapshots taken before our 	 * origin (i.e., our new origin will be our parent's origin). 	 * Take ownership of them so that we can rename them into our 	 * namespace. 	 */
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|err
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
name|B_TRUE
argument_list|,
literal|0
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
operator|&
name|pa
operator|.
name|shared_snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
name|B_FALSE
argument_list|,
literal|0
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
operator|&
name|pa
operator|.
name|clone_snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|pa
operator|.
name|shared_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|)
expr_stmt|;
name|err
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
name|B_FALSE
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
operator|&
name|pa
operator|.
name|origin_snaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|pa
operator|.
name|origin_origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
comment|/* 	 * Add in 128x the snapnames zapobj size, since we will be moving 	 * a bunch of snapnames to the promoted ds, and dirtying their 	 * bonus buffers. 	 */
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_promote_check
argument_list|,
name|dsl_dataset_promote_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|pa
argument_list|,
literal|2
operator|+
literal|2
operator|*
name|doi
operator|.
name|doi_physical_blocks_512
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|&&
name|pa
operator|.
name|err_ds
operator|&&
name|conflsnap
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|conflsnap
argument_list|,
name|pa
operator|.
name|err_ds
argument_list|,
name|MAXNAMELEN
argument_list|)
expr_stmt|;
block|}
name|snaplist_destroy
argument_list|(
operator|&
name|pa
operator|.
name|shared_snaps
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|snaplist_destroy
argument_list|(
operator|&
name|pa
operator|.
name|clone_snaps
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|snaplist_destroy
argument_list|(
operator|&
name|pa
operator|.
name|origin_snaps
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|pa
operator|.
name|origin_origin
condition|)
name|dsl_dataset_rele
argument_list|(
name|pa
operator|.
name|origin_origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|cloneswaparg
block|{
name|dsl_dataset_t
modifier|*
name|cds
decl_stmt|;
comment|/* clone dataset */
name|dsl_dataset_t
modifier|*
name|ohds
decl_stmt|;
comment|/* origin's head dataset */
name|boolean_t
name|force
decl_stmt|;
name|int64_t
name|unused_refres_delta
decl_stmt|;
comment|/* change in unconsumed refreservation */
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_clone_swap_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|cloneswaparg
modifier|*
name|csa
init|=
name|arg1
decl_stmt|;
comment|/* they should both be heads */
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|csa
operator|->
name|cds
argument_list|)
operator|||
name|dsl_dataset_is_snapshot
argument_list|(
name|csa
operator|->
name|ohds
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* the branch point should be just before them */
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|!=
name|csa
operator|->
name|ohds
operator|->
name|ds_prev
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* cds should be the clone (unless they are unrelated) */
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|!=
name|csa
operator|->
name|cds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_origin_snap
operator|&&
name|csa
operator|->
name|ohds
operator|->
name|ds_object
operator|!=
name|csa
operator|->
name|cds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* the clone should be a child of the origin */
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_dir
operator|->
name|dd_parent
operator|!=
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* ohds shouldn't be modified unless 'force' */
if|if
condition|(
operator|!
name|csa
operator|->
name|force
operator|&&
name|dsl_dataset_modified_since_lastsnap
argument_list|(
name|csa
operator|->
name|ohds
argument_list|)
condition|)
return|return
operator|(
name|ETXTBSY
operator|)
return|;
comment|/* adjust amount of any unconsumed refreservation */
name|csa
operator|->
name|unused_refres_delta
operator|=
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_reserved
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
operator|-
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_reserved
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa
operator|->
name|unused_refres_delta
operator|>
literal|0
operator|&&
name|csa
operator|->
name|unused_refres_delta
operator|>
name|dsl_dir_space_available
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|csa
operator|->
name|ohds
operator|->
name|ds_quota
operator|!=
literal|0
operator|&&
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|>
name|csa
operator|->
name|ohds
operator|->
name|ds_quota
condition|)
return|return
operator|(
name|EDQUOT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_clone_swap_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|cloneswaparg
modifier|*
name|csa
init|=
name|arg1
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|csa
operator|->
name|cds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_reserved
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_quota
operator|==
literal|0
operator|||
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|<=
name|csa
operator|->
name|ohds
operator|->
name|ds_quota
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_objset
operator|!=
name|NULL
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|csa
operator|->
name|cds
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|csa
operator|->
name|ohds
operator|->
name|ds_objset
operator|!=
name|NULL
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|csa
operator|->
name|ohds
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Reset origin's unique bytes, if it exists. 	 */
if|if
condition|(
name|csa
operator|->
name|cds
operator|->
name|ds_prev
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|origin
init|=
name|csa
operator|->
name|cds
operator|->
name|ds_prev
decl_stmt|;
name|uint64_t
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
name|origin
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|origin
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
block|}
comment|/* swap blkptrs */
block|{
name|blkptr_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* set dd_*_bytes */
block|{
name|int64_t
name|dused
decl_stmt|,
name|dcomp
decl_stmt|,
name|duncomp
decl_stmt|;
name|uint64_t
name|cdl_used
decl_stmt|,
name|cdl_comp
decl_stmt|,
name|cdl_uncomp
decl_stmt|;
name|uint64_t
name|odl_used
decl_stmt|,
name|odl_comp
decl_stmt|,
name|odl_uncomp
decl_stmt|;
name|ASSERT3U
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_deadlist_space
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|cdl_used
argument_list|,
operator|&
name|cdl_comp
argument_list|,
operator|&
name|cdl_uncomp
argument_list|)
expr_stmt|;
name|dsl_deadlist_space
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|odl_used
argument_list|,
operator|&
name|odl_comp
argument_list|,
operator|&
name|odl_uncomp
argument_list|)
expr_stmt|;
name|dused
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+
name|cdl_used
operator|-
operator|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+
name|odl_used
operator|)
expr_stmt|;
name|dcomp
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+
name|cdl_comp
operator|-
operator|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+
name|odl_comp
operator|)
expr_stmt|;
name|duncomp
operator|=
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+
name|cdl_uncomp
operator|-
operator|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+
name|odl_uncomp
operator|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|dused
argument_list|,
name|dcomp
argument_list|,
name|duncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|csa
operator|->
name|cds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|dused
argument_list|,
operator|-
name|dcomp
argument_list|,
operator|-
name|duncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * The difference in the space used by snapshots is the 		 * difference in snapshot space due to the head's 		 * deadlist (since that's the only thing that's 		 * changing that affects the snapused). 		 */
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|cdl_used
argument_list|,
operator|&
name|cdl_comp
argument_list|,
operator|&
name|cdl_uncomp
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|odl_used
argument_list|,
operator|&
name|odl_comp
argument_list|,
operator|&
name|odl_uncomp
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|cdl_used
operator|-
name|odl_used
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* swap ds_*_bytes */
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
comment|/* apply any parent delta for change in unconsumed refreservation */
name|dsl_dir_diduse_space
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|csa
operator|->
name|unused_refres_delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Swap deadlists. 	 */
name|dsl_deadlist_close
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|csa
operator|->
name|cds
operator|->
name|ds_deadlist
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|csa
operator|->
name|cds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|csa
operator|->
name|ohds
operator|->
name|ds_deadlist
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_scan_ds_clone_swapped
argument_list|(
name|csa
operator|->
name|ohds
argument_list|,
name|csa
operator|->
name|cds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|csa
operator|->
name|cds
argument_list|,
literal|"clone swap"
argument_list|,
name|tx
argument_list|,
literal|"parent=%s"
argument_list|,
name|csa
operator|->
name|ohds
operator|->
name|ds_dir
operator|->
name|dd_myname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Swap 'clone' with its origin head datasets.  Used at the end of "zfs  * recv" into an existing fs to swizzle the file system to the new  * version, and by "zfs rollback".  Can also be used to swap two  * independent head datasets if neither has any snapshots.  */
end_comment

begin_function
name|int
name|dsl_dataset_clone_swap
parameter_list|(
name|dsl_dataset_t
modifier|*
name|clone
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin_head
parameter_list|,
name|boolean_t
name|force
parameter_list|)
block|{
name|struct
name|cloneswaparg
name|csa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|clone
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|origin_head
operator|->
name|ds_owner
argument_list|)
expr_stmt|;
name|retry
label|:
comment|/* 	 * Need exclusive access for the swap. If we're swapping these 	 * datasets back after an error, we already hold the locks. 	 */
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|clone
operator|->
name|ds_rwlock
argument_list|)
condition|)
name|rw_enter
argument_list|(
operator|&
name|clone
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|RW_WRITE_HELD
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_rwlock
argument_list|)
operator|&&
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|clone
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|clone
operator|->
name|ds_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_rwlock
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
block|}
name|csa
operator|.
name|cds
operator|=
name|clone
expr_stmt|;
name|csa
operator|.
name|ohds
operator|=
name|origin_head
expr_stmt|;
name|csa
operator|.
name|force
operator|=
name|force
expr_stmt|;
name|error
operator|=
name|dsl_sync_task_do
argument_list|(
name|clone
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_clone_swap_check
argument_list|,
name|dsl_dataset_clone_swap_sync
argument_list|,
operator|&
name|csa
argument_list|,
name|NULL
argument_list|,
literal|9
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a pool name and a dataset object number in that pool,  * return the name of that dataset.  */
end_comment

begin_function
name|int
name|dsl_dsobj_to_dsname
parameter_list|(
name|char
modifier|*
name|pname
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_open
argument_list|(
name|pname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_check_quota
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|boolean_t
name|check_quota
parameter_list|,
name|uint64_t
name|asize
parameter_list|,
name|uint64_t
name|inflight
parameter_list|,
name|uint64_t
modifier|*
name|used
parameter_list|,
name|uint64_t
modifier|*
name|ref_rsrv
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT3S
argument_list|(
name|asize
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * *ref_rsrv is the portion of asize that will come from any 	 * unconsumed refreservation space. 	 */
operator|*
name|ref_rsrv
operator|=
literal|0
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Make a space adjustment for reserved bytes. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
condition|)
block|{
name|ASSERT3U
argument_list|(
operator|*
name|used
argument_list|,
operator|>=
argument_list|,
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
operator|*
name|used
operator|-=
operator|(
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|)
expr_stmt|;
operator|*
name|ref_rsrv
operator|=
name|asize
operator|-
name|MIN
argument_list|(
name|asize
argument_list|,
name|parent_delta
argument_list|(
name|ds
argument_list|,
name|asize
operator|+
name|inflight
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_quota
operator|||
name|ds
operator|->
name|ds_quota
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If they are requesting more space, and our current estimate 	 * is over quota, they get to try again unless the actual 	 * on-disk is over quota and there are no pending changes (which 	 * may free up space for us). 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+
name|inflight
operator|>=
name|ds
operator|->
name|ds_quota
condition|)
block|{
if|if
condition|(
name|inflight
operator|>
literal|0
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|<
name|ds
operator|->
name|ds_quota
condition|)
name|error
operator|=
name|ERESTART
expr_stmt|;
else|else
name|error
operator|=
name|EDQUOT
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_set_quota_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|dsl_prop_setarg_t
modifier|*
name|psa
init|=
name|arg2
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_REFQUOTA
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|dsl_prop_predict_sync
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|psa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|psa
operator|->
name|psa_effective_value
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|psa
operator|->
name|psa_effective_value
operator|<
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|||
name|psa
operator|->
name|psa_effective_value
operator|<
name|ds
operator|->
name|ds_reserved
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|extern
name|void
name|dsl_prop_set_sync
parameter_list|(
name|void
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|dsl_dataset_set_quota_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|dsl_prop_setarg_t
modifier|*
name|psa
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|effective_value
init|=
name|psa
operator|->
name|psa_effective_value
decl_stmt|;
name|dsl_prop_set_sync
argument_list|(
name|ds
argument_list|,
name|psa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|DSL_PROP_CHECK_PREDICTION
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|psa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_quota
operator|!=
name|effective_value
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_quota
operator|=
name|effective_value
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|dsl_dataset_set_quota
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|uint64_t
name|quota
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_prop_setarg_t
name|psa
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_prop_setarg_init_uint64
argument_list|(
operator|&
name|psa
argument_list|,
literal|"refquota"
argument_list|,
name|source
argument_list|,
operator|&
name|quota
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * If someone removes a file, then tries to set the quota, we 	 * want to make sure the file freeing takes effect. 	 */
name|txg_wait_open
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_set_quota_check
argument_list|,
name|dsl_dataset_set_quota_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|psa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_set_reservation_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|dsl_prop_setarg_t
modifier|*
name|psa
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|effective_value
decl_stmt|;
name|uint64_t
name|unique
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_REFRESERVATION
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
operator|(
name|err
operator|=
name|dsl_prop_predict_sync
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|psa
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|effective_value
operator|=
name|psa
operator|->
name|psa_effective_value
expr_stmt|;
comment|/* 	 * If we are doing the preliminary check in open context, the 	 * space estimates may be inaccurate. 	 */
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
condition|)
name|dsl_dataset_recalc_head_uniq
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|unique
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX
argument_list|(
name|unique
argument_list|,
name|effective_value
argument_list|)
operator|>
name|MAX
argument_list|(
name|unique
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
condition|)
block|{
name|uint64_t
name|delta
init|=
name|MAX
argument_list|(
name|unique
argument_list|,
name|effective_value
argument_list|)
operator|-
name|MAX
argument_list|(
name|unique
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|>
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_quota
operator|>
literal|0
operator|&&
name|effective_value
operator|>
name|ds
operator|->
name|ds_quota
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_set_reservation_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|dsl_prop_setarg_t
modifier|*
name|psa
init|=
name|arg2
decl_stmt|;
name|uint64_t
name|effective_value
init|=
name|psa
operator|->
name|psa_effective_value
decl_stmt|;
name|uint64_t
name|unique
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|dsl_prop_set_sync
argument_list|(
name|ds
argument_list|,
name|psa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|DSL_PROP_CHECK_PREDICTION
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|psa
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|unique
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
name|delta
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|effective_value
operator|-
name|unique
argument_list|)
argument_list|)
operator|-
name|MAX
argument_list|(
literal|0
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|ds
operator|->
name|ds_reserved
operator|-
name|unique
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_reserved
operator|=
name|effective_value
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_set_reservation
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|uint64_t
name|reservation
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_prop_setarg_t
name|psa
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_prop_setarg_init_uint64
argument_list|(
operator|&
name|psa
argument_list|,
literal|"refreservation"
argument_list|,
name|source
argument_list|,
operator|&
name|reservation
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_set_reservation_check
argument_list|,
name|dsl_dataset_set_reservation_sync
argument_list|,
name|ds
argument_list|,
operator|&
name|psa
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zfs_hold_cleanup_arg
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|char
name|htag
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
block|}
name|zfs_hold_cleanup_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|dsl_dataset_user_release_onexit
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|zfs_hold_cleanup_arg_t
modifier|*
name|ca
init|=
name|arg
decl_stmt|;
operator|(
name|void
operator|)
name|dsl_dataset_user_release_tmp
argument_list|(
name|ca
operator|->
name|dp
argument_list|,
name|ca
operator|->
name|dsobj
argument_list|,
name|ca
operator|->
name|htag
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ca
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_hold_cleanup_arg_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_register_onexit_hold_cleanup
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|htag
parameter_list|,
name|minor_t
name|minor
parameter_list|)
block|{
name|zfs_hold_cleanup_arg_t
modifier|*
name|ca
decl_stmt|;
name|ca
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_hold_cleanup_arg_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ca
operator|->
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
name|ca
operator|->
name|dsobj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ca
operator|->
name|htag
argument_list|,
name|htag
argument_list|,
sizeof|sizeof
argument_list|(
name|ca
operator|->
name|htag
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zfs_onexit_add_cb
argument_list|(
name|minor
argument_list|,
name|dsl_dataset_user_release_onexit
argument_list|,
name|ca
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If you add new checks here, you may need to add  * additional checks to the "temporary" case in  * snapshot_check() in dmu_objset.c.  */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_user_hold_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|struct
name|dsl_ds_holdarg
modifier|*
name|ha
init|=
name|arg2
decl_stmt|;
specifier|const
name|char
modifier|*
name|htag
init|=
name|ha
operator|->
name|htag
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_USERREFS
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
comment|/* tags must be unique */
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
condition|)
block|{
name|error
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
argument_list|,
name|htag
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|ha
operator|->
name|temphold
operator|&&
name|strlen
argument_list|(
name|htag
argument_list|)
operator|+
name|MAX_TAG_PREFIX_LEN
operator|>=
name|MAXNAMELEN
condition|)
name|error
operator|=
name|E2BIG
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_user_hold_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|arg1
decl_stmt|;
name|struct
name|dsl_ds_holdarg
modifier|*
name|ha
init|=
name|arg2
decl_stmt|;
specifier|const
name|char
modifier|*
name|htag
init|=
name|ha
operator|->
name|htag
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|now
init|=
name|gethrestime_sec
argument_list|()
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
operator|==
literal|0
condition|)
block|{
comment|/* 		 * This is the first user hold for this dataset.  Create 		 * the userrefs zap object. 		 */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_USERREFS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zapobj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
expr_stmt|;
block|}
name|ds
operator|->
name|ds_userrefs
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|htag
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|now
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ha
operator|->
name|temphold
condition|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_pool_user_hold
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|htag
argument_list|,
operator|&
name|now
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"hold"
argument_list|,
name|tx
argument_list|,
literal|"tag = %s temp = %d holds now = %llu"
argument_list|,
name|htag
argument_list|,
operator|(
name|int
operator|)
name|ha
operator|->
name|temphold
argument_list|,
name|ds
operator|->
name|ds_userrefs
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_user_hold_one
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dsl_ds_holdarg
modifier|*
name|ha
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
comment|/* alloc a buffer to hold dsname@snapname plus terminating NULL */
name|name
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s@%s"
argument_list|,
name|dsname
argument_list|,
name|ha
operator|->
name|snapname
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|name
argument_list|,
name|ha
operator|->
name|dstg
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|ha
operator|->
name|gotone
operator|=
name|B_TRUE
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|ha
operator|->
name|dstg
argument_list|,
name|dsl_dataset_user_hold_check
argument_list|,
name|dsl_dataset_user_hold_sync
argument_list|,
name|ds
argument_list|,
name|ha
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|&&
name|ha
operator|->
name|recursive
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ha
operator|->
name|failed
argument_list|,
name|dsname
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_user_hold_for_send
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|htag
parameter_list|,
name|boolean_t
name|temphold
parameter_list|)
block|{
name|struct
name|dsl_ds_holdarg
modifier|*
name|ha
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ha
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ha
operator|->
name|htag
operator|=
name|htag
expr_stmt|;
name|ha
operator|->
name|temphold
operator|=
name|temphold
expr_stmt|;
name|error
operator|=
name|dsl_sync_task_do
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|dsl_dataset_user_hold_check
argument_list|,
name|dsl_dataset_user_hold_sync
argument_list|,
name|ds
argument_list|,
name|ha
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_user_hold
parameter_list|(
name|char
modifier|*
name|dsname
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|,
name|char
modifier|*
name|htag
parameter_list|,
name|boolean_t
name|recursive
parameter_list|,
name|boolean_t
name|temphold
parameter_list|,
name|int
name|cleanup_fd
parameter_list|)
block|{
name|struct
name|dsl_ds_holdarg
modifier|*
name|ha
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|minor_t
name|minor
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|cleanup_fd
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* Currently we only support cleanup-on-exit of tempholds. */
if|if
condition|(
operator|!
name|temphold
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|error
operator|=
name|zfs_onexit_fd_hold
argument_list|(
name|cleanup_fd
argument_list|,
operator|&
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ha
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ha
operator|->
name|failed
argument_list|,
name|dsname
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|dsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_fd
operator|!=
operator|-
literal|1
condition|)
name|zfs_onexit_fd_rele
argument_list|(
name|cleanup_fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ha
operator|->
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ha
operator|->
name|htag
operator|=
name|htag
expr_stmt|;
name|ha
operator|->
name|snapname
operator|=
name|snapname
expr_stmt|;
name|ha
operator|->
name|recursive
operator|=
name|recursive
expr_stmt|;
name|ha
operator|->
name|temphold
operator|=
name|temphold
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
block|{
name|error
operator|=
name|dmu_objset_find
argument_list|(
name|dsname
argument_list|,
name|dsl_dataset_user_hold_one
argument_list|,
name|ha
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dsl_dataset_user_hold_one
argument_list|(
name|dsname
argument_list|,
name|ha
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|ha
operator|->
name|dstg
argument_list|)
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|ha
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|ha
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
block|{
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|ha
operator|->
name|failed
argument_list|)
expr_stmt|;
operator|*
name|strchr
argument_list|(
name|ha
operator|->
name|failed
argument_list|,
literal|'@'
argument_list|)
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|minor
operator|!=
literal|0
operator|&&
name|temphold
condition|)
block|{
comment|/* 			 * If this hold is to be released upon process exit, 			 * register that action now. 			 */
name|dsl_register_onexit_hold_cleanup
argument_list|(
name|ds
argument_list|,
name|htag
argument_list|,
name|minor
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|ha
operator|->
name|dstg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|recursive
operator|&&
operator|!
name|ha
operator|->
name|gotone
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|error
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|ha
operator|->
name|failed
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|ha
operator|->
name|dstg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|cleanup_fd
operator|!=
operator|-
literal|1
condition|)
name|zfs_onexit_fd_rele
argument_list|(
name|cleanup_fd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|dsl_ds_releasearg
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
specifier|const
name|char
modifier|*
name|htag
decl_stmt|;
name|boolean_t
name|own
decl_stmt|;
comment|/* do we own or just hold ds? */
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|dsl_dataset_release_might_destroy
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|htag
parameter_list|,
name|boolean_t
modifier|*
name|might_destroy
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|uint64_t
name|tmp
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|might_destroy
operator|=
name|B_FALSE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
expr_stmt|;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
block|{
comment|/* The tag can't possibly exist */
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
comment|/* Make sure the tag exists */
name|error
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|htag
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
name|ESRCH
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|ds
operator|->
name|ds_userrefs
operator|==
literal|1
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|==
literal|1
operator|&&
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds
argument_list|)
condition|)
operator|*
name|might_destroy
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_user_release_check
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|dsl_ds_releasearg
modifier|*
name|ra
init|=
name|arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|ra
operator|->
name|ds
decl_stmt|;
name|boolean_t
name|might_destroy
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_USERREFS
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|error
operator|=
name|dsl_dataset_release_might_destroy
argument_list|(
name|ds
argument_list|,
name|ra
operator|->
name|htag
argument_list|,
operator|&
name|might_destroy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|might_destroy
condition|)
block|{
name|struct
name|dsl_ds_destroyarg
name|dsda
init|=
block|{
literal|0
block|}
decl_stmt|;
if|if
condition|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
block|{
comment|/* 			 * If we're not prepared to remove the snapshot, 			 * we can't allow the release to happen right now. 			 */
if|if
condition|(
operator|!
name|ra
operator|->
name|own
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
name|dsda
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|dsda
operator|.
name|releasing
operator|=
name|B_TRUE
expr_stmt|;
return|return
operator|(
name|dsl_dataset_destroy_check
argument_list|(
operator|&
name|dsda
argument_list|,
name|tag
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_user_release_sync
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|dsl_ds_releasearg
modifier|*
name|ra
init|=
name|arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|ra
operator|->
name|ds
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
decl_stmt|;
name|uint64_t
name|refs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_userrefs
operator|--
expr_stmt|;
name|refs
operator|=
name|ds
operator|->
name|ds_userrefs
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_pool_user_release
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|ra
operator|->
name|htag
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|ra
operator|->
name|htag
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"release"
argument_list|,
name|tx
argument_list|,
literal|"tag = %s refs now = %lld"
argument_list|,
name|ra
operator|->
name|htag
argument_list|,
operator|(
name|longlong_t
operator|)
name|refs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_userrefs
operator|==
literal|0
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|==
literal|1
operator|&&
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|struct
name|dsl_ds_destroyarg
name|dsda
init|=
block|{
literal|0
block|}
decl_stmt|;
name|ASSERT
argument_list|(
name|ra
operator|->
name|own
argument_list|)
expr_stmt|;
name|dsda
operator|.
name|ds
operator|=
name|ds
expr_stmt|;
name|dsda
operator|.
name|releasing
operator|=
name|B_TRUE
expr_stmt|;
comment|/* We already did the destroy_check */
name|dsl_dataset_destroy_sync
argument_list|(
operator|&
name|dsda
argument_list|,
name|tag
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_user_release_one
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|dsl_ds_holdarg
modifier|*
name|ha
init|=
name|arg
decl_stmt|;
name|struct
name|dsl_ds_releasearg
modifier|*
name|ra
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|void
modifier|*
name|dtag
init|=
name|ha
operator|->
name|dstg
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|boolean_t
name|own
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|might_destroy
decl_stmt|;
comment|/* alloc a buffer to hold dsname@snapname, plus the terminating NULL */
name|name
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s@%s"
argument_list|,
name|dsname
argument_list|,
name|ha
operator|->
name|snapname
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|name
argument_list|,
name|dtag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
operator|&&
name|ha
operator|->
name|recursive
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ha
operator|->
name|failed
argument_list|,
name|dsname
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ha
operator|->
name|gotone
operator|=
name|B_TRUE
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_release_might_destroy
argument_list|(
name|ds
argument_list|,
name|ha
operator|->
name|htag
argument_list|,
operator|&
name|might_destroy
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|dtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|might_destroy
condition|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|name
operator|=
name|kmem_asprintf
argument_list|(
literal|"%s@%s"
argument_list|,
name|dsname
argument_list|,
name|ha
operator|->
name|snapname
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_unmount_snap
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|dtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|dsl_dataset_tryown
argument_list|(
name|ds
argument_list|,
name|B_TRUE
argument_list|,
name|dtag
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|dtag
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
else|else
block|{
name|own
operator|=
name|B_TRUE
expr_stmt|;
name|dsl_dataset_make_exclusive
argument_list|(
name|ds
argument_list|,
name|dtag
argument_list|)
expr_stmt|;
block|}
block|}
name|ra
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_releasearg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ra
operator|->
name|ds
operator|=
name|ds
expr_stmt|;
name|ra
operator|->
name|htag
operator|=
name|ha
operator|->
name|htag
expr_stmt|;
name|ra
operator|->
name|own
operator|=
name|own
expr_stmt|;
name|dsl_sync_task_create
argument_list|(
name|ha
operator|->
name|dstg
argument_list|,
name|dsl_dataset_user_release_check
argument_list|,
name|dsl_dataset_user_release_sync
argument_list|,
name|ra
argument_list|,
name|dtag
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_user_release
parameter_list|(
name|char
modifier|*
name|dsname
parameter_list|,
name|char
modifier|*
name|snapname
parameter_list|,
name|char
modifier|*
name|htag
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|struct
name|dsl_ds_holdarg
modifier|*
name|ha
decl_stmt|;
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|top
label|:
name|ha
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ha
operator|->
name|failed
argument_list|,
name|dsname
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|dsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ha
operator|->
name|dstg
operator|=
name|dsl_sync_task_group_create
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ha
operator|->
name|htag
operator|=
name|htag
expr_stmt|;
name|ha
operator|->
name|snapname
operator|=
name|snapname
expr_stmt|;
name|ha
operator|->
name|recursive
operator|=
name|recursive
expr_stmt|;
if|if
condition|(
name|recursive
condition|)
block|{
name|error
operator|=
name|dmu_objset_find
argument_list|(
name|dsname
argument_list|,
name|dsl_dataset_user_release_one
argument_list|,
name|ha
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dsl_dataset_user_release_one
argument_list|(
name|dsname
argument_list|,
name|ha
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dsl_sync_task_group_wait
argument_list|(
name|ha
operator|->
name|dstg
argument_list|)
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|list_head
argument_list|(
operator|&
name|ha
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|)
init|;
name|dst
condition|;
name|dst
operator|=
name|list_next
argument_list|(
operator|&
name|ha
operator|->
name|dstg
operator|->
name|dstg_tasks
argument_list|,
name|dst
argument_list|)
control|)
block|{
name|struct
name|dsl_ds_releasearg
modifier|*
name|ra
init|=
name|dst
operator|->
name|dst_arg1
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|ra
operator|->
name|ds
decl_stmt|;
if|if
condition|(
name|dst
operator|->
name|dst_err
condition|)
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|ha
operator|->
name|failed
argument_list|)
expr_stmt|;
if|if
condition|(
name|ra
operator|->
name|own
condition|)
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|ha
operator|->
name|dstg
argument_list|)
expr_stmt|;
else|else
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|ha
operator|->
name|dstg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ra
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_releasearg
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|recursive
operator|&&
operator|!
name|ha
operator|->
name|gotone
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|EBUSY
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|ha
operator|->
name|failed
argument_list|,
sizeof|sizeof
argument_list|(
name|ha
operator|->
name|failed
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_destroy
argument_list|(
name|ha
operator|->
name|dstg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ha
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|dsl_ds_holdarg
argument_list|)
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * We can get EBUSY if we were racing with deferred destroy and 	 * dsl_dataset_user_release_check() hadn't done the necessary 	 * open context setup.  We can also get EBUSY if we're racing 	 * with destroy and that thread is the ds_owner.  Either way 	 * the busy condition should be transient, and we should retry 	 * the release operation. 	 */
if|if
condition|(
name|error
operator|==
name|EBUSY
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called at spa_load time (with retry == B_FALSE) to release a stale  * temporary user hold. Also called by the onexit code (with retry == B_TRUE).  */
end_comment

begin_function
name|int
name|dsl_dataset_user_release_tmp
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|char
modifier|*
name|htag
parameter_list|,
name|boolean_t
name|retry
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|char
modifier|*
name|snap
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|int
name|error
decl_stmt|;
do|do
block|{
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|namelen
operator|=
name|dsl_dataset_namelen
argument_list|(
name|ds
argument_list|)
operator|+
literal|1
expr_stmt|;
name|name
operator|=
name|kmem_alloc
argument_list|(
name|namelen
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|snap
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|*
name|snap
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|snap
expr_stmt|;
name|error
operator|=
name|dsl_dataset_user_release
argument_list|(
name|name
argument_list|,
name|snap
argument_list|,
name|htag
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|name
argument_list|,
name|namelen
argument_list|)
expr_stmt|;
comment|/* 		 * The object can't have been destroyed because we have a hold, 		 * but it might have been renamed, resulting in ENOENT.  Retry 		 * if we've been requested to do so. 		 * 		 * It would be nice if we could use the dsobj all the way 		 * through and avoid ENOENT entirely.  But we might need to 		 * unmount the snapshot, and there's currently no way to lookup 		 * a vfsp using a ZFS object id. 		 */
block|}
do|while
condition|(
operator|(
name|error
operator|==
name|ENOENT
operator|)
operator|&&
name|retry
condition|)
do|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_get_holds
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold
argument_list|(
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
operator|!=
literal|0
condition|)
block|{
name|zap_attribute_t
modifier|*
name|za
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|za
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|VERIFY
argument_list|(
literal|0
operator|==
name|nvlist_add_uint64
argument_list|(
operator|*
name|nvp
argument_list|,
name|za
operator|->
name|za_name
argument_list|,
name|za
operator|->
name|za_first_integer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|za
argument_list|,
sizeof|sizeof
argument_list|(
name|zap_attribute_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note, this function is used as the callback for dmu_objset_find().  We  * always return 0 so that we will continue to find and process  * inconsistent datasets, even if we encounter an error trying to  * process one of them.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|dsl_destroy_inconsistent
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
name|dsl_dataset_own
argument_list|(
name|dsname
argument_list|,
name|B_TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|DS_IS_INCONSISTENT
argument_list|(
name|ds
argument_list|)
condition|)
operator|(
name|void
operator|)
name|dsl_dataset_destroy
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
else|else
name|dsl_dataset_disown
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return (in *usedp) the amount of space written in new that is not  * present in oldsnap.  New may be a snapshot or the head.  Old must be  * a snapshot before new, in new's filesystem (or its origin).  If not then  * fail and return EINVAL.  *  * The written space is calculated by considering two components:  First, we  * ignore any freed space, and calculate the written as new's used space  * minus old's used space.  Next, we add in the amount of space that was freed  * between the two snapshots, thus reducing new's used space relative to old's.  * Specifically, this is the space that was born before old->ds_creation_txg,  * and freed before new (ie. on new's deadlist or a previous deadlist).  *  * space freed                         [---------------------]  * snapshots                       ---O-------O--------O-------O------  *                                         oldsnap            new  */
end_comment

begin_function
name|int
name|dsl_dataset_space_written
parameter_list|(
name|dsl_dataset_t
modifier|*
name|oldsnap
parameter_list|,
name|dsl_dataset_t
modifier|*
name|new
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|,
name|uint64_t
modifier|*
name|compp
parameter_list|,
name|uint64_t
modifier|*
name|uncompp
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uint64_t
name|snapobj
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|new
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
operator|*
name|usedp
operator|=
literal|0
expr_stmt|;
operator|*
name|usedp
operator|+=
name|new
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
operator|*
name|usedp
operator|-=
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
operator|*
name|compp
operator|=
literal|0
expr_stmt|;
operator|*
name|compp
operator|+=
name|new
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
operator|*
name|compp
operator|-=
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
operator|*
name|uncompp
operator|=
literal|0
expr_stmt|;
operator|*
name|uncompp
operator|+=
name|new
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
operator|*
name|uncompp
operator|-=
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|snapobj
operator|=
name|new
operator|->
name|ds_object
expr_stmt|;
while|while
condition|(
name|snapobj
operator|!=
name|oldsnap
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|snap
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
if|if
condition|(
name|snapobj
operator|==
name|new
operator|->
name|ds_object
condition|)
block|{
name|snap
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|snapobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|snap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|snap
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|==
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
block|{
comment|/* 			 * The blocks in the deadlist can not be born after 			 * ds_prev_snap_txg, so get the whole deadlist space, 			 * which is more efficient (especially for old-format 			 * deadlists).  Unfortunately the deadlist code 			 * doesn't have enough information to make this 			 * optimization itself. 			 */
name|dsl_deadlist_space
argument_list|(
operator|&
name|snap
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|snap
operator|->
name|ds_deadlist
argument_list|,
literal|0
argument_list|,
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
block|}
operator|*
name|usedp
operator|+=
name|used
expr_stmt|;
operator|*
name|compp
operator|+=
name|comp
expr_stmt|;
operator|*
name|uncompp
operator|+=
name|uncomp
expr_stmt|;
comment|/* 		 * If we get to the beginning of the chain of snapshots 		 * (ds_prev_snap_obj == 0) before oldsnap, then oldsnap 		 * was not a snapshot of/before new. 		 */
name|snapobj
operator|=
name|snap
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
if|if
condition|(
name|snap
operator|!=
name|new
condition|)
name|dsl_dataset_rele
argument_list|(
name|snap
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapobj
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|EINVAL
expr_stmt|;
break|break;
block|}
block|}
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return (in *usedp) the amount of space that will be reclaimed if firstsnap,  * lastsnap, and all snapshots in between are deleted.  *  * blocks that would be freed            [---------------------------]  * snapshots                       ---O-------O--------O-------O--------O  *                                        firstsnap        lastsnap  *  * This is the set of blocks that were born after the snap before firstsnap,  * (birth> firstsnap->prev_snap_txg) and died before the snap after the  * last snap (ie, is on lastsnap->ds_next->ds_deadlist or an earlier deadlist).  * We calculate this by iterating over the relevant deadlists (from the snap  * after lastsnap, backward to the snap after firstsnap), summing up the  * space on the deadlist that was born after the snap before firstsnap.  */
end_comment

begin_function
name|int
name|dsl_dataset_space_wouldfree
parameter_list|(
name|dsl_dataset_t
modifier|*
name|firstsnap
parameter_list|,
name|dsl_dataset_t
modifier|*
name|lastsnap
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|,
name|uint64_t
modifier|*
name|compp
parameter_list|,
name|uint64_t
modifier|*
name|uncompp
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uint64_t
name|snapobj
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|firstsnap
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_is_snapshot
argument_list|(
name|firstsnap
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_is_snapshot
argument_list|(
name|lastsnap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the snapshots are in the same dsl_dir, and firstsnap 	 * is before lastsnap. 	 */
if|if
condition|(
name|firstsnap
operator|->
name|ds_dir
operator|!=
name|lastsnap
operator|->
name|ds_dir
operator|||
name|firstsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
operator|>
name|lastsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
operator|*
name|usedp
operator|=
operator|*
name|compp
operator|=
operator|*
name|uncompp
operator|=
literal|0
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|snapobj
operator|=
name|lastsnap
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
while|while
condition|(
name|snapobj
operator|!=
name|firstsnap
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|snapobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|firstsnap
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
operator|*
name|usedp
operator|+=
name|used
expr_stmt|;
operator|*
name|compp
operator|+=
name|comp
expr_stmt|;
operator|*
name|uncompp
operator|+=
name|uncomp
expr_stmt|;
name|snapobj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snapobj
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

