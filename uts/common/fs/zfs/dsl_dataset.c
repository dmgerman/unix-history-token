begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013 by Delphix. All rights reserved.  * Copyright (c) 2014, Joyent, Inc. All rights reserved.  * Copyright (c) 2014 RackTop Systems.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_onexit.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deadlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_destroy.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_userhold.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_bookmark.h>
end_include

begin_define
define|#
directive|define
name|SWITCH64
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
define|\
value|{ \ 		uint64_t __tmp = (x); \ 		(x) = (y); \ 		(y) = __tmp; \ 	}
end_define

begin_define
define|#
directive|define
name|DS_REF_MAX
value|(1ULL<< 62)
end_define

begin_define
define|#
directive|define
name|DSL_DEADLIST_BLOCKSIZE
value|SPA_MAXBLOCKSIZE
end_define

begin_comment
comment|/*  * Figure out how much of this delta should be propogated to the dsl_dir  * layer.  If there's a refreservation, that space has already been  * partially accounted for in our ancestors.  */
end_comment

begin_function
specifier|static
name|int64_t
name|parent_delta
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|int64_t
name|delta
parameter_list|)
block|{
name|uint64_t
name|old_bytes
decl_stmt|,
name|new_bytes
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|==
literal|0
condition|)
return|return
operator|(
name|delta
operator|)
return|;
name|old_bytes
operator|=
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|new_bytes
operator|=
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+
name|delta
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ABS
argument_list|(
call|(
name|int64_t
call|)
argument_list|(
name|new_bytes
operator|-
name|old_bytes
argument_list|)
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|ABS
argument_list|(
name|delta
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_bytes
operator|-
name|old_bytes
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_block_born
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|used
init|=
name|bp_get_dsize_sync
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"ds=%p"
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* It could have been compressed away to nothing */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|!=
name|DMU_OT_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DMU_OT_IS_VALID
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_pool_mos_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
name|used
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
return|return;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|delta
operator|=
name|parent_delta
argument_list|(
name|ds
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+=
name|used
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+=
name|compressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+=
name|uncompressed
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|delta
argument_list|,
name|compressed
argument_list|,
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
operator|-
name|delta
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_block_kill
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|async
parameter_list|)
block|{
name|int
name|used
init|=
name|bp_get_dsize_sync
argument_list|(
name|tx
operator|->
name|tx_pool
operator|->
name|dp_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|int
name|compressed
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|uncompressed
init|=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|<=
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_free
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|dsl_pool_mos_diduse_space
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
operator|-
name|used
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|)
expr_stmt|;
return|return
operator|(
name|used
operator|)
return|;
block|}
name|ASSERT3P
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|int64_t
name|delta
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"freeing ds=%llu"
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_free
argument_list|(
name|tx
operator|->
name|tx_pool
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|>=
name|used
operator|||
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|parent_delta
argument_list|(
name|ds
argument_list|,
operator|-
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|-=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|delta
argument_list|,
operator|-
name|compressed
argument_list|,
operator|-
name|uncompressed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|-
name|used
operator|-
name|delta
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"putting on dead list: %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|async
condition|)
block|{
comment|/* 			 * We are here as part of zio's write done callback, 			 * which means we're a zio interrupt thread.  We can't 			 * call dsl_deadlist_insert() now because it may block 			 * waiting for I/O.  Instead, put bp on the deferred 			 * queue and let dsl_pool_sync() finish the job. 			 */
name|bplist_append
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_deadlist_insert
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* if (bp->blk_birth> prev prev snap txg) prev unique += bs */
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|&&
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|+=
name|used
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|ds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
condition|)
block|{
name|dsl_dir_transfer_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|used
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
argument_list|,
operator|>=
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|-=
name|used
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
operator|>=
argument_list|,
name|compressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|-=
name|compressed
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
operator|>=
argument_list|,
name|uncompressed
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|-=
name|uncompressed
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|used
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_prev_snap_txg
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|uint64_t
name|trysnap
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * The snapshot creation could fail, but that would cause an 	 * incorrect FALSE return, which would only result in an 	 * overestimation of the amount of space that an operation would 	 * consume, which is OK. 	 * 	 * There's also a small window where we could miss a pending 	 * snapshot, because we could set the sync task in the quiescing 	 * phase.  So this should only be used as a guess. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_trysnap_txg
operator|>
name|spa_last_synced_txg
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
condition|)
name|trysnap
operator|=
name|ds
operator|->
name|ds_trysnap_txg
expr_stmt|;
return|return
operator|(
name|MAX
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|trysnap
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_block_freeable
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|blk_birth
parameter_list|)
block|{
if|if
condition|(
name|blk_birth
operator|<=
name|dsl_dataset_prev_snap_txg
argument_list|(
name|ds
argument_list|)
operator|||
operator|(
name|bp
operator|!=
name|NULL
operator|&&
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|ddt_prefetch
argument_list|(
name|dsl_dataset_get_spa
argument_list|(
name|ds
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|dsl_dataset_evict
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|dsv
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dsv
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_owner
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|unique_remove
argument_list|(
name|ds
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_objset
operator|!=
name|NULL
condition|)
name|dmu_objset_evict
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|=
name|NULL
expr_stmt|;
block|}
name|bplist_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|!=
literal|0
condition|)
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dir
condition|)
name|dsl_dir_rele
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_get_snapname
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|dsl_dataset_phys_t
modifier|*
name|headphys
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_buf_t
modifier|*
name|headdbuf
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|headdbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|headphys
operator|=
name|headdbuf
operator|->
name|db_data
expr_stmt|;
name|err
operator|=
name|zap_value_search
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|headphys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
literal|0
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|headdbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_snap_lookup
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|snapobj
init|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
decl_stmt|;
name|matchtype_t
name|mt
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_CI_DATASET
condition|)
name|mt
operator|=
name|MT_FIRST
expr_stmt|;
else|else
name|mt
operator|=
name|MT_EXACT
expr_stmt|;
name|err
operator|=
name|zap_lookup_norm
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|,
name|mt
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOTSUP
operator|&&
name|mt
operator|==
name|MT_FIRST
condition|)
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_snap_remove
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|adj_cnt
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|snapobj
init|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
decl_stmt|;
name|matchtype_t
name|mt
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_dir_snap_cmtime_update
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_CI_DATASET
condition|)
name|mt
operator|=
name|MT_FIRST
expr_stmt|;
else|else
name|mt
operator|=
name|MT_EXACT
expr_stmt|;
name|err
operator|=
name|zap_remove_norm
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
name|mt
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOTSUP
operator|&&
name|mt
operator|==
name|MT_FIRST
condition|)
name|err
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|snapobj
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|adj_cnt
condition|)
name|dsl_fs_ss_count_adjust
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|-
literal|1
argument_list|,
name|DD_FIELD_SNAPSHOT_COUNT
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_hold_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
operator|&
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* Make sure dsobj has the correct object type. */
name|dmu_object_info_from_db
argument_list|(
name|dbuf
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|doi
operator|.
name|doi_bonus_type
operator|!=
name|DMU_OT_DSL_DATASET
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|ds
operator|=
name|dmu_buf_get_user
argument_list|(
name|dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|winner
init|=
name|NULL
decl_stmt|;
name|ds
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dbuf
operator|=
name|dbuf
expr_stmt|;
name|ds
operator|->
name|ds_object
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|ds
operator|->
name|ds_sendstream_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|refcount_create
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|)
expr_stmt|;
name|bplist_create
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|ds
operator|->
name|ds_sendstreams
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_sendarg_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_sendarg_t
argument_list|,
name|dsa_link
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|)
expr_stmt|;
name|bplist_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doi
operator|.
name|doi_type
operator|==
name|DMU_OTN_ZAP_METADATA
condition|)
block|{
name|int
name|zaperr
init|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|DS_FIELD_BOOKMARK_NAMES
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|ds_bookmarks
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_bookmarks
argument_list|)
decl_stmt|;
if|if
condition|(
name|zaperr
operator|!=
name|ENOENT
condition|)
name|VERIFY0
argument_list|(
name|zaperr
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|zfs_flags
operator|&
name|ZFS_DEBUG_SNAPNAMES
condition|)
name|err
operator|=
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|zap_count
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_userrefs_obj
argument_list|,
operator|&
name|ds
operator|->
name|ds_userrefs
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|err
operator|=
name|dsl_prop_get_int_ds
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
operator|&
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_prop_get_int_ds
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFQUOTA
argument_list|)
argument_list|,
operator|&
name|ds
operator|->
name|ds_quota
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|ds
operator|->
name|ds_reserved
operator|=
name|ds
operator|->
name|ds_quota
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|!=
literal|0
operator|||
operator|(
name|winner
operator|=
name|dmu_buf_set_user_ie
argument_list|(
name|dbuf
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_phys
argument_list|,
name|dsl_dataset_evict
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bplist_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
name|dsl_dataset_rele
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_opening_lock
argument_list|)
expr_stmt|;
name|refcount_destroy
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ds
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ds
operator|=
name|winner
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|->
name|ds_fsid_guid
operator|=
name|unique_insert
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
operator|==
argument_list|,
name|dbuf
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_phys
argument_list|,
operator|==
argument_list|,
name|dbuf
operator|->
name|db_data
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
operator|||
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_ORIGIN
operator|||
name|dp
operator|->
name|dp_origin_snap
operator|==
name|NULL
operator|||
name|ds
operator|==
name|dp
operator|->
name|dp_origin_snap
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|ds
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_hold
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
specifier|const
name|char
modifier|*
name|snapname
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|err
operator|=
name|dsl_dir_hold
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|,
operator|&
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|obj
operator|=
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
expr_stmt|;
if|if
condition|(
name|obj
operator|!=
literal|0
condition|)
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
comment|/* we may be looking for a snapshot */
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|snapname
operator|!=
name|NULL
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
if|if
condition|(
operator|*
name|snapname
operator|++
operator|!=
literal|'@'
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
name|dprintf
argument_list|(
literal|"looking for snapshot '%s'\n"
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
operator|*
name|dsp
argument_list|,
name|snapname
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|snapname
argument_list|,
sizeof|sizeof
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|ds
expr_stmt|;
block|}
block|}
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_own_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
name|dsl_dataset_tryown
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
operator|*
name|dsp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_own
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_dataset_t
modifier|*
modifier|*
name|dsp
parameter_list|)
block|{
name|int
name|err
init|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|tag
argument_list|,
name|dsp
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
operator|!
name|dsl_dataset_tryown
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
operator|*
name|dsp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * See the comment above dsl_pool_hold() for details.  In summary, a long  * hold is used to prevent destruction of a dataset while the pool hold  * is dropped, allowing other concurrent operations (e.g. spa_sync()).  *  * The dataset and pool must be held when this function is called.  After it  * is called, the pool hold may be released while the dataset is still held  * and accessed.  */
end_comment

begin_function
name|void
name|dsl_dataset_long_hold
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|refcount_add
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_long_rele
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
operator|(
name|void
operator|)
name|refcount_remove
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return B_TRUE if there are any long holds on this dataset. */
end_comment

begin_function
name|boolean_t
name|dsl_dataset_long_held
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
operator|!
name|refcount_is_zero
argument_list|(
operator|&
name|ds
operator|->
name|ds_longholds
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_name
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|name
argument_list|,
literal|"mos"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dir_name
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_snapname
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
comment|/* 			 * We use a "recursive" mutex so that we 			 * can call dprintf_ds() with ds_lock held. 			 */
if|if
condition|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|name
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|dsl_dataset_rele
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_disown
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_owner
operator|==
name|tag
operator|&&
name|ds
operator|->
name|ds_dbuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_owner
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dataset_long_rele
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dbuf
operator|!=
name|NULL
condition|)
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
else|else
name|dsl_dataset_evict
argument_list|(
name|NULL
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_tryown
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|boolean_t
name|gotit
init|=
name|FALSE
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_owner
operator|==
name|NULL
operator|&&
operator|!
name|DS_IS_INCONSISTENT
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|ds
operator|->
name|ds_owner
operator|=
name|tag
expr_stmt|;
name|dsl_dataset_long_hold
argument_list|(
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|gotit
operator|=
name|TRUE
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|gotit
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_create_sync_dd
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dd
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
name|origin
operator|=
name|dp
operator|->
name|dp_origin_snap
expr_stmt|;
name|ASSERT
argument_list|(
name|origin
operator|==
name|NULL
operator|||
name|origin
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|==
name|dp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|origin
operator|==
name|NULL
operator|||
name|origin
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|dsphys
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator|=
name|flags
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_snapnames_zapobj
operator|=
name|zap_create_norm
argument_list|(
name|mos
argument_list|,
name|U8_TEXTPREP_TOUPPER
argument_list|,
name|DMU_OT_DSL_DS_SNAP_MAP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|tx
operator|->
name|tx_txg
operator|==
name|TXG_INITIAL
condition|?
literal|1
else|:
name|tx
operator|->
name|tx_txg
expr_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
block|{
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|dsl_deadlist_alloc
argument_list|(
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dataset_t
modifier|*
name|ohds
decl_stmt|;
comment|/* head of the origin snapshot */
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|origin
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_referenced_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator||=
name|origin
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|++
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ohds
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|dsl_deadlist_clone
argument_list|(
operator|&
name|ohds
operator|->
name|ds_deadlist
argument_list|,
name|dsphys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|dsphys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ohds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_NEXT_CLONES
condition|)
block|{
if|if
condition|(
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|==
literal|0
condition|)
block|{
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_NEXT_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|origin
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|origin
operator|->
name|ds_object
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
if|if
condition|(
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|dsphys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
operator|=
name|dsobj
expr_stmt|;
return|return
operator|(
name|dsobj
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_zero_zil
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|VERIFY0
argument_list|(
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|os
operator|->
name|os_zil_header
argument_list|,
sizeof|sizeof
argument_list|(
name|os
operator|->
name|os_zil_header
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_dirty
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_create_sync
parameter_list|(
name|dsl_dir_t
modifier|*
name|pdd
parameter_list|,
specifier|const
name|char
modifier|*
name|lastname
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|pdd
operator|->
name|dd_pool
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|ddobj
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lastname
index|[
literal|0
index|]
operator|!=
literal|'@'
argument_list|)
expr_stmt|;
name|ddobj
operator|=
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|pdd
argument_list|,
name|lastname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|ddobj
argument_list|,
name|lastname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dd
argument_list|)
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dsl_dataset_create_sync_dd
argument_list|(
name|dd
argument_list|,
name|origin
argument_list|,
name|flags
operator|&
operator|~
name|DS_CREATE_FLAG_NODIRTY
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_deleg_set_create_perms
argument_list|(
name|dd
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* 	 * Since we're creating a new node we know it's a leaf, so we can 	 * initialize the counts if the limit feature is active. 	 */
if|if
condition|(
name|spa_feature_is_active
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_FEATURE_FS_SS_LIMIT
argument_list|)
condition|)
block|{
name|uint64_t
name|cnt
init|=
literal|0
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|dd
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dsl_dir_zapify
argument_list|(
name|dd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|os
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|DD_FIELD_FILESYSTEM_COUNT
argument_list|,
sizeof|sizeof
argument_list|(
name|cnt
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|cnt
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|os
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|DD_FIELD_SNAPSHOT_COUNT
argument_list|,
sizeof|sizeof
argument_list|(
name|cnt
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|cnt
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * If we are creating a clone, make sure we zero out any stale 	 * data from the origin snapshots zil header. 	 */
if|if
condition|(
name|origin
operator|!=
name|NULL
operator|&&
operator|!
operator|(
name|flags
operator|&
name|DS_CREATE_FLAG_NODIRTY
operator|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_zero_zil
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dsobj
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The unique space in the head dataset can be calculated by subtracting  * the space used in the most recent snapshot, that is still being used  * in this file system, from the space currently in use.  To figure out  * the space in the most recent snapshot still in use, we need to take  * the total space used in the snapshot and subtract out the space that  * has been freed up since the snapshot was taken.  */
end_comment

begin_function
name|void
name|dsl_dataset_recalc_head_uniq
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|uint64_t
name|mrs_used
decl_stmt|;
name|uint64_t
name|dlused
decl_stmt|,
name|dlcomp
decl_stmt|,
name|dluncomp
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
name|mrs_used
operator|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
else|else
name|mrs_used
operator|=
literal|0
expr_stmt|;
name|dsl_deadlist_space
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dlused
argument_list|,
operator|&
name|dlcomp
argument_list|,
operator|&
name|dluncomp
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dlused
argument_list|,
operator|<=
argument_list|,
name|mrs_used
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|-
operator|(
name|mrs_used
operator|-
name|dlused
operator|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_remove_from_next_clones
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|count
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_remove_int
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * The err should not be ENOENT, but a bug in a previous version 	 * of the code could cause upgrade_clones_cb() to not set 	 * ds_next_snap_obj when it should, leading to a missing entry. 	 * If we knew that the pool was created after 	 * SPA_VERSION_NEXT_CLONES, we could assert that it isn't 	 * ENOENT.  However, at least we can check that we don't have 	 * too many entries in the next_clones_obj even after failing to 	 * remove this one. 	 */
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
name|VERIFY0
argument_list|(
name|err
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
operator|&
name|count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|count
argument_list|,
operator|<=
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|blkptr_t
modifier|*
name|dsl_dataset_get_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
operator|&
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_set_blkptr
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If it's the meta-objset, set dp_meta_rootbp */
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
block|{
name|tx
operator|->
name|tx_pool
operator|->
name|dp_meta_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
else|else
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
operator|*
name|bp
expr_stmt|;
block|}
block|}
end_function

begin_function
name|spa_t
modifier|*
name|dsl_dataset_get_spa
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_spa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_dirty
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|ds
operator|==
name|NULL
condition|)
comment|/* this is the meta-objset */
return|return;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_objset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
literal|0
condition|)
name|panic
argument_list|(
literal|"dirtying snapshot!"
argument_list|)
expr_stmt|;
name|dp
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
expr_stmt|;
if|if
condition|(
name|txg_list_add
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|ds
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
condition|)
block|{
comment|/* up the hold count until we can be written out */
name|dmu_buf_add_ref
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_is_dirty
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|txg_list_member
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_dirty_datasets
argument_list|,
name|ds
argument_list|,
name|t
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_reserve_space
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|asize
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If there's an fs-only reservation, any blocks that might become 	 * owned by the snapshot dataset must be accommodated by space 	 * outside of the reservation. 	 */
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_reserved
operator|==
literal|0
operator|||
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|asize
operator|=
name|MIN
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
if|if
condition|(
name|asize
operator|>
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
comment|/* 	 * Propagate any reserved space for this snapshot to other 	 * snapshot checks in this sync group. 	 */
if|if
condition|(
name|asize
operator|>
literal|0
condition|)
name|dsl_dir_willuse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|asize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dsl_dataset_snapshot_arg
block|{
name|nvlist_t
modifier|*
name|ddsa_snaps
decl_stmt|;
name|nvlist_t
modifier|*
name|ddsa_props
decl_stmt|;
name|nvlist_t
modifier|*
name|ddsa_errors
decl_stmt|;
name|cred_t
modifier|*
name|ddsa_cr
decl_stmt|;
block|}
name|dsl_dataset_snapshot_arg_t
typedef|;
end_typedef

begin_function
name|int
name|dsl_dataset_snapshot_check_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|recv
parameter_list|,
name|uint64_t
name|cnt
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|value
decl_stmt|;
name|ds
operator|->
name|ds_trysnap_txg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * We don't allow multiple snapshots of the same txg.  If there 	 * is already one, try again. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|>=
name|tx
operator|->
name|tx_txg
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
comment|/* 	 * Check for conflicting snapshot name. 	 */
name|error
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|ds
argument_list|,
name|snapname
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
if|if
condition|(
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * We don't allow taking snapshots of inconsistent datasets, such as 	 * those into which we are currently receiving.  However, if we are 	 * creating this snapshot as part of a receive, this check will be 	 * executed atomically with respect to the completion of the receive 	 * itself but prior to the clearing of DS_FLAG_INCONSISTENT; in this 	 * case we ignore this, knowing it will be fixed up for us shortly in 	 * dmu_recv_end_sync(). 	 */
if|if
condition|(
operator|!
name|recv
operator|&&
name|DS_IS_INCONSISTENT
argument_list|(
name|ds
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * Skip the check for temporary snapshots or if we have already checked 	 * the counts in dsl_dataset_snapshot_check. This means we really only 	 * check the count here when we're receiving a stream. 	 */
if|if
condition|(
name|cnt
operator|!=
literal|0
operator|&&
name|cr
operator|!=
name|NULL
condition|)
block|{
name|error
operator|=
name|dsl_fs_ss_limit_check
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|cnt
argument_list|,
name|ZFS_PROP_SNAPSHOT_LIMIT
argument_list|,
name|NULL
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dsl_dataset_snapshot_reserve_space
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_snapshot_arg_t
modifier|*
name|ddsa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|nvpair_t
modifier|*
name|pair
decl_stmt|;
name|int
name|rv
init|=
literal|0
decl_stmt|;
comment|/* 	 * Pre-compute how many total new snapshots will be created for each 	 * level in the tree and below. This is needed for validating the 	 * snapshot limit when either taking a recursive snapshot or when 	 * taking multiple snapshots. 	 * 	 * The problem is that the counts are not actually adjusted when 	 * we are checking, only when we finally sync. For a single snapshot, 	 * this is easy, the count will increase by 1 at each node up the tree, 	 * but its more complicated for the recursive/multiple snapshot case. 	 * 	 * The dsl_fs_ss_limit_check function does recursively check the count 	 * at each level up the tree but since it is validating each snapshot 	 * independently we need to be sure that we are validating the complete 	 * count for the entire set of snapshots. We do this by rolling up the 	 * counts for each component of the name into an nvlist and then 	 * checking each of those cases with the aggregated count. 	 * 	 * This approach properly handles not only the recursive snapshot 	 * case (where we get all of those on the ddsa_snaps list) but also 	 * the sibling case (e.g. snapshot a/b and a/c so that we will also 	 * validate the limit on 'a' using a count of 2). 	 * 	 * We validate the snapshot names in the third loop and only report 	 * name errors once. 	 */
if|if
condition|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
block|{
name|nvlist_t
modifier|*
name|cnt_track
init|=
name|NULL
decl_stmt|;
name|cnt_track
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
comment|/* Rollup aggregated counts into the cnt_track list */
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|ddsa
operator|->
name|ddsa_snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|ddsa
operator|->
name|ddsa_snaps
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|char
modifier|*
name|pdelim
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|char
name|nm
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|nm
argument_list|,
name|nvpair_name
argument_list|(
name|pair
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|nm
argument_list|)
argument_list|)
expr_stmt|;
name|pdelim
operator|=
name|strchr
argument_list|(
name|nm
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdelim
operator|==
name|NULL
condition|)
continue|continue;
operator|*
name|pdelim
operator|=
literal|'\0'
expr_stmt|;
do|do
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|cnt_track
argument_list|,
name|nm
argument_list|,
operator|&
name|val
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* update existing entry */
name|fnvlist_add_uint64
argument_list|(
name|cnt_track
argument_list|,
name|nm
argument_list|,
name|val
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* add to list */
name|fnvlist_add_uint64
argument_list|(
name|cnt_track
argument_list|,
name|nm
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|pdelim
operator|=
name|strrchr
argument_list|(
name|nm
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|pdelim
operator|!=
name|NULL
condition|)
operator|*
name|pdelim
operator|=
literal|'\0'
expr_stmt|;
block|}
do|while
condition|(
name|pdelim
operator|!=
name|NULL
condition|)
do|;
block|}
comment|/* Check aggregated counts at each level */
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|cnt_track
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|cnt_track
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|uint64_t
name|cnt
init|=
literal|0
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|name
operator|=
name|nvpair_name
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|cnt
operator|=
name|fnvpair_value_uint64
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_fs_ss_limit_check
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|cnt
argument_list|,
name|ZFS_PROP_SNAPSHOT_LIMIT
argument_list|,
name|NULL
argument_list|,
name|ddsa
operator|->
name|ddsa_cr
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ddsa
operator|->
name|ddsa_errors
operator|!=
name|NULL
condition|)
name|fnvlist_add_int32
argument_list|(
name|ddsa
operator|->
name|ddsa_errors
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|rv
operator|=
name|error
expr_stmt|;
comment|/* only report one error for this check */
break|break;
block|}
block|}
name|nvlist_free
argument_list|(
name|cnt_track
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|ddsa
operator|->
name|ddsa_snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|ddsa
operator|->
name|ddsa_snaps
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|atp
decl_stmt|;
name|char
name|dsname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|name
operator|=
name|nvpair_name
argument_list|(
name|pair
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|atp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|name
argument_list|,
name|atp
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* passing 0/NULL skips dsl_fs_ss_limit_check */
name|error
operator|=
name|dsl_dataset_snapshot_check_impl
argument_list|(
name|ds
argument_list|,
name|atp
operator|+
literal|1
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|ddsa
operator|->
name|ddsa_errors
operator|!=
name|NULL
condition|)
block|{
name|fnvlist_add_int32
argument_list|(
name|ddsa
operator|->
name|ddsa_errors
argument_list|,
name|name
argument_list|,
name|error
argument_list|)
expr_stmt|;
block|}
name|rv
operator|=
name|error
expr_stmt|;
block|}
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_snapshot_sync_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
specifier|static
name|zil_header_t
name|zero_zil
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
decl_stmt|;
name|dsl_dataset_phys_t
modifier|*
name|dsphys
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|,
name|crtxg
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|ASSERT
argument_list|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are on an old pool, the zil must not be active, in which 	 * case it will be zeroed.  Usually zil_suspend() accomplishes this. 	 */
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_FAST_SNAP
operator|||
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
operator|!=
literal|0
operator|||
name|bcmp
argument_list|(
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_zil_header
argument_list|,
operator|&
name|zero_zil
argument_list|,
sizeof|sizeof
argument_list|(
name|zero_zil
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dsl_fs_ss_count_adjust
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
literal|1
argument_list|,
name|DD_FIELD_SNAPSHOT_COUNT
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * The origin's ds_creation_txg has to be< TXG_INITIAL 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|snapname
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|)
operator|==
literal|0
condition|)
name|crtxg
operator|=
literal|1
expr_stmt|;
else|else
name|crtxg
operator|=
name|tx
operator|->
name|tx_txg
expr_stmt|;
name|dsobj
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
literal|0
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsphys
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bzero
argument_list|(
name|dsphys
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_dir_obj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_object
expr_stmt|;
name|dsphys
operator|->
name|ds_fsid_guid
operator|=
name|unique_create
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|dsphys
operator|->
name|ds_guid
argument_list|,
sizeof|sizeof
argument_list|(
name|dsphys
operator|->
name|ds_guid
argument_list|)
argument_list|)
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_prev_snap_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
expr_stmt|;
name|dsphys
operator|->
name|ds_next_snap_obj
operator|=
name|ds
operator|->
name|ds_object
expr_stmt|;
name|dsphys
operator|->
name|ds_num_children
operator|=
literal|1
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_time
operator|=
name|gethrestime_sec
argument_list|()
expr_stmt|;
name|dsphys
operator|->
name|ds_creation_txg
operator|=
name|crtxg
expr_stmt|;
name|dsphys
operator|->
name|ds_deadlist_obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
expr_stmt|;
name|dsphys
operator|->
name|ds_referenced_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_compressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_uncompressed_bytes
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|dsphys
operator|->
name|ds_flags
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
expr_stmt|;
name|dsphys
operator|->
name|ds_bp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_prev
operator|!=
literal|0
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
block|{
name|uint64_t
name|next_clones_obj
init|=
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
decl_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
operator|||
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
name|ds
operator|->
name|ds_object
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|==
argument_list|,
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|dsobj
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_remove_from_next_clones
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|dsphys
operator|->
name|ds_next_snap_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|mos
argument_list|,
name|next_clones_obj
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * If we have a reference-reservation on this dataset, we will 	 * need to increase the amount of refreservation being charged 	 * since our unique space is going to zero. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
condition|)
block|{
name|int64_t
name|delta
decl_stmt|;
name|ASSERT
argument_list|(
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|delta
operator|=
name|MIN
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
operator|=
name|dsl_deadlist_clone
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|UINT64_MAX
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_add_key
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
operator|<
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|dsobj
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|crtxg
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_UNIQUE_ACCURATE
condition|)
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator||=
name|DS_FLAG_UNIQUE_ACCURATE
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_prev
condition|)
name|dsl_dataset_rele
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_scan_ds_snapshotted
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_snap_cmtime_update
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
literal|"snapshot"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_snapshot_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_snapshot_arg_t
modifier|*
name|ddsa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|nvpair_t
modifier|*
name|pair
decl_stmt|;
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|ddsa
operator|->
name|ddsa_snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|ddsa
operator|->
name|ddsa_snaps
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|atp
decl_stmt|;
name|char
name|dsname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|name
operator|=
name|nvpair_name
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|atp
operator|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|name
argument_list|,
name|atp
operator|-
name|name
operator|+
literal|1
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|dsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_snapshot_sync_impl
argument_list|(
name|ds
argument_list|,
name|atp
operator|+
literal|1
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddsa
operator|->
name|ddsa_props
operator|!=
name|NULL
condition|)
block|{
name|dsl_props_set_sync_impl
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|,
name|ddsa
operator|->
name|ddsa_props
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The snapshots must all be in the same pool.  * All-or-nothing: if there are any failures, nothing will be modified.  */
end_comment

begin_function
name|int
name|dsl_dataset_snapshot
parameter_list|(
name|nvlist_t
modifier|*
name|snaps
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
name|errors
parameter_list|)
block|{
name|dsl_dataset_snapshot_arg_t
name|ddsa
decl_stmt|;
name|nvpair_t
modifier|*
name|pair
decl_stmt|;
name|boolean_t
name|needsuspend
decl_stmt|;
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|firstname
decl_stmt|;
name|nvlist_t
modifier|*
name|suspended
init|=
name|NULL
decl_stmt|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|pair
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|firstname
operator|=
name|nvpair_name
argument_list|(
name|pair
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|firstname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|needsuspend
operator|=
operator|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_FAST_SNAP
operator|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsuspend
condition|)
block|{
name|suspended
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|snaps
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|char
name|fsname
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|snapname
init|=
name|nvpair_name
argument_list|(
name|pair
argument_list|)
decl_stmt|;
name|char
modifier|*
name|atp
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|atp
operator|=
name|strchr
argument_list|(
name|snapname
argument_list|,
literal|'@'
argument_list|)
expr_stmt|;
if|if
condition|(
name|atp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|fsname
argument_list|,
name|snapname
argument_list|,
name|atp
operator|-
name|snapname
operator|+
literal|1
argument_list|)
expr_stmt|;
name|error
operator|=
name|zil_suspend
argument_list|(
name|fsname
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|fnvlist_add_uint64
argument_list|(
name|suspended
argument_list|,
name|fsname
argument_list|,
operator|(
name|uintptr_t
operator|)
name|cookie
argument_list|)
expr_stmt|;
block|}
block|}
name|ddsa
operator|.
name|ddsa_snaps
operator|=
name|snaps
expr_stmt|;
name|ddsa
operator|.
name|ddsa_props
operator|=
name|props
expr_stmt|;
name|ddsa
operator|.
name|ddsa_errors
operator|=
name|errors
expr_stmt|;
name|ddsa
operator|.
name|ddsa_cr
operator|=
name|CRED
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_sync_task
argument_list|(
name|firstname
argument_list|,
name|dsl_dataset_snapshot_check
argument_list|,
name|dsl_dataset_snapshot_sync
argument_list|,
operator|&
name|ddsa
argument_list|,
name|fnvlist_num_pairs
argument_list|(
name|snaps
argument_list|)
operator|*
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|suspended
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|suspended
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|suspended
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|zil_resume
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|fnvpair_value_uint64
argument_list|(
name|pair
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fnvlist_free
argument_list|(
name|suspended
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dsl_dataset_snapshot_tmp_arg
block|{
specifier|const
name|char
modifier|*
name|ddsta_fsname
decl_stmt|;
specifier|const
name|char
modifier|*
name|ddsta_snapname
decl_stmt|;
name|minor_t
name|ddsta_cleanup_minor
decl_stmt|;
specifier|const
name|char
modifier|*
name|ddsta_htag
decl_stmt|;
block|}
name|dsl_dataset_snapshot_tmp_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|dsl_dataset_snapshot_tmp_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_snapshot_tmp_arg_t
modifier|*
name|ddsta
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddsta
operator|->
name|ddsta_fsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* NULL cred means no limit check for tmp snapshot */
name|error
operator|=
name|dsl_dataset_snapshot_check_impl
argument_list|(
name|ds
argument_list|,
name|ddsta
operator|->
name|ddsta_snapname
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_USERREFS
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dsl_dataset_user_hold_check_one
argument_list|(
name|NULL
argument_list|,
name|ddsta
operator|->
name|ddsta_htag
argument_list|,
name|B_TRUE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_snapshot_tmp_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_snapshot_tmp_arg_t
modifier|*
name|ddsta
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddsta
operator|->
name|ddsta_fsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_snapshot_sync_impl
argument_list|(
name|ds
argument_list|,
name|ddsta
operator|->
name|ddsta_snapname
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_user_hold_sync_one
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|ddsta
operator|->
name|ddsta_htag
argument_list|,
name|ddsta
operator|->
name|ddsta_cleanup_minor
argument_list|,
name|gethrestime_sec
argument_list|()
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_destroy_snapshot_sync_impl
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|B_TRUE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_snapshot_tmp
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|,
name|minor_t
name|cleanup_minor
parameter_list|,
specifier|const
name|char
modifier|*
name|htag
parameter_list|)
block|{
name|dsl_dataset_snapshot_tmp_arg_t
name|ddsta
decl_stmt|;
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|boolean_t
name|needsuspend
decl_stmt|;
name|void
modifier|*
name|cookie
decl_stmt|;
name|ddsta
operator|.
name|ddsta_fsname
operator|=
name|fsname
expr_stmt|;
name|ddsta
operator|.
name|ddsta_snapname
operator|=
name|snapname
expr_stmt|;
name|ddsta
operator|.
name|ddsta_cleanup_minor
operator|=
name|cleanup_minor
expr_stmt|;
name|ddsta
operator|.
name|ddsta_htag
operator|=
name|htag
expr_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|fsname
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|needsuspend
operator|=
operator|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_FAST_SNAP
operator|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsuspend
condition|)
block|{
name|error
operator|=
name|zil_suspend
argument_list|(
name|fsname
argument_list|,
operator|&
name|cookie
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dsl_sync_task
argument_list|(
name|fsname
argument_list|,
name|dsl_dataset_snapshot_tmp_check
argument_list|,
name|dsl_dataset_snapshot_tmp_sync
argument_list|,
operator|&
name|ddsta
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|needsuspend
condition|)
name|zil_resume
argument_list|(
name|cookie
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_sync
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_objset
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * in case we had to change ds_fsid_guid when we opened it, 	 * sync it out now. 	 */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_fsid_guid
operator|=
name|ds
operator|->
name|ds_fsid_guid
expr_stmt|;
name|dmu_objset_sync
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_clones_stat
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|uint64_t
name|count
init|=
literal|0
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|nvlist_t
modifier|*
name|val
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * There may be missing entries in ds_next_clones_obj 	 * due to a bug in a previous version of the code. 	 * Only trust it if it has the right number of entries. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|!=
literal|0
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_count
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
operator|&
name|count
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|!=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|1
condition|)
goto|goto
name|fail
goto|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|clone
decl_stmt|;
name|char
name|buf
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dir_name
argument_list|(
name|clone
operator|->
name|ds_dir
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|val
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|clone
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CLONES
argument_list|)
argument_list|,
name|propval
argument_list|)
expr_stmt|;
name|fail
label|:
name|nvlist_free
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_stats
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|uobjs
decl_stmt|,
name|aobjs
decl_stmt|,
name|ratio
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|ratio
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|==
literal|0
condition|?
literal|100
else|:
operator|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|*
literal|100
operator|/
name|ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFRATIO
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_LOGICALREFERENCED
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_COMPRESSRATIO
argument_list|,
name|ratio
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_USED
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
name|get_clones_stat
argument_list|(
name|ds
argument_list|,
name|nv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_dir_stats
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|nv
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_space
argument_list|(
name|ds
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|uobjs
argument_list|,
operator|&
name|aobjs
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_AVAILABLE
argument_list|,
name|avail
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFERENCED
argument_list|,
name|refd
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATION
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_time
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_CREATETXG
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFQUOTA
argument_list|,
name|ds
operator|->
name|ds_quota
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_REFRESERVATION
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_GUID
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_guid
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_UNIQUE
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_OBJSETID
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_USERREFS
argument_list|,
name|ds
operator|->
name|ds_userrefs
argument_list|)
expr_stmt|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_DEFER_DESTROY
argument_list|,
name|DS_IS_DEFER_DESTROY
argument_list|(
name|ds
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|written
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|prev
decl_stmt|;
name|int
name|err
init|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_space_written
argument_list|(
name|prev
argument_list|,
name|ds
argument_list|,
operator|&
name|written
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_WRITTEN
argument_list|,
name|written
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|dsl_dataset_fast_stat
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|stat
operator|->
name|dds_creation_txg
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|stat
operator|->
name|dds_inconsistent
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_INCONSISTENT
expr_stmt|;
name|stat
operator|->
name|dds_guid
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_guid
expr_stmt|;
name|stat
operator|->
name|dds_origin
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|stat
operator|->
name|dds_is_snapshot
operator|=
name|B_TRUE
expr_stmt|;
name|stat
operator|->
name|dds_num_clones
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|stat
operator|->
name|dds_is_snapshot
operator|=
name|B_FALSE
expr_stmt|;
name|stat
operator|->
name|dds_num_clones
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dsl_dir_is_clone
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ods
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ods
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ods
argument_list|,
name|stat
operator|->
name|dds_origin
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ods
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|uint64_t
name|dsl_dataset_fsid_guid
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
return|return
operator|(
name|ds
operator|->
name|ds_fsid_guid
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_space
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
block|{
operator|*
name|refdbytesp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
operator|*
name|availbytesp
operator|=
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
condition|)
operator|*
name|availbytesp
operator|+=
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_quota
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Adjust available bytes according to refquota 		 */
if|if
condition|(
operator|*
name|refdbytesp
operator|<
name|ds
operator|->
name|ds_quota
condition|)
operator|*
name|availbytesp
operator|=
name|MIN
argument_list|(
operator|*
name|availbytesp
argument_list|,
name|ds
operator|->
name|ds_quota
operator|-
operator|*
name|refdbytesp
argument_list|)
expr_stmt|;
else|else
operator|*
name|availbytesp
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|usedobjsp
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_fill
expr_stmt|;
operator|*
name|availobjsp
operator|=
name|DN_MAX_OBJECT
operator|-
operator|*
name|usedobjsp
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_dataset_modified_since_snap
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dsl_dataset_t
modifier|*
name|snap
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|snap
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|>
name|snap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|,
modifier|*
name|os_snap
decl_stmt|;
comment|/* 		 * It may be that only the ZIL differs, because it was 		 * reset in the head.  Don't count that as being 		 * modified. 		 */
if|if
condition|(
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
name|dmu_objset_from_ds
argument_list|(
name|snap
argument_list|,
operator|&
name|os_snap
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
return|return
operator|(
name|bcmp
argument_list|(
operator|&
name|os
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|,
operator|&
name|os_snap
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|,
sizeof|sizeof
argument_list|(
name|os
operator|->
name|os_phys
operator|->
name|os_meta_dnode
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dsl_dataset_rename_snapshot_arg
block|{
specifier|const
name|char
modifier|*
name|ddrsa_fsname
decl_stmt|;
specifier|const
name|char
modifier|*
name|ddrsa_oldsnapname
decl_stmt|;
specifier|const
name|char
modifier|*
name|ddrsa_newsnapname
decl_stmt|;
name|boolean_t
name|ddrsa_recursive
decl_stmt|;
name|dmu_tx_t
modifier|*
name|ddrsa_tx
decl_stmt|;
block|}
name|dsl_dataset_rename_snapshot_arg_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_rename_snapshot_check_impl
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|hds
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsl_dataset_rename_snapshot_arg_t
modifier|*
name|ddrsa
init|=
name|arg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|error
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|ddrsa
operator|->
name|ddrsa_oldsnapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
comment|/* ignore nonexistent snapshots */
return|return
operator|(
name|error
operator|==
name|ENOENT
condition|?
literal|0
else|:
name|error
operator|)
return|;
block|}
comment|/* new name should not exist */
name|error
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|ddrsa
operator|->
name|ddrsa_newsnapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
comment|/* dataset name + 1 for the "@" + the new snapshot name must fit */
if|if
condition|(
name|dsl_dir_namelen
argument_list|(
name|hds
operator|->
name|ds_dir
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|ddrsa
operator|->
name|ddrsa_newsnapname
argument_list|)
operator|>=
name|MAXNAMELEN
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_rename_snapshot_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_rename_snapshot_arg_t
modifier|*
name|ddrsa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddrsa
operator|->
name|ddrsa_fsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ddrsa
operator|->
name|ddrsa_recursive
condition|)
block|{
name|error
operator|=
name|dmu_objset_find_dp
argument_list|(
name|dp
argument_list|,
name|hds
operator|->
name|ds_dir
operator|->
name|dd_object
argument_list|,
name|dsl_dataset_rename_snapshot_check_impl
argument_list|,
name|ddrsa
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dsl_dataset_rename_snapshot_check_impl
argument_list|(
name|dp
argument_list|,
name|hds
argument_list|,
name|ddrsa
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_rename_snapshot_sync_impl
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|hds
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dsl_dataset_rename_snapshot_arg_t
modifier|*
name|ddrsa
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|ddrsa
operator|->
name|ddrsa_tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|ddrsa
operator|->
name|ddrsa_oldsnapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* ignore nonexistent snapshots */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|val
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
comment|/* log before we change the name */
name|spa_history_log_internal_ds
argument_list|(
name|ds
argument_list|,
literal|"rename"
argument_list|,
name|tx
argument_list|,
literal|"-> @%s"
argument_list|,
name|ddrsa
operator|->
name|ddrsa_newsnapname
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_snap_remove
argument_list|(
name|hds
argument_list|,
name|ddrsa
operator|->
name|ddrsa_oldsnapname
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ds
operator|->
name|ds_snapname
argument_list|,
name|ddrsa
operator|->
name|ddrsa_newsnapname
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_rename_snapshot_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_rename_snapshot_arg_t
modifier|*
name|ddrsa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddrsa
operator|->
name|ddrsa_fsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|hds
argument_list|)
argument_list|)
expr_stmt|;
name|ddrsa
operator|->
name|ddrsa_tx
operator|=
name|tx
expr_stmt|;
if|if
condition|(
name|ddrsa
operator|->
name|ddrsa_recursive
condition|)
block|{
name|VERIFY0
argument_list|(
name|dmu_objset_find_dp
argument_list|(
name|dp
argument_list|,
name|hds
operator|->
name|ds_dir
operator|->
name|dd_object
argument_list|,
name|dsl_dataset_rename_snapshot_sync_impl
argument_list|,
name|ddrsa
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY0
argument_list|(
name|dsl_dataset_rename_snapshot_sync_impl
argument_list|(
name|dp
argument_list|,
name|hds
argument_list|,
name|ddrsa
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|hds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_rename_snapshot
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|oldsnapname
parameter_list|,
specifier|const
name|char
modifier|*
name|newsnapname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
block|{
name|dsl_dataset_rename_snapshot_arg_t
name|ddrsa
decl_stmt|;
name|ddrsa
operator|.
name|ddrsa_fsname
operator|=
name|fsname
expr_stmt|;
name|ddrsa
operator|.
name|ddrsa_oldsnapname
operator|=
name|oldsnapname
expr_stmt|;
name|ddrsa
operator|.
name|ddrsa_newsnapname
operator|=
name|newsnapname
expr_stmt|;
name|ddrsa
operator|.
name|ddrsa_recursive
operator|=
name|recursive
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|fsname
argument_list|,
name|dsl_dataset_rename_snapshot_check
argument_list|,
name|dsl_dataset_rename_snapshot_sync
argument_list|,
operator|&
name|ddrsa
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we're doing an ownership handoff, we need to make sure that there is  * only one long hold on the dataset.  We're not allowed to change anything here  * so we don't permanently release the long hold or regular hold here.  We want  * to do this only when syncing to avoid the dataset unexpectedly going away  * when we release the long hold.  */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_handoff_check
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|boolean_t
name|held
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|owner
operator|!=
name|NULL
condition|)
block|{
name|VERIFY3P
argument_list|(
name|ds
operator|->
name|ds_owner
argument_list|,
operator|==
argument_list|,
name|owner
argument_list|)
expr_stmt|;
name|dsl_dataset_long_rele
argument_list|(
name|ds
argument_list|,
name|owner
argument_list|)
expr_stmt|;
block|}
name|held
operator|=
name|dsl_dataset_long_held
argument_list|(
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
name|NULL
condition|)
name|dsl_dataset_long_hold
argument_list|(
name|ds
argument_list|,
name|owner
argument_list|)
expr_stmt|;
if|if
condition|(
name|held
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dsl_dataset_rollback_arg
block|{
specifier|const
name|char
modifier|*
name|ddra_fsname
decl_stmt|;
name|void
modifier|*
name|ddra_owner
decl_stmt|;
name|nvlist_t
modifier|*
name|ddra_result
decl_stmt|;
block|}
name|dsl_dataset_rollback_arg_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|dsl_dataset_rollback_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_rollback_arg_t
modifier|*
name|ddra
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int64_t
name|unused_refres_delta
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddra
operator|->
name|ddra_fsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* must not be a snapshot */
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* must have a most recent snapshot */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|<
name|TXG_INITIAL
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* must not have any bookmarks after the most recent snapshot */
name|nvlist_t
modifier|*
name|proprequest
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|proprequest
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CREATETXG
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_t
modifier|*
name|bookmarks
init|=
name|fnvlist_alloc
argument_list|()
decl_stmt|;
name|error
operator|=
name|dsl_get_bookmarks_impl
argument_list|(
name|ds
argument_list|,
name|proprequest
argument_list|,
name|bookmarks
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|proprequest
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
for|for
control|(
name|nvpair_t
modifier|*
name|pair
init|=
name|nvlist_next_nvpair
argument_list|(
name|bookmarks
argument_list|,
name|NULL
argument_list|)
init|;
name|pair
operator|!=
name|NULL
condition|;
name|pair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|bookmarks
argument_list|,
name|pair
argument_list|)
control|)
block|{
name|nvlist_t
modifier|*
name|valuenv
init|=
name|fnvlist_lookup_nvlist
argument_list|(
name|fnvpair_value_nvlist
argument_list|(
name|pair
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CREATETXG
argument_list|)
argument_list|)
decl_stmt|;
name|uint64_t
name|createtxg
init|=
name|fnvlist_lookup_uint64
argument_list|(
name|valuenv
argument_list|,
literal|"value"
argument_list|)
decl_stmt|;
if|if
condition|(
name|createtxg
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
condition|)
block|{
name|fnvlist_free
argument_list|(
name|bookmarks
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
block|}
name|fnvlist_free
argument_list|(
name|bookmarks
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_dataset_handoff_check
argument_list|(
name|ds
argument_list|,
name|ddra
operator|->
name|ddra_owner
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Check if the snap we are rolling back to uses more than 	 * the refquota. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_quota
operator|!=
literal|0
operator|&&
name|ds
operator|->
name|ds_prev
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|>
name|ds
operator|->
name|ds_quota
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * When we do the clone swap, we will temporarily use more space 	 * due to the refreservation (the head will no longer have any 	 * unique space, so the entire amount of the refreservation will need 	 * to be free).  We will immediately destroy the clone, freeing 	 * this space, but the freeing happens over many txg's. 	 */
name|unused_refres_delta
operator|=
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|ds
operator|->
name|ds_reserved
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|unused_refres_delta
operator|>
literal|0
operator|&&
name|unused_refres_delta
operator|>
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_rollback_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_rollback_arg_t
modifier|*
name|ddra
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|,
modifier|*
name|clone
decl_stmt|;
name|uint64_t
name|cloneobj
decl_stmt|;
name|char
name|namebuf
index|[
name|ZFS_MAXNAMELEN
index|]
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddra
operator|->
name|ddra_fsname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ds
operator|->
name|ds_prev
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|ddra
operator|->
name|ddra_result
argument_list|,
literal|"target"
argument_list|,
name|namebuf
argument_list|)
expr_stmt|;
name|cloneobj
operator|=
name|dsl_dataset_create_sync
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
literal|"%rollback"
argument_list|,
name|ds
operator|->
name|ds_prev
argument_list|,
name|DS_CREATE_FLAG_NODIRTY
argument_list|,
name|kcred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|cloneobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|clone
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_clone_swap_sync_impl
argument_list|(
name|clone
argument_list|,
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_zero_zil
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_destroy_head_sync_impl
argument_list|(
name|clone
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|clone
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rolls back the given filesystem or volume to the most recent snapshot.  * The name of the most recent snapshot will be returned under key "target"  * in the result nvlist.  *  * If owner != NULL:  * - The existing dataset MUST be owned by the specified owner at entry  * - Upon return, dataset will still be held by the same owner, whether we  *   succeed or not.  *  * This mode is required any time the existing filesystem is mounted.  See  * notes above zfs_suspend_fs() for further details.  */
end_comment

begin_function
name|int
name|dsl_dataset_rollback
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|,
name|nvlist_t
modifier|*
name|result
parameter_list|)
block|{
name|dsl_dataset_rollback_arg_t
name|ddra
decl_stmt|;
name|ddra
operator|.
name|ddra_fsname
operator|=
name|fsname
expr_stmt|;
name|ddra
operator|.
name|ddra_owner
operator|=
name|owner
expr_stmt|;
name|ddra
operator|.
name|ddra_result
operator|=
name|result
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|fsname
argument_list|,
name|dsl_dataset_rollback_check
argument_list|,
name|dsl_dataset_rollback_sync
argument_list|,
operator|&
name|ddra
argument_list|,
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|promotenode
block|{
name|list_node_t
name|link
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
struct|struct
name|dsl_dataset_promote_arg
block|{
specifier|const
name|char
modifier|*
name|ddpa_clonename
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ddpa_clone
decl_stmt|;
name|list_t
name|shared_snaps
decl_stmt|,
name|origin_snaps
decl_stmt|,
name|clone_snaps
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_origin
decl_stmt|;
comment|/* origin of the origin */
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|,
name|unique
decl_stmt|,
name|cloneusedsnap
decl_stmt|,
name|originusedsnap
decl_stmt|;
name|char
modifier|*
name|err_ds
decl_stmt|;
name|cred_t
modifier|*
name|cr
decl_stmt|;
block|}
name|dsl_dataset_promote_arg_t
typedef|;
end_typedef

begin_function_decl
specifier|static
name|int
name|snaplist_space
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|promote_hold
parameter_list|(
name|dsl_dataset_promote_arg_t
modifier|*
name|ddpa
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|promote_rele
parameter_list|(
name|dsl_dataset_promote_arg_t
modifier|*
name|ddpa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|dsl_dataset_promote_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_promote_arg_t
modifier|*
name|ddpa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_ds
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|unused
decl_stmt|;
name|uint64_t
name|ss_mv_cnt
decl_stmt|;
name|err
operator|=
name|promote_hold
argument_list|(
name|ddpa
argument_list|,
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|hds
operator|=
name|ddpa
operator|->
name|ddpa_clone
expr_stmt|;
if|if
condition|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
condition|)
block|{
name|promote_rele
argument_list|(
name|ddpa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EXDEV
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Compute and check the amount of space to transfer.  Since this is 	 * so expensive, don't do the preliminary check. 	 */
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
block|{
name|promote_rele
argument_list|(
name|ddpa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|)
expr_stmt|;
name|origin_ds
operator|=
name|snap
operator|->
name|ds
expr_stmt|;
comment|/* compute origin's new unique space */
name|snap
operator|=
name|list_tail
argument_list|(
operator|&
name|ddpa
operator|->
name|clone_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|snap
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|ddpa
operator|->
name|unique
argument_list|,
operator|&
name|unused
argument_list|,
operator|&
name|unused
argument_list|)
expr_stmt|;
comment|/* 	 * Walk the snapshots that we are moving 	 * 	 * Compute space to transfer.  Consider the incremental changes 	 * to used by each snapshot: 	 * (my used) = (prev's used) + (blocks born) - (blocks killed) 	 * So each snapshot gave birth to: 	 * (blocks born) = (my used) - (prev's used) + (blocks killed) 	 * So a sequence would look like: 	 * (uN - u(N-1) + kN) + ... + (u1 - u0 + k1) + (u0 - 0 + k0) 	 * Which simplifies to: 	 * uN + kN + kN-1 + ... + k1 + k0 	 * Note however, if we stop before we reach the ORIGIN we get: 	 * uN + kN + kN-1 + ... + kM - uM-1 	 */
name|ss_mv_cnt
operator|=
literal|0
expr_stmt|;
name|ddpa
operator|->
name|used
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|ddpa
operator|->
name|comp
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|ddpa
operator|->
name|uncomp
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|uint64_t
name|val
decl_stmt|,
name|dlused
decl_stmt|,
name|dlcomp
decl_stmt|,
name|dluncomp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
name|ss_mv_cnt
operator|++
expr_stmt|;
comment|/* 		 * If there are long holds, we won't be able to evict 		 * the objset. 		 */
if|if
condition|(
name|dsl_dataset_long_held
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* Check that the snapshot name does not conflict */
name|VERIFY0
argument_list|(
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|dsl_dataset_snap_lookup
argument_list|(
name|hds
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ddpa
operator|->
name|err_ds
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_snapname
argument_list|)
expr_stmt|;
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|err
operator|!=
name|ENOENT
condition|)
goto|goto
name|out
goto|;
comment|/* The very first snapshot does not have a deadlist */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|==
literal|0
condition|)
continue|continue;
name|dsl_deadlist_space
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|dlused
argument_list|,
operator|&
name|dlcomp
argument_list|,
operator|&
name|dluncomp
argument_list|)
expr_stmt|;
name|ddpa
operator|->
name|used
operator|+=
name|dlused
expr_stmt|;
name|ddpa
operator|->
name|comp
operator|+=
name|dlcomp
expr_stmt|;
name|ddpa
operator|->
name|uncomp
operator|+=
name|dluncomp
expr_stmt|;
block|}
comment|/* 	 * If we are a clone of a clone then we never reached ORIGIN, 	 * so we need to subtract out the clone origin's used space. 	 */
if|if
condition|(
name|ddpa
operator|->
name|origin_origin
condition|)
block|{
name|ddpa
operator|->
name|used
operator|-=
name|ddpa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
name|ddpa
operator|->
name|comp
operator|-=
name|ddpa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
name|ddpa
operator|->
name|uncomp
operator|-=
name|ddpa
operator|->
name|origin_origin
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
block|}
comment|/* Check that there is enough space and limit headroom here */
name|err
operator|=
name|dsl_dir_transfer_possible
argument_list|(
name|origin_ds
operator|->
name|ds_dir
argument_list|,
name|hds
operator|->
name|ds_dir
argument_list|,
literal|0
argument_list|,
name|ss_mv_cnt
argument_list|,
name|ddpa
operator|->
name|used
argument_list|,
name|ddpa
operator|->
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Compute the amounts of space that will be used by snapshots 	 * after the promotion (for both origin and clone).  For each, 	 * it is the amount of space that will be on all of their 	 * deadlists (that was not born before their new origin). 	 */
if|if
condition|(
name|hds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_flags
operator|&
name|DD_FLAG_USED_BREAKDOWN
condition|)
block|{
name|uint64_t
name|space
decl_stmt|;
comment|/* 		 * Note, typically this will not be a clone of a clone, 		 * so dd_origin_txg will be< TXG_INITIAL, so 		 * these snaplist_space() -> dsl_deadlist_space_range() 		 * calls will be fast because they do not have to 		 * iterate over all bps. 		 */
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|ddpa
operator|->
name|origin_snaps
argument_list|)
expr_stmt|;
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
operator|&
name|ddpa
operator|->
name|cloneusedsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|ddpa
operator|->
name|clone_snaps
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
operator|&
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|ddpa
operator|->
name|cloneusedsnap
operator|+=
name|space
expr_stmt|;
block|}
if|if
condition|(
name|origin_ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_flags
operator|&
name|DD_FLAG_USED_BREAKDOWN
condition|)
block|{
name|err
operator|=
name|snaplist_space
argument_list|(
operator|&
name|ddpa
operator|->
name|origin_snaps
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|ddpa
operator|->
name|originusedsnap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|promote_rele
argument_list|(
name|ddpa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_promote_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_promote_arg_t
modifier|*
name|ddpa
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|hds
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_ds
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|origin_head
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dir_t
modifier|*
name|odd
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|oldnext_obj
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|VERIFY0
argument_list|(
name|promote_hold
argument_list|(
name|ddpa
argument_list|,
name|dp
argument_list|,
name|FTAG
argument_list|)
argument_list|)
expr_stmt|;
name|hds
operator|=
name|ddpa
operator|->
name|ddpa_clone
expr_stmt|;
name|ASSERT0
argument_list|(
name|hds
operator|->
name|ds_phys
operator|->
name|ds_flags
operator|&
name|DS_FLAG_NOPROMOTE
argument_list|)
expr_stmt|;
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|)
expr_stmt|;
name|origin_ds
operator|=
name|snap
operator|->
name|ds
expr_stmt|;
name|dd
operator|=
name|hds
operator|->
name|ds_dir
expr_stmt|;
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|ddpa
operator|->
name|origin_snaps
argument_list|)
expr_stmt|;
name|origin_head
operator|=
name|snap
operator|->
name|ds
expr_stmt|;
comment|/* 	 * We need to explicitly open odd, since origin_ds's dd will be 	 * changing. 	 */
name|VERIFY0
argument_list|(
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|origin_ds
operator|->
name|ds_dir
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|FTAG
argument_list|,
operator|&
name|odd
argument_list|)
argument_list|)
expr_stmt|;
comment|/* change origin's next snap */
name|dmu_buf_will_dirty
argument_list|(
name|origin_ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|oldnext_obj
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
name|snap
operator|=
name|list_tail
argument_list|(
operator|&
name|ddpa
operator|->
name|clone_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|=
name|snap
operator|->
name|ds
operator|->
name|ds_object
expr_stmt|;
comment|/* change the origin's next clone */
if|if
condition|(
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
condition|)
block|{
name|dsl_dataset_remove_from_next_clones
argument_list|(
name|origin_ds
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|oldnext_obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* change origin */
name|dmu_buf_will_dirty
argument_list|(
name|dd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
operator|==
argument_list|,
name|origin_ds
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|odd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
expr_stmt|;
name|dd
operator|->
name|dd_origin_txg
operator|=
name|origin_head
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|odd
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|odd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|origin_ds
operator|->
name|ds_object
expr_stmt|;
name|origin_head
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
operator|=
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
comment|/* change dd_clone entries */
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|odd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|hds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ddpa
operator|->
name|origin_origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|hds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ddpa
operator|->
name|origin_origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|origin_head
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|==
literal|0
condition|)
block|{
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|=
name|zap_create
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_OT_DSL_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|origin_head
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* move snapshots to this dir */
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|snap
operator|->
name|ds
decl_stmt|;
comment|/* 		 * Property callbacks are registered to a particular 		 * dsl_dir.  Since ours is changing, evict the objset 		 * so that they will be unregistered from the old dsl_dir. 		 */
if|if
condition|(
name|ds
operator|->
name|ds_objset
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* move snap name entry */
name|VERIFY0
argument_list|(
name|dsl_dataset_get_snapname
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_snap_remove
argument_list|(
name|origin_head
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
name|tx
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|hds
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
name|ds
operator|->
name|ds_snapname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_fs_ss_count_adjust
argument_list|(
name|hds
operator|->
name|ds_dir
argument_list|,
literal|1
argument_list|,
name|DD_FIELD_SNAPSHOT_COUNT
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* change containing dsl_dir */
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
argument_list|,
operator|==
argument_list|,
name|odd
operator|->
name|dd_object
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_dir_obj
operator|=
name|dd
operator|->
name|dd_object
expr_stmt|;
name|ASSERT3P
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
operator|==
argument_list|,
name|odd
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_object
argument_list|,
name|NULL
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move any clone references */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|&&
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|dsl_dataset_t
modifier|*
name|cnds
decl_stmt|;
name|uint64_t
name|o
decl_stmt|;
if|if
condition|(
name|za
operator|.
name|za_first_integer
operator|==
name|oldnext_obj
condition|)
block|{
comment|/* 					 * We've already moved the 					 * origin's reference. 					 */
continue|continue;
block|}
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|cnds
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|=
name|cnds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_remove_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|odd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|o
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|o
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|cnds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|dsl_prop_hascb
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Change space accounting. 	 * Note, pa->*usedsnap and dd_used_breakdown[SNAP] will either 	 * both be valid, or both be 0 (resulting in delta == 0).  This 	 * is true for each of {clone,origin} independently. 	 */
name|delta
operator|=
name|ddpa
operator|->
name|cloneusedsnap
operator|-
name|dd
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|delta
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ddpa
operator|->
name|used
argument_list|,
operator|>=
argument_list|,
name|delta
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dd
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|dd
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|ddpa
operator|->
name|used
operator|-
name|delta
argument_list|,
name|ddpa
operator|->
name|comp
argument_list|,
name|ddpa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ddpa
operator|->
name|originusedsnap
operator|-
name|odd
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|delta
argument_list|,
operator|<=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|ddpa
operator|->
name|used
argument_list|,
operator|>=
argument_list|,
operator|-
name|delta
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|odd
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|odd
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|ddpa
operator|->
name|used
operator|-
name|delta
argument_list|,
operator|-
name|ddpa
operator|->
name|comp
argument_list|,
operator|-
name|ddpa
operator|->
name|uncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin_ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|=
name|ddpa
operator|->
name|unique
expr_stmt|;
comment|/* log history record */
name|spa_history_log_internal_ds
argument_list|(
name|hds
argument_list|,
literal|"promote"
argument_list|,
name|tx
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|dsl_dir_rele
argument_list|(
name|odd
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|promote_rele
argument_list|(
name|ddpa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make a list of dsl_dataset_t's for the snapshots between first_obj  * (exclusive) and last_obj (inclusive).  The list will be in reverse  * order (last_obj will be the list_head()).  If first_obj == 0, do all  * snapshots back to this dataset's origin.  */
end_comment

begin_function
specifier|static
name|int
name|snaplist_make
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|first_obj
parameter_list|,
name|uint64_t
name|last_obj
parameter_list|,
name|list_t
modifier|*
name|l
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|uint64_t
name|obj
init|=
name|last_obj
decl_stmt|;
name|list_create
argument_list|(
name|l
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|promotenode
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|promotenode
argument_list|,
name|link
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|obj
operator|!=
name|first_obj
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|tag
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|!=
name|ENOENT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|first_obj
operator|==
literal|0
condition|)
name|first_obj
operator|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
expr_stmt|;
name|snap
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|snap
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|snap
operator|->
name|ds
operator|=
name|ds
expr_stmt|;
name|list_insert_tail
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
expr_stmt|;
name|obj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|snaplist_space
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|uint64_t
modifier|*
name|spacep
parameter_list|)
block|{
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
operator|*
name|spacep
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|snap
operator|=
name|list_head
argument_list|(
name|l
argument_list|)
init|;
name|snap
condition|;
name|snap
operator|=
name|list_next
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
control|)
block|{
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|snap
operator|->
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|mintxg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
operator|*
name|spacep
operator|+=
name|used
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|snaplist_destroy
parameter_list|(
name|list_t
modifier|*
name|l
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
if|if
condition|(
name|l
operator|==
name|NULL
operator|||
operator|!
name|list_link_active
argument_list|(
operator|&
name|l
operator|->
name|list_head
argument_list|)
condition|)
return|return;
while|while
condition|(
operator|(
name|snap
operator|=
name|list_tail
argument_list|(
name|l
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
name|l
argument_list|,
name|snap
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|snap
operator|->
name|ds
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|snap
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|snap
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|promote_hold
parameter_list|(
name|dsl_dataset_promote_arg_t
modifier|*
name|ddpa
parameter_list|,
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|struct
name|promotenode
modifier|*
name|snap
decl_stmt|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddpa
operator|->
name|ddpa_clonename
argument_list|,
name|tag
argument_list|,
operator|&
name|ddpa
operator|->
name|ddpa_clone
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dd
operator|=
name|ddpa
operator|->
name|ddpa_clone
operator|->
name|ds_dir
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ddpa
operator|->
name|ddpa_clone
argument_list|)
operator|||
operator|!
name|dsl_dir_is_clone
argument_list|(
name|dd
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ddpa
operator|->
name|ddpa_clone
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
literal|0
argument_list|,
name|ddpa
operator|->
name|ddpa_clone
operator|->
name|ds_object
argument_list|,
operator|&
name|ddpa
operator|->
name|clone_snaps
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|snap
operator|=
name|list_head
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snap
operator|->
name|ds
operator|->
name|ds_object
argument_list|,
operator|==
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|)
expr_stmt|;
name|error
operator|=
name|snaplist_make
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
operator|&
name|ddpa
operator|->
name|origin_snaps
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|snap
operator|->
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|tag
argument_list|,
operator|&
name|ddpa
operator|->
name|origin_origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|promote_rele
argument_list|(
name|ddpa
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|promote_rele
parameter_list|(
name|dsl_dataset_promote_arg_t
modifier|*
name|ddpa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|snaplist_destroy
argument_list|(
operator|&
name|ddpa
operator|->
name|shared_snaps
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|snaplist_destroy
argument_list|(
operator|&
name|ddpa
operator|->
name|clone_snaps
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|snaplist_destroy
argument_list|(
operator|&
name|ddpa
operator|->
name|origin_snaps
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddpa
operator|->
name|origin_origin
operator|!=
name|NULL
condition|)
name|dsl_dataset_rele
argument_list|(
name|ddpa
operator|->
name|origin_origin
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ddpa
operator|->
name|ddpa_clone
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Promote a clone.  *  * If it fails due to a conflicting snapshot name, "conflsnap" will be filled  * in with the name.  (It must be at least MAXNAMELEN bytes long.)  */
end_comment

begin_function
name|int
name|dsl_dataset_promote
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|conflsnap
parameter_list|)
block|{
name|dsl_dataset_promote_arg_t
name|ddpa
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint64_t
name|numsnaps
decl_stmt|;
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
comment|/* 	 * We will modify space proportional to the number of 	 * snapshots.  Compute numsnaps. 	 */
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zap_count
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
operator|->
name|dp_meta_objset
argument_list|,
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
operator|->
name|ds_phys
operator|->
name|ds_snapnames_zapobj
argument_list|,
operator|&
name|numsnaps
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ddpa
operator|.
name|ddpa_clonename
operator|=
name|name
expr_stmt|;
name|ddpa
operator|.
name|err_ds
operator|=
name|conflsnap
expr_stmt|;
name|ddpa
operator|.
name|cr
operator|=
name|CRED
argument_list|()
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|name
argument_list|,
name|dsl_dataset_promote_check
argument_list|,
name|dsl_dataset_promote_sync
argument_list|,
operator|&
name|ddpa
argument_list|,
literal|2
operator|+
name|numsnaps
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_clone_swap_check_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|clone
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin_head
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|void
modifier|*
name|owner
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int64_t
name|unused_refres_delta
decl_stmt|;
comment|/* they should both be heads */
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|clone
argument_list|)
operator|||
name|dsl_dataset_is_snapshot
argument_list|(
name|origin_head
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* if we are not forcing, the branch point should be just before them */
if|if
condition|(
operator|!
name|force
operator|&&
name|clone
operator|->
name|ds_prev
operator|!=
name|origin_head
operator|->
name|ds_prev
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* clone should be the clone (unless they are unrelated) */
if|if
condition|(
name|clone
operator|->
name|ds_prev
operator|!=
name|NULL
operator|&&
name|clone
operator|->
name|ds_prev
operator|!=
name|clone
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_origin_snap
operator|&&
name|origin_head
operator|->
name|ds_dir
operator|!=
name|clone
operator|->
name|ds_prev
operator|->
name|ds_dir
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* the clone should be a child of the origin */
if|if
condition|(
name|clone
operator|->
name|ds_dir
operator|->
name|dd_parent
operator|!=
name|origin_head
operator|->
name|ds_dir
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* origin_head shouldn't be modified unless 'force' */
if|if
condition|(
operator|!
name|force
operator|&&
name|dsl_dataset_modified_since_snap
argument_list|(
name|origin_head
argument_list|,
name|origin_head
operator|->
name|ds_prev
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ETXTBSY
argument_list|)
operator|)
return|;
comment|/* origin_head should have no long holds (e.g. is not mounted) */
if|if
condition|(
name|dsl_dataset_handoff_check
argument_list|(
name|origin_head
argument_list|,
name|owner
argument_list|,
name|tx
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* check amount of any unconsumed refreservation */
name|unused_refres_delta
operator|=
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|origin_head
operator|->
name|ds_reserved
argument_list|,
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
operator|-
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|origin_head
operator|->
name|ds_reserved
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|unused_refres_delta
operator|>
literal|0
operator|&&
name|unused_refres_delta
operator|>
name|dsl_dir_space_available
argument_list|(
name|origin_head
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|TRUE
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
comment|/* clone can't be over the head's refquota */
if|if
condition|(
name|origin_head
operator|->
name|ds_quota
operator|!=
literal|0
operator|&&
name|clone
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|>
name|origin_head
operator|->
name|ds_quota
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_clone_swap_sync_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|clone
parameter_list|,
name|dsl_dataset_t
modifier|*
name|origin_head
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|int64_t
name|unused_refres_delta
decl_stmt|;
name|ASSERT
argument_list|(
name|clone
operator|->
name|ds_reserved
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|origin_head
operator|->
name|ds_quota
operator|==
literal|0
operator|||
name|clone
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|<=
name|origin_head
operator|->
name|ds_quota
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|clone
operator|->
name|ds_prev
argument_list|,
operator|==
argument_list|,
name|origin_head
operator|->
name|ds_prev
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|clone
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|origin_head
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|clone
operator|->
name|ds_objset
operator|!=
name|NULL
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|clone
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|clone
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|origin_head
operator|->
name|ds_objset
operator|!=
name|NULL
condition|)
block|{
name|dmu_objset_evict
argument_list|(
name|origin_head
operator|->
name|ds_objset
argument_list|)
expr_stmt|;
name|origin_head
operator|->
name|ds_objset
operator|=
name|NULL
expr_stmt|;
block|}
name|unused_refres_delta
operator|=
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|origin_head
operator|->
name|ds_reserved
argument_list|,
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
operator|-
operator|(
name|int64_t
operator|)
name|MIN
argument_list|(
name|origin_head
operator|->
name|ds_reserved
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
comment|/* 	 * Reset origin's unique bytes, if it exists. 	 */
if|if
condition|(
name|clone
operator|->
name|ds_prev
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|origin
init|=
name|clone
operator|->
name|ds_prev
decl_stmt|;
name|uint64_t
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|clone
operator|->
name|ds_deadlist
argument_list|,
name|origin
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|origin
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
block|}
comment|/* swap blkptrs */
block|{
name|blkptr_t
name|tmp
decl_stmt|;
name|tmp
operator|=
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|clone
operator|->
name|ds_phys
operator|->
name|ds_bp
expr_stmt|;
name|clone
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* set dd_*_bytes */
block|{
name|int64_t
name|dused
decl_stmt|,
name|dcomp
decl_stmt|,
name|duncomp
decl_stmt|;
name|uint64_t
name|cdl_used
decl_stmt|,
name|cdl_comp
decl_stmt|,
name|cdl_uncomp
decl_stmt|;
name|uint64_t
name|odl_used
decl_stmt|,
name|odl_comp
decl_stmt|,
name|odl_uncomp
decl_stmt|;
name|ASSERT3U
argument_list|(
name|clone
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_used_breakdown
index|[
name|DD_USED_SNAP
index|]
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_deadlist_space
argument_list|(
operator|&
name|clone
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|cdl_used
argument_list|,
operator|&
name|cdl_comp
argument_list|,
operator|&
name|cdl_uncomp
argument_list|)
expr_stmt|;
name|dsl_deadlist_space
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|odl_used
argument_list|,
operator|&
name|odl_comp
argument_list|,
operator|&
name|odl_uncomp
argument_list|)
expr_stmt|;
name|dused
operator|=
name|clone
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+
name|cdl_used
operator|-
operator|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+
name|odl_used
operator|)
expr_stmt|;
name|dcomp
operator|=
name|clone
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+
name|cdl_comp
operator|-
operator|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
operator|+
name|odl_comp
operator|)
expr_stmt|;
name|duncomp
operator|=
name|clone
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+
name|cdl_uncomp
operator|-
operator|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
operator|+
name|odl_uncomp
operator|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|origin_head
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|dused
argument_list|,
name|dcomp
argument_list|,
name|duncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|clone
operator|->
name|ds_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
operator|-
name|dused
argument_list|,
operator|-
name|dcomp
argument_list|,
operator|-
name|duncomp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 		 * The difference in the space used by snapshots is the 		 * difference in snapshot space due to the head's 		 * deadlist (since that's the only thing that's 		 * changing that affects the snapused). 		 */
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|clone
operator|->
name|ds_deadlist
argument_list|,
name|origin_head
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|cdl_used
argument_list|,
operator|&
name|cdl_comp
argument_list|,
operator|&
name|cdl_uncomp
argument_list|)
expr_stmt|;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_deadlist
argument_list|,
name|origin_head
operator|->
name|ds_dir
operator|->
name|dd_origin_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|odl_used
argument_list|,
operator|&
name|odl_comp
argument_list|,
operator|&
name|odl_uncomp
argument_list|)
expr_stmt|;
name|dsl_dir_transfer_space
argument_list|(
name|origin_head
operator|->
name|ds_dir
argument_list|,
name|cdl_used
operator|-
name|odl_used
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|DD_USED_SNAP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* swap ds_*_bytes */
name|SWITCH64
argument_list|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
comment|/* apply any parent delta for change in unconsumed refreservation */
name|dsl_dir_diduse_space
argument_list|(
name|origin_head
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|unused_refres_delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Swap deadlists. 	 */
name|dsl_deadlist_close
argument_list|(
operator|&
name|clone
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|dsl_deadlist_close
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_deadlist
argument_list|)
expr_stmt|;
name|SWITCH64
argument_list|(
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|clone
operator|->
name|ds_deadlist
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|clone
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_deadlist_open
argument_list|(
operator|&
name|origin_head
operator|->
name|ds_deadlist
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|origin_head
operator|->
name|ds_phys
operator|->
name|ds_deadlist_obj
argument_list|)
expr_stmt|;
name|dsl_scan_ds_clone_swapped
argument_list|(
name|origin_head
argument_list|,
name|clone
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_log_internal_ds
argument_list|(
name|clone
argument_list|,
literal|"clone swap"
argument_list|,
name|tx
argument_list|,
literal|"parent=%s"
argument_list|,
name|origin_head
operator|->
name|ds_dir
operator|->
name|dd_myname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a pool name and a dataset object number in that pool,  * return the name of that dataset.  */
end_comment

begin_function
name|int
name|dsl_dsobj_to_dsname
parameter_list|(
name|char
modifier|*
name|pname
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dsl_pool_hold
argument_list|(
name|pname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|dsl_pool_rele
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_check_quota
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|boolean_t
name|check_quota
parameter_list|,
name|uint64_t
name|asize
parameter_list|,
name|uint64_t
name|inflight
parameter_list|,
name|uint64_t
modifier|*
name|used
parameter_list|,
name|uint64_t
modifier|*
name|ref_rsrv
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT3S
argument_list|(
name|asize
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * *ref_rsrv is the portion of asize that will come from any 	 * unconsumed refreservation space. 	 */
operator|*
name|ref_rsrv
operator|=
literal|0
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Make a space adjustment for reserved bytes. 	 */
if|if
condition|(
name|ds
operator|->
name|ds_reserved
operator|>
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
condition|)
block|{
name|ASSERT3U
argument_list|(
operator|*
name|used
argument_list|,
operator|>=
argument_list|,
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
argument_list|)
expr_stmt|;
operator|*
name|used
operator|-=
operator|(
name|ds
operator|->
name|ds_reserved
operator|-
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
operator|)
expr_stmt|;
operator|*
name|ref_rsrv
operator|=
name|asize
operator|-
name|MIN
argument_list|(
name|asize
argument_list|,
name|parent_delta
argument_list|(
name|ds
argument_list|,
name|asize
operator|+
name|inflight
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|check_quota
operator|||
name|ds
operator|->
name|ds_quota
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If they are requesting more space, and our current estimate 	 * is over quota, they get to try again unless the actual 	 * on-disk is over quota and there are no pending changes (which 	 * may free up space for us). 	 */
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|+
name|inflight
operator|>=
name|ds
operator|->
name|ds_quota
condition|)
block|{
if|if
condition|(
name|inflight
operator|>
literal|0
operator|||
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|<
name|ds
operator|->
name|ds_quota
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ERESTART
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|dsl_dataset_set_qr_arg
block|{
specifier|const
name|char
modifier|*
name|ddsqra_name
decl_stmt|;
name|zprop_source_t
name|ddsqra_source
decl_stmt|;
name|uint64_t
name|ddsqra_value
decl_stmt|;
block|}
name|dsl_dataset_set_qr_arg_t
typedef|;
end_typedef

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|dsl_dataset_set_refquota_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_set_qr_arg_t
modifier|*
name|ddsqra
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|newval
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_REFQUOTA
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddsqra
operator|->
name|ddsqra_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dsl_prop_predict
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFQUOTA
argument_list|)
argument_list|,
name|ddsqra
operator|->
name|ddsqra_source
argument_list|,
name|ddsqra
operator|->
name|ddsqra_value
argument_list|,
operator|&
name|newval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|newval
operator|==
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|newval
operator|<
name|ds
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
operator|||
name|newval
operator|<
name|ds
operator|->
name|ds_reserved
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_set_refquota_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_set_qr_arg_t
modifier|*
name|ddsqra
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|newval
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddsqra
operator|->
name|ddsqra_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_prop_set_sync_impl
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFQUOTA
argument_list|)
argument_list|,
name|ddsqra
operator|->
name|ddsqra_source
argument_list|,
sizeof|sizeof
argument_list|(
name|ddsqra
operator|->
name|ddsqra_value
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|ddsqra
operator|->
name|ddsqra_value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_prop_get_int_ds
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFQUOTA
argument_list|)
argument_list|,
operator|&
name|newval
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_quota
operator|!=
name|newval
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_quota
operator|=
name|newval
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_set_refquota
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|uint64_t
name|refquota
parameter_list|)
block|{
name|dsl_dataset_set_qr_arg_t
name|ddsqra
decl_stmt|;
name|ddsqra
operator|.
name|ddsqra_name
operator|=
name|dsname
expr_stmt|;
name|ddsqra
operator|.
name|ddsqra_source
operator|=
name|source
expr_stmt|;
name|ddsqra
operator|.
name|ddsqra_value
operator|=
name|refquota
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|dsname
argument_list|,
name|dsl_dataset_set_refquota_check
argument_list|,
name|dsl_dataset_set_refquota_sync
argument_list|,
operator|&
name|ddsqra
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_dataset_set_refreservation_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_set_qr_arg_t
modifier|*
name|ddsqra
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|newval
decl_stmt|,
name|unique
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|<
name|SPA_VERSION_REFRESERVATION
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
name|error
operator|=
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddsqra
operator|->
name|ddsqra_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|ds
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|dsl_prop_predict
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
name|ddsqra
operator|->
name|ddsqra_source
argument_list|,
name|ddsqra
operator|->
name|ddsqra_value
argument_list|,
operator|&
name|newval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we are doing the preliminary check in open context, the 	 * space estimates may be inaccurate. 	 */
if|if
condition|(
operator|!
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
condition|)
name|dsl_dataset_recalc_head_uniq
argument_list|(
name|ds
argument_list|)
expr_stmt|;
name|unique
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|MAX
argument_list|(
name|unique
argument_list|,
name|newval
argument_list|)
operator|>
name|MAX
argument_list|(
name|unique
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
condition|)
block|{
name|uint64_t
name|delta
init|=
name|MAX
argument_list|(
name|unique
argument_list|,
name|newval
argument_list|)
operator|-
name|MAX
argument_list|(
name|unique
argument_list|,
name|ds
operator|->
name|ds_reserved
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|>
name|dsl_dir_space_available
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|B_TRUE
argument_list|)
operator|||
operator|(
name|ds
operator|->
name|ds_quota
operator|>
literal|0
operator|&&
name|newval
operator|>
name|ds
operator|->
name|ds_quota
operator|)
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_set_refreservation_sync_impl
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|uint64_t
name|value
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|newval
decl_stmt|;
name|uint64_t
name|unique
decl_stmt|;
name|int64_t
name|delta
decl_stmt|;
name|dsl_prop_set_sync_impl
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
name|source
argument_list|,
sizeof|sizeof
argument_list|(
name|value
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_prop_get_int_ds
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
operator|&
name|newval
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|DS_UNIQUE_IS_ACCURATE
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|unique
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_unique_bytes
expr_stmt|;
name|delta
operator|=
name|MAX
argument_list|(
literal|0
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|newval
operator|-
name|unique
argument_list|)
argument_list|)
operator|-
name|MAX
argument_list|(
literal|0
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|ds
operator|->
name|ds_reserved
operator|-
name|unique
argument_list|)
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_reserved
operator|=
name|newval
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_lock
argument_list|)
expr_stmt|;
name|dsl_dir_diduse_space
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|,
name|DD_USED_REFRSRV
argument_list|,
name|delta
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_dir
operator|->
name|dd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_dataset_set_refreservation_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_dataset_set_qr_arg_t
modifier|*
name|ddsqra
init|=
name|arg
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold
argument_list|(
name|dp
argument_list|,
name|ddsqra
operator|->
name|ddsqra_name
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_set_refreservation_sync_impl
argument_list|(
name|ds
argument_list|,
name|ddsqra
operator|->
name|ddsqra_source
argument_list|,
name|ddsqra
operator|->
name|ddsqra_value
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|dsl_dataset_set_refreservation
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|zprop_source_t
name|source
parameter_list|,
name|uint64_t
name|refreservation
parameter_list|)
block|{
name|dsl_dataset_set_qr_arg_t
name|ddsqra
decl_stmt|;
name|ddsqra
operator|.
name|ddsqra_name
operator|=
name|dsname
expr_stmt|;
name|ddsqra
operator|.
name|ddsqra_source
operator|=
name|source
expr_stmt|;
name|ddsqra
operator|.
name|ddsqra_value
operator|=
name|refreservation
expr_stmt|;
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|dsname
argument_list|,
name|dsl_dataset_set_refreservation_check
argument_list|,
name|dsl_dataset_set_refreservation_sync
argument_list|,
operator|&
name|ddsqra
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return (in *usedp) the amount of space written in new that is not  * present in oldsnap.  New may be a snapshot or the head.  Old must be  * a snapshot before new, in new's filesystem (or its origin).  If not then  * fail and return EINVAL.  *  * The written space is calculated by considering two components:  First, we  * ignore any freed space, and calculate the written as new's used space  * minus old's used space.  Next, we add in the amount of space that was freed  * between the two snapshots, thus reducing new's used space relative to old's.  * Specifically, this is the space that was born before old->ds_creation_txg,  * and freed before new (ie. on new's deadlist or a previous deadlist).  *  * space freed                         [---------------------]  * snapshots                       ---O-------O--------O-------O------  *                                         oldsnap            new  */
end_comment

begin_function
name|int
name|dsl_dataset_space_written
parameter_list|(
name|dsl_dataset_t
modifier|*
name|oldsnap
parameter_list|,
name|dsl_dataset_t
modifier|*
name|new
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|,
name|uint64_t
modifier|*
name|compp
parameter_list|,
name|uint64_t
modifier|*
name|uncompp
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uint64_t
name|snapobj
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|new
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|usedp
operator|=
literal|0
expr_stmt|;
operator|*
name|usedp
operator|+=
name|new
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
operator|*
name|usedp
operator|-=
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_referenced_bytes
expr_stmt|;
operator|*
name|compp
operator|=
literal|0
expr_stmt|;
operator|*
name|compp
operator|+=
name|new
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
operator|*
name|compp
operator|-=
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_compressed_bytes
expr_stmt|;
operator|*
name|uncompp
operator|=
literal|0
expr_stmt|;
operator|*
name|uncompp
operator|+=
name|new
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
operator|*
name|uncompp
operator|-=
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_uncompressed_bytes
expr_stmt|;
name|snapobj
operator|=
name|new
operator|->
name|ds_object
expr_stmt|;
while|while
condition|(
name|snapobj
operator|!=
name|oldsnap
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|snap
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
if|if
condition|(
name|snapobj
operator|==
name|new
operator|->
name|ds_object
condition|)
block|{
name|snap
operator|=
name|new
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|snapobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|snap
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
block|}
if|if
condition|(
name|snap
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|==
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
block|{
comment|/* 			 * The blocks in the deadlist can not be born after 			 * ds_prev_snap_txg, so get the whole deadlist space, 			 * which is more efficient (especially for old-format 			 * deadlists).  Unfortunately the deadlist code 			 * doesn't have enough information to make this 			 * optimization itself. 			 */
name|dsl_deadlist_space
argument_list|(
operator|&
name|snap
operator|->
name|ds_deadlist
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|snap
operator|->
name|ds_deadlist
argument_list|,
literal|0
argument_list|,
name|oldsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
block|}
operator|*
name|usedp
operator|+=
name|used
expr_stmt|;
operator|*
name|compp
operator|+=
name|comp
expr_stmt|;
operator|*
name|uncompp
operator|+=
name|uncomp
expr_stmt|;
comment|/* 		 * If we get to the beginning of the chain of snapshots 		 * (ds_prev_snap_obj == 0) before oldsnap, then oldsnap 		 * was not a snapshot of/before new. 		 */
name|snapobj
operator|=
name|snap
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
if|if
condition|(
name|snap
operator|!=
name|new
condition|)
name|dsl_dataset_rele
argument_list|(
name|snap
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|snapobj
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return (in *usedp) the amount of space that will be reclaimed if firstsnap,  * lastsnap, and all snapshots in between are deleted.  *  * blocks that would be freed            [---------------------------]  * snapshots                       ---O-------O--------O-------O--------O  *                                        firstsnap        lastsnap  *  * This is the set of blocks that were born after the snap before firstsnap,  * (birth> firstsnap->prev_snap_txg) and died before the snap after the  * last snap (ie, is on lastsnap->ds_next->ds_deadlist or an earlier deadlist).  * We calculate this by iterating over the relevant deadlists (from the snap  * after lastsnap, backward to the snap after firstsnap), summing up the  * space on the deadlist that was born after the snap before firstsnap.  */
end_comment

begin_function
name|int
name|dsl_dataset_space_wouldfree
parameter_list|(
name|dsl_dataset_t
modifier|*
name|firstsnap
parameter_list|,
name|dsl_dataset_t
modifier|*
name|lastsnap
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|,
name|uint64_t
modifier|*
name|compp
parameter_list|,
name|uint64_t
modifier|*
name|uncompp
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
name|uint64_t
name|snapobj
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|firstsnap
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_is_snapshot
argument_list|(
name|firstsnap
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_is_snapshot
argument_list|(
name|lastsnap
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check that the snapshots are in the same dsl_dir, and firstsnap 	 * is before lastsnap. 	 */
if|if
condition|(
name|firstsnap
operator|->
name|ds_dir
operator|!=
name|lastsnap
operator|->
name|ds_dir
operator|||
name|firstsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
operator|>
name|lastsnap
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
operator|*
name|usedp
operator|=
operator|*
name|compp
operator|=
operator|*
name|uncompp
operator|=
literal|0
expr_stmt|;
name|snapobj
operator|=
name|lastsnap
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
expr_stmt|;
while|while
condition|(
name|snapobj
operator|!=
name|firstsnap
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|snapobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
break|break;
name|dsl_deadlist_space_range
argument_list|(
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|firstsnap
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
argument_list|,
name|UINT64_MAX
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
expr_stmt|;
operator|*
name|usedp
operator|+=
name|used
expr_stmt|;
operator|*
name|compp
operator|+=
name|comp
expr_stmt|;
operator|*
name|uncompp
operator|+=
name|uncomp
expr_stmt|;
name|snapobj
operator|=
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
expr_stmt|;
name|ASSERT3U
argument_list|(
name|snapobj
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return TRUE if 'earlier' is an earlier snapshot in 'later's timeline.  * For example, they could both be snapshots of the same filesystem, and  * 'earlier' is before 'later'.  Or 'earlier' could be the origin of  * 'later's filesystem.  Or 'earlier' could be an older snapshot in the origin's  * filesystem.  Or 'earlier' could be the origin's origin.  *  * If non-zero, earlier_txg is used instead of earlier's ds_creation_txg.  */
end_comment

begin_function
name|boolean_t
name|dsl_dataset_is_before
parameter_list|(
name|dsl_dataset_t
modifier|*
name|later
parameter_list|,
name|dsl_dataset_t
modifier|*
name|earlier
parameter_list|,
name|uint64_t
name|earlier_txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|later
operator|->
name|ds_dir
operator|->
name|dd_pool
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|ret
decl_stmt|;
name|ASSERT
argument_list|(
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dsl_dataset_is_snapshot
argument_list|(
name|earlier
argument_list|)
operator|||
name|earlier_txg
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|earlier_txg
operator|==
literal|0
condition|)
name|earlier_txg
operator|=
name|earlier
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
if|if
condition|(
name|dsl_dataset_is_snapshot
argument_list|(
name|later
argument_list|)
operator|&&
name|earlier_txg
operator|>=
name|later
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|later
operator|->
name|ds_dir
operator|==
name|earlier
operator|->
name|ds_dir
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
if|if
condition|(
operator|!
name|dsl_dir_is_clone
argument_list|(
name|later
operator|->
name|ds_dir
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
name|later
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|==
name|earlier
operator|->
name|ds_object
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
name|dsl_dataset_t
modifier|*
name|origin
decl_stmt|;
name|error
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|later
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|ret
operator|=
name|dsl_dataset_is_before
argument_list|(
name|origin
argument_list|,
name|earlier
argument_list|,
name|earlier_txg
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_dataset_zapify
parameter_list|(
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|ds
operator|->
name|ds_dir
operator|->
name|dd_pool
operator|->
name|dp_meta_objset
decl_stmt|;
name|dmu_object_zapify
argument_list|(
name|mos
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|DMU_OT_DSL_DATASET
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

