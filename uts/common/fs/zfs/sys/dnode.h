begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2016 by Delphix. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_DNODE_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_DNODE_H
end_define

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_zfetch.h>
end_include

begin_include
include|#
directive|include
file|<sys/zrlock.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * dnode_hold() flags.  */
define|#
directive|define
name|DNODE_MUST_BE_ALLOCATED
value|1
define|#
directive|define
name|DNODE_MUST_BE_FREE
value|2
comment|/*  * dnode_next_offset() flags.  */
define|#
directive|define
name|DNODE_FIND_HOLE
value|1
define|#
directive|define
name|DNODE_FIND_BACKWARDS
value|2
define|#
directive|define
name|DNODE_FIND_HAVELOCK
value|4
comment|/*  * Fixed constants.  */
define|#
directive|define
name|DNODE_SHIFT
value|9
comment|/* 512 bytes */
define|#
directive|define
name|DN_MIN_INDBLKSHIFT
value|12
comment|/* 4k */
comment|/*  * If we ever increase this value beyond 20, we need to revisit all logic that  * does x<< level * ebps to handle overflow.  With a 1M indirect block size,  * 4 levels of indirect blocks would not be able to guarantee addressing an  * entire object, so 5 levels will be used, but 5 * (20 - 7) = 65.  */
define|#
directive|define
name|DN_MAX_INDBLKSHIFT
value|17
comment|/* 128k */
define|#
directive|define
name|DNODE_BLOCK_SHIFT
value|14
comment|/* 16k */
define|#
directive|define
name|DNODE_CORE_SIZE
value|64
comment|/* 64 bytes for dnode sans blkptrs */
define|#
directive|define
name|DN_MAX_OBJECT_SHIFT
value|48
comment|/* 256 trillion (zfs_fid_t limit) */
define|#
directive|define
name|DN_MAX_OFFSET_SHIFT
value|64
comment|/* 2^64 bytes in a dnode */
comment|/*  * dnode id flags  *  * Note: a file will never ever have its  * ids moved from bonus->spill  * and only in a crypto environment would it be on spill  */
define|#
directive|define
name|DN_ID_CHKED_BONUS
value|0x1
define|#
directive|define
name|DN_ID_CHKED_SPILL
value|0x2
define|#
directive|define
name|DN_ID_OLD_EXIST
value|0x4
define|#
directive|define
name|DN_ID_NEW_EXIST
value|0x8
comment|/*  * Derived constants.  */
define|#
directive|define
name|DNODE_SIZE
value|(1<< DNODE_SHIFT)
define|#
directive|define
name|DN_MAX_NBLKPTR
value|((DNODE_SIZE - DNODE_CORE_SIZE)>> SPA_BLKPTRSHIFT)
define|#
directive|define
name|DN_MAX_BONUSLEN
value|(DNODE_SIZE - DNODE_CORE_SIZE - (1<< SPA_BLKPTRSHIFT))
define|#
directive|define
name|DN_MAX_OBJECT
value|(1ULL<< DN_MAX_OBJECT_SHIFT)
define|#
directive|define
name|DN_ZERO_BONUSLEN
value|(DN_MAX_BONUSLEN + 1)
define|#
directive|define
name|DN_KILL_SPILLBLK
value|(1)
define|#
directive|define
name|DNODES_PER_BLOCK_SHIFT
value|(DNODE_BLOCK_SHIFT - DNODE_SHIFT)
define|#
directive|define
name|DNODES_PER_BLOCK
value|(1ULL<< DNODES_PER_BLOCK_SHIFT)
comment|/*  * This is inaccurate if the indblkshift of the particular object is not the  * max.  But it's only used by userland to calculate the zvol reservation.  */
define|#
directive|define
name|DNODES_PER_LEVEL_SHIFT
value|(DN_MAX_INDBLKSHIFT - SPA_BLKPTRSHIFT)
define|#
directive|define
name|DNODES_PER_LEVEL
value|(1ULL<< DNODES_PER_LEVEL_SHIFT)
comment|/* The +2 here is a cheesy way to round up */
define|#
directive|define
name|DN_MAX_LEVELS
value|(2 + ((DN_MAX_OFFSET_SHIFT - SPA_MINBLOCKSHIFT) / \ 	(DN_MIN_INDBLKSHIFT - SPA_BLKPTRSHIFT)))
define|#
directive|define
name|DN_BONUS
parameter_list|(
name|dnp
parameter_list|)
value|((void*)((dnp)->dn_bonus + \ 	(((dnp)->dn_nblkptr - 1) * sizeof (blkptr_t))))
define|#
directive|define
name|DN_USED_BYTES
parameter_list|(
name|dnp
parameter_list|)
value|(((dnp)->dn_flags& DNODE_FLAG_USED_BYTES) ? \ 	(dnp)->dn_used : (dnp)->dn_used<< SPA_MINBLOCKSHIFT)
define|#
directive|define
name|EPB
parameter_list|(
name|blkshift
parameter_list|,
name|typeshift
parameter_list|)
value|(1<< (blkshift - typeshift))
struct_decl|struct
name|dmu_buf_impl
struct_decl|;
struct_decl|struct
name|objset
struct_decl|;
struct_decl|struct
name|zio
struct_decl|;
enum|enum
name|dnode_dirtycontext
block|{
name|DN_UNDIRTIED
block|,
name|DN_DIRTY_OPEN
block|,
name|DN_DIRTY_SYNC
block|}
enum|;
comment|/* Is dn_used in bytes?  if not, it's in multiples of SPA_MINBLOCKSIZE */
define|#
directive|define
name|DNODE_FLAG_USED_BYTES
value|(1<<0)
define|#
directive|define
name|DNODE_FLAG_USERUSED_ACCOUNTED
value|(1<<1)
comment|/* Does dnode have a SA spill blkptr in bonus? */
define|#
directive|define
name|DNODE_FLAG_SPILL_BLKPTR
value|(1<<2)
typedef|typedef
struct|struct
name|dnode_phys
block|{
name|uint8_t
name|dn_type
decl_stmt|;
comment|/* dmu_object_type_t */
name|uint8_t
name|dn_indblkshift
decl_stmt|;
comment|/* ln2(indirect block size) */
name|uint8_t
name|dn_nlevels
decl_stmt|;
comment|/* 1=dn_blkptr->data blocks */
name|uint8_t
name|dn_nblkptr
decl_stmt|;
comment|/* length of dn_blkptr */
name|uint8_t
name|dn_bonustype
decl_stmt|;
comment|/* type of data in bonus buffer */
name|uint8_t
name|dn_checksum
decl_stmt|;
comment|/* ZIO_CHECKSUM type */
name|uint8_t
name|dn_compress
decl_stmt|;
comment|/* ZIO_COMPRESS type */
name|uint8_t
name|dn_flags
decl_stmt|;
comment|/* DNODE_FLAG_* */
name|uint16_t
name|dn_datablkszsec
decl_stmt|;
comment|/* data block size in 512b sectors */
name|uint16_t
name|dn_bonuslen
decl_stmt|;
comment|/* length of dn_bonus */
name|uint8_t
name|dn_pad2
index|[
literal|4
index|]
decl_stmt|;
comment|/* accounting is protected by dn_dirty_mtx */
name|uint64_t
name|dn_maxblkid
decl_stmt|;
comment|/* largest allocated block ID */
name|uint64_t
name|dn_used
decl_stmt|;
comment|/* bytes (or sectors) of disk space */
name|uint64_t
name|dn_pad3
index|[
literal|4
index|]
decl_stmt|;
name|blkptr_t
name|dn_blkptr
index|[
literal|1
index|]
decl_stmt|;
name|uint8_t
name|dn_bonus
index|[
name|DN_MAX_BONUSLEN
operator|-
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
index|]
decl_stmt|;
name|blkptr_t
name|dn_spill
decl_stmt|;
block|}
name|dnode_phys_t
typedef|;
struct|struct
name|dnode
block|{
comment|/* 	 * Protects the structure of the dnode, including the number of levels 	 * of indirection (dn_nlevels), dn_maxblkid, and dn_next_* 	 */
name|krwlock_t
name|dn_struct_rwlock
decl_stmt|;
comment|/* Our link on dn_objset->os_dnodes list; protected by os_lock.  */
name|list_node_t
name|dn_link
decl_stmt|;
comment|/* immutable: */
name|struct
name|objset
modifier|*
name|dn_objset
decl_stmt|;
name|uint64_t
name|dn_object
decl_stmt|;
name|struct
name|dmu_buf_impl
modifier|*
name|dn_dbuf
decl_stmt|;
name|struct
name|dnode_handle
modifier|*
name|dn_handle
decl_stmt|;
name|dnode_phys_t
modifier|*
name|dn_phys
decl_stmt|;
comment|/* pointer into dn->dn_dbuf->db.db_data */
comment|/* 	 * Copies of stuff in dn_phys.  They're valid in the open 	 * context (eg. even before the dnode is first synced). 	 * Where necessary, these are protected by dn_struct_rwlock. 	 */
name|dmu_object_type_t
name|dn_type
decl_stmt|;
comment|/* object type */
name|uint16_t
name|dn_bonuslen
decl_stmt|;
comment|/* bonus length */
name|uint8_t
name|dn_bonustype
decl_stmt|;
comment|/* bonus type */
name|uint8_t
name|dn_nblkptr
decl_stmt|;
comment|/* number of blkptrs (immutable) */
name|uint8_t
name|dn_checksum
decl_stmt|;
comment|/* ZIO_CHECKSUM type */
name|uint8_t
name|dn_compress
decl_stmt|;
comment|/* ZIO_COMPRESS type */
name|uint8_t
name|dn_nlevels
decl_stmt|;
name|uint8_t
name|dn_indblkshift
decl_stmt|;
name|uint8_t
name|dn_datablkshift
decl_stmt|;
comment|/* zero if blksz not power of 2! */
name|uint8_t
name|dn_moved
decl_stmt|;
comment|/* Has this dnode been moved? */
name|uint16_t
name|dn_datablkszsec
decl_stmt|;
comment|/* in 512b sectors */
name|uint32_t
name|dn_datablksz
decl_stmt|;
comment|/* in bytes */
name|uint64_t
name|dn_maxblkid
decl_stmt|;
name|uint8_t
name|dn_next_type
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|uint8_t
name|dn_next_nblkptr
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|uint8_t
name|dn_next_nlevels
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|uint8_t
name|dn_next_indblkshift
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|uint8_t
name|dn_next_bonustype
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|uint8_t
name|dn_rm_spillblk
index|[
name|TXG_SIZE
index|]
decl_stmt|;
comment|/* for removing spill blk */
name|uint16_t
name|dn_next_bonuslen
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|uint32_t
name|dn_next_blksz
index|[
name|TXG_SIZE
index|]
decl_stmt|;
comment|/* next block size in bytes */
comment|/* protected by dn_dbufs_mtx; declared here to fill 32-bit hole */
name|uint32_t
name|dn_dbufs_count
decl_stmt|;
comment|/* count of dn_dbufs */
comment|/* protected by os_lock: */
name|list_node_t
name|dn_dirty_link
index|[
name|TXG_SIZE
index|]
decl_stmt|;
comment|/* next on dataset's dirty */
comment|/* protected by dn_mtx: */
name|kmutex_t
name|dn_mtx
decl_stmt|;
name|list_t
name|dn_dirty_records
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|struct
name|range_tree
modifier|*
name|dn_free_ranges
index|[
name|TXG_SIZE
index|]
decl_stmt|;
name|uint64_t
name|dn_allocated_txg
decl_stmt|;
name|uint64_t
name|dn_free_txg
decl_stmt|;
name|uint64_t
name|dn_assigned_txg
decl_stmt|;
name|kcondvar_t
name|dn_notxholds
decl_stmt|;
name|enum
name|dnode_dirtycontext
name|dn_dirtyctx
decl_stmt|;
name|uint8_t
modifier|*
name|dn_dirtyctx_firstset
decl_stmt|;
comment|/* dbg: contents meaningless */
comment|/* protected by own devices */
name|refcount_t
name|dn_tx_holds
decl_stmt|;
name|refcount_t
name|dn_holds
decl_stmt|;
name|kmutex_t
name|dn_dbufs_mtx
decl_stmt|;
comment|/* 	 * Descendent dbufs, ordered by dbuf_compare. Note that dn_dbufs 	 * can contain multiple dbufs of the same (level, blkid) when a 	 * dbuf is marked DB_EVICTING without being removed from 	 * dn_dbufs. To maintain the avl invariant that there cannot be 	 * duplicate entries, we order the dbufs by an arbitrary value - 	 * their address in memory. This means that dn_dbufs cannot be used to 	 * directly look up a dbuf. Instead, callers must use avl_walk, have 	 * a reference to the dbuf, or look up a non-existant node with 	 * db_state = DB_SEARCH (see dbuf_free_range for an example). 	 */
name|avl_tree_t
name|dn_dbufs
decl_stmt|;
comment|/* protected by dn_struct_rwlock */
name|struct
name|dmu_buf_impl
modifier|*
name|dn_bonus
decl_stmt|;
comment|/* bonus buffer dbuf */
name|boolean_t
name|dn_have_spill
decl_stmt|;
comment|/* have spill or are spilling */
comment|/* parent IO for current sync write */
name|zio_t
modifier|*
name|dn_zio
decl_stmt|;
comment|/* used in syncing context */
name|uint64_t
name|dn_oldused
decl_stmt|;
comment|/* old phys used bytes */
name|uint64_t
name|dn_oldflags
decl_stmt|;
comment|/* old phys dn_flags */
name|uint64_t
name|dn_olduid
decl_stmt|,
name|dn_oldgid
decl_stmt|;
name|uint64_t
name|dn_newuid
decl_stmt|,
name|dn_newgid
decl_stmt|;
name|int
name|dn_id_flags
decl_stmt|;
comment|/* holds prefetch structure */
name|struct
name|zfetch
name|dn_zfetch
decl_stmt|;
block|}
struct|;
comment|/*  * Adds a level of indirection between the dbuf and the dnode to avoid  * iterating descendent dbufs in dnode_move(). Handles are not allocated  * individually, but as an array of child dnodes in dnode_hold_impl().  */
typedef|typedef
struct|struct
name|dnode_handle
block|{
comment|/* Protects dnh_dnode from modification by dnode_move(). */
name|zrlock_t
name|dnh_zrlock
decl_stmt|;
name|dnode_t
modifier|*
name|dnh_dnode
decl_stmt|;
block|}
name|dnode_handle_t
typedef|;
typedef|typedef
struct|struct
name|dnode_children
block|{
name|dmu_buf_user_t
name|dnc_dbu
decl_stmt|;
comment|/* User evict data */
name|size_t
name|dnc_count
decl_stmt|;
comment|/* number of children */
name|dnode_handle_t
name|dnc_children
index|[]
decl_stmt|;
comment|/* sized dynamically */
block|}
name|dnode_children_t
typedef|;
typedef|typedef
struct|struct
name|free_range
block|{
name|avl_node_t
name|fr_node
decl_stmt|;
name|uint64_t
name|fr_blkid
decl_stmt|;
name|uint64_t
name|fr_nblks
decl_stmt|;
block|}
name|free_range_t
typedef|;
name|void
name|dnode_special_open
parameter_list|(
name|struct
name|objset
modifier|*
name|dd
parameter_list|,
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dnode_handle_t
modifier|*
name|dnh
parameter_list|)
function_decl|;
name|void
name|dnode_special_close
parameter_list|(
name|dnode_handle_t
modifier|*
name|dnh
parameter_list|)
function_decl|;
name|void
name|dnode_setbonuslen
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|newsize
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_setbonus_type
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_rm_spill
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dnode_hold
parameter_list|(
name|struct
name|objset
modifier|*
name|dd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|void
modifier|*
name|ref
parameter_list|,
name|dnode_t
modifier|*
modifier|*
name|dnp
parameter_list|)
function_decl|;
name|int
name|dnode_hold_impl
parameter_list|(
name|struct
name|objset
modifier|*
name|dd
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int
name|flag
parameter_list|,
name|void
modifier|*
name|ref
parameter_list|,
name|dnode_t
modifier|*
modifier|*
name|dnp
parameter_list|)
function_decl|;
name|boolean_t
name|dnode_add_ref
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|ref
parameter_list|)
function_decl|;
name|void
name|dnode_rele
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|ref
parameter_list|)
function_decl|;
name|void
name|dnode_rele_and_unlock
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|void
name|dnode_setdirty
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_sync
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_allocate
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_reallocate
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_free
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_byteswap
parameter_list|(
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|)
function_decl|;
name|void
name|dnode_buf_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|dnode_verify
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
function_decl|;
name|int
name|dnode_set_blksz
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_free_range
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dnode_diduse_space
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int64_t
name|space
parameter_list|)
function_decl|;
name|void
name|dnode_new_blkid
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
name|uint64_t
name|dnode_block_freed
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|)
function_decl|;
name|void
name|dnode_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|dnode_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|dnode_next_offset
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|flags
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|,
name|int
name|minlvl
parameter_list|,
name|uint64_t
name|blkfill
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
function_decl|;
name|void
name|dnode_evict_dbufs
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
function_decl|;
name|void
name|dnode_evict_bonus
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|)
function_decl|;
define|#
directive|define
name|DNODE_IS_CACHEABLE
parameter_list|(
name|_dn
parameter_list|)
define|\
value|((_dn)->dn_objset->os_primary_cache == ZFS_CACHE_ALL ||		\ 	(DMU_OT_IS_METADATA((_dn)->dn_type)&&				\ 	(_dn)->dn_objset->os_primary_cache == ZFS_CACHE_METADATA))
define|#
directive|define
name|DNODE_META_IS_CACHEABLE
parameter_list|(
name|_dn
parameter_list|)
define|\
value|((_dn)->dn_objset->os_primary_cache == ZFS_CACHE_ALL ||		\ 	(_dn)->dn_objset->os_primary_cache == ZFS_CACHE_METADATA)
ifdef|#
directive|ifdef
name|ZFS_DEBUG
comment|/*  * There should be a ## between the string literal and fmt, to make it  * clear that we're joining two strings together, but that piece of shit  * gcc doesn't support that preprocessor token.  */
define|#
directive|define
name|dprintf_dnode
parameter_list|(
name|dn
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do { \ 	if (zfs_flags& ZFS_DEBUG_DPRINTF) { \ 	char __db_buf[32]; \ 	uint64_t __db_obj = (dn)->dn_object; \ 	if (__db_obj == DMU_META_DNODE_OBJECT) \ 		(void) strcpy(__db_buf, "mdn"); \ 	else \ 		(void) snprintf(__db_buf, sizeof (__db_buf), "%lld", \ 		    (u_longlong_t)__db_obj);\ 	dprintf_ds((dn)->dn_objset->os_dsl_dataset, "obj=%s " fmt, \ 	    __db_buf, __VA_ARGS__); \ 	} \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|DNODE_VERIFY
parameter_list|(
name|dn
parameter_list|)
value|dnode_verify(dn)
define|#
directive|define
name|FREE_VERIFY
parameter_list|(
name|db
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|tx
parameter_list|)
value|free_verify(db, start, end, tx)
else|#
directive|else
define|#
directive|define
name|dprintf_dnode
parameter_list|(
name|db
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
define|#
directive|define
name|DNODE_VERIFY
parameter_list|(
name|dn
parameter_list|)
define|#
directive|define
name|FREE_VERIFY
parameter_list|(
name|db
parameter_list|,
name|start
parameter_list|,
name|end
parameter_list|,
name|tx
parameter_list|)
endif|#
directive|endif
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_DNODE_H */
end_comment

end_unit

