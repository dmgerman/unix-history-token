begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2016 by Delphix. All rights reserved.  * Copyright 2011 Nexenta Systems, Inc. All rights reserved.  * Copyright (c) 2012, Joyent, Inc. All rights reserved.  * Copyright 2013 DEY Storage Systems, Inc.  * Copyright 2014 HybridCluster. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright 2013 Saso Kiselkov. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_comment
comment|/* Portions Copyright 2010 Robert Milkowski */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_DMU_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_DMU_H
end_define

begin_comment
comment|/*  * This file describes the interface that the DMU provides for its  * consumers.  *  * The DMU also interacts with the SPA.  That interface is described in  * dmu_spa.h.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/inttypes.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_priority.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
struct_decl|struct
name|uio
struct_decl|;
struct_decl|struct
name|xuio
struct_decl|;
struct_decl|struct
name|page
struct_decl|;
struct_decl|struct
name|vnode
struct_decl|;
struct_decl|struct
name|spa
struct_decl|;
struct_decl|struct
name|zilog
struct_decl|;
struct_decl|struct
name|zio
struct_decl|;
struct_decl|struct
name|blkptr
struct_decl|;
struct_decl|struct
name|zap_cursor
struct_decl|;
struct_decl|struct
name|dsl_dataset
struct_decl|;
struct_decl|struct
name|dsl_pool
struct_decl|;
struct_decl|struct
name|dnode
struct_decl|;
struct_decl|struct
name|drr_begin
struct_decl|;
struct_decl|struct
name|drr_end
struct_decl|;
struct_decl|struct
name|zbookmark_phys
struct_decl|;
struct_decl|struct
name|spa
struct_decl|;
struct_decl|struct
name|nvlist
struct_decl|;
struct_decl|struct
name|arc_buf
struct_decl|;
struct_decl|struct
name|zio_prop
struct_decl|;
struct_decl|struct
name|sa_handle
struct_decl|;
typedef|typedef
name|struct
name|objset
name|objset_t
typedef|;
typedef|typedef
name|struct
name|dmu_tx
name|dmu_tx_t
typedef|;
typedef|typedef
name|struct
name|dsl_dir
name|dsl_dir_t
typedef|;
typedef|typedef
name|struct
name|dnode
name|dnode_t
typedef|;
typedef|typedef
enum|enum
name|dmu_object_byteswap
block|{
name|DMU_BSWAP_UINT8
block|,
name|DMU_BSWAP_UINT16
block|,
name|DMU_BSWAP_UINT32
block|,
name|DMU_BSWAP_UINT64
block|,
name|DMU_BSWAP_ZAP
block|,
name|DMU_BSWAP_DNODE
block|,
name|DMU_BSWAP_OBJSET
block|,
name|DMU_BSWAP_ZNODE
block|,
name|DMU_BSWAP_OLDACL
block|,
name|DMU_BSWAP_ACL
block|,
comment|/* 	 * Allocating a new byteswap type number makes the on-disk format 	 * incompatible with any other format that uses the same number. 	 * 	 * Data can usually be structured to work with one of the 	 * DMU_BSWAP_UINT* or DMU_BSWAP_ZAP types. 	 */
name|DMU_BSWAP_NUMFUNCS
block|}
name|dmu_object_byteswap_t
typedef|;
define|#
directive|define
name|DMU_OT_NEWTYPE
value|0x80
define|#
directive|define
name|DMU_OT_METADATA
value|0x40
define|#
directive|define
name|DMU_OT_BYTESWAP_MASK
value|0x3f
comment|/*  * Defines a uint8_t object type. Object types specify if the data  * in the object is metadata (boolean) and how to byteswap the data  * (dmu_object_byteswap_t).  */
define|#
directive|define
name|DMU_OT
parameter_list|(
name|byteswap
parameter_list|,
name|metadata
parameter_list|)
define|\
value|(DMU_OT_NEWTYPE | \ 	((metadata) ? DMU_OT_METADATA : 0) | \ 	((byteswap)& DMU_OT_BYTESWAP_MASK))
define|#
directive|define
name|DMU_OT_IS_VALID
parameter_list|(
name|ot
parameter_list|)
value|(((ot)& DMU_OT_NEWTYPE) ? \ 	((ot)& DMU_OT_BYTESWAP_MASK)< DMU_BSWAP_NUMFUNCS : \ 	(ot)< DMU_OT_NUMTYPES)
define|#
directive|define
name|DMU_OT_IS_METADATA
parameter_list|(
name|ot
parameter_list|)
value|(((ot)& DMU_OT_NEWTYPE) ? \ 	((ot)& DMU_OT_METADATA) : \ 	dmu_ot[(ot)].ot_metadata)
comment|/*  * These object types use bp_fill != 1 for their L0 bp's. Therefore they can't  * have their data embedded (i.e. use a BP_IS_EMBEDDED() bp), because bp_fill  * is repurposed for embedded BPs.  */
define|#
directive|define
name|DMU_OT_HAS_FILL
parameter_list|(
name|ot
parameter_list|)
define|\
value|((ot) == DMU_OT_DNODE || (ot) == DMU_OT_OBJSET)
define|#
directive|define
name|DMU_OT_BYTESWAP
parameter_list|(
name|ot
parameter_list|)
value|(((ot)& DMU_OT_NEWTYPE) ? \ 	((ot)& DMU_OT_BYTESWAP_MASK) : \ 	dmu_ot[(ot)].ot_byteswap)
typedef|typedef
enum|enum
name|dmu_object_type
block|{
name|DMU_OT_NONE
block|,
comment|/* general: */
name|DMU_OT_OBJECT_DIRECTORY
block|,
comment|/* ZAP */
name|DMU_OT_OBJECT_ARRAY
block|,
comment|/* UINT64 */
name|DMU_OT_PACKED_NVLIST
block|,
comment|/* UINT8 (XDR by nvlist_pack/unpack) */
name|DMU_OT_PACKED_NVLIST_SIZE
block|,
comment|/* UINT64 */
name|DMU_OT_BPOBJ
block|,
comment|/* UINT64 */
name|DMU_OT_BPOBJ_HDR
block|,
comment|/* UINT64 */
comment|/* spa: */
name|DMU_OT_SPACE_MAP_HEADER
block|,
comment|/* UINT64 */
name|DMU_OT_SPACE_MAP
block|,
comment|/* UINT64 */
comment|/* zil: */
name|DMU_OT_INTENT_LOG
block|,
comment|/* UINT64 */
comment|/* dmu: */
name|DMU_OT_DNODE
block|,
comment|/* DNODE */
name|DMU_OT_OBJSET
block|,
comment|/* OBJSET */
comment|/* dsl: */
name|DMU_OT_DSL_DIR
block|,
comment|/* UINT64 */
name|DMU_OT_DSL_DIR_CHILD_MAP
block|,
comment|/* ZAP */
name|DMU_OT_DSL_DS_SNAP_MAP
block|,
comment|/* ZAP */
name|DMU_OT_DSL_PROPS
block|,
comment|/* ZAP */
name|DMU_OT_DSL_DATASET
block|,
comment|/* UINT64 */
comment|/* zpl: */
name|DMU_OT_ZNODE
block|,
comment|/* ZNODE */
name|DMU_OT_OLDACL
block|,
comment|/* Old ACL */
name|DMU_OT_PLAIN_FILE_CONTENTS
block|,
comment|/* UINT8 */
name|DMU_OT_DIRECTORY_CONTENTS
block|,
comment|/* ZAP */
name|DMU_OT_MASTER_NODE
block|,
comment|/* ZAP */
name|DMU_OT_UNLINKED_SET
block|,
comment|/* ZAP */
comment|/* zvol: */
name|DMU_OT_ZVOL
block|,
comment|/* UINT8 */
name|DMU_OT_ZVOL_PROP
block|,
comment|/* ZAP */
comment|/* other; for testing only! */
name|DMU_OT_PLAIN_OTHER
block|,
comment|/* UINT8 */
name|DMU_OT_UINT64_OTHER
block|,
comment|/* UINT64 */
name|DMU_OT_ZAP_OTHER
block|,
comment|/* ZAP */
comment|/* new object types: */
name|DMU_OT_ERROR_LOG
block|,
comment|/* ZAP */
name|DMU_OT_SPA_HISTORY
block|,
comment|/* UINT8 */
name|DMU_OT_SPA_HISTORY_OFFSETS
block|,
comment|/* spa_his_phys_t */
name|DMU_OT_POOL_PROPS
block|,
comment|/* ZAP */
name|DMU_OT_DSL_PERMS
block|,
comment|/* ZAP */
name|DMU_OT_ACL
block|,
comment|/* ACL */
name|DMU_OT_SYSACL
block|,
comment|/* SYSACL */
name|DMU_OT_FUID
block|,
comment|/* FUID table (Packed NVLIST UINT8) */
name|DMU_OT_FUID_SIZE
block|,
comment|/* FUID table size UINT64 */
name|DMU_OT_NEXT_CLONES
block|,
comment|/* ZAP */
name|DMU_OT_SCAN_QUEUE
block|,
comment|/* ZAP */
name|DMU_OT_USERGROUP_USED
block|,
comment|/* ZAP */
name|DMU_OT_USERGROUP_QUOTA
block|,
comment|/* ZAP */
name|DMU_OT_USERREFS
block|,
comment|/* ZAP */
name|DMU_OT_DDT_ZAP
block|,
comment|/* ZAP */
name|DMU_OT_DDT_STATS
block|,
comment|/* ZAP */
name|DMU_OT_SA
block|,
comment|/* System attr */
name|DMU_OT_SA_MASTER_NODE
block|,
comment|/* ZAP */
name|DMU_OT_SA_ATTR_REGISTRATION
block|,
comment|/* ZAP */
name|DMU_OT_SA_ATTR_LAYOUTS
block|,
comment|/* ZAP */
name|DMU_OT_SCAN_XLATE
block|,
comment|/* ZAP */
name|DMU_OT_DEDUP
block|,
comment|/* fake dedup BP from ddt_bp_create() */
name|DMU_OT_DEADLIST
block|,
comment|/* ZAP */
name|DMU_OT_DEADLIST_HDR
block|,
comment|/* UINT64 */
name|DMU_OT_DSL_CLONES
block|,
comment|/* ZAP */
name|DMU_OT_BPOBJ_SUBOBJ
block|,
comment|/* UINT64 */
comment|/* 	 * Do not allocate new object types here. Doing so makes the on-disk 	 * format incompatible with any other format that uses the same object 	 * type number. 	 * 	 * When creating an object which does not have one of the above types 	 * use the DMU_OTN_* type with the correct byteswap and metadata 	 * values. 	 * 	 * The DMU_OTN_* types do not have entries in the dmu_ot table, 	 * use the DMU_OT_IS_METDATA() and DMU_OT_BYTESWAP() macros instead 	 * of indexing into dmu_ot directly (this works for both DMU_OT_* types 	 * and DMU_OTN_* types). 	 */
name|DMU_OT_NUMTYPES
block|,
comment|/* 	 * Names for valid types declared with DMU_OT(). 	 */
name|DMU_OTN_UINT8_DATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT8
argument_list|,
name|B_FALSE
argument_list|)
block|,
name|DMU_OTN_UINT8_METADATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT8
argument_list|,
name|B_TRUE
argument_list|)
block|,
name|DMU_OTN_UINT16_DATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT16
argument_list|,
name|B_FALSE
argument_list|)
block|,
name|DMU_OTN_UINT16_METADATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT16
argument_list|,
name|B_TRUE
argument_list|)
block|,
name|DMU_OTN_UINT32_DATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT32
argument_list|,
name|B_FALSE
argument_list|)
block|,
name|DMU_OTN_UINT32_METADATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT32
argument_list|,
name|B_TRUE
argument_list|)
block|,
name|DMU_OTN_UINT64_DATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT64
argument_list|,
name|B_FALSE
argument_list|)
block|,
name|DMU_OTN_UINT64_METADATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_UINT64
argument_list|,
name|B_TRUE
argument_list|)
block|,
name|DMU_OTN_ZAP_DATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_ZAP
argument_list|,
name|B_FALSE
argument_list|)
block|,
name|DMU_OTN_ZAP_METADATA
init|=
name|DMU_OT
argument_list|(
name|DMU_BSWAP_ZAP
argument_list|,
name|B_TRUE
argument_list|)
block|, }
name|dmu_object_type_t
typedef|;
typedef|typedef
enum|enum
name|txg_how
block|{
name|TXG_WAIT
init|=
literal|1
block|,
name|TXG_NOWAIT
block|,
name|TXG_WAITED
block|, }
name|txg_how_t
typedef|;
name|void
name|byteswap_uint64_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|byteswap_uint32_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|byteswap_uint16_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|byteswap_uint8_array
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zap_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zfs_oldacl_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zfs_acl_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|void
name|zfs_znode_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
define|#
directive|define
name|DS_FIND_SNAPSHOTS
value|(1<<0)
define|#
directive|define
name|DS_FIND_CHILDREN
value|(1<<1)
define|#
directive|define
name|DS_FIND_SERIALIZE
value|(1<<2)
comment|/*  * The maximum number of bytes that can be accessed as part of one  * operation, including metadata.  */
define|#
directive|define
name|DMU_MAX_ACCESS
value|(32 * 1024 * 1024)
comment|/* 32MB */
define|#
directive|define
name|DMU_MAX_DELETEBLKCNT
value|(20480)
comment|/* ~5MB of indirect blocks */
define|#
directive|define
name|DMU_USERUSED_OBJECT
value|(-1ULL)
define|#
directive|define
name|DMU_GROUPUSED_OBJECT
value|(-2ULL)
comment|/*  * artificial blkids for bonus buffer and spill blocks  */
define|#
directive|define
name|DMU_BONUS_BLKID
value|(-1ULL)
define|#
directive|define
name|DMU_SPILL_BLKID
value|(-2ULL)
comment|/*  * Public routines to create, destroy, open, and close objsets.  */
name|int
name|dmu_objset_hold
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
function_decl|;
name|int
name|dmu_objset_own
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|boolean_t
name|readonly
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
function_decl|;
name|void
name|dmu_objset_rele
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|void
name|dmu_objset_disown
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|int
name|dmu_objset_open_ds
parameter_list|(
name|struct
name|dsl_dataset
modifier|*
name|ds
parameter_list|,
name|objset_t
modifier|*
modifier|*
name|osp
parameter_list|)
function_decl|;
name|void
name|dmu_objset_evict_dbufs
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|int
name|dmu_objset_create
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dmu_objset_type_t
name|type
parameter_list|,
name|uint64_t
name|flags
parameter_list|,
name|void
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|int
name|dmu_objset_clone
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|origin
parameter_list|)
function_decl|;
name|int
name|dsl_destroy_snapshots_nvl
parameter_list|(
name|struct
name|nvlist
modifier|*
name|snaps
parameter_list|,
name|boolean_t
name|defer
parameter_list|,
name|struct
name|nvlist
modifier|*
name|errlist
parameter_list|)
function_decl|;
name|int
name|dmu_objset_snapshot_one
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|snapname
parameter_list|)
function_decl|;
name|int
name|dmu_objset_snapshot_tmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
name|dmu_objset_find
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|int
name|func
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|void
modifier|*
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
name|void
name|dmu_objset_byteswap
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
name|int
name|dsl_dataset_rename_snapshot
parameter_list|(
specifier|const
name|char
modifier|*
name|fsname
parameter_list|,
specifier|const
name|char
modifier|*
name|oldsnapname
parameter_list|,
specifier|const
name|char
modifier|*
name|newsnapname
parameter_list|,
name|boolean_t
name|recursive
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_buf
block|{
name|uint64_t
name|db_object
decl_stmt|;
comment|/* object that this buffer is part of */
name|uint64_t
name|db_offset
decl_stmt|;
comment|/* byte offset in this object */
name|uint64_t
name|db_size
decl_stmt|;
comment|/* size of buffer in bytes */
name|void
modifier|*
name|db_data
decl_stmt|;
comment|/* data in buffer */
block|}
name|dmu_buf_t
typedef|;
comment|/*  * The names of zap entries in the DIRECTORY_OBJECT of the MOS.  */
define|#
directive|define
name|DMU_POOL_DIRECTORY_OBJECT
value|1
define|#
directive|define
name|DMU_POOL_CONFIG
value|"config"
define|#
directive|define
name|DMU_POOL_FEATURES_FOR_WRITE
value|"features_for_write"
define|#
directive|define
name|DMU_POOL_FEATURES_FOR_READ
value|"features_for_read"
define|#
directive|define
name|DMU_POOL_FEATURE_DESCRIPTIONS
value|"feature_descriptions"
define|#
directive|define
name|DMU_POOL_FEATURE_ENABLED_TXG
value|"feature_enabled_txg"
define|#
directive|define
name|DMU_POOL_ROOT_DATASET
value|"root_dataset"
define|#
directive|define
name|DMU_POOL_SYNC_BPOBJ
value|"sync_bplist"
define|#
directive|define
name|DMU_POOL_ERRLOG_SCRUB
value|"errlog_scrub"
define|#
directive|define
name|DMU_POOL_ERRLOG_LAST
value|"errlog_last"
define|#
directive|define
name|DMU_POOL_SPARES
value|"spares"
define|#
directive|define
name|DMU_POOL_DEFLATE
value|"deflate"
define|#
directive|define
name|DMU_POOL_HISTORY
value|"history"
define|#
directive|define
name|DMU_POOL_PROPS
value|"pool_props"
define|#
directive|define
name|DMU_POOL_L2CACHE
value|"l2cache"
define|#
directive|define
name|DMU_POOL_TMP_USERREFS
value|"tmp_userrefs"
define|#
directive|define
name|DMU_POOL_DDT
value|"DDT-%s-%s-%s"
define|#
directive|define
name|DMU_POOL_DDT_STATS
value|"DDT-statistics"
define|#
directive|define
name|DMU_POOL_CREATION_VERSION
value|"creation_version"
define|#
directive|define
name|DMU_POOL_SCAN
value|"scan"
define|#
directive|define
name|DMU_POOL_FREE_BPOBJ
value|"free_bpobj"
define|#
directive|define
name|DMU_POOL_BPTREE_OBJ
value|"bptree_obj"
define|#
directive|define
name|DMU_POOL_EMPTY_BPOBJ
value|"empty_bpobj"
define|#
directive|define
name|DMU_POOL_CHECKSUM_SALT
value|"org.illumos:checksum_salt"
define|#
directive|define
name|DMU_POOL_VDEV_ZAP_MAP
value|"com.delphix:vdev_zap_map"
comment|/*  * Allocate an object from this objset.  The range of object numbers  * available is (0, DN_MAX_OBJECT).  Object 0 is the meta-dnode.  *  * The transaction must be assigned to a txg.  The newly allocated  * object will be "held" in the transaction (ie. you can modify the  * newly allocated object in this transaction).  *  * dmu_object_alloc() chooses an object and returns it in *objectp.  *  * dmu_object_claim() allocates a specific object number.  If that  * number is already allocated, it fails and returns EEXIST.  *  * Return 0 on success, or ENOSPC or EEXIST as specified above.  */
name|uint64_t
name|dmu_object_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonus_type
parameter_list|,
name|int
name|bonus_len
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_object_claim
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonus_type
parameter_list|,
name|int
name|bonus_len
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_object_reclaim
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_type_t
name|ot
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|int
name|bonuslen
parameter_list|,
name|dmu_tx_t
modifier|*
name|txp
parameter_list|)
function_decl|;
comment|/*  * Free an object from this objset.  *  * The object's data will be freed as well (ie. you don't need to call  * dmu_free(object, 0, -1, tx)).  *  * The object need not be held in the transaction.  *  * If there are any holds on this object's buffers (via dmu_buf_hold()),  * or tx holds on the object (via dmu_tx_hold_object()), you can not  * free it; it fails and returns EBUSY.  *  * If the object is not allocated, it fails and returns ENOENT.  *  * Return 0 on success, or EBUSY or ENOENT as specified above.  */
name|int
name|dmu_object_free
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Find the next allocated or free object.  *  * The objectp parameter is in-out.  It will be updated to be the next  * object which is allocated.  Ignore objects which have not been  * modified since txg.  *  * XXX Can only be called on a objset with no dirty data.  *  * Returns 0 on success, or ENOENT if there are no more objects.  */
name|int
name|dmu_object_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
modifier|*
name|objectp
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
function_decl|;
comment|/*  * Set the data blocksize for an object.  *  * The object cannot have any blocks allcated beyond the first.  If  * the first block is allocated already, the new size must be greater  * than the current block size.  If these conditions are not met,  * ENOTSUP will be returned.  *  * Returns 0 on success, or EBUSY if there are any holds on the object  * contents, or ENOTSUP as described above.  */
name|int
name|dmu_object_set_blocksize
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|ibs
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Set the checksum property on a dnode.  The new checksum algorithm will  * apply to all newly written blocks; existing blocks will not be affected.  */
name|void
name|dmu_object_set_checksum
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|checksum
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Set the compress property on a dnode.  The new compression algorithm will  * apply to all newly written blocks; existing blocks will not be affected.  */
name|void
name|dmu_object_set_compress
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint8_t
name|compress
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dmu_write_embedded
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint8_t
name|etype
parameter_list|,
name|uint8_t
name|comp
parameter_list|,
name|int
name|uncompressed_size
parameter_list|,
name|int
name|compressed_size
parameter_list|,
name|int
name|byteorder
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Decide how to write a block: checksum, compression, number of copies, etc.  */
define|#
directive|define
name|WP_NOFILL
value|0x1
define|#
directive|define
name|WP_DMU_SYNC
value|0x2
define|#
directive|define
name|WP_SPILL
value|0x4
name|void
name|dmu_write_policy
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|int
name|level
parameter_list|,
name|int
name|wp
parameter_list|,
name|enum
name|zio_compress
name|compress_override
parameter_list|,
name|struct
name|zio_prop
modifier|*
name|zp
parameter_list|)
function_decl|;
comment|/*  * The bonus data is accessed more or less like a regular buffer.  * You must dmu_bonus_hold() to get the buffer, which will give you a  * dmu_buf_t with db_offset==-1ULL, and db_size = the size of the bonus  * data.  As with any normal buffer, you must call dmu_buf_read() to  * read db_data, dmu_buf_will_dirty() before modifying it, and the  * object must be held in an assigned transaction before calling  * dmu_buf_will_dirty.  You may use dmu_buf_set_user() on the bonus  * buffer as well.  You must release your hold with dmu_buf_rele().  *  * Returns ENOENT, EIO, or 0.  */
name|int
name|dmu_bonus_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
name|int
name|dmu_bonus_max
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|int
name|dmu_set_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|dmu_set_bonustype
parameter_list|(
name|dmu_buf_t
modifier|*
parameter_list|,
name|dmu_object_type_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
name|dmu_object_type_t
name|dmu_get_bonustype
parameter_list|(
name|dmu_buf_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|dmu_rm_spill
parameter_list|(
name|objset_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|dmu_tx_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Special spill buffer support used by "SA" framework  */
name|int
name|dmu_spill_hold_by_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|bonus
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
name|int
name|dmu_spill_hold_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint32_t
name|flags
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
name|int
name|dmu_spill_hold_existing
parameter_list|(
name|dmu_buf_t
modifier|*
name|bonus
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|)
function_decl|;
comment|/*  * Obtain the DMU buffer from the specified object which contains the  * specified offset.  dmu_buf_hold() puts a "hold" on the buffer, so  * that it will remain in memory.  You must release the hold with  * dmu_buf_rele().  You musn't access the dmu_buf_t after releasing your  * hold.  You must have a hold on any dmu_buf_t* you pass to the DMU.  *  * You must call dmu_buf_read, dmu_buf_will_dirty, or dmu_buf_will_fill  * on the returned buffer before reading or writing the buffer's  * db_data.  The comments for those routines describe what particular  * operations are valid after calling them.  *  * The object number must be a valid, allocated object number.  */
name|int
name|dmu_buf_hold
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
name|int
name|dmu_buf_hold_by_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|dbp
parameter_list|,
name|int
name|flags
parameter_list|)
function_decl|;
comment|/*  * Add a reference to a dmu buffer that has already been held via  * dmu_buf_hold() in the current context.  */
name|void
name|dmu_buf_add_ref
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
comment|/*  * Attempt to add a reference to a dmu buffer that is in an unknown state,  * using a pointer that may have been invalidated by eviction processing.  * The request will succeed if the passed in dbuf still represents the  * same os/object/blkid, is ineligible for eviction, and has at least  * one hold by a user other than the syncer.  */
name|boolean_t
name|dmu_buf_try_add_ref
parameter_list|(
name|dmu_buf_t
modifier|*
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|void
name|dmu_buf_rele
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
name|uint64_t
name|dmu_buf_refcount
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
comment|/*  * dmu_buf_hold_array holds the DMU buffers which contain all bytes in a  * range of an object.  A pointer to an array of dmu_buf_t*'s is  * returned (in *dbpp).  *  * dmu_buf_rele_array releases the hold on an array of dmu_buf_t*'s, and  * frees the array.  The hold on the array of buffers MUST be released  * with dmu_buf_rele_array.  You can NOT release the hold on each buffer  * individually with dmu_buf_rele.  */
name|int
name|dmu_buf_hold_array_by_bonus
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|length
parameter_list|,
name|boolean_t
name|read
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|int
modifier|*
name|numbufsp
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
modifier|*
name|dbpp
parameter_list|)
function_decl|;
name|void
name|dmu_buf_rele_array
parameter_list|(
name|dmu_buf_t
modifier|*
modifier|*
parameter_list|,
name|int
name|numbufs
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
typedef|typedef
name|void
name|dmu_buf_evict_func_t
parameter_list|(
name|void
modifier|*
name|user_ptr
parameter_list|)
function_decl|;
comment|/*  * A DMU buffer user object may be associated with a dbuf for the  * duration of its lifetime.  This allows the user of a dbuf (client)  * to attach private data to a dbuf (e.g. in-core only data such as a  * dnode_children_t, zap_t, or zap_leaf_t) and be optionally notified  * when that dbuf has been evicted.  Clients typically respond to the  * eviction notification by freeing their private data, thus ensuring  * the same lifetime for both dbuf and private data.  *  * The mapping from a dmu_buf_user_t to any client private data is the  * client's responsibility.  All current consumers of the API with private  * data embed a dmu_buf_user_t as the first member of the structure for  * their private data.  This allows conversions between the two types  * with a simple cast.  Since the DMU buf user API never needs access  * to the private data, other strategies can be employed if necessary  * or convenient for the client (e.g. using container_of() to do the  * conversion for private data that cannot have the dmu_buf_user_t as  * its first member).  *  * Eviction callbacks are executed without the dbuf mutex held or any  * other type of mechanism to guarantee that the dbuf is still available.  * For this reason, users must assume the dbuf has already been freed  * and not reference the dbuf from the callback context.  *  * Users requesting "immediate eviction" are notified as soon as the dbuf  * is only referenced by dirty records (dirties == holds).  Otherwise the  * notification occurs after eviction processing for the dbuf begins.  */
typedef|typedef
struct|struct
name|dmu_buf_user
block|{
comment|/* 	 * Asynchronous user eviction callback state. 	 */
name|taskq_ent_t
name|dbu_tqent
decl_stmt|;
comment|/* 	 * This instance's eviction function pointers. 	 * 	 * dbu_evict_func_sync is called synchronously and then 	 * dbu_evict_func_async is executed asynchronously on a taskq. 	 */
name|dmu_buf_evict_func_t
modifier|*
name|dbu_evict_func_sync
decl_stmt|;
name|dmu_buf_evict_func_t
modifier|*
name|dbu_evict_func_async
decl_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
comment|/* 	 * Pointer to user's dbuf pointer.  NULL for clients that do 	 * not associate a dbuf with their user data. 	 * 	 * The dbuf pointer is cleared upon eviction so as to catch 	 * use-after-evict bugs in clients. 	 */
name|dmu_buf_t
modifier|*
modifier|*
name|dbu_clear_on_evict_dbufp
decl_stmt|;
endif|#
directive|endif
block|}
name|dmu_buf_user_t
typedef|;
comment|/*  * Initialize the given dmu_buf_user_t instance with the eviction function  * evict_func, to be called when the user is evicted.  *  * NOTE: This function should only be called once on a given dmu_buf_user_t.  *       To allow enforcement of this, dbu must already be zeroed on entry.  */
comment|/*ARGSUSED*/
specifier|inline
name|void
name|dmu_buf_init_user
parameter_list|(
name|dmu_buf_user_t
modifier|*
name|dbu
parameter_list|,
name|dmu_buf_evict_func_t
modifier|*
name|evict_func_sync
parameter_list|,
name|dmu_buf_evict_func_t
modifier|*
name|evict_func_async
parameter_list|,
name|dmu_buf_t
modifier|*
modifier|*
name|clear_on_evict_dbufp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dbu
operator|->
name|dbu_evict_func_sync
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dbu
operator|->
name|dbu_evict_func_async
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* must have at least one evict func */
name|IMPLY
argument_list|(
name|evict_func_sync
operator|==
name|NULL
argument_list|,
name|evict_func_async
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dbu
operator|->
name|dbu_evict_func_sync
operator|=
name|evict_func_sync
expr_stmt|;
name|dbu
operator|->
name|dbu_evict_func_async
operator|=
name|evict_func_async
expr_stmt|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
name|dbu
operator|->
name|dbu_clear_on_evict_dbufp
operator|=
name|clear_on_evict_dbufp
expr_stmt|;
endif|#
directive|endif
block|}
comment|/*  * Attach user data to a dbuf and mark it for normal (when the dbuf's  * data is cleared or its reference count goes to zero) eviction processing.  *  * Returns NULL on success, or the existing user if another user currently  * owns the buffer.  */
name|void
modifier|*
name|dmu_buf_set_user
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_buf_user_t
modifier|*
name|user
parameter_list|)
function_decl|;
comment|/*  * Attach user data to a dbuf and mark it for immediate (its dirty and  * reference counts are equal) eviction processing.  *  * Returns NULL on success, or the existing user if another user currently  * owns the buffer.  */
name|void
modifier|*
name|dmu_buf_set_user_ie
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_buf_user_t
modifier|*
name|user
parameter_list|)
function_decl|;
comment|/*  * Replace the current user of a dbuf.  *  * If given the current user of a dbuf, replaces the dbuf's user with  * "new_user" and returns the user data pointer that was replaced.  * Otherwise returns the current, and unmodified, dbuf user pointer.  */
name|void
modifier|*
name|dmu_buf_replace_user
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_buf_user_t
modifier|*
name|old_user
parameter_list|,
name|dmu_buf_user_t
modifier|*
name|new_user
parameter_list|)
function_decl|;
comment|/*  * Remove the specified user data for a DMU buffer.  *  * Returns the user that was removed on success, or the current user if  * another user currently owns the buffer.  */
name|void
modifier|*
name|dmu_buf_remove_user
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_buf_user_t
modifier|*
name|user
parameter_list|)
function_decl|;
comment|/*  * Returns the user data (dmu_buf_user_t *) associated with this dbuf.  */
name|void
modifier|*
name|dmu_buf_get_user
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|objset_t
modifier|*
name|dmu_buf_get_objset
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|dnode_t
modifier|*
name|dmu_buf_dnode_enter
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
name|void
name|dmu_buf_dnode_exit
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
comment|/* Block until any in-progress dmu buf user evictions complete. */
name|void
name|dmu_buf_user_evict_wait
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/*  * Returns the blkptr associated with this dbuf, or NULL if not set.  */
name|struct
name|blkptr
modifier|*
name|dmu_buf_get_blkptr
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|)
function_decl|;
comment|/*  * Indicate that you are going to modify the buffer's data (db_data).  *  * The transaction (tx) must be assigned to a txg (ie. you've called  * dmu_tx_assign()).  The buffer's object must be held in the tx  * (ie. you've called dmu_tx_hold_object(tx, db->db_object)).  */
name|void
name|dmu_buf_will_dirty
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Tells if the given dbuf is freeable.  */
name|boolean_t
name|dmu_buf_freeable
parameter_list|(
name|dmu_buf_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * You must create a transaction, then hold the objects which you will  * (or might) modify as part of this transaction.  Then you must assign  * the transaction to a transaction group.  Once the transaction has  * been assigned, you can modify buffers which belong to held objects as  * part of this transaction.  You can't modify buffers before the  * transaction has been assigned; you can't modify buffers which don't  * belong to objects which this transaction holds; you can't hold  * objects once the transaction has been assigned.  You may hold an  * object which you are going to free (with dmu_object_free()), but you  * don't have to.  *  * You can abort the transaction before it has been assigned.  *  * Note that you may hold buffers (with dmu_buf_hold) at any time,  * regardless of transaction state.  */
define|#
directive|define
name|DMU_NEW_OBJECT
value|(-1ULL)
define|#
directive|define
name|DMU_OBJECT_END
value|(-1ULL)
name|dmu_tx_t
modifier|*
name|dmu_tx_create
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_write
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_free
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_zap
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int
name|add
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_bonus
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_spill
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|object
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_sa
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|struct
name|sa_handle
modifier|*
name|hdl
parameter_list|,
name|boolean_t
name|may_grow
parameter_list|)
function_decl|;
name|void
name|dmu_tx_hold_sa_create
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|int
name|total_size
parameter_list|)
function_decl|;
name|void
name|dmu_tx_abort
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_tx_assign
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|enum
name|txg_how
name|txg_how
parameter_list|)
function_decl|;
name|void
name|dmu_tx_wait
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dmu_tx_commit
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dmu_tx_mark_netfree
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * To register a commit callback, dmu_tx_callback_register() must be called.  *  * dcb_data is a pointer to caller private data that is passed on as a  * callback parameter. The caller is responsible for properly allocating and  * freeing it.  *  * When registering a callback, the transaction must be already created, but  * it cannot be committed or aborted. It can be assigned to a txg or not.  *  * The callback will be called after the transaction has been safely written  * to stable storage and will also be called if the dmu_tx is aborted.  * If there is any error which prevents the transaction from being committed to  * disk, the callback will be called with a value of error != 0.  */
typedef|typedef
name|void
name|dmu_tx_callback_func_t
parameter_list|(
name|void
modifier|*
name|dcb_data
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
name|void
name|dmu_tx_callback_register
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|dmu_tx_callback_func_t
modifier|*
name|dcb_func
parameter_list|,
name|void
modifier|*
name|dcb_data
parameter_list|)
function_decl|;
comment|/*  * Free up the data blocks for a defined range of a file.  If size is  * -1, the range from offset to end-of-file is freed.  */
name|int
name|dmu_free_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_free_long_range
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|)
function_decl|;
name|int
name|dmu_free_long_object
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|)
function_decl|;
comment|/*  * Convenience functions.  *  * Canfail routines will return 0 on success, or an errno if there is a  * nonrecoverable I/O error.  */
define|#
directive|define
name|DMU_READ_PREFETCH
value|0
comment|/* prefetch */
define|#
directive|define
name|DMU_READ_NO_PREFETCH
value|1
comment|/* don't prefetch */
name|int
name|dmu_read
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint32_t
name|flags
parameter_list|)
function_decl|;
name|void
name|dmu_write
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|void
name|dmu_prealloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_read_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
function_decl|;
name|int
name|dmu_read_uio_dbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|zdb
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
function_decl|;
name|int
name|dmu_write_uio
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_write_uio_dbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|zdb
parameter_list|,
name|struct
name|uio
modifier|*
name|uio
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_write_pages
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|struct
name|page
modifier|*
name|pp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|struct
name|arc_buf
modifier|*
name|dmu_request_arcbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|handle
parameter_list|,
name|int
name|size
parameter_list|)
function_decl|;
name|void
name|dmu_return_arcbuf
parameter_list|(
name|struct
name|arc_buf
modifier|*
name|buf
parameter_list|)
function_decl|;
name|void
name|dmu_assign_arcbuf
parameter_list|(
name|dmu_buf_t
modifier|*
name|handle
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|struct
name|arc_buf
modifier|*
name|buf
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
name|int
name|dmu_xuio_init
parameter_list|(
name|struct
name|xuio
modifier|*
name|uio
parameter_list|,
name|int
name|niov
parameter_list|)
function_decl|;
name|void
name|dmu_xuio_fini
parameter_list|(
name|struct
name|xuio
modifier|*
name|uio
parameter_list|)
function_decl|;
name|int
name|dmu_xuio_add
parameter_list|(
name|struct
name|xuio
modifier|*
name|uio
parameter_list|,
name|struct
name|arc_buf
modifier|*
name|abuf
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|size_t
name|n
parameter_list|)
function_decl|;
name|int
name|dmu_xuio_cnt
parameter_list|(
name|struct
name|xuio
modifier|*
name|uio
parameter_list|)
function_decl|;
name|struct
name|arc_buf
modifier|*
name|dmu_xuio_arcbuf
parameter_list|(
name|struct
name|xuio
modifier|*
name|uio
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
name|void
name|dmu_xuio_clear
parameter_list|(
name|struct
name|xuio
modifier|*
name|uio
parameter_list|,
name|int
name|i
parameter_list|)
function_decl|;
name|void
name|xuio_stat_wbuf_copied
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|xuio_stat_wbuf_nocopy
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|zfs_prefetch_disable
decl_stmt|;
specifier|extern
name|int
name|zfs_max_recordsize
decl_stmt|;
comment|/*  * Asynchronously try to read in the data.  */
name|void
name|dmu_prefetch
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|int64_t
name|level
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|enum
name|zio_priority
name|pri
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_object_info
block|{
comment|/* All sizes are in bytes unless otherwise indicated. */
name|uint32_t
name|doi_data_block_size
decl_stmt|;
name|uint32_t
name|doi_metadata_block_size
decl_stmt|;
name|dmu_object_type_t
name|doi_type
decl_stmt|;
name|dmu_object_type_t
name|doi_bonus_type
decl_stmt|;
name|uint64_t
name|doi_bonus_size
decl_stmt|;
name|uint8_t
name|doi_indirection
decl_stmt|;
comment|/* 2 = dnode->indirect->data */
name|uint8_t
name|doi_checksum
decl_stmt|;
name|uint8_t
name|doi_compress
decl_stmt|;
name|uint8_t
name|doi_nblkptr
decl_stmt|;
name|uint8_t
name|doi_pad
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|doi_physical_blocks_512
decl_stmt|;
comment|/* data + metadata, 512b blks */
name|uint64_t
name|doi_max_offset
decl_stmt|;
name|uint64_t
name|doi_fill_count
decl_stmt|;
comment|/* number of non-empty blocks */
block|}
name|dmu_object_info_t
typedef|;
typedef|typedef
name|void
name|arc_byteswap_func_t
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_object_type_info
block|{
name|dmu_object_byteswap_t
name|ot_byteswap
decl_stmt|;
name|boolean_t
name|ot_metadata
decl_stmt|;
name|char
modifier|*
name|ot_name
decl_stmt|;
block|}
name|dmu_object_type_info_t
typedef|;
typedef|typedef
struct|struct
name|dmu_object_byteswap_info
block|{
name|arc_byteswap_func_t
modifier|*
name|ob_func
decl_stmt|;
name|char
modifier|*
name|ob_name
decl_stmt|;
block|}
name|dmu_object_byteswap_info_t
typedef|;
specifier|extern
specifier|const
name|dmu_object_type_info_t
name|dmu_ot
index|[
name|DMU_OT_NUMTYPES
index|]
decl_stmt|;
specifier|extern
specifier|const
name|dmu_object_byteswap_info_t
name|dmu_ot_byteswap
index|[
name|DMU_BSWAP_NUMFUNCS
index|]
decl_stmt|;
comment|/*  * Get information on a DMU object.  *  * Return 0 on success or ENOENT if object is not allocated.  *  * If doi is NULL, just indicates whether the object exists.  */
name|int
name|dmu_object_info
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
function_decl|;
comment|/* Like dmu_object_info, but faster if you have a held dnode in hand. */
name|void
name|dmu_object_info_from_dnode
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
function_decl|;
comment|/* Like dmu_object_info, but faster if you have a held dbuf in hand. */
name|void
name|dmu_object_info_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|dmu_object_info_t
modifier|*
name|doi
parameter_list|)
function_decl|;
comment|/*  * Like dmu_object_info_from_db, but faster still when you only care about  * the size.  This is specifically optimized for zfs_getattr().  */
name|void
name|dmu_object_size_from_db
parameter_list|(
name|dmu_buf_t
modifier|*
name|db
parameter_list|,
name|uint32_t
modifier|*
name|blksize
parameter_list|,
name|u_longlong_t
modifier|*
name|nblk512
parameter_list|)
function_decl|;
typedef|typedef
struct|struct
name|dmu_objset_stats
block|{
name|uint64_t
name|dds_num_clones
decl_stmt|;
comment|/* number of clones of this */
name|uint64_t
name|dds_creation_txg
decl_stmt|;
name|uint64_t
name|dds_guid
decl_stmt|;
name|dmu_objset_type_t
name|dds_type
decl_stmt|;
name|uint8_t
name|dds_is_snapshot
decl_stmt|;
name|uint8_t
name|dds_inconsistent
decl_stmt|;
name|char
name|dds_origin
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
block|}
name|dmu_objset_stats_t
typedef|;
comment|/*  * Get stats on a dataset.  */
name|void
name|dmu_objset_fast_stat
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_objset_stats_t
modifier|*
name|stat
parameter_list|)
function_decl|;
comment|/*  * Add entries to the nvlist for all the objset's properties.  See  * zfs_prop_table[] and zfs(1m) for details on the properties.  */
name|void
name|dmu_objset_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|struct
name|nvlist
modifier|*
name|nv
parameter_list|)
function_decl|;
comment|/*  * Get the space usage statistics for statvfs().  *  * refdbytes is the amount of space "referenced" by this objset.  * availbytes is the amount of space available to this objset, taking  * into account quotas& reservations, assuming that no other objsets  * use the space first.  These values correspond to the 'referenced' and  * 'available' properties, described in the zfs(1m) manpage.  *  * usedobjs and availobjs are the number of objects currently allocated,  * and available.  */
name|void
name|dmu_objset_space
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
modifier|*
name|refdbytesp
parameter_list|,
name|uint64_t
modifier|*
name|availbytesp
parameter_list|,
name|uint64_t
modifier|*
name|usedobjsp
parameter_list|,
name|uint64_t
modifier|*
name|availobjsp
parameter_list|)
function_decl|;
comment|/*  * The fsid_guid is a 56-bit ID that can change to avoid collisions.  * (Contrast with the ds_guid which is a 64-bit ID that will never  * change, so there is a small probability that it will collide.)  */
name|uint64_t
name|dmu_objset_fsid_guid
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
comment|/*  * Get the [cm]time for an objset's snapshot dir  */
name|timestruc_t
name|dmu_objset_snap_cmtime
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
name|int
name|dmu_objset_is_snapshot
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|spa
modifier|*
name|dmu_objset_spa
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|zilog
modifier|*
name|dmu_objset_zil
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|dsl_pool
modifier|*
name|dmu_objset_pool
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|dsl_dataset
modifier|*
name|dmu_objset_ds
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dmu_objset_name
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|)
function_decl|;
specifier|extern
name|dmu_objset_type_t
name|dmu_objset_type
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|dmu_objset_id
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|zfs_sync_type_t
name|dmu_objset_syncprop
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|zfs_logbias_op_t
name|dmu_objset_logbias
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dmu_snapshot_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|id
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|,
name|boolean_t
modifier|*
name|case_conflict
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dmu_snapshot_realname
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|real
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|boolean_t
modifier|*
name|conflict
parameter_list|)
function_decl|;
specifier|extern
name|int
name|dmu_dir_list_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|namelen
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|idp
parameter_list|,
name|uint64_t
modifier|*
name|offp
parameter_list|)
function_decl|;
typedef|typedef
name|int
name|objset_used_cb_t
parameter_list|(
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|void
modifier|*
name|bonus
parameter_list|,
name|uint64_t
modifier|*
name|userp
parameter_list|,
name|uint64_t
modifier|*
name|groupp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dmu_objset_register_type
parameter_list|(
name|dmu_objset_type_t
name|ost
parameter_list|,
name|objset_used_cb_t
modifier|*
name|cb
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dmu_objset_set_user
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|user_ptr
parameter_list|)
function_decl|;
specifier|extern
name|void
modifier|*
name|dmu_objset_get_user
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
comment|/*  * Return the txg number for the given assigned transaction.  */
name|uint64_t
name|dmu_tx_get_txg
parameter_list|(
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
comment|/*  * Synchronous write.  * If a parent zio is provided this function initiates a write on the  * provided buffer as a child of the parent zio.  * In the absence of a parent zio, the write is completed synchronously.  * At write completion, blk is filled with the bp of the written block.  * Note that while the data covered by this function will be on stable  * storage when the write completes this new data does not become a  * permanent part of the file until the associated transaction commits.  */
comment|/*  * {zfs,zvol,ztest}_get_done() args  */
typedef|typedef
struct|struct
name|zgd
block|{
name|struct
name|zilog
modifier|*
name|zgd_zilog
decl_stmt|;
name|struct
name|blkptr
modifier|*
name|zgd_bp
decl_stmt|;
name|dmu_buf_t
modifier|*
name|zgd_db
decl_stmt|;
name|struct
name|rl
modifier|*
name|zgd_rl
decl_stmt|;
name|void
modifier|*
name|zgd_private
decl_stmt|;
block|}
name|zgd_t
typedef|;
typedef|typedef
name|void
name|dmu_sync_cb_t
parameter_list|(
name|zgd_t
modifier|*
name|arg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
name|int
name|dmu_sync
parameter_list|(
name|struct
name|zio
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|dmu_sync_cb_t
modifier|*
name|done
parameter_list|,
name|zgd_t
modifier|*
name|zgd
parameter_list|)
function_decl|;
comment|/*  * Find the next hole or data block in file starting at *off  * Return found offset in *off. Return ESRCH for end of file.  */
name|int
name|dmu_offset_next
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|boolean_t
name|hole
parameter_list|,
name|uint64_t
modifier|*
name|off
parameter_list|)
function_decl|;
comment|/*  * Check if a DMU object has any dirty blocks. If so, sync out  * all pending transaction groups. Otherwise, this function  * does not alter DMU state. This could be improved to only sync  * out the necessary transaction groups for this particular  * object.  */
name|int
name|dmu_object_wait_synced
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|)
function_decl|;
comment|/*  * Initial setup and final teardown.  */
specifier|extern
name|void
name|dmu_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|dmu_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
typedef|typedef
name|void
function_decl|(
modifier|*
name|dmu_traverse_cb_t
function_decl|)
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|struct
name|blkptr
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|object
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|int
name|len
parameter_list|)
function_decl|;
name|void
name|dmu_traverse_objset
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|txg_start
parameter_list|,
name|dmu_traverse_cb_t
name|cb
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
function_decl|;
name|int
name|dmu_diff
parameter_list|(
specifier|const
name|char
modifier|*
name|tosnap_name
parameter_list|,
specifier|const
name|char
modifier|*
name|fromsnap_name
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|offset_t
modifier|*
name|offp
parameter_list|)
function_decl|;
comment|/* CRC64 table */
define|#
directive|define
name|ZFS_CRC64_POLY
value|0xC96C5795D7870F42ULL
comment|/* ECMA-182, reflected form */
specifier|extern
name|uint64_t
name|zfs_crc64_table
index|[
literal|256
index|]
decl_stmt|;
specifier|extern
name|int
name|zfs_mdcomp_disable
decl_stmt|;
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_DMU_H */
end_comment

end_unit

