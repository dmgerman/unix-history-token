begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2016 by Delphix. All rights reserved.  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright 2013 Saso Kiselkov. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2017 Joyent, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_SPA_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_SPA_H
end_define

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Forward references that lots of things need.  */
typedef|typedef
name|struct
name|spa
name|spa_t
typedef|;
typedef|typedef
name|struct
name|vdev
name|vdev_t
typedef|;
typedef|typedef
name|struct
name|metaslab
name|metaslab_t
typedef|;
typedef|typedef
name|struct
name|metaslab_group
name|metaslab_group_t
typedef|;
typedef|typedef
name|struct
name|metaslab_class
name|metaslab_class_t
typedef|;
typedef|typedef
name|struct
name|zio
name|zio_t
typedef|;
typedef|typedef
name|struct
name|zilog
name|zilog_t
typedef|;
typedef|typedef
name|struct
name|spa_aux_vdev
name|spa_aux_vdev_t
typedef|;
typedef|typedef
name|struct
name|ddt
name|ddt_t
typedef|;
typedef|typedef
name|struct
name|ddt_entry
name|ddt_entry_t
typedef|;
struct_decl|struct
name|dsl_pool
struct_decl|;
struct_decl|struct
name|dsl_dataset
struct_decl|;
comment|/*  * General-purpose 32-bit and 64-bit bitfield encodings.  */
define|#
directive|define
name|BF32_DECODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|P2PHASE((x)>> (low), 1U<< (len))
define|#
directive|define
name|BF64_DECODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|P2PHASE((x)>> (low), 1ULL<< (len))
define|#
directive|define
name|BF32_ENCODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|(P2PHASE((x), 1U<< (len))<< (low))
define|#
directive|define
name|BF64_ENCODE
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|(P2PHASE((x), 1ULL<< (len))<< (low))
define|#
directive|define
name|BF32_GET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|BF32_DECODE(x, low, len)
define|#
directive|define
name|BF64_GET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|)
value|BF64_DECODE(x, low, len)
define|#
directive|define
name|BF32_SET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
value|do { \ 	ASSERT3U(val,<, 1U<< (len)); \ 	ASSERT3U(low + len,<=, 32); \ 	(x) ^= BF32_ENCODE((x>> low) ^ (val), low, len); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BF64_SET
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|val
parameter_list|)
value|do { \ 	ASSERT3U(val,<, 1ULL<< (len)); \ 	ASSERT3U(low + len,<=, 64); \ 	((x) ^= BF64_ENCODE((x>> low) ^ (val), low, len)); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BF32_GET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|)
define|\
value|((BF32_GET(x, low, len) + (bias))<< (shift))
define|#
directive|define
name|BF64_GET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|)
define|\
value|((BF64_GET(x, low, len) + (bias))<< (shift))
define|#
directive|define
name|BF32_SET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|,
name|val
parameter_list|)
value|do { \ 	ASSERT(IS_P2ALIGNED(val, 1U<< shift)); \ 	ASSERT3S((val)>> (shift),>=, bias); \ 	BF32_SET(x, low, len, ((val)>> (shift)) - (bias)); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BF64_SET_SB
parameter_list|(
name|x
parameter_list|,
name|low
parameter_list|,
name|len
parameter_list|,
name|shift
parameter_list|,
name|bias
parameter_list|,
name|val
parameter_list|)
value|do { \ 	ASSERT(IS_P2ALIGNED(val, 1ULL<< shift)); \ 	ASSERT3S((val)>> (shift),>=, bias); \ 	BF64_SET(x, low, len, ((val)>> (shift)) - (bias)); \ _NOTE(CONSTCOND) } while (0)
comment|/*  * We currently support block sizes from 512 bytes to 16MB.  * The benefits of larger blocks, and thus larger IO, need to be weighed  * against the cost of COWing a giant block to modify one byte, and the  * large latency of reading or writing a large block.  *  * Note that although blocks up to 16MB are supported, the recordsize  * property can not be set larger than zfs_max_recordsize (default 1MB).  * See the comment near zfs_max_recordsize in dsl_dataset.c for details.  *  * Note that although the LSIZE field of the blkptr_t can store sizes up  * to 32MB, the dnode's dn_datablkszsec can only store sizes up to  * 32MB - 512 bytes.  Therefore, we limit SPA_MAXBLOCKSIZE to 16MB.  */
define|#
directive|define
name|SPA_MINBLOCKSHIFT
value|9
define|#
directive|define
name|SPA_OLD_MAXBLOCKSHIFT
value|17
define|#
directive|define
name|SPA_MAXBLOCKSHIFT
value|24
define|#
directive|define
name|SPA_MINBLOCKSIZE
value|(1ULL<< SPA_MINBLOCKSHIFT)
define|#
directive|define
name|SPA_OLD_MAXBLOCKSIZE
value|(1ULL<< SPA_OLD_MAXBLOCKSHIFT)
define|#
directive|define
name|SPA_MAXBLOCKSIZE
value|(1ULL<< SPA_MAXBLOCKSHIFT)
comment|/*  * Size of block to hold the configuration data (a packed nvlist)  */
define|#
directive|define
name|SPA_CONFIG_BLOCKSIZE
value|(1ULL<< 14)
comment|/*  * The DVA size encodings for LSIZE and PSIZE support blocks up to 32MB.  * The ASIZE encoding should be at least 64 times larger (6 more bits)  * to support up to 4-way RAID-Z mirror mode with worst-case gang block  * overhead, three DVAs per bp, plus one more bit in case we do anything  * else that expands the ASIZE.  */
define|#
directive|define
name|SPA_LSIZEBITS
value|16
comment|/* LSIZE up to 32M (2^16 * 512)	*/
define|#
directive|define
name|SPA_PSIZEBITS
value|16
comment|/* PSIZE up to 32M (2^16 * 512)	*/
define|#
directive|define
name|SPA_ASIZEBITS
value|24
comment|/* ASIZE up to 64 times larger	*/
define|#
directive|define
name|SPA_COMPRESSBITS
value|7
comment|/*  * All SPA data is represented by 128-bit data virtual addresses (DVAs).  * The members of the dva_t should be considered opaque outside the SPA.  */
typedef|typedef
struct|struct
name|dva
block|{
name|uint64_t
name|dva_word
index|[
literal|2
index|]
decl_stmt|;
block|}
name|dva_t
typedef|;
comment|/*  * Each block has a 256-bit checksum -- strong enough for cryptographic hashes.  */
typedef|typedef
struct|struct
name|zio_cksum
block|{
name|uint64_t
name|zc_word
index|[
literal|4
index|]
decl_stmt|;
block|}
name|zio_cksum_t
typedef|;
comment|/*  * Some checksums/hashes need a 256-bit initialization salt. This salt is kept  * secret and is suitable for use in MAC algorithms as the key.  */
typedef|typedef
struct|struct
name|zio_cksum_salt
block|{
name|uint8_t
name|zcs_bytes
index|[
literal|32
index|]
decl_stmt|;
block|}
name|zio_cksum_salt_t
typedef|;
comment|/*  * Each block is described by its DVAs, time of birth, checksum, etc.  * The word-by-word, bit-by-bit layout of the blkptr is as follows:  *  *	64	56	48	40	32	24	16	8	0  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 0	|		vdev1		| GRID  |	  ASIZE		|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 1	|G|			 offset1				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 2	|		vdev2		| GRID  |	  ASIZE		|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 3	|G|			 offset2				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 4	|		vdev3		| GRID  |	  ASIZE		|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 5	|G|			 offset3				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 6	|BDX|lvl| type	| cksum |E| comp|    PSIZE	|     LSIZE	|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 7	|			padding					|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 8	|			padding					|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 9	|			physical birth txg			|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * a	|			logical birth txg			|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * b	|			fill count				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * c	|			checksum[0]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * d	|			checksum[1]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * e	|			checksum[2]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * f	|			checksum[3]				|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  *  * Legend:  *  * vdev		virtual device ID  * offset	offset into virtual device  * LSIZE	logical size  * PSIZE	physical size (after compression)  * ASIZE	allocated size (including RAID-Z parity and gang block headers)  * GRID		RAID-Z layout information (reserved for future use)  * cksum	checksum function  * comp		compression function  * G		gang block indicator  * B		byteorder (endianness)  * D		dedup  * X		encryption (on version 30, which is not supported)  * E		blkptr_t contains embedded data (see below)  * lvl		level of indirection  * type		DMU object type  * phys birth	txg of block allocation; zero if same as logical birth txg  * log. birth	transaction group in which the block was logically born  * fill count	number of non-zero blocks under this bp  * checksum[4]	256-bit checksum of the data this bp describes  */
comment|/*  * "Embedded" blkptr_t's don't actually point to a block, instead they  * have a data payload embedded in the blkptr_t itself.  See the comment  * in blkptr.c for more details.  *  * The blkptr_t is laid out as follows:  *  *	64	56	48	40	32	24	16	8	0  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 0	|      payload                                                  |  * 1	|      payload                                                  |  * 2	|      payload                                                  |  * 3	|      payload                                                  |  * 4	|      payload                                                  |  * 5	|      payload                                                  |  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 6	|BDX|lvl| type	| etype |E| comp| PSIZE|              LSIZE	|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * 7	|      payload                                                  |  * 8	|      payload                                                  |  * 9	|      payload                                                  |  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * a	|			logical birth txg			|  *	+-------+-------+-------+-------+-------+-------+-------+-------+  * b	|      payload                                                  |  * c	|      payload                                                  |  * d	|      payload                                                  |  * e	|      payload                                                  |  * f	|      payload                                                  |  *	+-------+-------+-------+-------+-------+-------+-------+-------+  *  * Legend:  *  * payload		contains the embedded data  * B (byteorder)	byteorder (endianness)  * D (dedup)		padding (set to zero)  * X			encryption (set to zero; see above)  * E (embedded)		set to one  * lvl			indirection level  * type			DMU object type  * etype		how to interpret embedded data (BP_EMBEDDED_TYPE_*)  * comp			compression function of payload  * PSIZE		size of payload after compression, in bytes  * LSIZE		logical size of payload, in bytes  *			note that 25 bits is enough to store the largest  *			"normal" BP's LSIZE (2^16 * 2^9) in bytes  * log. birth		transaction group in which the block was logically born  *  * Note that LSIZE and PSIZE are stored in bytes, whereas for non-embedded  * bp's they are stored in units of SPA_MINBLOCKSHIFT.  * Generally, the generic BP_GET_*() macros can be used on embedded BP's.  * The B, D, X, lvl, type, and comp fields are stored the same as with normal  * BP's so the BP_SET_* macros can be used with them.  etype, PSIZE, LSIZE must  * be set with the BPE_SET_* macros.  BP_SET_EMBEDDED() should be called before  * other macros, as they assert that they are only used on BP's of the correct  * "embedded-ness".  */
define|#
directive|define
name|BPE_GET_ETYPE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(ASSERT(BP_IS_EMBEDDED(bp)), \ 	BF64_GET((bp)->blk_prop, 40, 8))
define|#
directive|define
name|BPE_SET_ETYPE
parameter_list|(
name|bp
parameter_list|,
name|t
parameter_list|)
value|do { \ 	ASSERT(BP_IS_EMBEDDED(bp)); \ 	BF64_SET((bp)->blk_prop, 40, 8, t); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BPE_GET_LSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(ASSERT(BP_IS_EMBEDDED(bp)), \ 	BF64_GET_SB((bp)->blk_prop, 0, 25, 0, 1))
define|#
directive|define
name|BPE_SET_LSIZE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|do { \ 	ASSERT(BP_IS_EMBEDDED(bp)); \ 	BF64_SET_SB((bp)->blk_prop, 0, 25, 0, 1, x); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BPE_GET_PSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(ASSERT(BP_IS_EMBEDDED(bp)), \ 	BF64_GET_SB((bp)->blk_prop, 25, 7, 0, 1))
define|#
directive|define
name|BPE_SET_PSIZE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|do { \ 	ASSERT(BP_IS_EMBEDDED(bp)); \ 	BF64_SET_SB((bp)->blk_prop, 25, 7, 0, 1, x); \ _NOTE(CONSTCOND) } while (0)
typedef|typedef
enum|enum
name|bp_embedded_type
block|{
name|BP_EMBEDDED_TYPE_DATA
block|,
name|BP_EMBEDDED_TYPE_RESERVED
block|,
comment|/* Reserved for an unintegrated feature. */
name|NUM_BP_EMBEDDED_TYPES
init|=
name|BP_EMBEDDED_TYPE_RESERVED
block|}
name|bp_embedded_type_t
typedef|;
define|#
directive|define
name|BPE_NUM_WORDS
value|14
define|#
directive|define
name|BPE_PAYLOAD_SIZE
value|(BPE_NUM_WORDS * sizeof (uint64_t))
define|#
directive|define
name|BPE_IS_PAYLOADWORD
parameter_list|(
name|bp
parameter_list|,
name|wp
parameter_list|)
define|\
value|((wp) !=&(bp)->blk_prop&& (wp) !=&(bp)->blk_birth)
define|#
directive|define
name|SPA_BLKPTRSHIFT
value|7
comment|/* blkptr_t is 128 bytes	*/
define|#
directive|define
name|SPA_DVAS_PER_BP
value|3
comment|/* Number of DVAs in a bp	*/
comment|/*  * A block is a hole when it has either 1) never been written to, or  * 2) is zero-filled. In both cases, ZFS can return all zeroes for all reads  * without physically allocating disk space. Holes are represented in the  * blkptr_t structure by zeroed blk_dva. Correct checking for holes is  * done through the BP_IS_HOLE macro. For holes, the logical size, level,  * DMU object type, and birth times are all also stored for holes that  * were written to at some point (i.e. were punched after having been filled).  */
typedef|typedef
struct|struct
name|blkptr
block|{
name|dva_t
name|blk_dva
index|[
name|SPA_DVAS_PER_BP
index|]
decl_stmt|;
comment|/* Data Virtual Addresses */
name|uint64_t
name|blk_prop
decl_stmt|;
comment|/* size, compression, type, etc	    */
name|uint64_t
name|blk_pad
index|[
literal|2
index|]
decl_stmt|;
comment|/* Extra space for the future	    */
name|uint64_t
name|blk_phys_birth
decl_stmt|;
comment|/* txg when block was allocated	    */
name|uint64_t
name|blk_birth
decl_stmt|;
comment|/* transaction group at birth	    */
name|uint64_t
name|blk_fill
decl_stmt|;
comment|/* fill count			    */
name|zio_cksum_t
name|blk_cksum
decl_stmt|;
comment|/* 256-bit checksum		    */
block|}
name|blkptr_t
typedef|;
comment|/*  * Macros to get and set fields in a bp or DVA.  */
define|#
directive|define
name|DVA_GET_ASIZE
parameter_list|(
name|dva
parameter_list|)
define|\
value|BF64_GET_SB((dva)->dva_word[0], 0, SPA_ASIZEBITS, SPA_MINBLOCKSHIFT, 0)
define|#
directive|define
name|DVA_SET_ASIZE
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
define|\
value|BF64_SET_SB((dva)->dva_word[0], 0, SPA_ASIZEBITS, \ 	SPA_MINBLOCKSHIFT, 0, x)
define|#
directive|define
name|DVA_GET_GRID
parameter_list|(
name|dva
parameter_list|)
value|BF64_GET((dva)->dva_word[0], 24, 8)
define|#
directive|define
name|DVA_SET_GRID
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((dva)->dva_word[0], 24, 8, x)
define|#
directive|define
name|DVA_GET_VDEV
parameter_list|(
name|dva
parameter_list|)
value|BF64_GET((dva)->dva_word[0], 32, 32)
define|#
directive|define
name|DVA_SET_VDEV
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((dva)->dva_word[0], 32, 32, x)
define|#
directive|define
name|DVA_GET_OFFSET
parameter_list|(
name|dva
parameter_list|)
define|\
value|BF64_GET_SB((dva)->dva_word[1], 0, 63, SPA_MINBLOCKSHIFT, 0)
define|#
directive|define
name|DVA_SET_OFFSET
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
define|\
value|BF64_SET_SB((dva)->dva_word[1], 0, 63, SPA_MINBLOCKSHIFT, 0, x)
define|#
directive|define
name|DVA_GET_GANG
parameter_list|(
name|dva
parameter_list|)
value|BF64_GET((dva)->dva_word[1], 63, 1)
define|#
directive|define
name|DVA_SET_GANG
parameter_list|(
name|dva
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((dva)->dva_word[1], 63, 1, x)
define|#
directive|define
name|BP_GET_LSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ?	\ 	(BPE_GET_ETYPE(bp) == BP_EMBEDDED_TYPE_DATA ? BPE_GET_LSIZE(bp) : 0): \ 	BF64_GET_SB((bp)->blk_prop, 0, SPA_LSIZEBITS, SPA_MINBLOCKSHIFT, 1))
define|#
directive|define
name|BP_SET_LSIZE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|do { \ 	ASSERT(!BP_IS_EMBEDDED(bp)); \ 	BF64_SET_SB((bp)->blk_prop, \ 	    0, SPA_LSIZEBITS, SPA_MINBLOCKSHIFT, 1, x); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BP_GET_PSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ? 0 : \ 	BF64_GET_SB((bp)->blk_prop, 16, SPA_PSIZEBITS, SPA_MINBLOCKSHIFT, 1))
define|#
directive|define
name|BP_SET_PSIZE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|do { \ 	ASSERT(!BP_IS_EMBEDDED(bp)); \ 	BF64_SET_SB((bp)->blk_prop, \ 	    16, SPA_PSIZEBITS, SPA_MINBLOCKSHIFT, 1, x); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BP_GET_COMPRESS
parameter_list|(
name|bp
parameter_list|)
define|\
value|BF64_GET((bp)->blk_prop, 32, SPA_COMPRESSBITS)
define|#
directive|define
name|BP_SET_COMPRESS
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
define|\
value|BF64_SET((bp)->blk_prop, 32, SPA_COMPRESSBITS, x)
define|#
directive|define
name|BP_IS_EMBEDDED
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 39, 1)
define|#
directive|define
name|BP_SET_EMBEDDED
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 39, 1, x)
define|#
directive|define
name|BP_GET_CHECKSUM
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ? ZIO_CHECKSUM_OFF : \ 	BF64_GET((bp)->blk_prop, 40, 8))
define|#
directive|define
name|BP_SET_CHECKSUM
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|do { \ 	ASSERT(!BP_IS_EMBEDDED(bp)); \ 	BF64_SET((bp)->blk_prop, 40, 8, x); \ _NOTE(CONSTCOND) } while (0)
define|#
directive|define
name|BP_GET_TYPE
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 48, 8)
define|#
directive|define
name|BP_SET_TYPE
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 48, 8, x)
define|#
directive|define
name|BP_GET_LEVEL
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 56, 5)
define|#
directive|define
name|BP_SET_LEVEL
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 56, 5, x)
define|#
directive|define
name|BP_GET_DEDUP
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 62, 1)
define|#
directive|define
name|BP_SET_DEDUP
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 62, 1, x)
define|#
directive|define
name|BP_GET_BYTEORDER
parameter_list|(
name|bp
parameter_list|)
value|BF64_GET((bp)->blk_prop, 63, 1)
define|#
directive|define
name|BP_SET_BYTEORDER
parameter_list|(
name|bp
parameter_list|,
name|x
parameter_list|)
value|BF64_SET((bp)->blk_prop, 63, 1, x)
define|#
directive|define
name|BP_PHYSICAL_BIRTH
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ? 0 : \ 	(bp)->blk_phys_birth ? (bp)->blk_phys_birth : (bp)->blk_birth)
define|#
directive|define
name|BP_SET_BIRTH
parameter_list|(
name|bp
parameter_list|,
name|logical
parameter_list|,
name|physical
parameter_list|)
define|\
value|{						\ 	ASSERT(!BP_IS_EMBEDDED(bp));		\ 	(bp)->blk_birth = (logical);		\ 	(bp)->blk_phys_birth = ((logical) == (physical) ? 0 : (physical)); \ }
define|#
directive|define
name|BP_GET_FILL
parameter_list|(
name|bp
parameter_list|)
value|(BP_IS_EMBEDDED(bp) ? 1 : (bp)->blk_fill)
define|#
directive|define
name|BP_IS_METADATA
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_GET_LEVEL(bp)> 0 || DMU_OT_IS_METADATA(BP_GET_TYPE(bp)))
define|#
directive|define
name|BP_GET_ASIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ? 0 : \ 	DVA_GET_ASIZE(&(bp)->blk_dva[0]) + \ 	DVA_GET_ASIZE(&(bp)->blk_dva[1]) + \ 	DVA_GET_ASIZE(&(bp)->blk_dva[2]))
define|#
directive|define
name|BP_GET_UCSIZE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_METADATA(bp) ? BP_GET_PSIZE(bp) : BP_GET_LSIZE(bp))
define|#
directive|define
name|BP_GET_NDVAS
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ? 0 : \ 	!!DVA_GET_ASIZE(&(bp)->blk_dva[0]) + \ 	!!DVA_GET_ASIZE(&(bp)->blk_dva[1]) + \ 	!!DVA_GET_ASIZE(&(bp)->blk_dva[2]))
define|#
directive|define
name|BP_COUNT_GANG
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ? 0 : \ 	(DVA_GET_GANG(&(bp)->blk_dva[0]) + \ 	DVA_GET_GANG(&(bp)->blk_dva[1]) + \ 	DVA_GET_GANG(&(bp)->blk_dva[2])))
define|#
directive|define
name|DVA_EQUAL
parameter_list|(
name|dva1
parameter_list|,
name|dva2
parameter_list|)
define|\
value|((dva1)->dva_word[1] == (dva2)->dva_word[1]&& \ 	(dva1)->dva_word[0] == (dva2)->dva_word[0])
define|#
directive|define
name|BP_EQUAL
parameter_list|(
name|bp1
parameter_list|,
name|bp2
parameter_list|)
define|\
value|(BP_PHYSICAL_BIRTH(bp1) == BP_PHYSICAL_BIRTH(bp2)&&	\ 	(bp1)->blk_birth == (bp2)->blk_birth&&			\ 	DVA_EQUAL(&(bp1)->blk_dva[0],&(bp2)->blk_dva[0])&&	\ 	DVA_EQUAL(&(bp1)->blk_dva[1],&(bp2)->blk_dva[1])&&	\ 	DVA_EQUAL(&(bp1)->blk_dva[2],&(bp2)->blk_dva[2]))
define|#
directive|define
name|ZIO_CHECKSUM_EQUAL
parameter_list|(
name|zc1
parameter_list|,
name|zc2
parameter_list|)
define|\
value|(0 == (((zc1).zc_word[0] - (zc2).zc_word[0]) | \ 	((zc1).zc_word[1] - (zc2).zc_word[1]) | \ 	((zc1).zc_word[2] - (zc2).zc_word[2]) | \ 	((zc1).zc_word[3] - (zc2).zc_word[3])))
define|#
directive|define
name|ZIO_CHECKSUM_IS_ZERO
parameter_list|(
name|zc
parameter_list|)
define|\
value|(0 == ((zc)->zc_word[0] | (zc)->zc_word[1] | \ 	(zc)->zc_word[2] | (zc)->zc_word[3]))
define|#
directive|define
name|ZIO_CHECKSUM_BSWAP
parameter_list|(
name|zcp
parameter_list|)
define|\
value|{								\ 	(zcp)->zc_word[0] = BSWAP_64((zcp)->zc_word[0]);	\ 	(zcp)->zc_word[1] = BSWAP_64((zcp)->zc_word[1]);	\ 	(zcp)->zc_word[2] = BSWAP_64((zcp)->zc_word[2]);	\ 	(zcp)->zc_word[3] = BSWAP_64((zcp)->zc_word[3]);	\ }
define|#
directive|define
name|DVA_IS_VALID
parameter_list|(
name|dva
parameter_list|)
value|(DVA_GET_ASIZE(dva) != 0)
define|#
directive|define
name|ZIO_SET_CHECKSUM
parameter_list|(
name|zcp
parameter_list|,
name|w0
parameter_list|,
name|w1
parameter_list|,
name|w2
parameter_list|,
name|w3
parameter_list|)
define|\
value|{						\ 	(zcp)->zc_word[0] = w0;			\ 	(zcp)->zc_word[1] = w1;			\ 	(zcp)->zc_word[2] = w2;			\ 	(zcp)->zc_word[3] = w3;			\ }
define|#
directive|define
name|BP_IDENTITY
parameter_list|(
name|bp
parameter_list|)
value|(ASSERT(!BP_IS_EMBEDDED(bp)),&(bp)->blk_dva[0])
define|#
directive|define
name|BP_IS_GANG
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_EMBEDDED(bp) ? B_FALSE : DVA_GET_GANG(BP_IDENTITY(bp)))
define|#
directive|define
name|DVA_IS_EMPTY
parameter_list|(
name|dva
parameter_list|)
value|((dva)->dva_word[0] == 0ULL&&	\ 				(dva)->dva_word[1] == 0ULL)
define|#
directive|define
name|BP_IS_HOLE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(!BP_IS_EMBEDDED(bp)&& DVA_IS_EMPTY(BP_IDENTITY(bp)))
comment|/* BP_IS_RAIDZ(bp) assumes no block compression */
define|#
directive|define
name|BP_IS_RAIDZ
parameter_list|(
name|bp
parameter_list|)
value|(DVA_GET_ASIZE(&(bp)->blk_dva[0])> \ 				BP_GET_PSIZE(bp))
define|#
directive|define
name|BP_ZERO
parameter_list|(
name|bp
parameter_list|)
define|\
value|{						\ 	(bp)->blk_dva[0].dva_word[0] = 0;	\ 	(bp)->blk_dva[0].dva_word[1] = 0;	\ 	(bp)->blk_dva[1].dva_word[0] = 0;	\ 	(bp)->blk_dva[1].dva_word[1] = 0;	\ 	(bp)->blk_dva[2].dva_word[0] = 0;	\ 	(bp)->blk_dva[2].dva_word[1] = 0;	\ 	(bp)->blk_prop = 0;			\ 	(bp)->blk_pad[0] = 0;			\ 	(bp)->blk_pad[1] = 0;			\ 	(bp)->blk_phys_birth = 0;		\ 	(bp)->blk_birth = 0;			\ 	(bp)->blk_fill = 0;			\ 	ZIO_SET_CHECKSUM(&(bp)->blk_cksum, 0, 0, 0, 0);	\ }
ifdef|#
directive|ifdef
name|_BIG_ENDIAN
define|#
directive|define
name|ZFS_HOST_BYTEORDER
value|(0ULL)
else|#
directive|else
define|#
directive|define
name|ZFS_HOST_BYTEORDER
value|(1ULL)
endif|#
directive|endif
define|#
directive|define
name|BP_SHOULD_BYTESWAP
parameter_list|(
name|bp
parameter_list|)
value|(BP_GET_BYTEORDER(bp) != ZFS_HOST_BYTEORDER)
define|#
directive|define
name|BP_SPRINTF_LEN
value|320
comment|/*  * This macro allows code sharing between zfs, libzpool, and mdb.  * 'func' is either snprintf() or mdb_snprintf().  * 'ws' (whitespace) can be ' ' for single-line format, '\n' for multi-line.  */
define|#
directive|define
name|SNPRINTF_BLKPTR
parameter_list|(
name|func
parameter_list|,
name|ws
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|,
name|bp
parameter_list|,
name|type
parameter_list|,
name|checksum
parameter_list|,
name|compress
parameter_list|)
define|\
value|{									\ 	static const char *copyname[] =					\ 	    { "zero", "single", "double", "triple" };			\ 	int len = 0;							\ 	int copies = 0;							\ 									\ 	if (bp == NULL) {						\ 		len += func(buf + len, size - len, "<NULL>");		\ 	} else if (BP_IS_HOLE(bp)) {					\ 		len += func(buf + len, size - len,			\ 		    "HOLE [L%llu %s] "					\ 		    "size=%llxL birth=%lluL",				\ 		    (u_longlong_t)BP_GET_LEVEL(bp),			\ 		    type,						\ 		    (u_longlong_t)BP_GET_LSIZE(bp),			\ 		    (u_longlong_t)bp->blk_birth);			\ 	} else if (BP_IS_EMBEDDED(bp)) {				\ 		len = func(buf + len, size - len,			\ 		    "EMBEDDED [L%llu %s] et=%u %s "			\ 		    "size=%llxL/%llxP birth=%lluL",			\ 		    (u_longlong_t)BP_GET_LEVEL(bp),			\ 		    type,						\ 		    (int)BPE_GET_ETYPE(bp),				\ 		    compress,						\ 		    (u_longlong_t)BPE_GET_LSIZE(bp),			\ 		    (u_longlong_t)BPE_GET_PSIZE(bp),			\ 		    (u_longlong_t)bp->blk_birth);			\ 	} else {							\ 		for (int d = 0; d< BP_GET_NDVAS(bp); d++) {		\ 			const dva_t *dva =&bp->blk_dva[d];		\ 			if (DVA_IS_VALID(dva))				\ 				copies++;				\ 			len += func(buf + len, size - len,		\ 			    "DVA[%d]=<%llu:%llx:%llx>%c", d,		\ 			    (u_longlong_t)DVA_GET_VDEV(dva),		\ 			    (u_longlong_t)DVA_GET_OFFSET(dva),		\ 			    (u_longlong_t)DVA_GET_ASIZE(dva),		\ 			    ws);					\ 		}							\ 		if (BP_IS_GANG(bp)&&					\ 		    DVA_GET_ASIZE(&bp->blk_dva[2])<=			\ 		    DVA_GET_ASIZE(&bp->blk_dva[1]) / 2)			\ 			copies--;					\ 		len += func(buf + len, size - len,			\ 		    "[L%llu %s] %s %s %s %s %s %s%c"			\ 		    "size=%llxL/%llxP birth=%lluL/%lluP fill=%llu%c"	\ 		    "cksum=%llx:%llx:%llx:%llx",			\ 		    (u_longlong_t)BP_GET_LEVEL(bp),			\ 		    type,						\ 		    checksum,						\ 		    compress,						\ 		    BP_GET_BYTEORDER(bp) == 0 ? "BE" : "LE",		\ 		    BP_IS_GANG(bp) ? "gang" : "contiguous",		\ 		    BP_GET_DEDUP(bp) ? "dedup" : "unique",		\ 		    copyname[copies],					\ 		    ws,							\ 		    (u_longlong_t)BP_GET_LSIZE(bp),			\ 		    (u_longlong_t)BP_GET_PSIZE(bp),			\ 		    (u_longlong_t)bp->blk_birth,			\ 		    (u_longlong_t)BP_PHYSICAL_BIRTH(bp),		\ 		    (u_longlong_t)BP_GET_FILL(bp),			\ 		    ws,							\ 		    (u_longlong_t)bp->blk_cksum.zc_word[0],		\ 		    (u_longlong_t)bp->blk_cksum.zc_word[1],		\ 		    (u_longlong_t)bp->blk_cksum.zc_word[2],		\ 		    (u_longlong_t)bp->blk_cksum.zc_word[3]);		\ 	}								\ 	ASSERT(len< size);						\ }
define|#
directive|define
name|BP_GET_BUFC_TYPE
parameter_list|(
name|bp
parameter_list|)
define|\
value|(BP_IS_METADATA(bp) ? ARC_BUFC_METADATA : ARC_BUFC_DATA)
typedef|typedef
enum|enum
name|spa_import_type
block|{
name|SPA_IMPORT_EXISTING
block|,
name|SPA_IMPORT_ASSEMBLE
block|}
name|spa_import_type_t
typedef|;
comment|/* state manipulation functions */
specifier|extern
name|int
name|spa_open
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|spa_t
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_open_rewind
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|spa_t
modifier|*
modifier|*
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|nvlist_t
modifier|*
name|policy
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_get_stats
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|altroot
parameter_list|,
name|size_t
name|buflen
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_create
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
name|zplprops
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_import_rootpool
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_import
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
function_decl|;
specifier|extern
name|nvlist_t
modifier|*
name|spa_tryimport
parameter_list|(
name|nvlist_t
modifier|*
name|tryconfig
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_destroy
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_export
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_reset
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_request
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_unrequest
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|flag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_inject_addref
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_inject_delref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_scan_stat_init
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_scan_get_stats
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scan_stat_t
modifier|*
name|ps
parameter_list|)
function_decl|;
define|#
directive|define
name|SPA_ASYNC_CONFIG_UPDATE
value|0x01
define|#
directive|define
name|SPA_ASYNC_REMOVE
value|0x02
define|#
directive|define
name|SPA_ASYNC_PROBE
value|0x04
define|#
directive|define
name|SPA_ASYNC_RESILVER_DONE
value|0x08
define|#
directive|define
name|SPA_ASYNC_RESILVER
value|0x10
define|#
directive|define
name|SPA_ASYNC_AUTOEXPAND
value|0x20
define|#
directive|define
name|SPA_ASYNC_REMOVE_DONE
value|0x40
define|#
directive|define
name|SPA_ASYNC_REMOVE_STOP
value|0x80
comment|/*  * Controls the behavior of spa_vdev_remove().  */
define|#
directive|define
name|SPA_REMOVE_UNSPARE
value|0x01
define|#
directive|define
name|SPA_REMOVE_DONE
value|0x02
comment|/* device manipulation */
specifier|extern
name|int
name|spa_vdev_add
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_attach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_detach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
name|pguid
parameter_list|,
name|int
name|replace_done
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|unspare
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_vdev_remove_active
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_setpath
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_setfru
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newfru
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_split_mirror
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|boolean_t
name|exp
parameter_list|)
function_decl|;
comment|/* spare state (which is global across all pools) */
specifier|extern
name|void
name|spa_spare_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_spare_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_spare_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|,
name|int
modifier|*
name|refcnt
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_spare_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
comment|/* L2ARC state (which is global across all pools) */
specifier|extern
name|void
name|spa_l2cache_add
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_l2cache_remove
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_l2cache_exists
parameter_list|(
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
modifier|*
name|pool
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_l2cache_activate
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_l2cache_drop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* scanning */
specifier|extern
name|int
name|spa_scan
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scan_func_t
name|func
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_scan_stop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* spa syncing */
specifier|extern
name|void
name|spa_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
function_decl|;
comment|/* only for DMU use */
specifier|extern
name|void
name|spa_sync_allpools
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* spa namespace global mutex */
specifier|extern
name|kmutex_t
name|spa_namespace_lock
decl_stmt|;
comment|/*  * SPA configuration functions in spa_config.c  */
define|#
directive|define
name|SPA_CONFIG_UPDATE_POOL
value|0
define|#
directive|define
name|SPA_CONFIG_UPDATE_VDEVS
value|1
specifier|extern
name|void
name|spa_config_sync
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|boolean_t
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_load
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|nvlist_t
modifier|*
name|spa_all_configs
parameter_list|(
name|uint64_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
function_decl|;
specifier|extern
name|nvlist_t
modifier|*
name|spa_config_generate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|getstats
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_update
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|what
parameter_list|)
function_decl|;
comment|/*  * Miscellaneous SPA routines in spa_misc.c  */
comment|/* Namespace manipulation */
specifier|extern
name|spa_t
modifier|*
name|spa_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_add
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|altroot
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_next
parameter_list|(
name|spa_t
modifier|*
name|prev
parameter_list|)
function_decl|;
comment|/* Refcount functions */
specifier|extern
name|void
name|spa_open_ref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_close
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_async_close
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_refcount_zero
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
define|#
directive|define
name|SCL_NONE
value|0x00
define|#
directive|define
name|SCL_CONFIG
value|0x01
define|#
directive|define
name|SCL_STATE
value|0x02
define|#
directive|define
name|SCL_L2ARC
value|0x04
comment|/* hack until L2ARC 2.0 */
define|#
directive|define
name|SCL_ALLOC
value|0x08
define|#
directive|define
name|SCL_ZIO
value|0x10
define|#
directive|define
name|SCL_FREE
value|0x20
define|#
directive|define
name|SCL_VDEV
value|0x40
define|#
directive|define
name|SCL_LOCKS
value|7
define|#
directive|define
name|SCL_ALL
value|((1<< SCL_LOCKS) - 1)
define|#
directive|define
name|SCL_STATE_ALL
value|(SCL_STATE | SCL_L2ARC | SCL_ZIO)
comment|/* Pool configuration locks */
specifier|extern
name|int
name|spa_config_tryenter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|krw_t
name|rw
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|krw_t
name|rw
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_config_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_config_held
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|locks
parameter_list|,
name|krw_t
name|rw
parameter_list|)
function_decl|;
comment|/* Pool vdev add/remove lock */
specifier|extern
name|uint64_t
name|spa_vdev_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_vdev_config_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_vdev_config_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|error
parameter_list|,
name|char
modifier|*
name|tag
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
comment|/* Pool vdev state change lock */
specifier|extern
name|void
name|spa_vdev_state_enter
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|oplock
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_vdev_state_exit
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|error
parameter_list|)
function_decl|;
comment|/* Log state */
typedef|typedef
enum|enum
name|spa_log_state
block|{
name|SPA_LOG_UNKNOWN
init|=
literal|0
block|,
comment|/* unknown log state */
name|SPA_LOG_MISSING
block|,
comment|/* missing log(s) */
name|SPA_LOG_CLEAR
block|,
comment|/* clear the log(s) */
name|SPA_LOG_GOOD
block|,
comment|/* log(s) are good */
block|}
name|spa_log_state_t
typedef|;
specifier|extern
name|spa_log_state_t
name|spa_get_log_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_set_log_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_log_state_t
name|state
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_offline_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* Log claim callback */
specifier|extern
name|void
name|spa_claim_notify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
comment|/* Accessor functions */
specifier|extern
name|boolean_t
name|spa_shutting_down
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|struct
name|dsl_pool
modifier|*
name|spa_get_dsl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_is_initializing
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|blkptr_t
modifier|*
name|spa_get_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_set_rootblkptr
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_altroot
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_sync_pass
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|char
modifier|*
name|spa_name
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_load_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_last_synced_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_first_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_syncing_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_final_dirty_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|pool_state_t
name|spa_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|spa_load_state_t
name|spa_load_state
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_freeze_txg
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_worst_case_asize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|lsize
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_slop_space
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_update_dspace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_deflate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|metaslab_class_t
modifier|*
name|spa_normal_class
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|metaslab_class_t
modifier|*
name|spa_log_class
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_evicting_os_register
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_evicting_os_deregister
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_evicting_os_wait
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_max_replication
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_prev_software_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_busy
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|uint8_t
name|spa_get_failmode
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_suspended
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_delegation
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|objset_t
modifier|*
name|spa_meta_objset
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_deadman_synctime
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
comment|/* Miscellaneous support routines */
specifier|extern
name|void
name|spa_activate_mos_feature
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_deactivate_mos_feature
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|feature
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_rename
parameter_list|(
specifier|const
name|char
modifier|*
name|oldname
parameter_list|,
specifier|const
name|char
modifier|*
name|newname
parameter_list|)
function_decl|;
specifier|extern
name|spa_t
modifier|*
name|spa_by_guid
parameter_list|(
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|device_guid
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_guid_exists
parameter_list|(
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|device_guid
parameter_list|)
function_decl|;
specifier|extern
name|char
modifier|*
name|spa_strdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_strfree
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_random
parameter_list|(
name|uint64_t
name|range
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_generate_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|snprintf_blkptr
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|buflen
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_freeze
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_change_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_upgrade
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|version
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_evict_all
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|vdev_t
modifier|*
name|spa_lookup_by_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|l2cache
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_has_spare
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|dva_get_dsize_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|bp_get_dsize_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|bp_get_dsize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_has_slogs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_is_root
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_writeable
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|boolean_t
name|spa_has_pending_synctask
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_maxblocksize
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_blkptr_verify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_mode
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|zfs_strtonum
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
modifier|*
name|nptr
parameter_list|)
function_decl|;
specifier|extern
name|char
modifier|*
name|spa_his_ievent_table
index|[]
decl_stmt|;
specifier|extern
name|void
name|spa_history_create_obj
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_history_get
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
modifier|*
name|offset
parameter_list|,
name|uint64_t
modifier|*
name|len_read
parameter_list|,
name|char
modifier|*
name|his_buf
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_history_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|his_buf
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_history_log_nvl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_history_log_version
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|operation
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_history_log_internal
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|operation
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_history_log_internal_ds
parameter_list|(
name|struct
name|dsl_dataset
modifier|*
name|ds
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_history_log_internal_dd
parameter_list|(
name|dsl_dir_t
modifier|*
name|dd
parameter_list|,
specifier|const
name|char
modifier|*
name|operation
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
comment|/* error handling */
struct_decl|struct
name|zbookmark_phys
struct_decl|;
specifier|extern
name|void
name|spa_log_error
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_ereport_post
parameter_list|(
specifier|const
name|char
modifier|*
name|class
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|stateoroffset
parameter_list|,
name|uint64_t
name|length
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_post_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_post_state_change
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|void
name|zfs_post_autoreplace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
function_decl|;
specifier|extern
name|uint64_t
name|spa_get_errlog_size
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_get_errlog
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|void
modifier|*
name|uaddr
parameter_list|,
name|size_t
modifier|*
name|count
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_errlog_rotate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_errlog_drain
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_errlog_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_get_errlists
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|avl_tree_t
modifier|*
name|last
parameter_list|,
name|avl_tree_t
modifier|*
name|scrub
parameter_list|)
function_decl|;
comment|/* vdev cache */
specifier|extern
name|void
name|vdev_cache_stat_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|vdev_cache_stat_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Initialization and termination */
specifier|extern
name|void
name|spa_init
parameter_list|(
name|int
name|flags
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_fini
parameter_list|(
name|void
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_boot_init
parameter_list|()
function_decl|;
comment|/* properties */
specifier|extern
name|int
name|spa_prop_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|)
function_decl|;
specifier|extern
name|int
name|spa_prop_get
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_prop_clear_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
specifier|extern
name|void
name|spa_configfile_set
parameter_list|(
name|spa_t
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|boolean_t
parameter_list|)
function_decl|;
comment|/* asynchronous event notification */
specifier|extern
name|void
name|spa_event_notify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vdev
parameter_list|,
name|nvlist_t
modifier|*
name|hist_nvl
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
ifdef|#
directive|ifdef
name|ZFS_DEBUG
define|#
directive|define
name|dprintf_bp
parameter_list|(
name|bp
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
value|do {				\ 	if (zfs_flags& ZFS_DEBUG_DPRINTF) {			\ 	char *__blkbuf = kmem_alloc(BP_SPRINTF_LEN, KM_SLEEP);	\ 	snprintf_blkptr(__blkbuf, BP_SPRINTF_LEN, (bp));	\ 	dprintf(fmt " %s\n", __VA_ARGS__, __blkbuf);		\ 	kmem_free(__blkbuf, BP_SPRINTF_LEN);			\ 	} \ _NOTE(CONSTCOND) } while (0)
else|#
directive|else
define|#
directive|define
name|dprintf_bp
parameter_list|(
name|bp
parameter_list|,
name|fmt
parameter_list|,
modifier|...
parameter_list|)
endif|#
directive|endif
specifier|extern
name|boolean_t
name|spa_debug_enabled
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
define|#
directive|define
name|spa_dbgmsg
parameter_list|(
name|spa
parameter_list|,
modifier|...
parameter_list|)
define|\
value|{						\ 	if (spa_debug_enabled(spa))		\ 		zfs_dbgmsg(__VA_ARGS__);	\ }
specifier|extern
name|int
name|spa_mode_global
decl_stmt|;
comment|/* mode, e.g. FREAD | FWRITE */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_SPA_H */
end_comment

end_unit

