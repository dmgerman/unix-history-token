begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.  */
end_comment

begin_comment
comment|/*  * Virtual Device Labels  * ---------------------  *  * The vdev label serves several distinct purposes:  *  *	1. Uniquely identify this device as part of a ZFS pool and confirm its  *	   identity within the pool.  *  * 	2. Verify that all the devices given in a configuration are present  *         within the pool.  *  * 	3. Determine the uberblock for the pool.  *  * 	4. In case of an import operation, determine the configuration of the  *         toplevel vdev of which it is a part.  *  * 	5. If an import operation cannot find all the devices in the pool,  *         provide enough information to the administrator to determine which  *         devices are missing.  *  * It is important to note that while the kernel is responsible for writing the  * label, it only consumes the information in the first three cases.  The  * latter information is only consumed in userland when determining the  * configuration to import a pool.  *  *  * Label Organization  * ------------------  *  * Before describing the contents of the label, it's important to understand how  * the labels are written and updated with respect to the uberblock.  *  * When the pool configuration is altered, either because it was newly created  * or a device was added, we want to update all the labels such that we can deal  * with fatal failure at any point.  To this end, each disk has two labels which  * are updated before and after the uberblock is synced.  Assuming we have  * labels and an uberblock with the following transaction groups:  *  *              L1          UB          L2  *           +------+    +------+    +------+  *           |      |    |      |    |      |  *           | t10  |    | t10  |    | t10  |  *           |      |    |      |    |      |  *           +------+    +------+    +------+  *  * In this stable state, the labels and the uberblock were all updated within  * the same transaction group (10).  Each label is mirrored and checksummed, so  * that we can detect when we fail partway through writing the label.  *  * In order to identify which labels are valid, the labels are written in the  * following manner:  *  * 	1. For each vdev, update 'L1' to the new label  * 	2. Update the uberblock  * 	3. For each vdev, update 'L2' to the new label  *  * Given arbitrary failure, we can determine the correct label to use based on  * the transaction group.  If we fail after updating L1 but before updating the  * UB, we will notice that L1's transaction group is greater than the uberblock,  * so L2 must be valid.  If we fail after writing the uberblock but before  * writing L2, we will notice that L2's transaction group is less than L1, and  * therefore L1 is valid.  *  * Another added complexity is that not every label is updated when the config  * is synced.  If we add a single device, we do not want to have to re-write  * every label for every device in the pool.  This means that both L1 and L2 may  * be older than the pool uberblock, because the necessary information is stored  * on another vdev.  *  *  * On-disk Format  * --------------  *  * The vdev label consists of two distinct parts, and is wrapped within the  * vdev_label_t structure.  The label includes 8k of padding to permit legacy  * VTOC disk labels, but is otherwise ignored.  *  * The first half of the label is a packed nvlist which contains pool wide  * properties, per-vdev properties, and configuration information.  It is  * described in more detail below.  *  * The latter half of the label consists of a redundant array of uberblocks.  * These uberblocks are updated whenever a transaction group is committed,  * or when the configuration is updated.  When a pool is loaded, we scan each  * vdev for the 'best' uberblock.  *  *  * Configuration Information  * -------------------------  *  * The nvlist describing the pool and vdev contains the following elements:  *  * 	version		ZFS on-disk version  * 	name		Pool name  * 	state		Pool state  * 	txg		Transaction group in which this label was written  * 	pool_guid	Unique identifier for this pool  * 	vdev_tree	An nvlist describing vdev tree.  *	features_for_read  *			An nvlist of the features necessary for reading the MOS.  *  * Each leaf device label also contains the following:  *  * 	top_guid	Unique ID for top-level vdev in which this is contained  * 	guid		Unique ID for the leaf vdev  *  * The 'vs' configuration follows the format described in 'spa_config.c'.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_comment
comment|/*  * Basic routines to read and write from a vdev label.  * Used throughout the rest of this file.  */
end_comment

begin_function
name|uint64_t
name|vdev_label_offset
parameter_list|(
name|uint64_t
name|psize
parameter_list|,
name|int
name|l
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|offset
operator|<
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE_TYPED
argument_list|(
name|psize
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
argument_list|,
name|uint64_t
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|+
name|l
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|+
operator|(
name|l
operator|<
name|VDEV_LABELS
operator|/
literal|2
condition|?
literal|0
else|:
name|psize
operator|-
name|VDEV_LABELS
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns back the vdev label associated with the passed in offset.  */
end_comment

begin_function
name|int
name|vdev_label_number
parameter_list|(
name|uint64_t
name|psize
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
if|if
condition|(
name|offset
operator|>=
name|psize
operator|-
name|VDEV_LABEL_END_SIZE
condition|)
block|{
name|offset
operator|-=
name|psize
operator|-
name|VDEV_LABEL_END_SIZE
expr_stmt|;
name|offset
operator|+=
operator|(
name|VDEV_LABELS
operator|/
literal|2
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
expr_stmt|;
block|}
name|l
operator|=
name|offset
operator|/
sizeof|sizeof
argument_list|(
name|vdev_label_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|l
operator|<
name|VDEV_LABELS
condition|?
name|l
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_label_read
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|l
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read_phys
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|vdev_label_offset
argument_list|(
name|vd
operator|->
name|vdev_psize
argument_list|,
name|l
argument_list|,
name|offset
argument_list|)
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|ZIO_CHECKSUM_LABEL
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|flags
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_label_write
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|l
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
operator|||
operator|(
name|spa_config_held
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|RW_READER
argument_list|)
operator|==
operator|(
name|SCL_CONFIG
operator||
name|SCL_STATE
operator|)
operator|&&
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_write_phys
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|vdev_label_offset
argument_list|(
name|vd
operator|->
name|vdev_psize
argument_list|,
name|l
argument_list|,
name|offset
argument_list|)
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|ZIO_CHECKSUM_LABEL
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_PRIORITY_SYNC_WRITE
argument_list|,
name|flags
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the nvlist representing this vdev's config.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|vdev_config_generate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|boolean_t
name|getstats
parameter_list|,
name|vdev_config_flag_t
name|flags
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|nv
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|VDEV_CONFIG_SPARE
operator||
name|VDEV_CONFIG_L2CACHE
operator|)
operator|)
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
name|vd
operator|->
name|vdev_id
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PATH
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEVID
argument_list|,
name|vd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_physpath
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_PHYS_PATH
argument_list|,
name|vd
operator|->
name|vdev_physpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_fru
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_FRU
argument_list|,
name|vd
operator|->
name|vdev_fru
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_nparity
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|strcmp
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|,
name|VDEV_TYPE_RAIDZ
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Make sure someone hasn't managed to sneak a fancy new vdev 		 * into a crufty old storage pool. 		 */
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_nparity
operator|==
literal|1
operator|||
operator|(
name|vd
operator|->
name|vdev_nparity
operator|<=
literal|2
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_RAIDZ2
operator|)
operator|||
operator|(
name|vd
operator|->
name|vdev_nparity
operator|<=
literal|3
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_RAIDZ3
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Note that we'll add the nparity tag even on storage pools 		 * that only support a single parity device -- older software 		 * will just ignore it. 		 */
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NPARITY
argument_list|,
name|vd
operator|->
name|vdev_nparity
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_wholedisk
operator|!=
operator|-
literal|1ULL
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_WHOLE_DISK
argument_list|,
name|vd
operator|->
name|vdev_wholedisk
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_not_present
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_NOT_PRESENT
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isspare
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|VDEV_CONFIG_SPARE
operator||
name|VDEV_CONFIG_L2CACHE
operator|)
operator|)
operator|&&
name|vd
operator|==
name|vd
operator|->
name|vdev_top
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_ARRAY
argument_list|,
name|vd
operator|->
name|vdev_ms_array
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_METASLAB_SHIFT
argument_list|,
name|vd
operator|->
name|vdev_ms_shift
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ASIZE
argument_list|,
name|vd
operator|->
name|vdev_asize
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
name|vd
operator|->
name|vdev_islog
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_removing
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REMOVING
argument_list|,
name|vd
operator|->
name|vdev_removing
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_dtl_sm
operator|!=
name|NULL
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DTL
argument_list|,
name|space_map_object
argument_list|(
name|vd
operator|->
name|vdev_dtl_sm
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_crtxg
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CREATE_TXG
argument_list|,
name|vd
operator|->
name|vdev_crtxg
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|VDEV_CONFIG_MOS
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_leaf_zap
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_LEAF_ZAP
argument_list|,
name|vd
operator|->
name|vdev_leaf_zap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_top_zap
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_TOP_ZAP
argument_list|,
name|vd
operator|->
name|vdev_top_zap
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|getstats
condition|)
block|{
name|vdev_stat_t
name|vs
decl_stmt|;
name|pool_scan_stat_t
name|ps
decl_stmt|;
name|vdev_get_stats
argument_list|(
name|vd
argument_list|,
operator|&
name|vs
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|vs
argument_list|,
sizeof|sizeof
argument_list|(
name|vs
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* provide either current or previous scan information */
if|if
condition|(
name|spa_scan_get_stats
argument_list|(
name|spa
argument_list|,
operator|&
name|ps
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnvlist_add_uint64_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_SCAN_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
operator|&
name|ps
argument_list|,
sizeof|sizeof
argument_list|(
name|pool_scan_stat_t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|int
name|c
decl_stmt|,
name|idx
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
name|child
operator|=
name|kmem_alloc
argument_list|(
name|vd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|idx
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
comment|/* 			 * If we're generating an nvlist of removing 			 * vdevs then skip over any device which is 			 * not being removed. 			 */
if|if
condition|(
operator|(
name|flags
operator|&
name|VDEV_CONFIG_REMOVING
operator|)
operator|&&
operator|!
name|cvd
operator|->
name|vdev_removing
condition|)
continue|continue;
name|child
index|[
name|idx
operator|++
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|cvd
argument_list|,
name|getstats
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
condition|)
block|{
name|fnvlist_add_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|idx
condition|;
name|c
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|child
argument_list|,
name|vd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
specifier|const
name|char
modifier|*
name|aux
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_offline
operator|&&
operator|!
name|vd
operator|->
name|vdev_tmpoffline
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_OFFLINE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_resilver_txg
operator|!=
literal|0
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_RESILVER_TXG
argument_list|,
name|vd
operator|->
name|vdev_resilver_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_faulted
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_FAULTED
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_degraded
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_DEGRADED
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_removed
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_REMOVED
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_unspare
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_UNSPARE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ishole
condition|)
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
condition|)
block|{
case|case
name|VDEV_AUX_ERR_EXCEEDED
case|:
name|aux
operator|=
literal|"err_exceeded"
expr_stmt|;
break|break;
case|case
name|VDEV_AUX_EXTERNAL
case|:
name|aux
operator|=
literal|"external"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|aux
operator|!=
name|NULL
condition|)
name|fnvlist_add_string
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_AUX_STATE
argument_list|,
name|aux
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_splitting
operator|&&
name|vd
operator|->
name|vdev_orig_guid
operator|!=
literal|0LL
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_ORIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_orig_guid
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|nv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a view of the top-level vdevs.  If we currently have holes  * in the namespace, then generate an array which contains a list of holey  * vdevs.  Additionally, add the number of top-level children that currently  * exist.  */
end_comment

begin_function
name|void
name|vdev_top_config_generate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|uint64_t
modifier|*
name|array
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|idx
decl_stmt|;
name|array
operator|=
name|kmem_alloc
argument_list|(
name|rvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|idx
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_ishole
condition|)
name|array
index|[
name|idx
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|idx
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOLE_ARRAY
argument_list|,
name|array
argument_list|,
name|idx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_CHILDREN
argument_list|,
name|rvd
operator|->
name|vdev_children
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|array
argument_list|,
name|rvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns the configuration from the label of the given vdev. For vdevs  * which don't have a txg value stored on their label (i.e. spares/cache)  * or have not been completely initialized (txg = 0) just return  * the configuration from the first valid label we find. Otherwise,  * find the most up-to-date label that does not exceed the specified  * 'txg' value.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|vdev_label_read_config
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|nvlist_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|vdev_phys_t
modifier|*
name|vp
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|uint64_t
name|best_txg
init|=
literal|0
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
name|ZIO_FLAG_CONFIG_WRITER
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_STATE_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|vp
operator|=
name|zio_buf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|retry
label|:
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
name|nvlist_t
modifier|*
name|label
init|=
name|NULL
decl_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|vdev_label_read
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|vp
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_vdev_phys
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
operator|&&
name|nvlist_unpack
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|,
sizeof|sizeof
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|)
argument_list|,
operator|&
name|label
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|label_txg
init|=
literal|0
decl_stmt|;
comment|/* 			 * Auxiliary vdevs won't have txg values in their 			 * labels and newly added vdevs may not have been 			 * completely initialized so just return the 			 * configuration from the first valid label we 			 * encounter. 			 */
name|error
operator|=
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|label_txg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|||
name|label_txg
operator|==
literal|0
operator|)
operator|&&
operator|!
name|config
condition|)
block|{
name|config
operator|=
name|label
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|label_txg
operator|<=
name|txg
operator|&&
name|label_txg
operator|>
name|best_txg
condition|)
block|{
name|best_txg
operator|=
name|label_txg
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|config
operator|=
name|fnvlist_dup
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|label
operator|!=
name|NULL
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|label
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|config
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_TRYHARD
operator|)
condition|)
block|{
name|flags
operator||=
name|ZIO_FLAG_TRYHARD
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine if a device is in use.  The 'spare_guid' parameter will be filled  * in with the device guid if this spare is active elsewhere on the system.  */
end_comment

begin_function
specifier|static
name|boolean_t
name|vdev_inuse
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|vdev_labeltype_t
name|reason
parameter_list|,
name|uint64_t
modifier|*
name|spare_guid
parameter_list|,
name|uint64_t
modifier|*
name|l2cache_guid
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|uint64_t
name|state
decl_stmt|,
name|pool_guid
decl_stmt|,
name|device_guid
decl_stmt|,
name|txg
decl_stmt|,
name|spare_pool
decl_stmt|;
name|uint64_t
name|vdtxg
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
if|if
condition|(
name|spare_guid
condition|)
operator|*
name|spare_guid
operator|=
literal|0ULL
expr_stmt|;
if|if
condition|(
name|l2cache_guid
condition|)
operator|*
name|l2cache_guid
operator|=
literal|0ULL
expr_stmt|;
comment|/* 	 * Read the label, if any, and perform some basic sanity checks. 	 */
if|if
condition|(
operator|(
name|label
operator|=
name|vdev_label_read_config
argument_list|(
name|vd
argument_list|,
operator|-
literal|1ULL
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_CREATE_TXG
argument_list|,
operator|&
name|vdtxg
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|device_guid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
name|state
operator|!=
name|POOL_STATE_L2CACHE
operator|&&
operator|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if this device indeed belongs to the pool it claims to 	 * be a part of.  The only way this is allowed is if the device is a hot 	 * spare (which we check for later on). 	 */
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
name|state
operator|!=
name|POOL_STATE_L2CACHE
operator|&&
operator|!
name|spa_guid_exists
argument_list|(
name|pool_guid
argument_list|,
name|device_guid
argument_list|)
operator|&&
operator|!
name|spa_spare_exists
argument_list|(
name|device_guid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|&&
operator|!
name|spa_l2cache_exists
argument_list|(
name|device_guid
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* 	 * If the transaction group is zero, then this an initialized (but 	 * unused) label.  This is only an error if the create transaction 	 * on-disk is the same as the one we're using now, in which case the 	 * user has attempted to add the same vdev multiple times in the same 	 * transaction. 	 */
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
name|state
operator|!=
name|POOL_STATE_L2CACHE
operator|&&
name|txg
operator|==
literal|0
operator|&&
name|vdtxg
operator|==
name|crtxg
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
comment|/* 	 * Check to see if this is a spare device.  We do an explicit check for 	 * spa_has_spare() here because it may be on our pending list of spares 	 * to add.  We also check if it is an l2cache device. 	 */
if|if
condition|(
name|spa_spare_exists
argument_list|(
name|device_guid
argument_list|,
operator|&
name|spare_pool
argument_list|,
name|NULL
argument_list|)
operator|||
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|device_guid
argument_list|)
condition|)
block|{
if|if
condition|(
name|spare_guid
condition|)
operator|*
name|spare_guid
operator|=
name|device_guid
expr_stmt|;
switch|switch
condition|(
name|reason
condition|)
block|{
case|case
name|VDEV_LABEL_CREATE
case|:
case|case
name|VDEV_LABEL_L2CACHE
case|:
return|return
operator|(
name|B_TRUE
operator|)
return|;
case|case
name|VDEV_LABEL_REPLACE
case|:
return|return
operator|(
operator|!
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|device_guid
argument_list|)
operator|||
name|spare_pool
operator|!=
literal|0ULL
operator|)
return|;
case|case
name|VDEV_LABEL_SPARE
case|:
return|return
operator|(
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|device_guid
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* 	 * Check to see if this is an l2cache device. 	 */
if|if
condition|(
name|spa_l2cache_exists
argument_list|(
name|device_guid
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
comment|/* 	 * We can't rely on a pool's state if it's been imported 	 * read-only.  Instead we look to see if the pools is marked 	 * read-only in the namespace and set the state to active. 	 */
if|if
condition|(
name|state
operator|!=
name|POOL_STATE_SPARE
operator|&&
name|state
operator|!=
name|POOL_STATE_L2CACHE
operator|&&
operator|(
name|spa
operator|=
name|spa_by_guid
argument_list|(
name|pool_guid
argument_list|,
name|device_guid
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|spa_mode
argument_list|(
name|spa
argument_list|)
operator|==
name|FREAD
condition|)
name|state
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
comment|/* 	 * If the device is marked ACTIVE, then this device is in use by another 	 * pool on the system. 	 */
return|return
operator|(
name|state
operator|==
name|POOL_STATE_ACTIVE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Initialize a vdev label.  We check to make sure each leaf device is not in  * use, and writable.  We put down an initial label which we will later  * overwrite with a complete label.  Note that it's important to do this  * sequentially, not in parallel, so that we catch cases of multiple use of the  * same leaf vdev in the vdev we're creating -- e.g. mirroring a disk with  * itself.  */
end_comment

begin_function
name|int
name|vdev_label_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|vdev_labeltype_t
name|reason
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|vdev_phys_t
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|pad2
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|spare_guid
decl_stmt|,
name|l2cache_guid
decl_stmt|;
name|int
name|flags
init|=
name|ZIO_FLAG_CONFIG_WRITER
operator||
name|ZIO_FLAG_CANFAIL
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|crtxg
argument_list|,
name|reason
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* Track the creation time for this vdev */
name|vd
operator|->
name|vdev_crtxg
operator|=
name|crtxg
expr_stmt|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|||
operator|!
name|spa_writeable
argument_list|(
name|spa
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Dead vdevs cannot be initialized. 	 */
if|if
condition|(
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
comment|/* 	 * Determine if the vdev is in use. 	 */
if|if
condition|(
name|reason
operator|!=
name|VDEV_LABEL_REMOVE
operator|&&
name|reason
operator|!=
name|VDEV_LABEL_SPLIT
operator|&&
name|vdev_inuse
argument_list|(
name|vd
argument_list|,
name|crtxg
argument_list|,
name|reason
argument_list|,
operator|&
name|spare_guid
argument_list|,
operator|&
name|l2cache_guid
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * If this is a request to add or replace a spare or l2cache device 	 * that is in use elsewhere on the system, then we must update the 	 * guid (which was initialized to a random value) to reflect the 	 * actual GUID (which is shared between multiple pools). 	 */
if|if
condition|(
name|reason
operator|!=
name|VDEV_LABEL_REMOVE
operator|&&
name|reason
operator|!=
name|VDEV_LABEL_L2CACHE
operator|&&
name|spare_guid
operator|!=
literal|0ULL
condition|)
block|{
name|uint64_t
name|guid_delta
init|=
name|spare_guid
operator|-
name|vd
operator|->
name|vdev_guid
decl_stmt|;
name|vd
operator|->
name|vdev_guid
operator|+=
name|guid_delta
expr_stmt|;
for|for
control|(
name|vdev_t
modifier|*
name|pvd
init|=
name|vd
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_guid_sum
operator|+=
name|guid_delta
expr_stmt|;
comment|/* 		 * If this is a replacement, then we want to fallthrough to the 		 * rest of the code.  If we're adding a spare, then it's already 		 * labeled appropriately and we can just return. 		 */
if|if
condition|(
name|reason
operator|==
name|VDEV_LABEL_SPARE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|reason
operator|==
name|VDEV_LABEL_REPLACE
operator|||
name|reason
operator|==
name|VDEV_LABEL_SPLIT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reason
operator|!=
name|VDEV_LABEL_REMOVE
operator|&&
name|reason
operator|!=
name|VDEV_LABEL_SPARE
operator|&&
name|l2cache_guid
operator|!=
literal|0ULL
condition|)
block|{
name|uint64_t
name|guid_delta
init|=
name|l2cache_guid
operator|-
name|vd
operator|->
name|vdev_guid
decl_stmt|;
name|vd
operator|->
name|vdev_guid
operator|+=
name|guid_delta
expr_stmt|;
for|for
control|(
name|vdev_t
modifier|*
name|pvd
init|=
name|vd
init|;
name|pvd
operator|!=
name|NULL
condition|;
name|pvd
operator|=
name|pvd
operator|->
name|vdev_parent
control|)
name|pvd
operator|->
name|vdev_guid_sum
operator|+=
name|guid_delta
expr_stmt|;
comment|/* 		 * If this is a replacement, then we want to fallthrough to the 		 * rest of the code.  If we're adding an l2cache, then it's 		 * already labeled appropriately and we can just return. 		 */
if|if
condition|(
name|reason
operator|==
name|VDEV_LABEL_L2CACHE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|reason
operator|==
name|VDEV_LABEL_REPLACE
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Initialize its label. 	 */
name|vp
operator|=
name|zio_buf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Generate a label describing the pool and our top-level vdev. 	 * We mark it as being from txg 0 to indicate that it's not 	 * really part of an active pool just yet.  The labels will 	 * be written again with a meaningful txg by spa_sync(). 	 */
if|if
condition|(
name|reason
operator|==
name|VDEV_LABEL_SPARE
operator|||
operator|(
name|reason
operator|==
name|VDEV_LABEL_REMOVE
operator|&&
name|vd
operator|->
name|vdev_isspare
operator|)
condition|)
block|{
comment|/* 		 * For inactive hot spares, we generate a special label that 		 * identifies as a mutually shared hot spare.  We write the 		 * label if we are adding a hot spare, or if we are removing an 		 * active hot spare (in which case we want to revert the 		 * labels). 		 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|label
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|POOL_STATE_SPARE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reason
operator|==
name|VDEV_LABEL_L2CACHE
operator|||
operator|(
name|reason
operator|==
name|VDEV_LABEL_REMOVE
operator|&&
name|vd
operator|->
name|vdev_isl2cache
operator|)
condition|)
block|{
comment|/* 		 * For level 2 ARC devices, add a special label. 		 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|label
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|POOL_STATE_L2CACHE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|txg
init|=
literal|0ULL
decl_stmt|;
if|if
condition|(
name|reason
operator|==
name|VDEV_LABEL_SPLIT
condition|)
name|txg
operator|=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
expr_stmt|;
name|label
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 		 * Add our creation time.  This allows us to detect multiple 		 * vdev uses as described above, and automatically expires if we 		 * fail. 		 */
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_CREATE_TXG
argument_list|,
name|crtxg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
name|vp
operator|->
name|vp_nvlist
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|)
expr_stmt|;
name|error
operator|=
name|nvlist_pack
argument_list|(
name|label
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* EFAULT means nvlist_pack ran out of room */
return|return
operator|(
name|error
operator|==
name|EFAULT
condition|?
name|ENAMETOOLONG
else|:
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * Initialize uberblock template. 	 */
name|ub
operator|=
name|zio_buf_alloc
argument_list|(
name|VDEV_UBERBLOCK_RING
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ub
argument_list|,
name|VDEV_UBERBLOCK_RING
argument_list|)
expr_stmt|;
operator|*
name|ub
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|ub
operator|->
name|ub_txg
operator|=
literal|0
expr_stmt|;
comment|/* Initialize the 2nd padding area. */
name|pad2
operator|=
name|zio_buf_alloc
argument_list|(
name|VDEV_PAD_SIZE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pad2
argument_list|,
name|VDEV_PAD_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Write everything in parallel. 	 */
name|retry
label|:
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|vp
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_vdev_phys
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 		 * Skip the 1st padding area. 		 * Zero out the 2nd padding area where it might have 		 * left over data from previous filesystem format. 		 */
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|pad2
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_pad2
argument_list|)
argument_list|,
name|VDEV_PAD_SIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|ub
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_uberblock
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_RING
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_TRYHARD
operator|)
condition|)
block|{
name|flags
operator||=
name|ZIO_FLAG_TRYHARD
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|pad2
argument_list|,
name|VDEV_PAD_SIZE
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|ub
argument_list|,
name|VDEV_UBERBLOCK_RING
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this vdev hasn't been previously identified as a spare, then we 	 * mark it as such only if a) we are labeling it as a spare, or b) it 	 * exists as a spare elsewhere in the system.  Do the same for 	 * level 2 ARC devices. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|vd
operator|->
name|vdev_isspare
operator|&&
operator|(
name|reason
operator|==
name|VDEV_LABEL_SPARE
operator|||
name|spa_spare_exists
argument_list|(
name|vd
operator|->
name|vdev_guid
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|spa_spare_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|vd
operator|->
name|vdev_isl2cache
operator|&&
operator|(
name|reason
operator|==
name|VDEV_LABEL_L2CACHE
operator|||
name|spa_l2cache_exists
argument_list|(
name|vd
operator|->
name|vdev_guid
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
name|spa_l2cache_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * uberblock load/sync  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Consider the following situation: txg is safely synced to disk.  We've  * written the first uberblock for txg + 1, and then we lose power.  When we  * come back up, we fail to see the uberblock for txg + 1 because, say,  * it was on a mirrored device and the replica to which we wrote txg + 1  * is now offline.  If we then make some changes and sync txg + 1, and then  * the missing replica comes back, then for a few seconds we'll have two  * conflicting uberblocks on disk with the same txg.  The solution is simple:  * among uberblocks with equal txg, choose the one with the latest timestamp.  */
end_comment

begin_function
specifier|static
name|int
name|vdev_uberblock_compare
parameter_list|(
name|uberblock_t
modifier|*
name|ub1
parameter_list|,
name|uberblock_t
modifier|*
name|ub2
parameter_list|)
block|{
if|if
condition|(
name|ub1
operator|->
name|ub_txg
operator|<
name|ub2
operator|->
name|ub_txg
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ub1
operator|->
name|ub_txg
operator|>
name|ub2
operator|->
name|ub_txg
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|ub1
operator|->
name|ub_timestamp
operator|<
name|ub2
operator|->
name|ub_timestamp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ub1
operator|->
name|ub_timestamp
operator|>
name|ub2
operator|->
name|ub_timestamp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|ubl_cbdata
block|{
name|uberblock_t
modifier|*
name|ubl_ubbest
decl_stmt|;
comment|/* Best uberblock */
name|vdev_t
modifier|*
name|ubl_vd
decl_stmt|;
comment|/* vdev associated with the above */
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|vdev_uberblock_load_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_t
modifier|*
name|rio
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
init|=
name|zio
operator|->
name|io_data
decl_stmt|;
name|struct
name|ubl_cbdata
modifier|*
name|cbp
init|=
name|rio
operator|->
name|io_private
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
operator|==
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|uberblock_verify
argument_list|(
name|ub
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|rio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ub
operator|->
name|ub_txg
operator|<=
name|spa
operator|->
name|spa_load_max_txg
operator|&&
name|vdev_uberblock_compare
argument_list|(
name|ub
argument_list|,
name|cbp
operator|->
name|ubl_ubbest
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Keep track of the vdev in which this uberblock 			 * was found. We will use this information later 			 * to obtain the config nvlist associated with 			 * this uberblock. 			 */
operator|*
name|cbp
operator|->
name|ubl_ubbest
operator|=
operator|*
name|ub
expr_stmt|;
name|cbp
operator|->
name|ubl_vd
operator|=
name|vd
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|rio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
name|zio_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_uberblock_load_impl
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|flags
parameter_list|,
name|struct
name|ubl_cbdata
modifier|*
name|cbp
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_uberblock_load_impl
argument_list|(
name|zio
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|flags
argument_list|,
name|cbp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
block|{
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
block|{
for|for
control|(
name|int
name|n
init|=
literal|0
init|;
name|n
operator|<
name|VDEV_UBERBLOCK_COUNT
argument_list|(
name|vd
argument_list|)
condition|;
name|n
operator|++
control|)
block|{
name|vdev_label_read
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|zio_buf_alloc
argument_list|(
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_OFFSET
argument_list|(
name|vd
argument_list|,
name|n
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|,
name|vdev_uberblock_load_done
argument_list|,
name|zio
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Reads the 'best' uberblock from disk along with its associated  * configuration. First, we read the uberblock array of each label of each  * vdev, keeping track of the uberblock with the highest txg in each array.  * Then, we read the configuration from the same vdev as the best uberblock.  */
end_comment

begin_function
name|void
name|vdev_uberblock_load
parameter_list|(
name|vdev_t
modifier|*
name|rvd
parameter_list|,
name|uberblock_t
modifier|*
name|ub
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|rvd
operator|->
name|vdev_spa
decl_stmt|;
name|struct
name|ubl_cbdata
name|cb
decl_stmt|;
name|int
name|flags
init|=
name|ZIO_FLAG_CONFIG_WRITER
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_TRYHARD
decl_stmt|;
name|ASSERT
argument_list|(
name|ub
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ub
argument_list|,
sizeof|sizeof
argument_list|(
name|uberblock_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
name|cb
operator|.
name|ubl_ubbest
operator|=
name|ub
expr_stmt|;
name|cb
operator|.
name|ubl_vd
operator|=
name|NULL
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|cb
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|vdev_uberblock_load_impl
argument_list|(
name|zio
argument_list|,
name|rvd
argument_list|,
name|flags
argument_list|,
operator|&
name|cb
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * It's possible that the best uberblock was discovered on a label 	 * that has a configuration which was written in a future txg. 	 * Search all labels on this vdev to find the configuration that 	 * matches the txg for our uberblock. 	 */
if|if
condition|(
name|cb
operator|.
name|ubl_vd
operator|!=
name|NULL
condition|)
operator|*
name|config
operator|=
name|vdev_label_read_config
argument_list|(
name|cb
operator|.
name|ubl_vd
argument_list|,
name|ub
operator|->
name|ub_txg
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * On success, increment root zio's count of good writes.  * We only get credit for writes to known-visible vdevs; see spa_vdev_add().  */
end_comment

begin_function
specifier|static
name|void
name|vdev_uberblock_sync_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|uint64_t
modifier|*
name|good_writes
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_top
operator|->
name|vdev_ms_array
operator|!=
literal|0
condition|)
name|atomic_inc_64
argument_list|(
name|good_writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write the uberblock to all labels of all leaves of the specified vdev.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_uberblock_sync
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uberblock_t
modifier|*
name|ub
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|uberblock_t
modifier|*
name|ubbuf
decl_stmt|;
name|int
name|n
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_uberblock_sync
argument_list|(
name|zio
argument_list|,
name|ub
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return;
if|if
condition|(
operator|!
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
condition|)
return|return;
name|n
operator|=
name|ub
operator|->
name|ub_txg
operator|&
operator|(
name|VDEV_UBERBLOCK_COUNT
argument_list|(
name|vd
argument_list|)
operator|-
literal|1
operator|)
expr_stmt|;
name|ubbuf
operator|=
name|zio_buf_alloc
argument_list|(
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|ubbuf
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ubbuf
operator|=
operator|*
name|ub
expr_stmt|;
for|for
control|(
name|int
name|l
init|=
literal|0
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|++
control|)
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|ubbuf
argument_list|,
name|VDEV_UBERBLOCK_OFFSET
argument_list|(
name|vd
argument_list|,
name|n
argument_list|)
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|,
name|vdev_uberblock_sync_done
argument_list|,
name|zio
operator|->
name|io_private
argument_list|,
name|flags
operator||
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|ubbuf
argument_list|,
name|VDEV_UBERBLOCK_SIZE
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Sync the uberblocks to all vdevs in svd[] */
end_comment

begin_function
name|int
name|vdev_uberblock_sync_list
parameter_list|(
name|vdev_t
modifier|*
modifier|*
name|svd
parameter_list|,
name|int
name|svdcount
parameter_list|,
name|uberblock_t
modifier|*
name|ub
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|svd
index|[
literal|0
index|]
operator|->
name|vdev_spa
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|uint64_t
name|good_writes
init|=
literal|0
decl_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|good_writes
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|svdcount
condition|;
name|v
operator|++
control|)
name|vdev_uberblock_sync
argument_list|(
name|zio
argument_list|,
name|ub
argument_list|,
name|svd
index|[
name|v
index|]
argument_list|,
name|flags
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the uberblocks to disk.  This ensures that the odd labels 	 * are no longer needed (because the new uberblocks and the even 	 * labels are safely on disk), so it is safe to overwrite them. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|v
init|=
literal|0
init|;
name|v
operator|<
name|svdcount
condition|;
name|v
operator|++
control|)
name|zio_flush
argument_list|(
name|zio
argument_list|,
name|svd
index|[
name|v
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|good_writes
operator|>=
literal|1
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * On success, increment the count of good writes for our top-level vdev.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_label_sync_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|uint64_t
modifier|*
name|good_writes
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|atomic_inc_64
argument_list|(
name|good_writes
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there weren't enough good writes, indicate failure to the parent.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_label_sync_top_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|uint64_t
modifier|*
name|good_writes
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
if|if
condition|(
operator|*
name|good_writes
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|good_writes
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We ignore errors for log and cache devices, simply free the private data.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_label_sync_ignore_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|zio
operator|->
name|io_private
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write all even or odd labels to all leaves of the specified vdev.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_label_sync
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|l
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|vdev_phys_t
modifier|*
name|vp
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|buflen
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_label_sync
argument_list|(
name|zio
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|l
argument_list|,
name|txg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return;
if|if
condition|(
operator|!
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
condition|)
return|return;
comment|/* 	 * Generate a label describing the top-level config to which we belong. 	 */
name|label
operator|=
name|spa_config_generate
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|vp
operator|=
name|zio_buf_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|buf
operator|=
name|vp
operator|->
name|vp_nvlist
expr_stmt|;
name|buflen
operator|=
sizeof|sizeof
argument_list|(
name|vp
operator|->
name|vp_nvlist
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_pack
argument_list|(
name|label
argument_list|,
operator|&
name|buf
argument_list|,
operator|&
name|buflen
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
name|l
operator|<
name|VDEV_LABELS
condition|;
name|l
operator|+=
literal|2
control|)
block|{
name|vdev_label_write
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|vp
argument_list|,
name|offsetof
argument_list|(
name|vdev_label_t
argument_list|,
name|vl_vdev_phys
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|,
name|vdev_label_sync_done
argument_list|,
name|zio
operator|->
name|io_private
argument_list|,
name|flags
operator||
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|)
expr_stmt|;
block|}
block|}
name|zio_buf_free
argument_list|(
name|vp
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_phys_t
argument_list|)
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vdev_label_sync_list
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|l
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|list_t
modifier|*
name|dl
init|=
operator|&
name|spa
operator|->
name|spa_config_dirty_list
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Write the new labels to disk. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|vd
operator|=
name|list_head
argument_list|(
name|dl
argument_list|)
init|;
name|vd
operator|!=
name|NULL
condition|;
name|vd
operator|=
name|list_next
argument_list|(
name|dl
argument_list|,
name|vd
argument_list|)
control|)
block|{
name|uint64_t
modifier|*
name|good_writes
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
name|zio_t
modifier|*
name|vio
init|=
name|zio_null
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
operator|(
name|vd
operator|->
name|vdev_islog
operator|||
name|vd
operator|->
name|vdev_aux
operator|!=
name|NULL
operator|)
condition|?
name|vdev_label_sync_ignore_done
else|:
name|vdev_label_sync_top_done
argument_list|,
name|good_writes
argument_list|,
name|flags
argument_list|)
decl_stmt|;
name|vdev_label_sync
argument_list|(
name|vio
argument_list|,
name|vd
argument_list|,
name|l
argument_list|,
name|txg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|vio
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the new labels to disk. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|vd
operator|=
name|list_head
argument_list|(
name|dl
argument_list|)
init|;
name|vd
operator|!=
name|NULL
condition|;
name|vd
operator|=
name|list_next
argument_list|(
name|dl
argument_list|,
name|vd
argument_list|)
control|)
name|zio_flush
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Sync the uberblock and any changes to the vdev configuration.  *  * The order of operations is carefully crafted to ensure that  * if the system panics or loses power at any time, the state on disk  * is still transactionally consistent.  The in-line comments below  * describe the failure semantics at each stage.  *  * Moreover, vdev_config_sync() is designed to be idempotent: if it fails  * at any time, you can just call it again, and it will resume its work.  */
end_comment

begin_function
name|int
name|vdev_config_sync
parameter_list|(
name|vdev_t
modifier|*
modifier|*
name|svd
parameter_list|,
name|int
name|svdcount
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|svd
index|[
literal|0
index|]
operator|->
name|vdev_spa
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
init|=
operator|&
name|spa
operator|->
name|spa_uberblock
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|int
name|flags
init|=
name|ZIO_FLAG_CONFIG_WRITER
operator||
name|ZIO_FLAG_CANFAIL
decl_stmt|;
name|retry
label|:
comment|/* 	 * Normally, we don't want to try too hard to write every label and 	 * uberblock.  If there is a flaky disk, we don't want the rest of the 	 * sync process to block while we retry.  But if we can't write a 	 * single label out, we should retry with ZIO_FLAG_TRYHARD before 	 * bailing out and declaring the pool faulted. 	 */
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|ZIO_FLAG_TRYHARD
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|flags
operator||=
name|ZIO_FLAG_TRYHARD
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|ub
operator|->
name|ub_txg
operator|<=
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * If this isn't a resync due to I/O errors, 	 * and nothing changed in this transaction group, 	 * and the vdev configuration hasn't changed, 	 * then there's nothing to do. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_txg
operator|<
name|txg
operator|&&
name|uberblock_update
argument_list|(
name|ub
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|txg
argument_list|)
operator|==
name|B_FALSE
operator|&&
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|txg
operator|<=
name|spa
operator|->
name|spa_final_txg
argument_list|)
expr_stmt|;
comment|/* 	 * Flush the write cache of every disk that's been written to 	 * in this transaction group.  This ensures that all blocks 	 * written in this txg will be committed to stable storage 	 * before any uberblock that references them. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|vd
operator|=
name|txg_list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
init|;
name|vd
condition|;
name|vd
operator|=
name|txg_list_next
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|vd
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
control|)
name|zio_flush
argument_list|(
name|zio
argument_list|,
name|vd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * Sync out the even labels (L0, L2) for every dirty vdev.  If the 	 * system dies in the middle of this process, that's OK: all of the 	 * even labels that made it to disk will be newer than any uberblock, 	 * and will therefore be considered invalid.  The odd labels (L1, L3), 	 * which have not yet been touched, will still be valid.  We flush 	 * the new labels to disk to ensure that all even-label updates 	 * are committed to stable storage before the uberblock update. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_label_sync_list
argument_list|(
name|spa
argument_list|,
literal|0
argument_list|,
name|txg
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
comment|/* 	 * Sync the uberblocks to all vdevs in svd[]. 	 * If the system dies in the middle of this step, there are two cases 	 * to consider, and the on-disk state is consistent either way: 	 * 	 * (1)	If none of the new uberblocks made it to disk, then the 	 *	previous uberblock will be the newest, and the odd labels 	 *	(which had not yet been touched) will be valid with respect 	 *	to that uberblock. 	 * 	 * (2)	If one or more new uberblocks made it to disk, then they 	 *	will be the newest, and the even labels (which had all 	 *	been successfully committed) will be valid with respect 	 *	to the new uberblocks. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_uberblock_sync_list
argument_list|(
name|svd
argument_list|,
name|svdcount
argument_list|,
name|ub
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
comment|/* 	 * Sync out odd labels for every dirty vdev.  If the system dies 	 * in the middle of this process, the even labels and the new 	 * uberblocks will suffice to open the pool.  The next time 	 * the pool is opened, the first thing we'll do -- before any 	 * user data is modified -- is mark every vdev dirty so that 	 * all labels will be brought up to date.  We flush the new labels 	 * to disk to ensure that all odd-label updates are committed to 	 * stable storage before the next transaction group begins. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_label_sync_list
argument_list|(
name|spa
argument_list|,
literal|1
argument_list|,
name|txg
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|retry
goto|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

