begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright (c) 2011 Nexenta Systems, Inc. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddt.h>
end_include

begin_include
include|#
directive|include
file|<sys/blkptr.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_comment
comment|/*  * ==========================================================================  * I/O type descriptions  * ==========================================================================  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|zio_type_name
index|[
name|ZIO_TYPES
index|]
init|=
block|{
literal|"zio_null"
block|,
literal|"zio_read"
block|,
literal|"zio_write"
block|,
literal|"zio_free"
block|,
literal|"zio_claim"
block|,
literal|"zio_ioctl"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * I/O kmem caches  * ==========================================================================  */
end_comment

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|zio_cache
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|zio_link_cache
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|kmem_cache_t
operator|*
name|zio_buf_cache
index|[
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
index|]
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|kmem_cache_t
operator|*
name|zio_data_buf_cache
index|[
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
index|]
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
specifier|extern
name|vmem_t
modifier|*
name|zio_alloc_arena
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|ZIO_PIPELINE_CONTINUE
value|0x100
end_define

begin_define
define|#
directive|define
name|ZIO_PIPELINE_STOP
value|0x101
end_define

begin_define
define|#
directive|define
name|BP_SPANB
parameter_list|(
name|indblkshift
parameter_list|,
name|level
parameter_list|)
define|\
value|(((uint64_t)1)<< ((level) * ((indblkshift) - SPA_BLKPTRSHIFT)))
end_define

begin_define
define|#
directive|define
name|COMPARE_META_LEVEL
value|0x80000000ul
end_define

begin_comment
comment|/*  * The following actions directly effect the spa's sync-to-convergence logic.  * The values below define the sync pass when we start performing the action.  * Care should be taken when changing these values as they directly impact  * spa_sync() performance. Tuning these values may introduce subtle performance  * pathologies and should only be done in the context of performance analysis.  * These tunables will eventually be removed and replaced with #defines once  * enough analysis has been done to determine optimal values.  *  * The 'zfs_sync_pass_deferred_free' pass must be greater than 1 to ensure that  * regular blocks are not deferred.  */
end_comment

begin_decl_stmt
name|int
name|zfs_sync_pass_deferred_free
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* defer frees starting in this pass */
end_comment

begin_decl_stmt
name|int
name|zfs_sync_pass_dont_compress
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't compress starting in this pass */
end_comment

begin_decl_stmt
name|int
name|zfs_sync_pass_rewrite
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* rewrite new bps starting in this pass */
end_comment

begin_comment
comment|/*  * An allocating zio is one that either currently has the DVA allocate  * stage set or will have it later in its lifetime.  */
end_comment

begin_define
define|#
directive|define
name|IO_IS_ALLOCATING
parameter_list|(
name|zio
parameter_list|)
value|((zio)->io_orig_pipeline& ZIO_STAGE_DVA_ALLOCATE)
end_define

begin_decl_stmt
name|boolean_t
name|zio_requeue_io_start_cut_in_line
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|ZFS_DEBUG
end_ifdef

begin_decl_stmt
name|int
name|zio_buf_debug_limit
init|=
literal|16384
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|zio_buf_debug_limit
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|zio_init
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|c
decl_stmt|;
name|vmem_t
modifier|*
name|data_alloc_arena
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|data_alloc_arena
operator|=
name|zio_alloc_arena
expr_stmt|;
endif|#
directive|endif
name|zio_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"zio_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|zio_link_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"zio_link_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_link_t
argument_list|)
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * For small buffers, we want a cache for each multiple of 	 * SPA_MINBLOCKSIZE.  For larger buffers, we want a cache 	 * for each quarter-power of 2. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
condition|;
name|c
operator|++
control|)
block|{
name|size_t
name|size
init|=
operator|(
name|c
operator|+
literal|1
operator|)
operator|<<
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|size_t
name|p2
init|=
name|size
decl_stmt|;
name|size_t
name|align
init|=
literal|0
decl_stmt|;
name|size_t
name|cflags
init|=
operator|(
name|size
operator|>
name|zio_buf_debug_limit
operator|)
condition|?
name|KMC_NODEBUG
else|:
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|ISP2
argument_list|(
name|p2
argument_list|)
condition|)
name|p2
operator|&=
name|p2
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|_KERNEL
comment|/* 		 * If we are using watchpoints, put each buffer on its own page, 		 * to eliminate the performance overhead of trapping to the 		 * kernel when modifying a non-watched buffer that shares the 		 * page with a watched buffer. 		 */
if|if
condition|(
name|arc_watch
operator|&&
operator|!
name|IS_P2ALIGNED
argument_list|(
name|size
argument_list|,
name|PAGESIZE
argument_list|)
condition|)
continue|continue;
endif|#
directive|endif
if|if
condition|(
name|size
operator|<=
literal|4
operator|*
name|SPA_MINBLOCKSIZE
condition|)
block|{
name|align
operator|=
name|SPA_MINBLOCKSIZE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|IS_P2ALIGNED
argument_list|(
name|size
argument_list|,
name|p2
operator|>>
literal|2
argument_list|)
condition|)
block|{
name|align
operator|=
name|MIN
argument_list|(
name|p2
operator|>>
literal|2
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|align
operator|!=
literal|0
condition|)
block|{
name|char
name|name
index|[
literal|36
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"zio_buf_%lu"
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|zio_buf_cache
index|[
name|c
index|]
operator|=
name|kmem_cache_create
argument_list|(
name|name
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|cflags
argument_list|)
expr_stmt|;
comment|/* 			 * Since zio_data bufs do not appear in crash dumps, we 			 * pass KMC_NOTOUCH so that no allocator metadata is 			 * stored with the buffers. 			 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"zio_data_buf_%lu"
argument_list|,
operator|(
name|ulong_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|zio_data_buf_cache
index|[
name|c
index|]
operator|=
name|kmem_cache_create
argument_list|(
name|name
argument_list|,
name|size
argument_list|,
name|align
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|data_alloc_arena
argument_list|,
name|cflags
operator||
name|KMC_NOTOUCH
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|--
name|c
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
name|zio_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|=
name|zio_buf_cache
index|[
name|c
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_data_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|==
name|NULL
condition|)
name|zio_data_buf_cache
index|[
name|c
operator|-
literal|1
index|]
operator|=
name|zio_data_buf_cache
index|[
name|c
index|]
expr_stmt|;
block|}
name|zio_inject_init
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|size_t
name|c
decl_stmt|;
name|kmem_cache_t
modifier|*
name|last_cache
init|=
name|NULL
decl_stmt|;
name|kmem_cache_t
modifier|*
name|last_data_cache
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|zio_buf_cache
index|[
name|c
index|]
operator|!=
name|last_cache
condition|)
block|{
name|last_cache
operator|=
name|zio_buf_cache
index|[
name|c
index|]
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|zio_buf_cache
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zio_data_buf_cache
index|[
name|c
index|]
operator|!=
name|last_data_cache
condition|)
block|{
name|last_data_cache
operator|=
name|zio_data_buf_cache
index|[
name|c
index|]
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
name|zio_data_buf_cache
index|[
name|c
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|kmem_cache_destroy
argument_list|(
name|zio_link_cache
argument_list|)
expr_stmt|;
name|kmem_cache_destroy
argument_list|(
name|zio_cache
argument_list|)
expr_stmt|;
name|zio_inject_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Allocate and free I/O buffers  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Use zio_buf_alloc to allocate ZFS metadata.  This data will appear in a  * crashdump if the kernel panics, so use it judiciously.  Obviously, it's  * useful to inspect ZFS metadata, but if possible, we should avoid keeping  * excess / transient data in-core during a crashdump.  */
end_comment

begin_function
name|void
modifier|*
name|zio_buf_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|VERIFY3U
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
name|kmem_cache_alloc
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
argument_list|,
name|KM_PUSHPAGE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Use zio_data_buf_alloc to allocate data.  The data will not appear in a  * crashdump if the kernel panics.  This exists so that we will limit the amount  * of ZFS data that shows up in a kernel crashdump.  (Thus reducing the amount  * of kernel heap dumped to disk when the kernel panics)  */
end_comment

begin_function
name|void
modifier|*
name|zio_data_buf_alloc
parameter_list|(
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|VERIFY3U
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
return|return
operator|(
name|kmem_cache_alloc
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
argument_list|,
name|KM_PUSHPAGE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_buf_free
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|VERIFY3U
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zio_buf_cache
index|[
name|c
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_data_buf_free
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|size_t
name|c
init|=
operator|(
name|size
operator|-
literal|1
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
decl_stmt|;
name|VERIFY3U
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|SPA_MAXBLOCKSIZE
operator|>>
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zio_data_buf_cache
index|[
name|c
index|]
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Push and pop I/O transform buffers  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_push_transform
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|bufsize
parameter_list|,
name|zio_transform_func_t
modifier|*
name|transform
parameter_list|)
block|{
name|zio_transform_t
modifier|*
name|zt
init|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zio_transform_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|zt
operator|->
name|zt_orig_data
operator|=
name|zio
operator|->
name|io_data
expr_stmt|;
name|zt
operator|->
name|zt_orig_size
operator|=
name|zio
operator|->
name|io_size
expr_stmt|;
name|zt
operator|->
name|zt_bufsize
operator|=
name|bufsize
expr_stmt|;
name|zt
operator|->
name|zt_transform
operator|=
name|transform
expr_stmt|;
name|zt
operator|->
name|zt_next
operator|=
name|zio
operator|->
name|io_transform_stack
expr_stmt|;
name|zio
operator|->
name|io_transform_stack
operator|=
name|zt
expr_stmt|;
name|zio
operator|->
name|io_data
operator|=
name|data
expr_stmt|;
name|zio
operator|->
name|io_size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_pop_transforms
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_transform_t
modifier|*
name|zt
decl_stmt|;
while|while
condition|(
operator|(
name|zt
operator|=
name|zio
operator|->
name|io_transform_stack
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zt
operator|->
name|zt_transform
operator|!=
name|NULL
condition|)
name|zt
operator|->
name|zt_transform
argument_list|(
name|zio
argument_list|,
name|zt
operator|->
name|zt_orig_data
argument_list|,
name|zt
operator|->
name|zt_orig_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zt
operator|->
name|zt_bufsize
operator|!=
literal|0
condition|)
name|zio_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zt
operator|->
name|zt_bufsize
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_data
operator|=
name|zt
operator|->
name|zt_orig_data
expr_stmt|;
name|zio
operator|->
name|io_size
operator|=
name|zt
operator|->
name|zt_orig_size
expr_stmt|;
name|zio
operator|->
name|io_transform_stack
operator|=
name|zt
operator|->
name|zt_next
expr_stmt|;
name|kmem_free
argument_list|(
name|zt
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_transform_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O transform callbacks for subblocks and decompression  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_subblock
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_size
operator|>
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|data
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_decompress
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|zio_decompress_data
argument_list|(
name|BP_GET_COMPRESS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O parent/child relationships and pipeline interlocks  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * NOTE - Callers to zio_walk_parents() and zio_walk_children must  *        continue calling these functions until they return NULL.  *        Otherwise, the next caller will pick up the list walk in  *        some indeterminate state.  (Otherwise every caller would  *        have to pass in a cookie to keep the state represented by  *        io_walk_link, which gets annoying.)  */
end_comment

begin_function
name|zio_t
modifier|*
name|zio_walk_parents
parameter_list|(
name|zio_t
modifier|*
name|cio
parameter_list|)
block|{
name|zio_link_t
modifier|*
name|zl
init|=
name|cio
operator|->
name|io_walk_link
decl_stmt|;
name|list_t
modifier|*
name|pl
init|=
operator|&
name|cio
operator|->
name|io_parent_list
decl_stmt|;
name|zl
operator|=
operator|(
name|zl
operator|==
name|NULL
operator|)
condition|?
name|list_head
argument_list|(
name|pl
argument_list|)
else|:
name|list_next
argument_list|(
name|pl
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|cio
operator|->
name|io_walk_link
operator|=
name|zl
expr_stmt|;
if|if
condition|(
name|zl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ASSERT
argument_list|(
name|zl
operator|->
name|zl_child
operator|==
name|cio
argument_list|)
expr_stmt|;
return|return
operator|(
name|zl
operator|->
name|zl_parent
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_walk_children
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|)
block|{
name|zio_link_t
modifier|*
name|zl
init|=
name|pio
operator|->
name|io_walk_link
decl_stmt|;
name|list_t
modifier|*
name|cl
init|=
operator|&
name|pio
operator|->
name|io_child_list
decl_stmt|;
name|zl
operator|=
operator|(
name|zl
operator|==
name|NULL
operator|)
condition|?
name|list_head
argument_list|(
name|cl
argument_list|)
else|:
name|list_next
argument_list|(
name|cl
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|pio
operator|->
name|io_walk_link
operator|=
name|zl
expr_stmt|;
if|if
condition|(
name|zl
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|ASSERT
argument_list|(
name|zl
operator|->
name|zl_parent
operator|==
name|pio
argument_list|)
expr_stmt|;
return|return
operator|(
name|zl
operator|->
name|zl_child
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_unique_parent
parameter_list|(
name|zio_t
modifier|*
name|cio
parameter_list|)
block|{
name|zio_t
modifier|*
name|pio
init|=
name|zio_walk_parents
argument_list|(
name|cio
argument_list|)
decl_stmt|;
name|VERIFY
argument_list|(
name|zio_walk_parents
argument_list|(
name|cio
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|pio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_add_child
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_t
modifier|*
name|cio
parameter_list|)
block|{
name|zio_link_t
modifier|*
name|zl
init|=
name|kmem_cache_alloc
argument_list|(
name|zio_link_cache
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
comment|/* 	 * Logical I/Os can have logical, gang, or vdev children. 	 * Gang I/Os can have gang or vdev children. 	 * Vdev I/Os can only have vdev children. 	 * The following ASSERT captures all of these constraints. 	 */
name|ASSERT
argument_list|(
name|cio
operator|->
name|io_child_type
operator|<=
name|pio
operator|->
name|io_child_type
argument_list|)
expr_stmt|;
name|zl
operator|->
name|zl_parent
operator|=
name|pio
expr_stmt|;
name|zl
operator|->
name|zl_child
operator|=
name|cio
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_state
index|[
name|ZIO_WAIT_DONE
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|ZIO_WAIT_TYPES
condition|;
name|w
operator|++
control|)
name|pio
operator|->
name|io_children
index|[
name|cio
operator|->
name|io_child_type
index|]
index|[
name|w
index|]
operator|+=
operator|!
name|cio
operator|->
name|io_state
index|[
name|w
index|]
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|pio
operator|->
name|io_child_list
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|cio
operator|->
name|io_parent_list
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|pio
operator|->
name|io_child_count
operator|++
expr_stmt|;
name|cio
operator|->
name|io_parent_count
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_remove_child
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_t
modifier|*
name|cio
parameter_list|,
name|zio_link_t
modifier|*
name|zl
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zl
operator|->
name|zl_parent
operator|==
name|pio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zl
operator|->
name|zl_child
operator|==
name|cio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|pio
operator|->
name|io_child_list
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|cio
operator|->
name|io_parent_list
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|pio
operator|->
name|io_child_count
operator|--
expr_stmt|;
name|cio
operator|->
name|io_parent_count
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zio_link_cache
argument_list|,
name|zl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zio_wait_for_children
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_child
name|child
parameter_list|,
name|enum
name|zio_wait_type
name|wait
parameter_list|)
block|{
name|uint64_t
modifier|*
name|countp
init|=
operator|&
name|zio
operator|->
name|io_children
index|[
name|child
index|]
index|[
name|wait
index|]
decl_stmt|;
name|boolean_t
name|waiting
init|=
name|B_FALSE
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stall
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|!=
literal|0
condition|)
block|{
name|zio
operator|->
name|io_stage
operator|>>=
literal|1
expr_stmt|;
name|zio
operator|->
name|io_stall
operator|=
name|countp
expr_stmt|;
name|waiting
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|waiting
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_notify_parent
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_wait_type
name|wait
parameter_list|)
block|{
name|uint64_t
modifier|*
name|countp
init|=
operator|&
name|pio
operator|->
name|io_children
index|[
name|zio
operator|->
name|io_child_type
index|]
index|[
name|wait
index|]
decl_stmt|;
name|int
modifier|*
name|errorp
init|=
operator|&
name|pio
operator|->
name|io_child_error
index|[
name|zio
operator|->
name|io_child_type
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_PROPAGATE
operator|)
condition|)
operator|*
name|errorp
operator|=
name|zio_worst_error
argument_list|(
operator|*
name|errorp
argument_list|,
name|zio
operator|->
name|io_error
argument_list|)
expr_stmt|;
name|pio
operator|->
name|io_reexecute
operator||=
name|zio
operator|->
name|io_reexecute
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|*
name|countp
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
operator|*
name|countp
operator|)
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|countp
operator|==
literal|0
operator|&&
name|pio
operator|->
name|io_stall
operator|==
name|countp
condition|)
block|{
name|pio
operator|->
name|io_stall
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|pio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zio_inherit_child_errors
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_child
name|c
parameter_list|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_child_error
index|[
name|c
index|]
operator|!=
literal|0
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio
operator|->
name|io_child_error
index|[
name|c
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Create the various types of I/O (read, write, free, etc)  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|zio_t
modifier|*
name|zio_create
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|zio_type_t
name|type
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|,
name|enum
name|zio_stage
name|stage
parameter_list|,
name|enum
name|zio_stage
name|pipeline
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|||
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_STATE_ALL
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|bp
operator|||
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|||
name|stage
operator|==
name|ZIO_STAGE_OPEN
argument_list|)
expr_stmt|;
name|zio
operator|=
name|kmem_cache_alloc
argument_list|(
name|zio_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zio
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zio
operator|->
name|io_parent_list
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_link_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zio_link_t
argument_list|,
name|zl_parent_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zio
operator|->
name|io_child_list
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_link_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zio_link_t
argument_list|,
name|zl_child_node
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
name|zio
operator|->
name|io_child_type
operator|=
name|ZIO_CHILD_VDEV
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_GANG_CHILD
condition|)
name|zio
operator|->
name|io_child_type
operator|=
name|ZIO_CHILD_GANG
expr_stmt|;
elseif|else
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_DDT_CHILD
condition|)
name|zio
operator|->
name|io_child_type
operator|=
name|ZIO_CHILD_DDT
expr_stmt|;
else|else
name|zio
operator|->
name|io_child_type
operator|=
name|ZIO_CHILD_LOGICAL
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|->
name|io_bp
operator|=
operator|(
name|blkptr_t
operator|*
operator|)
name|bp
expr_stmt|;
name|zio
operator|->
name|io_bp_copy
operator|=
operator|*
name|bp
expr_stmt|;
name|zio
operator|->
name|io_bp_orig
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|ZIO_TYPE_WRITE
operator|||
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_DDT
condition|)
name|zio
operator|->
name|io_bp
operator|=
operator|&
name|zio
operator|->
name|io_bp_copy
expr_stmt|;
comment|/* so caller can free */
if|if
condition|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
condition|)
name|zio
operator|->
name|io_logical
operator|=
name|zio
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_type
operator|>
name|ZIO_CHILD_GANG
operator|&&
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|)
name|pipeline
operator||=
name|ZIO_GANG_STAGES
expr_stmt|;
block|}
name|zio
operator|->
name|io_spa
operator|=
name|spa
expr_stmt|;
name|zio
operator|->
name|io_txg
operator|=
name|txg
expr_stmt|;
name|zio
operator|->
name|io_done
operator|=
name|done
expr_stmt|;
name|zio
operator|->
name|io_private
operator|=
name|private
expr_stmt|;
name|zio
operator|->
name|io_type
operator|=
name|type
expr_stmt|;
name|zio
operator|->
name|io_priority
operator|=
name|priority
expr_stmt|;
name|zio
operator|->
name|io_vd
operator|=
name|vd
expr_stmt|;
name|zio
operator|->
name|io_offset
operator|=
name|offset
expr_stmt|;
name|zio
operator|->
name|io_orig_data
operator|=
name|zio
operator|->
name|io_data
operator|=
name|data
expr_stmt|;
name|zio
operator|->
name|io_orig_size
operator|=
name|zio
operator|->
name|io_size
operator|=
name|size
expr_stmt|;
name|zio
operator|->
name|io_orig_flags
operator|=
name|zio
operator|->
name|io_flags
operator|=
name|flags
expr_stmt|;
name|zio
operator|->
name|io_orig_stage
operator|=
name|zio
operator|->
name|io_stage
operator|=
name|stage
expr_stmt|;
name|zio
operator|->
name|io_orig_pipeline
operator|=
name|zio
operator|->
name|io_pipeline
operator|=
name|pipeline
expr_stmt|;
name|zio
operator|->
name|io_state
index|[
name|ZIO_WAIT_READY
index|]
operator|=
operator|(
name|stage
operator|>=
name|ZIO_STAGE_READY
operator|)
expr_stmt|;
name|zio
operator|->
name|io_state
index|[
name|ZIO_WAIT_DONE
index|]
operator|=
operator|(
name|stage
operator|>=
name|ZIO_STAGE_DONE
operator|)
expr_stmt|;
if|if
condition|(
name|zb
operator|!=
name|NULL
condition|)
name|zio
operator|->
name|io_bookmark
operator|=
operator|*
name|zb
expr_stmt|;
if|if
condition|(
name|pio
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_logical
operator|==
name|NULL
condition|)
name|zio
operator|->
name|io_logical
operator|=
name|pio
operator|->
name|io_logical
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_GANG
condition|)
name|zio
operator|->
name|io_gang_leader
operator|=
name|pio
operator|->
name|io_gang_leader
expr_stmt|;
name|zio_add_child
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_destroy
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|list_destroy
argument_list|(
operator|&
name|zio
operator|->
name|io_parent_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zio
operator|->
name|io_child_list
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|zio_cache
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_null
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_NULL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|flags
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_INTERLOCK_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_root
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|)
block|{
return|return
operator|(
name|zio_null
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_blkptr_verify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
operator|!
name|DMU_OT_IS_VALID
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p has invalid TYPE %llu"
argument_list|,
name|bp
argument_list|,
operator|(
name|longlong_t
operator|)
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|>=
name|ZIO_CHECKSUM_FUNCTIONS
operator|||
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|<=
name|ZIO_CHECKSUM_ON
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p has invalid CHECKSUM %llu"
argument_list|,
name|bp
argument_list|,
operator|(
name|longlong_t
operator|)
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
operator|>=
name|ZIO_COMPRESS_FUNCTIONS
operator|||
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
operator|<=
name|ZIO_COMPRESS_ON
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p has invalid COMPRESS %llu"
argument_list|,
name|bp
argument_list|,
operator|(
name|longlong_t
operator|)
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
operator|>
name|SPA_MAXBLOCKSIZE
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p has invalid LSIZE %llu"
argument_list|,
name|bp
argument_list|,
operator|(
name|longlong_t
operator|)
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|>
name|SPA_MAXBLOCKSIZE
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p has invalid PSIZE %llu"
argument_list|,
name|bp
argument_list|,
operator|(
name|longlong_t
operator|)
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
if|if
condition|(
name|BPE_GET_ETYPE
argument_list|(
name|bp
argument_list|)
operator|>
name|NUM_BP_EMBEDDED_TYPES
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p has invalid ETYPE %llu"
argument_list|,
name|bp
argument_list|,
operator|(
name|longlong_t
operator|)
name|BPE_GET_ETYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Pool-specific checks. 	 * 	 * Note: it would be nice to verify that the blk_birth and 	 * BP_PHYSICAL_BIRTH() are not too large.  However, spa_freeze() 	 * allows the birth time of log blocks (and dmu_sync()-ed blocks 	 * that are in the log) to be arbitrarily large. 	 */
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|vdevid
init|=
name|DVA_GET_VDEV
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|vdevid
operator|>=
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_children
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p DVA %u has invalid "
literal|"VDEV %llu"
argument_list|,
name|bp
argument_list|,
name|i
argument_list|,
operator|(
name|longlong_t
operator|)
name|vdevid
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|vdev_t
modifier|*
name|vd
init|=
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
name|vdevid
index|]
decl_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p DVA %u has invalid "
literal|"VDEV %llu"
argument_list|,
name|bp
argument_list|,
name|i
argument_list|,
operator|(
name|longlong_t
operator|)
name|vdevid
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_hole_ops
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p DVA %u has hole "
literal|"VDEV %llu"
argument_list|,
name|bp
argument_list|,
name|i
argument_list|,
operator|(
name|longlong_t
operator|)
name|vdevid
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_missing_ops
condition|)
block|{
comment|/* 			 * "missing" vdevs are valid during import, but we 			 * don't have their detailed info (e.g. asize), so 			 * we can't perform any more checks on them. 			 */
continue|continue;
block|}
name|uint64_t
name|offset
init|=
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
argument_list|)
decl_stmt|;
name|uint64_t
name|asize
init|=
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|bp
operator|->
name|blk_dva
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|)
name|asize
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|+
name|asize
operator|>
name|vd
operator|->
name|vdev_asize
condition|)
block|{
name|zfs_panic_recover
argument_list|(
literal|"blkptr at %p DVA %u has invalid "
literal|"OFFSET %llu"
argument_list|,
name|bp
argument_list|,
name|i
argument_list|,
operator|(
name|longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_read
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zfs_blkptr_verify
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|BP_PHYSICAL_BIRTH
argument_list|(
name|bp
argument_list|)
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_READ
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zb
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
operator|(
name|flags
operator|&
name|ZIO_FLAG_DDT_CHILD
operator|)
condition|?
name|ZIO_DDT_CHILD_READ_PIPELINE
else|:
name|ZIO_READ_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_write
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|zio_prop_t
modifier|*
name|zp
parameter_list|,
name|zio_done_func_t
modifier|*
name|ready
parameter_list|,
name|zio_done_func_t
modifier|*
name|physdone
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_checksum
operator|>=
name|ZIO_CHECKSUM_OFF
operator|&&
name|zp
operator|->
name|zp_checksum
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
operator|&&
name|zp
operator|->
name|zp_compress
operator|>=
name|ZIO_COMPRESS_OFF
operator|&&
name|zp
operator|->
name|zp_compress
operator|<
name|ZIO_COMPRESS_FUNCTIONS
operator|&&
name|DMU_OT_IS_VALID
argument_list|(
name|zp
operator|->
name|zp_type
argument_list|)
operator|&&
name|zp
operator|->
name|zp_level
operator|<
literal|32
operator|&&
name|zp
operator|->
name|zp_copies
operator|>
literal|0
operator|&&
name|zp
operator|->
name|zp_copies
operator|<=
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zb
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
operator|(
name|flags
operator|&
name|ZIO_FLAG_DDT_CHILD
operator|)
condition|?
name|ZIO_DDT_CHILD_WRITE_PIPELINE
else|:
name|ZIO_WRITE_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_ready
operator|=
name|ready
expr_stmt|;
name|zio
operator|->
name|io_physdone
operator|=
name|physdone
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|=
operator|*
name|zp
expr_stmt|;
comment|/* 	 * Data can be NULL if we are going to call zio_write_override() to 	 * provide the already-allocated BP.  But we may need the data to 	 * verify a dedup hit (if requested).  In this case, don't try to 	 * dedup (just take the already-allocated BP verbatim). 	 */
if|if
condition|(
name|data
operator|==
name|NULL
operator|&&
name|zio
operator|->
name|io_prop
operator|.
name|zp_dedup_verify
condition|)
block|{
name|zio
operator|->
name|io_prop
operator|.
name|zp_dedup
operator|=
name|zio
operator|->
name|io_prop
operator|.
name|zp_dedup_verify
operator|=
name|B_FALSE
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_rewrite
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|zb
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_REWRITE_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_write_override
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|int
name|copies
parameter_list|,
name|boolean_t
name|nopwrite
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_OPEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_txg
operator|==
name|spa_syncing_txg
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We must reset the io_prop to match the values that existed 	 * when the bp was first written by dmu_sync() keeping in mind 	 * that nopwrite and dedup are mutually exclusive. 	 */
name|zio
operator|->
name|io_prop
operator|.
name|zp_dedup
operator|=
name|nopwrite
condition|?
name|B_FALSE
else|:
name|zio
operator|->
name|io_prop
operator|.
name|zp_dedup
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|.
name|zp_nopwrite
operator|=
name|nopwrite
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
operator|=
name|copies
expr_stmt|;
name|zio
operator|->
name|io_bp_override
operator|=
name|bp
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_free
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
comment|/* 	 * The check for EMBEDDED is a performance optimization.  We 	 * process the free here (by ignoring it) rather than 	 * putting it on the list and then processing it in zio_free_sync(). 	 */
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return;
name|metaslab_check_free
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * Frees that are for the currently-syncing txg, are not going to be 	 * deferred, and which will not need to do a read (i.e. not GANG or 	 * DEDUP), can be processed immediately.  Otherwise, put them on the 	 * in-memory list for later processing. 	 */
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|||
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
operator|||
name|txg
operator|!=
name|spa
operator|->
name|spa_syncing_txg
operator|||
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|>=
name|zfs_sync_pass_deferred_free
condition|)
block|{
name|bplist_append
argument_list|(
operator|&
name|spa
operator|->
name|spa_free_bplist
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VERIFY0
argument_list|(
name|zio_wait
argument_list|(
name|zio_free_sync
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_free_sync
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|enum
name|zio_stage
name|stage
init|=
name|ZIO_FREE_PIPELINE
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
operator|==
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|<
name|zfs_sync_pass_deferred_free
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|metaslab_check_free
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|arc_freed
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
comment|/* 	 * GANG and DEDUP blocks can induce a read (for the gang block header, 	 * or the DDT), so issue them asynchronously so that this thread is 	 * not tied up. 	 */
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|||
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
condition|)
name|stage
operator||=
name|ZIO_STAGE_ISSUE_ASYNC
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_TYPE_FREE
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|stage
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_claim
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"claiming in txg %llu"
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* 	 * A claim is an allocation of a specific block.  Claims are needed 	 * to support immediate writes in the intent log.  The issue is that 	 * immediate writes contain committed data, but in a txg that was 	 * *not* committed.  Upon opening the pool after an unclean shutdown, 	 * the intent log claims all blocks that contain immediate write data 	 * so that the SPA knows they're in use. 	 * 	 * All claims *must* be resolved in the first txg -- before the SPA 	 * starts allocating blocks -- so that nothing is allocated twice. 	 * If txg == 0 we just verify that the block is claimable. 	 */
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_rootbp
operator|.
name|blk_birth
argument_list|,
operator|<
argument_list|,
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|==
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
operator|||
name|txg
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* zdb(1M) */
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_CLAIM
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|flags
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_CLAIM_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_ioctl
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|cmd
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|int
name|c
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
block|{
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_IOCTL
argument_list|,
name|ZIO_PRIORITY_NOW
argument_list|,
name|flags
argument_list|,
name|vd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_IOCTL_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_cmd
operator|=
name|cmd
expr_stmt|;
block|}
else|else
block|{
name|zio
operator|=
name|zio_null
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|cmd
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_read_phys
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|checksum
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
name|boolean_t
name|labels
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|labels
operator|||
name|offset
operator|+
name|size
operator|<=
name|VDEV_LABEL_START_SIZE
operator|||
name|offset
operator|>=
name|vd
operator|->
name|vdev_psize
operator|-
name|VDEV_LABEL_END_SIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|offset
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|vd
operator|->
name|vdev_psize
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|vd
operator|->
name|vdev_spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_READ
argument_list|,
name|priority
argument_list|,
name|flags
operator||
name|ZIO_FLAG_PHYSICAL
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_READ_PHYS_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|=
name|checksum
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_write_phys
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|checksum
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
name|boolean_t
name|labels
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|labels
operator|||
name|offset
operator|+
name|size
operator|<=
name|VDEV_LABEL_START_SIZE
operator|||
name|offset
operator|>=
name|vd
operator|->
name|vdev_psize
operator|-
name|VDEV_LABEL_END_SIZE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|offset
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|vd
operator|->
name|vdev_psize
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|vd
operator|->
name|vdev_spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|priority
argument_list|,
name|flags
operator||
name|ZIO_FLAG_PHYSICAL
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_OPEN
argument_list|,
name|ZIO_WRITE_PHYS_PIPELINE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|=
name|checksum
expr_stmt|;
if|if
condition|(
name|zio_checksum_table
index|[
name|checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_EMBEDDED
condition|)
block|{
comment|/* 		 * zec checksums are necessarily destructive -- they modify 		 * the end of the write buffer to hold the verifier/checksum. 		 * Therefore, we must make a local copy in case the data is 		 * being written to multiple places in parallel. 		 */
name|void
modifier|*
name|wbuf
init|=
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|data
argument_list|,
name|wbuf
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|wbuf
argument_list|,
name|size
argument_list|,
name|size
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a child I/O to do some work for us.  */
end_comment

begin_function
name|zio_t
modifier|*
name|zio_vdev_child_io
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|type
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|enum
name|zio_stage
name|pipeline
init|=
name|ZIO_VDEV_CHILD_PIPELINE
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_parent
operator|==
operator|(
name|pio
operator|->
name|io_vd
condition|?
name|pio
operator|->
name|io_vd
else|:
name|pio
operator|->
name|io_spa
operator|->
name|spa_root_vdev
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|ZIO_TYPE_READ
operator|&&
name|bp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we have the bp, then the child should perform the 		 * checksum and the parent need not.  This pushes error 		 * detection as close to the leaves as possible and 		 * eliminates redundant checksums in the interior nodes. 		 */
name|pipeline
operator||=
name|ZIO_STAGE_CHECKSUM_VERIFY
expr_stmt|;
name|pio
operator|->
name|io_pipeline
operator|&=
operator|~
name|ZIO_STAGE_CHECKSUM_VERIFY
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
condition|)
name|offset
operator|+=
name|VDEV_LABEL_START_SIZE
expr_stmt|;
name|flags
operator||=
name|ZIO_VDEV_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
operator||
name|ZIO_FLAG_DONT_PROPAGATE
expr_stmt|;
comment|/* 	 * If we've decided to do a repair, the write is not speculative -- 	 * even if the original read was. 	 */
if|if
condition|(
name|flags
operator|&
name|ZIO_FLAG_IO_REPAIR
condition|)
name|flags
operator|&=
operator|~
name|ZIO_FLAG_SPECULATIVE
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|type
argument_list|,
name|priority
argument_list|,
name|flags
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|,
name|ZIO_STAGE_VDEV_IO_START
operator|>>
literal|1
argument_list|,
name|pipeline
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_physdone
operator|=
name|pio
operator|->
name|io_physdone
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|zio
operator|->
name|io_logical
operator|!=
name|NULL
condition|)
name|zio
operator|->
name|io_logical
operator|->
name|io_phys_children
operator|++
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_vdev_delegated_io
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|type
parameter_list|,
name|zio_priority_t
name|priority
parameter_list|,
name|enum
name|zio_flag
name|flags
parameter_list|,
name|zio_done_func_t
modifier|*
name|done
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
argument_list|)
expr_stmt|;
name|zio
operator|=
name|zio_create
argument_list|(
name|NULL
argument_list|,
name|vd
operator|->
name|vdev_spa
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|done
argument_list|,
name|private
argument_list|,
name|type
argument_list|,
name|priority
argument_list|,
name|flags
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_RETRY
operator||
name|ZIO_FLAG_DELEGATED
argument_list|,
name|vd
argument_list|,
name|offset
argument_list|,
name|NULL
argument_list|,
name|ZIO_STAGE_VDEV_IO_START
operator|>>
literal|1
argument_list|,
name|ZIO_VDEV_CHILD_PIPELINE
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_flush
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|zio_nowait
argument_list|(
name|zio_ioctl
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|vd
argument_list|,
name|DKIOCFLUSHWRITECACHE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_DONT_PROPAGATE
operator||
name|ZIO_FLAG_DONT_RETRY
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_shrink
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_executor
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_orig_size
operator|==
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|<=
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
comment|/* 	 * We don't shrink for raidz because of problems with the 	 * reconstruction when reading back less than the block size. 	 * Note, BP_IS_RAIDZ() assumes no compression. 	 */
name|ASSERT
argument_list|(
name|BP_GET_COMPRESS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
operator|==
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BP_IS_RAIDZ
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
condition|)
name|zio
operator|->
name|io_orig_size
operator|=
name|zio
operator|->
name|io_size
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Prepare to read and write logical blocks  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_read_bp_init
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
operator|!=
name|ZIO_COMPRESS_OFF
operator|&&
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RAW
operator|)
condition|)
block|{
name|uint64_t
name|psize
init|=
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|?
name|BPE_GET_PSIZE
argument_list|(
name|bp
argument_list|)
else|:
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|void
modifier|*
name|cbuf
init|=
name|zio_buf_alloc
argument_list|(
name|psize
argument_list|)
decl_stmt|;
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|cbuf
argument_list|,
name|psize
argument_list|,
name|psize
argument_list|,
name|zio_decompress
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
operator|&&
name|BPE_GET_ETYPE
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_EMBEDDED_TYPE_DATA
condition|)
block|{
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
name|decode_embedded_bp_compressed
argument_list|(
name|bp
argument_list|,
name|zio
operator|->
name|io_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|!
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|DMU_OT_IS_METADATA
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|&&
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_CACHE
expr_stmt|;
if|if
condition|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|==
name|DMU_OT_DDT_ZAP
condition|)
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_CACHE
expr_stmt|;
if|if
condition|(
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
condition|)
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_DDT_READ_PIPELINE
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_write_bp_init
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_prop_t
modifier|*
name|zp
init|=
operator|&
name|zio
operator|->
name|io_prop
decl_stmt|;
name|enum
name|zio_compress
name|compress
init|=
name|zp
operator|->
name|zp_compress
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|uint64_t
name|lsize
init|=
name|zio
operator|->
name|io_size
decl_stmt|;
name|uint64_t
name|psize
init|=
name|lsize
decl_stmt|;
name|int
name|pass
init|=
literal|1
decl_stmt|;
comment|/* 	 * If our children haven't all reached the ready stage, 	 * wait for them and then repeat this pipeline stage. 	 */
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_LOGICAL
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
operator|!
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|!=
name|ZIO_CHILD_DDT
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_bp_override
condition|)
block|{
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|!=
name|zio
operator|->
name|io_txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_DEDUP
argument_list|(
name|zio
operator|->
name|io_bp_override
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
operator|*
name|zio
operator|->
name|io_bp_override
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
comment|/* 		 * If we've been overridden and nopwrite is set then 		 * set the flag accordingly to indicate that a nopwrite 		 * has already occurred. 		 */
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|&&
name|zp
operator|->
name|zp_nopwrite
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|zp
operator|->
name|zp_dedup
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_NOPWRITE
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
name|ASSERT
argument_list|(
operator|!
name|zp
operator|->
name|zp_nopwrite
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
operator|!
name|zp
operator|->
name|zp_dedup
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
name|ASSERT
argument_list|(
operator|(
name|zio_checksum_table
index|[
name|zp
operator|->
name|zp_checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_DEDUP
operator|)
operator|||
name|zp
operator|->
name|zp_dedup_verify
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|zp
operator|->
name|zp_checksum
condition|)
block|{
name|BP_SET_DEDUP
argument_list|(
name|bp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator||=
name|ZIO_STAGE_DDT_WRITE
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
name|zio
operator|->
name|io_bp_override
operator|=
name|NULL
expr_stmt|;
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|&&
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
condition|)
block|{
comment|/* 		 * We're rewriting an existing block, which means we're 		 * working on behalf of spa_sync().  For spa_sync() to 		 * converge, it must eventually be the case that we don't 		 * have to allocate new blocks.  But compression changes 		 * the blocksize, which forces a reallocate, and makes 		 * convergence take longer.  Therefore, after the first 		 * few passes, stop compressing to ensure convergence. 		 */
name|pass
operator|=
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_txg
operator|==
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|>=
name|zfs_sync_pass_dont_compress
condition|)
name|compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
comment|/* Make sure someone doesn't change their mind on overwrites */
name|ASSERT
argument_list|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
operator|||
name|MIN
argument_list|(
name|zp
operator|->
name|zp_copies
operator|+
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|,
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|compress
operator|!=
name|ZIO_COMPRESS_OFF
condition|)
block|{
name|void
modifier|*
name|cbuf
init|=
name|zio_buf_alloc
argument_list|(
name|lsize
argument_list|)
decl_stmt|;
name|psize
operator|=
name|zio_compress_data
argument_list|(
name|compress
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|cbuf
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|psize
operator|==
literal|0
operator|||
name|psize
operator|==
name|lsize
condition|)
block|{
name|compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
name|zio_buf_free
argument_list|(
name|cbuf
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zp
operator|->
name|zp_dedup
operator|&&
name|psize
operator|<=
name|BPE_PAYLOAD_SIZE
operator|&&
name|zp
operator|->
name|zp_level
operator|==
literal|0
operator|&&
operator|!
name|DMU_OT_HAS_FILL
argument_list|(
name|zp
operator|->
name|zp_type
argument_list|)
operator|&&
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_EMBEDDED_DATA
argument_list|)
condition|)
block|{
name|encode_embedded_bp_compressed
argument_list|(
name|bp
argument_list|,
name|cbuf
argument_list|,
name|compress
argument_list|,
name|lsize
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|BPE_SET_ETYPE
argument_list|(
name|bp
argument_list|,
name|BP_EMBEDDED_TYPE_DATA
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|bp
argument_list|,
name|zio
operator|->
name|io_prop
operator|.
name|zp_type
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|bp
argument_list|,
name|zio
operator|->
name|io_prop
operator|.
name|zp_level
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|cbuf
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|bp
operator|->
name|blk_birth
operator|=
name|zio
operator|->
name|io_txg
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_EMBEDDED_DATA
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
else|else
block|{
comment|/* 			 * Round up compressed size up to the ashift 			 * of the smallest-ashift device, and zero the tail. 			 * This ensures that the compressed size of the BP 			 * (and thus compressratio property) are correct, 			 * in that we charge for the padding used to fill out 			 * the last sector. 			 */
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_min_ashift
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|size_t
name|rounded
init|=
operator|(
name|size_t
operator|)
name|P2ROUNDUP
argument_list|(
name|psize
argument_list|,
literal|1ULL
operator|<<
name|spa
operator|->
name|spa_min_ashift
argument_list|)
decl_stmt|;
if|if
condition|(
name|rounded
operator|>=
name|lsize
condition|)
block|{
name|compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
name|zio_buf_free
argument_list|(
name|cbuf
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|psize
operator|=
name|lsize
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cbuf
operator|+
name|psize
argument_list|,
name|rounded
operator|-
name|psize
argument_list|)
expr_stmt|;
name|psize
operator|=
name|rounded
expr_stmt|;
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|cbuf
argument_list|,
name|psize
argument_list|,
name|lsize
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * The final pass of spa_sync() must be all rewrites, but the first 	 * few passes offer a trade-off: allocating blocks defers convergence, 	 * but newly allocated blocks are sequential, so they can be written 	 * to disk faster.  Therefore, we allow the first few passes of 	 * spa_sync() to allocate new blocks, but force rewrites after that. 	 * There should only be a handful of blocks after pass 1 in any case. 	 */
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|&&
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
operator|&&
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|==
name|psize
operator|&&
name|pass
operator|>=
name|zfs_sync_pass_rewrite
condition|)
block|{
name|ASSERT
argument_list|(
name|psize
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|enum
name|zio_stage
name|gang_stages
init|=
name|zio
operator|->
name|io_pipeline
operator|&
name|ZIO_GANG_STAGES
decl_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_REWRITE_PIPELINE
operator||
name|gang_stages
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_IO_REWRITE
expr_stmt|;
block|}
else|else
block|{
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_WRITE_PIPELINE
expr_stmt|;
block|}
if|if
condition|(
name|psize
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_bp_orig
operator|.
name|blk_birth
operator|!=
literal|0
operator|&&
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_HOLE_BIRTH
argument_list|)
condition|)
block|{
name|BP_SET_LSIZE
argument_list|(
name|bp
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_type
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_level
argument_list|)
expr_stmt|;
name|BP_SET_BIRTH
argument_list|(
name|bp
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_checksum
operator|!=
name|ZIO_CHECKSUM_GANG_HEADER
argument_list|)
expr_stmt|;
name|BP_SET_LSIZE
argument_list|(
name|bp
argument_list|,
name|lsize
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_type
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_level
argument_list|)
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
name|bp
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
name|bp
argument_list|,
name|compress
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_checksum
argument_list|)
expr_stmt|;
name|BP_SET_DEDUP
argument_list|(
name|bp
argument_list|,
name|zp
operator|->
name|zp_dedup
argument_list|)
expr_stmt|;
name|BP_SET_BYTEORDER
argument_list|(
name|bp
argument_list|,
name|ZFS_HOST_BYTEORDER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|zp_dedup
condition|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REWRITE
operator|)
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_DDT_WRITE_PIPELINE
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|zp_nopwrite
condition|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REWRITE
operator|)
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator||=
name|ZIO_STAGE_NOP_WRITE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_free_bp_init
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
condition|)
block|{
if|if
condition|(
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
condition|)
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_DDT_FREE_PIPELINE
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Execute the I/O pipeline  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_taskq_dispatch
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|zio_taskq_type_t
name|q
parameter_list|,
name|boolean_t
name|cutinline
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_type_t
name|t
init|=
name|zio
operator|->
name|io_type
decl_stmt|;
name|int
name|flags
init|=
operator|(
name|cutinline
condition|?
name|TQ_FRONT
else|:
literal|0
operator|)
decl_stmt|;
comment|/* 	 * If we're a config writer or a probe, the normal issue and 	 * interrupt threads may all be blocked waiting for the config lock. 	 * In this case, select the otherwise-unused taskq for ZIO_TYPE_NULL. 	 */
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
operator|(
name|ZIO_FLAG_CONFIG_WRITER
operator||
name|ZIO_FLAG_PROBE
operator|)
condition|)
name|t
operator|=
name|ZIO_TYPE_NULL
expr_stmt|;
comment|/* 	 * A similar issue exists for the L2ARC write thread until L2ARC 2.0. 	 */
if|if
condition|(
name|t
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|zio
operator|->
name|io_vd
operator|&&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_aux
condition|)
name|t
operator|=
name|ZIO_TYPE_NULL
expr_stmt|;
comment|/* 	 * If this is a high priority I/O, then use the high priority taskq if 	 * available. 	 */
if|if
condition|(
name|zio
operator|->
name|io_priority
operator|==
name|ZIO_PRIORITY_NOW
operator|&&
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
operator|+
literal|1
index|]
operator|.
name|stqs_count
operator|!=
literal|0
condition|)
name|q
operator|++
expr_stmt|;
name|ASSERT3U
argument_list|(
name|q
argument_list|,
operator|<
argument_list|,
name|ZIO_TASKQ_TYPES
argument_list|)
expr_stmt|;
comment|/* 	 * NB: We are assuming that the zio can only be dispatched 	 * to a single taskq at a time.  It would be a grievous error 	 * to dispatch the zio to another taskq at the same time. 	 */
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_tqent
operator|.
name|tqent_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|spa_taskq_dispatch_ent
argument_list|(
name|spa
argument_list|,
name|t
argument_list|,
name|q
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|zio_execute
argument_list|,
name|zio
argument_list|,
name|flags
argument_list|,
operator|&
name|zio
operator|->
name|io_tqent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zio_taskq_member
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|zio_taskq_type_t
name|q
parameter_list|)
block|{
name|kthread_t
modifier|*
name|executor
init|=
name|zio
operator|->
name|io_executor
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
for|for
control|(
name|zio_type_t
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
name|spa_taskqs_t
modifier|*
name|tqs
init|=
operator|&
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
decl_stmt|;
name|uint_t
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tqs
operator|->
name|stqs_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|taskq_member
argument_list|(
name|tqs
operator|->
name|stqs_taskq
index|[
name|i
index|]
argument_list|,
name|executor
argument_list|)
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_issue_async
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_interrupt
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_INTERRUPT
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Execute the I/O pipeline until one of the following occurs:  *  *	(1) the I/O completes  *	(2) the pipeline stalls waiting for dependent child I/Os  *	(3) the I/O issues, so we're waiting for an I/O completion interrupt  *	(4) the I/O is delegated by vdev-level caching or aggregation  *	(5) the I/O is deferred due to vdev-level queueing  *	(6) the I/O is handed off to another thread.  *  * In all cases, the pipeline stops whenever there's no CPU work; it never  * burns a thread in cv_wait().  *  * There's no locking on io_stage because there's no legitimate way  * for multiple threads to be attempting to process the same I/O.  */
end_comment

begin_decl_stmt
specifier|static
name|zio_pipe_stage_t
modifier|*
name|zio_pipeline
index|[]
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|zio_execute
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio
operator|->
name|io_executor
operator|=
name|curthread
expr_stmt|;
while|while
condition|(
name|zio
operator|->
name|io_stage
operator|<
name|ZIO_STAGE_DONE
condition|)
block|{
name|enum
name|zio_stage
name|pipeline
init|=
name|zio
operator|->
name|io_pipeline
decl_stmt|;
name|enum
name|zio_stage
name|stage
init|=
name|zio
operator|->
name|io_stage
decl_stmt|;
name|int
name|rv
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|stage
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stall
operator|==
name|NULL
argument_list|)
expr_stmt|;
do|do
block|{
name|stage
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|stage
operator|&
name|pipeline
operator|)
operator|==
literal|0
condition|)
do|;
name|ASSERT
argument_list|(
name|stage
operator|<=
name|ZIO_STAGE_DONE
argument_list|)
expr_stmt|;
comment|/* 		 * If we are in interrupt context and this pipeline stage 		 * will grab a config lock that is held across I/O, 		 * or may wait for an I/O that needs an interrupt thread 		 * to complete, issue async to avoid deadlock. 		 * 		 * For VDEV_IO_START, we cut in line so that the io will 		 * be sent to disk promptly. 		 */
if|if
condition|(
operator|(
name|stage
operator|&
name|ZIO_BLOCKING_STAGES
operator|)
operator|&&
name|zio
operator|->
name|io_vd
operator|==
name|NULL
operator|&&
name|zio_taskq_member
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_INTERRUPT
argument_list|)
condition|)
block|{
name|boolean_t
name|cut
init|=
operator|(
name|stage
operator|==
name|ZIO_STAGE_VDEV_IO_START
operator|)
condition|?
name|zio_requeue_io_start_cut_in_line
else|:
name|B_FALSE
decl_stmt|;
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|,
name|cut
argument_list|)
expr_stmt|;
return|return;
block|}
name|zio
operator|->
name|io_stage
operator|=
name|stage
expr_stmt|;
name|rv
operator|=
name|zio_pipeline
index|[
name|highbit64
argument_list|(
name|stage
argument_list|)
operator|-
literal|1
index|]
operator|(
name|zio
operator|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
name|ZIO_PIPELINE_STOP
condition|)
return|return;
name|ASSERT
argument_list|(
name|rv
operator|==
name|ZIO_PIPELINE_CONTINUE
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Initiate I/O, either sync or async  * ==========================================================================  */
end_comment

begin_function
name|int
name|zio_wait
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_OPEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_executor
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_waiter
operator|=
name|curthread
expr_stmt|;
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|zio
operator|->
name|io_executor
operator|!=
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|,
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|zio_destroy
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_nowait
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_executor
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
operator|&&
name|zio_unique_parent
argument_list|(
name|zio
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is a logical async I/O with no parent to wait for it. 		 * We add it to the spa_async_root_zio "Godfather" I/O which 		 * will ensure they complete prior to unloading the pool. 		 */
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_add_child
argument_list|(
name|spa
operator|->
name|spa_async_zio_root
index|[
name|CPU_SEQID
index|]
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Reexecute or suspend/resume failed I/O  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_reexecute
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|)
block|{
name|zio_t
modifier|*
name|cio
decl_stmt|,
modifier|*
name|cio_next
decl_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_orig_stage
operator|==
name|ZIO_STAGE_OPEN
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_gang_leader
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_gang_tree
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|pio
operator|->
name|io_flags
operator|=
name|pio
operator|->
name|io_orig_flags
expr_stmt|;
name|pio
operator|->
name|io_stage
operator|=
name|pio
operator|->
name|io_orig_stage
expr_stmt|;
name|pio
operator|->
name|io_pipeline
operator|=
name|pio
operator|->
name|io_orig_pipeline
expr_stmt|;
name|pio
operator|->
name|io_reexecute
operator|=
literal|0
expr_stmt|;
name|pio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_REEXECUTED
expr_stmt|;
name|pio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|ZIO_WAIT_TYPES
condition|;
name|w
operator|++
control|)
name|pio
operator|->
name|io_state
index|[
name|w
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHILD_TYPES
condition|;
name|c
operator|++
control|)
name|pio
operator|->
name|io_child_error
index|[
name|c
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|IO_IS_ALLOCATING
argument_list|(
name|pio
argument_list|)
condition|)
name|BP_ZERO
argument_list|(
name|pio
operator|->
name|io_bp
argument_list|)
expr_stmt|;
comment|/* 	 * As we reexecute pio's children, new children could be created. 	 * New children go to the head of pio's io_child_list, however, 	 * so we will (correctly) not reexecute them.  The key is that 	 * the remainder of pio's io_child_list, from 'cio_next' onward, 	 * cannot be affected by any side effects of reexecuting 'cio'. 	 */
for|for
control|(
name|cio
operator|=
name|zio_walk_children
argument_list|(
name|pio
argument_list|)
init|;
name|cio
operator|!=
name|NULL
condition|;
name|cio
operator|=
name|cio_next
control|)
block|{
name|cio_next
operator|=
name|zio_walk_children
argument_list|(
name|pio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|ZIO_WAIT_TYPES
condition|;
name|w
operator|++
control|)
name|pio
operator|->
name|io_children
index|[
name|cio
operator|->
name|io_child_type
index|]
index|[
name|w
index|]
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio_reexecute
argument_list|(
name|cio
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Now that all children have been reexecuted, execute the parent. 	 * We don't reexecute "The Godfather" I/O here as it's the 	 * responsibility of the caller to wait on him. 	 */
if|if
condition|(
operator|!
operator|(
name|pio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_GODFATHER
operator|)
condition|)
name|zio_execute
argument_list|(
name|pio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
if|if
condition|(
name|spa_get_failmode
argument_list|(
name|spa
argument_list|)
operator|==
name|ZIO_FAILURE_MODE_PANIC
condition|)
name|fm_panic
argument_list|(
literal|"Pool '%s' has encountered an uncorrectable I/O "
literal|"failure and the failure mode property for this pool "
literal|"is set to panic."
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_IO_FAILURE
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_suspend_zio_root
operator|==
name|NULL
condition|)
name|spa
operator|->
name|spa_suspend_zio_root
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_GODFATHER
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_suspended
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zio
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_GODFATHER
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|!=
name|spa
operator|->
name|spa_suspend_zio_root
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio_unique_parent
argument_list|(
name|zio
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_DONE
argument_list|)
expr_stmt|;
name|zio_add_child
argument_list|(
name|spa
operator|->
name|spa_suspend_zio_root
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zio_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|;
comment|/* 	 * Reexecute all previously suspended i/o. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_suspended
operator|=
name|B_FALSE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_cv
argument_list|)
expr_stmt|;
name|pio
operator|=
name|spa
operator|->
name|spa_suspend_zio_root
expr_stmt|;
name|spa
operator|->
name|spa_suspend_zio_root
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|pio
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zio_reexecute
argument_list|(
name|pio
argument_list|)
expr_stmt|;
return|return
operator|(
name|zio_wait
argument_list|(
name|pio
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_resume_wait
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_suspend_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Gang blocks.  *  * A gang block is a collection of small blocks that looks to the DMU  * like one large block.  When zio_dva_allocate() cannot find a block  * of the requested size, due to either severe fragmentation or the pool  * being nearly full, it calls zio_write_gang_block() to construct the  * block from smaller fragments.  *  * A gang block consists of a gang header (zio_gbh_phys_t) and up to  * three (SPA_GBH_NBLKPTRS) gang members.  The gang header is just like  * an indirect block: it's an array of block pointers.  It consumes  * only one sector and hence is allocatable regardless of fragmentation.  * The gang header's bps point to its gang members, which hold the data.  *  * Gang blocks are self-checksumming, using the bp's<vdev, offset, txg>  * as the verifier to ensure uniqueness of the SHA256 checksum.  * Critically, the gang block bp's blk_cksum is the checksum of the data,  * not the gang header.  This ensures that data block signatures (needed for  * deduplication) are independent of how the block is physically stored.  *  * Gang blocks can be nested: a gang member may itself be a gang block.  * Thus every gang block is a tree in which root and all interior nodes are  * gang headers, and the leaves are normal blocks that contain user data.  * The root of the gang tree is called the gang leader.  *  * To perform any operation (read, rewrite, free, claim) on a gang block,  * zio_gang_assemble() first assembles the gang tree (minus data leaves)  * in the io_gang_tree field of the original logical i/o by recursively  * reading the gang leader and all gang headers below it.  This yields  * an in-core tree containing the contents of every gang header and the  * bps for every constituent of the gang block.  *  * With the gang tree now assembled, zio_gang_issue() just walks the gang tree  * and invokes a callback on each bp.  To free a gang block, zio_gang_issue()  * calls zio_free_gang() -- a trivial wrapper around zio_free() -- for each bp.  * zio_claim_gang() provides a similarly trivial wrapper for zio_claim().  * zio_read_gang() is a wrapper around zio_read() that omits reading gang  * headers, since we already have those in io_gang_tree.  zio_rewrite_gang()  * performs a zio_rewrite() of the data or, for gang headers, a zio_rewrite()  * of the gang header plus zio_checksum_compute() of the data to update the  * gang header's blk_cksum as described above.  *  * The two-phase assemble/issue model solves the problem of partial failure --  * what if you'd freed part of a gang block but then couldn't read the  * gang header for another part?  Assembling the entire gang tree first  * ensures that all the necessary gang header I/O has succeeded before  * starting the actual work of free, claim, or write.  Once the gang tree  * is assembled, free and claim are in-memory operations that cannot fail.  *  * In the event that a gang write fails, zio_dva_unallocate() walks the  * gang tree to immediately free (i.e. insert back into the space map)  * everything we've allocated.  This ensures that we don't get ENOSPC  * errors during repeated suspend/resume cycles due to a flaky device.  *  * Gang rewrites only happen during sync-to-convergence.  If we can't assemble  * the gang tree, we won't modify the block, so we can safely defer the free  * (knowing that the block is still intact).  If we *can* assemble the gang  * tree, then even if some of the rewrites fail, zio_dva_unallocate() will free  * each constituent bp and we can allocate a new block on the next sync pass.  *  * In all cases, the gang tree allows complete recovery from partial failure.  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|zio_t
modifier|*
name|zio_read_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pio
operator|)
return|;
return|return
operator|(
name|zio_read
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|zio_rewrite_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|=
name|zio_rewrite
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|gn
operator|->
name|gn_gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
comment|/* 		 * As we rewrite each gang header, the pipeline will compute 		 * a new gang block header checksum for it; but no one will 		 * compute a new data checksum, so we do that here.  The one 		 * exception is the gang leader: the pipeline already computed 		 * its data checksum because that stage precedes gang assembly. 		 * (Presently, nothing actually uses interior data checksums; 		 * this is just good hygiene.) 		 */
if|if
condition|(
name|gn
operator|!=
name|pio
operator|->
name|io_gang_leader
operator|->
name|io_gang_tree
condition|)
block|{
name|zio_checksum_compute
argument_list|(
name|zio
argument_list|,
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
argument_list|,
name|data
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we are here to damage data for testing purposes, 		 * leave the GBH alone so that we can detect the damage. 		 */
if|if
condition|(
name|pio
operator|->
name|io_gang_leader
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_INDUCE_DAMAGE
condition|)
name|zio
operator|->
name|io_pipeline
operator|&=
operator|~
name|ZIO_VDEV_IO_STAGES
expr_stmt|;
block|}
else|else
block|{
name|zio
operator|=
name|zio_rewrite
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|data
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|zio_t
modifier|*
name|zio_free_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|zio_free_sync
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|zio_t
modifier|*
name|zio_claim_gang
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
return|return
operator|(
name|zio_claim
argument_list|(
name|pio
argument_list|,
name|pio
operator|->
name|io_spa
argument_list|,
name|pio
operator|->
name|io_txg
argument_list|,
name|bp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|zio_gang_issue_func_t
modifier|*
name|zio_gang_issue_func
index|[
name|ZIO_TYPES
index|]
init|=
block|{
name|NULL
block|,
name|zio_read_gang
block|,
name|zio_rewrite_gang
block|,
name|zio_free_gang
block|,
name|zio_claim_gang
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|zio_gang_tree_assemble_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|zio_gang_node_t
modifier|*
name|zio_gang_node_alloc
parameter_list|(
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
decl_stmt|;
name|ASSERT
argument_list|(
operator|*
name|gnpp
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|gn
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|gn
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|gn
operator|->
name|gn_gbh
operator|=
name|zio_buf_alloc
argument_list|(
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
operator|*
name|gnpp
operator|=
name|gn
expr_stmt|;
return|return
operator|(
name|gn
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_node_free
parameter_list|(
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
init|=
operator|*
name|gnpp
decl_stmt|;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
name|ASSERT
argument_list|(
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|gn
operator|->
name|gn_gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|gn
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|gn
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|gnpp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_free
parameter_list|(
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
init|=
operator|*
name|gnpp
decl_stmt|;
if|if
condition|(
name|gn
operator|==
name|NULL
condition|)
return|return;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
name|zio_gang_tree_free
argument_list|(
operator|&
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|)
expr_stmt|;
name|zio_gang_node_free
argument_list|(
name|gnpp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_assemble
parameter_list|(
name|zio_t
modifier|*
name|gio
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|zio_gang_node_t
modifier|*
modifier|*
name|gnpp
parameter_list|)
block|{
name|zio_gang_node_t
modifier|*
name|gn
init|=
name|zio_gang_node_alloc
argument_list|(
name|gnpp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|gio
operator|->
name|io_gang_leader
operator|==
name|gio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|gio
argument_list|,
name|gio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|,
name|gn
operator|->
name|gn_gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|zio_gang_tree_assemble_done
argument_list|,
name|gn
argument_list|,
name|gio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|gio
argument_list|)
argument_list|,
operator|&
name|gio
operator|->
name|io_bookmark
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_assemble_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|gio
init|=
name|zio
operator|->
name|io_gang_leader
decl_stmt|;
name|zio_gang_node_t
modifier|*
name|gn
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ASSERT
argument_list|(
name|gio
operator|==
name|zio_unique_parent
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_count
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
return|return;
if|if
condition|(
name|BP_SHOULD_BYTESWAP
argument_list|(
name|bp
argument_list|)
condition|)
name|byteswap_uint64_array
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_data
operator|==
name|gn
operator|->
name|gn_gbh
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_size
operator|==
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_tail
operator|.
name|zec_magic
operator|==
name|ZEC_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
block|{
name|blkptr_t
modifier|*
name|gbp
init|=
operator|&
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|BP_IS_GANG
argument_list|(
name|gbp
argument_list|)
condition|)
continue|continue;
name|zio_gang_tree_assemble
argument_list|(
name|gio
argument_list|,
name|gbp
argument_list|,
operator|&
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|zio_gang_tree_issue
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|)
block|{
name|zio_t
modifier|*
name|gio
init|=
name|pio
operator|->
name|io_gang_leader
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|==
operator|!
operator|!
name|gn
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_GET_CHECKSUM
argument_list|(
name|gio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|||
name|gn
operator|==
name|gio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
comment|/* 	 * If you're a gang header, your data is in gn->gn_gbh. 	 * If you're a gang member, your data is in 'data' and gn == NULL. 	 */
name|zio
operator|=
name|zio_gang_issue_func
index|[
name|gio
operator|->
name|io_type
index|]
operator|(
name|pio
operator|,
name|bp
operator|,
name|gn
operator|,
name|data
operator|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_tail
operator|.
name|zec_magic
operator|==
name|ZEC_MAGIC
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
block|{
name|blkptr_t
modifier|*
name|gbp
init|=
operator|&
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|gbp
argument_list|)
condition|)
continue|continue;
name|zio_gang_tree_issue
argument_list|(
name|zio
argument_list|,
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|,
name|gbp
argument_list|,
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|BP_GET_PSIZE
argument_list|(
name|gbp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|gn
operator|==
name|gio
operator|->
name|io_gang_tree
condition|)
name|ASSERT3P
argument_list|(
operator|(
name|char
operator|*
operator|)
name|gio
operator|->
name|io_data
operator|+
name|gio
operator|->
name|io_size
argument_list|,
operator|==
argument_list|,
name|data
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|!=
name|pio
condition|)
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_gang_assemble
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|->
name|io_gang_leader
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|>
name|ZIO_CHILD_GANG
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_gang_leader
operator|=
name|zio
expr_stmt|;
name|zio_gang_tree_assemble
argument_list|(
name|zio
argument_list|,
name|bp
argument_list|,
operator|&
name|zio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_gang_issue
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|->
name|io_gang_leader
operator|==
name|zio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|>
name|ZIO_CHILD_GANG
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_error
index|[
name|ZIO_CHILD_GANG
index|]
operator|==
literal|0
condition|)
name|zio_gang_tree_issue
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_gang_tree
argument_list|,
name|bp
argument_list|,
name|zio
operator|->
name|io_data
argument_list|)
expr_stmt|;
else|else
name|zio_gang_tree_free
argument_list|(
operator|&
name|zio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_write_gang_member_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|pio
init|=
name|zio_unique_parent
argument_list|(
name|zio
argument_list|)
decl_stmt|;
name|zio_t
modifier|*
name|gio
init|=
name|zio
operator|->
name|io_gang_leader
decl_stmt|;
name|dva_t
modifier|*
name|cdva
init|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_dva
decl_stmt|;
name|dva_t
modifier|*
name|pdva
init|=
name|pio
operator|->
name|io_bp
operator|->
name|blk_dva
decl_stmt|;
name|uint64_t
name|asize
decl_stmt|;
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
condition|)
return|return;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_GANG
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|,
operator|==
argument_list|,
name|gio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|pio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|pio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|pio
operator|->
name|io_bp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|BP_GET_NDVAS
argument_list|(
name|zio
operator|->
name|io_bp
argument_list|)
condition|;
name|d
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|DVA_GET_GANG
argument_list|(
operator|&
name|pdva
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|asize
operator|=
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|pdva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|asize
operator|+=
name|DVA_GET_ASIZE
argument_list|(
operator|&
name|cdva
index|[
name|d
index|]
argument_list|)
expr_stmt|;
name|DVA_SET_ASIZE
argument_list|(
operator|&
name|pdva
index|[
name|d
index|]
argument_list|,
name|asize
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_write_gang_block
parameter_list|(
name|zio_t
modifier|*
name|pio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|pio
operator|->
name|io_spa
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|pio
operator|->
name|io_bp
decl_stmt|;
name|zio_t
modifier|*
name|gio
init|=
name|pio
operator|->
name|io_gang_leader
decl_stmt|;
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|zio_gang_node_t
modifier|*
name|gn
decl_stmt|,
modifier|*
modifier|*
name|gnpp
decl_stmt|;
name|zio_gbh_phys_t
modifier|*
name|gbh
decl_stmt|;
name|uint64_t
name|txg
init|=
name|pio
operator|->
name|io_txg
decl_stmt|;
name|uint64_t
name|resid
init|=
name|pio
operator|->
name|io_size
decl_stmt|;
name|uint64_t
name|lsize
decl_stmt|;
name|int
name|copies
init|=
name|gio
operator|->
name|io_prop
operator|.
name|zp_copies
decl_stmt|;
name|int
name|gbh_copies
init|=
name|MIN
argument_list|(
name|copies
operator|+
literal|1
argument_list|,
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
decl_stmt|;
name|zio_prop_t
name|zp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|bp
argument_list|,
name|gbh_copies
argument_list|,
name|txg
argument_list|,
name|pio
operator|==
name|gio
condition|?
name|NULL
else|:
name|gio
operator|->
name|io_bp
argument_list|,
name|METASLAB_HINTBP_FAVOR
operator||
name|METASLAB_GANG_HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
if|if
condition|(
name|pio
operator|==
name|gio
condition|)
block|{
name|gnpp
operator|=
operator|&
name|gio
operator|->
name|io_gang_tree
expr_stmt|;
block|}
else|else
block|{
name|gnpp
operator|=
name|pio
operator|->
name|io_private
expr_stmt|;
name|ASSERT
argument_list|(
name|pio
operator|->
name|io_ready
operator|==
name|zio_write_gang_member_ready
argument_list|)
expr_stmt|;
block|}
name|gn
operator|=
name|zio_gang_node_alloc
argument_list|(
name|gnpp
argument_list|)
expr_stmt|;
name|gbh
operator|=
name|gn
operator|->
name|gn_gbh
expr_stmt|;
name|bzero
argument_list|(
name|gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Create the gang header. 	 */
name|zio
operator|=
name|zio_rewrite
argument_list|(
name|pio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|gbh
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
comment|/* 	 * Create and nowait the gang children. 	 */
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|resid
operator|!=
literal|0
condition|;
name|resid
operator|-=
name|lsize
operator|,
name|g
operator|++
control|)
block|{
name|lsize
operator|=
name|P2ROUNDUP
argument_list|(
name|resid
operator|/
operator|(
name|SPA_GBH_NBLKPTRS
operator|-
name|g
operator|)
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lsize
operator|>=
name|SPA_MINBLOCKSIZE
operator|&&
name|lsize
operator|<=
name|resid
argument_list|)
expr_stmt|;
name|zp
operator|.
name|zp_checksum
operator|=
name|gio
operator|->
name|io_prop
operator|.
name|zp_checksum
expr_stmt|;
name|zp
operator|.
name|zp_compress
operator|=
name|ZIO_COMPRESS_OFF
expr_stmt|;
name|zp
operator|.
name|zp_type
operator|=
name|DMU_OT_NONE
expr_stmt|;
name|zp
operator|.
name|zp_level
operator|=
literal|0
expr_stmt|;
name|zp
operator|.
name|zp_copies
operator|=
name|gio
operator|->
name|io_prop
operator|.
name|zp_copies
expr_stmt|;
name|zp
operator|.
name|zp_dedup
operator|=
name|B_FALSE
expr_stmt|;
name|zp
operator|.
name|zp_dedup_verify
operator|=
name|B_FALSE
expr_stmt|;
name|zp
operator|.
name|zp_nopwrite
operator|=
name|B_FALSE
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_write
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
operator|&
name|gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pio
operator|->
name|io_data
operator|+
operator|(
name|pio
operator|->
name|io_size
operator|-
name|resid
operator|)
argument_list|,
name|lsize
argument_list|,
operator|&
name|zp
argument_list|,
name|zio_write_gang_member_ready
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|,
name|pio
operator|->
name|io_priority
argument_list|,
name|ZIO_GANG_CHILD_FLAGS
argument_list|(
name|pio
argument_list|)
argument_list|,
operator|&
name|pio
operator|->
name|io_bookmark
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set pio's pipeline to just wait for zio to finish. 	 */
name|pio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The zio_nop_write stage in the pipeline determines if allocating a  * new bp is necessary.  The nopwrite feature can handle writes in  * either syncing or open context (i.e. zil writes) and as a result is  * mutually exclusive with dedup.  *  * By leveraging a cryptographically secure checksum, such as SHA256, we  * can compare the checksums of the new data and the old to determine if  * allocating a new block is required.  Note that our requirements for  * cryptographic strength are fairly weak: there can't be any accidental  * hash collisions, but we don't need to be secure against intentional  * (malicious) collisions.  To trigger a nopwrite, you have to be able  * to write the file to begin with, and triggering an incorrect (hash  * collision) nopwrite is no worse than simply writing to the file.  * That said, there are no known attacks against the checksum algorithms  * used for nopwrite, assuming that the salt and the checksums  * themselves remain secret.  */
end_comment

begin_function
specifier|static
name|int
name|zio_nop_write
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|blkptr_t
modifier|*
name|bp_orig
init|=
operator|&
name|zio
operator|->
name|io_bp_orig
decl_stmt|;
name|zio_prop_t
modifier|*
name|zp
init|=
operator|&
name|zio
operator|->
name|io_prop
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REWRITE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_nopwrite
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|zp
operator|->
name|zp_dedup
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_bp_override
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Check to see if the original bp and the new bp have matching 	 * characteristics (i.e. same checksum, compression algorithms, etc). 	 * If they don't then just continue with the pipeline which will 	 * allocate a new bp. 	 */
if|if
condition|(
name|BP_IS_HOLE
argument_list|(
name|bp_orig
argument_list|)
operator|||
operator|!
operator|(
name|zio_checksum_table
index|[
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_NOPWRITE
operator|)
operator|||
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|!=
name|BP_GET_CHECKSUM
argument_list|(
name|bp_orig
argument_list|)
operator|||
name|BP_GET_COMPRESS
argument_list|(
name|bp
argument_list|)
operator|!=
name|BP_GET_COMPRESS
argument_list|(
name|bp_orig
argument_list|)
operator|||
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
operator|!=
name|BP_GET_DEDUP
argument_list|(
name|bp_orig
argument_list|)
operator|||
name|zp
operator|->
name|zp_copies
operator|!=
name|BP_GET_NDVAS
argument_list|(
name|bp_orig
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
comment|/* 	 * If the checksums match then reset the pipeline so that we 	 * avoid allocating a new bp and issuing any I/O. 	 */
if|if
condition|(
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|bp
operator|->
name|blk_cksum
argument_list|,
name|bp_orig
operator|->
name|blk_cksum
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|zio_checksum_table
index|[
name|zp
operator|->
name|zp_checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_NOPWRITE
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|==
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp_orig
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|BP_GET_LSIZE
argument_list|(
name|bp
argument_list|)
argument_list|,
operator|==
argument_list|,
name|BP_GET_LSIZE
argument_list|(
name|bp_orig
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_compress
operator|!=
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
operator|&
name|bp
operator|->
name|blk_prop
argument_list|,
operator|&
name|bp_orig
operator|->
name|blk_prop
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
operator|*
name|bp_orig
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_NOPWRITE
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Dedup  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|zio_ddt_child_read_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
decl_stmt|;
name|zio_t
modifier|*
name|pio
init|=
name|zio_unique_parent
argument_list|(
name|zio
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|ddp
operator|=
name|ddt_phys_select
argument_list|(
name|dde
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|ddt_phys_clear
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
comment|/* this ddp doesn't need repair */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|dde
operator|->
name|dde_repair_data
operator|==
name|NULL
condition|)
name|dde
operator|->
name|dde_repair_data
operator|=
name|zio
operator|->
name|io_data
expr_stmt|;
else|else
name|zio_buf_free
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_ddt_read_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|==
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_error
index|[
name|ZIO_CHILD_DDT
index|]
condition|)
block|{
name|ddt_t
modifier|*
name|ddt
init|=
name|ddt_select
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
init|=
name|ddt_repair_start
argument_list|(
name|ddt
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
init|=
name|dde
operator|->
name|dde_phys
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp_self
init|=
name|ddt_phys_select
argument_list|(
name|dde
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|blkptr_t
name|blk
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_vsd
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_vsd
operator|=
name|dde
expr_stmt|;
if|if
condition|(
name|ddp_self
operator|==
name|NULL
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
for|for
control|(
name|int
name|p
init|=
literal|0
init|;
name|p
operator|<
name|DDT_PHYS_TYPES
condition|;
name|p
operator|++
operator|,
name|ddp
operator|++
control|)
block|{
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|==
literal|0
operator|||
name|ddp
operator|==
name|ddp_self
condition|)
continue|continue;
name|ddt_bp_create
argument_list|(
name|ddt
operator|->
name|ddt_checksum
argument_list|,
operator|&
name|dde
operator|->
name|dde_key
argument_list|,
name|ddp
argument_list|,
operator|&
name|blk
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
operator|&
name|blk
argument_list|,
name|zio_buf_alloc
argument_list|(
name|zio
operator|->
name|io_size
argument_list|)
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|zio_ddt_child_read_done
argument_list|,
name|dde
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_DDT_CHILD_FLAGS
argument_list|(
name|zio
argument_list|)
operator||
name|ZIO_FLAG_DONT_PROPAGATE
argument_list|,
operator|&
name|zio
operator|->
name|io_bookmark
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_DDT_CHILD_FLAGS
argument_list|(
name|zio
argument_list|)
argument_list|,
operator|&
name|zio
operator|->
name|io_bookmark
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_ddt_read_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_DDT
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
name|ASSERT
argument_list|(
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|==
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_child_error
index|[
name|ZIO_CHILD_DDT
index|]
condition|)
block|{
name|ddt_t
modifier|*
name|ddt
init|=
name|ddt_select
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
if|if
condition|(
name|ddt
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_load_state
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
operator|!=
name|SPA_LOAD_NONE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
if|if
condition|(
name|dde
operator|==
name|NULL
condition|)
block|{
name|zio
operator|->
name|io_stage
operator|=
name|ZIO_STAGE_DDT_READ_START
operator|>>
literal|1
expr_stmt|;
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
if|if
condition|(
name|dde
operator|->
name|dde_repair_data
operator|!=
name|NULL
condition|)
block|{
name|bcopy
argument_list|(
name|dde
operator|->
name|dde_repair_data
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_child_error
index|[
name|ZIO_CHILD_DDT
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ddt_repair_done
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_vsd
operator|=
name|NULL
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_vsd
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|zio_ddt_collision
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|ddt_t
modifier|*
name|ddt
parameter_list|,
name|ddt_entry_t
modifier|*
name|dde
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
comment|/* 	 * Note: we compare the original data, not the transformed data, 	 * because when zio->io_bp is an override bp, we will not have 	 * pushed the I/O transforms.  That's an important optimization 	 * because otherwise we'd compress/encrypt all dmu_sync() data twice. 	 */
for|for
control|(
name|int
name|p
init|=
name|DDT_PHYS_SINGLE
init|;
name|p
operator|<=
name|DDT_PHYS_TRIPLE
condition|;
name|p
operator|++
control|)
block|{
name|zio_t
modifier|*
name|lio
init|=
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
decl_stmt|;
if|if
condition|(
name|lio
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
name|lio
operator|->
name|io_orig_size
operator|!=
name|zio
operator|->
name|io_orig_size
operator|||
name|bcmp
argument_list|(
name|zio
operator|->
name|io_orig_data
argument_list|,
name|lio
operator|->
name|io_orig_data
argument_list|,
name|zio
operator|->
name|io_orig_size
argument_list|)
operator|!=
literal|0
operator|)
return|;
block|}
block|}
for|for
control|(
name|int
name|p
init|=
name|DDT_PHYS_SINGLE
init|;
name|p
operator|<=
name|DDT_PHYS_TRIPLE
condition|;
name|p
operator|++
control|)
block|{
name|ddt_phys_t
modifier|*
name|ddp
init|=
operator|&
name|dde
operator|->
name|dde_phys
index|[
name|p
index|]
decl_stmt|;
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|!=
literal|0
condition|)
block|{
name|arc_buf_t
modifier|*
name|abuf
init|=
name|NULL
decl_stmt|;
name|arc_flags_t
name|aflags
init|=
name|ARC_FLAG_WAIT
decl_stmt|;
name|blkptr_t
name|blk
init|=
operator|*
name|zio
operator|->
name|io_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ddt_bp_fill
argument_list|(
name|ddp
argument_list|,
operator|&
name|blk
argument_list|,
name|ddp
operator|->
name|ddp_phys_birth
argument_list|)
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|error
operator|=
name|arc_read
argument_list|(
name|NULL
argument_list|,
name|spa
argument_list|,
operator|&
name|blk
argument_list|,
name|arc_getbuf_func
argument_list|,
operator|&
name|abuf
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
argument_list|,
operator|&
name|aflags
argument_list|,
operator|&
name|zio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|arc_buf_size
argument_list|(
name|abuf
argument_list|)
operator|!=
name|zio
operator|->
name|io_orig_size
operator|||
name|bcmp
argument_list|(
name|abuf
operator|->
name|b_data
argument_list|,
name|zio
operator|->
name|io_orig_data
argument_list|,
name|zio
operator|->
name|io_orig_size
argument_list|)
operator|!=
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|arc_buf_remove_ref
argument_list|(
name|abuf
argument_list|,
operator|&
name|abuf
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|!=
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_ddt_child_write_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|p
init|=
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
decl_stmt|;
name|ddt_t
modifier|*
name|ddt
init|=
name|ddt_select
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|)
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
init|=
operator|&
name|dde
operator|->
name|dde_phys
index|[
name|p
index|]
decl_stmt|;
name|zio_t
modifier|*
name|pio
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
return|return;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|==
name|zio
argument_list|)
expr_stmt|;
name|ddt_phys_fill
argument_list|(
name|ddp
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|ddt_bp_fill
argument_list|(
name|ddp
argument_list|,
name|pio
operator|->
name|io_bp
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|)
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_ddt_child_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|p
init|=
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
decl_stmt|;
name|ddt_t
modifier|*
name|ddt
init|=
name|ddt_select
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|)
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
init|=
operator|&
name|dde
operator|->
name|dde_phys
index|[
name|p
index|]
decl_stmt|;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ddp
operator|->
name|ddp_refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|==
name|zio
argument_list|)
expr_stmt|;
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
operator|!=
name|NULL
condition|)
name|ddt_phys_addref
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ddt_phys_clear
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
block|}
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zio_ddt_ditto_write_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|p
init|=
name|DDT_PHYS_DITTO
decl_stmt|;
name|zio_prop_t
modifier|*
name|zp
init|=
operator|&
name|zio
operator|->
name|io_prop
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ddt_t
modifier|*
name|ddt
init|=
name|ddt_select
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
init|=
operator|&
name|dde
operator|->
name|dde_phys
index|[
name|p
index|]
decl_stmt|;
name|ddt_key_t
modifier|*
name|ddk
init|=
operator|&
name|dde
operator|->
name|dde_key
decl_stmt|;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ddp
operator|->
name|ddp_refcnt
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|==
name|zio
argument_list|)
expr_stmt|;
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|bp
operator|->
name|blk_cksum
argument_list|,
name|ddk
operator|->
name|ddk_cksum
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_copies
operator|<
name|SPA_DVAS_PER_BP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zp
operator|->
name|zp_copies
operator|==
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
operator|-
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|!=
literal|0
condition|)
name|ddt_phys_free
argument_list|(
name|ddt
argument_list|,
name|ddk
argument_list|,
name|ddp
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|)
expr_stmt|;
name|ddt_phys_fill
argument_list|(
name|ddp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_ddt_write
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|uint64_t
name|txg
init|=
name|zio
operator|->
name|io_txg
decl_stmt|;
name|zio_prop_t
modifier|*
name|zp
init|=
operator|&
name|zio
operator|->
name|io_prop
decl_stmt|;
name|int
name|p
init|=
name|zp
operator|->
name|zp_copies
decl_stmt|;
name|int
name|ditto_copies
decl_stmt|;
name|zio_t
modifier|*
name|cio
init|=
name|NULL
decl_stmt|;
name|zio_t
modifier|*
name|dio
init|=
name|NULL
decl_stmt|;
name|ddt_t
modifier|*
name|ddt
init|=
name|ddt_select
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|==
name|zp
operator|->
name|zp_checksum
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
name|zio
operator|->
name|io_bp_override
argument_list|)
expr_stmt|;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|dde
operator|=
name|ddt_lookup
argument_list|(
name|ddt
argument_list|,
name|bp
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|ddp
operator|=
operator|&
name|dde
operator|->
name|dde_phys
index|[
name|p
index|]
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|zp_dedup_verify
operator|&&
name|zio_ddt_collision
argument_list|(
name|zio
argument_list|,
name|ddt
argument_list|,
name|dde
argument_list|)
condition|)
block|{
comment|/* 		 * If we're using a weak checksum, upgrade to a strong checksum 		 * and try again.  If we're already using a strong checksum, 		 * we can't resolve it, so just convert to an ordinary write. 		 * (And automatically e-mail a paper to Nature?) 		 */
if|if
condition|(
operator|!
operator|(
name|zio_checksum_table
index|[
name|zp
operator|->
name|zp_checksum
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_DEDUP
operator|)
condition|)
block|{
name|zp
operator|->
name|zp_checksum
operator|=
name|spa_dedup_checksum
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|zio_pop_transforms
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|=
name|ZIO_STAGE_OPEN
expr_stmt|;
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zp
operator|->
name|zp_dedup
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_WRITE_PIPELINE
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
name|ditto_copies
operator|=
name|ddt_ditto_copies_needed
argument_list|(
name|ddt
argument_list|,
name|dde
argument_list|,
name|ddp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ditto_copies
operator|<
name|SPA_DVAS_PER_BP
argument_list|)
expr_stmt|;
if|if
condition|(
name|ditto_copies
operator|>
name|ddt_ditto_copies_present
argument_list|(
name|dde
argument_list|)
operator|&&
name|dde
operator|->
name|dde_lead_zio
index|[
name|DDT_PHYS_DITTO
index|]
operator|==
name|NULL
condition|)
block|{
name|zio_prop_t
name|czp
init|=
operator|*
name|zp
decl_stmt|;
name|czp
operator|.
name|zp_copies
operator|=
name|ditto_copies
expr_stmt|;
comment|/* 		 * If we arrived here with an override bp, we won't have run 		 * the transform stack, so we won't have the data we need to 		 * generate a child i/o.  So, toss the override bp and restart. 		 * This is safe, because using the override bp is just an 		 * optimization; and it's rare, so the cost doesn't matter. 		 */
if|if
condition|(
name|zio
operator|->
name|io_bp_override
condition|)
block|{
name|zio_pop_transforms
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|=
name|ZIO_STAGE_OPEN
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_WRITE_PIPELINE
expr_stmt|;
name|zio
operator|->
name|io_bp_override
operator|=
name|NULL
expr_stmt|;
name|BP_ZERO
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
name|dio
operator|=
name|zio_write
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|zio
operator|->
name|io_orig_data
argument_list|,
name|zio
operator|->
name|io_orig_size
argument_list|,
operator|&
name|czp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|zio_ddt_ditto_write_done
argument_list|,
name|dde
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_DDT_CHILD_FLAGS
argument_list|(
name|zio
argument_list|)
argument_list|,
operator|&
name|zio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
name|zio_push_transform
argument_list|(
name|dio
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dde
operator|->
name|dde_lead_zio
index|[
name|DDT_PHYS_DITTO
index|]
operator|=
name|dio
expr_stmt|;
block|}
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|!=
literal|0
operator|||
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ddp
operator|->
name|ddp_phys_birth
operator|!=
literal|0
condition|)
name|ddt_bp_fill
argument_list|(
name|ddp
argument_list|,
name|bp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|!=
name|NULL
condition|)
name|zio_add_child
argument_list|(
name|zio
argument_list|,
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
argument_list|)
expr_stmt|;
else|else
name|ddt_phys_addref
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_bp_override
condition|)
block|{
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|==
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_EQUAL
argument_list|(
name|bp
argument_list|,
name|zio
operator|->
name|io_bp_override
argument_list|)
argument_list|)
expr_stmt|;
name|ddt_phys_fill
argument_list|(
name|ddp
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ddt_phys_addref
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cio
operator|=
name|zio_write
argument_list|(
name|zio
argument_list|,
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|,
name|zio
operator|->
name|io_orig_data
argument_list|,
name|zio
operator|->
name|io_orig_size
argument_list|,
name|zp
argument_list|,
name|zio_ddt_child_write_ready
argument_list|,
name|NULL
argument_list|,
name|zio_ddt_child_write_done
argument_list|,
name|dde
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_DDT_CHILD_FLAGS
argument_list|(
name|zio
argument_list|)
argument_list|,
operator|&
name|zio
operator|->
name|io_bookmark
argument_list|)
expr_stmt|;
name|zio_push_transform
argument_list|(
name|cio
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dde
operator|->
name|dde_lead_zio
index|[
name|p
index|]
operator|=
name|cio
expr_stmt|;
block|}
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
if|if
condition|(
name|cio
condition|)
name|zio_nowait
argument_list|(
name|cio
argument_list|)
expr_stmt|;
if|if
condition|(
name|dio
condition|)
name|zio_nowait
argument_list|(
name|dio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|ddt_entry_t
modifier|*
name|freedde
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for debugging */
end_comment

begin_function
specifier|static
name|int
name|zio_ddt_free
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|ddt_t
modifier|*
name|ddt
init|=
name|ddt_select
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|)
decl_stmt|;
name|ddt_entry_t
modifier|*
name|dde
decl_stmt|;
name|ddt_phys_t
modifier|*
name|ddp
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|ddt_enter
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
name|freedde
operator|=
name|dde
operator|=
name|ddt_lookup
argument_list|(
name|ddt
argument_list|,
name|bp
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|ddp
operator|=
name|ddt_phys_select
argument_list|(
name|dde
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ddt_phys_decref
argument_list|(
name|ddp
argument_list|)
expr_stmt|;
name|ddt_exit
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Allocate and free blocks  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_dva_allocate
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|metaslab_class_t
modifier|*
name|mc
init|=
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_gang_leader
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|>
name|ZIO_CHILD_GANG
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_gang_leader
operator|=
name|zio
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|,
operator|<=
argument_list|,
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
operator|==
argument_list|,
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The dump device does not support gang blocks so allocation on 	 * behalf of the dump device (i.e. ZIO_FLAG_NODATA) must avoid 	 * the "fast" gang feature. 	 */
name|flags
operator||=
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
operator|)
condition|?
name|METASLAB_GANG_AVOID
else|:
literal|0
expr_stmt|;
name|flags
operator||=
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_GANG_CHILD
operator|)
condition|?
name|METASLAB_GANG_CHILD
else|:
literal|0
expr_stmt|;
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|mc
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|bp
argument_list|,
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
name|NULL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|spa_dbgmsg
argument_list|(
name|spa
argument_list|,
literal|"%s: metaslab allocation failure: zio %p, "
literal|"size %llu, error %d"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|zio
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOSPC
operator|&&
name|zio
operator|->
name|io_size
operator|>
name|SPA_MINBLOCKSIZE
condition|)
return|return
operator|(
name|zio_write_gang_block
argument_list|(
name|zio
argument_list|)
operator|)
return|;
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_dva_free
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|metaslab_free
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_dva_claim
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|metaslab_claim
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_bp
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Undo an allocation.  This is used by zio_done() when an I/O fails  * and we want to give back the block we just allocated.  * This handles both normal blocks and gang blocks.  */
end_comment

begin_function
specifier|static
name|void
name|zio_dva_unallocate
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|zio_gang_node_t
modifier|*
name|gn
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_bp_override
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
condition|)
name|metaslab_free
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|bp
argument_list|,
name|bp
operator|->
name|blk_birth
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|gn
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|g
init|=
literal|0
init|;
name|g
operator|<
name|SPA_GBH_NBLKPTRS
condition|;
name|g
operator|++
control|)
block|{
name|zio_dva_unallocate
argument_list|(
name|zio
argument_list|,
name|gn
operator|->
name|gn_child
index|[
name|g
index|]
argument_list|,
operator|&
name|gn
operator|->
name|gn_gbh
operator|->
name|zg_blkptr
index|[
name|g
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Try to allocate an intent log block.  Return 0 on success, errno on failure.  */
end_comment

begin_function
name|int
name|zio_alloc_zil
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|new_bp
parameter_list|,
name|blkptr_t
modifier|*
name|old_bp
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|boolean_t
name|use_slog
parameter_list|)
block|{
name|int
name|error
init|=
literal|1
decl_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|>
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * ZIL blocks are always contiguous (i.e. not gang blocks) so we 	 * set the METASLAB_GANG_AVOID flag so that they don't "fast gang" 	 * when allocating them. 	 */
if|if
condition|(
name|use_slog
condition|)
block|{
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|spa_log_class
argument_list|(
name|spa
argument_list|)
argument_list|,
name|size
argument_list|,
name|new_bp
argument_list|,
literal|1
argument_list|,
name|txg
argument_list|,
name|old_bp
argument_list|,
name|METASLAB_HINTBP_AVOID
operator||
name|METASLAB_GANG_AVOID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|error
operator|=
name|metaslab_alloc
argument_list|(
name|spa
argument_list|,
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|,
name|size
argument_list|,
name|new_bp
argument_list|,
literal|1
argument_list|,
name|txg
argument_list|,
name|old_bp
argument_list|,
name|METASLAB_HINTBP_AVOID
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|BP_SET_LSIZE
argument_list|(
name|new_bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|BP_SET_PSIZE
argument_list|(
name|new_bp
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|BP_SET_COMPRESS
argument_list|(
name|new_bp
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
expr_stmt|;
name|BP_SET_CHECKSUM
argument_list|(
name|new_bp
argument_list|,
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_SLIM_ZIL
condition|?
name|ZIO_CHECKSUM_ZILOG2
else|:
name|ZIO_CHECKSUM_ZILOG
argument_list|)
expr_stmt|;
name|BP_SET_TYPE
argument_list|(
name|new_bp
argument_list|,
name|DMU_OT_INTENT_LOG
argument_list|)
expr_stmt|;
name|BP_SET_LEVEL
argument_list|(
name|new_bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BP_SET_DEDUP
argument_list|(
name|new_bp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|BP_SET_BYTEORDER
argument_list|(
name|new_bp
argument_list|,
name|ZFS_HOST_BYTEORDER
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free an intent log block.  */
end_comment

begin_function
name|void
name|zio_free_zil
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
operator|==
name|DMU_OT_INTENT_LOG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|zio_free
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Read and write to physical devices  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Issue an I/O to the underlying vdev. Typically the issue pipeline  * stops after this stage and will resume upon I/O completion.  * However, there are instances where the vdev layer may need to  * continue the pipeline when an I/O was not issued. Since the I/O  * that was sent to the vdev layer might be different than the one  * currently active in the pipeline (see vdev_queue_io()), we explicitly  * force the underlying vdev layers to call either zio_execute() or  * zio_interrupt() to ensure that the pipeline continues with the correct I/O.  */
end_comment

begin_function
specifier|static
name|int
name|zio_vdev_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|uint64_t
name|align
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_error
index|[
name|ZIO_CHILD_VDEV
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
operator|)
condition|)
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ZIO
argument_list|,
name|zio
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
comment|/* 		 * The mirror_ops handle multiple DVAs in a single BP. 		 */
name|vdev_mirror_ops
operator|.
name|vdev_op_io_start
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
comment|/* 	 * We keep track of time-sensitive I/Os so that the scan thread 	 * can quickly react to certain workloads.  In particular, we care 	 * about non-scrubbing, top-level reads and writes with the following 	 * characteristics: 	 *	- synchronous writes of user data to non-slog devices 	 *	- any reads of user data 	 * When these conditions are met, adjust the timestamp of spa_last_io 	 * which allows the scan thread to adjust its workload accordingly. 	 */
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCAN_THREAD
operator|)
operator|&&
name|zio
operator|->
name|io_bp
operator|!=
name|NULL
operator|&&
name|vd
operator|==
name|vd
operator|->
name|vdev_top
operator|&&
operator|!
name|vd
operator|->
name|vdev_islog
operator|&&
name|zio
operator|->
name|io_bookmark
operator|.
name|zb_objset
operator|!=
name|DMU_META_OBJSET
operator|&&
name|zio
operator|->
name|io_txg
operator|!=
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|uint64_t
name|old
init|=
name|spa
operator|->
name|spa_last_io
decl_stmt|;
name|uint64_t
name|new
init|=
name|ddi_get_lbolt64
argument_list|()
decl_stmt|;
if|if
condition|(
name|old
operator|!=
name|new
condition|)
operator|(
name|void
operator|)
name|atomic_cas_64
argument_list|(
operator|&
name|spa
operator|->
name|spa_last_io
argument_list|,
name|old
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
name|align
operator|=
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_PHYSICAL
operator|)
operator|&&
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
name|align
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* Transform logical writes to be a full physical block size. */
name|uint64_t
name|asize
init|=
name|P2ROUNDUP
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
name|align
argument_list|)
decl_stmt|;
name|char
modifier|*
name|abuf
init|=
name|zio_buf_alloc
argument_list|(
name|asize
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|abuf
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|abuf
operator|+
name|zio
operator|->
name|io_size
argument_list|,
name|asize
operator|-
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
name|zio_push_transform
argument_list|(
name|zio
argument_list|,
name|abuf
argument_list|,
name|asize
argument_list|,
name|asize
argument_list|,
name|zio_subblock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If this is not a physical io, make sure that it is properly aligned 	 * before proceeding. 	 */
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_PHYSICAL
operator|)
condition|)
block|{
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_offset
argument_list|,
name|align
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
name|align
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * For physical writes, we allow 512b aligned writes and assume 		 * the device will perform a read-modify-write as necessary. 		 */
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_offset
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|P2PHASE
argument_list|(
name|zio
operator|->
name|io_size
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|zio
operator|->
name|io_type
operator|!=
name|ZIO_TYPE_WRITE
operator|||
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If this is a repair I/O, and there's no self-healing involved -- 	 * that is, we're just resilvering what we expect to resilver -- 	 * then don't do the I/O unless zio's txg is actually in vd's DTL. 	 * This prevents spurious resilvering with nested replication. 	 * For example, given a mirror of mirrors, (A+B)+(C+D), if only 	 * A is out of date, we'll read from C+D, then use the data to 	 * resilver A+B -- but we don't actually want to resilver B, just A. 	 * The top-level mirror has no way to know this, so instead we just 	 * discard unnecessary repairs as we work our way down the vdev tree. 	 * The same logic applies to any form of nested replication: 	 * ditto + mirror, RAID-Z + replacing, etc.  This covers them all. 	 */
if|if
condition|(
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REPAIR
operator|)
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SELF_HEAL
operator|)
operator|&&
name|zio
operator|->
name|io_txg
operator|!=
literal|0
operator|&&
comment|/* not a delegated i/o */
operator|!
name|vdev_dtl_contains
argument_list|(
name|vd
argument_list|,
name|DTL_PARTIAL
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|)
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|&&
name|vdev_cache_read
argument_list|(
name|zio
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
if|if
condition|(
operator|(
name|zio
operator|=
name|vdev_queue_io
argument_list|(
name|zio
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
name|zio_interrupt
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
block|}
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_io_start
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_vdev_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_ops_t
modifier|*
name|ops
init|=
name|vd
condition|?
name|vd
operator|->
name|vdev_ops
else|:
operator|&
name|vdev_mirror_ops
decl_stmt|;
name|boolean_t
name|unexpected_error
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_queue_io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
name|vdev_cache_write
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_handle_device_injection
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_handle_label_injection
argument_list|(
name|zio
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
block|{
if|if
condition|(
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unexpected_error
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
block|}
name|ops
operator|->
name|vdev_op_io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|unexpected_error
condition|)
name|VERIFY
argument_list|(
name|vdev_probe
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * For non-raidz ZIOs, we can just copy aside the bad data read from the  * disk, and use that to finish the checksum ereport later.  */
end_comment

begin_function
specifier|static
name|void
name|zio_vsd_default_cksum_finish
parameter_list|(
name|zio_cksum_report_t
modifier|*
name|zcr
parameter_list|,
specifier|const
name|void
modifier|*
name|good_buf
parameter_list|)
block|{
comment|/* no processing needed */
name|zfs_ereport_finish_checksum
argument_list|(
name|zcr
argument_list|,
name|good_buf
argument_list|,
name|zcr
operator|->
name|zcr_cbdata
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zio_vsd_default_cksum_report
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|zio_cksum_report_t
modifier|*
name|zcr
parameter_list|,
name|void
modifier|*
name|ignored
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|zio_buf_alloc
argument_list|(
name|zio
operator|->
name|io_size
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|buf
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|zcr
operator|->
name|zcr_cbinfo
operator|=
name|zio
operator|->
name|io_size
expr_stmt|;
name|zcr
operator|->
name|zcr_cbdata
operator|=
name|buf
expr_stmt|;
name|zcr
operator|->
name|zcr_finish
operator|=
name|zio_vsd_default_cksum_finish
expr_stmt|;
name|zcr
operator|->
name|zcr_free
operator|=
name|zio_buf_free
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_vdev_io_assess
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
name|vd
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CONFIG_WRITER
operator|)
condition|)
name|spa_config_exit
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|SCL_ZIO
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_vsd
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|->
name|io_vsd_ops
operator|->
name|vsd_free
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_vsd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
name|zio
operator|->
name|io_error
operator|=
name|zio_handle_fault_injection
argument_list|(
name|zio
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O failed, determine whether we should attempt to retry it. 	 * 	 * On retry, we cut in line in the issue queue, since we don't want 	 * compression/checksumming/etc. work to prevent our (cheap) IO reissue. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
name|vd
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
operator|(
name|ZIO_FLAG_DONT_RETRY
operator||
name|ZIO_FLAG_IO_RETRY
operator|)
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_QUEUE
operator|)
argument_list|)
expr_stmt|;
comment|/* not a leaf */
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_BYPASS
operator|)
argument_list|)
expr_stmt|;
comment|/* not a leaf */
name|zio
operator|->
name|io_error
operator|=
literal|0
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_IO_RETRY
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_AGGREGATE
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|=
name|ZIO_STAGE_VDEV_IO_START
operator|>>
literal|1
expr_stmt|;
name|zio_taskq_dispatch
argument_list|(
name|zio
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|,
name|zio_requeue_io_start_cut_in_line
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
comment|/* 	 * If we got an error on a leaf device, convert it to ENXIO 	 * if the device is not accessible at all. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
name|vd
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
operator|!
name|vdev_accessible
argument_list|(
name|vd
argument_list|,
name|zio
argument_list|)
condition|)
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
comment|/* 	 * If we can't write to an interior vdev (mirror or RAID-Z), 	 * set vdev_cant_write so that we stop trying to allocate from it. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
name|ENXIO
operator|&&
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|vd
operator|!=
name|NULL
operator|&&
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vd
operator|->
name|vdev_cant_write
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|zio
operator|->
name|io_physdone
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DELEGATED
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_VDEV
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_physdone
argument_list|(
name|zio
operator|->
name|io_logical
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zio_vdev_io_reissue
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_VDEV_IO_START
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|>>=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_vdev_io_redone
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_VDEV_IO_DONE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|>>=
literal|1
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zio_vdev_io_bypass
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_stage
operator|==
name|ZIO_STAGE_VDEV_IO_START
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_IO_BYPASS
expr_stmt|;
name|zio
operator|->
name|io_stage
operator|=
name|ZIO_STAGE_VDEV_IO_ASSESS
operator|>>
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Generate and verify checksums  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_checksum_generate
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|enum
name|zio_checksum
name|checksum
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is zio_write_phys(). 		 * We're either generating a label checksum, or none at all. 		 */
name|checksum
operator|=
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
expr_stmt|;
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_OFF
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
name|ASSERT
argument_list|(
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_GANG
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
name|checksum
operator|=
name|ZIO_CHECKSUM_GANG_HEADER
expr_stmt|;
block|}
else|else
block|{
name|checksum
operator|=
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
block|}
name|zio_checksum_compute
argument_list|(
name|zio
argument_list|,
name|checksum
argument_list|,
name|zio
operator|->
name|io_data
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_checksum_verify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_bad_cksum_t
name|info
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * This is zio_read_phys(). 		 * We're either verifying a label checksum, or nothing at all. 		 */
if|if
condition|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|==
name|ZIO_CHECKSUM_OFF
condition|)
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
operator|==
name|ZIO_CHECKSUM_LABEL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zio_checksum_error
argument_list|(
name|zio
argument_list|,
operator|&
name|info
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ECKSUM
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
block|{
name|zfs_ereport_start_checksum
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|zio
operator|->
name|io_vd
argument_list|,
name|zio
argument_list|,
name|zio
operator|->
name|io_offset
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|NULL
argument_list|,
operator|&
name|info
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by RAID-Z to ensure we don't compute the checksum twice.  */
end_comment

begin_function
name|void
name|zio_checksum_verified
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio
operator|->
name|io_pipeline
operator|&=
operator|~
name|ZIO_STAGE_CHECKSUM_VERIFY
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Error rank.  Error are ranked in the order 0, ENXIO, ECKSUM, EIO, other.  * An error of 0 indicates success.  ENXIO indicates whole-device failure,  * which may be transient (e.g. unplugged) or permament.  ECKSUM and EIO  * indicate errors that are specific to one I/O, and most likely permanent.  * Any other error is presumed to be worse because we weren't expecting it.  * ==========================================================================  */
end_comment

begin_function
name|int
name|zio_worst_error
parameter_list|(
name|int
name|e1
parameter_list|,
name|int
name|e2
parameter_list|)
block|{
specifier|static
name|int
name|zio_error_rank
index|[]
init|=
block|{
literal|0
block|,
name|ENXIO
block|,
name|ECKSUM
block|,
name|EIO
block|}
decl_stmt|;
name|int
name|r1
decl_stmt|,
name|r2
decl_stmt|;
for|for
control|(
name|r1
operator|=
literal|0
init|;
name|r1
operator|<
sizeof|sizeof
argument_list|(
name|zio_error_rank
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|r1
operator|++
control|)
if|if
condition|(
name|e1
operator|==
name|zio_error_rank
index|[
name|r1
index|]
condition|)
break|break;
for|for
control|(
name|r2
operator|=
literal|0
init|;
name|r2
operator|<
sizeof|sizeof
argument_list|(
name|zio_error_rank
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|r2
operator|++
control|)
if|if
condition|(
name|e2
operator|==
name|zio_error_rank
index|[
name|r2
index|]
condition|)
break|break;
return|return
operator|(
name|r1
operator|>
name|r2
condition|?
name|e1
else|:
name|e2
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O completion  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|zio_ready
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|zio_t
modifier|*
name|pio
decl_stmt|,
modifier|*
name|pio_next
decl_stmt|;
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_DDT
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
if|if
condition|(
name|zio
operator|->
name|io_ready
condition|)
block|{
name|ASSERT
argument_list|(
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|==
name|zio
operator|->
name|io_txg
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NOPWRITE
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_children
index|[
name|ZIO_CHILD_GANG
index|]
index|[
name|ZIO_WAIT_READY
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_ready
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|!=
name|NULL
operator|&&
name|bp
operator|!=
operator|&
name|zio
operator|->
name|io_bp_copy
condition|)
name|zio
operator|->
name|io_bp_copy
operator|=
operator|*
name|bp
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
name|zio
operator|->
name|io_pipeline
operator|=
name|ZIO_INTERLOCK_PIPELINE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_state
index|[
name|ZIO_WAIT_READY
index|]
operator|=
literal|1
expr_stmt|;
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 	 * As we notify zio's parents, new parents could be added. 	 * New parents go to the head of zio's io_parent_list, however, 	 * so we will (correctly) not notify them.  The remainder of zio's 	 * io_parent_list, from 'pio_next' onward, cannot change because 	 * all parents must wait for us to be done before they can be done. 	 */
for|for
control|(
init|;
name|pio
operator|!=
name|NULL
condition|;
name|pio
operator|=
name|pio_next
control|)
block|{
name|pio_next
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_notify_parent
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|ZIO_WAIT_READY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
condition|)
block|{
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|zio
operator|->
name|io_flags
operator|&=
operator|~
name|ZIO_FLAG_NODATA
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
operator|(
name|uintptr_t
operator|)
name|zio
operator|->
name|io_data
operator|<
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_pipeline
operator|&=
operator|~
name|ZIO_VDEV_IO_STAGES
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|zio
operator|->
name|io_spa
operator|->
name|spa_syncing_txg
operator|==
name|zio
operator|->
name|io_txg
condition|)
name|zio_handle_ignored_writes
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return
operator|(
name|ZIO_PIPELINE_CONTINUE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zio_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|zio_t
modifier|*
name|lio
init|=
name|zio
operator|->
name|io_logical
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|uint64_t
name|psize
init|=
name|zio
operator|->
name|io_size
decl_stmt|;
name|zio_t
modifier|*
name|pio
decl_stmt|,
modifier|*
name|pio_next
decl_stmt|;
comment|/* 	 * If our children haven't all completed, 	 * wait for them and then repeat this pipeline stage. 	 */
if|if
condition|(
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_DDT
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
operator|||
name|zio_wait_for_children
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_LOGICAL
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
condition|)
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|ZIO_CHILD_TYPES
condition|;
name|c
operator|++
control|)
for|for
control|(
name|int
name|w
init|=
literal|0
init|;
name|w
operator|<
name|ZIO_WAIT_TYPES
condition|;
name|w
operator|++
control|)
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_children
index|[
name|c
index|]
index|[
name|w
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
operator|&&
operator|!
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_pad
index|[
literal|0
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_pad
index|[
literal|1
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bcmp
argument_list|(
name|bp
argument_list|,
operator|&
name|zio
operator|->
name|io_bp_copy
argument_list|,
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|bp
operator|==
name|zio_unique_parent
argument_list|(
name|zio
argument_list|)
operator|->
name|io_bp
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|&&
name|zio
operator|->
name|io_bp_override
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_IO_REPAIR
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|BP_SHOULD_BYTESWAP
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_prop
operator|.
name|zp_copies
argument_list|,
operator|<=
argument_list|,
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_COUNT_GANG
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
operator|||
operator|(
name|BP_COUNT_GANG
argument_list|(
name|bp
argument_list|)
operator|==
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NOPWRITE
condition|)
name|VERIFY
argument_list|(
name|BP_EQUAL
argument_list|(
name|bp
argument_list|,
operator|&
name|zio
operator|->
name|io_bp_orig
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If there were child vdev/gang/ddt errors, they apply to us now. 	 */
name|zio_inherit_child_errors
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_VDEV
argument_list|)
expr_stmt|;
name|zio_inherit_child_errors
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_GANG
argument_list|)
expr_stmt|;
name|zio_inherit_child_errors
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_DDT
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O on the transformed data was successful, generate any 	 * checksum reports now while we still have the transformed data. 	 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|zio
operator|->
name|io_cksum_report
operator|!=
name|NULL
condition|)
block|{
name|zio_cksum_report_t
modifier|*
name|zcr
init|=
name|zio
operator|->
name|io_cksum_report
decl_stmt|;
name|uint64_t
name|align
init|=
name|zcr
operator|->
name|zcr_align
decl_stmt|;
name|uint64_t
name|asize
init|=
name|P2ROUNDUP
argument_list|(
name|psize
argument_list|,
name|align
argument_list|)
decl_stmt|;
name|char
modifier|*
name|abuf
init|=
name|zio
operator|->
name|io_data
decl_stmt|;
if|if
condition|(
name|asize
operator|!=
name|psize
condition|)
block|{
name|abuf
operator|=
name|zio_buf_alloc
argument_list|(
name|asize
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|zio
operator|->
name|io_data
argument_list|,
name|abuf
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|abuf
operator|+
name|psize
argument_list|,
name|asize
operator|-
name|psize
argument_list|)
expr_stmt|;
block|}
name|zio
operator|->
name|io_cksum_report
operator|=
name|zcr
operator|->
name|zcr_next
expr_stmt|;
name|zcr
operator|->
name|zcr_next
operator|=
name|NULL
expr_stmt|;
name|zcr
operator|->
name|zcr_finish
argument_list|(
name|zcr
argument_list|,
name|abuf
argument_list|)
expr_stmt|;
name|zfs_ereport_free_checksum
argument_list|(
name|zcr
argument_list|)
expr_stmt|;
if|if
condition|(
name|asize
operator|!=
name|psize
condition|)
name|zio_buf_free
argument_list|(
name|abuf
argument_list|,
name|asize
argument_list|)
expr_stmt|;
block|}
block|}
name|zio_pop_transforms
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* note: may set zio->io_error */
name|vdev_stat_update
argument_list|(
name|zio
argument_list|,
name|psize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
block|{
comment|/* 		 * If this I/O is attached to a particular vdev, 		 * generate an error message describing the I/O failure 		 * at the block level.  We ignore these errors if the 		 * device is currently unavailable. 		 */
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
name|ECKSUM
operator|&&
name|vd
operator|!=
name|NULL
operator|&&
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_IO
argument_list|,
name|spa
argument_list|,
name|vd
argument_list|,
name|zio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zio
operator|->
name|io_error
operator|==
name|EIO
operator|||
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
operator|(
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_DONT_PROPAGATE
operator|)
operator|)
operator|)
operator|&&
name|zio
operator|==
name|lio
condition|)
block|{
comment|/* 			 * For logical I/O requests, tell the SPA to log the 			 * error and generate a logical data ereport. 			 */
name|spa_log_error
argument_list|(
name|spa
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_DATA
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|zio
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|->
name|io_error
operator|&&
name|zio
operator|==
name|lio
condition|)
block|{
comment|/* 		 * Determine whether zio should be reexecuted.  This will 		 * propagate all the way to the root via zio_notify_parent(). 		 */
name|ASSERT
argument_list|(
name|vd
operator|==
name|NULL
operator|&&
name|bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CANFAIL
operator|)
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_error
operator|!=
name|ENOSPC
condition|)
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_NOW
expr_stmt|;
else|else
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_SUSPEND
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_FREE
operator|)
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SCAN_THREAD
operator|)
operator|&&
name|zio
operator|->
name|io_error
operator|==
name|ENXIO
operator|&&
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_NONE
operator|&&
name|spa_get_failmode
argument_list|(
name|spa
argument_list|)
operator|!=
name|ZIO_FAILURE_MODE_CONTINUE
condition|)
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_SUSPEND
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CANFAIL
operator|)
operator|&&
operator|!
name|zio
operator|->
name|io_reexecute
condition|)
name|zio
operator|->
name|io_reexecute
operator||=
name|ZIO_REEXECUTE_SUSPEND
expr_stmt|;
comment|/* 		 * Here is a possibly good place to attempt to do 		 * either combinatorial reconstruction or error correction 		 * based on checksums.  It also might be a good place 		 * to send out preliminary ereports before we suspend 		 * processing. 		 */
block|}
comment|/* 	 * If there were logical child errors, they apply to us now. 	 * We defer this until now to avoid conflating logical child 	 * errors with errors that happened to the zio itself when 	 * updating vdev stats and reporting FMA events above. 	 */
name|zio_inherit_child_errors
argument_list|(
name|zio
argument_list|,
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zio
operator|->
name|io_error
operator|||
name|zio
operator|->
name|io_reexecute
operator|)
operator|&&
name|IO_IS_ALLOCATING
argument_list|(
name|zio
argument_list|)
operator|&&
name|zio
operator|->
name|io_gang_leader
operator|==
name|zio
operator|&&
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
operator|(
name|ZIO_FLAG_IO_REWRITE
operator||
name|ZIO_FLAG_NOPWRITE
operator|)
operator|)
condition|)
name|zio_dva_unallocate
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_gang_tree
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|zio_gang_tree_free
argument_list|(
operator|&
name|zio
operator|->
name|io_gang_tree
argument_list|)
expr_stmt|;
comment|/* 	 * Godfather I/Os should never suspend. 	 */
if|if
condition|(
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_GODFATHER
operator|)
operator|&&
operator|(
name|zio
operator|->
name|io_reexecute
operator|&
name|ZIO_REEXECUTE_SUSPEND
operator|)
condition|)
name|zio
operator|->
name|io_reexecute
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_reexecute
condition|)
block|{
comment|/* 		 * This is a logical I/O that wants to reexecute. 		 * 		 * Reexecute is top-down.  When an i/o fails, if it's not 		 * the root, it simply notifies its parent and sticks around. 		 * The parent, seeing that it still has children in zio_done(), 		 * does the same.  This percolates all the way up to the root. 		 * The root i/o will reexecute or suspend the entire tree. 		 * 		 * This approach ensures that zio_reexecute() honors 		 * all the original i/o dependency relationships, e.g. 		 * parents not executing until children are ready. 		 */
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_type
operator|==
name|ZIO_CHILD_LOGICAL
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_gang_leader
operator|=
name|NULL
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_state
index|[
name|ZIO_WAIT_DONE
index|]
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
comment|/* 		 * "The Godfather" I/O monitors its children but is 		 * not a true parent to them. It will track them through 		 * the pipeline but severs its ties whenever they get into 		 * trouble (e.g. suspended). This allows "The Godfather" 		 * I/O to return status without blocking. 		 */
for|for
control|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
init|;
name|pio
operator|!=
name|NULL
condition|;
name|pio
operator|=
name|pio_next
control|)
block|{
name|zio_link_t
modifier|*
name|zl
init|=
name|zio
operator|->
name|io_walk_link
decl_stmt|;
name|pio_next
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_GODFATHER
operator|)
operator|&&
operator|(
name|zio
operator|->
name|io_reexecute
operator|&
name|ZIO_REEXECUTE_SUSPEND
operator|)
condition|)
block|{
name|zio_remove_child
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|zio_notify_parent
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|pio
operator|=
name|zio_unique_parent
argument_list|(
name|zio
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * We're not a root i/o, so there's nothing to do 			 * but notify our parent.  Don't propagate errors 			 * upward since we haven't permanently failed yet. 			 */
name|ASSERT
argument_list|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_GODFATHER
operator|)
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_PROPAGATE
expr_stmt|;
name|zio_notify_parent
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_reexecute
operator|&
name|ZIO_REEXECUTE_SUSPEND
condition|)
block|{
comment|/* 			 * We'd fail again if we reexecuted now, so suspend 			 * until conditions improve (e.g. device comes online). 			 */
name|zio_suspend
argument_list|(
name|spa
argument_list|,
name|zio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Reexecution is potentially a huge amount of work. 			 * Hand it off to the otherwise-unused claim taskq. 			 */
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_tqent
operator|.
name|tqent_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|spa_taskq_dispatch_ent
argument_list|(
name|spa
argument_list|,
name|ZIO_TYPE_CLAIM
argument_list|,
name|ZIO_TASKQ_ISSUE
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|zio_reexecute
argument_list|,
name|zio
argument_list|,
literal|0
argument_list|,
operator|&
name|zio
operator|->
name|io_tqent
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_child_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_reexecute
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_CANFAIL
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Report any checksum errors, since the I/O is complete. 	 */
while|while
condition|(
name|zio
operator|->
name|io_cksum_report
operator|!=
name|NULL
condition|)
block|{
name|zio_cksum_report_t
modifier|*
name|zcr
init|=
name|zio
operator|->
name|io_cksum_report
decl_stmt|;
name|zio
operator|->
name|io_cksum_report
operator|=
name|zcr
operator|->
name|zcr_next
expr_stmt|;
name|zcr
operator|->
name|zcr_next
operator|=
name|NULL
expr_stmt|;
name|zcr
operator|->
name|zcr_finish
argument_list|(
name|zcr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfs_ereport_free_checksum
argument_list|(
name|zcr
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * It is the responsibility of the done callback to ensure that this 	 * particular zio is no longer discoverable for adoption, and as 	 * such, cannot acquire any new parents. 	 */
if|if
condition|(
name|zio
operator|->
name|io_done
condition|)
name|zio
operator|->
name|io_done
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_state
index|[
name|ZIO_WAIT_DONE
index|]
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
init|;
name|pio
operator|!=
name|NULL
condition|;
name|pio
operator|=
name|pio_next
control|)
block|{
name|zio_link_t
modifier|*
name|zl
init|=
name|zio
operator|->
name|io_walk_link
decl_stmt|;
name|pio_next
operator|=
name|zio_walk_parents
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_remove_child
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|zl
argument_list|)
expr_stmt|;
name|zio_notify_parent
argument_list|(
name|pio
argument_list|,
name|zio
argument_list|,
name|ZIO_WAIT_DONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio
operator|->
name|io_waiter
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_executor
operator|=
name|NULL
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|zio
operator|->
name|io_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zio
operator|->
name|io_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio_destroy
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ZIO_PIPELINE_STOP
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * I/O pipeline definition  * ==========================================================================  */
end_comment

begin_decl_stmt
specifier|static
name|zio_pipe_stage_t
modifier|*
name|zio_pipeline
index|[]
init|=
block|{
name|NULL
block|,
name|zio_read_bp_init
block|,
name|zio_free_bp_init
block|,
name|zio_issue_async
block|,
name|zio_write_bp_init
block|,
name|zio_checksum_generate
block|,
name|zio_nop_write
block|,
name|zio_ddt_read_start
block|,
name|zio_ddt_read_done
block|,
name|zio_ddt_write
block|,
name|zio_ddt_free
block|,
name|zio_gang_assemble
block|,
name|zio_gang_issue
block|,
name|zio_dva_allocate
block|,
name|zio_dva_free
block|,
name|zio_dva_claim
block|,
name|zio_ready
block|,
name|zio_vdev_io_start
block|,
name|zio_vdev_io_done
block|,
name|zio_vdev_io_assess
block|,
name|zio_checksum_verify
block|,
name|zio_done
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compare two zbookmark_phys_t's to see which we would reach first in a  * pre-order traversal of the object tree.  *  * This is simple in every case aside from the meta-dnode object. For all other  * objects, we traverse them in order (object 1 before object 2, and so on).  * However, all of these objects are traversed while traversing object 0, since  * the data it points to is the list of objects.  Thus, we need to convert to a  * canonical representation so we can compare meta-dnode bookmarks to  * non-meta-dnode bookmarks.  *  * We do this by calculating "equivalents" for each field of the zbookmark.  * zbookmarks outside of the meta-dnode use their own object and level, and  * calculate the level 0 equivalent (the first L0 blkid that is contained in the  * blocks this bookmark refers to) by multiplying their blkid by their span  * (the number of L0 blocks contained within one block at their level).  * zbookmarks inside the meta-dnode calculate their object equivalent  * (which is L0equiv * dnodes per data block), use 0 for their L0equiv, and use  * level + 1<<31 (any value larger than a level could ever be) for their level.  * This causes them to always compare before a bookmark in their object  * equivalent, compare appropriately to bookmarks in other objects, and to  * compare appropriately to other bookmarks in the meta-dnode.  */
end_comment

begin_function
name|int
name|zbookmark_compare
parameter_list|(
name|uint16_t
name|dbss1
parameter_list|,
name|uint8_t
name|ibs1
parameter_list|,
name|uint16_t
name|dbss2
parameter_list|,
name|uint8_t
name|ibs2
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb1
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb2
parameter_list|)
block|{
comment|/* 	 * These variables represent the "equivalent" values for the zbookmark, 	 * after converting zbookmarks inside the meta dnode to their 	 * normal-object equivalents. 	 */
name|uint64_t
name|zb1obj
decl_stmt|,
name|zb2obj
decl_stmt|;
name|uint64_t
name|zb1L0
decl_stmt|,
name|zb2L0
decl_stmt|;
name|uint64_t
name|zb1level
decl_stmt|,
name|zb2level
decl_stmt|;
if|if
condition|(
name|zb1
operator|->
name|zb_object
operator|==
name|zb2
operator|->
name|zb_object
operator|&&
name|zb1
operator|->
name|zb_level
operator|==
name|zb2
operator|->
name|zb_level
operator|&&
name|zb1
operator|->
name|zb_blkid
operator|==
name|zb2
operator|->
name|zb_blkid
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * BP_SPANB calculates the span in blocks. 	 */
name|zb1L0
operator|=
operator|(
name|zb1
operator|->
name|zb_blkid
operator|)
operator|*
name|BP_SPANB
argument_list|(
name|ibs1
argument_list|,
name|zb1
operator|->
name|zb_level
argument_list|)
expr_stmt|;
name|zb2L0
operator|=
operator|(
name|zb2
operator|->
name|zb_blkid
operator|)
operator|*
name|BP_SPANB
argument_list|(
name|ibs2
argument_list|,
name|zb2
operator|->
name|zb_level
argument_list|)
expr_stmt|;
if|if
condition|(
name|zb1
operator|->
name|zb_object
operator|==
name|DMU_META_DNODE_OBJECT
condition|)
block|{
name|zb1obj
operator|=
name|zb1L0
operator|*
operator|(
name|dbss1
operator|<<
operator|(
name|SPA_MINBLOCKSHIFT
operator|-
name|DNODE_SHIFT
operator|)
operator|)
expr_stmt|;
name|zb1L0
operator|=
literal|0
expr_stmt|;
name|zb1level
operator|=
name|zb1
operator|->
name|zb_level
operator|+
name|COMPARE_META_LEVEL
expr_stmt|;
block|}
else|else
block|{
name|zb1obj
operator|=
name|zb1
operator|->
name|zb_object
expr_stmt|;
name|zb1level
operator|=
name|zb1
operator|->
name|zb_level
expr_stmt|;
block|}
if|if
condition|(
name|zb2
operator|->
name|zb_object
operator|==
name|DMU_META_DNODE_OBJECT
condition|)
block|{
name|zb2obj
operator|=
name|zb2L0
operator|*
operator|(
name|dbss2
operator|<<
operator|(
name|SPA_MINBLOCKSHIFT
operator|-
name|DNODE_SHIFT
operator|)
operator|)
expr_stmt|;
name|zb2L0
operator|=
literal|0
expr_stmt|;
name|zb2level
operator|=
name|zb2
operator|->
name|zb_level
operator|+
name|COMPARE_META_LEVEL
expr_stmt|;
block|}
else|else
block|{
name|zb2obj
operator|=
name|zb2
operator|->
name|zb_object
expr_stmt|;
name|zb2level
operator|=
name|zb2
operator|->
name|zb_level
expr_stmt|;
block|}
comment|/* Now that we have a canonical representation, do the comparison. */
if|if
condition|(
name|zb1obj
operator|!=
name|zb2obj
condition|)
return|return
operator|(
name|zb1obj
operator|<
name|zb2obj
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|zb1L0
operator|!=
name|zb2L0
condition|)
return|return
operator|(
name|zb1L0
operator|<
name|zb2L0
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|zb1level
operator|!=
name|zb2level
condition|)
return|return
operator|(
name|zb1level
operator|>
name|zb2level
condition|?
operator|-
literal|1
else|:
literal|1
operator|)
return|;
comment|/* 	 * This can (theoretically) happen if the bookmarks have the same object 	 * and level, but different blkids, if the block sizes are not the same. 	 * There is presently no way to change the indirect block sizes 	 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  This function checks the following: given that last_block is the place that  *  our traversal stopped last time, does that guarantee that we've visited  *  every node under subtree_root?  Therefore, we can't just use the raw output  *  of zbookmark_compare.  We have to pass in a modified version of  *  subtree_root; by incrementing the block id, and then checking whether  *  last_block is before or equal to that, we can tell whether or not having  *  visited last_block implies that all of subtree_root's children have been  *  visited.  */
end_comment

begin_function
name|boolean_t
name|zbookmark_subtree_completed
parameter_list|(
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|subtree_root
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|last_block
parameter_list|)
block|{
name|zbookmark_phys_t
name|mod_zb
init|=
operator|*
name|subtree_root
decl_stmt|;
name|mod_zb
operator|.
name|zb_blkid
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|last_block
operator|->
name|zb_level
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* The objset_phys_t isn't before anything. */
if|if
condition|(
name|dnp
operator|==
name|NULL
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
comment|/* 	 * We pass in 1ULL<< (DNODE_BLOCK_SHIFT - SPA_MINBLOCKSHIFT) for the 	 * data block size in sectors, because that variable is only used if 	 * the bookmark refers to a block in the meta-dnode.  Since we don't 	 * know without examining it what object it refers to, and there's no 	 * harm in passing in this value in other cases, we always pass it in. 	 * 	 * We pass in 0 for the indirect block size shift because zb2 must be 	 * level 0.  The indirect block size is only used to calculate the span 	 * of the bookmark, but since the bookmark must be level 0, the span is 	 * always 1, so the math works out. 	 * 	 * If you make changes to how the zbookmark_compare code works, be sure 	 * to make sure that this code still works afterwards. 	 */
return|return
operator|(
name|zbookmark_compare
argument_list|(
name|dnp
operator|->
name|dn_datablkszsec
argument_list|,
name|dnp
operator|->
name|dn_indblkshift
argument_list|,
literal|1ULL
operator|<<
operator|(
name|DNODE_BLOCK_SHIFT
operator|-
name|SPA_MINBLOCKSHIFT
operator|)
argument_list|,
literal|0
argument_list|,
operator|&
name|mod_zb
argument_list|,
name|last_block
argument_list|)
operator|<=
literal|0
operator|)
return|;
block|}
end_function

end_unit

