begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2016 Nexenta Systems, Inc. All rights reserved.  */
end_comment

begin_comment
comment|/* Portions Copyright 2010 Robert Milkowski */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/pathname.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs_opreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/mntent.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|"fs/fs_subr.h"
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deleg.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/varargs.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/refstr.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/bootconf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_boot.h>
end_include

begin_include
include|#
directive|include
file|"zfs_comutil.h"
end_include

begin_decl_stmt
name|int
name|zfsfstype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vfsops_t
modifier|*
name|zfs_vfsops
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|major_t
name|zfs_major
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|minor_t
name|zfs_minor
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|zfs_dev_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|sys_shutdown
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|int
name|zfs_mount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnode_t
modifier|*
name|mvp
parameter_list|,
name|struct
name|mounta
modifier|*
name|uap
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_umount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|fflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_mountroot
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|enum
name|whymountroot
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_root
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_statvfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|statvfs64
modifier|*
name|statp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_vget
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|zfs_freevfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfs_vfsops_template
index|[]
init|=
block|{
name|VFSNAME_MOUNT
block|,
block|{
operator|.
name|vfs_mount
operator|=
name|zfs_mount
block|}
block|,
name|VFSNAME_MOUNTROOT
block|,
block|{
operator|.
name|vfs_mountroot
operator|=
name|zfs_mountroot
block|}
block|,
name|VFSNAME_UNMOUNT
block|,
block|{
operator|.
name|vfs_unmount
operator|=
name|zfs_umount
block|}
block|,
name|VFSNAME_ROOT
block|,
block|{
operator|.
name|vfs_root
operator|=
name|zfs_root
block|}
block|,
name|VFSNAME_STATVFS
block|,
block|{
operator|.
name|vfs_statvfs
operator|=
name|zfs_statvfs
block|}
block|,
name|VFSNAME_SYNC
block|,
block|{
operator|.
name|vfs_sync
operator|=
name|zfs_sync
block|}
block|,
name|VFSNAME_VGET
block|,
block|{
operator|.
name|vfs_vget
operator|=
name|zfs_vget
block|}
block|,
name|VFSNAME_FREEVFS
block|,
block|{
operator|.
name|vfs_freevfs
operator|=
name|zfs_freevfs
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * We need to keep a count of active fs's.  * This is necessary to prevent our module  * from being unloaded after a umount -f  */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|zfs_active_fs_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noatime_cancel
index|[]
init|=
block|{
name|MNTOPT_ATIME
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|atime_cancel
index|[]
init|=
block|{
name|MNTOPT_NOATIME
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|noxattr_cancel
index|[]
init|=
block|{
name|MNTOPT_XATTR
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|xattr_cancel
index|[]
init|=
block|{
name|MNTOPT_NOXATTR
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * MO_DEFAULT is not used since the default value is determined  * by the equivalent property.  */
end_comment

begin_decl_stmt
specifier|static
name|mntopt_t
name|mntopts
index|[]
init|=
block|{
block|{
name|MNTOPT_NOXATTR
block|,
name|noxattr_cancel
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
name|MNTOPT_XATTR
block|,
name|xattr_cancel
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
name|MNTOPT_NOATIME
block|,
name|noatime_cancel
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|,
block|{
name|MNTOPT_ATIME
block|,
name|atime_cancel
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|mntopts_t
name|zfs_mntopts
init|=
block|{
sizeof|sizeof
argument_list|(
name|mntopts
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mntopt_t
argument_list|)
block|,
name|mntopts
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|zfs_sync
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|short
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
comment|/* 	 * Data integrity is job one.  We don't want a compromised kernel 	 * writing to the storage pool, so we never sync during panic. 	 */
if|if
condition|(
name|panicstr
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * SYNC_ATTR is used by fsflush() to force old filesystems like UFS 	 * to sync metadata, which they would otherwise cache indefinitely. 	 * Semantically, the only requirement is that the sync be initiated. 	 * The DMU syncs out txgs frequently, so there's nothing to do. 	 */
if|if
condition|(
name|flag
operator|&
name|SYNC_ATTR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|vfsp
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Sync a specific filesystem. 		 */
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|dp
operator|=
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
comment|/* 		 * If the system is shutting down, then skip any 		 * filesystems which may exist on a suspended pool. 		 */
if|if
condition|(
name|sys_shutdown
operator|&&
name|spa_suspended
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_log
operator|!=
name|NULL
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Sync all ZFS filesystems.  This is what happens when you 		 * run sync(1M).  Unlike other filesystems, ZFS honors the 		 * request by waiting for all pools to commit all dirty data. 		 */
name|spa_sync_allpools
argument_list|()
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_create_unique_device
parameter_list|(
name|dev_t
modifier|*
name|dev
parameter_list|)
block|{
name|major_t
name|new_major
decl_stmt|;
do|do
block|{
name|ASSERT3U
argument_list|(
name|zfs_minor
argument_list|,
operator|<=
argument_list|,
name|MAXMIN32
argument_list|)
expr_stmt|;
name|minor_t
name|start
init|=
name|zfs_minor
decl_stmt|;
do|do
block|{
name|mutex_enter
argument_list|(
operator|&
name|zfs_dev_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_minor
operator|>=
name|MAXMIN32
condition|)
block|{
comment|/* 				 * If we're still using the real major 				 * keep out of /dev/zfs and /dev/zvol minor 				 * number space.  If we're using a getudev()'ed 				 * major number, we can use all of its minors. 				 */
if|if
condition|(
name|zfs_major
operator|==
name|ddi_name_to_major
argument_list|(
name|ZFS_DRIVER
argument_list|)
condition|)
name|zfs_minor
operator|=
name|ZFS_MIN_MINOR
expr_stmt|;
else|else
name|zfs_minor
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|zfs_minor
operator|++
expr_stmt|;
block|}
operator|*
name|dev
operator|=
name|makedevice
argument_list|(
name|zfs_major
argument_list|,
name|zfs_minor
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfs_dev_mtx
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|vfs_devismounted
argument_list|(
operator|*
name|dev
argument_list|)
operator|&&
name|zfs_minor
operator|!=
name|start
condition|)
do|;
if|if
condition|(
name|zfs_minor
operator|==
name|start
condition|)
block|{
comment|/* 			 * We are using all ~262,000 minor numbers for the 			 * current major number.  Create a new major number. 			 */
if|if
condition|(
operator|(
name|new_major
operator|=
name|getudev
argument_list|()
operator|)
operator|==
operator|(
name|major_t
operator|)
operator|-
literal|1
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"zfs_mount: Can't get unique major "
literal|"device number."
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zfs_dev_mtx
argument_list|)
expr_stmt|;
name|zfs_major
operator|=
name|new_major
expr_stmt|;
name|zfs_minor
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfs_dev_mtx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
comment|/* CONSTANTCONDITION */
block|}
do|while
condition|(
literal|1
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|atime_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|TRUE
condition|)
block|{
name|zfsvfs
operator|->
name|z_atime
operator|=
name|TRUE
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOATIME
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_ATIME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_atime
operator|=
name|FALSE
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_ATIME
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOATIME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|xattr_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|TRUE
condition|)
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_XATTR
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOXATTR
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_XATTR
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_XATTR
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|blksz_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|ASSERT3U
argument_list|(
name|newval
argument_list|,
operator|<=
argument_list|,
name|spa_maxblocksize
argument_list|(
name|dmu_objset_spa
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|newval
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ISP2
argument_list|(
name|newval
argument_list|)
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_max_blksz
operator|=
name|newval
expr_stmt|;
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_bsize
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|readonly_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
condition|)
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_RDONLY
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RW
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* XXX locking on vfs_flag? */
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_RDONLY
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RO
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|devices_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_NODEVICES
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_DEVICES
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NODEVICES
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_NODEVICES
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NODEVICES
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_DEVICES
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|setuid_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_NOSETUID
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_SETUID
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_NOSETUID
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOSETUID
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|exec_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|VFS_NOEXEC
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_EXEC
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_NOEXEC
expr_stmt|;
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NOEXEC
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The nbmand mount option can be changed at mount time.  * We can't allow it to be toggled on live file systems or incorrect  * behavior may be seen from cifs clients  *  * This property isn't registered via dsl_prop_register(), but this callback  * will be called when a file system is first mounted  */
end_comment

begin_function
specifier|static
name|void
name|nbmand_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|newval
operator|==
name|FALSE
condition|)
block|{
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NBMAND
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NONBMAND
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vfs_clearmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NONBMAND
argument_list|)
expr_stmt|;
name|vfs_setmntopt
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MNTOPT_NBMAND
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|snapdir_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_show_ctldir
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vscan_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_vscan
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acl_mode_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_acl_mode
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|acl_inherit_changed_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|uint64_t
name|newval
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|zfsvfs
operator|->
name|z_acl_inherit
operator|=
name|newval
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_register_callbacks
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|struct
name|dsl_dataset
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|NULL
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|nbmand
decl_stmt|;
name|boolean_t
name|readonly
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_readonly
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|setuid
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_setuid
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|exec
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_exec
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|devices
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_devices
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|xattr
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_xattr
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|atime
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|do_atime
init|=
name|B_FALSE
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|vfsp
operator|->
name|vfs_data
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
comment|/* 	 * The act of registering our callbacks will destroy any mount 	 * options we may have.  In order to enable temporary overrides 	 * of mount options, we stash away the current values and 	 * restore them after we register the callbacks. 	 */
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
block|{
name|readonly
operator|=
name|B_TRUE
expr_stmt|;
name|do_readonly
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RW
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|readonly
operator|=
name|B_FALSE
expr_stmt|;
name|do_readonly
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|devices
operator|=
name|B_FALSE
expr_stmt|;
name|setuid
operator|=
name|B_FALSE
expr_stmt|;
name|do_devices
operator|=
name|B_TRUE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NODEVICES
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|devices
operator|=
name|B_FALSE
expr_stmt|;
name|do_devices
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_DEVICES
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|devices
operator|=
name|B_TRUE
expr_stmt|;
name|do_devices
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOSETUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_FALSE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_SETUID
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|setuid
operator|=
name|B_TRUE
expr_stmt|;
name|do_setuid
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOEXEC
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exec
operator|=
name|B_FALSE
expr_stmt|;
name|do_exec
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_EXEC
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|exec
operator|=
name|B_TRUE
expr_stmt|;
name|do_exec
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOXATTR
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|xattr
operator|=
name|B_FALSE
expr_stmt|;
name|do_xattr
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_XATTR
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|xattr
operator|=
name|B_TRUE
expr_stmt|;
name|do_xattr
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NOATIME
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|atime
operator|=
name|B_FALSE
expr_stmt|;
name|do_atime
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_ATIME
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|atime
operator|=
name|B_TRUE
expr_stmt|;
name|do_atime
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * nbmand is a special property.  It can only be changed at 	 * mount time. 	 * 	 * This is weird, but it is documented to only be changeable 	 * at mount time. 	 */
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NONBMAND
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|nbmand
operator|=
name|B_FALSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vfs_optionisset
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_NBMAND
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|nbmand
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|char
name|osname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|osname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"nbmand"
argument_list|,
operator|&
name|nbmand
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Register property callbacks. 	 * 	 * It would probably be fine to just check for i/o error from 	 * the first prop_register(), but I guess I like to go 	 * overboard... 	 */
name|ds
operator|=
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_ATIME
argument_list|)
argument_list|,
name|atime_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_XATTR
argument_list|)
argument_list|,
name|xattr_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_RECORDSIZE
argument_list|)
argument_list|,
name|blksz_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_READONLY
argument_list|)
argument_list|,
name|readonly_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEVICES
argument_list|)
argument_list|,
name|devices_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_SETUID
argument_list|)
argument_list|,
name|setuid_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_EXEC
argument_list|)
argument_list|,
name|exec_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_SNAPDIR
argument_list|)
argument_list|,
name|snapdir_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_ACLMODE
argument_list|)
argument_list|,
name|acl_mode_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_ACLINHERIT
argument_list|)
argument_list|,
name|acl_inherit_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|error
condition|?
name|error
else|:
name|dsl_prop_register
argument_list|(
name|ds
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VSCAN
argument_list|)
argument_list|,
name|vscan_changed_cb
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|unregister
goto|;
comment|/* 	 * Invoke our callbacks to restore temporary mount options. 	 */
if|if
condition|(
name|do_readonly
condition|)
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|readonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_setuid
condition|)
name|setuid_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|setuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_exec
condition|)
name|exec_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_devices
condition|)
name|devices_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|devices
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_xattr
condition|)
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|xattr
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_atime
condition|)
name|atime_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|atime
argument_list|)
expr_stmt|;
name|nbmand_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|nbmand
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|unregister
label|:
name|dsl_prop_unregister_all
argument_list|(
name|ds
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_space_delta_cb
parameter_list|(
name|dmu_object_type_t
name|bonustype
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|uint64_t
modifier|*
name|userp
parameter_list|,
name|uint64_t
modifier|*
name|groupp
parameter_list|)
block|{
comment|/* 	 * Is it a valid type of object to track? 	 */
if|if
condition|(
name|bonustype
operator|!=
name|DMU_OT_ZNODE
operator|&&
name|bonustype
operator|!=
name|DMU_OT_SA
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
comment|/* 	 * If we have a NULL data pointer 	 * then assume the id's aren't changing and 	 * return EEXIST to the dmu to let it know to 	 * use the same ids 	 */
if|if
condition|(
name|data
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
if|if
condition|(
name|bonustype
operator|==
name|DMU_OT_ZNODE
condition|)
block|{
name|znode_phys_t
modifier|*
name|znp
init|=
name|data
decl_stmt|;
operator|*
name|userp
operator|=
name|znp
operator|->
name|zp_uid
expr_stmt|;
operator|*
name|groupp
operator|=
name|znp
operator|->
name|zp_gid
expr_stmt|;
block|}
else|else
block|{
name|int
name|hdrsize
decl_stmt|;
name|sa_hdr_phys_t
modifier|*
name|sap
init|=
name|data
decl_stmt|;
name|sa_hdr_phys_t
name|sa
init|=
operator|*
name|sap
decl_stmt|;
name|boolean_t
name|swap
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|bonustype
operator|==
name|DMU_OT_SA
argument_list|)
expr_stmt|;
if|if
condition|(
name|sa
operator|.
name|sa_magic
operator|==
literal|0
condition|)
block|{
comment|/* 			 * This should only happen for newly created 			 * files that haven't had the znode data filled 			 * in yet. 			 */
operator|*
name|userp
operator|=
literal|0
expr_stmt|;
operator|*
name|groupp
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|sa
operator|.
name|sa_magic
operator|==
name|BSWAP_32
argument_list|(
name|SA_MAGIC
argument_list|)
condition|)
block|{
name|sa
operator|.
name|sa_magic
operator|=
name|SA_MAGIC
expr_stmt|;
name|sa
operator|.
name|sa_layout_info
operator|=
name|BSWAP_16
argument_list|(
name|sa
operator|.
name|sa_layout_info
argument_list|)
expr_stmt|;
name|swap
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|VERIFY3U
argument_list|(
name|sa
operator|.
name|sa_magic
argument_list|,
operator|==
argument_list|,
name|SA_MAGIC
argument_list|)
expr_stmt|;
block|}
name|hdrsize
operator|=
name|sa_hdrsize
argument_list|(
operator|&
name|sa
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|hdrsize
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
name|sa_hdr_phys_t
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|userp
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|data
operator|+
name|hdrsize
operator|+
name|SA_UID_OFFSET
operator|)
operator|)
expr_stmt|;
operator|*
name|groupp
operator|=
operator|*
operator|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|(
name|uintptr_t
operator|)
name|data
operator|+
name|hdrsize
operator|+
name|SA_GID_OFFSET
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|swap
condition|)
block|{
operator|*
name|userp
operator|=
name|BSWAP_64
argument_list|(
operator|*
name|userp
argument_list|)
expr_stmt|;
operator|*
name|groupp
operator|=
name|BSWAP_64
argument_list|(
operator|*
name|groupp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fuidstr_to_sid
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
specifier|const
name|char
modifier|*
name|fuidstr
parameter_list|,
name|char
modifier|*
name|domainbuf
parameter_list|,
name|int
name|buflen
parameter_list|,
name|uid_t
modifier|*
name|ridp
parameter_list|)
block|{
name|uint64_t
name|fuid
decl_stmt|;
specifier|const
name|char
modifier|*
name|domain
decl_stmt|;
name|fuid
operator|=
name|strtonum
argument_list|(
name|fuidstr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|domain
operator|=
name|zfs_fuid_find_by_idx
argument_list|(
name|zfsvfs
argument_list|,
name|FUID_INDEX
argument_list|(
name|fuid
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|domain
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|domainbuf
argument_list|,
name|domain
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
else|else
name|domainbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|ridp
operator|=
name|FUID_RID
argument_list|(
name|fuid
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|zfs_userquota_prop_to_obj
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_userquota_prop_t
name|type
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|ZFS_PROP_USERUSED
case|:
return|return
operator|(
name|DMU_USERUSED_OBJECT
operator|)
return|;
case|case
name|ZFS_PROP_GROUPUSED
case|:
return|return
operator|(
name|DMU_GROUPUSED_OBJECT
operator|)
return|;
case|case
name|ZFS_PROP_USERQUOTA
case|:
return|return
operator|(
name|zfsvfs
operator|->
name|z_userquota_obj
operator|)
return|;
case|case
name|ZFS_PROP_GROUPQUOTA
case|:
return|return
operator|(
name|zfsvfs
operator|->
name|z_groupquota_obj
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_userspace_many
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_userquota_prop_t
name|type
parameter_list|,
name|uint64_t
modifier|*
name|cookiep
parameter_list|,
name|void
modifier|*
name|vbuf
parameter_list|,
name|uint64_t
modifier|*
name|bufsizep
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|zfs_useracct_t
modifier|*
name|buf
init|=
name|vbuf
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_objset_userspace_present
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
name|obj
operator|=
name|zfs_userquota_prop_to_obj
argument_list|(
name|zfsvfs
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
literal|0
condition|)
block|{
operator|*
name|bufsizep
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|zc
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|obj
argument_list|,
operator|*
name|cookiep
argument_list|)
init|;
operator|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
name|uintptr_t
operator|)
name|buf
operator|-
operator|(
name|uintptr_t
operator|)
name|vbuf
operator|+
sizeof|sizeof
argument_list|(
name|zfs_useracct_t
argument_list|)
operator|>
operator|*
name|bufsizep
condition|)
break|break;
name|fuidstr_to_sid
argument_list|(
name|zfsvfs
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|buf
operator|->
name|zu_domain
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
operator|->
name|zu_domain
argument_list|)
argument_list|,
operator|&
name|buf
operator|->
name|zu_rid
argument_list|)
expr_stmt|;
name|buf
operator|->
name|zu_space
operator|=
name|za
operator|.
name|za_first_integer
expr_stmt|;
name|buf
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|uintptr_t
operator|)
name|buf
operator|-
operator|(
name|uintptr_t
operator|)
name|vbuf
argument_list|,
operator|<=
argument_list|,
operator|*
name|bufsizep
argument_list|)
expr_stmt|;
operator|*
name|bufsizep
operator|=
operator|(
name|uintptr_t
operator|)
name|buf
operator|-
operator|(
name|uintptr_t
operator|)
name|vbuf
expr_stmt|;
operator|*
name|cookiep
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * buf must be big enough (eg, 32 bytes)  */
end_comment

begin_function
specifier|static
name|int
name|id_to_fuidstr
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|uid_t
name|rid
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|boolean_t
name|addok
parameter_list|)
block|{
name|uint64_t
name|fuid
decl_stmt|;
name|int
name|domainid
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|domain
operator|&&
name|domain
index|[
literal|0
index|]
condition|)
block|{
name|domainid
operator|=
name|zfs_fuid_find_by_domain
argument_list|(
name|zfsvfs
argument_list|,
name|domain
argument_list|,
name|NULL
argument_list|,
name|addok
argument_list|)
expr_stmt|;
if|if
condition|(
name|domainid
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
name|fuid
operator|=
name|FUID_ENCODE
argument_list|(
name|domainid
argument_list|,
name|rid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%llx"
argument_list|,
operator|(
name|longlong_t
operator|)
name|fuid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_userspace_one
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_userquota_prop_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|uint64_t
name|rid
parameter_list|,
name|uint64_t
modifier|*
name|valp
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|dmu_objset_userspace_present
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
name|obj
operator|=
name|zfs_userquota_prop_to_obj
argument_list|(
name|zfsvfs
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|err
operator|=
name|id_to_fuidstr
argument_list|(
name|zfsvfs
argument_list|,
name|domain
argument_list|,
name|rid
argument_list|,
name|buf
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|obj
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|valp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_set_userquota
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|zfs_userquota_prop_t
name|type
parameter_list|,
specifier|const
name|char
modifier|*
name|domain
parameter_list|,
name|uint64_t
name|rid
parameter_list|,
name|uint64_t
name|quota
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
modifier|*
name|objp
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
if|if
condition|(
name|type
operator|!=
name|ZFS_PROP_USERQUOTA
operator|&&
name|type
operator|!=
name|ZFS_PROP_GROUPQUOTA
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|<
name|ZPL_VERSION_USERSPACE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
name|objp
operator|=
operator|(
name|type
operator|==
name|ZFS_PROP_USERQUOTA
operator|)
condition|?
operator|&
name|zfsvfs
operator|->
name|z_userquota_obj
else|:
operator|&
name|zfsvfs
operator|->
name|z_groupquota_obj
expr_stmt|;
name|err
operator|=
name|id_to_fuidstr
argument_list|(
name|zfsvfs
argument_list|,
name|domain
argument_list|,
name|rid
argument_list|,
name|buf
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
operator|*
name|objp
condition|?
operator|*
name|objp
else|:
name|DMU_NEW_OBJECT
argument_list|,
name|B_TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|objp
operator|==
literal|0
condition|)
block|{
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|B_TRUE
argument_list|,
name|zfs_userquota_prop_prefixes
index|[
name|type
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|objp
operator|==
literal|0
condition|)
block|{
operator|*
name|objp
operator|=
name|zap_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|DMU_OT_USERGROUP_QUOTA
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|zfs_userquota_prop_prefixes
index|[
name|type
index|]
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|objp
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|quota
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|zap_remove
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
operator|*
name|objp
argument_list|,
name|buf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|zap_update
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
operator|*
name|objp
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|quota
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|zfs_fuid_overquota
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|boolean_t
name|isgroup
parameter_list|,
name|uint64_t
name|fuid
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|quota
decl_stmt|,
name|usedobj
decl_stmt|,
name|quotaobj
decl_stmt|;
name|int
name|err
decl_stmt|;
name|usedobj
operator|=
name|isgroup
condition|?
name|DMU_GROUPUSED_OBJECT
else|:
name|DMU_USERUSED_OBJECT
expr_stmt|;
name|quotaobj
operator|=
name|isgroup
condition|?
name|zfsvfs
operator|->
name|z_groupquota_obj
else|:
name|zfsvfs
operator|->
name|z_userquota_obj
expr_stmt|;
if|if
condition|(
name|quotaobj
operator|==
literal|0
operator|||
name|zfsvfs
operator|->
name|z_replay
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%llx"
argument_list|,
operator|(
name|longlong_t
operator|)
name|fuid
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|quotaobj
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|quota
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|usedobj
argument_list|,
name|buf
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|used
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|used
operator|>=
name|quota
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|zfs_owner_overquota
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|znode_t
modifier|*
name|zp
parameter_list|,
name|boolean_t
name|isgroup
parameter_list|)
block|{
name|uint64_t
name|fuid
decl_stmt|;
name|uint64_t
name|quotaobj
decl_stmt|;
name|quotaobj
operator|=
name|isgroup
condition|?
name|zfsvfs
operator|->
name|z_groupquota_obj
else|:
name|zfsvfs
operator|->
name|z_userquota_obj
expr_stmt|;
name|fuid
operator|=
name|isgroup
condition|?
name|zp
operator|->
name|z_gid
else|:
name|zp
operator|->
name|z_uid
expr_stmt|;
if|if
condition|(
name|quotaobj
operator|==
literal|0
operator|||
name|zfsvfs
operator|->
name|z_replay
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|zfs_fuid_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|isgroup
argument_list|,
name|fuid
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Associate this zfsvfs with the given objset, which must be owned.  * This will cache a bunch of on-disk state from the objset in the  * zfsvfs.  */
end_comment

begin_function
specifier|static
name|int
name|zfsvfs_init
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|zfsvfs
operator|->
name|z_max_blksz
operator|=
name|SPA_OLD_MAXBLOCKSIZE
expr_stmt|;
name|zfsvfs
operator|->
name|z_show_ctldir
operator|=
name|ZFS_SNAPDIR_VISIBLE
expr_stmt|;
name|zfsvfs
operator|->
name|z_os
operator|=
name|os
expr_stmt|;
name|error
operator|=
name|zfs_get_zplprop
argument_list|(
name|os
argument_list|,
name|ZFS_PROP_VERSION
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|>
name|zfs_zpl_version_map
argument_list|(
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Can't mount a version %lld file system "
literal|"on a version %lld pool\n. Pool must be upgraded to mount "
literal|"this file system."
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zfsvfs
operator|->
name|z_version
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|zfs_get_zplprop
argument_list|(
name|os
argument_list|,
name|ZFS_PROP_NORMALIZE
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zfsvfs
operator|->
name|z_norm
operator|=
operator|(
name|int
operator|)
name|val
expr_stmt|;
name|error
operator|=
name|zfs_get_zplprop
argument_list|(
name|os
argument_list|,
name|ZFS_PROP_UTF8ONLY
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zfsvfs
operator|->
name|z_utf8
operator|=
operator|(
name|val
operator|!=
literal|0
operator|)
expr_stmt|;
name|error
operator|=
name|zfs_get_zplprop
argument_list|(
name|os
argument_list|,
name|ZFS_PROP_CASE
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zfsvfs
operator|->
name|z_case
operator|=
operator|(
name|uint_t
operator|)
name|val
expr_stmt|;
comment|/* 	 * Fold case on file systems that are always or sometimes case 	 * insensitive. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
operator|||
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
condition|)
name|zfsvfs
operator|->
name|z_norm
operator||=
name|U8_TEXTPREP_TOUPPER
expr_stmt|;
name|zfsvfs
operator|->
name|z_use_fuids
operator|=
name|USE_FUIDS
argument_list|(
name|zfsvfs
operator|->
name|z_version
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_use_sa
operator|=
name|USE_SA
argument_list|(
name|zfsvfs
operator|->
name|z_version
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|uint64_t
name|sa_obj
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_sa
condition|)
block|{
comment|/* should either have both of these objects or none */
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_SA_ATTRS
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|sa_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|sa_setup
argument_list|(
name|os
argument_list|,
name|sa_obj
argument_list|,
name|zfs_attr_table
argument_list|,
name|ZPL_END
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_attr_table
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_SA
condition|)
name|sa_register_update_callback
argument_list|(
name|os
argument_list|,
name|zfs_sa_upgrade
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_ROOT_OBJ
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_root
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_UNLINKED_SET
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|zfs_userquota_prop_prefixes
index|[
name|ZFS_PROP_USERQUOTA
index|]
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_userquota_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|zfsvfs
operator|->
name|z_userquota_obj
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|zfs_userquota_prop_prefixes
index|[
name|ZFS_PROP_GROUPQUOTA
index|]
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_groupquota_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|zfsvfs
operator|->
name|z_groupquota_obj
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_FUID_TABLES
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_fuid_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|zfsvfs
operator|->
name|z_fuid_obj
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_SHARES_DIR
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zfsvfs
operator|->
name|z_shares_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|zfsvfs
operator|->
name|z_shares_dir
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfsvfs_create
parameter_list|(
specifier|const
name|char
modifier|*
name|osname
parameter_list|,
name|zfsvfs_t
modifier|*
modifier|*
name|zfvp
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfsvfs
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * We claim to always be readonly so we can open snapshots; 	 * other ZPL code will prevent us from writing to snapshots. 	 */
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|osname
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|B_TRUE
argument_list|,
name|zfsvfs
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
name|zfsvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zfsvfs
operator|->
name|z_vfs
operator|=
name|NULL
expr_stmt|;
name|zfsvfs
operator|->
name|z_parent
operator|=
name|zfsvfs
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
sizeof|sizeof
argument_list|(
name|znode_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|znode_t
argument_list|,
name|z_link_node
argument_list|)
argument_list|)
expr_stmt|;
name|rrm_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|!=
name|ZFS_OBJ_MTX_SZ
condition|;
name|i
operator|++
control|)
name|mutex_init
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_hold_mtx
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfsvfs_init
argument_list|(
name|zfsvfs
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
operator|*
name|zfvp
operator|=
name|NULL
expr_stmt|;
name|kmem_free
argument_list|(
name|zfsvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|*
name|zfvp
operator|=
name|zfsvfs
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfsvfs_setup
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|boolean_t
name|mounting
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|zfs_register_callbacks
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zfsvfs
operator|->
name|z_log
operator|=
name|zil_open
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfs_get_data
argument_list|)
expr_stmt|;
comment|/* 	 * If we are not mounting (ie: online recv), then we don't 	 * have to worry about replaying the log as we blocked all 	 * operations out since we closed the ZIL. 	 */
if|if
condition|(
name|mounting
condition|)
block|{
name|boolean_t
name|readonly
decl_stmt|;
comment|/* 		 * During replay we remove the read only flag to 		 * allow replays to succeed. 		 */
name|readonly
operator|=
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
expr_stmt|;
if|if
condition|(
name|readonly
operator|!=
literal|0
condition|)
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&=
operator|~
name|VFS_RDONLY
expr_stmt|;
else|else
name|zfs_unlinked_drain
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 		 * Parse and replay the intent log. 		 * 		 * Because of ziltest, this must be done after 		 * zfs_unlinked_drain().  (Further note: ziltest 		 * doesn't use readonly mounts, where 		 * zfs_unlinked_drain() isn't called.)  This is because 		 * ziltest causes spa_sync() to think it's committed, 		 * but actually it is not, so the intent log contains 		 * many txg's worth of changes. 		 * 		 * In particular, if object N is in the unlinked set in 		 * the last txg to actually sync, then it could be 		 * actually freed in a later txg and then reallocated 		 * in a yet later txg.  This would write a "create 		 * object N" record to the intent log.  Normally, this 		 * would be fine because the spa_sync() would have 		 * written out the fact that object N is free, before 		 * we could write the "create object N" intent log 		 * record. 		 * 		 * But when we are in ziltest mode, we advance the "open 		 * txg" without actually spa_sync()-ing the changes to 		 * disk.  So we would see that object N is still 		 * allocated and in the unlinked set, and there is an 		 * intent log record saying to allocate it. 		 */
if|if
condition|(
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zil_replay_disable
condition|)
block|{
name|zil_destroy
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zfsvfs
operator|->
name|z_replay
operator|=
name|B_TRUE
expr_stmt|;
name|zil_replay
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
argument_list|,
name|zfs_replay_vector
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_replay
operator|=
name|B_FALSE
expr_stmt|;
block|}
block|}
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator||=
name|readonly
expr_stmt|;
comment|/* restore readonly bit */
block|}
comment|/* 	 * Set the objset user_ptr to track its zfsvfs. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|dmu_objset_set_user
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfsvfs_free
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
specifier|extern
name|krwlock_t
name|zfsvfs_lock
decl_stmt|;
comment|/* in zfs_znode.c */
comment|/* 	 * This is a barrier to prevent the filesystem from going away in 	 * zfs_znode_move() until we can safely ensure that the filesystem is 	 * not unmounted. We consider the filesystem valid before the barrier 	 * and invalid after the barrier. 	 */
name|rw_enter
argument_list|(
operator|&
name|zfsvfs_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs_lock
argument_list|)
expr_stmt|;
name|zfs_fuid_destroy
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
expr_stmt|;
name|rrm_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_fuid_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|ZFS_OBJ_MTX_SZ
condition|;
name|i
operator|++
control|)
name|mutex_destroy
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_hold_mtx
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zfsvfs
argument_list|,
sizeof|sizeof
argument_list|(
name|zfsvfs_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_set_fuid_feature
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|zfsvfs
operator|->
name|z_use_fuids
operator|=
name|USE_FUIDS
argument_list|(
name|zfsvfs
operator|->
name|z_version
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
condition|)
block|{
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
block|{
name|vfs_set_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_XVATTR
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_ACLONCREATE
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_ACCESS_FILTER
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_REPARSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vfs_clear_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_XVATTR
argument_list|)
expr_stmt|;
name|vfs_clear_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
expr_stmt|;
name|vfs_clear_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
expr_stmt|;
name|vfs_clear_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_ACLONCREATE
argument_list|)
expr_stmt|;
name|vfs_clear_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_ACCESS_FILTER
argument_list|)
expr_stmt|;
name|vfs_clear_feature
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|VFSFT_REPARSE
argument_list|)
expr_stmt|;
block|}
block|}
name|zfsvfs
operator|->
name|z_use_sa
operator|=
name|USE_SA
argument_list|(
name|zfsvfs
operator|->
name|z_version
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_domount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|char
modifier|*
name|osname
parameter_list|)
block|{
name|dev_t
name|mount_dev
decl_stmt|;
name|uint64_t
name|recordsize
decl_stmt|,
name|fsid_guid
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|osname
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfsvfs_create
argument_list|(
name|osname
argument_list|,
operator|&
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zfsvfs
operator|->
name|z_vfs
operator|=
name|vfsp
expr_stmt|;
comment|/* Initialize the generic filesystem structure. */
name|vfsp
operator|->
name|vfs_bcount
operator|=
literal|0
expr_stmt|;
name|vfsp
operator|->
name|vfs_data
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|zfs_create_unique_device
argument_list|(
operator|&
name|mount_dev
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENODEV
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ASSERT
argument_list|(
name|vfs_devismounted
argument_list|(
name|mount_dev
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"recordsize"
argument_list|,
operator|&
name|recordsize
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|vfsp
operator|->
name|vfs_dev
operator|=
name|mount_dev
expr_stmt|;
name|vfsp
operator|->
name|vfs_fstype
operator|=
name|zfsfstype
expr_stmt|;
name|vfsp
operator|->
name|vfs_bsize
operator|=
name|recordsize
expr_stmt|;
name|vfsp
operator|->
name|vfs_flag
operator||=
name|VFS_NOTRUNC
expr_stmt|;
name|vfsp
operator|->
name|vfs_data
operator|=
name|zfsvfs
expr_stmt|;
comment|/* 	 * The fsid is 64 bits, composed of an 8-bit fs type, which 	 * separates our fsid from any other filesystem types, and a 	 * 56-bit objset unique ID.  The objset unique ID is unique to 	 * all objsets open on this system, provided by unique_create(). 	 * The 8-bit fs type must be put in the low bits of fsid[1] 	 * because that's where other Solaris filesystems put it. 	 */
name|fsid_guid
operator|=
name|dmu_objset_fsid_guid
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|fsid_guid
operator|&
operator|~
operator|(
operator|(
literal|1ULL
operator|<<
literal|56
operator|)
operator|-
literal|1
operator|)
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vfsp
operator|->
name|vfs_fsid
operator|.
name|val
index|[
literal|0
index|]
operator|=
name|fsid_guid
expr_stmt|;
name|vfsp
operator|->
name|vfs_fsid
operator|.
name|val
index|[
literal|1
index|]
operator|=
operator|(
operator|(
name|fsid_guid
operator|>>
literal|32
operator|)
operator|<<
literal|8
operator|)
operator||
name|zfsfstype
operator|&
literal|0xFF
expr_stmt|;
comment|/* 	 * Set features for file system. 	 */
name|zfs_set_fuid_feature
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
condition|)
block|{
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_DIRENTFLAGS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
condition|)
block|{
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_DIRENTFLAGS
argument_list|)
expr_stmt|;
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
expr_stmt|;
block|}
name|vfs_set_feature
argument_list|(
name|vfsp
argument_list|,
name|VFSFT_ZEROCOPY_SUPPORTED
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmu_objset_is_snapshot
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
condition|)
block|{
name|uint64_t
name|pval
decl_stmt|;
name|atime_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|readonly_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
literal|"xattr"
argument_list|,
operator|&
name|pval
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|xattr_changed_cb
argument_list|(
name|zfsvfs
argument_list|,
name|pval
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_issnap
operator|=
name|B_TRUE
expr_stmt|;
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|=
name|ZFS_SYNC_DISABLED
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|dmu_objset_set_user
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zfsvfs_setup
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_issnap
condition|)
name|zfsctl_create
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|error
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|zfsvfs_free
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|atomic_inc_32
argument_list|(
operator|&
name|zfs_active_fs_count
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_unregister_callbacks
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
if|if
condition|(
operator|!
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
condition|)
name|dsl_prop_unregister_all
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Convert a decimal digit string to a uint64_t integer.  */
end_comment

begin_function
specifier|static
name|int
name|str_to_uint64
parameter_list|(
name|char
modifier|*
name|str
parameter_list|,
name|uint64_t
modifier|*
name|objnum
parameter_list|)
block|{
name|uint64_t
name|num
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|<
literal|'0'
operator|||
operator|*
name|str
operator|>
literal|'9'
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|num
operator|=
name|num
operator|*
literal|10
operator|+
operator|*
name|str
operator|++
operator|-
literal|'0'
expr_stmt|;
block|}
operator|*
name|objnum
operator|=
name|num
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The boot path passed from the boot loader is in the form of  * "rootpool-name/root-filesystem-object-number'. Convert this  * string to a dataset name: "rootpool-name/root-filesystem-name".  */
end_comment

begin_function
specifier|static
name|int
name|zfs_parse_bootfs
parameter_list|(
name|char
modifier|*
name|bpath
parameter_list|,
name|char
modifier|*
name|outpath
parameter_list|)
block|{
name|char
modifier|*
name|slashp
decl_stmt|;
name|uint64_t
name|objnum
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|*
name|bpath
operator|==
literal|0
operator|||
operator|*
name|bpath
operator|==
literal|'/'
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|outpath
argument_list|,
name|bpath
argument_list|)
expr_stmt|;
name|slashp
operator|=
name|strchr
argument_list|(
name|bpath
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* if no '/', just return the pool name */
if|if
condition|(
name|slashp
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* if not a number, just return the root dataset name */
if|if
condition|(
name|str_to_uint64
argument_list|(
name|slashp
operator|+
literal|1
argument_list|,
operator|&
name|objnum
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|*
name|slashp
operator|=
literal|'\0'
expr_stmt|;
name|error
operator|=
name|dsl_dsobj_to_dsname
argument_list|(
name|bpath
argument_list|,
name|objnum
argument_list|,
name|outpath
argument_list|)
expr_stmt|;
operator|*
name|slashp
operator|=
literal|'/'
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that the hex label string is appropriate for the dataset being  * mounted into the global_zone proper.  *  * Return an error if the hex label string is not default or  * admin_low/admin_high.  For admin_low labels, the corresponding  * dataset must be readonly.  */
end_comment

begin_function
name|int
name|zfs_check_global_label
parameter_list|(
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
specifier|const
name|char
modifier|*
name|hexsl
parameter_list|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|hexsl
argument_list|,
name|ZFS_MLSLABEL_DEFAULT
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|hexsl
argument_list|,
name|ADMIN_HIGH
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|hexsl
argument_list|,
name|ADMIN_LOW
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* must be readonly */
name|uint64_t
name|rdonly
decl_stmt|;
if|if
condition|(
name|dsl_prop_get_integer
argument_list|(
name|dsname
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_READONLY
argument_list|)
argument_list|,
operator|&
name|rdonly
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
return|return
operator|(
name|rdonly
condition|?
literal|0
else|:
name|EACCES
operator|)
return|;
block|}
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Determine whether the mount is allowed according to MAC check.  * by comparing (where appropriate) label of the dataset against  * the label of the zone being mounted into.  If the dataset has  * no label, create one.  *  * Returns 0 if access allowed, error otherwise (e.g. EACCES)  */
end_comment

begin_function
specifier|static
name|int
name|zfs_mount_label_policy
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|char
modifier|*
name|osname
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|retv
decl_stmt|;
name|zone_t
modifier|*
name|mntzone
init|=
name|NULL
decl_stmt|;
name|ts_label_t
modifier|*
name|mnt_tsl
decl_stmt|;
name|bslabel_t
modifier|*
name|mnt_sl
decl_stmt|;
name|bslabel_t
name|ds_sl
decl_stmt|;
name|char
name|ds_hexsl
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|retv
operator|=
name|EACCES
expr_stmt|;
comment|/* assume the worst */
comment|/* 	 * Start by getting the dataset label if it exists. 	 */
name|error
operator|=
name|dsl_prop_get
argument_list|(
name|osname
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_MLSLABEL
argument_list|)
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|ds_hexsl
argument_list|)
argument_list|,
operator|&
name|ds_hexsl
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
comment|/* 	 * If labeling is NOT enabled, then disallow the mount of datasets 	 * which have a non-default label already.  No other label checks 	 * are needed. 	 */
if|if
condition|(
operator|!
name|is_system_labeled
argument_list|()
condition|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|ds_hexsl
argument_list|,
name|ZFS_MLSLABEL_DEFAULT
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Get the label of the mountpoint.  If mounting into the global 	 * zone (i.e. mountpoint is not within an active zone and the 	 * zoned property is off), the label must be default or 	 * admin_low/admin_high only; no other checks are needed. 	 */
name|mntzone
operator|=
name|zone_find_by_any_path
argument_list|(
name|refstr_value
argument_list|(
name|vfsp
operator|->
name|vfs_mntpt
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|mntzone
operator|->
name|zone_id
operator|==
name|GLOBAL_ZONEID
condition|)
block|{
name|uint64_t
name|zoned
decl_stmt|;
name|zone_rele
argument_list|(
name|mntzone
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_prop_get_integer
argument_list|(
name|osname
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_ZONED
argument_list|)
argument_list|,
operator|&
name|zoned
argument_list|,
name|NULL
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|zoned
condition|)
return|return
operator|(
name|zfs_check_global_label
argument_list|(
name|osname
argument_list|,
name|ds_hexsl
argument_list|)
operator|)
return|;
else|else
comment|/* 			 * This is the case of a zone dataset being mounted 			 * initially, before the zone has been fully created; 			 * allow this mount into global zone. 			 */
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mnt_tsl
operator|=
name|mntzone
operator|->
name|zone_slabel
expr_stmt|;
name|ASSERT
argument_list|(
name|mnt_tsl
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|label_hold
argument_list|(
name|mnt_tsl
argument_list|)
expr_stmt|;
name|mnt_sl
operator|=
name|label2bslabel
argument_list|(
name|mnt_tsl
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|ds_hexsl
argument_list|,
name|ZFS_MLSLABEL_DEFAULT
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The dataset doesn't have a real label, so fabricate one. 		 */
name|char
modifier|*
name|str
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|l_to_str_internal
argument_list|(
name|mnt_sl
argument_list|,
operator|&
name|str
argument_list|)
operator|==
literal|0
operator|&&
name|dsl_prop_set_string
argument_list|(
name|osname
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_MLSLABEL
argument_list|)
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|,
name|str
argument_list|)
operator|==
literal|0
condition|)
name|retv
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|str
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|hexstr_to_label
argument_list|(
name|ds_hexsl
argument_list|,
operator|&
name|ds_sl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Now compare labels to complete the MAC check.  If the 		 * labels are equal then allow access.  If the mountpoint 		 * label dominates the dataset label, allow readonly access. 		 * Otherwise, access is denied. 		 */
if|if
condition|(
name|blequal
argument_list|(
name|mnt_sl
argument_list|,
operator|&
name|ds_sl
argument_list|)
condition|)
name|retv
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|bldominates
argument_list|(
name|mnt_sl
argument_list|,
operator|&
name|ds_sl
argument_list|)
condition|)
block|{
name|vfs_setmntopt
argument_list|(
name|vfsp
argument_list|,
name|MNTOPT_RO
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retv
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|label_rele
argument_list|(
name|mnt_tsl
argument_list|)
expr_stmt|;
name|zone_rele
argument_list|(
name|mntzone
argument_list|)
expr_stmt|;
return|return
operator|(
name|retv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_mountroot
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|enum
name|whymountroot
name|why
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|zfsrootdone
init|=
literal|0
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|NULL
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|NULL
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|zfs_bootfs
decl_stmt|;
name|char
modifier|*
name|zfs_devid
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
comment|/* 	 * The filesystem that we mount as root is defined in the 	 * boot property "zfs-bootfs" with a format of 	 * "poolname/root-dataset-objnum". 	 */
if|if
condition|(
name|why
operator|==
name|ROOT_INIT
condition|)
block|{
if|if
condition|(
name|zfsrootdone
operator|++
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 		 * the process of doing a spa_load will require the 		 * clock to be set before we could (for example) do 		 * something better by looking at the timestamp on 		 * an uberblock, so just set it to -1. 		 */
name|clkset
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zfs_bootfs
operator|=
name|spa_get_bootprop
argument_list|(
literal|"zfs-bootfs"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"spa_get_bootfs: can not get "
literal|"bootfs name"
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|zfs_devid
operator|=
name|spa_get_bootprop
argument_list|(
literal|"diskdevid"
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_import_rootpool
argument_list|(
name|rootfs
operator|.
name|bo_name
argument_list|,
name|zfs_devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfs_devid
condition|)
name|spa_free_bootprop
argument_list|(
name|zfs_devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|spa_free_bootprop
argument_list|(
name|zfs_bootfs
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"spa_import_rootpool: error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_parse_bootfs
argument_list|(
name|zfs_bootfs
argument_list|,
name|rootfs
operator|.
name|bo_name
argument_list|)
condition|)
block|{
name|spa_free_bootprop
argument_list|(
name|zfs_bootfs
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"zfs_parse_bootfs: error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|spa_free_bootprop
argument_list|(
name|zfs_bootfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|vfs_lock
argument_list|(
name|vfsp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|zfs_domount
argument_list|(
name|vfsp
argument_list|,
name|rootfs
operator|.
name|bo_name
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"zfs_domount: error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|zfsvfs
operator|=
operator|(
name|zfsvfs_t
operator|*
operator|)
name|vfsp
operator|->
name|vfs_data
expr_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_root
argument_list|,
operator|&
name|zp
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"zfs_zget: error %d"
argument_list|,
name|error
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VROOT
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|rootvp
operator|=
name|vp
expr_stmt|;
comment|/* 		 * Leave rootvp held.  The root file system is never unmounted. 		 */
name|vfs_add
argument_list|(
operator|(
expr|struct
name|vnode
operator|*
operator|)
literal|0
argument_list|,
name|vfsp
argument_list|,
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|?
name|MS_RDONLY
else|:
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
name|vfs_unlock
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|why
operator|==
name|ROOT_REMOUNT
condition|)
block|{
name|readonly_changed_cb
argument_list|(
name|vfsp
operator|->
name|vfs_data
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|vfsp
operator|->
name|vfs_flag
operator||=
name|VFS_REMOUNT
expr_stmt|;
comment|/* refresh mount options */
name|zfs_unregister_callbacks
argument_list|(
name|vfsp
operator|->
name|vfs_data
argument_list|)
expr_stmt|;
return|return
operator|(
name|zfs_register_callbacks
argument_list|(
name|vfsp
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|why
operator|==
name|ROOT_UNMOUNT
condition|)
block|{
name|zfs_unregister_callbacks
argument_list|(
operator|(
name|zfsvfs_t
operator|*
operator|)
name|vfsp
operator|->
name|vfs_data
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_sync
argument_list|(
name|vfsp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * if "why" is equal to anything else other than ROOT_INIT, 	 * ROOT_REMOUNT, or ROOT_UNMOUNT, we do not support it. 	 */
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_mount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnode_t
modifier|*
name|mvp
parameter_list|,
name|struct
name|mounta
modifier|*
name|uap
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|char
modifier|*
name|osname
decl_stmt|;
name|pathname_t
name|spn
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uio_seg_t
name|fromspace
init|=
operator|(
name|uap
operator|->
name|flags
operator|&
name|MS_SYSSPACE
operator|)
condition|?
name|UIO_SYSSPACE
else|:
name|UIO_USERSPACE
decl_stmt|;
name|int
name|canwrite
decl_stmt|;
if|if
condition|(
name|mvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|mvp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uap
operator|->
name|flags
operator|&
name|MS_REMOUNT
operator|)
operator|==
literal|0
operator|&&
operator|(
name|uap
operator|->
name|flags
operator|&
name|MS_OVERLAY
operator|)
operator|==
literal|0
operator|&&
operator|(
name|mvp
operator|->
name|v_count
operator|!=
literal|1
operator|||
operator|(
name|mvp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|mvp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|mvp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
comment|/* 	 * ZFS does not support passing unparsed data in via MS_DATA. 	 * Users should use the MS_OPTIONSTR interface; this means 	 * that all option parsing is already done and the options struct 	 * can be interrogated. 	 */
if|if
condition|(
operator|(
name|uap
operator|->
name|flags
operator|&
name|MS_DATA
operator|)
operator|&&
name|uap
operator|->
name|datalen
operator|>
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * Get the objset name (the "special" mount argument). 	 */
if|if
condition|(
name|error
operator|=
name|pn_get
argument_list|(
name|uap
operator|->
name|spec
argument_list|,
name|fromspace
argument_list|,
operator|&
name|spn
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|osname
operator|=
name|spn
operator|.
name|pn_path
expr_stmt|;
comment|/* 	 * Check for mount privilege? 	 * 	 * If we don't have privilege then see if 	 * we have local permission to allow it 	 */
name|error
operator|=
name|secpolicy_fs_mount
argument_list|(
name|cr
argument_list|,
name|mvp
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|dsl_deleg_access
argument_list|(
name|osname
argument_list|,
name|ZFS_DELEG_PERM_MOUNT
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vattr_t
name|vattr
decl_stmt|;
comment|/* 			 * Make sure user is the owner of the mount point 			 * or has sufficient privileges. 			 */
name|vattr
operator|.
name|va_mask
operator|=
name|AT_UID
expr_stmt|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|mvp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|secpolicy_vnode_owner
argument_list|(
name|cr
argument_list|,
name|vattr
operator|.
name|va_uid
argument_list|)
operator|!=
literal|0
operator|&&
name|VOP_ACCESS
argument_list|(
name|mvp
argument_list|,
name|VWRITE
argument_list|,
literal|0
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|secpolicy_fs_mount_clearopts
argument_list|(
name|cr
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Refuse to mount a filesystem if we are in a local zone and the 	 * dataset is not visible. 	 */
if|if
condition|(
operator|!
name|INGLOBALZONE
argument_list|(
name|curproc
argument_list|)
operator|&&
operator|(
operator|!
name|zone_dataset_visible
argument_list|(
name|osname
argument_list|,
operator|&
name|canwrite
argument_list|)
operator|||
operator|!
name|canwrite
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|zfs_mount_label_policy
argument_list|(
name|vfsp
argument_list|,
name|osname
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * When doing a remount, we simply refresh our temporary properties 	 * according to those options set in the current VFS options. 	 */
if|if
condition|(
name|uap
operator|->
name|flags
operator|&
name|MS_REMOUNT
condition|)
block|{
comment|/* refresh mount options */
name|zfs_unregister_callbacks
argument_list|(
name|vfsp
operator|->
name|vfs_data
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_register_callbacks
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
name|zfs_domount
argument_list|(
name|vfsp
argument_list|,
name|osname
argument_list|)
expr_stmt|;
comment|/* 	 * Add an extra VFS_HOLD on our parent vfs so that it can't 	 * disappear due to a forced unmount. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
operator|(
name|zfsvfs_t
operator|*
operator|)
name|vfsp
operator|->
name|vfs_data
operator|)
operator|->
name|z_issnap
condition|)
name|VFS_HOLD
argument_list|(
name|mvp
operator|->
name|v_vfsp
argument_list|)
expr_stmt|;
name|out
label|:
name|pn_free
argument_list|(
operator|&
name|spn
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_statvfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|statvfs64
modifier|*
name|statp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|dev32_t
name|d32
decl_stmt|;
name|uint64_t
name|refdbytes
decl_stmt|,
name|availbytes
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|dmu_objset_space
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
operator|&
name|refdbytes
argument_list|,
operator|&
name|availbytes
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
comment|/* 	 * The underlying storage pool actually uses multiple block sizes. 	 * We report the fragsize as the smallest block size we support, 	 * and we report our blocksize as the filesystem's maximum blocksize. 	 */
name|statp
operator|->
name|f_frsize
operator|=
literal|1UL
operator|<<
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|statp
operator|->
name|f_bsize
operator|=
name|zfsvfs
operator|->
name|z_max_blksz
expr_stmt|;
comment|/* 	 * The following report "total" blocks of various kinds in the 	 * file system, but reported in terms of f_frsize - the 	 * "fragment" size. 	 */
name|statp
operator|->
name|f_blocks
operator|=
operator|(
name|refdbytes
operator|+
name|availbytes
operator|)
operator|>>
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|statp
operator|->
name|f_bfree
operator|=
name|availbytes
operator|>>
name|SPA_MINBLOCKSHIFT
expr_stmt|;
name|statp
operator|->
name|f_bavail
operator|=
name|statp
operator|->
name|f_bfree
expr_stmt|;
comment|/* no root reservation */
comment|/* 	 * statvfs() should really be called statufs(), because it assumes 	 * static metadata.  ZFS doesn't preallocate files, so the best 	 * we can do is report the max that could possibly fit in f_files, 	 * and that minus the number actually used in f_ffree. 	 * For f_ffree, report the smaller of the number of object available 	 * and the number of blocks (each object will take at least a block). 	 */
name|statp
operator|->
name|f_ffree
operator|=
name|MIN
argument_list|(
name|availobjs
argument_list|,
name|statp
operator|->
name|f_bfree
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_favail
operator|=
name|statp
operator|->
name|f_ffree
expr_stmt|;
comment|/* no "root reservation" */
name|statp
operator|->
name|f_files
operator|=
name|statp
operator|->
name|f_ffree
operator|+
name|usedobjs
expr_stmt|;
operator|(
name|void
operator|)
name|cmpldev
argument_list|(
operator|&
name|d32
argument_list|,
name|vfsp
operator|->
name|vfs_dev
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_fsid
operator|=
name|d32
expr_stmt|;
comment|/* 	 * We're a zfs filesystem. 	 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|statp
operator|->
name|f_basetype
argument_list|,
name|vfssw
index|[
name|vfsp
operator|->
name|vfs_fstype
index|]
operator|.
name|vsw_name
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_flag
operator|=
name|vf_to_stf
argument_list|(
name|vfsp
operator|->
name|vfs_flag
argument_list|)
expr_stmt|;
name|statp
operator|->
name|f_namemax
operator|=
name|MAXNAMELEN
operator|-
literal|1
expr_stmt|;
comment|/* 	 * We have all of 32 characters to stuff a string here. 	 * Is there anything useful we could/should provide? 	 */
name|bzero
argument_list|(
name|statp
operator|->
name|f_fstr
argument_list|,
sizeof|sizeof
argument_list|(
name|statp
operator|->
name|f_fstr
argument_list|)
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_root
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|rootzp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_root
argument_list|,
operator|&
name|rootzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|rootzp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Teardown the zfsvfs::z_os.  *  * Note, if 'unmounting' is FALSE, we return with the 'z_teardown_lock'  * and 'z_teardown_inactive_lock' held.  */
end_comment

begin_function
specifier|static
name|int
name|zfsvfs_teardown
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|boolean_t
name|unmounting
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|rrm_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unmounting
condition|)
block|{
comment|/* 		 * We purge the parent filesystem's vfsp as the parent 		 * filesystem and all of its snapshots have their vnode's 		 * v_vfsp set to the parent's filesystem's vfsp.  Note, 		 * 'z_parent' is self referential for non-snapshots. 		 */
operator|(
name|void
operator|)
name|dnlc_purge_vfsp
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_vfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Close the zil. NB: Can't close the zil while zfs_inactive 	 * threads are blocked as zil_close can call zfs_inactive. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_log
condition|)
block|{
name|zil_close
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_log
operator|=
name|NULL
expr_stmt|;
block|}
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * If we are not unmounting (ie: online recv) and someone already 	 * unmounted this file system while we were doing the switcheroo, 	 * or a reopen of z_os failed then just bail out now. 	 */
if|if
condition|(
operator|!
name|unmounting
operator|&&
operator|(
name|zfsvfs
operator|->
name|z_unmounted
operator|||
name|zfsvfs
operator|->
name|z_os
operator|==
name|NULL
operator|)
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|rrm_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * At this point there are no vops active, and any new vops will 	 * fail with EIO since we have z_teardown_lock for writer (only 	 * relavent for forced unmount). 	 * 	 * Release all holds on dbufs. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|list_head
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
init|;
name|zp
operator|!=
name|NULL
condition|;
name|zp
operator|=
name|list_next
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
name|zp
argument_list|)
control|)
if|if
condition|(
name|zp
operator|->
name|z_sa_hdl
condition|)
block|{
name|ASSERT
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|zfs_znode_dmu_fini
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If we are unmounting, set the unmounted flag and let new vops 	 * unblock.  zfs_inactive will have the unmounted behavior, and all 	 * other vops will fail with EIO. 	 */
if|if
condition|(
name|unmounting
condition|)
block|{
name|zfsvfs
operator|->
name|z_unmounted
operator|=
name|B_TRUE
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|rrm_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * z_os will be NULL if there was an error in attempting to reopen 	 * zfsvfs, so just return as the properties had already been 	 * unregistered and cached data had been evicted before. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Unregister properties. 	 */
name|zfs_unregister_callbacks
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * Evict cached data 	 */
if|if
condition|(
name|dsl_dataset_is_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_objset_evict_dbufs
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_umount
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|fflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|secpolicy_fs_unmount
argument_list|(
name|cr
argument_list|,
name|vfsp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
if|if
condition|(
name|dsl_deleg_access
argument_list|(
operator|(
name|char
operator|*
operator|)
name|refstr_value
argument_list|(
name|vfsp
operator|->
name|vfs_resource
argument_list|)
argument_list|,
name|ZFS_DELEG_PERM_MOUNT
argument_list|,
name|cr
argument_list|)
condition|)
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* 	 * We purge the parent filesystem's vfsp as the parent filesystem 	 * and all of its snapshots have their vnode's v_vfsp set to the 	 * parent's filesystem's vfsp.  Note, 'z_parent' is self 	 * referential for non-snapshots. 	 */
operator|(
name|void
operator|)
name|dnlc_purge_vfsp
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_vfs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Unmount any snapshots mounted under .zfs before unmounting the 	 * dataset itself. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
operator|&&
operator|(
name|ret
operator|=
name|zfsctl_umount_snapshots
argument_list|(
name|vfsp
argument_list|,
name|fflag
argument_list|,
name|cr
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|ret
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|fflag
operator|&
name|MS_FORCE
operator|)
condition|)
block|{
comment|/* 		 * Check the number of active vnodes in the file system. 		 * Our count is maintained in the vfs structure, but the 		 * number is off by 1 to indicate a hold on the vfs 		 * structure itself. 		 * 		 * The '.zfs' directory maintains a reference of its 		 * own, and any active references underneath are 		 * reflected in the vnode count. 		 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|vfsp
operator|->
name|vfs_count
operator|>
literal|1
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|vfsp
operator|->
name|vfs_count
operator|>
literal|2
operator|||
name|zfsvfs
operator|->
name|z_ctldir
operator|->
name|v_count
operator|>
literal|1
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
block|}
name|vfsp
operator|->
name|vfs_flag
operator||=
name|VFS_UNMOUNTED
expr_stmt|;
name|VERIFY
argument_list|(
name|zfsvfs_teardown
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
comment|/* 	 * z_os will be NULL if there was an error in 	 * attempting to reopen zfsvfs. 	 */
if|if
condition|(
name|os
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Unset the objset user_ptr. 		 */
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|dmu_objset_set_user
argument_list|(
name|os
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Finally release the objset 		 */
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We can now safely destroy the '.zfs' directory node. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
condition|)
name|zfsctl_destroy
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_vget
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|uint64_t
name|object
init|=
literal|0
decl_stmt|;
name|uint64_t
name|fid_gen
init|=
literal|0
decl_stmt|;
name|uint64_t
name|gen_mask
decl_stmt|;
name|uint64_t
name|zp_gen
decl_stmt|;
name|int
name|i
decl_stmt|,
name|err
decl_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|zfid_long_t
modifier|*
name|zlfid
init|=
operator|(
name|zfid_long_t
operator|*
operator|)
name|fidp
decl_stmt|;
name|uint64_t
name|objsetid
init|=
literal|0
decl_stmt|;
name|uint64_t
name|setgen
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setid
argument_list|)
condition|;
name|i
operator|++
control|)
name|objsetid
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zlfid
operator|->
name|zf_setid
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setgen
argument_list|)
condition|;
name|i
operator|++
control|)
name|setgen
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zlfid
operator|->
name|zf_setgen
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfsctl_lookup_objset
argument_list|(
name|vfsp
argument_list|,
name|objsetid
argument_list|,
operator|&
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|==
name|SHORT_FID_LEN
operator|||
name|fidp
operator|->
name|fid_len
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|zfid_short_t
modifier|*
name|zfid
init|=
operator|(
name|zfid_short_t
operator|*
operator|)
name|fidp
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_object
argument_list|)
condition|;
name|i
operator|++
control|)
name|object
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zfid
operator|->
name|zf_object
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_gen
argument_list|)
condition|;
name|i
operator|++
control|)
name|fid_gen
operator||=
operator|(
operator|(
name|uint64_t
operator|)
name|zfid
operator|->
name|zf_gen
index|[
name|i
index|]
operator|)
operator|<<
operator|(
literal|8
operator|*
name|i
operator|)
expr_stmt|;
block|}
else|else
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* A zero fid_gen means we are in the .zfs control directories */
if|if
condition|(
name|fid_gen
operator|==
literal|0
operator|&&
operator|(
name|object
operator|==
name|ZFSCTL_INO_ROOT
operator|||
name|object
operator|==
name|ZFSCTL_INO_SNAPDIR
operator|)
condition|)
block|{
operator|*
name|vpp
operator|=
name|zfsvfs
operator|->
name|z_ctldir
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|vpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|object
operator|==
name|ZFSCTL_INO_SNAPDIR
condition|)
block|{
name|VERIFY
argument_list|(
name|zfsctl_root_lookup
argument_list|(
operator|*
name|vpp
argument_list|,
literal|"snapshot"
argument_list|,
name|vpp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VN_HOLD
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|gen_mask
operator|=
operator|-
literal|1ULL
operator|>>
operator|(
literal|64
operator|-
literal|8
operator|*
name|i
operator|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"getting %llu [%u mask %llx]\n"
argument_list|,
name|object
argument_list|,
name|fid_gen
argument_list|,
name|gen_mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|object
argument_list|,
operator|&
name|zp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_GEN
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|zp_gen
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|zp_gen
operator|=
name|zp_gen
operator|&
name|gen_mask
expr_stmt|;
if|if
condition|(
name|zp_gen
operator|==
literal|0
condition|)
name|zp_gen
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_unlinked
operator|||
name|zp_gen
operator|!=
name|fid_gen
condition|)
block|{
name|dprintf
argument_list|(
literal|"znode gen (%u) != fid gen (%u)\n"
argument_list|,
name|zp_gen
argument_list|,
name|fid_gen
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Block out VOPs and close zfsvfs_t::z_os  *  * Note, if successful, then we return with the 'z_teardown_lock' and  * 'z_teardown_inactive_lock' write held.  We leave ownership of the underlying  * dataset and objset intact so that they can be atomically handed off during  * a subsequent rollback or recv operation and the resume thereafter.  */
end_comment

begin_function
name|int
name|zfs_suspend_fs
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zfsvfs_teardown
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Rebuild SA and release VOPs.  Note that ownership of the underlying dataset  * is an invariant across any of the operations that can be performed while the  * filesystem was suspended.  Whether it succeeded or failed, the preconditions  * are the same: the relevant objset and associated dataset are owned by  * zfsvfs, held, and long held on entry.  */
end_comment

begin_function
name|int
name|zfs_resume_fs
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|ASSERT
argument_list|(
name|RRM_WRITE_HELD
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We already own this, so just update the objset_t, as the one we 	 * had before may have been evicted. 	 */
name|objset_t
modifier|*
name|os
decl_stmt|;
name|VERIFY3P
argument_list|(
name|ds
operator|->
name|ds_owner
argument_list|,
operator|==
argument_list|,
name|zfsvfs
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_dataset_long_held
argument_list|(
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_objset_from_ds
argument_list|(
name|ds
argument_list|,
operator|&
name|os
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfsvfs_init
argument_list|(
name|zfsvfs
argument_list|,
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|bail
goto|;
name|VERIFY
argument_list|(
name|zfsvfs_setup
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zfs_set_fuid_feature
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * Attempt to re-establish all the active znodes with 	 * their dbufs.  If a zfs_rezget() fails, then we'll let 	 * any potential callers discover that via ZFS_ENTER_VERIFY_VP 	 * when they try to use their znode. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|zp
operator|=
name|list_head
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|)
init|;
name|zp
condition|;
name|zp
operator|=
name|list_next
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_all_znodes
argument_list|,
name|zp
argument_list|)
control|)
block|{
operator|(
name|void
operator|)
name|zfs_rezget
argument_list|(
name|zp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_znodes_lock
argument_list|)
expr_stmt|;
name|bail
label|:
comment|/* release the VOPs */
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|rrm_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_lock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* 		 * Since we couldn't setup the sa framework, try to force 		 * unmount this file system. 		 */
if|if
condition|(
name|vn_vfswlock
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_vnodecovered
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|dounmount
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|MS_FORCE
argument_list|,
name|CRED
argument_list|()
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfs_freevfs
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
comment|/* 	 * If this is a snapshot, we have an extra VFS_HOLD on our parent 	 * from zfs_mount().  Release it here.  If we came through 	 * zfs_mountroot() instead, we didn't grab an extra hold, so 	 * skip the VFS_RELE for rootvfs. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_issnap
operator|&&
operator|(
name|vfsp
operator|!=
name|rootvfs
operator|)
condition|)
name|VFS_RELE
argument_list|(
name|zfsvfs
operator|->
name|z_parent
operator|->
name|z_vfs
argument_list|)
expr_stmt|;
name|zfsvfs_free
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|atomic_dec_32
argument_list|(
operator|&
name|zfs_active_fs_count
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * VFS_INIT() initialization.  Note that there is no VFS_FINI(),  * so we can't safely do any non-idempotent initialization here.  * Leave that to zfs_init() and zfs_fini(), which are called  * from the module's _init() and _fini() entry points.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_vfsinit
parameter_list|(
name|int
name|fstype
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|zfsfstype
operator|=
name|fstype
expr_stmt|;
comment|/* 	 * Setup vfsops and vnodeops tables. 	 */
name|error
operator|=
name|vfs_setfsops
argument_list|(
name|fstype
argument_list|,
name|zfs_vfsops_template
argument_list|,
operator|&
name|zfs_vfsops
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"zfs: bad vfs ops template"
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zfs_create_op_tables
argument_list|()
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_remove_op_tables
argument_list|()
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"zfs: bad vnode ops template"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|vfs_freevfsops_by_type
argument_list|(
name|zfsfstype
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|mutex_init
argument_list|(
operator|&
name|zfs_dev_mtx
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Unique major number for all zfs mounts. 	 * If we run out of 32-bit minors, we'll getudev() another major. 	 */
name|zfs_major
operator|=
name|ddi_name_to_major
argument_list|(
name|ZFS_DRIVER
argument_list|)
expr_stmt|;
name|zfs_minor
operator|=
name|ZFS_MIN_MINOR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_init
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Initialize .zfs directory structures 	 */
name|zfsctl_init
argument_list|()
expr_stmt|;
comment|/* 	 * Initialize znode cache, vnode ops, etc... 	 */
name|zfs_znode_init
argument_list|()
expr_stmt|;
name|dmu_objset_register_type
argument_list|(
name|DMU_OST_ZFS
argument_list|,
name|zfs_space_delta_cb
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfs_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|zfsctl_fini
argument_list|()
expr_stmt|;
name|zfs_znode_fini
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zfs_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|zfs_active_fs_count
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zfs_set_version
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|,
name|uint64_t
name|newvers
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
if|if
condition|(
name|newvers
operator|<
name|ZPL_VERSION_INITIAL
operator|||
name|newvers
operator|>
name|ZPL_VERSION
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|newvers
operator|<
name|zfsvfs
operator|->
name|z_version
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|zfs_spa_version_map
argument_list|(
name|newvers
argument_list|)
operator|>
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|B_FALSE
argument_list|,
name|ZPL_VERSION_STR
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvers
operator|>=
name|ZPL_VERSION_SA
operator|&&
operator|!
name|zfsvfs
operator|->
name|z_use_sa
condition|)
block|{
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|B_TRUE
argument_list|,
name|ZFS_SA_ATTRS
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZPL_VERSION_STR
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|newvers
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|newvers
operator|>=
name|ZPL_VERSION_SA
operator|&&
operator|!
name|zfsvfs
operator|->
name|z_use_sa
condition|)
block|{
name|uint64_t
name|sa_obj
decl_stmt|;
name|ASSERT3U
argument_list|(
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|)
argument_list|,
operator|>=
argument_list|,
name|SPA_VERSION_SA
argument_list|)
expr_stmt|;
name|sa_obj
operator|=
name|zap_create
argument_list|(
name|os
argument_list|,
name|DMU_OT_SA_MASTER_NODE
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_add
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|ZFS_SA_ATTRS
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|sa_obj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|sa_set_sa_object
argument_list|(
name|os
argument_list|,
name|sa_obj
argument_list|)
argument_list|)
expr_stmt|;
name|sa_register_update_callback
argument_list|(
name|os
argument_list|,
name|zfs_sa_upgrade
argument_list|)
expr_stmt|;
block|}
name|spa_history_log_internal_ds
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
literal|"upgrade"
argument_list|,
name|tx
argument_list|,
literal|"from %llu to %llu"
argument_list|,
name|zfsvfs
operator|->
name|z_version
argument_list|,
name|newvers
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_version
operator|=
name|newvers
expr_stmt|;
name|zfs_set_fuid_feature
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a property stored within the master node.  */
end_comment

begin_function
name|int
name|zfs_get_zplprop
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|zfs_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|pname
decl_stmt|;
name|int
name|error
init|=
name|ENOENT
decl_stmt|;
comment|/* 	 * Look up the file system's value for the property.  For the 	 * version property, we look up a slightly different string. 	 */
if|if
condition|(
name|prop
operator|==
name|ZFS_PROP_VERSION
condition|)
name|pname
operator|=
name|ZPL_VERSION_STR
expr_stmt|;
else|else
name|pname
operator|=
name|zfs_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|os
operator|!=
name|NULL
condition|)
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|MASTER_NODE_OBJ
argument_list|,
name|pname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* No value set, use the default value */
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZFS_PROP_VERSION
case|:
operator|*
name|value
operator|=
name|ZPL_VERSION
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_NORMALIZE
case|:
case|case
name|ZFS_PROP_UTF8ONLY
case|:
operator|*
name|value
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ZFS_PROP_CASE
case|:
operator|*
name|value
operator|=
name|ZFS_CASE_SENSITIVE
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return true if the coresponding vfs's unmounted flag is set.  * Otherwise return false.  * If this function returns true we know VFS unmount has been initiated.  */
end_comment

begin_function
name|boolean_t
name|zfs_get_vfs_flag_unmounted
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfvp
decl_stmt|;
name|boolean_t
name|unmounted
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_objset_type
argument_list|(
name|os
argument_list|)
operator|==
name|DMU_OST_ZFS
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
name|zfvp
operator|=
name|dmu_objset_get_user
argument_list|(
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfvp
operator|!=
name|NULL
operator|&&
name|zfvp
operator|->
name|z_vfs
operator|!=
name|NULL
operator|&&
operator|(
name|zfvp
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_UNMOUNTED
operator|)
condition|)
name|unmounted
operator|=
name|B_TRUE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|os
operator|->
name|os_user_ptr_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|unmounted
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|vfsdef_t
name|vfw
init|=
block|{
name|VFSDEF_VERSION
block|,
name|MNTTYPE_ZFS
block|,
name|zfs_vfsinit
block|,
name|VSW_HASPROTO
operator||
name|VSW_CANRWRO
operator||
name|VSW_CANREMOUNT
operator||
name|VSW_VOLATILEDEV
operator||
name|VSW_STATS
operator||
name|VSW_XID
operator||
name|VSW_ZMOUNT
block|,
operator|&
name|zfs_mntopts
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|modlfs
name|zfs_modlfs
init|=
block|{
operator|&
name|mod_fsops
block|,
literal|"ZFS filesystem version "
name|SPA_VERSION_STRING
block|,
operator|&
name|vfw
block|}
decl_stmt|;
end_decl_stmt

end_unit

