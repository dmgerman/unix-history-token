begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2015 Joyent, Inc.  * Copyright 2017 Nexenta Systems, Inc.  */
end_comment

begin_comment
comment|/* Portions Copyright 2007 Jeremy Teo */
end_comment

begin_comment
comment|/* Portions Copyright 2010 Robert Milkowski */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs_opreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskq.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmsystm.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/vm.h>
end_include

begin_include
include|#
directive|include
file|<vm/seg_vn.h>
end_include

begin_include
include|#
directive|include
file|<vm/pvn.h>
end_include

begin_include
include|#
directive|include
file|<vm/as.h>
end_include

begin_include
include|#
directive|include
file|<vm/kpm.h>
end_include

begin_include
include|#
directive|include
file|<vm/seg_kpm.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/pathname.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/filio.h>
end_include

begin_include
include|#
directive|include
file|<sys/sid.h>
end_include

begin_include
include|#
directive|include
file|"fs/fs_subr.h"
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_fuid.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_sa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnlc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/extdirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/kidmap.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/attr.h>
end_include

begin_comment
comment|/*  * Programming rules.  *  * Each vnode op performs some logical unit of work.  To do this, the ZPL must  * properly lock its in-core state, create a DMU transaction, do the work,  * record this work in the intent log (ZIL), commit the DMU transaction,  * and wait for the intent log to commit if it is a synchronous operation.  * Moreover, the vnode ops must work in both normal and log replay context.  * The ordering of events is important to avoid deadlocks and references  * to freed memory.  The example below illustrates the following Big Rules:  *  *  (1)	A check must be made in each zfs thread for a mounted file system.  *	This is done avoiding races using ZFS_ENTER(zfsvfs).  *	A ZFS_EXIT(zfsvfs) is needed before all returns.  Any znodes  *	must be checked with ZFS_VERIFY_ZP(zp).  Both of these macros  *	can return EIO from the calling function.  *  *  (2)	VN_RELE() should always be the last thing except for zil_commit()  *	(if necessary) and ZFS_EXIT(). This is for 3 reasons:  *	First, if it's the last reference, the vnode/znode  *	can be freed, so the zp may point to freed memory.  Second, the last  *	reference will call zfs_zinactive(), which may induce a lot of work --  *	pushing cached pages (which acquires range locks) and syncing out  *	cached atime changes.  Third, zfs_zinactive() may require a new tx,  *	which could deadlock the system if you were already holding one.  *	If you must call VN_RELE() within a tx then use VN_RELE_ASYNC().  *  *  (3)	All range locks must be grabbed before calling dmu_tx_assign(),  *	as they can span dmu_tx_assign() calls.  *  *  (4) If ZPL locks are held, pass TXG_NOWAIT as the second argument to  *      dmu_tx_assign().  This is critical because we don't want to block  *      while holding locks.  *  *	If no ZPL locks are held (aside from ZFS_ENTER()), use TXG_WAIT.  This  *	reduces lock contention and CPU usage when we must wait (note that if  *	throughput is constrained by the storage, nearly every transaction  *	must wait).  *  *      Note, in particular, that if a lock is sometimes acquired before  *      the tx assigns, and sometimes after (e.g. z_lock), then failing  *      to use a non-blocking assign can deadlock the system.  The scenario:  *  *	Thread A has grabbed a lock before calling dmu_tx_assign().  *	Thread B is in an already-assigned tx, and blocks for this lock.  *	Thread A calls dmu_tx_assign(TXG_WAIT) and blocks in txg_wait_open()  *	forever, because the previous txg can't quiesce until B's tx commits.  *  *	If dmu_tx_assign() returns ERESTART and zfsvfs->z_assign is TXG_NOWAIT,  *	then drop all locks, call dmu_tx_wait(), and try again.  On subsequent  *	calls to dmu_tx_assign(), pass TXG_WAITED rather than TXG_NOWAIT,  *	to indicate that this operation has already called dmu_tx_wait().  *	This will ensure that we don't retry forever, waiting a short bit  *	each time.  *  *  (5)	If the operation succeeded, generate the intent log entry for it  *	before dropping locks.  This ensures that the ordering of events  *	in the intent log matches the order in which they actually occurred.  *	During ZIL replay the zfs_log_* functions will update the sequence  *	number to indicate the zil transaction has replayed.  *  *  (6)	At the end of each vnode op, the DMU tx must always commit,  *	regardless of whether there were any errors.  *  *  (7)	After dropping all locks, invoke zil_commit(zilog, foid)  *	to ensure that synchronous semantics are provided when necessary.  *  * In general, this is how things should be ordered in each vnode op:  *  *	ZFS_ENTER(zfsvfs);		// exit if unmounted  * top:  *	zfs_dirent_lock(&dl, ...)	// lock directory entry (may VN_HOLD())  *	rw_enter(...);			// grab any other locks you need  *	tx = dmu_tx_create(...);	// get DMU tx  *	dmu_tx_hold_*();		// hold each object you might modify  *	error = dmu_tx_assign(tx, waited ? TXG_WAITED : TXG_NOWAIT);  *	if (error) {  *		rw_exit(...);		// drop locks  *		zfs_dirent_unlock(dl);	// unlock directory entry  *		VN_RELE(...);		// release held vnodes  *		if (error == ERESTART) {  *			waited = B_TRUE;  *			dmu_tx_wait(tx);  *			dmu_tx_abort(tx);  *			goto top;  *		}  *		dmu_tx_abort(tx);	// abort DMU tx  *		ZFS_EXIT(zfsvfs);	// finished in zfs  *		return (error);		// really out of space  *	}  *	error = do_real_work();		// do whatever this VOP does  *	if (error == 0)  *		zfs_log_*(...);		// on success, make ZIL entry  *	dmu_tx_commit(tx);		// commit DMU tx -- error or not  *	rw_exit(...);			// drop locks  *	zfs_dirent_unlock(dl);		// unlock directory entry  *	VN_RELE(...);			// release held vnodes  *	zil_commit(zilog, foid);	// synchronous when necessary  *	ZFS_EXIT(zfsvfs);		// finished in zfs  *	return (error);			// done, report error  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_open
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|&&
operator|(
operator|(
name|flag
operator|&
name|FAPPEND
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|zfs_has_ctldir
argument_list|(
name|zp
argument_list|)
operator|&&
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vscan
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|&&
name|zp
operator|->
name|z_size
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fs_vscan
argument_list|(
operator|*
name|vpp
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
block|}
comment|/* Keep a count of the synchronous opens in the znode */
if|if
condition|(
name|flag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
condition|)
name|atomic_inc_32
argument_list|(
operator|&
name|zp
operator|->
name|z_sync_cnt
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_close
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|count
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
comment|/* 	 * Clean up any locks held by this process on the vp. 	 */
name|cleanlocks
argument_list|(
name|vp
argument_list|,
name|ddi_get_pid
argument_list|()
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cleanshares
argument_list|(
name|vp
argument_list|,
name|ddi_get_pid
argument_list|()
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* Decrement the synchronous opens in the znode */
if|if
condition|(
operator|(
name|flag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
operator|)
operator|&&
operator|(
name|count
operator|==
literal|1
operator|)
condition|)
name|atomic_dec_32
argument_list|(
operator|&
name|zp
operator|->
name|z_sync_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_has_ctldir
argument_list|(
name|zp
argument_list|)
operator|&&
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vscan
operator|&&
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|&&
name|zp
operator|->
name|z_size
operator|>
literal|0
condition|)
name|VERIFY
argument_list|(
name|fs_vscan
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lseek support for finding holes (cmd == _FIO_SEEK_HOLE) and  * data (cmd == _FIO_SEEK_DATA). "off" is an in/out parameter.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_holey
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|offset_t
modifier|*
name|off
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|uint64_t
name|noff
init|=
operator|(
name|uint64_t
operator|)
operator|*
name|off
decl_stmt|;
comment|/* new offset */
name|uint64_t
name|file_sz
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|hole
decl_stmt|;
name|file_sz
operator|=
name|zp
operator|->
name|z_size
expr_stmt|;
if|if
condition|(
name|noff
operator|>=
name|file_sz
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|cmd
operator|==
name|_FIO_SEEK_HOLE
condition|)
name|hole
operator|=
name|B_TRUE
expr_stmt|;
else|else
name|hole
operator|=
name|B_FALSE
expr_stmt|;
name|error
operator|=
name|dmu_offset_next
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|hole
argument_list|,
operator|&
name|noff
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ESRCH
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
comment|/* 	 * We could find a hole that begins after the logical end-of-file, 	 * because dmu_offset_next() only works on whole blocks.  If the 	 * EOF falls mid-block, then indicate that the "virtual hole" 	 * at the end of the file begins at the logical EOF, rather than 	 * at the end of the last block. 	 */
if|if
condition|(
name|noff
operator|>
name|file_sz
condition|)
block|{
name|ASSERT
argument_list|(
name|hole
argument_list|)
expr_stmt|;
name|noff
operator|=
name|file_sz
expr_stmt|;
block|}
if|if
condition|(
name|noff
operator|<
operator|*
name|off
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|off
operator|=
name|noff
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_ioctl
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|com
parameter_list|,
name|intptr_t
name|data
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cred
parameter_list|,
name|int
modifier|*
name|rvalp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|offset_t
name|off
decl_stmt|;
name|offset_t
name|ndata
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
switch|switch
condition|(
name|com
condition|)
block|{
case|case
name|_FIOFFS
case|:
block|{
return|return
operator|(
name|zfs_sync
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
literal|0
argument_list|,
name|cred
argument_list|)
operator|)
return|;
comment|/* 		 * The following two ioctls are used by bfu.  Faking out, 		 * necessary to avoid bfu errors. 		 */
block|}
case|case
name|_FIOGDIO
case|:
case|case
name|_FIOSDIO
case|:
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|_FIO_SEEK_DATA
case|:
case|case
name|_FIO_SEEK_HOLE
case|:
block|{
if|if
condition|(
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
operator|&
name|off
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* offset parameter is in/out */
name|error
operator|=
name|zfs_holey
argument_list|(
name|vp
argument_list|,
name|com
argument_list|,
operator|&
name|off
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|off
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|off
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|_FIO_COUNT_FILLED
case|:
block|{
comment|/* 		 * _FIO_COUNT_FILLED adds a new ioctl command which 		 * exposes the number of filled blocks in a 		 * ZFS object. 		 */
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for all dirty blocks for this object 		 * to get synced out to disk, and the DMU info 		 * updated. 		 */
name|error
operator|=
name|dmu_object_wait_synced
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Retrieve fill count from DMU object. 		 */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|ndata
operator|=
name|doi
operator|.
name|doi_fill_count
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|ndata
argument_list|,
operator|(
name|void
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|ndata
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTTY
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility functions to map and unmap a single physical page.  These  * are used to manage the mappable copies of ZFS file data, and therefore  * do not update ref/mod bits.  */
end_comment

begin_function
name|caddr_t
name|zfs_map_page
parameter_list|(
name|page_t
modifier|*
name|pp
parameter_list|,
name|enum
name|seg_rw
name|rw
parameter_list|)
block|{
if|if
condition|(
name|kpm_enable
condition|)
return|return
operator|(
name|hat_kpm_mapin
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|rw
operator|==
name|S_READ
operator|||
name|rw
operator|==
name|S_WRITE
argument_list|)
expr_stmt|;
return|return
operator|(
name|ppmapin
argument_list|(
name|pp
argument_list|,
name|PROT_READ
operator||
operator|(
operator|(
name|rw
operator|==
name|S_WRITE
operator|)
condition|?
name|PROT_WRITE
else|:
literal|0
operator|)
argument_list|,
operator|(
name|caddr_t
operator|)
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_unmap_page
parameter_list|(
name|page_t
modifier|*
name|pp
parameter_list|,
name|caddr_t
name|addr
parameter_list|)
block|{
if|if
condition|(
name|kpm_enable
condition|)
block|{
name|hat_kpm_mapout
argument_list|(
name|pp
argument_list|,
literal|0
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ppmapout
argument_list|(
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * When a file is memory mapped, we must keep the IO data synchronized  * between the DMU cache and the memory mapped pages.  What this means:  *  * On Write:	If we find a memory mapped page, we write to *both*  *		the page and the dmu buffer.  */
end_comment

begin_function
specifier|static
name|void
name|update_pages
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int64_t
name|start
parameter_list|,
name|int
name|len
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|oid
parameter_list|)
block|{
name|int64_t
name|off
decl_stmt|;
name|off
operator|=
name|start
operator|&
name|PAGEOFFSET
expr_stmt|;
for|for
control|(
name|start
operator|&=
name|PAGEMASK
init|;
name|len
operator|>
literal|0
condition|;
name|start
operator|+=
name|PAGESIZE
control|)
block|{
name|page_t
modifier|*
name|pp
decl_stmt|;
name|uint64_t
name|nbytes
init|=
name|MIN
argument_list|(
name|PAGESIZE
operator|-
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp
operator|=
name|page_lookup
argument_list|(
name|vp
argument_list|,
name|start
argument_list|,
name|SE_SHARED
argument_list|)
condition|)
block|{
name|caddr_t
name|va
decl_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
name|S_WRITE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_read
argument_list|(
name|os
argument_list|,
name|oid
argument_list|,
name|start
operator|+
name|off
argument_list|,
name|nbytes
argument_list|,
name|va
operator|+
name|off
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|pp
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|page_unlock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|nbytes
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * When a file is memory mapped, we must keep the IO data synchronized  * between the DMU cache and the memory mapped pages.  What this means:  *  * On Read:	We "read" preferentially from memory mapped pages,  *		else we default from the dmu buffer.  *  * NOTE: We will always "break up" the IO into PAGESIZE uiomoves when  *	 the file is memory mapped.  */
end_comment

begin_function
specifier|static
name|int
name|mappedread
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|nbytes
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|int64_t
name|start
decl_stmt|,
name|off
decl_stmt|;
name|int
name|len
init|=
name|nbytes
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|start
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|off
operator|=
name|start
operator|&
name|PAGEOFFSET
expr_stmt|;
for|for
control|(
name|start
operator|&=
name|PAGEMASK
init|;
name|len
operator|>
literal|0
condition|;
name|start
operator|+=
name|PAGESIZE
control|)
block|{
name|page_t
modifier|*
name|pp
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|PAGESIZE
operator|-
name|off
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
name|pp
operator|=
name|page_lookup
argument_list|(
name|vp
argument_list|,
name|start
argument_list|,
name|SE_SHARED
argument_list|)
condition|)
block|{
name|caddr_t
name|va
decl_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
name|S_READ
argument_list|)
expr_stmt|;
name|error
operator|=
name|uiomove
argument_list|(
name|va
operator|+
name|off
argument_list|,
name|bytes
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|pp
argument_list|,
name|va
argument_list|)
expr_stmt|;
name|page_unlock
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_read_uio_dbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|uio
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
block|}
name|len
operator|-=
name|bytes
expr_stmt|;
name|off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|offset_t
name|zfs_read_chunk_size
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tunable */
end_comment

begin_comment
comment|/*  * Read bytes from specified file into supplied buffer.  *  *	IN:	vp	- vnode of file to be read from.  *		uio	- structure supplying read location, range info,  *			  and return buffer.  *		ioflag	- SYNC flags; used to provide FRSYNC semantics.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	uio	- updated offset and range, buffer filled.  *  *	RETURN:	0 on success, error code on failure.  *  * Side Effects:  *	vp - atime updated if byte count> 0  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_read
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ssize_t
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|xuio_t
modifier|*
name|xuio
init|=
name|NULL
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Validate file offset 	 */
if|if
condition|(
name|uio
operator|->
name|uio_loffset
operator|<
operator|(
name|offset_t
operator|)
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Fasttrack empty reads 	 */
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check for mandatory locks 	 */
if|if
condition|(
name|MANDMODE
argument_list|(
name|zp
operator|->
name|z_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|chklock
argument_list|(
name|vp
argument_list|,
name|FREAD
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|uio
operator|->
name|uio_fmode
argument_list|,
name|ct
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * If we're in FRSYNC mode, sync out this znode before reading it. 	 */
if|if
condition|(
name|ioflag
operator|&
name|FRSYNC
operator|||
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
comment|/* 	 * Lock the range against changes. 	 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* 	 * If we are reading past end-of-file we can skip 	 * to the end; but we might still need to set atime. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_loffset
operator|>=
name|zp
operator|->
name|z_size
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ASSERT
argument_list|(
name|uio
operator|->
name|uio_loffset
operator|<
name|zp
operator|->
name|z_size
argument_list|)
expr_stmt|;
name|n
operator|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|zp
operator|->
name|z_size
operator|-
name|uio
operator|->
name|uio_loffset
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_extflg
operator|==
name|UIO_XUIO
operator|)
operator|&&
operator|(
operator|(
operator|(
name|xuio_t
operator|*
operator|)
name|uio
operator|)
operator|->
name|xu_type
operator|==
name|UIOTYPE_ZEROCOPY
operator|)
condition|)
block|{
name|int
name|nblk
decl_stmt|;
name|int
name|blksz
init|=
name|zp
operator|->
name|z_blksz
decl_stmt|;
name|uint64_t
name|offset
init|=
name|uio
operator|->
name|uio_loffset
decl_stmt|;
name|xuio
operator|=
operator|(
name|xuio_t
operator|*
operator|)
name|uio
expr_stmt|;
if|if
condition|(
operator|(
name|ISP2
argument_list|(
name|blksz
argument_list|)
operator|)
condition|)
block|{
name|nblk
operator|=
operator|(
name|P2ROUNDUP
argument_list|(
name|offset
operator|+
name|n
argument_list|,
name|blksz
argument_list|)
operator|-
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
name|blksz
argument_list|)
operator|)
operator|/
name|blksz
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|offset
operator|+
name|n
operator|<=
name|blksz
argument_list|)
expr_stmt|;
name|nblk
operator|=
literal|1
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|dmu_xuio_init
argument_list|(
name|xuio
argument_list|,
name|nblk
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* 			 * For simplicity, we always allocate a full buffer 			 * even if we only expect to read a portion of a block. 			 */
while|while
condition|(
operator|--
name|nblk
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|dmu_xuio_add
argument_list|(
name|xuio
argument_list|,
name|dmu_request_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|blksz
argument_list|)
argument_list|,
literal|0
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|nbytes
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|zfs_read_chunk_size
operator|-
name|P2PHASE
argument_list|(
name|uio
operator|->
name|uio_loffset
argument_list|,
name|zfs_read_chunk_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|mappedread
argument_list|(
name|vp
argument_list|,
name|nbytes
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_read_uio_dbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|uio
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
name|n
operator|-=
name|nbytes
expr_stmt|;
block|}
name|out
label|:
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Write the bytes to a file.  *  *	IN:	vp	- vnode of file to be written to.  *		uio	- structure supplying write location, range info,  *			  and data buffer.  *		ioflag	- FAPPEND, FSYNC, and/or FDSYNC.  FAPPEND is  *			  set if in append mode.  *		cr	- credentials of caller.  *		ct	- caller context (NFS/CIFS fem monitor only)  *  *	OUT:	uio	- updated offset and range.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - ctime|mtime updated if byte count> 0  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_write
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|rlim64_t
name|limit
init|=
name|uio
operator|->
name|uio_llimit
decl_stmt|;
name|ssize_t
name|start_resid
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|ssize_t
name|tx_bytes
decl_stmt|;
name|uint64_t
name|end_size
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|offset_t
name|woff
decl_stmt|;
name|ssize_t
name|n
decl_stmt|,
name|nbytes
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|max_blksz
init|=
name|zfsvfs
operator|->
name|z_max_blksz
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
decl_stmt|;
name|iovec_t
modifier|*
name|aiov
init|=
name|NULL
decl_stmt|;
name|xuio_t
modifier|*
name|xuio
init|=
name|NULL
decl_stmt|;
name|int
name|i_iov
init|=
literal|0
decl_stmt|;
name|int
name|iovcnt
init|=
name|uio
operator|->
name|uio_iovcnt
decl_stmt|;
name|iovec_t
modifier|*
name|iovp
init|=
name|uio
operator|->
name|uio_iov
decl_stmt|;
name|int
name|write_eof
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|4
index|]
decl_stmt|;
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|;
comment|/* 	 * Fasttrack empty write 	 */
name|n
operator|=
name|start_resid
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|limit
operator|==
name|RLIM64_INFINITY
operator|||
name|limit
operator|>
name|MAXOFFSET_T
condition|)
name|limit
operator|=
name|MAXOFFSET_T
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mtime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_SIZE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_size
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
comment|/* 	 * In a case vp->v_vfsp != zp->z_zfsvfs->z_vfs (e.g. snapshots) our 	 * callers might not be able to detect properly that we are read-only, 	 * so check it explicitly here. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If immutable or not appending then return EPERM 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_READONLY
operator|)
operator|)
operator|||
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|&&
operator|!
operator|(
name|ioflag
operator|&
name|FAPPEND
operator|)
operator|&&
operator|(
name|uio
operator|->
name|uio_loffset
operator|<
name|zp
operator|->
name|z_size
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Validate file offset 	 */
name|woff
operator|=
name|ioflag
operator|&
name|FAPPEND
condition|?
name|zp
operator|->
name|z_size
else|:
name|uio
operator|->
name|uio_loffset
expr_stmt|;
if|if
condition|(
name|woff
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Check for mandatory locks before calling zfs_range_lock() 	 * in order to prevent a deadlock with locks set via fcntl(). 	 */
if|if
condition|(
name|MANDMODE
argument_list|(
operator|(
name|mode_t
operator|)
name|zp
operator|->
name|z_mode
argument_list|)
operator|&&
operator|(
name|error
operator|=
name|chklock
argument_list|(
name|vp
argument_list|,
name|FWRITE
argument_list|,
name|woff
argument_list|,
name|n
argument_list|,
name|uio
operator|->
name|uio_fmode
argument_list|,
name|ct
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Pre-fault the pages to ensure slow (eg NFS) pages 	 * don't hold up txg. 	 * Skip this if uio contains loaned arc_buf. 	 */
if|if
condition|(
operator|(
name|uio
operator|->
name|uio_extflg
operator|==
name|UIO_XUIO
operator|)
operator|&&
operator|(
operator|(
operator|(
name|xuio_t
operator|*
operator|)
name|uio
operator|)
operator|->
name|xu_type
operator|==
name|UIOTYPE_ZEROCOPY
operator|)
condition|)
name|xuio
operator|=
operator|(
name|xuio_t
operator|*
operator|)
name|uio
expr_stmt|;
else|else
name|uio_prefaultpages
argument_list|(
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
comment|/* 	 * If in append mode, set the io offset pointer to eof. 	 */
if|if
condition|(
name|ioflag
operator|&
name|FAPPEND
condition|)
block|{
comment|/* 		 * Obtain an appending range lock to guarantee file append 		 * semantics.  We reset the write offset once we have the lock. 		 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
name|n
argument_list|,
name|RL_APPEND
argument_list|)
expr_stmt|;
name|woff
operator|=
name|rl
operator|->
name|r_off
expr_stmt|;
if|if
condition|(
name|rl
operator|->
name|r_len
operator|==
name|UINT64_MAX
condition|)
block|{
comment|/* 			 * We overlocked the file because this write will cause 			 * the file block size to increase. 			 * Note that zp_size cannot change with this lock held. 			 */
name|woff
operator|=
name|zp
operator|->
name|z_size
expr_stmt|;
block|}
name|uio
operator|->
name|uio_loffset
operator|=
name|woff
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Note that if the file block size will change as a result of 		 * this write, then this range lock will lock the entire file 		 * so that we can re-write the block safely. 		 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|woff
argument_list|,
name|n
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|woff
operator|>=
name|limit
condition|)
block|{
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFBIG
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|woff
operator|+
name|n
operator|)
operator|>
name|limit
operator|||
name|woff
operator|>
operator|(
name|limit
operator|-
name|n
operator|)
condition|)
name|n
operator|=
name|limit
operator|-
name|woff
expr_stmt|;
comment|/* Will this write extend the file length? */
name|write_eof
operator|=
operator|(
name|woff
operator|+
name|n
operator|>
name|zp
operator|->
name|z_size
operator|)
expr_stmt|;
name|end_size
operator|=
name|MAX
argument_list|(
name|zp
operator|->
name|z_size
argument_list|,
name|woff
operator|+
name|n
argument_list|)
expr_stmt|;
comment|/* 	 * Write the file in reasonable size chunks.  Each chunk is written 	 * in a separate transaction; this keeps the intent log records small 	 * and allows us to do more fine-grained space accounting. 	 */
while|while
condition|(
name|n
operator|>
literal|0
condition|)
block|{
name|abuf
operator|=
name|NULL
expr_stmt|;
name|woff
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
if|if
condition|(
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_FALSE
argument_list|)
operator|||
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_TRUE
argument_list|)
condition|)
block|{
if|if
condition|(
name|abuf
operator|!=
name|NULL
condition|)
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|xuio
operator|&&
name|abuf
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|i_iov
operator|<
name|iovcnt
argument_list|)
expr_stmt|;
name|aiov
operator|=
operator|&
name|iovp
index|[
name|i_iov
index|]
expr_stmt|;
name|abuf
operator|=
name|dmu_xuio_arcbuf
argument_list|(
name|xuio
argument_list|,
name|i_iov
argument_list|)
expr_stmt|;
name|dmu_xuio_clear
argument_list|(
name|xuio
argument_list|,
name|i_iov
argument_list|)
expr_stmt|;
name|DTRACE_PROBE3
argument_list|(
name|zfs_cp_write
argument_list|,
name|int
argument_list|,
name|i_iov
argument_list|,
name|iovec_t
operator|*
argument_list|,
name|aiov
argument_list|,
name|arc_buf_t
operator|*
argument_list|,
name|abuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|aiov
operator|->
name|iov_base
operator|==
name|abuf
operator|->
name|b_data
operator|)
operator|||
operator|(
operator|(
name|char
operator|*
operator|)
name|aiov
operator|->
name|iov_base
operator|-
operator|(
name|char
operator|*
operator|)
name|abuf
operator|->
name|b_data
operator|+
name|aiov
operator|->
name|iov_len
operator|==
name|arc_buf_size
argument_list|(
name|abuf
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|i_iov
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|abuf
operator|==
name|NULL
operator|&&
name|n
operator|>=
name|max_blksz
operator|&&
name|woff
operator|>=
name|zp
operator|->
name|z_size
operator|&&
name|P2PHASE
argument_list|(
name|woff
argument_list|,
name|max_blksz
argument_list|)
operator|==
literal|0
operator|&&
name|zp
operator|->
name|z_blksz
operator|==
name|max_blksz
condition|)
block|{
comment|/* 			 * This write covers a full block.  "Borrow" a buffer 			 * from the dmu so that we can fill it before we enter 			 * a transaction.  This avoids the possibility of 			 * holding up the transaction if the data copy hangs 			 * up on a pagefault (e.g., from an NFS server mapping). 			 */
name|size_t
name|cbytes
decl_stmt|;
name|abuf
operator|=
name|dmu_request_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|max_blksz
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abuf
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|arc_buf_size
argument_list|(
name|abuf
argument_list|)
operator|==
name|max_blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|uiocopy
argument_list|(
name|abuf
operator|->
name|b_data
argument_list|,
name|max_blksz
argument_list|,
name|UIO_WRITE
argument_list|,
name|uio
argument_list|,
operator|&
name|cbytes
argument_list|)
condition|)
block|{
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
break|break;
block|}
name|ASSERT
argument_list|(
name|cbytes
operator|==
name|max_blksz
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Start a transaction. 		 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|woff
argument_list|,
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|abuf
operator|!=
name|NULL
condition|)
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * If zfs_range_lock() over-locked we grow the blocksize 		 * and then reduce the lock range.  This will only happen 		 * on the first iteration since zfs_range_reduce() will 		 * shrink down r_len to the appropriate size. 		 */
if|if
condition|(
name|rl
operator|->
name|r_len
operator|==
name|UINT64_MAX
condition|)
block|{
name|uint64_t
name|new_blksz
decl_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|>
name|max_blksz
condition|)
block|{
comment|/* 				 * File's blocksize is already larger than the 				 * "recordsize" property.  Only let it grow to 				 * the next power of 2. 				 */
name|ASSERT
argument_list|(
operator|!
name|ISP2
argument_list|(
name|zp
operator|->
name|z_blksz
argument_list|)
argument_list|)
expr_stmt|;
name|new_blksz
operator|=
name|MIN
argument_list|(
name|end_size
argument_list|,
literal|1
operator|<<
name|highbit64
argument_list|(
name|zp
operator|->
name|z_blksz
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new_blksz
operator|=
name|MIN
argument_list|(
name|end_size
argument_list|,
name|max_blksz
argument_list|)
expr_stmt|;
block|}
name|zfs_grow_blocksize
argument_list|(
name|zp
argument_list|,
name|new_blksz
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_range_reduce
argument_list|(
name|rl
argument_list|,
name|woff
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * XXX - should we really limit each write to z_max_blksz? 		 * Perhaps we should use SPA_MAXBLOCKSIZE chunks? 		 */
name|nbytes
operator|=
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
operator|-
name|P2PHASE
argument_list|(
name|woff
argument_list|,
name|max_blksz
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|abuf
operator|==
name|NULL
condition|)
block|{
name|tx_bytes
operator|=
name|uio
operator|->
name|uio_resid
expr_stmt|;
name|error
operator|=
name|dmu_write_uio_dbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|uio
argument_list|,
name|nbytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|tx_bytes
operator|-=
name|uio
operator|->
name|uio_resid
expr_stmt|;
block|}
else|else
block|{
name|tx_bytes
operator|=
name|nbytes
expr_stmt|;
name|ASSERT
argument_list|(
name|xuio
operator|==
name|NULL
operator|||
name|tx_bytes
operator|==
name|aiov
operator|->
name|iov_len
argument_list|)
expr_stmt|;
comment|/* 			 * If this is not a full block write, but we are 			 * extending the file past EOF and this data starts 			 * block-aligned, use assign_arcbuf().  Otherwise, 			 * write via dmu_write(). 			 */
if|if
condition|(
name|tx_bytes
operator|<
name|max_blksz
operator|&&
operator|(
operator|!
name|write_eof
operator|||
name|aiov
operator|->
name|iov_base
operator|!=
name|abuf
operator|->
name|b_data
operator|)
condition|)
block|{
name|ASSERT
argument_list|(
name|xuio
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|woff
argument_list|,
name|aiov
operator|->
name|iov_len
argument_list|,
name|aiov
operator|->
name|iov_base
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
name|xuio_stat_wbuf_copied
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|xuio
operator|||
name|tx_bytes
operator|==
name|max_blksz
argument_list|)
expr_stmt|;
name|dmu_assign_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|woff
argument_list|,
name|abuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|tx_bytes
operator|<=
name|uio
operator|->
name|uio_resid
argument_list|)
expr_stmt|;
name|uioskip
argument_list|(
name|uio
argument_list|,
name|tx_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx_bytes
operator|&&
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|update_pages
argument_list|(
name|vp
argument_list|,
name|woff
argument_list|,
name|tx_bytes
argument_list|,
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we made no progress, we're done.  If we made even 		 * partial progress, update the znode and ZIL accordingly. 		 */
if|if
condition|(
name|tx_bytes
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SIZE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_size
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Clear Set-UID/Set-GID bits on successful write if not 		 * privileged and at least one of the excute bits is set. 		 * 		 * It would be nice to to this after all writes have 		 * been done, but that would still expose the ISUID/ISGID 		 * to another app after the partial write is committed. 		 * 		 * Note: we don't call zfs_fuid_map_id() here because 		 * user 0 is not an ephemeral uid. 		 */
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zp
operator|->
name|z_mode
operator|&
operator|(
name|S_IXUSR
operator||
operator|(
name|S_IXUSR
operator|>>
literal|3
operator|)
operator||
operator|(
name|S_IXUSR
operator|>>
literal|6
operator|)
operator|)
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|zp
operator|->
name|z_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
operator|)
operator|!=
literal|0
operator|&&
name|secpolicy_vnode_setid_retain
argument_list|(
name|cr
argument_list|,
operator|(
name|zp
operator|->
name|z_mode
operator|&
name|S_ISUID
operator|)
operator|!=
literal|0
operator|&&
name|zp
operator|->
name|z_uid
operator|==
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|uint64_t
name|newmode
decl_stmt|;
name|zp
operator|->
name|z_mode
operator|&=
operator|~
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator|)
expr_stmt|;
name|newmode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_MODE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|newmode
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 		 * Update the file size (zp_size) if it has changed; 		 * account for possible concurrent updates. 		 */
while|while
condition|(
operator|(
name|end_size
operator|=
name|zp
operator|->
name|z_size
operator|)
operator|<
name|uio
operator|->
name|uio_loffset
condition|)
block|{
operator|(
name|void
operator|)
name|atomic_cas_64
argument_list|(
operator|&
name|zp
operator|->
name|z_size
argument_list|,
name|end_size
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If we are replaying and eof is non zero then force 		 * the file size to the specified eof. Note, there's no 		 * concurrency during replay. 		 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_replay
operator|&&
name|zfsvfs
operator|->
name|z_replay_eof
operator|!=
literal|0
condition|)
name|zp
operator|->
name|z_size
operator|=
name|zfsvfs
operator|->
name|z_replay_eof
expr_stmt|;
name|error
operator|=
name|sa_bulk_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_log_write
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_WRITE
argument_list|,
name|zp
argument_list|,
name|woff
argument_list|,
name|tx_bytes
argument_list|,
name|ioflag
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|ASSERT
argument_list|(
name|tx_bytes
operator|==
name|nbytes
argument_list|)
expr_stmt|;
name|n
operator|-=
name|nbytes
expr_stmt|;
if|if
condition|(
operator|!
name|xuio
operator|&&
name|n
operator|>
literal|0
condition|)
name|uio_prefaultpages
argument_list|(
name|MIN
argument_list|(
name|n
argument_list|,
name|max_blksz
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* 	 * If we're in replay mode, or we made no progress, return error. 	 * Otherwise, it's at least a partial write, so it's successful. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_replay
operator|||
name|uio
operator|->
name|uio_resid
operator|==
name|start_resid
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|ioflag
operator|&
operator|(
name|FSYNC
operator||
name|FDSYNC
operator|)
operator|||
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zfs_get_done
parameter_list|(
name|zgd_t
modifier|*
name|zgd
parameter_list|,
name|int
name|error
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|zgd
operator|->
name|zgd_private
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
if|if
condition|(
name|zgd
operator|->
name|zgd_db
condition|)
name|dmu_buf_rele
argument_list|(
name|zgd
operator|->
name|zgd_db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|zgd
operator|->
name|zgd_rl
argument_list|)
expr_stmt|;
comment|/* 	 * Release the vnode asynchronously as we currently have the 	 * txg stopped from syncing. 	 */
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zgd
operator|->
name|zgd_bp
condition|)
name|zil_add_block
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|zil_fault_io
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Get data to generate a TX_WRITE intent log record.  */
end_comment

begin_function
name|int
name|zfs_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zfsvfs
operator|->
name|z_os
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|uint64_t
name|object
init|=
name|lr
operator|->
name|lr_foid
decl_stmt|;
name|uint64_t
name|offset
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|uint64_t
name|size
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Nothing to do if the file has been removed 	 */
if|if
condition|(
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|object
argument_list|,
operator|&
name|zp
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
if|if
condition|(
name|zp
operator|->
name|z_unlinked
condition|)
block|{
comment|/* 		 * Release the vnode asynchronously as we currently have the 		 * txg stopped from syncing. 		 */
name|VN_RELE_ASYNC
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|dsl_pool_vnrele_taskq
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
name|zgd
operator|=
operator|(
name|zgd_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
name|zgd
operator|->
name|zgd_private
operator|=
name|zp
expr_stmt|;
comment|/* 	 * Write records come in two flavors: immediate and indirect. 	 * For small writes it's cheaper to store the data with the 	 * log record (immediate); for large writes it's cheaper to 	 * sync the data and get a pointer to it (indirect) so that 	 * we don't have to write the data twice. 	 */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* immediate write */
name|zgd
operator|->
name|zgd_rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* test for truncation needs to be done while range locked */
if|if
condition|(
name|offset
operator|>=
name|zp
operator|->
name|z_size
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|error
operator|==
name|ENOENT
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* indirect write */
comment|/* 		 * Have to lock the whole block to ensure when it's 		 * written out and it's checksum is being calculated 		 * that no one can change the data. We need to re-check 		 * blocksize after we get the lock in case it's changed! 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|blkoff
decl_stmt|;
name|size
operator|=
name|zp
operator|->
name|z_blksz
expr_stmt|;
name|blkoff
operator|=
name|ISP2
argument_list|(
name|size
argument_list|)
condition|?
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
else|:
name|offset
expr_stmt|;
name|offset
operator|-=
name|blkoff
expr_stmt|;
name|zgd
operator|->
name|zgd_rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|==
name|size
condition|)
break|break;
name|offset
operator|+=
name|blkoff
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|zgd
operator|->
name|zgd_rl
argument_list|)
expr_stmt|;
block|}
comment|/* test for truncation needs to be done while range locked */
if|if
condition|(
name|lr
operator|->
name|lr_offset
operator|>=
name|zp
operator|->
name|z_size
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|zil_fault_io
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
name|zil_fault_io
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|blkptr_t
modifier|*
name|obp
init|=
name|dmu_buf_get_blkptr
argument_list|(
name|db
argument_list|)
decl_stmt|;
if|if
condition|(
name|obp
condition|)
block|{
name|ASSERT
argument_list|(
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|bp
operator|=
operator|*
name|obp
expr_stmt|;
block|}
name|zgd
operator|->
name|zgd_db
operator|=
name|db
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
name|bp
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_offset
operator|==
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|zfs_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|||
name|lr
operator|->
name|lr_length
operator|<=
name|zp
operator|->
name|z_blksz
argument_list|)
expr_stmt|;
comment|/* 			 * On success, we need to wait for the write I/O 			 * initiated by dmu_sync() to complete before we can 			 * release this dbuf.  We will finish everything up 			 * in the zfs_get_done() callback. 			 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
operator|==
name|EALREADY
condition|)
block|{
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txtype
operator|=
name|TX_WRITE2
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
name|zfs_get_done
argument_list|(
name|zgd
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_access
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|V_ACE_MASK
condition|)
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|flag
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zfs_zaccess_rwx
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|flag
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If vnode is for a device return a specfs vnode instead.  */
end_comment

begin_function
specifier|static
name|int
name|specvp_check
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|IS_DEVVP
argument_list|(
operator|*
name|vpp
argument_list|)
condition|)
block|{
name|struct
name|vnode
modifier|*
name|svp
decl_stmt|;
name|svp
operator|=
name|specvp
argument_list|(
operator|*
name|vpp
argument_list|,
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_rdev
argument_list|,
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|svp
operator|==
name|NULL
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOSYS
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|svp
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup an entry in a directory, or an extended attribute directory.  * If it exists, return a held vnode reference for it.  *  *	IN:	dvp	- vnode of directory to search.  *		nm	- name of entry to lookup.  *		pnp	- full pathname to lookup [UNUSED].  *		flags	- LOOKUP_XATTR set if looking for an attribute.  *		rdir	- root directory vnode [UNUSED].  *		cr	- credentials of caller.  *		ct	- caller context  *		direntflags - directory lookup flags  *		realpnp - returned pathname.  *  *	OUT:	vpp	- vnode of located entry, NULL if not found.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	NA  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|struct
name|pathname
modifier|*
name|pnp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
name|rdir
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
name|znode_t
modifier|*
name|zdp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zdp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
comment|/* 	 * Fast path lookup, however we must skip DNLC lookup 	 * for case folding or normalizing lookups because the 	 * DNLC code only stores the passed in name.  This means 	 * creating 'a' and removing 'A' on a case insensitive 	 * file system would work, but DNLC still thinks 'a' 	 * exists and won't let you create it again on the next 	 * pass through fast path. 	 */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
operator|(
name|LOOKUP_XATTR
operator||
name|FIGNORECASE
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|zdp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nm
index|[
literal|0
index|]
operator|==
literal|0
operator|||
operator|(
name|nm
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|nm
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|)
condition|)
block|{
name|error
operator|=
name|zfs_fastaccesschk_execute
argument_list|(
name|zdp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
name|VN_HOLD
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|zdp
operator|->
name|z_zfsvfs
operator|->
name|z_norm
operator|&&
operator|(
name|zdp
operator|->
name|z_zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_SENSITIVE
operator|)
condition|)
block|{
name|vnode_t
modifier|*
name|tvp
init|=
name|dnlc_lookup
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|)
decl_stmt|;
if|if
condition|(
name|tvp
condition|)
block|{
name|error
operator|=
name|zfs_fastaccesschk_execute
argument_list|(
name|zdp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VN_RELE
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|tvp
operator|==
name|DNLC_NO_VNODE
condition|)
block|{
name|VN_RELE
argument_list|(
name|tvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
else|else
block|{
operator|*
name|vpp
operator|=
name|tvp
expr_stmt|;
return|return
operator|(
name|specvp_check
argument_list|(
name|vpp
argument_list|,
name|cr
argument_list|)
operator|)
return|;
block|}
block|}
block|}
block|}
name|DTRACE_PROBE2
argument_list|(
name|zfs__fastpath__lookup__miss
argument_list|,
name|vnode_t
operator|*
argument_list|,
name|dvp
argument_list|,
name|char
operator|*
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zdp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|LOOKUP_XATTR
condition|)
block|{
comment|/* 		 * If the xattr property is off, refuse the lookup request. 		 */
if|if
condition|(
operator|!
operator|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * We don't allow recursive attributes.. 		 * Maybe someday we will. 		 */
if|if
condition|(
name|zdp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_get_xattrdir
argument_list|(
name|VTOZ
argument_list|(
name|dvp
argument_list|)
argument_list|,
name|vpp
argument_list|,
name|cr
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Do we have permission to get into attribute directory? 		 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
argument_list|,
name|ACE_EXECUTE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|dvp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Check accessibility of directory. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zdp
argument_list|,
name|ACE_EXECUTE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|nm
argument_list|,
name|strlen
argument_list|(
name|nm
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
name|error
operator|=
name|zfs_dirlook
argument_list|(
name|zdp
argument_list|,
name|nm
argument_list|,
name|vpp
argument_list|,
name|flags
argument_list|,
name|direntflags
argument_list|,
name|realpnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|specvp_check
argument_list|(
name|vpp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attempt to create a new entry in a directory.  If the entry  * already exists, truncate the file if permissible, else return  * an error.  Return the vp of the created or trunc'd file.  *  *	IN:	dvp	- vnode of directory to put new file entry in.  *		name	- name of new file entry.  *		vap	- attributes of new file.  *		excl	- flag indicating exclusive or non-exclusive mode.  *		mode	- mode to open file with.  *		cr	- credentials of caller.  *		flag	- large file flag [UNUSED].  *		ct	- caller context  *		vsecp	- ACL to be set  *  *	OUT:	vpp	- vnode of created or trunc'd entry.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated if new entry created  *	 vp - ctime|mtime always, atime if new  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_create
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vcexcl_t
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
name|flag
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ksid_t
modifier|*
name|ksid
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
init|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|zfs_acl_ids_t
name|acl_ids
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
name|boolean_t
name|have_acl
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|waited
init|=
name|B_FALSE
decl_stmt|;
comment|/* 	 * If we have an ephemeral id, ACL, or XVATTR then 	 * make sure file system is at proper version 	 */
name|ksid
operator|=
name|crgetsid
argument_list|(
name|cr
argument_list|,
name|KSID_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksid
condition|)
name|uid
operator|=
name|ksid_getid
argument_list|(
name|ksid
argument_list|)
expr_stmt|;
else|else
name|uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
name|vsecp
operator|||
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|uid
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|gid
argument_list|)
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|secpolicy_xvattr
argument_list|(
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
argument_list|,
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|,
name|cr
argument_list|,
name|vap
operator|->
name|va_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|top
label|:
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mode
operator|&
name|VSVTX
operator|)
operator|&&
name|secpolicy_vnode_stky_modify
argument_list|(
name|cr
argument_list|)
condition|)
name|vap
operator|->
name|va_mode
operator|&=
operator|~
name|VSVTX
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
block|{
comment|/* 		 * Null component name refers to the directory itself. 		 */
name|VN_HOLD
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|zp
operator|=
name|dzp
expr_stmt|;
name|dl
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* possible VN_HOLD(zp) */
name|int
name|zflg
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|flag
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|have_acl
condition|)
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EISDIR
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
name|zp
operator|==
name|NULL
condition|)
block|{
name|uint64_t
name|txtype
decl_stmt|;
comment|/* 		 * Create a new file object and update the directory 		 * to reference it. 		 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
if|if
condition|(
name|have_acl
condition|)
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * We only support the creation of regular files in 		 * extended attribute directories. 		 */
if|if
condition|(
operator|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_type
operator|!=
name|VREG
operator|)
condition|)
block|{
if|if
condition|(
name|have_acl
condition|)
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|!
name|have_acl
operator|&&
operator|(
name|error
operator|=
name|zfs_acl_ids_create
argument_list|(
name|dzp
argument_list|,
literal|0
argument_list|,
name|vap
argument_list|,
name|cr
argument_list|,
name|vsecp
argument_list|,
operator|&
name|acl_ids
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|have_acl
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zfs_acl_ids_overquota
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acl_ids
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa_create
argument_list|(
name|tx
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|+
name|ZFS_SA_BASE_ATTR_SIZE
argument_list|)
expr_stmt|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_sa
operator|&&
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|waited
condition|?
name|TXG_WAITED
else|:
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|waited
operator|=
name|B_TRUE
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
name|txtype
operator|=
name|zfs_log_create_txtype
argument_list|(
name|Z_FILE
argument_list|,
name|vsecp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_create
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|name
argument_list|,
name|vsecp
argument_list|,
name|acl_ids
operator|.
name|z_fuidp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|aflags
init|=
operator|(
name|flag
operator|&
name|FAPPEND
operator|)
condition|?
name|V_APPEND
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|have_acl
condition|)
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|have_acl
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 		 * A directory entry already exists for this name. 		 */
comment|/* 		 * Can't truncate an existing file if in exclusive mode. 		 */
if|if
condition|(
name|excl
operator|==
name|EXCL
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Can't open a directory for writing. 		 */
if|if
condition|(
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
operator|)
operator|&&
operator|(
name|mode
operator|&
name|S_IWRITE
operator|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EISDIR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Verify requested access to file. 		 */
if|if
condition|(
name|mode
operator|&&
operator|(
name|error
operator|=
name|zfs_zaccess_rwx
argument_list|(
name|zp
argument_list|,
name|mode
argument_list|,
name|aflags
argument_list|,
name|cr
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dzp
operator|->
name|z_seq
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Truncate regular files if requested. 		 */
if|if
condition|(
operator|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_SIZE
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_size
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* we can't hold any locks when calling zfs_freesp() */
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|dl
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|zfs_freesp
argument_list|(
name|zp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vnevent_create
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|out
label|:
if|if
condition|(
name|dl
condition|)
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|zp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|specvp_check
argument_list|(
name|vpp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove an entry from a directory.  *  *	IN:	dvp	- vnode of directory to remove entry from.  *		name	- name of entry to remove.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime  *	 vp - ctime (if nlink> 0)  */
end_comment

begin_decl_stmt
name|uint64_t
name|null_xattr
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_remove
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|xzp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|,
name|xattr_obj
decl_stmt|;
name|uint64_t
name|xattr_obj_unlinked
init|=
literal|0
decl_stmt|;
name|uint64_t
name|obj
init|=
literal|0
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|boolean_t
name|may_delete_now
decl_stmt|,
name|delete_now
init|=
name|FALSE
decl_stmt|;
name|boolean_t
name|unlinked
decl_stmt|,
name|toobig
init|=
name|FALSE
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|pathname_t
modifier|*
name|realnmp
init|=
name|NULL
decl_stmt|;
name|pathname_t
name|realnm
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zflg
init|=
name|ZEXISTS
decl_stmt|;
name|boolean_t
name|waited
init|=
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
block|{
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|pn_alloc
argument_list|(
operator|&
name|realnm
argument_list|)
expr_stmt|;
name|realnmp
operator|=
operator|&
name|realnm
expr_stmt|;
block|}
name|top
label|:
name|xattr_obj
operator|=
literal|0
expr_stmt|;
name|xzp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Attempt to lock directory; fail if entry doesn't exist. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|realnmp
argument_list|)
condition|)
block|{
if|if
condition|(
name|realnmp
condition|)
name|pn_free
argument_list|(
name|realnmp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Need to use rmdir for removing directories. 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vnevent_remove
argument_list|(
name|vp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|realnmp
condition|)
name|dnlc_remove
argument_list|(
name|dvp
argument_list|,
name|realnmp
operator|->
name|pn_buf
argument_list|)
expr_stmt|;
else|else
name|dnlc_remove
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|may_delete_now
operator|=
name|vp
operator|->
name|v_count
operator|==
literal|1
operator|&&
operator|!
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We may delete the znode now, or we may put it in the unlinked set; 	 * it depends on whether we're the last link, and on whether there are 	 * other holds on the vnode.  So we dmu_tx_hold() the right things to 	 * allow for either case. 	 */
name|obj
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|dzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|may_delete_now
condition|)
block|{
name|toobig
operator|=
name|zp
operator|->
name|z_size
operator|>
name|zp
operator|->
name|z_blksz
operator|*
name|DMU_MAX_DELETEBLKCNT
expr_stmt|;
comment|/* if the file is too big, only hold_free a token amount */
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
literal|0
argument_list|,
operator|(
name|toobig
condition|?
name|DMU_MAX_ACCESS
else|:
name|DMU_OBJECT_END
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* are there any extended attributes? */
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_XATTR
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|xattr_obj
argument_list|,
sizeof|sizeof
argument_list|(
name|xattr_obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|xattr_obj
condition|)
block|{
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|xattr_obj
argument_list|,
operator|&
name|xzp
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|xzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|acl_obj
operator|=
name|zfs_external_acl
argument_list|(
name|zp
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|may_delete_now
condition|)
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
comment|/* charge as an update -- would be nice not to charge at all */
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Mark this transaction as typically resulting in a net free of space 	 */
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|waited
condition|?
name|TXG_WAITED
else|:
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|waited
operator|=
name|B_TRUE
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
name|realnmp
condition|)
name|pn_free
argument_list|(
name|realnmp
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Remove the directory entry. 	 */
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|zflg
argument_list|,
operator|&
name|unlinked
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|unlinked
condition|)
block|{
comment|/* 		 * Hold z_lock so that we can make sure that the ACL obj 		 * hasn't changed.  Could have been deleted due to 		 * zfs_sa_upgrade(). 		 */
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_XATTR
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|xattr_obj_unlinked
argument_list|,
sizeof|sizeof
argument_list|(
name|xattr_obj_unlinked
argument_list|)
argument_list|)
expr_stmt|;
name|delete_now
operator|=
name|may_delete_now
operator|&&
operator|!
name|toobig
operator|&&
name|vp
operator|->
name|v_count
operator|==
literal|1
operator|&&
operator|!
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
operator|&&
name|xattr_obj
operator|==
name|xattr_obj_unlinked
operator|&&
name|zfs_external_acl
argument_list|(
name|zp
argument_list|)
operator|==
name|acl_obj
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|delete_now
condition|)
block|{
if|if
condition|(
name|xattr_obj_unlinked
condition|)
block|{
name|ASSERT3U
argument_list|(
name|xzp
operator|->
name|z_links
argument_list|,
operator|==
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|xzp
operator|->
name|z_unlinked
operator|=
literal|1
expr_stmt|;
name|xzp
operator|->
name|z_links
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|sa_update
argument_list|(
name|xzp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_LINKS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|xzp
operator|->
name|z_links
argument_list|,
sizeof|sizeof
argument_list|(
name|xzp
operator|->
name|z_links
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|error
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|xzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zfs_unlinked_add
argument_list|(
name|xzp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
name|error
operator|=
name|sa_remove
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_XATTR
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_XATTR
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|null_xattr
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_count
operator|--
expr_stmt|;
name|ASSERT0
argument_list|(
name|vp
operator|->
name|v_count
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zfs_znode_delete
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|unlinked
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zfs_unlinked_add
argument_list|(
name|zp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|txtype
operator|=
name|TX_REMOVE
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_remove
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|realnmp
condition|)
name|pn_free
argument_list|(
name|realnmp
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delete_now
condition|)
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|xzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a new directory and insert it into dvp using the name  * provided.  Return a pointer to the inserted directory.  *  *	IN:	dvp	- vnode of directory to add subdir to.  *		dirname	- name of new directory.  *		vap	- attributes of new directory.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *		vsecp	- ACL to be set  *  *	OUT:	vpp	- vnode of created directory.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated  *	 vp - ctime|mtime|atime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_mkdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|uint64_t
name|txtype
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zf
init|=
name|ZNEW
decl_stmt|;
name|ksid_t
modifier|*
name|ksid
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|gid_t
name|gid
init|=
name|crgetgid
argument_list|(
name|cr
argument_list|)
decl_stmt|;
name|zfs_acl_ids_t
name|acl_ids
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
name|boolean_t
name|waited
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|vap
operator|->
name|va_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
comment|/* 	 * If we have an ephemeral id, ACL, or XVATTR then 	 * make sure file system is at proper version 	 */
name|ksid
operator|=
name|crgetsid
argument_list|(
name|cr
argument_list|,
name|KSID_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksid
condition|)
name|uid
operator|=
name|ksid_getid
argument_list|(
name|ksid
argument_list|)
expr_stmt|;
else|else
name|uid
operator|=
name|crgetuid
argument_list|(
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
name|vsecp
operator|||
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
operator|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|uid
argument_list|)
operator|||
name|IS_EPHEMERAL
argument_list|(
name|gid
argument_list|)
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zf
operator||=
name|ZCILOOK
expr_stmt|;
if|if
condition|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_XVATTR
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|secpolicy_xvattr
argument_list|(
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
argument_list|,
name|crgetuid
argument_list|(
name|cr
argument_list|)
argument_list|,
name|cr
argument_list|,
name|vap
operator|->
name|va_type
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_acl_ids_create
argument_list|(
name|dzp
argument_list|,
literal|0
argument_list|,
name|vap
argument_list|,
name|cr
argument_list|,
name|vsecp
argument_list|,
operator|&
name|acl_ids
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * First make sure the new directory doesn't exist. 	 * 	 * Existence is checked first to make sure we don't return 	 * EACCES instead of EEXIST which can cause some applications 	 * to fail. 	 */
name|top
label|:
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|dirname
argument_list|,
operator|&
name|zp
argument_list|,
name|zf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_SUBDIRECTORY
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zfs_acl_ids_overquota
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acl_ids
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Add a new entry to the directory. 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_sa
operator|&&
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_hold_sa_create
argument_list|(
name|tx
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|+
name|ZFS_SA_BASE_ATTR_SIZE
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|waited
condition|?
name|TXG_WAITED
else|:
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|waited
operator|=
name|B_TRUE
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Create new node. 	 */
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Now put new name in parent dir. 	 */
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|txtype
operator|=
name|zfs_log_create_txtype
argument_list|(
name|Z_DIR
argument_list|,
name|vsecp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_create
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|dirname
argument_list|,
name|vsecp
argument_list|,
name|acl_ids
operator|.
name|z_fuidp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a directory subdir entry.  If the current working  * directory is the same as the subdir to be removed, the  * remove will fail.  *  *	IN:	dvp	- vnode of directory to remove from.  *		name	- name of directory to be removed.  *		cwd	- vnode of current working directory.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_rmdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vnode_t
modifier|*
name|cwd
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|zp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zflg
init|=
name|ZEXISTS
decl_stmt|;
name|boolean_t
name|waited
init|=
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|top
label|:
name|zp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Attempt to lock directory; fail if entry doesn't exist. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vp
operator|=
name|ZTOV
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_delete
argument_list|(
name|dzp
argument_list|,
name|zp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vp
operator|==
name|cwd
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vnevent_rmdir
argument_list|(
name|vp
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
comment|/* 	 * Grab a lock on the directory to make sure that noone is 	 * trying to add (or lookup) entries while we are removing it. 	 */
name|rw_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_name_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Grab a lock on the parent pointer to make sure we play well 	 * with the treewalk and directory rename code. 	 */
name|rw_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_parent_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|dzp
argument_list|)
expr_stmt|;
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|waited
condition|?
name|TXG_WAITED
else|:
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_parent_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|waited
operator|=
name|B_TRUE
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|txtype
init|=
name|TX_RMDIR
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_remove
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
name|ZFS_NO_OBJECT
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_parent_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
name|out
label|:
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read as many directory entries as will fit into the provided  * buffer from the given directory cursor position (specified in  * the uio structure).  *  *	IN:	vp	- vnode of directory to read.  *		uio	- structure supplying read location, range info,  *			  and return buffer.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	OUT:	uio	- updated offset and range, buffer filled.  *		eofp	- set to true if end-of-file detected.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - atime updated  *  * Note that the low 4 bits of the cookie returned by zap is always zero.  * This allows us to use the low range for "special" directory entries:  * We use 0 for '.', and 1 for '..'.  If this is the root of the filesystem,  * we use the offset 2 for the '.zfs' directory.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_readdir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|iovec_t
modifier|*
name|iovp
decl_stmt|;
name|edirent_t
modifier|*
name|eodp
decl_stmt|;
name|dirent64_t
modifier|*
name|odp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|caddr_t
name|outbuf
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|zap
decl_stmt|;
name|uint_t
name|bytes_wanted
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
comment|/* must be unsigned; checks for< 1 */
name|uint64_t
name|parent
decl_stmt|;
name|int
name|local_eof
decl_stmt|;
name|int
name|outcount
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint8_t
name|prefetch
decl_stmt|;
name|boolean_t
name|check_sysattrs
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|parent
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we are not given an eof variable, 	 * use a local one. 	 */
if|if
condition|(
name|eofp
operator|==
name|NULL
condition|)
name|eofp
operator|=
operator|&
name|local_eof
expr_stmt|;
comment|/* 	 * Check for valid iov_len. 	 */
if|if
condition|(
name|uio
operator|->
name|uio_iov
operator|->
name|iov_len
operator|<=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Quit if directory has been removed (posix) 	 */
if|if
condition|(
operator|(
operator|*
name|eofp
operator|=
name|zp
operator|->
name|z_unlinked
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|os
operator|=
name|zfsvfs
operator|->
name|z_os
expr_stmt|;
name|offset
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|prefetch
operator|=
name|zp
operator|->
name|z_zn_prefetch
expr_stmt|;
comment|/* 	 * Initialize the iterator cursor. 	 */
if|if
condition|(
name|offset
operator|<=
literal|3
condition|)
block|{
comment|/* 		 * Start iteration from the beginning of the directory. 		 */
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * The offset is a serialized cursor. 		 */
name|zap_cursor_init_serialized
argument_list|(
operator|&
name|zc
argument_list|,
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|offset
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Get space to change directory entries into fs independent format. 	 */
name|iovp
operator|=
name|uio
operator|->
name|uio_iov
expr_stmt|;
name|bytes_wanted
operator|=
name|iovp
operator|->
name|iov_len
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
block|{
name|bufsize
operator|=
name|bytes_wanted
expr_stmt|;
name|outbuf
operator|=
name|kmem_alloc
argument_list|(
name|bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|odp
operator|=
operator|(
expr|struct
name|dirent64
operator|*
operator|)
name|outbuf
expr_stmt|;
block|}
else|else
block|{
name|bufsize
operator|=
name|bytes_wanted
expr_stmt|;
name|outbuf
operator|=
name|NULL
expr_stmt|;
name|odp
operator|=
operator|(
expr|struct
name|dirent64
operator|*
operator|)
name|iovp
operator|->
name|iov_base
expr_stmt|;
block|}
name|eodp
operator|=
operator|(
expr|struct
name|edirent
operator|*
operator|)
name|odp
expr_stmt|;
comment|/* 	 * If this VFS supports the system attribute view interface; and 	 * we're looking at an extended attribute directory; and we care 	 * about normalization conflicts on this vfs; then we must check 	 * for normalization conflicts with the sysattr name space. 	 */
name|check_sysattrs
operator|=
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
operator|&&
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
operator|)
operator|&&
name|zfsvfs
operator|->
name|z_norm
operator|&&
operator|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
operator|)
expr_stmt|;
comment|/* 	 * Transform to file-system independent format 	 */
name|outcount
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|outcount
operator|<
name|bytes_wanted
condition|)
block|{
name|ino64_t
name|objnum
decl_stmt|;
name|ushort_t
name|reclen
decl_stmt|;
name|off64_t
modifier|*
name|next
init|=
name|NULL
decl_stmt|;
comment|/* 		 * Special case `.', `..', and `.zfs'. 		 */
if|if
condition|(
name|offset
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
literal|".."
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|parent
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|offset
operator|==
literal|2
operator|&&
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|zap
operator|.
name|za_name
argument_list|,
name|ZFS_CTLDIR_NAME
argument_list|)
expr_stmt|;
name|zap
operator|.
name|za_normalization_conflict
operator|=
literal|0
expr_stmt|;
name|objnum
operator|=
name|ZFSCTL_INO_ROOT
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Grab next entry. 			 */
if|if
condition|(
name|error
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|zap
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|eofp
operator|=
operator|(
name|error
operator|==
name|ENOENT
operator|)
operator|)
operator|!=
literal|0
condition|)
break|break;
else|else
goto|goto
name|update
goto|;
block|}
if|if
condition|(
name|zap
operator|.
name|za_integer_length
operator|!=
literal|8
operator|||
name|zap
operator|.
name|za_num_integers
operator|!=
literal|1
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"zap_readdir: bad directory "
literal|"entry, obj = %lld, offset = %lld\n"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|zp
operator|->
name|z_id
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
goto|goto
name|update
goto|;
block|}
name|objnum
operator|=
name|ZFS_DIRENT_OBJ
argument_list|(
name|zap
operator|.
name|za_first_integer
argument_list|)
expr_stmt|;
comment|/* 			 * MacOS X can extract the object type here such as: 			 * uint8_t type = ZFS_DIRENT_TYPE(zap.za_first_integer); 			 */
if|if
condition|(
name|check_sysattrs
operator|&&
operator|!
name|zap
operator|.
name|za_normalization_conflict
condition|)
block|{
name|zap
operator|.
name|za_normalization_conflict
operator|=
name|xattr_sysattr_casechk
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ACCFILTER
condition|)
block|{
comment|/* 			 * If we have no access at all, don't include 			 * this entry in the returned information 			 */
name|znode_t
modifier|*
name|ezp
decl_stmt|;
if|if
condition|(
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|objnum
argument_list|,
operator|&
name|ezp
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|skip_entry
goto|;
if|if
condition|(
operator|!
name|zfs_has_access
argument_list|(
name|ezp
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|ezp
argument_list|)
argument_list|)
expr_stmt|;
goto|goto
name|skip_entry
goto|;
block|}
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|ezp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
name|reclen
operator|=
name|EDIRENT_RECLEN
argument_list|(
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|reclen
operator|=
name|DIRENT64_RECLEN
argument_list|(
name|strlen
argument_list|(
name|zap
operator|.
name|za_name
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * Will this entry fit in the buffer? 		 */
if|if
condition|(
name|outcount
operator|+
name|reclen
operator|>
name|bufsize
condition|)
block|{
comment|/* 			 * Did we manage to fit anything in the buffer? 			 */
if|if
condition|(
operator|!
name|outcount
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|update
goto|;
block|}
break|break;
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
block|{
comment|/* 			 * Add extended flag entry: 			 */
name|eodp
operator|->
name|ed_ino
operator|=
name|objnum
expr_stmt|;
name|eodp
operator|->
name|ed_reclen
operator|=
name|reclen
expr_stmt|;
comment|/* NOTE: ed_off is the offset for the *next* entry */
name|next
operator|=
operator|&
operator|(
name|eodp
operator|->
name|ed_off
operator|)
expr_stmt|;
name|eodp
operator|->
name|ed_eflags
operator|=
name|zap
operator|.
name|za_normalization_conflict
condition|?
name|ED_CASE_CONFLICT
else|:
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|eodp
operator|->
name|ed_name
argument_list|,
name|zap
operator|.
name|za_name
argument_list|,
name|EDIRENT_NAMELEN
argument_list|(
name|reclen
argument_list|)
argument_list|)
expr_stmt|;
name|eodp
operator|=
operator|(
name|edirent_t
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|eodp
operator|+
name|reclen
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * Add normal entry: 			 */
name|odp
operator|->
name|d_ino
operator|=
name|objnum
expr_stmt|;
name|odp
operator|->
name|d_reclen
operator|=
name|reclen
expr_stmt|;
comment|/* NOTE: d_off is the offset for the *next* entry */
name|next
operator|=
operator|&
operator|(
name|odp
operator|->
name|d_off
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|odp
operator|->
name|d_name
argument_list|,
name|zap
operator|.
name|za_name
argument_list|,
name|DIRENT64_NAMELEN
argument_list|(
name|reclen
argument_list|)
argument_list|)
expr_stmt|;
name|odp
operator|=
operator|(
name|dirent64_t
operator|*
operator|)
operator|(
operator|(
name|intptr_t
operator|)
name|odp
operator|+
name|reclen
operator|)
expr_stmt|;
block|}
name|outcount
operator|+=
name|reclen
expr_stmt|;
name|ASSERT
argument_list|(
name|outcount
operator|<=
name|bufsize
argument_list|)
expr_stmt|;
comment|/* Prefetch znode */
if|if
condition|(
name|prefetch
condition|)
name|dmu_prefetch
argument_list|(
name|os
argument_list|,
name|objnum
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ZIO_PRIORITY_SYNC_READ
argument_list|)
expr_stmt|;
name|skip_entry
label|:
comment|/* 		 * Move to the next entry, fill in the previous offset. 		 */
if|if
condition|(
name|offset
operator|>
literal|2
operator|||
operator|(
name|offset
operator|==
literal|2
operator|&&
operator|!
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
operator|)
condition|)
block|{
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|offset
operator|=
name|zap_cursor_serialize
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|+=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|next
condition|)
operator|*
name|next
operator|=
name|offset
expr_stmt|;
block|}
name|zp
operator|->
name|z_zn_prefetch
operator|=
name|B_FALSE
expr_stmt|;
comment|/* a lookup will re-enable pre-fetching */
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|==
name|UIO_SYSSPACE
operator|&&
name|uio
operator|->
name|uio_iovcnt
operator|==
literal|1
condition|)
block|{
name|iovp
operator|->
name|iov_base
operator|+=
name|outcount
expr_stmt|;
name|iovp
operator|->
name|iov_len
operator|-=
name|outcount
expr_stmt|;
name|uio
operator|->
name|uio_resid
operator|-=
name|outcount
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|=
name|uiomove
argument_list|(
name|outbuf
argument_list|,
operator|(
name|long
operator|)
name|outcount
argument_list|,
name|UIO_READ
argument_list|,
name|uio
argument_list|)
condition|)
block|{
comment|/* 		 * Reset the pointer. 		 */
name|offset
operator|=
name|uio
operator|->
name|uio_loffset
expr_stmt|;
block|}
name|update
label|:
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_segflg
operator|!=
name|UIO_SYSSPACE
operator|||
name|uio
operator|->
name|uio_iovcnt
operator|!=
literal|1
condition|)
name|kmem_free
argument_list|(
name|outbuf
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
name|error
operator|=
literal|0
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|uio
operator|->
name|uio_loffset
operator|=
name|offset
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|ulong_t
name|zfs_fsync_sync_cnt
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|zfs_fsync
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|syncflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
comment|/* 	 * Regardless of whether this is required for standards conformance, 	 * this is the logical behavior when fsync() is called on a file with 	 * dirty pages.  We use B_ASYNC since the ZIL transactions are already 	 * going to be pushed out as part of the zil_commit(). 	 */
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
operator|&&
operator|!
operator|(
name|syncflag
operator|&
name|FNODSYNC
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|!
operator|(
name|IS_SWAPVP
argument_list|(
name|vp
argument_list|)
operator|)
condition|)
operator|(
name|void
operator|)
name|VOP_PUTPAGE
argument_list|(
name|vp
argument_list|,
operator|(
name|offset_t
operator|)
literal|0
argument_list|,
operator|(
name|size_t
operator|)
literal|0
argument_list|,
name|B_ASYNC
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|tsd_set
argument_list|(
name|zfs_fsyncer_key
argument_list|,
operator|(
name|void
operator|*
operator|)
name|zfs_fsync_sync_cnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|!=
name|ZFS_SYNC_DISABLED
condition|)
block|{
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the requested file attributes and place them in the provided  * vattr structure.  *  *	IN:	vp	- vnode of file.  *		vap	- va_mask identifies requested attributes.  *			  If AT_XVATTR set, then optional attrs are requested  *		flags	- ATTR_NOACLCHECK (CIFS server context)  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	vap	- attribute values.  *  *	RETURN:	0 (always succeeds).  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|links
decl_stmt|;
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
comment|/* vap may be an xvattr_t * */
name|xoptattr_t
modifier|*
name|xoap
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|2
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|vap
operator|->
name|va_uid
argument_list|,
operator|&
name|vap
operator|->
name|va_gid
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mtime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_bulk_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If ACL is trivial don't bother looking for ACE_READ_ATTRIBUTES. 	 * Also, if we are the owner don't bother, since owner should 	 * always be allowed to read basic attributes of file. 	 */
if|if
condition|(
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_TRIVIAL
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_uid
operator|!=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_READ_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Return all attributes.  It's cheaper to provide the answer 	 * than to determine whether we were asked the question. 	 */
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|zp
operator|->
name|z_mode
operator|&
name|MODEMASK
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_dev
expr_stmt|;
name|vap
operator|->
name|va_nodeid
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|&&
name|zfs_show_ctldir
argument_list|(
name|zp
argument_list|)
condition|)
name|links
operator|=
name|zp
operator|->
name|z_links
operator|+
literal|1
expr_stmt|;
else|else
name|links
operator|=
name|zp
operator|->
name|z_links
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|MIN
argument_list|(
name|links
argument_list|,
name|UINT32_MAX
argument_list|)
expr_stmt|;
comment|/* nlink_t limit! */
name|vap
operator|->
name|va_size
operator|=
name|zp
operator|->
name|z_size
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
name|vp
operator|->
name|v_rdev
expr_stmt|;
name|vap
operator|->
name|va_seq
operator|=
name|zp
operator|->
name|z_seq
expr_stmt|;
comment|/* 	 * Add in any requested optional attributes and the create time. 	 * Also set the corresponding bits in the returned attribute bitmap. 	 */
if|if
condition|(
operator|(
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|zfsvfs
operator|->
name|z_use_fuids
condition|)
block|{
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_archive
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ARCHIVE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_readonly
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_READONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_system
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_SYSTEM
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_hidden
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_HIDDEN
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_nounlink
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NOUNLINK
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_immutable
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_appendonly
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_nodump
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NODUMP
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_opaque
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_OPAQUE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_av_quarantined
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_av_modified
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_MODIFIED
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
name|zfs_sa_get_scanstamp
argument_list|(
name|zp
argument_list|,
name|xvap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
condition|)
block|{
name|uint64_t
name|times
index|[
literal|2
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_CRTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|times
argument_list|,
sizeof|sizeof
argument_list|(
name|times
argument_list|)
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|xoap
operator|->
name|xoa_createtime
argument_list|,
name|times
argument_list|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_reparse
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_REPARSE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_GEN
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_generation
operator|=
name|zp
operator|->
name|z_gen
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_GEN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_offline
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_OFFLINE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
condition|)
block|{
name|xoap
operator|->
name|xoa_sparse
operator|=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_SPARSE
operator|)
operator|!=
literal|0
operator|)
expr_stmt|;
name|XVA_SET_RTN
argument_list|(
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
expr_stmt|;
block|}
block|}
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|zp
operator|->
name|z_atime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|vap
operator|->
name|va_ctime
argument_list|,
name|ctime
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|sa_object_size
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
operator|&
name|vap
operator|->
name|va_blksize
argument_list|,
operator|&
name|vap
operator|->
name|va_nblocks
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Block size hasn't been set; suggest maximal I/O transfers. 		 */
name|vap
operator|->
name|va_blksize
operator|=
name|zfsvfs
operator|->
name|z_max_blksz
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the file attributes to the values contained in the  * vattr structure.  *  *	IN:	vp	- vnode of file to be modified.  *		vap	- new attribute values.  *			  If AT_XVATTR set, then optional attrs are being set  *		flags	- ATTR_UTIME set if non-default time values provided.  *			- ATTR_NOACLCHECK (CIFS context only).  *		cr	- credentials of caller.  *		ct	- caller context  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - ctime updated, mtime updated if size changed.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_setattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|vattr_t
name|oldva
decl_stmt|;
name|xvattr_t
name|tmpxvattr
decl_stmt|;
name|uint_t
name|mask
init|=
name|vap
operator|->
name|va_mask
decl_stmt|;
name|uint_t
name|saved_mask
init|=
literal|0
decl_stmt|;
name|int
name|trim_mask
init|=
literal|0
decl_stmt|;
name|uint64_t
name|new_mode
decl_stmt|;
name|uint64_t
name|new_uid
decl_stmt|,
name|new_gid
decl_stmt|;
name|uint64_t
name|xattr_obj
decl_stmt|;
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|;
name|znode_t
modifier|*
name|attrzp
decl_stmt|;
name|int
name|need_policy
init|=
name|FALSE
decl_stmt|;
name|int
name|err
decl_stmt|,
name|err2
decl_stmt|;
name|zfs_fuid_info_t
modifier|*
name|fuidp
init|=
name|NULL
decl_stmt|;
name|xvattr_t
modifier|*
name|xvap
init|=
operator|(
name|xvattr_t
operator|*
operator|)
name|vap
decl_stmt|;
comment|/* vap may be an xvattr_t * */
name|xoptattr_t
modifier|*
name|xoap
decl_stmt|;
name|zfs_acl_t
modifier|*
name|aclp
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|boolean_t
name|fuid_dirtied
init|=
name|B_FALSE
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|7
index|]
decl_stmt|,
name|xattr_bulk
index|[
literal|7
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|,
name|xattr_count
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|mask
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|mask
operator|&
name|AT_NOSET
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Make sure that if we have ephemeral uid/gid or xvattr specified 	 * that file system is at proper version level 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_use_fuids
operator|==
name|B_FALSE
operator|&&
operator|(
operator|(
operator|(
name|mask
operator|&
name|AT_UID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_uid
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_GID
operator|)
operator|&&
name|IS_EPHEMERAL
argument_list|(
name|vap
operator|->
name|va_gid
argument_list|)
operator|)
operator|||
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EISDIR
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VFIFO
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If this is an xvattr_t, then get a pointer to the structure of 	 * optional attributes.  If this is NULL, then we have a vattr_t. 	 */
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvap
argument_list|)
expr_stmt|;
name|xva_init
argument_list|(
operator|&
name|tmpxvattr
argument_list|)
expr_stmt|;
comment|/* 	 * Immutable files can only alter immutable bit and atime 	 */
if|if
condition|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|&&
operator|(
operator|(
name|mask
operator|&
operator|(
name|AT_SIZE
operator||
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MTIME
operator||
name|AT_MODE
operator|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|mask
operator|&
name|AT_SIZE
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_READONLY
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Verify timestamps doesn't overflow 32 bits. 	 * ZFS can handle large timestamps, but 32bit syscalls can't 	 * handle times greater than 2039.  This check should be removed 	 * once large timestamps are fully supported. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_ATIME
operator||
name|AT_MTIME
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|mask
operator|&
name|AT_ATIME
operator|)
operator|&&
name|TIMESPEC_OVERFLOW
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_MTIME
operator|)
operator|&&
name|TIMESPEC_OVERFLOW
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
block|}
block|}
name|top
label|:
name|attrzp
operator|=
name|NULL
expr_stmt|;
name|aclp
operator|=
name|NULL
expr_stmt|;
comment|/* Can this be moved to before the top label? */
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * First validate permissions 	 */
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
condition|)
block|{
name|err
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_DATA
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 		 * XXX - Note, we are not providing any open 		 * mode flags here (like FNDELAY), so we may 		 * block if there are locks present... this 		 * should be addressed in openat(). 		 */
comment|/* XXX - would it be OK to generate a log record here? */
name|err
operator|=
name|zfs_freesp
argument_list|(
name|zp
argument_list|,
name|vap
operator|->
name|va_size
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|vap
operator|->
name|va_size
operator|==
literal|0
condition|)
name|vnevent_truncate
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_ATIME
operator||
name|AT_MTIME
operator|)
operator|||
operator|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_HIDDEN
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_READONLY
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_ARCHIVE
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OFFLINE
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SPARSE
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_CREATETIME
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_SYSTEM
argument_list|)
operator|)
operator|)
condition|)
block|{
name|need_policy
operator|=
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ATTRIBUTES
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
condition|)
block|{
name|int
name|idmask
init|=
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
decl_stmt|;
name|int
name|take_owner
decl_stmt|;
name|int
name|take_group
decl_stmt|;
comment|/* 		 * NOTE: even if a new mode is being set, 		 * we may clear S_ISUID/S_ISGID bits. 		 */
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|AT_MODE
operator|)
condition|)
name|vap
operator|->
name|va_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
comment|/* 		 * Take ownership or chgrp to group we are a member of 		 */
name|take_owner
operator|=
operator|(
name|mask
operator|&
name|AT_UID
operator|)
operator|&&
operator|(
name|vap
operator|->
name|va_uid
operator|==
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|)
expr_stmt|;
name|take_group
operator|=
operator|(
name|mask
operator|&
name|AT_GID
operator|)
operator|&&
name|zfs_groupmember
argument_list|(
name|zfsvfs
argument_list|,
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* 		 * If both AT_UID and AT_GID are set then take_owner and 		 * take_group must both be set in order to allow taking 		 * ownership. 		 * 		 * Otherwise, send the check through secpolicy_vnode_setattr() 		 * 		 */
if|if
condition|(
operator|(
operator|(
name|idmask
operator|==
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
operator|&&
name|take_owner
operator|&&
name|take_group
operator|)
operator|||
operator|(
operator|(
name|idmask
operator|==
name|AT_UID
operator|)
operator|&&
name|take_owner
operator|)
operator|||
operator|(
operator|(
name|idmask
operator|==
name|AT_GID
operator|)
operator|&&
name|take_group
operator|)
condition|)
block|{
if|if
condition|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_OWNER
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * Remove setuid/setgid for non-privileged users 				 */
name|secpolicy_setid_clear
argument_list|(
name|vap
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|trim_mask
operator|=
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
expr_stmt|;
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|oldva
operator|.
name|va_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
name|zfs_fuid_map_ids
argument_list|(
name|zp
argument_list|,
name|cr
argument_list|,
operator|&
name|oldva
operator|.
name|va_uid
argument_list|,
operator|&
name|oldva
operator|.
name|va_gid
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_XVATTR
condition|)
block|{
comment|/* 		 * Update xvattr mask to include only those attributes 		 * that are actually changing. 		 * 		 * the bits will be restored prior to actually setting 		 * the attributes so the caller thinks they were set. 		 */
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_appendonly
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_APPENDONLY
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_nounlink
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NOUNLINK
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_immutable
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_IMMUTABLE
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_nodump
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_NODUMP
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
block|{
if|if
condition|(
name|xoap
operator|->
name|xoa_av_modified
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_MODIFIED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
operator|&&
name|xoap
operator|->
name|xoa_av_quarantined
operator|)
operator|||
name|xoap
operator|->
name|xoa_av_quarantined
operator|!=
operator|(
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
else|else
block|{
name|XVA_CLR_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_REPARSE
argument_list|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|need_policy
operator|==
name|FALSE
operator|&&
operator|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
operator|||
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_OPAQUE
argument_list|)
operator|)
condition|)
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
if|if
condition|(
name|zfs_zaccess
argument_list|(
name|zp
argument_list|,
name|ACE_WRITE_ACL
argument_list|,
literal|0
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|secpolicy_setid_setsticky_clear
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|oldva
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|trim_mask
operator||=
name|AT_MODE
expr_stmt|;
block|}
else|else
block|{
name|need_policy
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|need_policy
condition|)
block|{
comment|/* 		 * If trim_mask is set then take ownership 		 * has been granted or write_acl is present and user 		 * has the ability to modify mode.  In that case remove 		 * UID|GID and or MODE from mask so that 		 * secpolicy_vnode_setattr() doesn't revoke it. 		 */
if|if
condition|(
name|trim_mask
condition|)
block|{
name|saved_mask
operator|=
name|vap
operator|->
name|va_mask
expr_stmt|;
name|vap
operator|->
name|va_mask
operator|&=
operator|~
name|trim_mask
expr_stmt|;
block|}
name|err
operator|=
name|secpolicy_vnode_setattr
argument_list|(
name|cr
argument_list|,
name|vp
argument_list|,
name|vap
argument_list|,
operator|&
name|oldva
argument_list|,
name|flags
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|,
name|int
argument_list|,
name|cred_t
operator|*
argument_list|)
operator|)
name|zfs_zaccess_unix
argument_list|,
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|trim_mask
condition|)
name|vap
operator|->
name|va_mask
operator||=
name|saved_mask
expr_stmt|;
block|}
comment|/* 	 * secpolicy_vnode_setattr, or take ownership may have 	 * changed va_mask 	 */
name|mask
operator|=
name|vap
operator|->
name|va_mask
expr_stmt|;
if|if
condition|(
operator|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
operator|)
condition|)
block|{
name|err
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_XATTR
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|xattr_obj
argument_list|,
sizeof|sizeof
argument_list|(
name|xattr_obj
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|xattr_obj
condition|)
block|{
name|err
operator|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|xattr_obj
argument_list|,
operator|&
name|attrzp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out2
goto|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_UID
condition|)
block|{
name|new_uid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_uid
operator|!=
name|zp
operator|->
name|z_uid
operator|&&
name|zfs_fuid_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|B_FALSE
argument_list|,
name|new_uid
argument_list|)
condition|)
block|{
if|if
condition|(
name|attrzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_GID
condition|)
block|{
name|new_gid
operator|=
name|zfs_fuid_create
argument_list|(
name|zfsvfs
argument_list|,
operator|(
name|uint64_t
operator|)
name|vap
operator|->
name|va_gid
argument_list|,
name|cr
argument_list|,
name|ZFS_GROUP
argument_list|,
operator|&
name|fuidp
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_gid
operator|!=
name|zp
operator|->
name|z_gid
operator|&&
name|zfs_fuid_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|B_TRUE
argument_list|,
name|new_gid
argument_list|)
condition|)
block|{
if|if
condition|(
name|attrzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
goto|goto
name|out2
goto|;
block|}
block|}
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
name|uint64_t
name|pmode
init|=
name|zp
operator|->
name|z_mode
decl_stmt|;
name|uint64_t
name|acl_obj
decl_stmt|;
name|new_mode
operator|=
operator|(
name|pmode
operator|&
name|S_IFMT
operator|)
operator||
operator|(
name|vap
operator|->
name|va_mode
operator|&
operator|~
name|S_IFMT
operator|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_acl_mode
operator|==
name|ZFS_ACL_RESTRICTED
operator|&&
operator|!
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_ACL_TRIVIAL
operator|)
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|err
operator|=
name|zfs_acl_chmod_setattr
argument_list|(
name|zp
argument_list|,
operator|&
name|aclp
argument_list|,
name|new_mode
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zp
operator|->
name|z_is_sa
operator|&&
operator|(
operator|(
name|acl_obj
operator|=
name|zfs_external_acl
argument_list|(
name|zp
argument_list|)
operator|)
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* 			 * Are we upgrading ACL from old V0 format 			 * to V1 format? 			 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_version
operator|>=
name|ZPL_VERSION_FUID
operator|&&
name|zfs_znode_acl_version
argument_list|(
name|zp
argument_list|)
operator|==
name|ZFS_ACL_VERSION_INITIAL
condition|)
block|{
name|dmu_tx_hold_free
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|acl_obj
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|zp
operator|->
name|z_is_sa
operator|&&
name|aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
operator|&&
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
condition|)
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
else|else
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attrzp
condition|)
block|{
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|attrzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Set each attribute requested. 	 * We group settings according to the locks they need to acquire. 	 * 	 * Note: you cannot set ctime directly, although it will be 	 * updated as a side-effect of calling this function. 	 */
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_pflags
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_enter
argument_list|(
operator|&
name|attrzp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|attrzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|attrzp
operator|->
name|z_pflags
argument_list|,
sizeof|sizeof
argument_list|(
name|attrzp
operator|->
name|z_pflags
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator|)
condition|)
block|{
if|if
condition|(
name|mask
operator|&
name|AT_UID
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_UID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_uid
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_uid
operator|=
name|new_uid
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_UID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_uid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_uid
argument_list|)
argument_list|)
expr_stmt|;
name|attrzp
operator|->
name|z_uid
operator|=
name|new_uid
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_GID
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_GID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_gid
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_gid
operator|=
name|new_gid
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_GID
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_gid
argument_list|,
sizeof|sizeof
argument_list|(
name|new_gid
argument_list|)
argument_list|)
expr_stmt|;
name|attrzp
operator|->
name|z_gid
operator|=
name|new_gid
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|(
name|mask
operator|&
name|AT_MODE
operator|)
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MODE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|new_mode
argument_list|)
argument_list|)
expr_stmt|;
name|new_mode
operator|=
name|zp
operator|->
name|z_mode
expr_stmt|;
block|}
name|err
operator|=
name|zfs_acl_chown_setattr
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|err
operator|=
name|zfs_acl_chown_setattr
argument_list|(
name|attrzp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|mask
operator|&
name|AT_MODE
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MODE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|new_mode
argument_list|,
sizeof|sizeof
argument_list|(
name|new_mode
argument_list|)
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_mode
operator|=
name|new_mode
expr_stmt|;
name|ASSERT3U
argument_list|(
operator|(
name|uintptr_t
operator|)
name|aclp
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfs_aclset_common
argument_list|(
name|zp
argument_list|,
name|aclp
argument_list|,
name|cr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_acl_cached
condition|)
name|zfs_acl_free
argument_list|(
name|zp
operator|->
name|z_acl_cached
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_acl_cached
operator|=
name|aclp
expr_stmt|;
name|aclp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_ATIME
condition|)
block|{
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_atime
argument_list|,
name|zp
operator|->
name|z_atime
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_ATIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_atime
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_atime
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|mask
operator|&
name|AT_MTIME
condition|)
block|{
name|ZFS_TIME_ENCODE
argument_list|(
operator|&
name|vap
operator|->
name|va_mtime
argument_list|,
name|mtime
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* XXX - shouldn't this be done *before* the ATIME/MTIME checks? */
if|if
condition|(
name|mask
operator|&
name|AT_SIZE
operator|&&
operator|!
operator|(
name|mask
operator|&
name|AT_MTIME
operator|)
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|mtime
argument_list|,
sizeof|sizeof
argument_list|(
name|mtime
argument_list|)
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|ctime
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|ctime
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
name|SA_ADD_BULK_ATTR
argument_list|(
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
sizeof|sizeof
argument_list|(
name|ctime
argument_list|)
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|attrzp
argument_list|,
name|STATE_CHANGED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Do this after setting timestamps to prevent timestamp 	 * update from toggling bit 	 */
if|if
condition|(
name|xoap
operator|&&
operator|(
name|mask
operator|&
name|AT_XVATTR
operator|)
condition|)
block|{
comment|/* 		 * restore trimmed off masks 		 * so that return masks can be set for caller. 		 */
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_APPENDONLY
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_APPENDONLY
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NOUNLINK
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NOUNLINK
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_IMMUTABLE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_NODUMP
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_NODUMP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_MODIFIED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
operator|&
name|tmpxvattr
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
condition|)
block|{
name|XVA_SET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_QUARANTINED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|XVA_ISSET_REQ
argument_list|(
name|xvap
argument_list|,
name|XAT_AV_SCANSTAMP
argument_list|)
condition|)
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
argument_list|)
expr_stmt|;
name|zfs_xvattr_set
argument_list|(
name|zp
argument_list|,
name|xvap
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|!=
literal|0
condition|)
name|zfs_log_setattr
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_SETATTR
argument_list|,
name|zp
argument_list|,
name|vap
argument_list|,
name|mask
argument_list|,
name|fuidp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|attrzp
condition|)
block|{
if|if
condition|(
name|mask
operator|&
operator|(
name|AT_UID
operator||
name|AT_GID
operator||
name|AT_MODE
operator|)
condition|)
name|mutex_exit
argument_list|(
operator|&
name|attrzp
operator|->
name|z_acl_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|attrzp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|err
operator|==
literal|0
operator|&&
name|attrzp
condition|)
block|{
name|err2
operator|=
name|sa_bulk_update
argument_list|(
name|attrzp
operator|->
name|z_sa_hdl
argument_list|,
name|xattr_bulk
argument_list|,
name|xattr_count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err2
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|attrzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|attrzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|aclp
condition|)
name|zfs_acl_free
argument_list|(
name|aclp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuidp
condition|)
block|{
name|zfs_fuid_info_free
argument_list|(
name|fuidp
argument_list|)
expr_stmt|;
name|fuidp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|err
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ERESTART
condition|)
goto|goto
name|top
goto|;
block|}
else|else
block|{
name|err2
operator|=
name|sa_bulk_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|bulk
argument_list|,
name|count
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
name|out2
label|:
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|zfs_zlock
block|{
name|krwlock_t
modifier|*
name|zl_rwlock
decl_stmt|;
comment|/* lock we acquired */
name|znode_t
modifier|*
name|zl_znode
decl_stmt|;
comment|/* znode we held */
name|struct
name|zfs_zlock
modifier|*
name|zl_next
decl_stmt|;
comment|/* next in list */
block|}
name|zfs_zlock_t
typedef|;
end_typedef

begin_comment
comment|/*  * Drop locks and release vnodes that were held by zfs_rename_lock().  */
end_comment

begin_function
specifier|static
name|void
name|zfs_rename_unlock
parameter_list|(
name|zfs_zlock_t
modifier|*
modifier|*
name|zlpp
parameter_list|)
block|{
name|zfs_zlock_t
modifier|*
name|zl
decl_stmt|;
while|while
condition|(
operator|(
name|zl
operator|=
operator|*
name|zlpp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|zl
operator|->
name|zl_znode
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zl
operator|->
name|zl_znode
argument_list|)
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
name|zl
operator|->
name|zl_rwlock
argument_list|)
expr_stmt|;
operator|*
name|zlpp
operator|=
name|zl
operator|->
name|zl_next
expr_stmt|;
name|kmem_free
argument_list|(
name|zl
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|zl
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Search back through the directory tree, using the ".." entries.  * Lock each directory in the chain to prevent concurrent renames.  * Fail any attempt to move a directory into one of its own descendants.  * XXX - z_parent_lock can overlap with map or grow locks  */
end_comment

begin_function
specifier|static
name|int
name|zfs_rename_lock
parameter_list|(
name|znode_t
modifier|*
name|szp
parameter_list|,
name|znode_t
modifier|*
name|tdzp
parameter_list|,
name|znode_t
modifier|*
name|sdzp
parameter_list|,
name|zfs_zlock_t
modifier|*
modifier|*
name|zlpp
parameter_list|)
block|{
name|zfs_zlock_t
modifier|*
name|zl
decl_stmt|;
name|znode_t
modifier|*
name|zp
init|=
name|tdzp
decl_stmt|;
name|uint64_t
name|rootid
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_root
decl_stmt|;
name|uint64_t
name|oidp
init|=
name|zp
operator|->
name|z_id
decl_stmt|;
name|krwlock_t
modifier|*
name|rwlp
init|=
operator|&
name|szp
operator|->
name|z_parent_lock
decl_stmt|;
name|krw_t
name|rw
init|=
name|RW_WRITER
decl_stmt|;
comment|/* 	 * First pass write-locks szp and compares to zp->z_id. 	 * Later passes read-lock zp and compare to zp->z_parent. 	 */
do|do
block|{
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
name|rwlp
argument_list|,
name|rw
argument_list|)
condition|)
block|{
comment|/* 			 * Another thread is renaming in this path. 			 * Note that if we are a WRITER, we don't have any 			 * parent_locks held yet. 			 */
if|if
condition|(
name|rw
operator|==
name|RW_READER
operator|&&
name|zp
operator|->
name|z_id
operator|>
name|szp
operator|->
name|z_id
condition|)
block|{
comment|/* 				 * Drop our locks and restart 				 */
name|zfs_rename_unlock
argument_list|(
operator|&
name|zl
argument_list|)
expr_stmt|;
operator|*
name|zlpp
operator|=
name|NULL
expr_stmt|;
name|zp
operator|=
name|tdzp
expr_stmt|;
name|oidp
operator|=
name|zp
operator|->
name|z_id
expr_stmt|;
name|rwlp
operator|=
operator|&
name|szp
operator|->
name|z_parent_lock
expr_stmt|;
name|rw
operator|=
name|RW_WRITER
expr_stmt|;
continue|continue;
block|}
else|else
block|{
comment|/* 				 * Wait for other thread to drop its locks 				 */
name|rw_enter
argument_list|(
name|rwlp
argument_list|,
name|rw
argument_list|)
expr_stmt|;
block|}
block|}
name|zl
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|zl
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zl
operator|->
name|zl_rwlock
operator|=
name|rwlp
expr_stmt|;
name|zl
operator|->
name|zl_znode
operator|=
name|NULL
expr_stmt|;
name|zl
operator|->
name|zl_next
operator|=
operator|*
name|zlpp
expr_stmt|;
operator|*
name|zlpp
operator|=
name|zl
expr_stmt|;
if|if
condition|(
name|oidp
operator|==
name|szp
operator|->
name|z_id
condition|)
comment|/* We're a descendant of szp */
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|oidp
operator|==
name|rootid
condition|)
comment|/* We've hit the top */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|rw
operator|==
name|RW_READER
condition|)
block|{
comment|/* i.e. not the first pass */
name|int
name|error
init|=
name|zfs_zget
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|,
name|oidp
argument_list|,
operator|&
name|zp
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zl
operator|->
name|zl_znode
operator|=
name|zp
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zp
operator|->
name|z_zfsvfs
argument_list|)
argument_list|,
operator|&
name|oidp
argument_list|,
sizeof|sizeof
argument_list|(
name|oidp
argument_list|)
argument_list|)
expr_stmt|;
name|rwlp
operator|=
operator|&
name|zp
operator|->
name|z_parent_lock
expr_stmt|;
name|rw
operator|=
name|RW_READER
expr_stmt|;
block|}
do|while
condition|(
name|zp
operator|->
name|z_id
operator|!=
name|sdzp
operator|->
name|z_id
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Move an entry from the provided source directory to the target  * directory.  Change the entry name as indicated.  *  *	IN:	sdvp	- Source directory containing the "old entry".  *		snm	- Old entry name.  *		tdvp	- Target directory to contain the "new entry".  *		tnm	- New entry name.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	sdvp,tdvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_rename
parameter_list|(
name|vnode_t
modifier|*
name|sdvp
parameter_list|,
name|char
modifier|*
name|snm
parameter_list|,
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|char
modifier|*
name|tnm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|tdzp
decl_stmt|,
modifier|*
name|szp
decl_stmt|,
modifier|*
name|tzp
decl_stmt|;
name|znode_t
modifier|*
name|sdzp
init|=
name|VTOZ
argument_list|(
name|sdvp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|sdzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|vnode_t
modifier|*
name|realvp
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|sdl
decl_stmt|,
modifier|*
name|tdl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfs_zlock_t
modifier|*
name|zl
decl_stmt|;
name|int
name|cmp
decl_stmt|,
name|serr
decl_stmt|,
name|terr
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|rm_err
init|=
literal|0
decl_stmt|;
name|int
name|zflg
init|=
literal|0
decl_stmt|;
name|boolean_t
name|waited
init|=
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|sdzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
comment|/* 	 * Make sure we have the real vp for the target directory. 	 */
if|if
condition|(
name|VOP_REALVP
argument_list|(
name|tdvp
argument_list|,
operator|&
name|realvp
argument_list|,
name|ct
argument_list|)
operator|==
literal|0
condition|)
name|tdvp
operator|=
name|realvp
expr_stmt|;
name|tdzp
operator|=
name|VTOZ
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|tdzp
argument_list|)
expr_stmt|;
comment|/* 	 * We check z_zfsvfs rather than v_vfsp here, because snapshots and the 	 * ctldir appear to have the same v_vfsp. 	 */
if|if
condition|(
name|tdzp
operator|->
name|z_zfsvfs
operator|!=
name|zfsvfs
operator|||
name|zfsctl_is_node
argument_list|(
name|tdvp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EXDEV
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|tnm
argument_list|,
name|strlen
argument_list|(
name|tnm
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
name|top
label|:
name|szp
operator|=
name|NULL
expr_stmt|;
name|tzp
operator|=
name|NULL
expr_stmt|;
name|zl
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * This is to prevent the creation of links into attribute space 	 * by renaming a linked file into/outof an attribute directory. 	 * See the comment in zfs_link() for why this is considered bad. 	 */
if|if
condition|(
operator|(
name|tdzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|!=
operator|(
name|sdzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Lock source and target directory entries.  To prevent deadlock, 	 * a lock ordering must be defined.  We lock the directory with 	 * the smallest object id first, or if it's a tie, the one with 	 * the lexically first name. 	 */
if|if
condition|(
name|sdzp
operator|->
name|z_id
operator|<
name|tdzp
operator|->
name|z_id
condition|)
block|{
name|cmp
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sdzp
operator|->
name|z_id
operator|>
name|tdzp
operator|->
name|z_id
condition|)
block|{
name|cmp
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * First compare the two name arguments without 		 * considering any case folding. 		 */
name|int
name|nofold
init|=
operator|(
name|zfsvfs
operator|->
name|z_norm
operator|&
operator|~
name|U8_TEXTPREP_TOUPPER
operator|)
decl_stmt|;
name|cmp
operator|=
name|u8_strcmp
argument_list|(
name|snm
argument_list|,
name|tnm
argument_list|,
literal|0
argument_list|,
name|nofold
argument_list|,
name|U8_UNICODE_LATEST
argument_list|,
operator|&
name|error
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
operator|!
name|zfsvfs
operator|->
name|z_utf8
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|/* 			 * POSIX: "If the old argument and the new argument 			 * both refer to links to the same existing file, 			 * the rename() function shall return successfully 			 * and perform no other action." 			 */
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 		 * If the file system is case-folding, then we may 		 * have some more checking to do.  A case-folding file 		 * system is either supporting mixed case sensitivity 		 * access or is completely case-insensitive.  Note 		 * that the file system is always case preserving. 		 * 		 * In mixed sensitivity mode case sensitive behavior 		 * is the default.  FIGNORECASE must be used to 		 * explicitly request case insensitive behavior. 		 * 		 * If the source and target names provided differ only 		 * by case (e.g., a request to rename 'tim' to 'Tim'), 		 * we will treat this as a special case in the 		 * case-insensitive mode: as long as the source name 		 * is an exact match, we will allow this to proceed as 		 * a name-change request. 		 */
if|if
condition|(
operator|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
operator|||
operator|(
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_MIXED
operator|&&
name|flags
operator|&
name|FIGNORECASE
operator|)
operator|)
operator|&&
name|u8_strcmp
argument_list|(
name|snm
argument_list|,
name|tnm
argument_list|,
literal|0
argument_list|,
name|zfsvfs
operator|->
name|z_norm
argument_list|,
name|U8_UNICODE_LATEST
argument_list|,
operator|&
name|error
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * case preserving rename request, require exact 			 * name matches 			 */
name|zflg
operator||=
name|ZCIEXACT
expr_stmt|;
name|zflg
operator|&=
operator|~
name|ZCILOOK
expr_stmt|;
block|}
block|}
comment|/* 	 * If the source and destination directories are the same, we should 	 * grab the z_name_lock of that directory only once. 	 */
if|if
condition|(
name|sdzp
operator|==
name|tdzp
condition|)
block|{
name|zflg
operator||=
name|ZHAVELOCK
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|sdzp
operator|->
name|z_name_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cmp
operator|<
literal|0
condition|)
block|{
name|serr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|sdl
argument_list|,
name|sdzp
argument_list|,
name|snm
argument_list|,
operator|&
name|szp
argument_list|,
name|ZEXISTS
operator||
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|terr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|tdl
argument_list|,
name|tdzp
argument_list|,
name|tnm
argument_list|,
operator|&
name|tzp
argument_list|,
name|ZRENAMING
operator||
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|terr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|tdl
argument_list|,
name|tdzp
argument_list|,
name|tnm
argument_list|,
operator|&
name|tzp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|serr
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|sdl
argument_list|,
name|sdzp
argument_list|,
name|snm
argument_list|,
operator|&
name|szp
argument_list|,
name|ZEXISTS
operator||
name|ZRENAMING
operator||
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serr
condition|)
block|{
comment|/* 		 * Source entry invalid or not there. 		 */
if|if
condition|(
operator|!
name|terr
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|tdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sdzp
operator|==
name|tdzp
condition|)
name|rw_exit
argument_list|(
operator|&
name|sdzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|snm
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
name|serr
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|serr
operator|)
return|;
block|}
if|if
condition|(
name|terr
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdzp
operator|==
name|tdzp
condition|)
name|rw_exit
argument_list|(
operator|&
name|sdzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|tnm
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
name|terr
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|terr
operator|)
return|;
block|}
comment|/* 	 * Must have write access at the source to remove the old entry 	 * and write access at the target to create the new entry. 	 * Note that if target and source are the same, this can be 	 * done in a single check. 	 */
if|if
condition|(
name|error
operator|=
name|zfs_zaccess_rename
argument_list|(
name|sdzp
argument_list|,
name|szp
argument_list|,
name|tdzp
argument_list|,
name|tzp
argument_list|,
name|cr
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
comment|/* 		 * Check to make sure rename is valid. 		 * Can't do a move like this: /usr/a/b to /usr/a/b/c/d 		 */
if|if
condition|(
name|error
operator|=
name|zfs_rename_lock
argument_list|(
name|szp
argument_list|,
name|tdzp
argument_list|,
name|sdzp
argument_list|,
operator|&
name|zl
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Does target exist? 	 */
if|if
condition|(
name|tzp
condition|)
block|{
comment|/* 		 * Source and target must be the same type. 		 */
if|if
condition|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
if|if
condition|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTDIR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EISDIR
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 		 * POSIX dictates that when the source and target 		 * entries refer to the same file object, rename 		 * must do nothing and exit without error. 		 */
if|if
condition|(
name|szp
operator|->
name|z_id
operator|==
name|tzp
operator|->
name|z_id
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
name|vnevent_pre_rename_src
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|,
name|sdvp
argument_list|,
name|snm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|vnevent_pre_rename_dest
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|,
name|tdvp
argument_list|,
name|tnm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
comment|/* 	 * notify the target directory if it is not the same 	 * as source directory. 	 */
if|if
condition|(
name|tdvp
operator|!=
name|sdvp
condition|)
block|{
name|vnevent_pre_rename_dest_dir
argument_list|(
name|tdvp
argument_list|,
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|,
name|tnm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|sdzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|sdzp
operator|->
name|z_id
argument_list|,
name|FALSE
argument_list|,
name|snm
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|tdzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|tnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdzp
operator|!=
name|tdzp
condition|)
block|{
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|tdzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|tdzp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tzp
condition|)
block|{
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|tzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|tzp
argument_list|)
expr_stmt|;
block|}
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|szp
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|zfsvfs
operator|->
name|z_unlinkedobj
argument_list|,
name|FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|waited
condition|?
name|TXG_WAITED
else|:
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|zl
operator|!=
name|NULL
condition|)
name|zfs_rename_unlock
argument_list|(
operator|&
name|zl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|tdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdzp
operator|==
name|tdzp
condition|)
name|rw_exit
argument_list|(
operator|&
name|sdzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|waited
operator|=
name|B_TRUE
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|tzp
condition|)
comment|/* Attempt to remove the existing target */
name|error
operator|=
name|rm_err
operator|=
name|zfs_link_destroy
argument_list|(
name|tdl
argument_list|,
name|tzp
argument_list|,
name|tx
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zfs_link_create
argument_list|(
name|tdl
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|szp
operator|->
name|z_pflags
operator||=
name|ZFS_AV_MODIFIED
expr_stmt|;
name|error
operator|=
name|sa_update
argument_list|(
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|szp
operator|->
name|z_pflags
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_link_destroy
argument_list|(
name|sdl
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zfs_log_rename
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|TX_RENAME
operator||
operator|(
name|flags
operator|&
name|FIGNORECASE
condition|?
name|TX_CI
else|:
literal|0
operator|)
argument_list|,
name|sdzp
argument_list|,
name|sdl
operator|->
name|dl_name
argument_list|,
name|tdzp
argument_list|,
name|tdl
operator|->
name|dl_name
argument_list|,
name|szp
argument_list|)
expr_stmt|;
comment|/* 				 * Update path information for the target vnode 				 */
name|vn_renamepath
argument_list|(
name|tdvp
argument_list|,
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|,
name|tnm
argument_list|,
name|strlen
argument_list|(
name|tnm
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * At this point, we have successfully created 				 * the target name, but have failed to remove 				 * the source name.  Since the create was done 				 * with the ZRENAMING flag, there are 				 * complications; for one, the link count is 				 * wrong.  The easiest way to deal with this 				 * is to remove the newly created target, and 				 * return the original error.  This must 				 * succeed; fortunately, it is very unlikely to 				 * fail, since we just created it. 				 */
name|VERIFY3U
argument_list|(
name|zfs_link_destroy
argument_list|(
name|tdl
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
name|ZRENAMING
argument_list|,
name|NULL
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
operator|&&
name|rm_err
operator|==
literal|0
condition|)
name|vnevent_rename_dest
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|,
name|tdvp
argument_list|,
name|tnm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vnevent_rename_src
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|,
name|sdvp
argument_list|,
name|snm
argument_list|,
name|ct
argument_list|)
expr_stmt|;
comment|/* notify the target dir if it is not the same as source dir */
if|if
condition|(
name|tdvp
operator|!=
name|sdvp
condition|)
name|vnevent_rename_dest_dir
argument_list|(
name|tdvp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|zl
operator|!=
name|NULL
condition|)
name|zfs_rename_unlock
argument_list|(
operator|&
name|zl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|sdl
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|tdl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sdzp
operator|==
name|tdzp
condition|)
name|rw_exit
argument_list|(
operator|&
name|sdzp
operator|->
name|z_name_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|szp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tzp
condition|)
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|tzp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert the indicated symbolic reference entry into the directory.  *  *	IN:	dvp	- Directory to contain new symbolic link.  *		link	- Name for new symlink entry.  *		vap	- Attributes of new entry.  *		cr	- credentials of caller.  *		ct	- caller context  *		flags	- case flags  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	dvp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_symlink
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|char
modifier|*
name|link
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|dvp
argument_list|)
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|uint64_t
name|len
init|=
name|strlen
argument_list|(
name|link
argument_list|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zflg
init|=
name|ZNEW
decl_stmt|;
name|zfs_acl_ids_t
name|acl_ids
decl_stmt|;
name|boolean_t
name|fuid_dirtied
decl_stmt|;
name|uint64_t
name|txtype
init|=
name|TX_SYMLINK
decl_stmt|;
name|boolean_t
name|waited
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|vap
operator|->
name|va_type
operator|==
name|VLNK
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zflg
operator||=
name|ZCILOOK
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|MAXPATHLEN
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_acl_ids_create
argument_list|(
name|dzp
argument_list|,
literal|0
argument_list|,
name|vap
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|,
operator|&
name|acl_ids
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|top
label|:
comment|/* 	 * Attempt to lock directory; fail if entry already exists. 	 */
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|zp
argument_list|,
name|zflg
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|zfs_acl_ids_overquota
argument_list|(
name|zfsvfs
argument_list|,
operator|&
name|acl_ids
argument_list|)
condition|)
block|{
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|fuid_dirtied
operator|=
name|zfsvfs
operator|->
name|z_fuid_dirty
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|MAX
argument_list|(
literal|1
argument_list|,
name|len
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa_create
argument_list|(
name|tx
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|+
name|ZFS_SA_BASE_ATTR_SIZE
operator|+
name|len
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfsvfs
operator|->
name|z_use_sa
operator|&&
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
operator|>
name|ZFS_ACE_SPACE
condition|)
block|{
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|DMU_NEW_OBJECT
argument_list|,
literal|0
argument_list|,
name|acl_ids
operator|.
name|z_aclp
operator|->
name|z_acl_bytes
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_txhold
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|waited
condition|?
name|TXG_WAITED
else|:
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|waited
operator|=
name|B_TRUE
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Create a new object for the symlink. 	 * for version 4 ZPL datsets the symlink will be an SA attribute 	 */
name|zfs_mknode
argument_list|(
name|dzp
argument_list|,
name|vap
argument_list|,
name|tx
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
operator|&
name|zp
argument_list|,
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
if|if
condition|(
name|fuid_dirtied
condition|)
name|zfs_fuid_sync
argument_list|(
name|zfsvfs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
name|error
operator|=
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SYMLINK
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|link
argument_list|,
name|len
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|zfs_sa_symlink
argument_list|(
name|zp
argument_list|,
name|link
argument_list|,
name|len
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_size
operator|=
name|len
expr_stmt|;
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SIZE
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|zp
operator|->
name|z_size
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_size
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Insert the new object into the directory. 	 */
operator|(
name|void
operator|)
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|zp
argument_list|,
name|tx
argument_list|,
name|ZNEW
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_symlink
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|zp
argument_list|,
name|name
argument_list|,
name|link
argument_list|)
expr_stmt|;
name|zfs_acl_ids_free
argument_list|(
operator|&
name|acl_ids
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return, in the buffer contained in the provided uio structure,  * the symbolic path referred to by vp.  *  *	IN:	vp	- vnode of symbolic link.  *		uio	- structure to contain the link path.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	OUT:	uio	- structure containing the link path.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - atime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_readlink
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_is_sa
condition|)
name|error
operator|=
name|sa_lookup_uio
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_SYMLINK
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|uio
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zfs_sa_readlink
argument_list|(
name|zp
argument_list|,
name|uio
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Insert a new entry into directory tdvp referencing svp.  *  *	IN:	tdvp	- Directory to contain new entry.  *		svp	- vnode of new entry.  *		name	- name of new entry.  *		cr	- credentials of caller.  *		ct	- caller context  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	tdvp - ctime|mtime updated  *	 svp - ctime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_link
parameter_list|(
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|vnode_t
modifier|*
name|svp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|znode_t
modifier|*
name|dzp
init|=
name|VTOZ
argument_list|(
name|tdvp
argument_list|)
decl_stmt|;
name|znode_t
modifier|*
name|tzp
decl_stmt|,
modifier|*
name|szp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dzp
operator|->
name|z_zfsvfs
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|vnode_t
modifier|*
name|realvp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|zf
init|=
name|ZNEW
decl_stmt|;
name|uint64_t
name|parent
decl_stmt|;
name|uid_t
name|owner
decl_stmt|;
name|boolean_t
name|waited
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|tdvp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|dzp
argument_list|)
expr_stmt|;
name|zilog
operator|=
name|zfsvfs
operator|->
name|z_log
expr_stmt|;
if|if
condition|(
name|VOP_REALVP
argument_list|(
name|svp
argument_list|,
operator|&
name|realvp
argument_list|,
name|ct
argument_list|)
operator|==
literal|0
condition|)
name|svp
operator|=
name|realvp
expr_stmt|;
comment|/* 	 * POSIX dictates that we return EPERM here. 	 * Better choices include ENOTSUP or EISDIR. 	 */
if|if
condition|(
name|svp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
name|szp
operator|=
name|VTOZ
argument_list|(
name|svp
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|szp
argument_list|)
expr_stmt|;
comment|/* 	 * We check z_zfsvfs rather than v_vfsp here, because snapshots and the 	 * ctldir appear to have the same v_vfsp. 	 */
if|if
condition|(
name|szp
operator|->
name|z_zfsvfs
operator|!=
name|zfsvfs
operator|||
name|zfsctl_is_node
argument_list|(
name|svp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EXDEV
argument_list|)
operator|)
return|;
block|}
comment|/* Prevent links to .zfs/shares files */
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_PARENT
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|parent
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|parent
operator|==
name|zfsvfs
operator|->
name|z_shares_dir
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_utf8
operator|&&
name|u8_validate
argument_list|(
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|error
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|zf
operator||=
name|ZCILOOK
expr_stmt|;
comment|/* 	 * We do not support links between attributes and non-attributes 	 * because of the potential security risk of creating links 	 * into "normal" file space in order to circumvent restrictions 	 * imposed in attribute space. 	 */
if|if
condition|(
operator|(
name|szp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
operator|!=
operator|(
name|dzp
operator|->
name|z_pflags
operator|&
name|ZFS_XATTR
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|owner
operator|=
name|zfs_fuid_map_id
argument_list|(
name|zfsvfs
argument_list|,
name|szp
operator|->
name|z_uid
argument_list|,
name|cr
argument_list|,
name|ZFS_OWNER
argument_list|)
expr_stmt|;
if|if
condition|(
name|owner
operator|!=
name|crgetuid
argument_list|(
name|cr
argument_list|)
operator|&&
name|secpolicy_basic_link
argument_list|(
name|cr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|zfs_zaccess
argument_list|(
name|dzp
argument_list|,
name|ACE_ADD_FILE
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|,
name|cr
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|top
label|:
comment|/* 	 * Attempt to lock directory; fail if entry already exists. 	 */
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|dzp
argument_list|,
name|name
argument_list|,
operator|&
name|tzp
argument_list|,
name|zf
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|szp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|dzp
operator|->
name|z_id
argument_list|,
name|TRUE
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|szp
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|dzp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|waited
condition|?
name|TXG_WAITED
else|:
name|TXG_NOWAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ERESTART
condition|)
block|{
name|waited
operator|=
name|B_TRUE
expr_stmt|;
name|dmu_tx_wait
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zfs_link_create
argument_list|(
name|dl
argument_list|,
name|szp
argument_list|,
name|tx
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|txtype
init|=
name|TX_LINK
decl_stmt|;
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
name|txtype
operator||=
name|TX_CI
expr_stmt|;
name|zfs_log_link
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|,
name|txtype
argument_list|,
name|dzp
argument_list|,
name|szp
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|vnevent_link
argument_list|(
name|svp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zfs_null_putapage() is used when the file system has been force  * unmounted. It just drops the pages.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_null_putapage
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|page_t
modifier|*
name|pp
parameter_list|,
name|u_offset_t
modifier|*
name|offp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|pvn_write_done
argument_list|(
name|pp
argument_list|,
name|B_INVAL
operator||
name|B_FORCE
operator||
name|B_ERROR
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Push a page out to disk, klustering if possible.  *  *	IN:	vp	- file to push page to.  *		pp	- page to push.  *		flags	- additional flags.  *		cr	- credentials of caller.  *  *	OUT:	offp	- start of range pushed.  *		lenp	- len of range pushed.  *  *	RETURN:	0 on success, error code on failure.  *  * NOTE: callers must have locked the page to be pushed.  On  * exit, the page (and all other pages in the kluster) must be  * unlocked.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_putapage
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|page_t
modifier|*
name|pp
parameter_list|,
name|u_offset_t
modifier|*
name|offp
parameter_list|,
name|size_t
modifier|*
name|lenp
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|u_offset_t
name|off
decl_stmt|,
name|koff
decl_stmt|;
name|size_t
name|len
decl_stmt|,
name|klen
decl_stmt|;
name|int
name|err
decl_stmt|;
name|off
operator|=
name|pp
operator|->
name|p_offset
expr_stmt|;
name|len
operator|=
name|PAGESIZE
expr_stmt|;
comment|/* 	 * If our blocksize is bigger than the page size, try to kluster 	 * multiple pages so that we write a full block (thus avoiding 	 * a read-modify-write). 	 */
if|if
condition|(
name|off
operator|<
name|zp
operator|->
name|z_size
operator|&&
name|zp
operator|->
name|z_blksz
operator|>
name|PAGESIZE
condition|)
block|{
name|klen
operator|=
name|P2ROUNDUP
argument_list|(
operator|(
name|ulong_t
operator|)
name|zp
operator|->
name|z_blksz
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|koff
operator|=
name|ISP2
argument_list|(
name|klen
argument_list|)
condition|?
name|P2ALIGN
argument_list|(
name|off
argument_list|,
operator|(
name|u_offset_t
operator|)
name|klen
argument_list|)
else|:
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|koff
operator|<=
name|zp
operator|->
name|z_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|koff
operator|+
name|klen
operator|>
name|zp
operator|->
name|z_size
condition|)
name|klen
operator|=
name|P2ROUNDUP
argument_list|(
name|zp
operator|->
name|z_size
operator|-
name|koff
argument_list|,
operator|(
name|uint64_t
operator|)
name|PAGESIZE
argument_list|)
expr_stmt|;
name|pp
operator|=
name|pvn_write_kluster
argument_list|(
name|vp
argument_list|,
name|pp
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|len
argument_list|,
name|koff
argument_list|,
name|klen
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|btop
argument_list|(
name|len
argument_list|)
argument_list|,
operator|==
argument_list|,
name|btopr
argument_list|(
name|len
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Can't push pages past end-of-file. 	 */
if|if
condition|(
name|off
operator|>=
name|zp
operator|->
name|z_size
condition|)
block|{
comment|/* ignore all pages */
name|err
operator|=
literal|0
expr_stmt|;
goto|goto
name|out
goto|;
block|}
elseif|else
if|if
condition|(
name|off
operator|+
name|len
operator|>
name|zp
operator|->
name|z_size
condition|)
block|{
name|int
name|npages
init|=
name|btopr
argument_list|(
name|zp
operator|->
name|z_size
operator|-
name|off
argument_list|)
decl_stmt|;
name|page_t
modifier|*
name|trunc
decl_stmt|;
name|page_list_break
argument_list|(
operator|&
name|pp
argument_list|,
operator|&
name|trunc
argument_list|,
name|npages
argument_list|)
expr_stmt|;
comment|/* ignore pages past end of file */
if|if
condition|(
name|trunc
condition|)
name|pvn_write_done
argument_list|(
name|trunc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|len
operator|=
name|zp
operator|->
name|z_size
operator|-
name|off
expr_stmt|;
block|}
if|if
condition|(
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_FALSE
argument_list|)
operator|||
name|zfs_owner_overquota
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|,
name|B_TRUE
argument_list|)
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EDQUOT
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_blksz
operator|<=
name|PAGESIZE
condition|)
block|{
name|caddr_t
name|va
init|=
name|zfs_map_page
argument_list|(
name|pp
argument_list|,
name|S_READ
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|len
argument_list|,
operator|<=
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|va
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|pp
argument_list|,
name|va
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|dmu_write_pages
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|pp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|mtime
index|[
literal|2
index|]
decl_stmt|,
name|ctime
index|[
literal|2
index|]
decl_stmt|;
name|sa_bulk_attr_t
name|bulk
index|[
literal|3
index|]
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_MTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|mtime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_CTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|ctime
argument_list|,
literal|16
argument_list|)
expr_stmt|;
name|SA_ADD_BULK_ATTR
argument_list|(
name|bulk
argument_list|,
name|count
argument_list|,
name|SA_ZPL_FLAGS
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
name|NULL
argument_list|,
operator|&
name|zp
operator|->
name|z_pflags
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|zfs_tstamp_update_setup
argument_list|(
name|zp
argument_list|,
name|CONTENT_MODIFIED
argument_list|,
name|mtime
argument_list|,
name|ctime
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|zfs_log_write
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|tx
argument_list|,
name|TX_WRITE
argument_list|,
name|zp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|out
label|:
name|pvn_write_done
argument_list|(
name|pp
argument_list|,
operator|(
name|err
condition|?
name|B_ERROR
else|:
literal|0
operator|)
operator||
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
condition|)
operator|*
name|offp
operator|=
name|off
expr_stmt|;
if|if
condition|(
name|lenp
condition|)
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Copy the portion of the file indicated from pages into the file.  * The pages are stored in a page list attached to the files vnode.  *  *	IN:	vp	- vnode of file to push page data to.  *		off	- position in file to put data.  *		len	- amount of data to write.  *		flags	- flags to control the operation.  *		cr	- credentials of caller.  *		ct	- caller context.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - ctime|mtime updated  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_putpage
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|page_t
modifier|*
name|pp
decl_stmt|;
name|size_t
name|io_len
decl_stmt|;
name|u_offset_t
name|io_off
decl_stmt|;
name|uint_t
name|blksz
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 	 * There's nothing to do if no data is cached. 	 */
if|if
condition|(
operator|!
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Align this request to the file block size in case we kluster. 	 * XXX - this can result in pretty aggresive locking, which can 	 * impact simultanious read/write access.  One option might be 	 * to break up long requests (len == 0) into block-by-block 	 * operations to get narrower locking. 	 */
name|blksz
operator|=
name|zp
operator|->
name|z_blksz
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
name|blksz
argument_list|)
condition|)
name|io_off
operator|=
name|P2ALIGN_TYPED
argument_list|(
name|off
argument_list|,
name|blksz
argument_list|,
name|u_offset_t
argument_list|)
expr_stmt|;
else|else
name|io_off
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|ISP2
argument_list|(
name|blksz
argument_list|)
condition|)
name|io_len
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|len
operator|+
operator|(
name|off
operator|-
name|io_off
operator|)
argument_list|,
name|blksz
argument_list|,
name|size_t
argument_list|)
expr_stmt|;
else|else
name|io_len
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|io_len
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Search the entire vp list for pages>= io_off. 		 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|io_off
argument_list|,
name|UINT64_MAX
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|pvn_vplist_dirty
argument_list|(
name|vp
argument_list|,
name|io_off
argument_list|,
name|zfs_putapage
argument_list|,
name|flags
argument_list|,
name|cr
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|rl
operator|=
name|zfs_range_lock
argument_list|(
name|zp
argument_list|,
name|io_off
argument_list|,
name|io_len
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|off
operator|>
name|zp
operator|->
name|z_size
condition|)
block|{
comment|/* past end of file */
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|len
operator|=
name|MIN
argument_list|(
name|io_len
argument_list|,
name|P2ROUNDUP
argument_list|(
name|zp
operator|->
name|z_size
argument_list|,
name|PAGESIZE
argument_list|)
operator|-
name|io_off
argument_list|)
expr_stmt|;
for|for
control|(
name|off
operator|=
name|io_off
init|;
name|io_off
operator|<
name|off
operator|+
name|len
condition|;
name|io_off
operator|+=
name|io_len
control|)
block|{
if|if
condition|(
operator|(
name|flags
operator|&
name|B_INVAL
operator|)
operator|||
operator|(
operator|(
name|flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
operator|)
condition|)
block|{
name|pp
operator|=
name|page_lookup
argument_list|(
name|vp
argument_list|,
name|io_off
argument_list|,
operator|(
name|flags
operator|&
operator|(
name|B_INVAL
operator||
name|B_FREE
operator|)
operator|)
condition|?
name|SE_EXCL
else|:
name|SE_SHARED
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pp
operator|=
name|page_lookup_nowait
argument_list|(
name|vp
argument_list|,
name|io_off
argument_list|,
operator|(
name|flags
operator|&
name|B_FREE
operator|)
condition|?
name|SE_EXCL
else|:
name|SE_SHARED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|!=
name|NULL
operator|&&
name|pvn_getdirty
argument_list|(
name|pp
argument_list|,
name|flags
argument_list|)
condition|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 			 * Found a dirty page to push 			 */
name|err
operator|=
name|zfs_putapage
argument_list|(
name|vp
argument_list|,
name|pp
argument_list|,
operator|&
name|io_off
argument_list|,
operator|&
name|io_len
argument_list|,
name|flags
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|error
operator|=
name|err
expr_stmt|;
block|}
else|else
block|{
name|io_len
operator|=
name|PAGESIZE
expr_stmt|;
block|}
block|}
name|out
label|:
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|B_ASYNC
operator|)
operator|==
literal|0
operator|||
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zfsvfs
operator|->
name|z_log
argument_list|,
name|zp
operator|->
name|z_id
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|zfs_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_sa_hdl
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The fs has been unmounted, or we did a 		 * suspend/resume and this file no longer exists. 		 */
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pvn_vplist_dirty
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|zfs_null_putapage
argument_list|,
name|B_INVAL
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_count
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
name|zfs_znode_free
argument_list|(
name|zp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Attempt to push any data in the page cache.  If this fails 	 * we will get kicked out later in zfs_zinactive(). 	 */
if|if
condition|(
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|pvn_vplist_dirty
argument_list|(
name|vp
argument_list|,
literal|0
argument_list|,
name|zfs_putapage
argument_list|,
name|B_INVAL
operator||
name|B_ASYNC
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zp
operator|->
name|z_atime_dirty
operator|&&
name|zp
operator|->
name|z_unlinked
operator|==
literal|0
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_sa
argument_list|(
name|tx
argument_list|,
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|zfs_sa_upgrade_txholds
argument_list|(
name|tx
argument_list|,
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mutex_enter
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sa_update
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_ATIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_atime
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_atime
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_atime_dirty
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zp
operator|->
name|z_lock
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
name|zfs_zinactive
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zfsvfs
operator|->
name|z_teardown_inactive_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Bounds-check the seek operation.  *  *	IN:	vp	- vnode seeking within  *		ooff	- old file offset  *		noffp	- pointer to new file offset  *		ct	- caller context  *  *	RETURN:	0 on success, EINVAL if new offset invalid.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_seek
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|ooff
parameter_list|,
name|offset_t
modifier|*
name|noffp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
operator|(
operator|*
name|noffp
operator|<
literal|0
operator|||
operator|*
name|noffp
operator|>
name|MAXOFFSET_T
operator|)
condition|?
name|EINVAL
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pre-filter the generic locking function to trap attempts to place  * a mandatory lock on a memory mapped file.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_frlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|flock64_t
modifier|*
name|bfp
parameter_list|,
name|int
name|flag
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|flk_callback_t
modifier|*
name|flk_cbp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
comment|/* 	 * We are following the UFS semantics with respect to mapcnt 	 * here: If we see that the file is mapped already, then we will 	 * return an error, but we don't worry about races between this 	 * function and zfs_map(). 	 */
if|if
condition|(
name|zp
operator|->
name|z_mapcnt
operator|>
literal|0
operator|&&
name|MANDMODE
argument_list|(
name|zp
operator|->
name|z_mode
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|fs_frlock
argument_list|(
name|vp
argument_list|,
name|cmd
argument_list|,
name|bfp
argument_list|,
name|flag
argument_list|,
name|offset
argument_list|,
name|flk_cbp
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If we can't find a page in the cache, we will create a new page  * and fill it with file data.  For efficiency, we may try to fill  * multiple pages at once (klustering) to fill up the supplied page  * list.  Note that the pages to be filled are held with an exclusive  * lock to prevent access by other threads while they are being filled.  */
end_comment

begin_function
specifier|static
name|int
name|zfs_fillpage
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|u_offset_t
name|off
parameter_list|,
name|struct
name|seg
modifier|*
name|seg
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|page_t
modifier|*
name|pl
index|[]
parameter_list|,
name|size_t
name|plsz
parameter_list|,
name|enum
name|seg_rw
name|rw
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|page_t
modifier|*
name|pp
decl_stmt|,
modifier|*
name|cur_pp
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_os
decl_stmt|;
name|u_offset_t
name|io_off
decl_stmt|,
name|total
decl_stmt|;
name|size_t
name|io_len
decl_stmt|;
name|int
name|err
decl_stmt|;
if|if
condition|(
name|plsz
operator|==
name|PAGESIZE
operator|||
name|zp
operator|->
name|z_blksz
operator|<=
name|PAGESIZE
condition|)
block|{
comment|/* 		 * We only have a single page, don't bother klustering 		 */
name|io_off
operator|=
name|off
expr_stmt|;
name|io_len
operator|=
name|PAGESIZE
expr_stmt|;
name|pp
operator|=
name|page_create_va
argument_list|(
name|vp
argument_list|,
name|io_off
argument_list|,
name|io_len
argument_list|,
name|PG_EXCL
operator||
name|PG_WAIT
argument_list|,
name|seg
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Try to find enough pages to fill the page list 		 */
name|pp
operator|=
name|pvn_read_kluster
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|seg
argument_list|,
name|addr
argument_list|,
operator|&
name|io_off
argument_list|,
operator|&
name|io_len
argument_list|,
name|off
argument_list|,
name|plsz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
block|{
comment|/* 		 * The page already exists, nothing to do here. 		 */
operator|*
name|pl
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Fill the pages in the kluster. 	 */
name|cur_pp
operator|=
name|pp
expr_stmt|;
for|for
control|(
name|total
operator|=
name|io_off
operator|+
name|io_len
init|;
name|io_off
operator|<
name|total
condition|;
name|io_off
operator|+=
name|PAGESIZE
control|)
block|{
name|caddr_t
name|va
decl_stmt|;
name|ASSERT3U
argument_list|(
name|io_off
argument_list|,
operator|==
argument_list|,
name|cur_pp
operator|->
name|p_offset
argument_list|)
expr_stmt|;
name|va
operator|=
name|zfs_map_page
argument_list|(
name|cur_pp
argument_list|,
name|S_WRITE
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|zp
operator|->
name|z_id
argument_list|,
name|io_off
argument_list|,
name|PAGESIZE
argument_list|,
name|va
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
name|zfs_unmap_page
argument_list|(
name|cur_pp
argument_list|,
name|va
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
comment|/* On error, toss the entire kluster */
name|pvn_read_done
argument_list|(
name|pp
argument_list|,
name|B_ERROR
argument_list|)
expr_stmt|;
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|err
operator|==
name|ECKSUM
condition|)
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|cur_pp
operator|=
name|cur_pp
operator|->
name|p_next
expr_stmt|;
block|}
comment|/* 	 * Fill in the page list array from the kluster starting 	 * from the desired offset `off'. 	 * NOTE: the page list will always be null terminated. 	 */
name|pvn_plist_init
argument_list|(
name|pp
argument_list|,
name|pl
argument_list|,
name|plsz
argument_list|,
name|off
argument_list|,
name|io_len
argument_list|,
name|rw
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pl
operator|==
name|NULL
operator|||
operator|(
operator|*
name|pl
operator|)
operator|->
name|p_offset
operator|==
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return pointers to the pages for the file region [off, off + len]  * in the pl array.  If plsz is greater than len, this function may  * also return page pointers from after the specified region  * (i.e. the region [off, off + plsz]).  These additional pages are  * only returned if they are already in the cache, or were created as  * part of a klustered read.  *  *	IN:	vp	- vnode of file to get data from.  *		off	- position in file to get data from.  *		len	- amount of data to retrieve.  *		plsz	- length of provided page list.  *		seg	- segment to obtain pages for.  *		addr	- virtual address of fault.  *		rw	- mode of created pages.  *		cr	- credentials of caller.  *		ct	- caller context.  *  *	OUT:	protp	- protection mode of created pages.  *		pl	- list of pages created.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - atime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_getpage
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint_t
modifier|*
name|protp
parameter_list|,
name|page_t
modifier|*
name|pl
index|[]
parameter_list|,
name|size_t
name|plsz
parameter_list|,
name|struct
name|seg
modifier|*
name|seg
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|enum
name|seg_rw
name|rw
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|page_t
modifier|*
modifier|*
name|pl0
init|=
name|pl
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
comment|/* we do our own caching, faultahead is unnecessary */
if|if
condition|(
name|pl
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
elseif|else
if|if
condition|(
name|len
operator|>
name|plsz
condition|)
name|len
operator|=
name|plsz
expr_stmt|;
else|else
name|len
operator|=
name|P2ROUNDUP
argument_list|(
name|len
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|plsz
operator|>=
name|len
argument_list|)
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|protp
condition|)
operator|*
name|protp
operator|=
name|PROT_ALL
expr_stmt|;
comment|/* 	 * Loop through the requested range [off, off + len) looking 	 * for pages.  If we don't find a page, we will need to create 	 * a new page and fill it with data from the file. 	 */
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|*
name|pl
operator|=
name|page_lookup
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|SE_SHARED
argument_list|)
condition|)
operator|*
operator|(
name|pl
operator|+
literal|1
operator|)
operator|=
name|NULL
expr_stmt|;
elseif|else
if|if
condition|(
name|err
operator|=
name|zfs_fillpage
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|seg
argument_list|,
name|addr
argument_list|,
name|pl
argument_list|,
name|plsz
argument_list|,
name|rw
argument_list|)
condition|)
goto|goto
name|out
goto|;
while|while
condition|(
operator|*
name|pl
condition|)
block|{
name|ASSERT3U
argument_list|(
operator|(
operator|*
name|pl
operator|)
operator|->
name|p_offset
argument_list|,
operator|==
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|PAGESIZE
expr_stmt|;
name|addr
operator|+=
name|PAGESIZE
expr_stmt|;
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|ASSERT3U
argument_list|(
name|len
argument_list|,
operator|>=
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|len
operator|-=
name|PAGESIZE
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|plsz
argument_list|,
operator|>=
argument_list|,
name|PAGESIZE
argument_list|)
expr_stmt|;
name|plsz
operator|-=
name|PAGESIZE
expr_stmt|;
name|pl
operator|++
expr_stmt|;
block|}
block|}
comment|/* 	 * Fill out the page array with any pages already in the cache. 	 */
while|while
condition|(
name|plsz
operator|>
literal|0
operator|&&
operator|(
operator|*
name|pl
operator|++
operator|=
name|page_lookup_nowait
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|SE_SHARED
argument_list|)
operator|)
condition|)
block|{
name|off
operator|+=
name|PAGESIZE
expr_stmt|;
name|plsz
operator|-=
name|PAGESIZE
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|err
condition|)
block|{
comment|/* 		 * Release any pages we have previously locked. 		 */
while|while
condition|(
name|pl
operator|>
name|pl0
condition|)
name|page_unlock
argument_list|(
operator|*
operator|--
name|pl
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZFS_ACCESSTIME_STAMP
argument_list|(
name|zfsvfs
argument_list|,
name|zp
argument_list|)
expr_stmt|;
block|}
operator|*
name|pl
operator|=
name|NULL
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Request a memory map for a section of a file.  This code interacts  * with common code and the VM system as follows:  *  * - common code calls mmap(), which ends up in smmap_common()  * - this calls VOP_MAP(), which takes you into (say) zfs  * - zfs_map() calls as_map(), passing segvn_create() as the callback  * - segvn_create() creates the new segment and calls VOP_ADDMAP()  * - zfs_addmap() updates z_mapcnt  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_map
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|struct
name|as
modifier|*
name|as
parameter_list|,
name|caddr_t
modifier|*
name|addrp
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uchar_t
name|prot
parameter_list|,
name|uchar_t
name|maxprot
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|segvn_crargs_t
name|vn_a
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|prot
operator|&
name|PROT_WRITE
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
operator|(
name|ZFS_IMMUTABLE
operator||
name|ZFS_READONLY
operator||
name|ZFS_APPENDONLY
operator|)
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EPERM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|PROT_READ
operator||
name|PROT_EXEC
operator|)
operator|)
operator|&&
operator|(
name|zp
operator|->
name|z_pflags
operator|&
name|ZFS_AV_QUARANTINED
operator|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VNOMAP
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSYS
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|off
operator|<
literal|0
operator|||
name|len
operator|>
name|MAXOFFSET_T
operator|-
name|off
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENODEV
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If file is locked, disallow mapping. 	 */
if|if
condition|(
name|MANDMODE
argument_list|(
name|zp
operator|->
name|z_mode
argument_list|)
operator|&&
name|vn_has_flocks
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
name|as_rangelock
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|error
operator|=
name|choose_addr
argument_list|(
name|as
argument_list|,
name|addrp
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
name|ADDR_VACALIGN
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|as_rangeunlock
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|vn_a
operator|.
name|vp
operator|=
name|vp
expr_stmt|;
name|vn_a
operator|.
name|offset
operator|=
operator|(
name|u_offset_t
operator|)
name|off
expr_stmt|;
name|vn_a
operator|.
name|type
operator|=
name|flags
operator|&
name|MAP_TYPE
expr_stmt|;
name|vn_a
operator|.
name|prot
operator|=
name|prot
expr_stmt|;
name|vn_a
operator|.
name|maxprot
operator|=
name|maxprot
expr_stmt|;
name|vn_a
operator|.
name|cred
operator|=
name|cr
expr_stmt|;
name|vn_a
operator|.
name|amp
operator|=
name|NULL
expr_stmt|;
name|vn_a
operator|.
name|flags
operator|=
name|flags
operator|&
operator|~
name|MAP_TYPE
expr_stmt|;
name|vn_a
operator|.
name|szc
operator|=
literal|0
expr_stmt|;
name|vn_a
operator|.
name|lgrp_mem_policy_flags
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|as_map
argument_list|(
name|as
argument_list|,
operator|*
name|addrp
argument_list|,
name|len
argument_list|,
name|segvn_create
argument_list|,
operator|&
name|vn_a
argument_list|)
expr_stmt|;
name|as_rangeunlock
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_addmap
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|struct
name|as
modifier|*
name|as
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uchar_t
name|prot
parameter_list|,
name|uchar_t
name|maxprot
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|uint64_t
name|pages
init|=
name|btopr
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_mapcnt
argument_list|,
name|pages
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The reason we push dirty pages as part of zfs_delmap() is so that we get a  * more accurate mtime for the associated file.  Since we don't have a way of  * detecting when the data was actually modified, we have to resort to  * heuristics.  If an explicit msync() is done, then we mark the mtime when the  * last page is pushed.  The problem occurs when the msync() call is omitted,  * which by far the most common case:  *  *	open()  *	mmap()  *<modify memory>  *	munmap()  *	close()  *<time lapse>  *	putpage() via fsflush  *  * If we wait until fsflush to come along, we can have a modification time that  * is some arbitrary point in the future.  In order to prevent this in the  * common case, we flush pages whenever a (MAP_SHARED, PROT_WRITE) mapping is  * torn down.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_delmap
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|struct
name|as
modifier|*
name|as
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint_t
name|prot
parameter_list|,
name|uint_t
name|maxprot
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|uint64_t
name|pages
init|=
name|btopr
argument_list|(
name|len
argument_list|)
decl_stmt|;
name|ASSERT3U
argument_list|(
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_mapcnt
argument_list|,
operator|>=
argument_list|,
name|pages
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_mapcnt
argument_list|,
operator|-
name|pages
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|MAP_SHARED
operator|)
operator|&&
operator|(
name|prot
operator|&
name|PROT_WRITE
operator|)
operator|&&
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
operator|(
name|void
operator|)
name|VOP_PUTPAGE
argument_list|(
name|vp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|B_ASYNC
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free or allocate space in a file.  Currently, this function only  * supports the `F_FREESP' command.  However, this command is somewhat  * misnamed, as its functionality includes the ability to allocate as  * well as free space.  *  *	IN:	vp	- vnode of file to free data in.  *		cmd	- action to take (only F_FREESP supported).  *		bfp	- section of file to free/alloc.  *		flag	- current file open mode flags.  *		offset	- current file offset.  *		cr	- credentials of caller [UNUSED].  *		ct	- caller context.  *  *	RETURN:	0 on success, error code on failure.  *  * Timestamps:  *	vp - ctime|mtime updated  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfs_space
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|flock64_t
modifier|*
name|bfp
parameter_list|,
name|int
name|flag
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|uint64_t
name|off
decl_stmt|,
name|len
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|!=
name|F_FREESP
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * In a case vp->v_vfsp != zp->z_zfsvfs->z_vfs (e.g. snapshots) our 	 * callers might not be able to detect properly that we are read-only, 	 * so check it explicitly here. 	 */
if|if
condition|(
name|zfsvfs
operator|->
name|z_vfs
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
operator|=
name|convoff
argument_list|(
name|vp
argument_list|,
name|bfp
argument_list|,
literal|0
argument_list|,
name|offset
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|bfp
operator|->
name|l_len
operator|<
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|off
operator|=
name|bfp
operator|->
name|l_start
expr_stmt|;
name|len
operator|=
name|bfp
operator|->
name|l_len
expr_stmt|;
comment|/* 0 means from off to end of file */
name|error
operator|=
name|zfs_freesp
argument_list|(
name|zp
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|flag
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|off
operator|==
literal|0
operator|&&
name|len
operator|==
literal|0
condition|)
name|vnevent_truncate
argument_list|(
name|ZTOV
argument_list|(
name|zp
argument_list|)
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_fid
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|uint32_t
name|gen
decl_stmt|;
name|uint64_t
name|gen64
decl_stmt|;
name|uint64_t
name|object
init|=
name|zp
operator|->
name|z_id
decl_stmt|;
name|zfid_short_t
modifier|*
name|zfid
decl_stmt|;
name|int
name|size
decl_stmt|,
name|i
decl_stmt|,
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|sa_lookup
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_GEN
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|gen64
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|gen
operator|=
operator|(
name|uint32_t
operator|)
name|gen64
expr_stmt|;
name|size
operator|=
operator|(
name|zfsvfs
operator|->
name|z_parent
operator|!=
name|zfsvfs
operator|)
condition|?
name|LONG_FID_LEN
else|:
name|SHORT_FID_LEN
expr_stmt|;
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|<
name|size
condition|)
block|{
name|fidp
operator|->
name|fid_len
operator|=
name|size
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
name|zfid
operator|=
operator|(
name|zfid_short_t
operator|*
operator|)
name|fidp
expr_stmt|;
name|zfid
operator|->
name|zf_len
operator|=
name|size
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_object
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_object
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|object
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* Must have a non-zero generation number to distinguish from .zfs */
if|if
condition|(
name|gen
operator|==
literal|0
condition|)
name|gen
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_gen
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_gen
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|gen
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|LONG_FID_LEN
condition|)
block|{
name|uint64_t
name|objsetid
init|=
name|dmu_objset_id
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
decl_stmt|;
name|zfid_long_t
modifier|*
name|zlfid
decl_stmt|;
name|zlfid
operator|=
operator|(
name|zfid_long_t
operator|*
operator|)
name|fidp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setid
argument_list|)
condition|;
name|i
operator|++
control|)
name|zlfid
operator|->
name|zf_setid
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|objsetid
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* XXX - this should be the generation number for the objset */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zlfid
operator|->
name|zf_setgen
argument_list|)
condition|;
name|i
operator|++
control|)
name|zlfid
operator|->
name|zf_setgen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_pathconf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|ulong_t
modifier|*
name|valp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
decl_stmt|,
modifier|*
name|xzp
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|zfs_dirlock_t
modifier|*
name|dl
decl_stmt|;
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|_PC_LINK_MAX
case|:
operator|*
name|valp
operator|=
name|ULONG_MAX
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_FILESIZEBITS
case|:
operator|*
name|valp
operator|=
literal|64
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_XATTR_EXISTS
case|:
name|zp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|zfsvfs
operator|=
name|zp
operator|->
name|z_zfsvfs
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|zfs_dirent_lock
argument_list|(
operator|&
name|dl
argument_list|,
name|zp
argument_list|,
literal|""
argument_list|,
operator|&
name|xzp
argument_list|,
name|ZXATTR
operator||
name|ZEXISTS
operator||
name|ZSHARED
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|zfs_dirent_unlock
argument_list|(
name|dl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|zfs_dirempty
argument_list|(
name|xzp
argument_list|)
condition|)
operator|*
name|valp
operator|=
literal|1
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|xzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* 			 * If there aren't extended attributes, it's the 			 * same as having zero of them. 			 */
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
case|case
name|_PC_SATTR_ENABLED
case|:
case|case
name|_PC_SATTR_EXISTS
case|:
operator|*
name|valp
operator|=
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_SYSATTR_VIEWS
argument_list|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|||
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_ACCESS_FILTERING
case|:
operator|*
name|valp
operator|=
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACCESS_FILTER
argument_list|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VDIR
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_ACL_ENABLED
case|:
operator|*
name|valp
operator|=
name|_ACL_ACE_ENABLED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_MIN_HOLE_SIZE
case|:
operator|*
name|valp
operator|=
operator|(
name|ulong_t
operator|)
name|SPA_MINBLOCKSIZE
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|_PC_TIMESTAMP_RESOLUTION
case|:
comment|/* nanosecond timestamp resolution */
operator|*
name|valp
operator|=
literal|1L
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
default|default:
return|return
operator|(
name|fs_pathconf
argument_list|(
name|vp
argument_list|,
name|cmd
argument_list|,
name|valp
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_getsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_getacl
argument_list|(
name|zp
argument_list|,
name|vsecp
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_setsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|error
decl_stmt|;
name|boolean_t
name|skipaclchk
init|=
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
condition|?
name|B_TRUE
else|:
name|B_FALSE
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zfsvfs
operator|->
name|z_log
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfs_setacl
argument_list|(
name|zp
argument_list|,
name|vsecp
argument_list|,
name|skipaclchk
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_os
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
condition|)
name|zil_commit
argument_list|(
name|zilog
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The smallest read we may consider to loan out an arcbuf.  * This must be a power of 2.  */
end_comment

begin_decl_stmt
name|int
name|zcr_blksz_min
init|=
operator|(
literal|1
operator|<<
literal|10
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1K */
end_comment

begin_comment
comment|/*  * If set to less than the file block size, allow loaning out of an  * arcbuf for a partial block read.  This must be a power of 2.  */
end_comment

begin_decl_stmt
name|int
name|zcr_blksz_max
init|=
operator|(
literal|1
operator|<<
literal|17
operator|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 128K */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_reqzcbuf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|enum
name|uio_rw
name|ioflag
parameter_list|,
name|xuio_t
modifier|*
name|xuio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|znode_t
modifier|*
name|zp
init|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|zp
operator|->
name|z_zfsvfs
decl_stmt|;
name|int
name|max_blksz
init|=
name|zfsvfs
operator|->
name|z_max_blksz
decl_stmt|;
name|uio_t
modifier|*
name|uio
init|=
operator|&
name|xuio
operator|->
name|xu_uio
decl_stmt|;
name|ssize_t
name|size
init|=
name|uio
operator|->
name|uio_resid
decl_stmt|;
name|offset_t
name|offset
init|=
name|uio
operator|->
name|uio_loffset
decl_stmt|;
name|int
name|blksz
decl_stmt|;
name|int
name|fullblk
decl_stmt|,
name|i
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
decl_stmt|;
name|ssize_t
name|maxsize
decl_stmt|;
name|int
name|preamble
decl_stmt|,
name|postamble
decl_stmt|;
if|if
condition|(
name|xuio
operator|->
name|xu_type
operator|!=
name|UIOTYPE_ZEROCOPY
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|ZFS_VERIFY_ZP
argument_list|(
name|zp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ioflag
condition|)
block|{
case|case
name|UIO_WRITE
case|:
comment|/* 		 * Loan out an arc_buf for write if write size is bigger than 		 * max_blksz, and the file's block size is also max_blksz. 		 */
name|blksz
operator|=
name|max_blksz
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|blksz
operator|||
name|zp
operator|->
name|z_blksz
operator|!=
name|blksz
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Caller requests buffers for write before knowing where the 		 * write offset might be (e.g. NFS TCP write). 		 */
if|if
condition|(
name|offset
operator|==
operator|-
literal|1
condition|)
block|{
name|preamble
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|preamble
operator|=
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
if|if
condition|(
name|preamble
condition|)
block|{
name|preamble
operator|=
name|blksz
operator|-
name|preamble
expr_stmt|;
name|size
operator|-=
name|preamble
expr_stmt|;
block|}
block|}
name|postamble
operator|=
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|size
operator|-=
name|postamble
expr_stmt|;
name|fullblk
operator|=
name|size
operator|/
name|blksz
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_xuio_init
argument_list|(
name|xuio
argument_list|,
operator|(
name|preamble
operator|!=
literal|0
operator|)
operator|+
name|fullblk
operator|+
operator|(
name|postamble
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
name|DTRACE_PROBE3
argument_list|(
name|zfs_reqzcbuf_align
argument_list|,
name|int
argument_list|,
name|preamble
argument_list|,
name|int
argument_list|,
name|postamble
argument_list|,
name|int
argument_list|,
operator|(
name|preamble
operator|!=
literal|0
operator|)
operator|+
name|fullblk
operator|+
operator|(
name|postamble
operator|!=
literal|0
operator|)
argument_list|)
expr_stmt|;
comment|/* 		 * Have to fix iov base/len for partial buffers.  They 		 * currently represent full arc_buf's. 		 */
if|if
condition|(
name|preamble
condition|)
block|{
comment|/* data begins in the middle of the arc_buf */
name|abuf
operator|=
name|dmu_request_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_xuio_add
argument_list|(
name|xuio
argument_list|,
name|abuf
argument_list|,
name|blksz
operator|-
name|preamble
argument_list|,
name|preamble
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fullblk
condition|;
name|i
operator|++
control|)
block|{
name|abuf
operator|=
name|dmu_request_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_xuio_add
argument_list|(
name|xuio
argument_list|,
name|abuf
argument_list|,
literal|0
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|postamble
condition|)
block|{
comment|/* data ends in the middle of the arc_buf */
name|abuf
operator|=
name|dmu_request_arcbuf
argument_list|(
name|sa_get_db
argument_list|(
name|zp
operator|->
name|z_sa_hdl
argument_list|)
argument_list|,
name|blksz
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_xuio_add
argument_list|(
name|xuio
argument_list|,
name|abuf
argument_list|,
literal|0
argument_list|,
name|postamble
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|UIO_READ
case|:
comment|/* 		 * Loan out an arc_buf for read if the read size is larger than 		 * the current file block size.  Block alignment is not 		 * considered.  Partial arc_buf will be loaned out for read. 		 */
name|blksz
operator|=
name|zp
operator|->
name|z_blksz
expr_stmt|;
if|if
condition|(
name|blksz
operator|<
name|zcr_blksz_min
condition|)
name|blksz
operator|=
name|zcr_blksz_min
expr_stmt|;
if|if
condition|(
name|blksz
operator|>
name|zcr_blksz_max
condition|)
name|blksz
operator|=
name|zcr_blksz_max
expr_stmt|;
comment|/* avoid potential complexity of dealing with it */
if|if
condition|(
name|blksz
operator|>
name|max_blksz
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|maxsize
operator|=
name|zp
operator|->
name|z_size
operator|-
name|uio
operator|->
name|uio_loffset
expr_stmt|;
if|if
condition|(
name|size
operator|>
name|maxsize
condition|)
name|size
operator|=
name|maxsize
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|blksz
operator|||
name|vn_has_cached_data
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
break|break;
default|default:
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|uio
operator|->
name|uio_extflg
operator|=
name|UIO_XUIO
expr_stmt|;
name|XUIO_XUZC_RW
argument_list|(
name|xuio
argument_list|)
operator|=
name|ioflag
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_retzcbuf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|xuio_t
modifier|*
name|xuio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|arc_buf_t
modifier|*
name|abuf
decl_stmt|;
name|int
name|ioflag
init|=
name|XUIO_XUZC_RW
argument_list|(
name|xuio
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|xuio
operator|->
name|xu_type
operator|==
name|UIOTYPE_ZEROCOPY
argument_list|)
expr_stmt|;
name|i
operator|=
name|dmu_xuio_cnt
argument_list|(
name|xuio
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|abuf
operator|=
name|dmu_xuio_arcbuf
argument_list|(
name|xuio
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* 		 * if abuf == NULL, it must be a write buffer 		 * that has been returned in zfs_write(). 		 */
if|if
condition|(
name|abuf
condition|)
name|dmu_return_arcbuf
argument_list|(
name|abuf
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|abuf
operator|||
name|ioflag
operator|==
name|UIO_WRITE
argument_list|)
expr_stmt|;
block|}
name|dmu_xuio_fini
argument_list|(
name|xuio
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Predeclare these here so that the compiler assumes that  * this is an "old style" function declaration that does  * not include arguments => we won't get type mismatch errors  * in the initializations that follow.  */
end_comment

begin_function_decl
specifier|static
name|int
name|zfs_inval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfs_isdir
parameter_list|()
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|zfs_inval
parameter_list|()
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfs_isdir
parameter_list|()
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EISDIR
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Directory vnode operations template  */
end_comment

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfs_dvnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|fs_operation_def_t
name|zfs_dvnodeops_template
index|[]
init|=
block|{
name|VOPNAME_OPEN
block|,
block|{
operator|.
name|vop_open
operator|=
name|zfs_open
block|}
block|,
name|VOPNAME_CLOSE
block|,
block|{
operator|.
name|vop_close
operator|=
name|zfs_close
block|}
block|,
name|VOPNAME_READ
block|,
block|{
operator|.
name|error
operator|=
name|zfs_isdir
block|}
block|,
name|VOPNAME_WRITE
block|,
block|{
operator|.
name|error
operator|=
name|zfs_isdir
block|}
block|,
name|VOPNAME_IOCTL
block|,
block|{
operator|.
name|vop_ioctl
operator|=
name|zfs_ioctl
block|}
block|,
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfs_getattr
block|}
block|,
name|VOPNAME_SETATTR
block|,
block|{
operator|.
name|vop_setattr
operator|=
name|zfs_setattr
block|}
block|,
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfs_access
block|}
block|,
name|VOPNAME_LOOKUP
block|,
block|{
operator|.
name|vop_lookup
operator|=
name|zfs_lookup
block|}
block|,
name|VOPNAME_CREATE
block|,
block|{
operator|.
name|vop_create
operator|=
name|zfs_create
block|}
block|,
name|VOPNAME_REMOVE
block|,
block|{
operator|.
name|vop_remove
operator|=
name|zfs_remove
block|}
block|,
name|VOPNAME_LINK
block|,
block|{
operator|.
name|vop_link
operator|=
name|zfs_link
block|}
block|,
name|VOPNAME_RENAME
block|,
block|{
operator|.
name|vop_rename
operator|=
name|zfs_rename
block|}
block|,
name|VOPNAME_MKDIR
block|,
block|{
operator|.
name|vop_mkdir
operator|=
name|zfs_mkdir
block|}
block|,
name|VOPNAME_RMDIR
block|,
block|{
operator|.
name|vop_rmdir
operator|=
name|zfs_rmdir
block|}
block|,
name|VOPNAME_READDIR
block|,
block|{
operator|.
name|vop_readdir
operator|=
name|zfs_readdir
block|}
block|,
name|VOPNAME_SYMLINK
block|,
block|{
operator|.
name|vop_symlink
operator|=
name|zfs_symlink
block|}
block|,
name|VOPNAME_FSYNC
block|,
block|{
operator|.
name|vop_fsync
operator|=
name|zfs_fsync
block|}
block|,
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfs_inactive
block|}
block|,
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfs_fid
block|}
block|,
name|VOPNAME_SEEK
block|,
block|{
operator|.
name|vop_seek
operator|=
name|zfs_seek
block|}
block|,
name|VOPNAME_PATHCONF
block|,
block|{
operator|.
name|vop_pathconf
operator|=
name|zfs_pathconf
block|}
block|,
name|VOPNAME_GETSECATTR
block|,
block|{
operator|.
name|vop_getsecattr
operator|=
name|zfs_getsecattr
block|}
block|,
name|VOPNAME_SETSECATTR
block|,
block|{
operator|.
name|vop_setsecattr
operator|=
name|zfs_setsecattr
block|}
block|,
name|VOPNAME_VNEVENT
block|,
block|{
operator|.
name|vop_vnevent
operator|=
name|fs_vnevent_support
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Regular file vnode operations template  */
end_comment

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfs_fvnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|fs_operation_def_t
name|zfs_fvnodeops_template
index|[]
init|=
block|{
name|VOPNAME_OPEN
block|,
block|{
operator|.
name|vop_open
operator|=
name|zfs_open
block|}
block|,
name|VOPNAME_CLOSE
block|,
block|{
operator|.
name|vop_close
operator|=
name|zfs_close
block|}
block|,
name|VOPNAME_READ
block|,
block|{
operator|.
name|vop_read
operator|=
name|zfs_read
block|}
block|,
name|VOPNAME_WRITE
block|,
block|{
operator|.
name|vop_write
operator|=
name|zfs_write
block|}
block|,
name|VOPNAME_IOCTL
block|,
block|{
operator|.
name|vop_ioctl
operator|=
name|zfs_ioctl
block|}
block|,
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfs_getattr
block|}
block|,
name|VOPNAME_SETATTR
block|,
block|{
operator|.
name|vop_setattr
operator|=
name|zfs_setattr
block|}
block|,
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfs_access
block|}
block|,
name|VOPNAME_LOOKUP
block|,
block|{
operator|.
name|vop_lookup
operator|=
name|zfs_lookup
block|}
block|,
name|VOPNAME_RENAME
block|,
block|{
operator|.
name|vop_rename
operator|=
name|zfs_rename
block|}
block|,
name|VOPNAME_FSYNC
block|,
block|{
operator|.
name|vop_fsync
operator|=
name|zfs_fsync
block|}
block|,
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfs_inactive
block|}
block|,
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfs_fid
block|}
block|,
name|VOPNAME_SEEK
block|,
block|{
operator|.
name|vop_seek
operator|=
name|zfs_seek
block|}
block|,
name|VOPNAME_FRLOCK
block|,
block|{
operator|.
name|vop_frlock
operator|=
name|zfs_frlock
block|}
block|,
name|VOPNAME_SPACE
block|,
block|{
operator|.
name|vop_space
operator|=
name|zfs_space
block|}
block|,
name|VOPNAME_GETPAGE
block|,
block|{
operator|.
name|vop_getpage
operator|=
name|zfs_getpage
block|}
block|,
name|VOPNAME_PUTPAGE
block|,
block|{
operator|.
name|vop_putpage
operator|=
name|zfs_putpage
block|}
block|,
name|VOPNAME_MAP
block|,
block|{
operator|.
name|vop_map
operator|=
name|zfs_map
block|}
block|,
name|VOPNAME_ADDMAP
block|,
block|{
operator|.
name|vop_addmap
operator|=
name|zfs_addmap
block|}
block|,
name|VOPNAME_DELMAP
block|,
block|{
operator|.
name|vop_delmap
operator|=
name|zfs_delmap
block|}
block|,
name|VOPNAME_PATHCONF
block|,
block|{
operator|.
name|vop_pathconf
operator|=
name|zfs_pathconf
block|}
block|,
name|VOPNAME_GETSECATTR
block|,
block|{
operator|.
name|vop_getsecattr
operator|=
name|zfs_getsecattr
block|}
block|,
name|VOPNAME_SETSECATTR
block|,
block|{
operator|.
name|vop_setsecattr
operator|=
name|zfs_setsecattr
block|}
block|,
name|VOPNAME_VNEVENT
block|,
block|{
operator|.
name|vop_vnevent
operator|=
name|fs_vnevent_support
block|}
block|,
name|VOPNAME_REQZCBUF
block|,
block|{
operator|.
name|vop_reqzcbuf
operator|=
name|zfs_reqzcbuf
block|}
block|,
name|VOPNAME_RETZCBUF
block|,
block|{
operator|.
name|vop_retzcbuf
operator|=
name|zfs_retzcbuf
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Symbolic link vnode operations template  */
end_comment

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfs_symvnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|fs_operation_def_t
name|zfs_symvnodeops_template
index|[]
init|=
block|{
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfs_getattr
block|}
block|,
name|VOPNAME_SETATTR
block|,
block|{
operator|.
name|vop_setattr
operator|=
name|zfs_setattr
block|}
block|,
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfs_access
block|}
block|,
name|VOPNAME_RENAME
block|,
block|{
operator|.
name|vop_rename
operator|=
name|zfs_rename
block|}
block|,
name|VOPNAME_READLINK
block|,
block|{
operator|.
name|vop_readlink
operator|=
name|zfs_readlink
block|}
block|,
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfs_inactive
block|}
block|,
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfs_fid
block|}
block|,
name|VOPNAME_PATHCONF
block|,
block|{
operator|.
name|vop_pathconf
operator|=
name|zfs_pathconf
block|}
block|,
name|VOPNAME_VNEVENT
block|,
block|{
operator|.
name|vop_vnevent
operator|=
name|fs_vnevent_support
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * special share hidden files vnode operations template  */
end_comment

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfs_sharevnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|fs_operation_def_t
name|zfs_sharevnodeops_template
index|[]
init|=
block|{
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfs_getattr
block|}
block|,
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfs_access
block|}
block|,
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfs_inactive
block|}
block|,
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfs_fid
block|}
block|,
name|VOPNAME_PATHCONF
block|,
block|{
operator|.
name|vop_pathconf
operator|=
name|zfs_pathconf
block|}
block|,
name|VOPNAME_GETSECATTR
block|,
block|{
operator|.
name|vop_getsecattr
operator|=
name|zfs_getsecattr
block|}
block|,
name|VOPNAME_SETSECATTR
block|,
block|{
operator|.
name|vop_setsecattr
operator|=
name|zfs_setsecattr
block|}
block|,
name|VOPNAME_VNEVENT
block|,
block|{
operator|.
name|vop_vnevent
operator|=
name|fs_vnevent_support
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Extended attribute directory vnode operations template  *  * This template is identical to the directory vnodes  * operation template except for restricted operations:  *	VOP_MKDIR()  *	VOP_SYMLINK()  *  * Note that there are other restrictions embedded in:  *	zfs_create()	- restrict type to VREG  *	zfs_link()	- no links into/out of attribute space  *	zfs_rename()	- no moves into/out of attribute space  */
end_comment

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfs_xdvnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|fs_operation_def_t
name|zfs_xdvnodeops_template
index|[]
init|=
block|{
name|VOPNAME_OPEN
block|,
block|{
operator|.
name|vop_open
operator|=
name|zfs_open
block|}
block|,
name|VOPNAME_CLOSE
block|,
block|{
operator|.
name|vop_close
operator|=
name|zfs_close
block|}
block|,
name|VOPNAME_IOCTL
block|,
block|{
operator|.
name|vop_ioctl
operator|=
name|zfs_ioctl
block|}
block|,
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfs_getattr
block|}
block|,
name|VOPNAME_SETATTR
block|,
block|{
operator|.
name|vop_setattr
operator|=
name|zfs_setattr
block|}
block|,
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfs_access
block|}
block|,
name|VOPNAME_LOOKUP
block|,
block|{
operator|.
name|vop_lookup
operator|=
name|zfs_lookup
block|}
block|,
name|VOPNAME_CREATE
block|,
block|{
operator|.
name|vop_create
operator|=
name|zfs_create
block|}
block|,
name|VOPNAME_REMOVE
block|,
block|{
operator|.
name|vop_remove
operator|=
name|zfs_remove
block|}
block|,
name|VOPNAME_LINK
block|,
block|{
operator|.
name|vop_link
operator|=
name|zfs_link
block|}
block|,
name|VOPNAME_RENAME
block|,
block|{
operator|.
name|vop_rename
operator|=
name|zfs_rename
block|}
block|,
name|VOPNAME_MKDIR
block|,
block|{
operator|.
name|error
operator|=
name|zfs_inval
block|}
block|,
name|VOPNAME_RMDIR
block|,
block|{
operator|.
name|vop_rmdir
operator|=
name|zfs_rmdir
block|}
block|,
name|VOPNAME_READDIR
block|,
block|{
operator|.
name|vop_readdir
operator|=
name|zfs_readdir
block|}
block|,
name|VOPNAME_SYMLINK
block|,
block|{
operator|.
name|error
operator|=
name|zfs_inval
block|}
block|,
name|VOPNAME_FSYNC
block|,
block|{
operator|.
name|vop_fsync
operator|=
name|zfs_fsync
block|}
block|,
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfs_inactive
block|}
block|,
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfs_fid
block|}
block|,
name|VOPNAME_SEEK
block|,
block|{
operator|.
name|vop_seek
operator|=
name|zfs_seek
block|}
block|,
name|VOPNAME_PATHCONF
block|,
block|{
operator|.
name|vop_pathconf
operator|=
name|zfs_pathconf
block|}
block|,
name|VOPNAME_GETSECATTR
block|,
block|{
operator|.
name|vop_getsecattr
operator|=
name|zfs_getsecattr
block|}
block|,
name|VOPNAME_SETSECATTR
block|,
block|{
operator|.
name|vop_setsecattr
operator|=
name|zfs_setsecattr
block|}
block|,
name|VOPNAME_VNEVENT
block|,
block|{
operator|.
name|vop_vnevent
operator|=
name|fs_vnevent_support
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Error vnode operations template  */
end_comment

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfs_evnodeops
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|fs_operation_def_t
name|zfs_evnodeops_template
index|[]
init|=
block|{
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfs_inactive
block|}
block|,
name|VOPNAME_PATHCONF
block|,
block|{
operator|.
name|vop_pathconf
operator|=
name|zfs_pathconf
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

end_unit

