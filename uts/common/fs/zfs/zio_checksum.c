begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, 2016 by Delphix. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright 2013 Saso Kiselkov. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_include
include|#
directive|include
file|<zfs_fletcher.h>
end_include

begin_comment
comment|/*  * Checksum vectors.  *  * In the SPA, everything is checksummed.  We support checksum vectors  * for three distinct reasons:  *  *   1. Different kinds of data need different levels of protection.  *	For SPA metadata, we always want a very strong checksum.  *	For user data, we let users make the trade-off between speed  *	and checksum strength.  *  *   2. Cryptographic hash and MAC algorithms are an area of active research.  *	It is likely that in future hash functions will be at least as strong  *	as current best-of-breed, and may be substantially faster as well.  *	We want the ability to take advantage of these new hashes as soon as  *	they become available.  *  *   3. If someone develops hardware that can compute a strong hash quickly,  *	we want the ability to take advantage of that hardware.  *  * Of course, we don't want a checksum upgrade to invalidate existing  * data, so we store the checksum *function* in eight bits of the bp.  * This gives us room for up to 256 different checksum functions.  *  * When writing a block, we always checksum it with the latest-and-greatest  * checksum function of the appropriate strength.  When reading a block,  * we compare the expected checksum against the actual checksum, which we  * compute via the checksum function specified by BP_GET_CHECKSUM(bp).  *  * SALTED CHECKSUMS  *  * To enable the use of less secure hash algorithms with dedup, we  * introduce the notion of salted checksums (MACs, really).  A salted  * checksum is fed both a random 256-bit value (the salt) and the data  * to be checksummed.  This salt is kept secret (stored on the pool, but  * never shown to the user).  Thus even if an attacker knew of collision  * weaknesses in the hash algorithm, they won't be able to mount a known  * plaintext attack on the DDT, since the actual hash value cannot be  * known ahead of time.  How the salt is used is algorithm-specific  * (some might simply prefix it to the data block, others might need to  * utilize a full-blown HMAC).  On disk the salt is stored in a ZAP  * object in the MOS (DMU_POOL_CHECKSUM_SALT).  *  * CONTEXT TEMPLATES  *  * Some hashing algorithms need to perform a substantial amount of  * initialization work (e.g. salted checksums above may need to pre-hash  * the salt) before being able to process data.  Performing this  * redundant work for each block would be wasteful, so we instead allow  * a checksum algorithm to do the work once (the first time it's used)  * and then keep this pre-initialized context as a template inside the  * spa_t (spa_cksum_tmpls).  If the zio_checksum_info_t contains  * non-NULL ci_tmpl_init and ci_tmpl_free callbacks, they are used to  * construct and destruct the pre-initialized checksum context.  The  * pre-initialized context is then reused during each checksum  * invocation and passed to the checksum function.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|abd_checksum_off
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|abd_fletcher_2_native
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|fletcher_2_incremental_native
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|abd_fletcher_2_byteswap
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|fletcher_2_incremental_byteswap
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|abd_fletcher_4_native
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|fletcher_4_incremental_native
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|void
name|abd_fletcher_4_byteswap
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|,
specifier|const
name|void
modifier|*
name|ctx_template
parameter_list|,
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|)
block|{
name|fletcher_init
argument_list|(
name|zcp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|abd
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|fletcher_4_incremental_byteswap
argument_list|,
name|zcp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|zio_checksum_info_t
name|zio_checksum_table
index|[
name|ZIO_CHECKSUM_FUNCTIONS
index|]
init|=
block|{
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"inherit"
block|}
block|,
block|{
block|{
name|NULL
block|,
name|NULL
block|}
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"on"
block|}
block|,
block|{
block|{
name|abd_checksum_off
block|,
name|abd_checksum_off
block|}
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"off"
block|}
block|,
block|{
block|{
name|abd_checksum_SHA256
block|,
name|abd_checksum_SHA256
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|ZCHECKSUM_FLAG_METADATA
operator||
name|ZCHECKSUM_FLAG_EMBEDDED
block|,
literal|"label"
block|}
block|,
block|{
block|{
name|abd_checksum_SHA256
block|,
name|abd_checksum_SHA256
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|ZCHECKSUM_FLAG_METADATA
operator||
name|ZCHECKSUM_FLAG_EMBEDDED
block|,
literal|"gang_header"
block|}
block|,
block|{
block|{
name|abd_fletcher_2_native
block|,
name|abd_fletcher_2_byteswap
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|ZCHECKSUM_FLAG_EMBEDDED
block|,
literal|"zilog"
block|}
block|,
block|{
block|{
name|abd_fletcher_2_native
block|,
name|abd_fletcher_2_byteswap
block|}
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"fletcher2"
block|}
block|,
block|{
block|{
name|abd_fletcher_4_native
block|,
name|abd_fletcher_4_byteswap
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|ZCHECKSUM_FLAG_METADATA
block|,
literal|"fletcher4"
block|}
block|,
block|{
block|{
name|abd_checksum_SHA256
block|,
name|abd_checksum_SHA256
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|ZCHECKSUM_FLAG_METADATA
operator||
name|ZCHECKSUM_FLAG_DEDUP
operator||
name|ZCHECKSUM_FLAG_NOPWRITE
block|,
literal|"sha256"
block|}
block|,
block|{
block|{
name|abd_fletcher_4_native
block|,
name|abd_fletcher_4_byteswap
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|ZCHECKSUM_FLAG_EMBEDDED
block|,
literal|"zilog2"
block|}
block|,
block|{
block|{
name|abd_checksum_off
block|,
name|abd_checksum_off
block|}
block|,
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
literal|"noparity"
block|}
block|,
block|{
block|{
name|abd_checksum_SHA512_native
block|,
name|abd_checksum_SHA512_byteswap
block|}
block|,
name|NULL
block|,
name|NULL
block|,
name|ZCHECKSUM_FLAG_METADATA
operator||
name|ZCHECKSUM_FLAG_DEDUP
operator||
name|ZCHECKSUM_FLAG_NOPWRITE
block|,
literal|"sha512"
block|}
block|,
block|{
block|{
name|abd_checksum_skein_native
block|,
name|abd_checksum_skein_byteswap
block|}
block|,
name|abd_checksum_skein_tmpl_init
block|,
name|abd_checksum_skein_tmpl_free
block|,
name|ZCHECKSUM_FLAG_METADATA
operator||
name|ZCHECKSUM_FLAG_DEDUP
operator||
name|ZCHECKSUM_FLAG_SALTED
operator||
name|ZCHECKSUM_FLAG_NOPWRITE
block|,
literal|"skein"
block|}
block|,
block|{
block|{
name|abd_checksum_edonr_native
block|,
name|abd_checksum_edonr_byteswap
block|}
block|,
name|abd_checksum_edonr_tmpl_init
block|,
name|abd_checksum_edonr_tmpl_free
block|,
name|ZCHECKSUM_FLAG_METADATA
operator||
name|ZCHECKSUM_FLAG_SALTED
operator||
name|ZCHECKSUM_FLAG_NOPWRITE
block|,
literal|"edonr"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The flag corresponding to the "verify" in dedup=[checksum,]verify  * must be cleared first, so callers should use ZIO_CHECKSUM_MASK.  */
end_comment

begin_function
name|spa_feature_t
name|zio_checksum_to_feature
parameter_list|(
name|enum
name|zio_checksum
name|cksum
parameter_list|)
block|{
name|VERIFY
argument_list|(
operator|(
name|cksum
operator|&
operator|~
name|ZIO_CHECKSUM_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cksum
condition|)
block|{
case|case
name|ZIO_CHECKSUM_SHA512
case|:
return|return
operator|(
name|SPA_FEATURE_SHA512
operator|)
return|;
case|case
name|ZIO_CHECKSUM_SKEIN
case|:
return|return
operator|(
name|SPA_FEATURE_SKEIN
operator|)
return|;
case|case
name|ZIO_CHECKSUM_EDONR
case|:
return|return
operator|(
name|SPA_FEATURE_EDONR
operator|)
return|;
block|}
return|return
operator|(
name|SPA_FEATURE_NONE
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|zio_checksum
name|zio_checksum_select
parameter_list|(
name|enum
name|zio_checksum
name|child
parameter_list|,
name|enum
name|zio_checksum
name|parent
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|child
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parent
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parent
operator|!=
name|ZIO_CHECKSUM_INHERIT
operator|&&
name|parent
operator|!=
name|ZIO_CHECKSUM_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|ZIO_CHECKSUM_INHERIT
condition|)
return|return
operator|(
name|parent
operator|)
return|;
if|if
condition|(
name|child
operator|==
name|ZIO_CHECKSUM_ON
condition|)
return|return
operator|(
name|ZIO_CHECKSUM_ON_VALUE
operator|)
return|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_function
name|enum
name|zio_checksum
name|zio_checksum_dedup_select
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|enum
name|zio_checksum
name|child
parameter_list|,
name|enum
name|zio_checksum
name|parent
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|(
name|child
operator|&
name|ZIO_CHECKSUM_MASK
operator|)
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|parent
operator|&
name|ZIO_CHECKSUM_MASK
operator|)
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parent
operator|!=
name|ZIO_CHECKSUM_INHERIT
operator|&&
name|parent
operator|!=
name|ZIO_CHECKSUM_ON
argument_list|)
expr_stmt|;
if|if
condition|(
name|child
operator|==
name|ZIO_CHECKSUM_INHERIT
condition|)
return|return
operator|(
name|parent
operator|)
return|;
if|if
condition|(
name|child
operator|==
name|ZIO_CHECKSUM_ON
condition|)
return|return
operator|(
name|spa_dedup_checksum
argument_list|(
name|spa
argument_list|)
operator|)
return|;
if|if
condition|(
name|child
operator|==
operator|(
name|ZIO_CHECKSUM_ON
operator||
name|ZIO_CHECKSUM_VERIFY
operator|)
condition|)
return|return
operator|(
name|spa_dedup_checksum
argument_list|(
name|spa
argument_list|)
operator||
name|ZIO_CHECKSUM_VERIFY
operator|)
return|;
name|ASSERT
argument_list|(
operator|(
name|zio_checksum_table
index|[
name|child
operator|&
name|ZIO_CHECKSUM_MASK
index|]
operator|.
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_DEDUP
operator|)
operator|||
operator|(
name|child
operator|&
name|ZIO_CHECKSUM_VERIFY
operator|)
operator|||
name|child
operator|==
name|ZIO_CHECKSUM_OFF
argument_list|)
expr_stmt|;
return|return
operator|(
name|child
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the external verifier for a gang block based on<vdev, offset, txg>,  * a tuple which is guaranteed to be unique for the life of the pool.  */
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_gang_verifier
parameter_list|(
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|)
block|{
name|dva_t
modifier|*
name|dva
init|=
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|uint64_t
name|txg
init|=
name|BP_PHYSICAL_BIRTH
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
argument_list|,
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set the external verifier for a label block based on its offset.  * The vdev is implicit, and the txg is unknowable at pool open time --  * hence the logic in vdev_uberblock_load() to find the most recent copy.  */
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_label_verifier
parameter_list|(
name|zio_cksum_t
modifier|*
name|zcp
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
name|ZIO_SET_CHECKSUM
argument_list|(
name|zcp
argument_list|,
name|offset
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Calls the template init function of a checksum which supports context  * templates and installs the template into the spa_t.  */
end_comment

begin_function
specifier|static
name|void
name|zio_checksum_template_init
parameter_list|(
name|enum
name|zio_checksum
name|checksum
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|zio_checksum_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
decl_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_tmpl_init
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|!=
name|NULL
condition|)
return|return;
name|VERIFY
argument_list|(
name|ci
operator|->
name|ci_tmpl_free
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_cksum_tmpls_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|==
name|NULL
condition|)
block|{
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|=
name|ci
operator|->
name|ci_tmpl_init
argument_list|(
operator|&
name|spa
operator|->
name|spa_cksum_salt
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_cksum_tmpls_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the checksum.  */
end_comment

begin_function
name|void
name|zio_checksum_compute
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|enum
name|zio_checksum
name|checksum
parameter_list|,
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|uint64_t
name|offset
init|=
name|zio
operator|->
name|io_offset
decl_stmt|;
name|zio_checksum_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
decl_stmt|;
name|zio_cksum_t
name|cksum
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|uint_t
operator|)
name|checksum
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|zio_checksum_template_init
argument_list|(
name|checksum
argument_list|,
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_EMBEDDED
condition|)
block|{
name|zio_eck_t
modifier|*
name|eck
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|abd_to_buf
argument_list|(
name|abd
argument_list|)
decl_stmt|;
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|zil_chain_t
modifier|*
name|zilc
init|=
name|data
decl_stmt|;
name|size
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|zilc
operator|->
name|zc_nused
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
name|eck
operator|=
operator|&
name|zilc
operator|->
name|zc_eck
expr_stmt|;
block|}
else|else
block|{
name|eck
operator|=
operator|(
name|zio_eck_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|size
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_GANG_HEADER
condition|)
name|zio_checksum_gang_verifier
argument_list|(
operator|&
name|eck
operator|->
name|zec_cksum
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
condition|)
name|zio_checksum_label_verifier
argument_list|(
operator|&
name|eck
operator|->
name|zec_cksum
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|bp
operator|->
name|blk_cksum
operator|=
name|eck
operator|->
name|zec_cksum
expr_stmt|;
name|eck
operator|->
name|zec_magic
operator|=
name|ZEC_MAGIC
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|(
name|abd
operator|,
name|size
operator|,
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|,
operator|&
name|cksum
operator|)
expr_stmt|;
name|eck
operator|->
name|zec_cksum
operator|=
name|cksum
expr_stmt|;
block|}
else|else
block|{
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|(
name|abd
operator|,
name|size
operator|,
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|,
operator|&
name|bp
operator|->
name|blk_cksum
operator|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|zio_checksum_error_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|enum
name|zio_checksum
name|checksum
parameter_list|,
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|zio_bad_cksum_t
modifier|*
name|info
parameter_list|)
block|{
name|zio_checksum_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
decl_stmt|;
name|zio_cksum_t
name|actual_cksum
decl_stmt|,
name|expected_cksum
decl_stmt|;
name|int
name|byteswap
decl_stmt|;
if|if
condition|(
name|checksum
operator|>=
name|ZIO_CHECKSUM_FUNCTIONS
operator|||
name|ci
operator|->
name|ci_func
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|zio_checksum_template_init
argument_list|(
name|checksum
argument_list|,
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|ci
operator|->
name|ci_flags
operator|&
name|ZCHECKSUM_FLAG_EMBEDDED
condition|)
block|{
name|zio_eck_t
modifier|*
name|eck
decl_stmt|;
name|zio_cksum_t
name|verifier
decl_stmt|;
name|uint64_t
name|data_size
init|=
name|size
decl_stmt|;
name|void
modifier|*
name|data
init|=
name|abd_borrow_buf_copy
argument_list|(
name|abd
argument_list|,
name|data_size
argument_list|)
decl_stmt|;
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_ZILOG2
condition|)
block|{
name|zil_chain_t
modifier|*
name|zilc
init|=
name|data
decl_stmt|;
name|uint64_t
name|nused
decl_stmt|;
name|eck
operator|=
operator|&
name|zilc
operator|->
name|zc_eck
expr_stmt|;
if|if
condition|(
name|eck
operator|->
name|zec_magic
operator|==
name|ZEC_MAGIC
condition|)
block|{
name|nused
operator|=
name|zilc
operator|->
name|zc_nused
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eck
operator|->
name|zec_magic
operator|==
name|BSWAP_64
argument_list|(
name|ZEC_MAGIC
argument_list|)
condition|)
block|{
name|nused
operator|=
name|BSWAP_64
argument_list|(
name|zilc
operator|->
name|zc_nused
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|abd_return_buf
argument_list|(
name|abd
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|nused
operator|>
name|data_size
condition|)
block|{
name|abd_return_buf
argument_list|(
name|abd
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
operator|)
return|;
block|}
name|size
operator|=
name|P2ROUNDUP_TYPED
argument_list|(
name|nused
argument_list|,
name|ZIL_MIN_BLKSZ
argument_list|,
name|uint64_t
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eck
operator|=
operator|(
name|zio_eck_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|data
operator|+
name|data_size
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_GANG_HEADER
condition|)
name|zio_checksum_gang_verifier
argument_list|(
operator|&
name|verifier
argument_list|,
name|bp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_LABEL
condition|)
name|zio_checksum_label_verifier
argument_list|(
operator|&
name|verifier
argument_list|,
name|offset
argument_list|)
expr_stmt|;
else|else
name|verifier
operator|=
name|bp
operator|->
name|blk_cksum
expr_stmt|;
name|byteswap
operator|=
operator|(
name|eck
operator|->
name|zec_magic
operator|==
name|BSWAP_64
argument_list|(
name|ZEC_MAGIC
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
operator|&
name|verifier
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
name|size_t
name|eck_offset
init|=
call|(
name|size_t
call|)
argument_list|(
operator|&
name|eck
operator|->
name|zec_cksum
argument_list|)
operator|-
operator|(
name|size_t
operator|)
name|data
decl_stmt|;
name|expected_cksum
operator|=
name|eck
operator|->
name|zec_cksum
expr_stmt|;
name|eck
operator|->
name|zec_cksum
operator|=
name|verifier
expr_stmt|;
name|abd_return_buf_copy
argument_list|(
name|abd
argument_list|,
name|data
argument_list|,
name|data_size
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
name|byteswap
index|]
operator|(
name|abd
operator|,
name|size
operator|,
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
name|abd_copy_from_buf_off
argument_list|(
name|abd
argument_list|,
operator|&
name|expected_cksum
argument_list|,
name|eck_offset
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|byteswap
condition|)
block|{
name|byteswap_uint64_array
argument_list|(
operator|&
name|expected_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_cksum_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|byteswap
operator|=
name|BP_SHOULD_BYTESWAP
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|expected_cksum
operator|=
name|bp
operator|->
name|blk_cksum
expr_stmt|;
name|ci
operator|->
name|ci_func
index|[
name|byteswap
index|]
operator|(
name|abd
operator|,
name|size
operator|,
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|,
operator|&
name|actual_cksum
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|info
operator|!=
name|NULL
condition|)
block|{
name|info
operator|->
name|zbc_expected
operator|=
name|expected_cksum
expr_stmt|;
name|info
operator|->
name|zbc_actual
operator|=
name|actual_cksum
expr_stmt|;
name|info
operator|->
name|zbc_checksum_name
operator|=
name|ci
operator|->
name|ci_name
expr_stmt|;
name|info
operator|->
name|zbc_byteswapped
operator|=
name|byteswap
expr_stmt|;
name|info
operator|->
name|zbc_injected
operator|=
literal|0
expr_stmt|;
name|info
operator|->
name|zbc_has_cksum
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|ZIO_CHECKSUM_EQUAL
argument_list|(
name|actual_cksum
argument_list|,
name|expected_cksum
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zio_checksum_error
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|zio_bad_cksum_t
modifier|*
name|info
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|uint_t
name|checksum
init|=
operator|(
name|bp
operator|==
name|NULL
condition|?
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
else|:
operator|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|?
name|ZIO_CHECKSUM_GANG_HEADER
else|:
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|)
operator|)
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|size
init|=
operator|(
name|bp
operator|==
name|NULL
condition|?
name|zio
operator|->
name|io_size
else|:
operator|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|?
name|SPA_GANGBLOCKSIZE
else|:
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
operator|)
operator|)
decl_stmt|;
name|uint64_t
name|offset
init|=
name|zio
operator|->
name|io_offset
decl_stmt|;
name|abd_t
modifier|*
name|data
init|=
name|zio
operator|->
name|io_abd
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|error
operator|=
name|zio_checksum_error_impl
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
name|checksum
argument_list|,
name|data
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|info
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
operator|&&
name|error
operator|==
literal|0
operator|&&
name|zio
operator|->
name|io_error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zio_handle_fault_injection
argument_list|(
name|zio
argument_list|,
name|ECKSUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|info
operator|->
name|zbc_injected
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called by a spa_t that's about to be deallocated. This steps through  * all of the checksum context templates and deallocates any that were  * initialized using the algorithm-specific template init function.  */
end_comment

begin_function
name|void
name|zio_checksum_templates_free
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
for|for
control|(
name|enum
name|zio_checksum
name|checksum
init|=
literal|0
init|;
name|checksum
operator|<
name|ZIO_CHECKSUM_FUNCTIONS
condition|;
name|checksum
operator|++
control|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|!=
name|NULL
condition|)
block|{
name|zio_checksum_info_t
modifier|*
name|ci
init|=
operator|&
name|zio_checksum_table
index|[
name|checksum
index|]
decl_stmt|;
name|VERIFY
argument_list|(
name|ci
operator|->
name|ci_tmpl_free
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ci
operator|->
name|ci_tmpl_free
argument_list|(
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_cksum_tmpls
index|[
name|checksum
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

