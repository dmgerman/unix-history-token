begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lgc.c,v 2.140.1.3 2014/09/01 16:55:08 roberto Exp $ ** Garbage Collector ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lgc_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lfunc.h"
end_include

begin_include
include|#
directive|include
file|"lgc.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_include
include|#
directive|include
file|"ltm.h"
end_include

begin_comment
comment|/* ** cost of sweeping one element (the size of a small object divided ** by some adjust for the sweep speed) */
end_comment

begin_define
define|#
directive|define
name|GCSWEEPCOST
value|((sizeof(TString) + 4) / 4)
end_define

begin_comment
comment|/* maximum number of elements to sweep in each single step */
end_comment

begin_define
define|#
directive|define
name|GCSWEEPMAX
value|(cast_int((GCSTEPSIZE / GCSWEEPCOST) / 4))
end_define

begin_comment
comment|/* maximum number of finalizers to call in each GC step */
end_comment

begin_define
define|#
directive|define
name|GCFINALIZENUM
value|4
end_define

begin_comment
comment|/* ** macro to adjust 'stepmul': 'stepmul' is actually used like ** 'stepmul / STEPMULADJ' (value chosen by tests) */
end_comment

begin_define
define|#
directive|define
name|STEPMULADJ
value|200
end_define

begin_comment
comment|/* ** macro to adjust 'pause': 'pause' is actually used like ** 'pause / PAUSEADJ' (value chosen by tests) */
end_comment

begin_define
define|#
directive|define
name|PAUSEADJ
value|100
end_define

begin_comment
comment|/* ** 'makewhite' erases all color bits plus the old bit and then ** sets only the current white bit */
end_comment

begin_define
define|#
directive|define
name|maskcolors
value|(~(bit2mask(BLACKBIT, OLDBIT) | WHITEBITS))
end_define

begin_define
define|#
directive|define
name|makewhite
parameter_list|(
name|g
parameter_list|,
name|x
parameter_list|)
define|\
value|(gch(x)->marked = cast_byte((gch(x)->marked& maskcolors) | luaC_white(g)))
end_define

begin_define
define|#
directive|define
name|white2gray
parameter_list|(
name|x
parameter_list|)
value|resetbits(gch(x)->marked, WHITEBITS)
end_define

begin_define
define|#
directive|define
name|black2gray
parameter_list|(
name|x
parameter_list|)
value|resetbit(gch(x)->marked, BLACKBIT)
end_define

begin_define
define|#
directive|define
name|isfinalized
parameter_list|(
name|x
parameter_list|)
value|testbit(gch(x)->marked, FINALIZEDBIT)
end_define

begin_define
define|#
directive|define
name|checkdeadkey
parameter_list|(
name|n
parameter_list|)
value|lua_assert(!ttisdeadkey(gkey(n)) || ttisnil(gval(n)))
end_define

begin_define
define|#
directive|define
name|checkconsistency
parameter_list|(
name|obj
parameter_list|)
define|\
value|lua_longassert(!iscollectable(obj) || righttt(obj))
end_define

begin_define
define|#
directive|define
name|markvalue
parameter_list|(
name|g
parameter_list|,
name|o
parameter_list|)
value|{ checkconsistency(o); \   if (valiswhite(o)) reallymarkobject(g,gcvalue(o)); }
end_define

begin_define
define|#
directive|define
name|markobject
parameter_list|(
name|g
parameter_list|,
name|t
parameter_list|)
value|{ if ((t)&& iswhite(obj2gco(t))) \ 		reallymarkobject(g, obj2gco(t)); }
end_define

begin_function_decl
specifier|static
name|void
name|reallymarkobject
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|GCObject
modifier|*
name|o
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** {====================================================== ** Generic functions ** ======================================================= */
end_comment

begin_comment
comment|/* ** one after last element in a hash array */
end_comment

begin_define
define|#
directive|define
name|gnodelast
parameter_list|(
name|h
parameter_list|)
value|gnode(h, cast(size_t, sizenode(h)))
end_define

begin_comment
comment|/* ** link table 'h' into list pointed by 'p' */
end_comment

begin_define
define|#
directive|define
name|linktable
parameter_list|(
name|h
parameter_list|,
name|p
parameter_list|)
value|((h)->gclist = *(p), *(p) = obj2gco(h))
end_define

begin_comment
comment|/* ** if key is not marked, mark its entry as dead (therefore removing it ** from the table) */
end_comment

begin_function
specifier|static
name|void
name|removeentry
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|valiswhite
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
name|setdeadvalue
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* unused and unmarked key; remove it */
block|}
end_function

begin_comment
comment|/* ** tells whether a key or value can be cleared from a weak ** table. Non-collectable objects are never removed from weak ** tables. Strings behave as `values', so are never removed too. for ** other objects: if really collected, cannot keep them; for objects ** being finalized, keep them in keys, but not in values */
end_comment

begin_function
specifier|static
name|int
name|iscleared
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
specifier|const
name|TValue
modifier|*
name|o
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iscollectable
argument_list|(
name|o
argument_list|)
condition|)
return|return
literal|0
return|;
elseif|else
if|if
condition|(
name|ttisstring
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|markobject
argument_list|(
name|g
argument_list|,
name|rawtsvalue
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
comment|/* strings are `values', so are never weak */
return|return
literal|0
return|;
block|}
else|else
return|return
name|iswhite
argument_list|(
name|gcvalue
argument_list|(
name|o
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** barrier that moves collector forward, that is, mark the white object ** being pointed by a black object. */
end_comment

begin_function
name|void
name|luaC_barrier_
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|GCObject
modifier|*
name|o
parameter_list|,
name|GCObject
modifier|*
name|v
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|isblack
argument_list|(
name|o
argument_list|)
operator|&&
name|iswhite
argument_list|(
name|v
argument_list|)
operator|&&
operator|!
name|isdead
argument_list|(
name|g
argument_list|,
name|v
argument_list|)
operator|&&
operator|!
name|isdead
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|g
operator|->
name|gcstate
operator|!=
name|GCSpause
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|tt
operator|!=
name|LUA_TTABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|keepinvariantout
argument_list|(
name|g
argument_list|)
condition|)
comment|/* must keep invariant? */
name|reallymarkobject
argument_list|(
name|g
argument_list|,
name|v
argument_list|)
expr_stmt|;
comment|/* restore invariant */
else|else
block|{
comment|/* sweep phase */
name|lua_assert
argument_list|(
name|issweepphase
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|makewhite
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|/* mark main obj. as white to avoid other barriers */
block|}
block|}
end_function

begin_comment
comment|/* ** barrier that moves collector backward, that is, mark the black object ** pointing to a white object as gray again. (Current implementation ** only works for tables; access to 'gclist' is not uniform across ** different types.) */
end_comment

begin_function
name|void
name|luaC_barrierback_
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|GCObject
modifier|*
name|o
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|isblack
argument_list|(
name|o
argument_list|)
operator|&&
operator|!
name|isdead
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
operator|&&
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|tt
operator|==
name|LUA_TTABLE
argument_list|)
expr_stmt|;
name|black2gray
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* make object gray (again) */
name|gco2t
argument_list|(
name|o
argument_list|)
operator|->
name|gclist
operator|=
name|g
operator|->
name|grayagain
expr_stmt|;
name|g
operator|->
name|grayagain
operator|=
name|o
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** barrier for prototypes. When creating first closure (cache is ** NULL), use a forward barrier; this may be the only closure of the ** prototype (if it is a "regular" function, with a single instance) ** and the prototype may be big, so it is better to avoid traversing ** it again. Otherwise, use a backward barrier, to avoid marking all ** possible instances. */
end_comment

begin_function
name|LUAI_FUNC
name|void
name|luaC_barrierproto_
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Proto
modifier|*
name|p
parameter_list|,
name|Closure
modifier|*
name|c
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|isblack
argument_list|(
name|obj2gco
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|cache
operator|==
name|NULL
condition|)
block|{
comment|/* first time? */
name|luaC_objbarrier
argument_list|(
name|L
argument_list|,
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* use a backward barrier */
name|black2gray
argument_list|(
name|obj2gco
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
comment|/* make prototype gray (again) */
name|p
operator|->
name|gclist
operator|=
name|g
operator|->
name|grayagain
expr_stmt|;
name|g
operator|->
name|grayagain
operator|=
name|obj2gco
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** check color (and invariants) for an upvalue that was closed, ** i.e., moved into the 'allgc' list */
end_comment

begin_function
name|void
name|luaC_checkupvalcolor
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|UpVal
modifier|*
name|uv
parameter_list|)
block|{
name|GCObject
modifier|*
name|o
init|=
name|obj2gco
argument_list|(
name|uv
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
operator|!
name|isblack
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
comment|/* open upvalues are never black */
if|if
condition|(
name|isgray
argument_list|(
name|o
argument_list|)
condition|)
block|{
if|if
condition|(
name|keepinvariant
argument_list|(
name|g
argument_list|)
condition|)
block|{
name|resetoldbit
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* see MOVE OLD rule */
name|gray2black
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* it is being visited now */
name|markvalue
argument_list|(
name|g
argument_list|,
name|uv
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|lua_assert
argument_list|(
name|issweepphase
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|makewhite
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** create a new collectable object (with given type and size) and link ** it to '*list'. 'offset' tells how many bytes to allocate before the ** object itself (used only by states). */
end_comment

begin_function
name|GCObject
modifier|*
name|luaC_newobj
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|tt
parameter_list|,
name|size_t
name|sz
parameter_list|,
name|GCObject
modifier|*
modifier|*
name|list
parameter_list|,
name|int
name|offset
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|char
modifier|*
name|raw
init|=
name|cast
argument_list|(
name|char
operator|*
argument_list|,
name|luaM_newobject
argument_list|(
name|L
argument_list|,
name|novariant
argument_list|(
name|tt
argument_list|)
argument_list|,
name|sz
argument_list|)
argument_list|)
decl_stmt|;
name|GCObject
modifier|*
name|o
init|=
name|obj2gco
argument_list|(
name|raw
operator|+
name|offset
argument_list|)
decl_stmt|;
if|if
condition|(
name|list
operator|==
name|NULL
condition|)
name|list
operator|=
operator|&
name|g
operator|->
name|allgc
expr_stmt|;
comment|/* standard list for collectable objects */
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|marked
operator|=
name|luaC_white
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|tt
operator|=
name|tt
expr_stmt|;
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|next
operator|=
operator|*
name|list
expr_stmt|;
operator|*
name|list
operator|=
name|o
expr_stmt|;
return|return
name|o
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Mark functions ** ======================================================= */
end_comment

begin_comment
comment|/* ** mark an object. Userdata, strings, and closed upvalues are visited ** and turned black here. Other objects are marked gray and added ** to appropriate list to be visited (and turned black) later. (Open ** upvalues are already linked in 'headuv' list.) */
end_comment

begin_function
specifier|static
name|void
name|reallymarkobject
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|GCObject
modifier|*
name|o
parameter_list|)
block|{
name|lu_mem
name|size
decl_stmt|;
name|white2gray
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|tt
condition|)
block|{
case|case
name|LUA_TSHRSTR
case|:
case|case
name|LUA_TLNGSTR
case|:
block|{
name|size
operator|=
name|sizestring
argument_list|(
name|gco2ts
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
comment|/* nothing else to mark; make it black */
block|}
case|case
name|LUA_TUSERDATA
case|:
block|{
name|Table
modifier|*
name|mt
init|=
name|gco2u
argument_list|(
name|o
argument_list|)
operator|->
name|metatable
decl_stmt|;
name|markobject
argument_list|(
name|g
argument_list|,
name|mt
argument_list|)
expr_stmt|;
name|markobject
argument_list|(
name|g
argument_list|,
name|gco2u
argument_list|(
name|o
argument_list|)
operator|->
name|env
argument_list|)
expr_stmt|;
name|size
operator|=
name|sizeudata
argument_list|(
name|gco2u
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TUPVAL
case|:
block|{
name|UpVal
modifier|*
name|uv
init|=
name|gco2uv
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|markvalue
argument_list|(
name|g
argument_list|,
name|uv
operator|->
name|v
argument_list|)
expr_stmt|;
if|if
condition|(
name|uv
operator|->
name|v
operator|!=
operator|&
name|uv
operator|->
name|u
operator|.
name|value
condition|)
comment|/* open? */
return|return;
comment|/* open upvalues remain gray */
name|size
operator|=
sizeof|sizeof
argument_list|(
name|UpVal
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TLCL
case|:
block|{
name|gco2lcl
argument_list|(
name|o
argument_list|)
operator|->
name|gclist
operator|=
name|g
operator|->
name|gray
expr_stmt|;
name|g
operator|->
name|gray
operator|=
name|o
expr_stmt|;
return|return;
block|}
case|case
name|LUA_TCCL
case|:
block|{
name|gco2ccl
argument_list|(
name|o
argument_list|)
operator|->
name|gclist
operator|=
name|g
operator|->
name|gray
expr_stmt|;
name|g
operator|->
name|gray
operator|=
name|o
expr_stmt|;
return|return;
block|}
case|case
name|LUA_TTABLE
case|:
block|{
name|linktable
argument_list|(
name|gco2t
argument_list|(
name|o
argument_list|)
argument_list|,
operator|&
name|g
operator|->
name|gray
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
name|LUA_TTHREAD
case|:
block|{
name|gco2th
argument_list|(
name|o
argument_list|)
operator|->
name|gclist
operator|=
name|g
operator|->
name|gray
expr_stmt|;
name|g
operator|->
name|gray
operator|=
name|o
expr_stmt|;
return|return;
block|}
case|case
name|LUA_TPROTO
case|:
block|{
name|gco2p
argument_list|(
name|o
argument_list|)
operator|->
name|gclist
operator|=
name|g
operator|->
name|gray
expr_stmt|;
name|g
operator|->
name|gray
operator|=
name|o
expr_stmt|;
return|return;
block|}
default|default:
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|gray2black
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|g
operator|->
name|GCmemtrav
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** mark metamethods for basic types */
end_comment

begin_function
specifier|static
name|void
name|markmt
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LUA_NUMTAGS
condition|;
name|i
operator|++
control|)
name|markobject
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|mt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** mark all objects in list of being-finalized */
end_comment

begin_function
specifier|static
name|void
name|markbeingfnz
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|GCObject
modifier|*
name|o
decl_stmt|;
for|for
control|(
name|o
operator|=
name|g
operator|->
name|tobefnz
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|next
control|)
block|{
name|makewhite
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
name|reallymarkobject
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** mark all values stored in marked open upvalues. (See comment in ** 'lstate.h'.) */
end_comment

begin_function
specifier|static
name|void
name|remarkupvals
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|UpVal
modifier|*
name|uv
decl_stmt|;
for|for
control|(
name|uv
operator|=
name|g
operator|->
name|uvhead
operator|.
name|u
operator|.
name|l
operator|.
name|next
init|;
name|uv
operator|!=
operator|&
name|g
operator|->
name|uvhead
condition|;
name|uv
operator|=
name|uv
operator|->
name|u
operator|.
name|l
operator|.
name|next
control|)
block|{
if|if
condition|(
name|isgray
argument_list|(
name|obj2gco
argument_list|(
name|uv
argument_list|)
argument_list|)
condition|)
name|markvalue
argument_list|(
name|g
argument_list|,
name|uv
operator|->
name|v
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** mark root set and reset all gray lists, to start a new ** incremental (or full) collection */
end_comment

begin_function
specifier|static
name|void
name|restartcollection
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|g
operator|->
name|gray
operator|=
name|g
operator|->
name|grayagain
operator|=
name|NULL
expr_stmt|;
name|g
operator|->
name|weak
operator|=
name|g
operator|->
name|allweak
operator|=
name|g
operator|->
name|ephemeron
operator|=
name|NULL
expr_stmt|;
name|markobject
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|mainthread
argument_list|)
expr_stmt|;
name|markvalue
argument_list|(
name|g
argument_list|,
operator|&
name|g
operator|->
name|l_registry
argument_list|)
expr_stmt|;
name|markmt
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|markbeingfnz
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* mark any finalizing object left from previous cycle */
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Traverse functions ** ======================================================= */
end_comment

begin_function
specifier|static
name|void
name|traverseweakvalue
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|Table
modifier|*
name|h
parameter_list|)
block|{
name|Node
modifier|*
name|n
decl_stmt|,
modifier|*
name|limit
init|=
name|gnodelast
argument_list|(
name|h
argument_list|)
decl_stmt|;
comment|/* if there is array part, assume it may have white values (do not      traverse it just to check) */
name|int
name|hasclears
init|=
operator|(
name|h
operator|->
name|sizearray
operator|>
literal|0
operator|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|gnode
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
init|;
name|n
operator|<
name|limit
condition|;
name|n
operator|++
control|)
block|{
name|checkdeadkey
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
comment|/* entry is empty? */
name|removeentry
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* remove it */
else|else
block|{
name|lua_assert
argument_list|(
operator|!
name|ttisnil
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|markvalue
argument_list|(
name|g
argument_list|,
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark key */
if|if
condition|(
operator|!
name|hasclears
operator|&&
name|iscleared
argument_list|(
name|g
argument_list|,
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
comment|/* is there a white value? */
name|hasclears
operator|=
literal|1
expr_stmt|;
comment|/* table will have to be cleared */
block|}
block|}
if|if
condition|(
name|hasclears
condition|)
name|linktable
argument_list|(
name|h
argument_list|,
operator|&
name|g
operator|->
name|weak
argument_list|)
expr_stmt|;
comment|/* has to be cleared later */
else|else
comment|/* no white values */
name|linktable
argument_list|(
name|h
argument_list|,
operator|&
name|g
operator|->
name|grayagain
argument_list|)
expr_stmt|;
comment|/* no need to clean */
block|}
end_function

begin_function
specifier|static
name|int
name|traverseephemeron
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|Table
modifier|*
name|h
parameter_list|)
block|{
name|int
name|marked
init|=
literal|0
decl_stmt|;
comment|/* true if an object is marked in this traversal */
name|int
name|hasclears
init|=
literal|0
decl_stmt|;
comment|/* true if table has white keys */
name|int
name|prop
init|=
literal|0
decl_stmt|;
comment|/* true if table has entry "white-key -> white-value" */
name|Node
modifier|*
name|n
decl_stmt|,
modifier|*
name|limit
init|=
name|gnodelast
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* traverse array part (numeric keys are 'strong') */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|sizearray
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|valiswhite
argument_list|(
operator|&
name|h
operator|->
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|marked
operator|=
literal|1
expr_stmt|;
name|reallymarkobject
argument_list|(
name|g
argument_list|,
name|gcvalue
argument_list|(
operator|&
name|h
operator|->
name|array
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* traverse hash part */
for|for
control|(
name|n
operator|=
name|gnode
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
init|;
name|n
operator|<
name|limit
condition|;
name|n
operator|++
control|)
block|{
name|checkdeadkey
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
comment|/* entry is empty? */
name|removeentry
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* remove it */
elseif|else
if|if
condition|(
name|iscleared
argument_list|(
name|g
argument_list|,
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
comment|/* key is not marked (yet)? */
name|hasclears
operator|=
literal|1
expr_stmt|;
comment|/* table must be cleared */
if|if
condition|(
name|valiswhite
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
comment|/* value not marked yet? */
name|prop
operator|=
literal|1
expr_stmt|;
comment|/* must propagate again */
block|}
elseif|else
if|if
condition|(
name|valiswhite
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
comment|/* value not marked yet? */
name|marked
operator|=
literal|1
expr_stmt|;
name|reallymarkobject
argument_list|(
name|g
argument_list|,
name|gcvalue
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark it now */
block|}
block|}
if|if
condition|(
name|g
operator|->
name|gcstate
operator|!=
name|GCSatomic
operator|||
name|prop
condition|)
name|linktable
argument_list|(
name|h
argument_list|,
operator|&
name|g
operator|->
name|ephemeron
argument_list|)
expr_stmt|;
comment|/* have to propagate again */
elseif|else
if|if
condition|(
name|hasclears
condition|)
comment|/* does table have white keys? */
name|linktable
argument_list|(
name|h
argument_list|,
operator|&
name|g
operator|->
name|allweak
argument_list|)
expr_stmt|;
comment|/* may have to clean white keys */
else|else
comment|/* no white keys */
name|linktable
argument_list|(
name|h
argument_list|,
operator|&
name|g
operator|->
name|grayagain
argument_list|)
expr_stmt|;
comment|/* no need to clean */
return|return
name|marked
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|traversestrongtable
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|Table
modifier|*
name|h
parameter_list|)
block|{
name|Node
modifier|*
name|n
decl_stmt|,
modifier|*
name|limit
init|=
name|gnodelast
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|sizearray
condition|;
name|i
operator|++
control|)
comment|/* traverse array part */
name|markvalue
argument_list|(
name|g
argument_list|,
operator|&
name|h
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|n
operator|=
name|gnode
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
init|;
name|n
operator|<
name|limit
condition|;
name|n
operator|++
control|)
block|{
comment|/* traverse hash part */
name|checkdeadkey
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
comment|/* entry is empty? */
name|removeentry
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* remove it */
else|else
block|{
name|lua_assert
argument_list|(
operator|!
name|ttisnil
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|markvalue
argument_list|(
name|g
argument_list|,
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark key */
name|markvalue
argument_list|(
name|g
argument_list|,
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* mark value */
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|lu_mem
name|traversetable
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|Table
modifier|*
name|h
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|weakkey
decl_stmt|,
modifier|*
name|weakvalue
decl_stmt|;
specifier|const
name|TValue
modifier|*
name|mode
init|=
name|gfasttm
argument_list|(
name|g
argument_list|,
name|h
operator|->
name|metatable
argument_list|,
name|TM_MODE
argument_list|)
decl_stmt|;
name|markobject
argument_list|(
name|g
argument_list|,
name|h
operator|->
name|metatable
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&&
name|ttisstring
argument_list|(
name|mode
argument_list|)
operator|&&
comment|/* is there a weak mode? */
operator|(
operator|(
name|weakkey
operator|=
name|strchr
argument_list|(
name|svalue
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|'k'
argument_list|)
operator|)
operator|,
operator|(
name|weakvalue
operator|=
name|strchr
argument_list|(
name|svalue
argument_list|(
name|mode
argument_list|)
argument_list|,
literal|'v'
argument_list|)
operator|)
operator|,
operator|(
name|weakkey
operator|||
name|weakvalue
operator|)
operator|)
condition|)
block|{
comment|/* is really weak? */
name|black2gray
argument_list|(
name|obj2gco
argument_list|(
name|h
argument_list|)
argument_list|)
expr_stmt|;
comment|/* keep table gray */
if|if
condition|(
operator|!
name|weakkey
condition|)
comment|/* strong keys? */
name|traverseweakvalue
argument_list|(
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|weakvalue
condition|)
comment|/* strong values? */
name|traverseephemeron
argument_list|(
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
else|else
comment|/* all weak */
name|linktable
argument_list|(
name|h
argument_list|,
operator|&
name|g
operator|->
name|allweak
argument_list|)
expr_stmt|;
comment|/* nothing to traverse now */
block|}
else|else
comment|/* not weak */
name|traversestrongtable
argument_list|(
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|Table
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TValue
argument_list|)
operator|*
name|h
operator|->
name|sizearray
operator|+
sizeof|sizeof
argument_list|(
name|Node
argument_list|)
operator|*
name|cast
argument_list|(
name|size_t
argument_list|,
name|sizenode
argument_list|(
name|h
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|traverseproto
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|Proto
modifier|*
name|f
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|f
operator|->
name|cache
operator|&&
name|iswhite
argument_list|(
name|obj2gco
argument_list|(
name|f
operator|->
name|cache
argument_list|)
argument_list|)
condition|)
name|f
operator|->
name|cache
operator|=
name|NULL
expr_stmt|;
comment|/* allow cache to be collected */
name|markobject
argument_list|(
name|g
argument_list|,
name|f
operator|->
name|source
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|sizek
condition|;
name|i
operator|++
control|)
comment|/* mark literals */
name|markvalue
argument_list|(
name|g
argument_list|,
operator|&
name|f
operator|->
name|k
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|sizeupvalues
condition|;
name|i
operator|++
control|)
comment|/* mark upvalue names */
name|markobject
argument_list|(
name|g
argument_list|,
name|f
operator|->
name|upvalues
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|sizep
condition|;
name|i
operator|++
control|)
comment|/* mark nested protos */
name|markobject
argument_list|(
name|g
argument_list|,
name|f
operator|->
name|p
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|sizelocvars
condition|;
name|i
operator|++
control|)
comment|/* mark local-variable names */
name|markobject
argument_list|(
name|g
argument_list|,
name|f
operator|->
name|locvars
index|[
name|i
index|]
operator|.
name|varname
argument_list|)
expr_stmt|;
return|return
sizeof|sizeof
argument_list|(
name|Proto
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|Instruction
argument_list|)
operator|*
name|f
operator|->
name|sizecode
operator|+
sizeof|sizeof
argument_list|(
name|Proto
operator|*
argument_list|)
operator|*
name|f
operator|->
name|sizep
operator|+
sizeof|sizeof
argument_list|(
name|TValue
argument_list|)
operator|*
name|f
operator|->
name|sizek
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
operator|*
name|f
operator|->
name|sizelineinfo
operator|+
sizeof|sizeof
argument_list|(
name|LocVar
argument_list|)
operator|*
name|f
operator|->
name|sizelocvars
operator|+
sizeof|sizeof
argument_list|(
name|Upvaldesc
argument_list|)
operator|*
name|f
operator|->
name|sizeupvalues
return|;
block|}
end_function

begin_function
specifier|static
name|lu_mem
name|traverseCclosure
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|CClosure
modifier|*
name|cl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl
operator|->
name|nupvalues
condition|;
name|i
operator|++
control|)
comment|/* mark its upvalues */
name|markvalue
argument_list|(
name|g
argument_list|,
operator|&
name|cl
operator|->
name|upvalue
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|sizeCclosure
argument_list|(
name|cl
operator|->
name|nupvalues
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|lu_mem
name|traverseLclosure
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|LClosure
modifier|*
name|cl
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|markobject
argument_list|(
name|g
argument_list|,
name|cl
operator|->
name|p
argument_list|)
expr_stmt|;
comment|/* mark its prototype */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cl
operator|->
name|nupvalues
condition|;
name|i
operator|++
control|)
comment|/* mark its upvalues */
name|markobject
argument_list|(
name|g
argument_list|,
name|cl
operator|->
name|upvals
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|sizeLclosure
argument_list|(
name|cl
operator|->
name|nupvalues
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|lu_mem
name|traversestack
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|lua_State
modifier|*
name|th
parameter_list|)
block|{
name|int
name|n
init|=
literal|0
decl_stmt|;
name|StkId
name|o
init|=
name|th
operator|->
name|stack
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NULL
condition|)
return|return
literal|1
return|;
comment|/* stack not completely built yet */
for|for
control|(
init|;
name|o
operator|<
name|th
operator|->
name|top
condition|;
name|o
operator|++
control|)
comment|/* mark live elements in the stack */
name|markvalue
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|gcstate
operator|==
name|GCSatomic
condition|)
block|{
comment|/* final traversal? */
name|StkId
name|lim
init|=
name|th
operator|->
name|stack
operator|+
name|th
operator|->
name|stacksize
decl_stmt|;
comment|/* real end of stack */
for|for
control|(
init|;
name|o
operator|<
name|lim
condition|;
name|o
operator|++
control|)
comment|/* clear not-marked stack slice */
name|setnilvalue
argument_list|(
name|o
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* count call infos to compute size */
name|CallInfo
modifier|*
name|ci
decl_stmt|;
for|for
control|(
name|ci
operator|=
operator|&
name|th
operator|->
name|base_ci
init|;
name|ci
operator|!=
name|th
operator|->
name|ci
condition|;
name|ci
operator|=
name|ci
operator|->
name|next
control|)
name|n
operator|++
expr_stmt|;
block|}
return|return
sizeof|sizeof
argument_list|(
name|lua_State
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|TValue
argument_list|)
operator|*
name|th
operator|->
name|stacksize
operator|+
sizeof|sizeof
argument_list|(
name|CallInfo
argument_list|)
operator|*
name|n
return|;
block|}
end_function

begin_comment
comment|/* ** traverse one gray object, turning it to black (except for threads, ** which are always gray). */
end_comment

begin_function
specifier|static
name|void
name|propagatemark
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|lu_mem
name|size
decl_stmt|;
name|GCObject
modifier|*
name|o
init|=
name|g
operator|->
name|gray
decl_stmt|;
name|lua_assert
argument_list|(
name|isgray
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|gray2black
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|tt
condition|)
block|{
case|case
name|LUA_TTABLE
case|:
block|{
name|Table
modifier|*
name|h
init|=
name|gco2t
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|g
operator|->
name|gray
operator|=
name|h
operator|->
name|gclist
expr_stmt|;
comment|/* remove from 'gray' list */
name|size
operator|=
name|traversetable
argument_list|(
name|g
argument_list|,
name|h
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TLCL
case|:
block|{
name|LClosure
modifier|*
name|cl
init|=
name|gco2lcl
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|g
operator|->
name|gray
operator|=
name|cl
operator|->
name|gclist
expr_stmt|;
comment|/* remove from 'gray' list */
name|size
operator|=
name|traverseLclosure
argument_list|(
name|g
argument_list|,
name|cl
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TCCL
case|:
block|{
name|CClosure
modifier|*
name|cl
init|=
name|gco2ccl
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|g
operator|->
name|gray
operator|=
name|cl
operator|->
name|gclist
expr_stmt|;
comment|/* remove from 'gray' list */
name|size
operator|=
name|traverseCclosure
argument_list|(
name|g
argument_list|,
name|cl
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TTHREAD
case|:
block|{
name|lua_State
modifier|*
name|th
init|=
name|gco2th
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|g
operator|->
name|gray
operator|=
name|th
operator|->
name|gclist
expr_stmt|;
comment|/* remove from 'gray' list */
name|th
operator|->
name|gclist
operator|=
name|g
operator|->
name|grayagain
expr_stmt|;
name|g
operator|->
name|grayagain
operator|=
name|o
expr_stmt|;
comment|/* insert into 'grayagain' list */
name|black2gray
argument_list|(
name|o
argument_list|)
expr_stmt|;
name|size
operator|=
name|traversestack
argument_list|(
name|g
argument_list|,
name|th
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TPROTO
case|:
block|{
name|Proto
modifier|*
name|p
init|=
name|gco2p
argument_list|(
name|o
argument_list|)
decl_stmt|;
name|g
operator|->
name|gray
operator|=
name|p
operator|->
name|gclist
expr_stmt|;
comment|/* remove from 'gray' list */
name|size
operator|=
name|traverseproto
argument_list|(
name|g
argument_list|,
name|p
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|g
operator|->
name|GCmemtrav
operator|+=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|propagateall
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
while|while
condition|(
name|g
operator|->
name|gray
condition|)
name|propagatemark
argument_list|(
name|g
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|propagatelist
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|GCObject
modifier|*
name|l
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|g
operator|->
name|gray
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* no grays left */
name|g
operator|->
name|gray
operator|=
name|l
expr_stmt|;
name|propagateall
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* traverse all elements from 'l' */
block|}
end_function

begin_comment
comment|/* ** retraverse all gray lists. Because tables may be reinserted in other ** lists when traversed, traverse the original lists to avoid traversing ** twice the same table (which is not wrong, but inefficient) */
end_comment

begin_function
specifier|static
name|void
name|retraversegrays
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|GCObject
modifier|*
name|weak
init|=
name|g
operator|->
name|weak
decl_stmt|;
comment|/* save original lists */
name|GCObject
modifier|*
name|grayagain
init|=
name|g
operator|->
name|grayagain
decl_stmt|;
name|GCObject
modifier|*
name|ephemeron
init|=
name|g
operator|->
name|ephemeron
decl_stmt|;
name|g
operator|->
name|weak
operator|=
name|g
operator|->
name|grayagain
operator|=
name|g
operator|->
name|ephemeron
operator|=
name|NULL
expr_stmt|;
name|propagateall
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* traverse main gray list */
name|propagatelist
argument_list|(
name|g
argument_list|,
name|grayagain
argument_list|)
expr_stmt|;
name|propagatelist
argument_list|(
name|g
argument_list|,
name|weak
argument_list|)
expr_stmt|;
name|propagatelist
argument_list|(
name|g
argument_list|,
name|ephemeron
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|convergeephemerons
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|int
name|changed
decl_stmt|;
do|do
block|{
name|GCObject
modifier|*
name|w
decl_stmt|;
name|GCObject
modifier|*
name|next
init|=
name|g
operator|->
name|ephemeron
decl_stmt|;
comment|/* get ephemeron list */
name|g
operator|->
name|ephemeron
operator|=
name|NULL
expr_stmt|;
comment|/* tables will return to this list when traversed */
name|changed
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|next
operator|)
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|gco2t
argument_list|(
name|w
argument_list|)
operator|->
name|gclist
expr_stmt|;
if|if
condition|(
name|traverseephemeron
argument_list|(
name|g
argument_list|,
name|gco2t
argument_list|(
name|w
argument_list|)
argument_list|)
condition|)
block|{
comment|/* traverse marked some value? */
name|propagateall
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* propagate changes */
name|changed
operator|=
literal|1
expr_stmt|;
comment|/* will have to revisit all ephemeron tables */
block|}
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Sweep Functions ** ======================================================= */
end_comment

begin_comment
comment|/* ** clear entries with unmarked keys from all weaktables in list 'l' up ** to element 'f' */
end_comment

begin_function
specifier|static
name|void
name|clearkeys
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|GCObject
modifier|*
name|l
parameter_list|,
name|GCObject
modifier|*
name|f
parameter_list|)
block|{
for|for
control|(
init|;
name|l
operator|!=
name|f
condition|;
name|l
operator|=
name|gco2t
argument_list|(
name|l
argument_list|)
operator|->
name|gclist
control|)
block|{
name|Table
modifier|*
name|h
init|=
name|gco2t
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|,
modifier|*
name|limit
init|=
name|gnodelast
argument_list|(
name|h
argument_list|)
decl_stmt|;
for|for
control|(
name|n
operator|=
name|gnode
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
init|;
name|n
operator|<
name|limit
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
operator|&&
operator|(
name|iscleared
argument_list|(
name|g
argument_list|,
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
operator|)
condition|)
block|{
name|setnilvalue
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove value ... */
name|removeentry
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* and remove entry from table */
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** clear entries with unmarked values from all weaktables in list 'l' up ** to element 'f' */
end_comment

begin_function
specifier|static
name|void
name|clearvalues
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|GCObject
modifier|*
name|l
parameter_list|,
name|GCObject
modifier|*
name|f
parameter_list|)
block|{
for|for
control|(
init|;
name|l
operator|!=
name|f
condition|;
name|l
operator|=
name|gco2t
argument_list|(
name|l
argument_list|)
operator|->
name|gclist
control|)
block|{
name|Table
modifier|*
name|h
init|=
name|gco2t
argument_list|(
name|l
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
decl_stmt|,
modifier|*
name|limit
init|=
name|gnodelast
argument_list|(
name|h
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|h
operator|->
name|sizearray
condition|;
name|i
operator|++
control|)
block|{
name|TValue
modifier|*
name|o
init|=
operator|&
name|h
operator|->
name|array
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|iscleared
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
condition|)
comment|/* value was collected? */
name|setnilvalue
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* remove value */
block|}
for|for
control|(
name|n
operator|=
name|gnode
argument_list|(
name|h
argument_list|,
literal|0
argument_list|)
init|;
name|n
operator|<
name|limit
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
operator|&&
name|iscleared
argument_list|(
name|g
argument_list|,
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|setnilvalue
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
comment|/* remove value ... */
name|removeentry
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* and remove entry from table */
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|freeobj
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|GCObject
modifier|*
name|o
parameter_list|)
block|{
switch|switch
condition|(
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|tt
condition|)
block|{
case|case
name|LUA_TPROTO
case|:
name|luaF_freeproto
argument_list|(
name|L
argument_list|,
name|gco2p
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TLCL
case|:
block|{
name|luaM_freemem
argument_list|(
name|L
argument_list|,
name|o
argument_list|,
name|sizeLclosure
argument_list|(
name|gco2lcl
argument_list|(
name|o
argument_list|)
operator|->
name|nupvalues
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TCCL
case|:
block|{
name|luaM_freemem
argument_list|(
name|L
argument_list|,
name|o
argument_list|,
name|sizeCclosure
argument_list|(
name|gco2ccl
argument_list|(
name|o
argument_list|)
operator|->
name|nupvalues
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|LUA_TUPVAL
case|:
name|luaF_freeupval
argument_list|(
name|L
argument_list|,
name|gco2uv
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TTABLE
case|:
name|luaH_free
argument_list|(
name|L
argument_list|,
name|gco2t
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TTHREAD
case|:
name|luaE_freethread
argument_list|(
name|L
argument_list|,
name|gco2th
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TUSERDATA
case|:
name|luaM_freemem
argument_list|(
name|L
argument_list|,
name|o
argument_list|,
name|sizeudata
argument_list|(
name|gco2u
argument_list|(
name|o
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TSHRSTR
case|:
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|strt
operator|.
name|nuse
operator|--
expr_stmt|;
comment|/* go through */
case|case
name|LUA_TLNGSTR
case|:
block|{
name|luaM_freemem
argument_list|(
name|L
argument_list|,
name|o
argument_list|,
name|sizestring
argument_list|(
name|gco2ts
argument_list|(
name|o
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|sweepwholelist
parameter_list|(
name|L
parameter_list|,
name|p
parameter_list|)
value|sweeplist(L,p,MAX_LUMEM)
end_define

begin_function_decl
specifier|static
name|GCObject
modifier|*
modifier|*
name|sweeplist
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|GCObject
modifier|*
modifier|*
name|p
parameter_list|,
name|lu_mem
name|count
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** sweep the (open) upvalues of a thread and resize its stack and ** list of call-info structures. */
end_comment

begin_function
specifier|static
name|void
name|sweepthread
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_State
modifier|*
name|L1
parameter_list|)
block|{
if|if
condition|(
name|L1
operator|->
name|stack
operator|==
name|NULL
condition|)
return|return;
comment|/* stack not completely built yet */
name|sweepwholelist
argument_list|(
name|L
argument_list|,
operator|&
name|L1
operator|->
name|openupval
argument_list|)
expr_stmt|;
comment|/* sweep open upvalues */
name|luaE_freeCI
argument_list|(
name|L1
argument_list|)
expr_stmt|;
comment|/* free extra CallInfo slots */
comment|/* should not change the stack during an emergency gc cycle */
if|if
condition|(
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|gckind
operator|!=
name|KGC_EMERGENCY
condition|)
name|luaD_shrinkstack
argument_list|(
name|L1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** sweep at most 'count' elements from a list of GCObjects erasing dead ** objects, where a dead (not alive) object is one marked with the "old" ** (non current) white and not fixed. ** In non-generational mode, change all non-dead objects back to white, ** preparing for next collection cycle. ** In generational mode, keep black objects black, and also mark them as ** old; stop when hitting an old object, as all objects after that ** one will be old too. ** When object is a thread, sweep its list of open upvalues too. */
end_comment

begin_function
specifier|static
name|GCObject
modifier|*
modifier|*
name|sweeplist
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|GCObject
modifier|*
modifier|*
name|p
parameter_list|,
name|lu_mem
name|count
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|ow
init|=
name|otherwhite
argument_list|(
name|g
argument_list|)
decl_stmt|;
name|int
name|toclear
decl_stmt|,
name|toset
decl_stmt|;
comment|/* bits to clear and to set in all live objects */
name|int
name|tostop
decl_stmt|;
comment|/* stop sweep when this is true */
if|if
condition|(
name|isgenerational
argument_list|(
name|g
argument_list|)
condition|)
block|{
comment|/* generational mode? */
name|toclear
operator|=
operator|~
literal|0
expr_stmt|;
comment|/* clear nothing */
name|toset
operator|=
name|bitmask
argument_list|(
name|OLDBIT
argument_list|)
expr_stmt|;
comment|/* set the old bit of all surviving objects */
name|tostop
operator|=
name|bitmask
argument_list|(
name|OLDBIT
argument_list|)
expr_stmt|;
comment|/* do not sweep old generation */
block|}
else|else
block|{
comment|/* normal mode */
name|toclear
operator|=
name|maskcolors
expr_stmt|;
comment|/* clear all color bits + old bit */
name|toset
operator|=
name|luaC_white
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* make object white */
name|tostop
operator|=
literal|0
expr_stmt|;
comment|/* do not stop */
block|}
while|while
condition|(
operator|*
name|p
operator|!=
name|NULL
operator|&&
name|count
operator|--
operator|>
literal|0
condition|)
block|{
name|GCObject
modifier|*
name|curr
init|=
operator|*
name|p
decl_stmt|;
name|int
name|marked
init|=
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|marked
decl_stmt|;
if|if
condition|(
name|isdeadm
argument_list|(
name|ow
argument_list|,
name|marked
argument_list|)
condition|)
block|{
comment|/* is 'curr' dead? */
operator|*
name|p
operator|=
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|next
expr_stmt|;
comment|/* remove 'curr' from list */
name|freeobj
argument_list|(
name|L
argument_list|,
name|curr
argument_list|)
expr_stmt|;
comment|/* erase 'curr' */
block|}
else|else
block|{
if|if
condition|(
name|testbits
argument_list|(
name|marked
argument_list|,
name|tostop
argument_list|)
condition|)
return|return
name|NULL
return|;
comment|/* stop sweeping this list */
if|if
condition|(
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|tt
operator|==
name|LUA_TTHREAD
condition|)
name|sweepthread
argument_list|(
name|L
argument_list|,
name|gco2th
argument_list|(
name|curr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* sweep thread's upvalues */
comment|/* update marks */
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|marked
operator|=
name|cast_byte
argument_list|(
operator|(
name|marked
operator|&
name|toclear
operator|)
operator||
name|toset
argument_list|)
expr_stmt|;
name|p
operator|=
operator|&
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|next
expr_stmt|;
comment|/* go to next element */
block|}
block|}
return|return
operator|(
operator|*
name|p
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|p
return|;
block|}
end_function

begin_comment
comment|/* ** sweep a list until a live object (or end of list) */
end_comment

begin_function
specifier|static
name|GCObject
modifier|*
modifier|*
name|sweeptolive
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|GCObject
modifier|*
modifier|*
name|p
parameter_list|,
name|int
modifier|*
name|n
parameter_list|)
block|{
name|GCObject
modifier|*
modifier|*
name|old
init|=
name|p
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
do|do
block|{
name|i
operator|++
expr_stmt|;
name|p
operator|=
name|sweeplist
argument_list|(
name|L
argument_list|,
name|p
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|p
operator|==
name|old
condition|)
do|;
if|if
condition|(
name|n
condition|)
operator|*
name|n
operator|+=
name|i
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Finalization ** ======================================================= */
end_comment

begin_function
specifier|static
name|void
name|checkSizes
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|->
name|gckind
operator|!=
name|KGC_EMERGENCY
condition|)
block|{
comment|/* do not change sizes in emergency */
name|int
name|hs
init|=
name|g
operator|->
name|strt
operator|.
name|size
operator|/
literal|2
decl_stmt|;
comment|/* half the size of the string table */
if|if
condition|(
name|g
operator|->
name|strt
operator|.
name|nuse
operator|<
name|cast
argument_list|(
name|lu_int32
argument_list|,
name|hs
argument_list|)
condition|)
comment|/* using less than that half? */
name|luaS_resize
argument_list|(
name|L
argument_list|,
name|hs
argument_list|)
expr_stmt|;
comment|/* halve its size */
name|luaZ_freebuffer
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|buff
argument_list|)
expr_stmt|;
comment|/* free concatenation buffer */
block|}
block|}
end_function

begin_function
specifier|static
name|GCObject
modifier|*
name|udata2finalize
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|)
block|{
name|GCObject
modifier|*
name|o
init|=
name|g
operator|->
name|tobefnz
decl_stmt|;
comment|/* get first element */
name|lua_assert
argument_list|(
name|isfinalized
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|tobefnz
operator|=
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|next
expr_stmt|;
comment|/* remove it from 'tobefnz' list */
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|next
operator|=
name|g
operator|->
name|allgc
expr_stmt|;
comment|/* return it to 'allgc' list */
name|g
operator|->
name|allgc
operator|=
name|o
expr_stmt|;
name|resetbit
argument_list|(
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|marked
argument_list|,
name|SEPARATED
argument_list|)
expr_stmt|;
comment|/* mark that it is not in 'tobefnz' */
name|lua_assert
argument_list|(
operator|!
name|isold
argument_list|(
name|o
argument_list|)
argument_list|)
expr_stmt|;
comment|/* see MOVE OLD rule */
if|if
condition|(
operator|!
name|keepinvariantout
argument_list|(
name|g
argument_list|)
condition|)
comment|/* not keeping invariant? */
name|makewhite
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|/* "sweep" object */
return|return
name|o
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dothecall
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|)
block|{
name|UNUSED
argument_list|(
name|ud
argument_list|)
expr_stmt|;
name|luaD_call
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|-
literal|2
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|GCTM
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|propagateerrors
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
specifier|const
name|TValue
modifier|*
name|tm
decl_stmt|;
name|TValue
name|v
decl_stmt|;
name|setgcovalue
argument_list|(
name|L
argument_list|,
operator|&
name|v
argument_list|,
name|udata2finalize
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|=
name|luaT_gettmbyobj
argument_list|(
name|L
argument_list|,
operator|&
name|v
argument_list|,
name|TM_GC
argument_list|)
expr_stmt|;
if|if
condition|(
name|tm
operator|!=
name|NULL
operator|&&
name|ttisfunction
argument_list|(
name|tm
argument_list|)
condition|)
block|{
comment|/* is there a finalizer? */
name|int
name|status
decl_stmt|;
name|lu_byte
name|oldah
init|=
name|L
operator|->
name|allowhook
decl_stmt|;
name|int
name|running
init|=
name|g
operator|->
name|gcrunning
decl_stmt|;
name|L
operator|->
name|allowhook
operator|=
literal|0
expr_stmt|;
comment|/* stop debug hooks during GC metamethod */
name|g
operator|->
name|gcrunning
operator|=
literal|0
expr_stmt|;
comment|/* avoid GC steps */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|tm
argument_list|)
expr_stmt|;
comment|/* push finalizer... */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|+
literal|1
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* ... and its argument */
name|L
operator|->
name|top
operator|+=
literal|2
expr_stmt|;
comment|/* and (next line) call the finalizer */
name|status
operator|=
name|luaD_pcall
argument_list|(
name|L
argument_list|,
name|dothecall
argument_list|,
name|NULL
argument_list|,
name|savestack
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|-
literal|2
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|L
operator|->
name|allowhook
operator|=
name|oldah
expr_stmt|;
comment|/* restore hooks */
name|g
operator|->
name|gcrunning
operator|=
name|running
expr_stmt|;
comment|/* restore state */
if|if
condition|(
name|status
operator|!=
name|LUA_OK
operator|&&
name|propagateerrors
condition|)
block|{
comment|/* error while running __gc? */
if|if
condition|(
name|status
operator|==
name|LUA_ERRRUN
condition|)
block|{
comment|/* is there an error object? */
specifier|const
name|char
modifier|*
name|msg
init|=
operator|(
name|ttisstring
argument_list|(
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
operator|)
condition|?
name|svalue
argument_list|(
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
else|:
literal|"no message"
decl_stmt|;
name|luaO_pushfstring
argument_list|(
name|L
argument_list|,
literal|"error in __gc metamethod (%s)"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|status
operator|=
name|LUA_ERRGCMM
expr_stmt|;
comment|/* error in __gc metamethod */
block|}
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|status
argument_list|)
expr_stmt|;
comment|/* re-throw error */
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** move all unreachable objects (or 'all' objects) that need ** finalization from list 'finobj' to list 'tobefnz' (to be finalized) */
end_comment

begin_function
specifier|static
name|void
name|separatetobefnz
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|all
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|GCObject
modifier|*
modifier|*
name|p
init|=
operator|&
name|g
operator|->
name|finobj
decl_stmt|;
name|GCObject
modifier|*
name|curr
decl_stmt|;
name|GCObject
modifier|*
modifier|*
name|lastnext
init|=
operator|&
name|g
operator|->
name|tobefnz
decl_stmt|;
comment|/* find last 'next' field in 'tobefnz' list (to add elements in its end) */
while|while
condition|(
operator|*
name|lastnext
operator|!=
name|NULL
condition|)
name|lastnext
operator|=
operator|&
name|gch
argument_list|(
operator|*
name|lastnext
argument_list|)
operator|->
name|next
expr_stmt|;
while|while
condition|(
operator|(
name|curr
operator|=
operator|*
name|p
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* traverse all finalizable objects */
name|lua_assert
argument_list|(
operator|!
name|isfinalized
argument_list|(
name|curr
argument_list|)
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|testbit
argument_list|(
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|marked
argument_list|,
name|SEPARATED
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|iswhite
argument_list|(
name|curr
argument_list|)
operator|||
name|all
operator|)
condition|)
comment|/* not being collected? */
name|p
operator|=
operator|&
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|next
expr_stmt|;
comment|/* don't bother with it */
else|else
block|{
name|l_setbit
argument_list|(
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|marked
argument_list|,
name|FINALIZEDBIT
argument_list|)
expr_stmt|;
comment|/* won't be finalized again */
operator|*
name|p
operator|=
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|next
expr_stmt|;
comment|/* remove 'curr' from 'finobj' list */
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|next
operator|=
operator|*
name|lastnext
expr_stmt|;
comment|/* link at the end of 'tobefnz' list */
operator|*
name|lastnext
operator|=
name|curr
expr_stmt|;
name|lastnext
operator|=
operator|&
name|gch
argument_list|(
name|curr
argument_list|)
operator|->
name|next
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** if object 'o' has a finalizer, remove it from 'allgc' list (must ** search the list to find it) and link it in 'finobj' list. */
end_comment

begin_function
name|void
name|luaC_checkfinalizer
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|GCObject
modifier|*
name|o
parameter_list|,
name|Table
modifier|*
name|mt
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|testbit
argument_list|(
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|marked
argument_list|,
name|SEPARATED
argument_list|)
operator|||
comment|/* obj. is already separated... */
name|isfinalized
argument_list|(
name|o
argument_list|)
operator|||
comment|/* ... or is finalized... */
name|gfasttm
argument_list|(
name|g
argument_list|,
name|mt
argument_list|,
name|TM_GC
argument_list|)
operator|==
name|NULL
condition|)
comment|/* or has no finalizer? */
return|return;
comment|/* nothing to be done */
else|else
block|{
comment|/* move 'o' to 'finobj' list */
name|GCObject
modifier|*
modifier|*
name|p
decl_stmt|;
name|GCheader
modifier|*
name|ho
init|=
name|gch
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|->
name|sweepgc
operator|==
operator|&
name|ho
operator|->
name|next
condition|)
block|{
comment|/* avoid removing current sweep object */
name|lua_assert
argument_list|(
name|issweepphase
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|sweepgc
operator|=
name|sweeptolive
argument_list|(
name|L
argument_list|,
name|g
operator|->
name|sweepgc
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* search for pointer pointing to 'o' */
for|for
control|(
name|p
operator|=
operator|&
name|g
operator|->
name|allgc
init|;
operator|*
name|p
operator|!=
name|o
condition|;
name|p
operator|=
operator|&
name|gch
argument_list|(
operator|*
name|p
argument_list|)
operator|->
name|next
control|)
block|{
comment|/* empty */
block|}
operator|*
name|p
operator|=
name|ho
operator|->
name|next
expr_stmt|;
comment|/* remove 'o' from root list */
name|ho
operator|->
name|next
operator|=
name|g
operator|->
name|finobj
expr_stmt|;
comment|/* link it in list 'finobj' */
name|g
operator|->
name|finobj
operator|=
name|o
expr_stmt|;
name|l_setbit
argument_list|(
name|ho
operator|->
name|marked
argument_list|,
name|SEPARATED
argument_list|)
expr_stmt|;
comment|/* mark it as such */
if|if
condition|(
operator|!
name|keepinvariantout
argument_list|(
name|g
argument_list|)
condition|)
comment|/* not keeping invariant? */
name|makewhite
argument_list|(
name|g
argument_list|,
name|o
argument_list|)
expr_stmt|;
comment|/* "sweep" object */
else|else
name|resetoldbit
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* see MOVE OLD rule */
block|}
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** GC control ** ======================================================= */
end_comment

begin_comment
comment|/* ** set a reasonable "time" to wait before starting a new GC cycle; ** cycle will start when memory use hits threshold */
end_comment

begin_function
specifier|static
name|void
name|setpause
parameter_list|(
name|global_State
modifier|*
name|g
parameter_list|,
name|l_mem
name|estimate
parameter_list|)
block|{
name|l_mem
name|debt
decl_stmt|,
name|threshold
decl_stmt|;
name|estimate
operator|=
name|estimate
operator|/
name|PAUSEADJ
expr_stmt|;
comment|/* adjust 'estimate' */
name|threshold
operator|=
operator|(
name|g
operator|->
name|gcpause
operator|<
name|MAX_LMEM
operator|/
name|estimate
operator|)
comment|/* overflow? */
condition|?
name|estimate
operator|*
name|g
operator|->
name|gcpause
comment|/* no overflow */
else|:
name|MAX_LMEM
expr_stmt|;
comment|/* overflow; truncate to maximum */
name|debt
operator|=
operator|-
name|cast
argument_list|(
name|l_mem
argument_list|,
name|threshold
operator|-
name|gettotalbytes
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|luaE_setdebt
argument_list|(
name|g
argument_list|,
name|debt
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|sweepphases
define|\
value|(bitmask(GCSsweepstring) | bitmask(GCSsweepudata) | bitmask(GCSsweep))
end_define

begin_comment
comment|/* ** enter first sweep phase (strings) and prepare pointers for other ** sweep phases.  The calls to 'sweeptolive' make pointers point to an ** object inside the list (instead of to the header), so that the real ** sweep do not need to skip objects created between "now" and the start ** of the real sweep. ** Returns how many objects it swept. */
end_comment

begin_function
specifier|static
name|int
name|entersweep
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|n
init|=
literal|0
decl_stmt|;
name|g
operator|->
name|gcstate
operator|=
name|GCSsweepstring
expr_stmt|;
name|lua_assert
argument_list|(
name|g
operator|->
name|sweepgc
operator|==
name|NULL
operator|&&
name|g
operator|->
name|sweepfin
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* prepare to sweep strings, finalizable objects, and regular objects */
name|g
operator|->
name|sweepstrgc
operator|=
literal|0
expr_stmt|;
name|g
operator|->
name|sweepfin
operator|=
name|sweeptolive
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|finobj
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
name|g
operator|->
name|sweepgc
operator|=
name|sweeptolive
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|allgc
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* ** change GC mode */
end_comment

begin_function
name|void
name|luaC_changemode
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|g
operator|->
name|gckind
condition|)
return|return;
comment|/* nothing to change */
if|if
condition|(
name|mode
operator|==
name|KGC_GEN
condition|)
block|{
comment|/* change to generational mode */
comment|/* make sure gray lists are consistent */
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
name|bitmask
argument_list|(
name|GCSpropagate
argument_list|)
argument_list|)
expr_stmt|;
name|g
operator|->
name|GCestimate
operator|=
name|gettotalbytes
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|gckind
operator|=
name|KGC_GEN
expr_stmt|;
block|}
else|else
block|{
comment|/* change to incremental mode */
comment|/* sweep all objects to turn them back to white        (as white has not changed, nothing extra will be collected) */
name|g
operator|->
name|gckind
operator|=
name|KGC_NORMAL
expr_stmt|;
name|entersweep
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
operator|~
name|sweepphases
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** call all pending finalizers */
end_comment

begin_function
specifier|static
name|void
name|callallpendingfinalizers
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|propagateerrors
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
while|while
condition|(
name|g
operator|->
name|tobefnz
condition|)
block|{
name|resetoldbit
argument_list|(
name|g
operator|->
name|tobefnz
argument_list|)
expr_stmt|;
name|GCTM
argument_list|(
name|L
argument_list|,
name|propagateerrors
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|luaC_freeallobjects
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
name|separatetobefnz
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* separate all objects with finalizers */
name|lua_assert
argument_list|(
name|g
operator|->
name|finobj
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|callallpendingfinalizers
argument_list|(
name|L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|g
operator|->
name|currentwhite
operator|=
name|WHITEBITS
expr_stmt|;
comment|/* this "white" makes all objects look dead */
name|g
operator|->
name|gckind
operator|=
name|KGC_NORMAL
expr_stmt|;
name|sweepwholelist
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|finobj
argument_list|)
expr_stmt|;
comment|/* finalizers can create objs. in 'finobj' */
name|sweepwholelist
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|allgc
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|g
operator|->
name|strt
operator|.
name|size
condition|;
name|i
operator|++
control|)
comment|/* free all string lists */
name|sweepwholelist
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|strt
operator|.
name|hash
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|g
operator|->
name|strt
operator|.
name|nuse
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|l_mem
name|atomic
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|l_mem
name|work
init|=
operator|-
name|cast
argument_list|(
name|l_mem
argument_list|,
name|g
operator|->
name|GCmemtrav
argument_list|)
decl_stmt|;
comment|/* start counting work */
name|GCObject
modifier|*
name|origweak
decl_stmt|,
modifier|*
name|origall
decl_stmt|;
name|lua_assert
argument_list|(
operator|!
name|iswhite
argument_list|(
name|obj2gco
argument_list|(
name|g
operator|->
name|mainthread
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|markobject
argument_list|(
name|g
argument_list|,
name|L
argument_list|)
expr_stmt|;
comment|/* mark running thread */
comment|/* registry and global metatables may be changed by API */
name|markvalue
argument_list|(
name|g
argument_list|,
operator|&
name|g
operator|->
name|l_registry
argument_list|)
expr_stmt|;
name|markmt
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* mark basic metatables */
comment|/* remark occasional upvalues of (maybe) dead threads */
name|remarkupvals
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|propagateall
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* propagate changes */
name|work
operator|+=
name|g
operator|->
name|GCmemtrav
expr_stmt|;
comment|/* stop counting (do not (re)count grays) */
comment|/* traverse objects caught by write barrier and by 'remarkupvals' */
name|retraversegrays
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|work
operator|-=
name|g
operator|->
name|GCmemtrav
expr_stmt|;
comment|/* restart counting */
name|convergeephemerons
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* at this point, all strongly accessible objects are marked. */
comment|/* clear values from weak tables, before checking finalizers */
name|clearvalues
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|weak
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|clearvalues
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|allweak
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|origweak
operator|=
name|g
operator|->
name|weak
expr_stmt|;
name|origall
operator|=
name|g
operator|->
name|allweak
expr_stmt|;
name|work
operator|+=
name|g
operator|->
name|GCmemtrav
expr_stmt|;
comment|/* stop counting (objects being finalized) */
name|separatetobefnz
argument_list|(
name|L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* separate objects to be finalized */
name|markbeingfnz
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* mark objects that will be finalized */
name|propagateall
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* remark, to propagate `preserveness' */
name|work
operator|-=
name|g
operator|->
name|GCmemtrav
expr_stmt|;
comment|/* restart counting */
name|convergeephemerons
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* at this point, all resurrected objects are marked. */
comment|/* remove dead objects from weak tables */
name|clearkeys
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|ephemeron
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* clear keys from all ephemeron tables */
name|clearkeys
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|allweak
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* clear keys from all allweak tables */
comment|/* clear values from resurrected weak tables */
name|clearvalues
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|weak
argument_list|,
name|origweak
argument_list|)
expr_stmt|;
name|clearvalues
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|allweak
argument_list|,
name|origall
argument_list|)
expr_stmt|;
name|g
operator|->
name|currentwhite
operator|=
name|cast_byte
argument_list|(
name|otherwhite
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
comment|/* flip current white */
name|work
operator|+=
name|g
operator|->
name|GCmemtrav
expr_stmt|;
comment|/* complete counting */
return|return
name|work
return|;
comment|/* estimate of memory marked by 'atomic' */
block|}
end_function

begin_function
specifier|static
name|lu_mem
name|singlestep
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|g
operator|->
name|gcstate
condition|)
block|{
case|case
name|GCSpause
case|:
block|{
comment|/* start to count memory traversed */
name|g
operator|->
name|GCmemtrav
operator|=
name|g
operator|->
name|strt
operator|.
name|size
operator|*
sizeof|sizeof
argument_list|(
name|GCObject
operator|*
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
operator|!
name|isgenerational
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|restartcollection
argument_list|(
name|g
argument_list|)
expr_stmt|;
name|g
operator|->
name|gcstate
operator|=
name|GCSpropagate
expr_stmt|;
return|return
name|g
operator|->
name|GCmemtrav
return|;
block|}
case|case
name|GCSpropagate
case|:
block|{
if|if
condition|(
name|g
operator|->
name|gray
condition|)
block|{
name|lu_mem
name|oldtrav
init|=
name|g
operator|->
name|GCmemtrav
decl_stmt|;
name|propagatemark
argument_list|(
name|g
argument_list|)
expr_stmt|;
return|return
name|g
operator|->
name|GCmemtrav
operator|-
name|oldtrav
return|;
comment|/* memory traversed in this step */
block|}
else|else
block|{
comment|/* no more `gray' objects */
name|lu_mem
name|work
decl_stmt|;
name|int
name|sw
decl_stmt|;
name|g
operator|->
name|gcstate
operator|=
name|GCSatomic
expr_stmt|;
comment|/* finish mark phase */
name|g
operator|->
name|GCestimate
operator|=
name|g
operator|->
name|GCmemtrav
expr_stmt|;
comment|/* save what was counted */
empty_stmt|;
name|work
operator|=
name|atomic
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* add what was traversed by 'atomic' */
name|g
operator|->
name|GCestimate
operator|+=
name|work
expr_stmt|;
comment|/* estimate of total memory traversed */
name|sw
operator|=
name|entersweep
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|work
operator|+
name|sw
operator|*
name|GCSWEEPCOST
return|;
block|}
block|}
case|case
name|GCSsweepstring
case|:
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|GCSWEEPMAX
operator|&&
name|g
operator|->
name|sweepstrgc
operator|+
name|i
operator|<
name|g
operator|->
name|strt
operator|.
name|size
condition|;
name|i
operator|++
control|)
name|sweepwholelist
argument_list|(
name|L
argument_list|,
operator|&
name|g
operator|->
name|strt
operator|.
name|hash
index|[
name|g
operator|->
name|sweepstrgc
operator|+
name|i
index|]
argument_list|)
expr_stmt|;
name|g
operator|->
name|sweepstrgc
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|sweepstrgc
operator|>=
name|g
operator|->
name|strt
operator|.
name|size
condition|)
comment|/* no more strings to sweep? */
name|g
operator|->
name|gcstate
operator|=
name|GCSsweepudata
expr_stmt|;
return|return
name|i
operator|*
name|GCSWEEPCOST
return|;
block|}
case|case
name|GCSsweepudata
case|:
block|{
if|if
condition|(
name|g
operator|->
name|sweepfin
condition|)
block|{
name|g
operator|->
name|sweepfin
operator|=
name|sweeplist
argument_list|(
name|L
argument_list|,
name|g
operator|->
name|sweepfin
argument_list|,
name|GCSWEEPMAX
argument_list|)
expr_stmt|;
return|return
name|GCSWEEPMAX
operator|*
name|GCSWEEPCOST
return|;
block|}
else|else
block|{
name|g
operator|->
name|gcstate
operator|=
name|GCSsweep
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
case|case
name|GCSsweep
case|:
block|{
if|if
condition|(
name|g
operator|->
name|sweepgc
condition|)
block|{
name|g
operator|->
name|sweepgc
operator|=
name|sweeplist
argument_list|(
name|L
argument_list|,
name|g
operator|->
name|sweepgc
argument_list|,
name|GCSWEEPMAX
argument_list|)
expr_stmt|;
return|return
name|GCSWEEPMAX
operator|*
name|GCSWEEPCOST
return|;
block|}
else|else
block|{
comment|/* sweep main thread */
name|GCObject
modifier|*
name|mt
init|=
name|obj2gco
argument_list|(
name|g
operator|->
name|mainthread
argument_list|)
decl_stmt|;
name|sweeplist
argument_list|(
name|L
argument_list|,
operator|&
name|mt
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|checkSizes
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|g
operator|->
name|gcstate
operator|=
name|GCSpause
expr_stmt|;
comment|/* finish collection */
return|return
name|GCSWEEPCOST
return|;
block|}
block|}
default|default:
name|lua_assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
block|}
end_function

begin_comment
comment|/* ** advances the garbage collector until it reaches a state allowed ** by 'statemask' */
end_comment

begin_function
name|void
name|luaC_runtilstate
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|statesmask
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
while|while
condition|(
operator|!
name|testbit
argument_list|(
name|statesmask
argument_list|,
name|g
operator|->
name|gcstate
argument_list|)
condition|)
name|singlestep
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|generationalcollection
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|g
operator|->
name|gcstate
operator|==
name|GCSpropagate
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|->
name|GCestimate
operator|==
literal|0
condition|)
block|{
comment|/* signal for another major collection? */
name|luaC_fullgc
argument_list|(
name|L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* perform a full regular collection */
name|g
operator|->
name|GCestimate
operator|=
name|gettotalbytes
argument_list|(
name|g
argument_list|)
expr_stmt|;
comment|/* update control */
block|}
else|else
block|{
name|lu_mem
name|estimate
init|=
name|g
operator|->
name|GCestimate
decl_stmt|;
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
name|bitmask
argument_list|(
name|GCSpause
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run complete (minor) cycle */
name|g
operator|->
name|gcstate
operator|=
name|GCSpropagate
expr_stmt|;
comment|/* skip restart */
if|if
condition|(
name|gettotalbytes
argument_list|(
name|g
argument_list|)
operator|>
operator|(
name|estimate
operator|/
literal|100
operator|)
operator|*
name|g
operator|->
name|gcmajorinc
condition|)
name|g
operator|->
name|GCestimate
operator|=
literal|0
expr_stmt|;
comment|/* signal for a major collection */
else|else
name|g
operator|->
name|GCestimate
operator|=
name|estimate
expr_stmt|;
comment|/* keep estimate from last major coll. */
block|}
name|setpause
argument_list|(
name|g
argument_list|,
name|gettotalbytes
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|g
operator|->
name|gcstate
operator|==
name|GCSpropagate
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|incstep
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|l_mem
name|debt
init|=
name|g
operator|->
name|GCdebt
decl_stmt|;
name|int
name|stepmul
init|=
name|g
operator|->
name|gcstepmul
decl_stmt|;
if|if
condition|(
name|stepmul
operator|<
literal|40
condition|)
name|stepmul
operator|=
literal|40
expr_stmt|;
comment|/* avoid ridiculous low values (and 0) */
comment|/* convert debt from Kb to 'work units' (avoid zero debt and overflows) */
name|debt
operator|=
operator|(
name|debt
operator|/
name|STEPMULADJ
operator|)
operator|+
literal|1
expr_stmt|;
name|debt
operator|=
operator|(
name|debt
operator|<
name|MAX_LMEM
operator|/
name|stepmul
operator|)
condition|?
name|debt
operator|*
name|stepmul
else|:
name|MAX_LMEM
expr_stmt|;
do|do
block|{
comment|/* always perform at least one single step */
name|lu_mem
name|work
init|=
name|singlestep
argument_list|(
name|L
argument_list|)
decl_stmt|;
comment|/* do some work */
name|debt
operator|-=
name|work
expr_stmt|;
block|}
do|while
condition|(
name|debt
operator|>
operator|-
name|GCSTEPSIZE
operator|&&
name|g
operator|->
name|gcstate
operator|!=
name|GCSpause
condition|)
do|;
if|if
condition|(
name|g
operator|->
name|gcstate
operator|==
name|GCSpause
condition|)
name|setpause
argument_list|(
name|g
argument_list|,
name|g
operator|->
name|GCestimate
argument_list|)
expr_stmt|;
comment|/* pause until next cycle */
else|else
block|{
name|debt
operator|=
operator|(
name|debt
operator|/
name|stepmul
operator|)
operator|*
name|STEPMULADJ
expr_stmt|;
comment|/* convert 'work units' to Kb */
name|luaE_setdebt
argument_list|(
name|g
argument_list|,
name|debt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** performs a basic GC step */
end_comment

begin_function
name|void
name|luaC_forcestep
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|isgenerational
argument_list|(
name|g
argument_list|)
condition|)
name|generationalcollection
argument_list|(
name|L
argument_list|)
expr_stmt|;
else|else
name|incstep
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* run a few finalizers (or all of them at the end of a collect cycle) */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|g
operator|->
name|tobefnz
operator|&&
operator|(
name|i
operator|<
name|GCFINALIZENUM
operator|||
name|g
operator|->
name|gcstate
operator|==
name|GCSpause
operator|)
condition|;
name|i
operator|++
control|)
name|GCTM
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* call one finalizer */
block|}
end_function

begin_comment
comment|/* ** performs a basic GC step only if collector is running */
end_comment

begin_function
name|void
name|luaC_step
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|g
operator|->
name|gcrunning
condition|)
name|luaC_forcestep
argument_list|(
name|L
argument_list|)
expr_stmt|;
else|else
name|luaE_setdebt
argument_list|(
name|g
argument_list|,
operator|-
name|GCSTEPSIZE
argument_list|)
expr_stmt|;
comment|/* avoid being called too often */
block|}
end_function

begin_comment
comment|/* ** performs a full GC cycle; if "isemergency", does not call ** finalizers (which could change stack positions) */
end_comment

begin_function
name|void
name|luaC_fullgc
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|isemergency
parameter_list|)
block|{
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|origkind
init|=
name|g
operator|->
name|gckind
decl_stmt|;
name|lua_assert
argument_list|(
name|origkind
operator|!=
name|KGC_EMERGENCY
argument_list|)
expr_stmt|;
if|if
condition|(
name|isemergency
condition|)
comment|/* do not run finalizers during emergency GC */
name|g
operator|->
name|gckind
operator|=
name|KGC_EMERGENCY
expr_stmt|;
else|else
block|{
name|g
operator|->
name|gckind
operator|=
name|KGC_NORMAL
expr_stmt|;
name|callallpendingfinalizers
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keepinvariant
argument_list|(
name|g
argument_list|)
condition|)
block|{
comment|/* may there be some black objects? */
comment|/* must sweep all objects to turn them back to white        (as white has not changed, nothing will be collected) */
name|entersweep
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
comment|/* finish any pending sweep phase to start a new cycle */
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
name|bitmask
argument_list|(
name|GCSpause
argument_list|)
argument_list|)
expr_stmt|;
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
operator|~
name|bitmask
argument_list|(
name|GCSpause
argument_list|)
argument_list|)
expr_stmt|;
comment|/* start new collection */
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
name|bitmask
argument_list|(
name|GCSpause
argument_list|)
argument_list|)
expr_stmt|;
comment|/* run entire collection */
if|if
condition|(
name|origkind
operator|==
name|KGC_GEN
condition|)
block|{
comment|/* generational mode? */
comment|/* generational mode must be kept in propagate phase */
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
name|bitmask
argument_list|(
name|GCSpropagate
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|g
operator|->
name|gckind
operator|=
name|origkind
expr_stmt|;
name|setpause
argument_list|(
name|g
argument_list|,
name|gettotalbytes
argument_list|(
name|g
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isemergency
condition|)
comment|/* do not run finalizers during emergency GC */
name|callallpendingfinalizers
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

end_unit

