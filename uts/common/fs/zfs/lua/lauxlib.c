begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lauxlib.c,v 1.248.1.1 2013/04/12 18:48:47 roberto Exp $ ** Auxiliary functions for building Lua libraries ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_comment
comment|/* This file uses only the official API of Lua. ** Any function declared here could be written as an application function. */
end_comment

begin_define
define|#
directive|define
name|lauxlib_c
end_define

begin_define
define|#
directive|define
name|LUA_LIB
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lauxlib.h"
end_include

begin_comment
comment|/* ** {====================================================== ** Traceback ** ======================================================= */
end_comment

begin_define
define|#
directive|define
name|LEVELS1
value|12
end_define

begin_comment
comment|/* size of the first part of the stack */
end_comment

begin_define
define|#
directive|define
name|LEVELS2
value|10
end_define

begin_comment
comment|/* size of the second part of the stack */
end_comment

begin_comment
comment|/* ** search for 'objidx' in table at index -1. ** return 1 + string at top if find a good name. */
end_comment

begin_function
specifier|static
name|int
name|findfield
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|objidx
parameter_list|,
name|int
name|level
parameter_list|)
block|{
if|if
condition|(
name|level
operator|==
literal|0
operator|||
operator|!
name|lua_istable
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* not found */
name|lua_pushnil
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* start 'next' loop */
while|while
condition|(
name|lua_next
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
block|{
comment|/* for each pair in table */
if|if
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
operator|==
name|LUA_TSTRING
condition|)
block|{
comment|/* ignore non-string keys */
if|if
condition|(
name|lua_rawequal
argument_list|(
name|L
argument_list|,
name|objidx
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* found object? */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove value (but keep name) */
return|return
literal|1
return|;
block|}
elseif|else
if|if
condition|(
name|findfield
argument_list|(
name|L
argument_list|,
name|objidx
argument_list|,
name|level
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* try recursively */
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* remove table (but keep name) */
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
name|lua_insert
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* place '.' between the two names */
name|lua_concat
argument_list|(
name|L
argument_list|,
literal|3
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove value */
block|}
return|return
literal|0
return|;
comment|/* not found */
block|}
end_function

begin_function
specifier|static
name|int
name|pushglobalfuncname
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_Debug
modifier|*
name|ar
parameter_list|)
block|{
name|int
name|top
init|=
name|lua_gettop
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|lua_getinfo
argument_list|(
name|L
argument_list|,
literal|"f"
argument_list|,
name|ar
argument_list|)
expr_stmt|;
comment|/* push function */
name|lua_pushglobaltable
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|findfield
argument_list|(
name|L
argument_list|,
name|top
operator|+
literal|1
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|lua_copy
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
name|top
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* move name to proper place */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* remove pushed values */
return|return
literal|1
return|;
block|}
else|else
block|{
name|lua_settop
argument_list|(
name|L
argument_list|,
name|top
argument_list|)
expr_stmt|;
comment|/* remove function and global table */
return|return
literal|0
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pushfuncname
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_Debug
modifier|*
name|ar
parameter_list|)
block|{
if|if
condition|(
operator|*
name|ar
operator|->
name|namewhat
operator|!=
literal|'\0'
condition|)
comment|/* is there a name? */
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"function "
name|LUA_QS
argument_list|,
name|ar
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ar
operator|->
name|what
operator|==
literal|'m'
condition|)
comment|/* main? */
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"main chunk"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|ar
operator|->
name|what
operator|==
literal|'C'
condition|)
block|{
if|if
condition|(
name|pushglobalfuncname
argument_list|(
name|L
argument_list|,
name|ar
argument_list|)
condition|)
block|{
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"function "
name|LUA_QS
argument_list|,
name|lua_tostring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* remove name */
block|}
else|else
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"?"
argument_list|)
expr_stmt|;
block|}
else|else
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"function<%s:%d>"
argument_list|,
name|ar
operator|->
name|short_src
argument_list|,
name|ar
operator|->
name|linedefined
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|countlevels
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_Debug
name|ar
decl_stmt|;
name|int
name|li
init|=
literal|1
decl_stmt|,
name|le
init|=
literal|1
decl_stmt|;
comment|/* find an upper bound */
while|while
condition|(
name|lua_getstack
argument_list|(
name|L
argument_list|,
name|le
argument_list|,
operator|&
name|ar
argument_list|)
condition|)
block|{
name|li
operator|=
name|le
expr_stmt|;
name|le
operator|*=
literal|2
expr_stmt|;
block|}
comment|/* do a binary search */
while|while
condition|(
name|li
operator|<
name|le
condition|)
block|{
name|int
name|m
init|=
operator|(
name|li
operator|+
name|le
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|lua_getstack
argument_list|(
name|L
argument_list|,
name|m
argument_list|,
operator|&
name|ar
argument_list|)
condition|)
name|li
operator|=
name|m
operator|+
literal|1
expr_stmt|;
else|else
name|le
operator|=
name|m
expr_stmt|;
block|}
return|return
name|le
operator|-
literal|1
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_traceback
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_State
modifier|*
name|L1
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|lua_Debug
name|ar
decl_stmt|;
name|int
name|top
init|=
name|lua_gettop
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|int
name|numlevels
init|=
name|countlevels
argument_list|(
name|L1
argument_list|)
decl_stmt|;
name|int
name|mark
init|=
operator|(
name|numlevels
operator|>
name|LEVELS1
operator|+
name|LEVELS2
operator|)
condition|?
name|LEVELS1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|msg
condition|)
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"stack traceback:"
argument_list|)
expr_stmt|;
while|while
condition|(
name|lua_getstack
argument_list|(
name|L1
argument_list|,
name|level
operator|++
argument_list|,
operator|&
name|ar
argument_list|)
condition|)
block|{
if|if
condition|(
name|level
operator|==
name|mark
condition|)
block|{
comment|/* too many levels? */
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"\n\t..."
argument_list|)
expr_stmt|;
comment|/* add a '...' */
name|level
operator|=
name|numlevels
operator|-
name|LEVELS2
expr_stmt|;
comment|/* and skip to last ones */
block|}
else|else
block|{
name|lua_getinfo
argument_list|(
name|L1
argument_list|,
literal|"Slnt"
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"\n\t%s:"
argument_list|,
name|ar
operator|.
name|short_src
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|.
name|currentline
operator|>
literal|0
condition|)
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"%d:"
argument_list|,
name|ar
operator|.
name|currentline
argument_list|)
expr_stmt|;
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|" in "
argument_list|)
expr_stmt|;
name|pushfuncname
argument_list|(
name|L
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|.
name|istailcall
condition|)
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"\n\t(...tail calls...)"
argument_list|)
expr_stmt|;
name|lua_concat
argument_list|(
name|L
argument_list|,
name|lua_gettop
argument_list|(
name|L
argument_list|)
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
block|}
name|lua_concat
argument_list|(
name|L
argument_list|,
name|lua_gettop
argument_list|(
name|L
argument_list|)
operator|-
name|top
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Error-report functions ** ======================================================= */
end_comment

begin_function
name|LUALIB_API
name|int
name|luaL_argerror
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
specifier|const
name|char
modifier|*
name|extramsg
parameter_list|)
block|{
name|lua_Debug
name|ar
decl_stmt|;
if|if
condition|(
operator|!
name|lua_getstack
argument_list|(
name|L
argument_list|,
literal|0
argument_list|,
operator|&
name|ar
argument_list|)
condition|)
comment|/* no stack frame? */
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"bad argument #%d (%s)"
argument_list|,
name|narg
argument_list|,
name|extramsg
argument_list|)
return|;
name|lua_getinfo
argument_list|(
name|L
argument_list|,
literal|"n"
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|ar
operator|.
name|namewhat
argument_list|,
literal|"method"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|narg
operator|--
expr_stmt|;
comment|/* do not count `self' */
if|if
condition|(
name|narg
operator|==
literal|0
condition|)
comment|/* error is in the self argument itself? */
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"calling "
name|LUA_QS
literal|" on bad self (%s)"
argument_list|,
name|ar
operator|.
name|name
argument_list|,
name|extramsg
argument_list|)
return|;
block|}
if|if
condition|(
name|ar
operator|.
name|name
operator|==
name|NULL
condition|)
name|ar
operator|.
name|name
operator|=
operator|(
name|pushglobalfuncname
argument_list|(
name|L
argument_list|,
operator|&
name|ar
argument_list|)
operator|)
condition|?
name|lua_tostring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
else|:
literal|"?"
expr_stmt|;
return|return
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"bad argument #%d to "
name|LUA_QS
literal|" (%s)"
argument_list|,
name|narg
argument_list|,
name|ar
operator|.
name|name
argument_list|,
name|extramsg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|typeerror
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|msg
init|=
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"%s expected, got %s"
argument_list|,
name|tname
argument_list|,
name|luaL_typename
argument_list|(
name|L
argument_list|,
name|narg
argument_list|)
argument_list|)
decl_stmt|;
return|return
name|luaL_argerror
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|msg
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|tag_error
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
name|int
name|tag
parameter_list|)
block|{
name|typeerror
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|lua_typename
argument_list|(
name|L
argument_list|,
name|tag
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_where
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|level
parameter_list|)
block|{
name|lua_Debug
name|ar
decl_stmt|;
if|if
condition|(
name|lua_getstack
argument_list|(
name|L
argument_list|,
name|level
argument_list|,
operator|&
name|ar
argument_list|)
condition|)
block|{
comment|/* check function at level */
name|lua_getinfo
argument_list|(
name|L
argument_list|,
literal|"Sl"
argument_list|,
operator|&
name|ar
argument_list|)
expr_stmt|;
comment|/* get info about it */
if|if
condition|(
name|ar
operator|.
name|currentline
operator|>
literal|0
condition|)
block|{
comment|/* is there info? */
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ar
operator|.
name|short_src
argument_list|,
name|ar
operator|.
name|currentline
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* else, no information available... */
block|}
end_function

begin_function
name|LUALIB_API
name|int
name|luaL_error
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|luaL_where
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lua_pushvfstring
argument_list|(
name|L
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|lua_concat
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return
name|lua_error
argument_list|(
name|L
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|inspectstat
argument_list|)
end_if

begin_comment
comment|/* { */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LUA_USE_POSIX
argument_list|)
end_if

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_comment
comment|/* ** use appropriate macros to interpret 'pclose' return status */
end_comment

begin_define
define|#
directive|define
name|inspectstat
parameter_list|(
name|stat
parameter_list|,
name|what
parameter_list|)
define|\
value|if (WIFEXITED(stat)) { stat = WEXITSTATUS(stat); } \    else if (WIFSIGNALED(stat)) { stat = WTERMSIG(stat); what = "signal"; }
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|inspectstat
parameter_list|(
name|stat
parameter_list|,
name|what
parameter_list|)
end_define

begin_comment
comment|/* no op */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* } */
end_comment

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Userdata's metatable manipulation ** ======================================================= */
end_comment

begin_function
name|LUALIB_API
name|int
name|luaL_newmetatable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|)
block|{
name|luaL_getmetatable
argument_list|(
name|L
argument_list|,
name|tname
argument_list|)
expr_stmt|;
comment|/* try to get metatable */
if|if
condition|(
operator|!
name|lua_isnil
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
comment|/* name already in use? */
return|return
literal|0
return|;
comment|/* leave previous value on top, but return 0 */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lua_newtable
argument_list|(
name|L
argument_list|)
expr_stmt|;
comment|/* create metatable */
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
name|tname
argument_list|)
expr_stmt|;
comment|/* registry.name = metatable */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_setmetatable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|)
block|{
name|luaL_getmetatable
argument_list|(
name|L
argument_list|,
name|tname
argument_list|)
expr_stmt|;
name|lua_setmetatable
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
modifier|*
name|luaL_testudata
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|ud
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|lua_touserdata
argument_list|(
name|L
argument_list|,
name|ud
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* value is a userdata? */
if|if
condition|(
name|lua_getmetatable
argument_list|(
name|L
argument_list|,
name|ud
argument_list|)
condition|)
block|{
comment|/* does it have a metatable? */
name|luaL_getmetatable
argument_list|(
name|L
argument_list|,
name|tname
argument_list|)
expr_stmt|;
comment|/* get correct metatable */
if|if
condition|(
operator|!
name|lua_rawequal
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|2
argument_list|)
condition|)
comment|/* not the same? */
name|p
operator|=
name|NULL
expr_stmt|;
comment|/* value is a userdata with wrong metatable */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* remove both metatables */
return|return
name|p
return|;
block|}
block|}
return|return
name|NULL
return|;
comment|/* value is not a userdata with a metatable */
block|}
end_function

begin_function
name|LUALIB_API
name|void
modifier|*
name|luaL_checkudata
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|ud
parameter_list|,
specifier|const
name|char
modifier|*
name|tname
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|luaL_testudata
argument_list|(
name|L
argument_list|,
name|ud
argument_list|,
name|tname
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|typeerror
argument_list|(
name|L
argument_list|,
name|ud
argument_list|,
name|tname
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Argument check functions ** ======================================================= */
end_comment

begin_function
name|LUALIB_API
name|int
name|luaL_checkoption
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|,
specifier|const
name|char
modifier|*
specifier|const
name|lst
index|[]
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
operator|(
name|def
operator|)
condition|?
name|luaL_optstring
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|def
argument_list|)
else|:
name|luaL_checkstring
argument_list|(
name|L
argument_list|,
name|narg
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|lst
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|lst
index|[
name|i
index|]
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
name|i
return|;
return|return
name|luaL_argerror
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"invalid option "
name|LUA_QS
argument_list|,
name|name
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_checkstack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|space
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
comment|/* keep some extra space to run error routines, if needed */
specifier|const
name|int
name|extra
init|=
name|LUA_MINSTACK
decl_stmt|;
if|if
condition|(
operator|!
name|lua_checkstack
argument_list|(
name|L
argument_list|,
name|space
operator|+
name|extra
argument_list|)
condition|)
block|{
if|if
condition|(
name|msg
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"stack overflow (%s)"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"stack overflow"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_checktype
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
name|int
name|t
parameter_list|)
block|{
if|if
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
name|narg
argument_list|)
operator|!=
name|t
condition|)
name|tag_error
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_checkany
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|)
block|{
if|if
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
name|narg
argument_list|)
operator|==
name|LUA_TNONE
condition|)
name|luaL_argerror
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
literal|"value expected"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
specifier|const
name|char
modifier|*
name|luaL_checklstring
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|s
init|=
name|lua_tolstring
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|len
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|s
condition|)
name|tag_error
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|LUA_TSTRING
argument_list|)
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_function
name|LUALIB_API
specifier|const
name|char
modifier|*
name|luaL_optlstring
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
specifier|const
name|char
modifier|*
name|def
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
name|lua_isnoneornil
argument_list|(
name|L
argument_list|,
name|narg
argument_list|)
condition|)
block|{
if|if
condition|(
name|len
condition|)
operator|*
name|len
operator|=
operator|(
name|def
condition|?
name|strlen
argument_list|(
name|def
argument_list|)
else|:
literal|0
operator|)
expr_stmt|;
return|return
name|def
return|;
block|}
else|else
return|return
name|luaL_checklstring
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|lua_Number
name|luaL_checknumber
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|)
block|{
name|int
name|isnum
decl_stmt|;
name|lua_Number
name|d
init|=
name|lua_tonumberx
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
operator|&
name|isnum
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isnum
condition|)
name|tag_error
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|LUA_TNUMBER
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|lua_Number
name|luaL_optnumber
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
name|lua_Number
name|def
parameter_list|)
block|{
return|return
name|luaL_opt
argument_list|(
name|L
argument_list|,
name|luaL_checknumber
argument_list|,
name|narg
argument_list|,
name|def
argument_list|)
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|lua_Integer
name|luaL_checkinteger
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|)
block|{
name|int
name|isnum
decl_stmt|;
name|lua_Integer
name|d
init|=
name|lua_tointegerx
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
operator|&
name|isnum
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isnum
condition|)
name|tag_error
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|LUA_TNUMBER
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|lua_Unsigned
name|luaL_checkunsigned
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|)
block|{
name|int
name|isnum
decl_stmt|;
name|lua_Unsigned
name|d
init|=
name|lua_tounsignedx
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
operator|&
name|isnum
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|isnum
condition|)
name|tag_error
argument_list|(
name|L
argument_list|,
name|narg
argument_list|,
name|LUA_TNUMBER
argument_list|)
expr_stmt|;
return|return
name|d
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|lua_Integer
name|luaL_optinteger
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
name|lua_Integer
name|def
parameter_list|)
block|{
return|return
name|luaL_opt
argument_list|(
name|L
argument_list|,
name|luaL_checkinteger
argument_list|,
name|narg
argument_list|,
name|def
argument_list|)
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|lua_Unsigned
name|luaL_optunsigned
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|narg
parameter_list|,
name|lua_Unsigned
name|def
parameter_list|)
block|{
return|return
name|luaL_opt
argument_list|(
name|L
argument_list|,
name|luaL_checkunsigned
argument_list|,
name|narg
argument_list|,
name|def
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Generic Buffer manipulation ** ======================================================= */
end_comment

begin_comment
comment|/* ** check whether buffer is using a userdata on the stack as a temporary ** buffer */
end_comment

begin_define
define|#
directive|define
name|buffonstack
parameter_list|(
name|B
parameter_list|)
value|((B)->b != (B)->initb)
end_define

begin_comment
comment|/* ** returns a pointer to a free area with at least 'sz' bytes */
end_comment

begin_function
name|LUALIB_API
name|char
modifier|*
name|luaL_prepbuffsize
parameter_list|(
name|luaL_Buffer
modifier|*
name|B
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|B
operator|->
name|L
decl_stmt|;
if|if
condition|(
name|B
operator|->
name|size
operator|-
name|B
operator|->
name|n
operator|<
name|sz
condition|)
block|{
comment|/* not enough space? */
name|char
modifier|*
name|newbuff
decl_stmt|;
name|size_t
name|newsize
init|=
name|B
operator|->
name|size
operator|*
literal|2
decl_stmt|;
comment|/* double buffer size */
if|if
condition|(
name|newsize
operator|-
name|B
operator|->
name|n
operator|<
name|sz
condition|)
comment|/* not big enough? */
name|newsize
operator|=
name|B
operator|->
name|n
operator|+
name|sz
expr_stmt|;
if|if
condition|(
name|newsize
operator|<
name|B
operator|->
name|n
operator|||
name|newsize
operator|-
name|B
operator|->
name|n
operator|<
name|sz
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"buffer too large"
argument_list|)
expr_stmt|;
comment|/* create larger buffer */
name|newbuff
operator|=
operator|(
name|char
operator|*
operator|)
name|lua_newuserdata
argument_list|(
name|L
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move content to new buffer */
name|memcpy
argument_list|(
name|newbuff
argument_list|,
name|B
operator|->
name|b
argument_list|,
name|B
operator|->
name|n
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffonstack
argument_list|(
name|B
argument_list|)
condition|)
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* remove old buffer */
name|B
operator|->
name|b
operator|=
name|newbuff
expr_stmt|;
name|B
operator|->
name|size
operator|=
name|newsize
expr_stmt|;
block|}
return|return
operator|&
name|B
operator|->
name|b
index|[
name|B
operator|->
name|n
index|]
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_addlstring
parameter_list|(
name|luaL_Buffer
modifier|*
name|B
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|char
modifier|*
name|b
init|=
name|luaL_prepbuffsize
argument_list|(
name|B
argument_list|,
name|l
argument_list|)
decl_stmt|;
name|memcpy
argument_list|(
name|b
argument_list|,
name|s
argument_list|,
name|l
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
name|luaL_addsize
argument_list|(
name|B
argument_list|,
name|l
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_addstring
parameter_list|(
name|luaL_Buffer
modifier|*
name|B
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
name|luaL_addlstring
argument_list|(
name|B
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_pushresult
parameter_list|(
name|luaL_Buffer
modifier|*
name|B
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|B
operator|->
name|L
decl_stmt|;
name|lua_pushlstring
argument_list|(
name|L
argument_list|,
name|B
operator|->
name|b
argument_list|,
name|B
operator|->
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|buffonstack
argument_list|(
name|B
argument_list|)
condition|)
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* remove old buffer */
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_pushresultsize
parameter_list|(
name|luaL_Buffer
modifier|*
name|B
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|luaL_addsize
argument_list|(
name|B
argument_list|,
name|sz
argument_list|)
expr_stmt|;
name|luaL_pushresult
argument_list|(
name|B
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_addvalue
parameter_list|(
name|luaL_Buffer
modifier|*
name|B
parameter_list|)
block|{
name|lua_State
modifier|*
name|L
init|=
name|B
operator|->
name|L
decl_stmt|;
name|size_t
name|l
decl_stmt|;
specifier|const
name|char
modifier|*
name|s
init|=
name|lua_tolstring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|l
argument_list|)
decl_stmt|;
if|if
condition|(
name|buffonstack
argument_list|(
name|B
argument_list|)
condition|)
name|lua_insert
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* put value below buffer */
name|luaL_addlstring
argument_list|(
name|B
argument_list|,
name|s
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|(
name|buffonstack
argument_list|(
name|B
argument_list|)
operator|)
condition|?
operator|-
literal|2
else|:
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* remove value */
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_buffinit
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|luaL_Buffer
modifier|*
name|B
parameter_list|)
block|{
name|B
operator|->
name|L
operator|=
name|L
expr_stmt|;
name|B
operator|->
name|b
operator|=
name|B
operator|->
name|initb
expr_stmt|;
name|B
operator|->
name|n
operator|=
literal|0
expr_stmt|;
name|B
operator|->
name|size
operator|=
name|LUAL_BUFFERSIZE
expr_stmt|;
block|}
end_function

begin_function
name|LUALIB_API
name|char
modifier|*
name|luaL_buffinitsize
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|luaL_Buffer
modifier|*
name|B
parameter_list|,
name|size_t
name|sz
parameter_list|)
block|{
name|luaL_buffinit
argument_list|(
name|L
argument_list|,
name|B
argument_list|)
expr_stmt|;
return|return
name|luaL_prepbuffsize
argument_list|(
name|B
argument_list|,
name|sz
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Reference system ** ======================================================= */
end_comment

begin_comment
comment|/* index of free-list header */
end_comment

begin_define
define|#
directive|define
name|freelist
value|0
end_define

begin_function
name|LUALIB_API
name|int
name|luaL_ref
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|t
parameter_list|)
block|{
name|int
name|ref
decl_stmt|;
if|if
condition|(
name|lua_isnil
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove from stack */
return|return
name|LUA_REFNIL
return|;
comment|/* `nil' has a unique fixed reference */
block|}
name|t
operator|=
name|lua_absindex
argument_list|(
name|L
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|freelist
argument_list|)
expr_stmt|;
comment|/* get first free element */
name|ref
operator|=
operator|(
name|int
operator|)
name|lua_tointeger
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* ref = t[freelist] */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove it from stack */
if|if
condition|(
name|ref
operator|!=
literal|0
condition|)
block|{
comment|/* any free element? */
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|ref
argument_list|)
expr_stmt|;
comment|/* remove it from list */
name|lua_rawseti
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|freelist
argument_list|)
expr_stmt|;
comment|/* (t[freelist] = t[ref]) */
block|}
else|else
comment|/* no free elements */
name|ref
operator|=
operator|(
name|int
operator|)
name|lua_rawlen
argument_list|(
name|L
argument_list|,
name|t
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* get a new reference */
name|lua_rawseti
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|ref
argument_list|)
expr_stmt|;
return|return
name|ref
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_unref
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|t
parameter_list|,
name|int
name|ref
parameter_list|)
block|{
if|if
condition|(
name|ref
operator|>=
literal|0
condition|)
block|{
name|t
operator|=
name|lua_absindex
argument_list|(
name|L
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|lua_rawgeti
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|freelist
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|ref
argument_list|)
expr_stmt|;
comment|/* t[ref] = t[freelist] */
name|lua_pushinteger
argument_list|(
name|L
argument_list|,
name|ref
argument_list|)
expr_stmt|;
name|lua_rawseti
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|freelist
argument_list|)
expr_stmt|;
comment|/* t[freelist] = ref */
block|}
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** {====================================================== ** Load functions ** ======================================================= */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|LoadS
block|{
specifier|const
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|size
decl_stmt|;
block|}
name|LoadS
typedef|;
end_typedef

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getS
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|void
modifier|*
name|ud
parameter_list|,
name|size_t
modifier|*
name|size
parameter_list|)
block|{
name|LoadS
modifier|*
name|ls
init|=
operator|(
name|LoadS
operator|*
operator|)
name|ud
decl_stmt|;
operator|(
name|void
operator|)
name|L
expr_stmt|;
comment|/* not used */
if|if
condition|(
name|ls
operator|->
name|size
operator|==
literal|0
condition|)
return|return
name|NULL
return|;
operator|*
name|size
operator|=
name|ls
operator|->
name|size
expr_stmt|;
name|ls
operator|->
name|size
operator|=
literal|0
expr_stmt|;
return|return
name|ls
operator|->
name|s
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|int
name|luaL_loadbufferx
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|buff
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|LoadS
name|ls
decl_stmt|;
name|ls
operator|.
name|s
operator|=
name|buff
expr_stmt|;
name|ls
operator|.
name|size
operator|=
name|size
expr_stmt|;
return|return
name|lua_load
argument_list|(
name|L
argument_list|,
name|getS
argument_list|,
operator|&
name|ls
argument_list|,
name|name
argument_list|,
name|mode
argument_list|)
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|int
name|luaL_loadstring
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|)
block|{
return|return
name|luaL_loadbuffer
argument_list|(
name|L
argument_list|,
name|s
argument_list|,
name|strlen
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_function
name|LUALIB_API
name|int
name|luaL_getmetafield
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|event
parameter_list|)
block|{
if|if
condition|(
operator|!
name|lua_getmetatable
argument_list|(
name|L
argument_list|,
name|obj
argument_list|)
condition|)
comment|/* no metatable? */
return|return
literal|0
return|;
name|lua_pushstring
argument_list|(
name|L
argument_list|,
name|event
argument_list|)
expr_stmt|;
name|lua_rawget
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lua_isnil
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* remove metatable and metafield */
return|return
literal|0
return|;
block|}
else|else
block|{
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* remove only metatable */
return|return
literal|1
return|;
block|}
block|}
end_function

begin_function
name|LUALIB_API
name|int
name|luaL_callmeta
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|obj
parameter_list|,
specifier|const
name|char
modifier|*
name|event
parameter_list|)
block|{
name|obj
operator|=
name|lua_absindex
argument_list|(
name|L
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|luaL_getmetafield
argument_list|(
name|L
argument_list|,
name|obj
argument_list|,
name|event
argument_list|)
condition|)
comment|/* no metafield? */
return|return
literal|0
return|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
name|obj
argument_list|)
expr_stmt|;
name|lua_call
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|int
name|luaL_len
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|)
block|{
name|int
name|l
decl_stmt|;
name|int
name|isnum
decl_stmt|;
name|lua_len
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|l
operator|=
operator|(
name|int
operator|)
name|lua_tointegerx
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
operator|&
name|isnum
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isnum
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"object length is not a number"
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove object */
return|return
name|l
return|;
block|}
end_function

begin_function
name|LUALIB_API
specifier|const
name|char
modifier|*
name|luaL_tolstring
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|,
name|size_t
modifier|*
name|len
parameter_list|)
block|{
if|if
condition|(
operator|!
name|luaL_callmeta
argument_list|(
name|L
argument_list|,
name|idx
argument_list|,
literal|"__tostring"
argument_list|)
condition|)
block|{
comment|/* no metafield? */
switch|switch
condition|(
name|lua_type
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
condition|)
block|{
case|case
name|LUA_TNUMBER
case|:
case|case
name|LUA_TSTRING
case|:
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TBOOLEAN
case|:
name|lua_pushstring
argument_list|(
name|L
argument_list|,
operator|(
name|lua_toboolean
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
condition|?
literal|"true"
else|:
literal|"false"
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_TNIL
case|:
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"nil"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|lua_pushfstring
argument_list|(
name|L
argument_list|,
literal|"%s: %p"
argument_list|,
name|luaL_typename
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
argument_list|,
name|lua_topointer
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|lua_tolstring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
name|len
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** {====================================================== ** Compatibility with 5.1 module functions ** ======================================================= */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LUA_COMPAT_MODULE
argument_list|)
end_if

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|luaL_findtable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|szhint
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|e
decl_stmt|;
if|if
condition|(
name|idx
condition|)
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
do|do
block|{
name|e
operator|=
name|strchr
argument_list|(
name|fname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|NULL
condition|)
name|e
operator|=
name|fname
operator|+
name|strlen
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|lua_pushlstring
argument_list|(
name|L
argument_list|,
name|fname
argument_list|,
name|e
operator|-
name|fname
argument_list|)
expr_stmt|;
name|lua_rawget
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lua_isnil
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* no such field? */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove this nil */
name|lua_createtable
argument_list|(
name|L
argument_list|,
literal|0
argument_list|,
operator|(
operator|*
name|e
operator|==
literal|'.'
condition|?
literal|1
else|:
name|szhint
operator|)
argument_list|)
expr_stmt|;
comment|/* new table for field */
name|lua_pushlstring
argument_list|(
name|L
argument_list|,
name|fname
argument_list|,
name|e
operator|-
name|fname
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|lua_settable
argument_list|(
name|L
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* set new table into field */
block|}
elseif|else
if|if
condition|(
operator|!
name|lua_istable
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* field has a non-table value? */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* remove table and value */
return|return
name|fname
return|;
comment|/* return problematic part of the name */
block|}
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* remove previous table */
name|fname
operator|=
name|e
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|e
operator|==
literal|'.'
condition|)
do|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/* ** Count number of elements in a luaL_Reg list. */
end_comment

begin_function
specifier|static
name|int
name|libsize
parameter_list|(
specifier|const
name|luaL_Reg
modifier|*
name|l
parameter_list|)
block|{
name|int
name|size
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
name|l
operator|&&
name|l
operator|->
name|name
condition|;
name|l
operator|++
control|)
name|size
operator|++
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* ** Find or create a module table with a given name. The function ** first looks at the _LOADED table and, if that fails, try a ** global variable with that name. In any case, leaves on the stack ** the module table. */
end_comment

begin_function
name|LUALIB_API
name|void
name|luaL_pushmodule
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|modname
parameter_list|,
name|int
name|sizehint
parameter_list|)
block|{
name|luaL_findtable
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
literal|"_LOADED"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* get _LOADED table */
name|lua_getfield
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|,
name|modname
argument_list|)
expr_stmt|;
comment|/* get _LOADED[modname] */
if|if
condition|(
operator|!
name|lua_istable
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* not found? */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove previous result */
comment|/* try global variable (and create one if it does not exist) */
name|lua_pushglobaltable
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|luaL_findtable
argument_list|(
name|L
argument_list|,
literal|0
argument_list|,
name|modname
argument_list|,
name|sizehint
argument_list|)
operator|!=
name|NULL
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"name conflict for module "
name|LUA_QS
argument_list|,
name|modname
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|3
argument_list|,
name|modname
argument_list|)
expr_stmt|;
comment|/* _LOADED[modname] = new table */
block|}
name|lua_remove
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* remove _LOADED table */
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_openlib
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|libname
parameter_list|,
specifier|const
name|luaL_Reg
modifier|*
name|l
parameter_list|,
name|int
name|nup
parameter_list|)
block|{
name|luaL_checkversion
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|libname
condition|)
block|{
name|luaL_pushmodule
argument_list|(
name|L
argument_list|,
name|libname
argument_list|,
name|libsize
argument_list|(
name|l
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get/create library table */
name|lua_insert
argument_list|(
name|L
argument_list|,
operator|-
operator|(
name|nup
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
comment|/* move library table to below upvalues */
block|}
if|if
condition|(
name|l
condition|)
name|luaL_setfuncs
argument_list|(
name|L
argument_list|,
name|l
argument_list|,
name|nup
argument_list|)
expr_stmt|;
else|else
name|lua_pop
argument_list|(
name|L
argument_list|,
name|nup
argument_list|)
expr_stmt|;
comment|/* remove upvalues */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** set functions from list 'l' into table at top - 'nup'; each ** function gets the 'nup' elements at the top as upvalues. ** Returns with only the table at the stack. */
end_comment

begin_function
name|LUALIB_API
name|void
name|luaL_setfuncs
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|luaL_Reg
modifier|*
name|l
parameter_list|,
name|int
name|nup
parameter_list|)
block|{
name|luaL_checkversion
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|luaL_checkstack
argument_list|(
name|L
argument_list|,
name|nup
argument_list|,
literal|"too many upvalues"
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|l
operator|->
name|name
operator|!=
name|NULL
condition|;
name|l
operator|++
control|)
block|{
comment|/* fill the table with given functions */
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nup
condition|;
name|i
operator|++
control|)
comment|/* copy upvalues to the top */
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
name|nup
argument_list|)
expr_stmt|;
name|lua_pushcclosure
argument_list|(
name|L
argument_list|,
name|l
operator|->
name|func
argument_list|,
name|nup
argument_list|)
expr_stmt|;
comment|/* closure with those upvalues */
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
operator|(
name|nup
operator|+
literal|2
operator|)
argument_list|,
name|l
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
name|lua_pop
argument_list|(
name|L
argument_list|,
name|nup
argument_list|)
expr_stmt|;
comment|/* remove upvalues */
block|}
end_function

begin_comment
comment|/* ** ensure that stack[idx][fname] has a table and push that table ** into the stack */
end_comment

begin_function
name|LUALIB_API
name|int
name|luaL_getsubtable
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|idx
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|lua_getfield
argument_list|(
name|L
argument_list|,
name|idx
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|lua_istable
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
comment|/* table already there */
else|else
block|{
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove previous result */
name|idx
operator|=
name|lua_absindex
argument_list|(
name|L
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|lua_newtable
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* copy to be left at top */
name|lua_setfield
argument_list|(
name|L
argument_list|,
name|idx
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* assign new table to field */
return|return
literal|0
return|;
comment|/* false, because did not find table there */
block|}
block|}
end_function

begin_comment
comment|/* ** stripped-down 'require'. Calls 'openf' to open a module, ** registers the result in 'package.loaded' table and, if 'glb' ** is true, also registers the result in the global table. ** Leaves resulting module on the top. */
end_comment

begin_function
name|LUALIB_API
name|void
name|luaL_requiref
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|modname
parameter_list|,
name|lua_CFunction
name|openf
parameter_list|,
name|int
name|glb
parameter_list|)
block|{
name|lua_pushcfunction
argument_list|(
name|L
argument_list|,
name|openf
argument_list|)
expr_stmt|;
name|lua_pushstring
argument_list|(
name|L
argument_list|,
name|modname
argument_list|)
expr_stmt|;
comment|/* argument to open function */
name|lua_call
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* open module */
name|luaL_getsubtable
argument_list|(
name|L
argument_list|,
name|LUA_REGISTRYINDEX
argument_list|,
literal|"_LOADED"
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* make copy of module (call result) */
name|lua_setfield
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|,
name|modname
argument_list|)
expr_stmt|;
comment|/* _LOADED[modname] = module */
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* remove _LOADED table */
if|if
condition|(
name|glb
condition|)
block|{
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* copy of 'mod' */
name|lua_setglobal
argument_list|(
name|L
argument_list|,
name|modname
argument_list|)
expr_stmt|;
comment|/* _G[modname] = module */
block|}
block|}
end_function

begin_function
name|LUALIB_API
specifier|const
name|char
modifier|*
name|luaL_gsub
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|p
parameter_list|,
specifier|const
name|char
modifier|*
name|r
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|wild
decl_stmt|;
name|size_t
name|l
init|=
name|strlen
argument_list|(
name|p
argument_list|)
decl_stmt|;
name|luaL_Buffer
name|b
decl_stmt|;
name|luaL_buffinit
argument_list|(
name|L
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|wild
operator|=
name|strstr
argument_list|(
name|s
argument_list|,
name|p
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|luaL_addlstring
argument_list|(
operator|&
name|b
argument_list|,
name|s
argument_list|,
name|wild
operator|-
name|s
argument_list|)
expr_stmt|;
comment|/* push prefix */
name|luaL_addstring
argument_list|(
operator|&
name|b
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* push replacement in place of pattern */
name|s
operator|=
name|wild
operator|+
name|l
expr_stmt|;
comment|/* continue after `p' */
block|}
name|luaL_addstring
argument_list|(
operator|&
name|b
argument_list|,
name|s
argument_list|)
expr_stmt|;
comment|/* push last suffix */
name|luaL_pushresult
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
return|return
name|lua_tostring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
return|;
block|}
end_function

begin_function
name|LUALIB_API
name|void
name|luaL_checkversion_
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_Number
name|ver
parameter_list|)
block|{
specifier|const
name|lua_Number
modifier|*
name|v
init|=
name|lua_version
argument_list|(
name|L
argument_list|)
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|lua_version
argument_list|(
name|NULL
argument_list|)
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"multiple Lua VMs detected"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|v
operator|!=
name|ver
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"version mismatch: app. needs %f, Lua core provides %f"
argument_list|,
name|ver
argument_list|,
operator|*
name|v
argument_list|)
expr_stmt|;
comment|/* check conversions number -> integer types */
name|lua_pushnumber
argument_list|(
name|L
argument_list|,
operator|-
operator|(
name|lua_Number
operator|)
literal|0x1234
argument_list|)
expr_stmt|;
if|if
condition|(
name|lua_tointeger
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
operator|-
literal|0x1234
operator|||
name|lua_tounsigned
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
operator|!=
operator|(
name|lua_Unsigned
operator|)
operator|-
literal|0x1234
condition|)
name|luaL_error
argument_list|(
name|L
argument_list|,
literal|"bad conversion number->int;"
literal|" must recompile Lua with proper settings"
argument_list|)
expr_stmt|;
name|lua_pop
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

