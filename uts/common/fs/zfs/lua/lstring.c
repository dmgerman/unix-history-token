begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lstring.c,v 2.26.1.1 2013/04/12 18:48:47 roberto Exp $ ** String table (keeps all strings handled by Lua) ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lstring_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_comment
comment|/* ** Lua will use at most ~(2^LUAI_HASHLIMIT) bytes from a string to ** compute its hash */
end_comment

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|LUAI_HASHLIMIT
argument_list|)
end_if

begin_define
define|#
directive|define
name|LUAI_HASHLIMIT
value|5
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ** equality for long strings */
end_comment

begin_function
name|int
name|luaS_eqlngstr
parameter_list|(
name|TString
modifier|*
name|a
parameter_list|,
name|TString
modifier|*
name|b
parameter_list|)
block|{
name|size_t
name|len
init|=
name|a
operator|->
name|tsv
operator|.
name|len
decl_stmt|;
name|lua_assert
argument_list|(
name|a
operator|->
name|tsv
operator|.
name|tt
operator|==
name|LUA_TLNGSTR
operator|&&
name|b
operator|->
name|tsv
operator|.
name|tt
operator|==
name|LUA_TLNGSTR
argument_list|)
expr_stmt|;
return|return
operator|(
name|a
operator|==
name|b
operator|)
operator|||
comment|/* same instance or... */
operator|(
operator|(
name|len
operator|==
name|b
operator|->
name|tsv
operator|.
name|len
operator|)
operator|&&
comment|/* equal length and ... */
operator|(
name|memcmp
argument_list|(
name|getstr
argument_list|(
name|a
argument_list|)
argument_list|,
name|getstr
argument_list|(
name|b
argument_list|)
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|)
operator|)
return|;
comment|/* equal contents */
block|}
end_function

begin_comment
comment|/* ** equality for strings */
end_comment

begin_function
name|int
name|luaS_eqstr
parameter_list|(
name|TString
modifier|*
name|a
parameter_list|,
name|TString
modifier|*
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|->
name|tsv
operator|.
name|tt
operator|==
name|b
operator|->
name|tsv
operator|.
name|tt
operator|)
operator|&&
operator|(
name|a
operator|->
name|tsv
operator|.
name|tt
operator|==
name|LUA_TSHRSTR
condition|?
name|eqshrstr
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
else|:
name|luaS_eqlngstr
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|unsigned
name|int
name|luaS_hash
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|l
parameter_list|,
name|unsigned
name|int
name|seed
parameter_list|)
block|{
name|unsigned
name|int
name|h
init|=
name|seed
operator|^
name|cast
argument_list|(
argument|unsigned int
argument_list|,
argument|l
argument_list|)
decl_stmt|;
name|size_t
name|l1
decl_stmt|;
name|size_t
name|step
init|=
operator|(
name|l
operator|>>
name|LUAI_HASHLIMIT
operator|)
operator|+
literal|1
decl_stmt|;
for|for
control|(
name|l1
operator|=
name|l
init|;
name|l1
operator|>=
name|step
condition|;
name|l1
operator|-=
name|step
control|)
name|h
operator|=
name|h
operator|^
operator|(
operator|(
name|h
operator|<<
literal|5
operator|)
operator|+
operator|(
name|h
operator|>>
literal|2
operator|)
operator|+
name|cast_byte
argument_list|(
name|str
index|[
name|l1
operator|-
literal|1
index|]
argument_list|)
operator|)
expr_stmt|;
return|return
name|h
return|;
block|}
end_function

begin_comment
comment|/* ** resizes the string table */
end_comment

begin_function
name|void
name|luaS_resize
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|newsize
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|stringtable
modifier|*
name|tb
init|=
operator|&
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|strt
decl_stmt|;
comment|/* cannot resize while GC is traversing strings */
name|luaC_runtilstate
argument_list|(
name|L
argument_list|,
operator|~
name|bitmask
argument_list|(
name|GCSsweepstring
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsize
operator|>
name|tb
operator|->
name|size
condition|)
block|{
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|tb
operator|->
name|hash
argument_list|,
name|tb
operator|->
name|size
argument_list|,
name|newsize
argument_list|,
name|GCObject
operator|*
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|tb
operator|->
name|size
init|;
name|i
operator|<
name|newsize
condition|;
name|i
operator|++
control|)
name|tb
operator|->
name|hash
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* rehash */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|tb
operator|->
name|size
condition|;
name|i
operator|++
control|)
block|{
name|GCObject
modifier|*
name|p
init|=
name|tb
operator|->
name|hash
index|[
name|i
index|]
decl_stmt|;
name|tb
operator|->
name|hash
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|p
condition|)
block|{
comment|/* for each node in the list */
name|GCObject
modifier|*
name|next
init|=
name|gch
argument_list|(
name|p
argument_list|)
operator|->
name|next
decl_stmt|;
comment|/* save next */
name|unsigned
name|int
name|h
init|=
name|lmod
argument_list|(
name|gco2ts
argument_list|(
name|p
argument_list|)
operator|->
name|hash
argument_list|,
name|newsize
argument_list|)
decl_stmt|;
comment|/* new position */
name|gch
argument_list|(
name|p
argument_list|)
operator|->
name|next
operator|=
name|tb
operator|->
name|hash
index|[
name|h
index|]
expr_stmt|;
comment|/* chain it */
name|tb
operator|->
name|hash
index|[
name|h
index|]
operator|=
name|p
expr_stmt|;
name|resetoldbit
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* see MOVE OLD rule */
name|p
operator|=
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|newsize
operator|<
name|tb
operator|->
name|size
condition|)
block|{
comment|/* shrinking slice must be empty */
name|lua_assert
argument_list|(
name|tb
operator|->
name|hash
index|[
name|newsize
index|]
operator|==
name|NULL
operator|&&
name|tb
operator|->
name|hash
index|[
name|tb
operator|->
name|size
operator|-
literal|1
index|]
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|tb
operator|->
name|hash
argument_list|,
name|tb
operator|->
name|size
argument_list|,
name|newsize
argument_list|,
name|GCObject
operator|*
argument_list|)
expr_stmt|;
block|}
name|tb
operator|->
name|size
operator|=
name|newsize
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** creates a new string object */
end_comment

begin_function
specifier|static
name|TString
modifier|*
name|createstrobj
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|l
parameter_list|,
name|int
name|tag
parameter_list|,
name|unsigned
name|int
name|h
parameter_list|,
name|GCObject
modifier|*
modifier|*
name|list
parameter_list|)
block|{
name|TString
modifier|*
name|ts
decl_stmt|;
name|size_t
name|totalsize
decl_stmt|;
comment|/* total size of TString object */
name|totalsize
operator|=
sizeof|sizeof
argument_list|(
name|TString
argument_list|)
operator|+
operator|(
operator|(
name|l
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
expr_stmt|;
name|ts
operator|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|tag
argument_list|,
name|totalsize
argument_list|,
name|list
argument_list|,
literal|0
argument_list|)
operator|->
name|ts
expr_stmt|;
name|ts
operator|->
name|tsv
operator|.
name|len
operator|=
name|l
expr_stmt|;
name|ts
operator|->
name|tsv
operator|.
name|hash
operator|=
name|h
expr_stmt|;
name|ts
operator|->
name|tsv
operator|.
name|extra
operator|=
literal|0
expr_stmt|;
name|memcpy
argument_list|(
name|ts
operator|+
literal|1
argument_list|,
name|str
argument_list|,
name|l
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|ts
operator|+
literal|1
operator|)
operator|)
index|[
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* ending 0 */
return|return
name|ts
return|;
block|}
end_function

begin_comment
comment|/* ** creates a new short string, inserting it into string table */
end_comment

begin_function
specifier|static
name|TString
modifier|*
name|newshrstr
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|l
parameter_list|,
name|unsigned
name|int
name|h
parameter_list|)
block|{
name|GCObject
modifier|*
modifier|*
name|list
decl_stmt|;
comment|/* (pointer to) list where it will be inserted */
name|stringtable
modifier|*
name|tb
init|=
operator|&
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|strt
decl_stmt|;
name|TString
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|tb
operator|->
name|nuse
operator|>=
name|cast
argument_list|(
name|lu_int32
argument_list|,
name|tb
operator|->
name|size
argument_list|)
operator|&&
name|tb
operator|->
name|size
operator|<=
name|MAX_INT
operator|/
literal|2
condition|)
name|luaS_resize
argument_list|(
name|L
argument_list|,
name|tb
operator|->
name|size
operator|*
literal|2
argument_list|)
expr_stmt|;
comment|/* too crowded */
name|list
operator|=
operator|&
name|tb
operator|->
name|hash
index|[
name|lmod
argument_list|(
name|h
argument_list|,
name|tb
operator|->
name|size
argument_list|)
index|]
expr_stmt|;
name|s
operator|=
name|createstrobj
argument_list|(
name|L
argument_list|,
name|str
argument_list|,
name|l
argument_list|,
name|LUA_TSHRSTR
argument_list|,
name|h
argument_list|,
name|list
argument_list|)
expr_stmt|;
name|tb
operator|->
name|nuse
operator|++
expr_stmt|;
return|return
name|s
return|;
block|}
end_function

begin_comment
comment|/* ** checks whether short string exists and reuses it or creates a new one */
end_comment

begin_function
specifier|static
name|TString
modifier|*
name|internshrstr
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
name|GCObject
modifier|*
name|o
decl_stmt|;
name|global_State
modifier|*
name|g
init|=
name|G
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|unsigned
name|int
name|h
init|=
name|luaS_hash
argument_list|(
name|str
argument_list|,
name|l
argument_list|,
name|g
operator|->
name|seed
argument_list|)
decl_stmt|;
for|for
control|(
name|o
operator|=
name|g
operator|->
name|strt
operator|.
name|hash
index|[
name|lmod
argument_list|(
name|h
argument_list|,
name|g
operator|->
name|strt
operator|.
name|size
argument_list|)
index|]
init|;
name|o
operator|!=
name|NULL
condition|;
name|o
operator|=
name|gch
argument_list|(
name|o
argument_list|)
operator|->
name|next
control|)
block|{
name|TString
modifier|*
name|ts
init|=
name|rawgco2ts
argument_list|(
name|o
argument_list|)
decl_stmt|;
if|if
condition|(
name|h
operator|==
name|ts
operator|->
name|tsv
operator|.
name|hash
operator|&&
name|l
operator|==
name|ts
operator|->
name|tsv
operator|.
name|len
operator|&&
operator|(
name|memcmp
argument_list|(
name|str
argument_list|,
name|getstr
argument_list|(
name|ts
argument_list|)
argument_list|,
name|l
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
name|isdead
argument_list|(
name|G
argument_list|(
name|L
argument_list|)
argument_list|,
name|o
argument_list|)
condition|)
comment|/* string is dead (but was not collected yet)? */
name|changewhite
argument_list|(
name|o
argument_list|)
expr_stmt|;
comment|/* resurrect it */
return|return
name|ts
return|;
block|}
block|}
return|return
name|newshrstr
argument_list|(
name|L
argument_list|,
name|str
argument_list|,
name|l
argument_list|,
name|h
argument_list|)
return|;
comment|/* not found; create a new string */
block|}
end_function

begin_comment
comment|/* ** new string (with explicit length) */
end_comment

begin_function
name|TString
modifier|*
name|luaS_newlstr
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|l
parameter_list|)
block|{
if|if
condition|(
name|l
operator|<=
name|LUAI_MAXSHORTLEN
condition|)
comment|/* short string? */
return|return
name|internshrstr
argument_list|(
name|L
argument_list|,
name|str
argument_list|,
name|l
argument_list|)
return|;
else|else
block|{
if|if
condition|(
name|l
operator|+
literal|1
operator|>
operator|(
name|MAX_SIZET
operator|-
sizeof|sizeof
argument_list|(
name|TString
argument_list|)
operator|)
operator|/
sizeof|sizeof
argument_list|(
name|char
argument_list|)
condition|)
name|luaM_toobig
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|createstrobj
argument_list|(
name|L
argument_list|,
name|str
argument_list|,
name|l
argument_list|,
name|LUA_TLNGSTR
argument_list|,
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|seed
argument_list|,
name|NULL
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ** new zero-terminated string */
end_comment

begin_function
name|TString
modifier|*
name|luaS_new
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
return|return
name|luaS_newlstr
argument_list|(
name|L
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
name|Udata
modifier|*
name|luaS_newudata
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|size_t
name|s
parameter_list|,
name|Table
modifier|*
name|e
parameter_list|)
block|{
name|Udata
modifier|*
name|u
decl_stmt|;
if|if
condition|(
name|s
operator|>
name|MAX_SIZET
operator|-
sizeof|sizeof
argument_list|(
name|Udata
argument_list|)
condition|)
name|luaM_toobig
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|u
operator|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TUSERDATA
argument_list|,
sizeof|sizeof
argument_list|(
name|Udata
argument_list|)
operator|+
name|s
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|->
name|u
expr_stmt|;
name|u
operator|->
name|uv
operator|.
name|len
operator|=
name|s
expr_stmt|;
name|u
operator|->
name|uv
operator|.
name|metatable
operator|=
name|NULL
expr_stmt|;
name|u
operator|->
name|uv
operator|.
name|env
operator|=
name|e
expr_stmt|;
return|return
name|u
return|;
block|}
end_function

end_unit

