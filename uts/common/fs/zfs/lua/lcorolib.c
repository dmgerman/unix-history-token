begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: lcorolib.c,v 1.5.1.1 2013/04/12 18:48:47 roberto Exp $ ** Coroutine Library ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|lcorolib_c
end_define

begin_define
define|#
directive|define
name|LUA_LIB
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lauxlib.h"
end_include

begin_include
include|#
directive|include
file|"lualib.h"
end_include

begin_function
specifier|static
name|int
name|auxresume
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_State
modifier|*
name|co
parameter_list|,
name|int
name|narg
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
if|if
condition|(
operator|!
name|lua_checkstack
argument_list|(
name|co
argument_list|,
name|narg
argument_list|)
condition|)
block|{
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"too many arguments to resume"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* error flag */
block|}
if|if
condition|(
name|lua_status
argument_list|(
name|co
argument_list|)
operator|==
name|LUA_OK
operator|&&
name|lua_gettop
argument_list|(
name|co
argument_list|)
operator|==
literal|0
condition|)
block|{
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"cannot resume dead coroutine"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* error flag */
block|}
name|lua_xmove
argument_list|(
name|L
argument_list|,
name|co
argument_list|,
name|narg
argument_list|)
expr_stmt|;
name|status
operator|=
name|lua_resume
argument_list|(
name|co
argument_list|,
name|L
argument_list|,
name|narg
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
name|LUA_OK
operator|||
name|status
operator|==
name|LUA_YIELD
condition|)
block|{
name|int
name|nres
init|=
name|lua_gettop
argument_list|(
name|co
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|lua_checkstack
argument_list|(
name|L
argument_list|,
name|nres
operator|+
literal|1
argument_list|)
condition|)
block|{
name|lua_pop
argument_list|(
name|co
argument_list|,
name|nres
argument_list|)
expr_stmt|;
comment|/* remove results anyway */
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"too many results to resume"
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
comment|/* error flag */
block|}
name|lua_xmove
argument_list|(
name|co
argument_list|,
name|L
argument_list|,
name|nres
argument_list|)
expr_stmt|;
comment|/* move yielded values */
return|return
name|nres
return|;
block|}
else|else
block|{
name|lua_xmove
argument_list|(
name|co
argument_list|,
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* move error message */
return|return
operator|-
literal|1
return|;
comment|/* error flag */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|luaB_coresume
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_State
modifier|*
name|co
init|=
name|lua_tothread
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|int
name|r
decl_stmt|;
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
name|co
argument_list|,
literal|1
argument_list|,
literal|"coroutine expected"
argument_list|)
expr_stmt|;
name|r
operator|=
name|auxresume
argument_list|(
name|L
argument_list|,
name|co
argument_list|,
name|lua_gettop
argument_list|(
name|L
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lua_insert
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
comment|/* return false + error message */
block|}
else|else
block|{
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lua_insert
argument_list|(
name|L
argument_list|,
operator|-
operator|(
name|r
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
return|return
name|r
operator|+
literal|1
return|;
comment|/* return true + `resume' returns */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|luaB_auxwrap
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_State
modifier|*
name|co
init|=
name|lua_tothread
argument_list|(
name|L
argument_list|,
name|lua_upvalueindex
argument_list|(
literal|1
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|r
init|=
name|auxresume
argument_list|(
name|L
argument_list|,
name|co
argument_list|,
name|lua_gettop
argument_list|(
name|L
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|r
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|lua_isstring
argument_list|(
name|L
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
block|{
comment|/* error object is a string? */
name|luaL_where
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* add extra info */
name|lua_insert
argument_list|(
name|L
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
name|lua_concat
argument_list|(
name|L
argument_list|,
literal|2
argument_list|)
expr_stmt|;
block|}
return|return
name|lua_error
argument_list|(
name|L
argument_list|)
return|;
comment|/* propagate error */
block|}
return|return
name|r
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|luaB_cocreate
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_State
modifier|*
name|NL
decl_stmt|;
name|luaL_checktype
argument_list|(
name|L
argument_list|,
literal|1
argument_list|,
name|LUA_TFUNCTION
argument_list|)
expr_stmt|;
name|NL
operator|=
name|lua_newthread
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_pushvalue
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* move function to top */
name|lua_xmove
argument_list|(
name|L
argument_list|,
name|NL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* move function from L to NL */
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|luaB_cowrap
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaB_cocreate
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_pushcclosure
argument_list|(
name|L
argument_list|,
name|luaB_auxwrap
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|luaB_yield
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
return|return
name|lua_yield
argument_list|(
name|L
argument_list|,
name|lua_gettop
argument_list|(
name|L
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|luaB_costatus
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|lua_State
modifier|*
name|co
init|=
name|lua_tothread
argument_list|(
name|L
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|luaL_argcheck
argument_list|(
name|L
argument_list|,
name|co
argument_list|,
literal|1
argument_list|,
literal|"coroutine expected"
argument_list|)
expr_stmt|;
if|if
condition|(
name|L
operator|==
name|co
condition|)
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"running"
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|lua_status
argument_list|(
name|co
argument_list|)
condition|)
block|{
case|case
name|LUA_YIELD
case|:
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"suspended"
argument_list|)
expr_stmt|;
break|break;
case|case
name|LUA_OK
case|:
block|{
name|lua_Debug
name|ar
decl_stmt|;
if|if
condition|(
name|lua_getstack
argument_list|(
name|co
argument_list|,
literal|0
argument_list|,
operator|&
name|ar
argument_list|)
operator|>
literal|0
condition|)
comment|/* does it have frames? */
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"normal"
argument_list|)
expr_stmt|;
comment|/* it is running */
elseif|else
if|if
condition|(
name|lua_gettop
argument_list|(
name|co
argument_list|)
operator|==
literal|0
condition|)
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"dead"
argument_list|)
expr_stmt|;
else|else
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"suspended"
argument_list|)
expr_stmt|;
comment|/* initial state */
break|break;
block|}
default|default:
comment|/* some error occurred */
name|lua_pushliteral
argument_list|(
name|L
argument_list|,
literal|"dead"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|luaB_corunning
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|int
name|ismain
init|=
name|lua_pushthread
argument_list|(
name|L
argument_list|)
decl_stmt|;
name|lua_pushboolean
argument_list|(
name|L
argument_list|,
name|ismain
argument_list|)
expr_stmt|;
return|return
literal|2
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|luaL_Reg
name|co_funcs
index|[]
init|=
block|{
block|{
literal|"create"
block|,
name|luaB_cocreate
block|}
block|,
block|{
literal|"resume"
block|,
name|luaB_coresume
block|}
block|,
block|{
literal|"running"
block|,
name|luaB_corunning
block|}
block|,
block|{
literal|"status"
block|,
name|luaB_costatus
block|}
block|,
block|{
literal|"wrap"
block|,
name|luaB_cowrap
block|}
block|,
block|{
literal|"yield"
block|,
name|luaB_yield
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|LUAMOD_API
name|int
name|luaopen_coroutine
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|luaL_newlib
argument_list|(
name|L
argument_list|,
name|co_funcs
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

end_unit

