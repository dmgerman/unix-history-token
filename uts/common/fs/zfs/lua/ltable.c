begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: ltable.c,v 2.72.1.1 2013/04/12 18:48:47 roberto Exp $ ** Lua tables (hash) ** See Copyright Notice in lua.h */
end_comment

begin_comment
comment|/* ** Implementation of tables (aka arrays, objects, or hash tables). ** Tables keep its elements in two parts: an array part and a hash part. ** Non-negative integer keys are all candidates to be kept in the array ** part. The actual size of the array is the largest `n' such that at ** least half the slots between 0 and n are in use. ** Hash uses a mix of chained scatter table with Brent's variation. ** A main invariant of these tables is that, if an element is not ** in its main position (i.e. the `original' position that its hash gives ** to it), then the colliding element is in its own main position. ** Hence even when the load factor reaches 100%, performance remains good. */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|ltable_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lgc.h"
end_include

begin_include
include|#
directive|include
file|"lmem.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_include
include|#
directive|include
file|"lvm.h"
end_include

begin_comment
comment|/* ** max size of array part is 2^MAXBITS */
end_comment

begin_if
if|#
directive|if
name|LUAI_BITSINT
operator|>=
literal|32
end_if

begin_define
define|#
directive|define
name|MAXBITS
value|30
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|MAXBITS
value|(LUAI_BITSINT-2)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXASIZE
value|(1<< MAXBITS)
end_define

begin_define
define|#
directive|define
name|hashpow2
parameter_list|(
name|t
parameter_list|,
name|n
parameter_list|)
value|(gnode(t, lmod((n), sizenode(t))))
end_define

begin_define
define|#
directive|define
name|hashstr
parameter_list|(
name|t
parameter_list|,
name|str
parameter_list|)
value|hashpow2(t, (str)->tsv.hash)
end_define

begin_define
define|#
directive|define
name|hashboolean
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|hashpow2(t, p)
end_define

begin_comment
comment|/* ** for some types, it is better to avoid modulus by power of 2, as ** they tend to have many 2 factors. */
end_comment

begin_define
define|#
directive|define
name|hashmod
parameter_list|(
name|t
parameter_list|,
name|n
parameter_list|)
value|(gnode(t, ((n) % ((sizenode(t)-1)|1))))
end_define

begin_define
define|#
directive|define
name|hashpointer
parameter_list|(
name|t
parameter_list|,
name|p
parameter_list|)
value|hashmod(t, IntPoint(p))
end_define

begin_define
define|#
directive|define
name|dummynode
value|(&dummynode_)
end_define

begin_define
define|#
directive|define
name|isdummy
parameter_list|(
name|n
parameter_list|)
value|((n) == dummynode)
end_define

begin_decl_stmt
specifier|static
specifier|const
name|Node
name|dummynode_
init|=
block|{
block|{
name|NILCONSTANT
block|}
block|,
comment|/* value */
block|{
block|{
name|NILCONSTANT
block|,
name|NULL
block|}
block|}
comment|/* key */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ** hash for lua_Numbers */
end_comment

begin_function
specifier|static
name|Node
modifier|*
name|hashnum
parameter_list|(
specifier|const
name|Table
modifier|*
name|t
parameter_list|,
name|lua_Number
name|n
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|luai_hashnum
argument_list|(
name|i
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|cast
argument_list|(
argument|unsigned int
argument_list|,
argument|i
argument_list|)
operator|==
literal|0u
operator|-
name|i
condition|)
comment|/* use unsigned to avoid overflows */
name|i
operator|=
literal|0
expr_stmt|;
comment|/* handle INT_MIN */
name|i
operator|=
operator|-
name|i
expr_stmt|;
comment|/* must be a positive value */
block|}
return|return
name|hashmod
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** returns the `main' position of an element in a table (that is, the index ** of its hash value) */
end_comment

begin_function
specifier|static
name|Node
modifier|*
name|mainposition
parameter_list|(
specifier|const
name|Table
modifier|*
name|t
parameter_list|,
specifier|const
name|TValue
modifier|*
name|key
parameter_list|)
block|{
switch|switch
condition|(
name|ttype
argument_list|(
name|key
argument_list|)
condition|)
block|{
case|case
name|LUA_TNUMBER
case|:
return|return
name|hashnum
argument_list|(
name|t
argument_list|,
name|nvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TLNGSTR
case|:
block|{
name|TString
modifier|*
name|s
init|=
name|rawtsvalue
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|->
name|tsv
operator|.
name|extra
operator|==
literal|0
condition|)
block|{
comment|/* no hash? */
name|s
operator|->
name|tsv
operator|.
name|hash
operator|=
name|luaS_hash
argument_list|(
name|getstr
argument_list|(
name|s
argument_list|)
argument_list|,
name|s
operator|->
name|tsv
operator|.
name|len
argument_list|,
name|s
operator|->
name|tsv
operator|.
name|hash
argument_list|)
expr_stmt|;
name|s
operator|->
name|tsv
operator|.
name|extra
operator|=
literal|1
expr_stmt|;
comment|/* now it has its hash */
block|}
return|return
name|hashstr
argument_list|(
name|t
argument_list|,
name|rawtsvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
case|case
name|LUA_TSHRSTR
case|:
return|return
name|hashstr
argument_list|(
name|t
argument_list|,
name|rawtsvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TBOOLEAN
case|:
return|return
name|hashboolean
argument_list|(
name|t
argument_list|,
name|bvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TLIGHTUSERDATA
case|:
return|return
name|hashpointer
argument_list|(
name|t
argument_list|,
name|pvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TLCF
case|:
return|return
name|hashpointer
argument_list|(
name|t
argument_list|,
name|fvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
default|default:
return|return
name|hashpointer
argument_list|(
name|t
argument_list|,
name|gcvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* ** returns the index for `key' if `key' is an appropriate key to live in ** the array part of the table, -1 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|arrayindex
parameter_list|(
specifier|const
name|TValue
modifier|*
name|key
parameter_list|)
block|{
if|if
condition|(
name|ttisnumber
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|lua_Number
name|n
init|=
name|nvalue
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|int
name|k
decl_stmt|;
name|lua_number2int
argument_list|(
name|k
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|luai_numeq
argument_list|(
name|cast_num
argument_list|(
name|k
argument_list|)
argument_list|,
name|n
argument_list|)
condition|)
return|return
name|k
return|;
block|}
return|return
operator|-
literal|1
return|;
comment|/* `key' did not match some condition */
block|}
end_function

begin_comment
comment|/* ** returns the index of a `key' for table traversals. First goes all ** elements in the array part, then elements in the hash part. The ** beginning of a traversal is signaled by -1. */
end_comment

begin_function
specifier|static
name|int
name|findindex
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
name|StkId
name|key
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|key
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* first iteration */
name|i
operator|=
name|arrayindex
argument_list|(
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
literal|0
operator|<
name|i
operator|&&
name|i
operator|<=
name|t
operator|->
name|sizearray
condition|)
comment|/* is `key' inside array part? */
return|return
name|i
operator|-
literal|1
return|;
comment|/* yes; that's the index (corrected to C) */
else|else
block|{
name|Node
modifier|*
name|n
init|=
name|mainposition
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* check whether `key' is somewhere in the chain */
comment|/* key may be dead already, but it is ok to use it in `next' */
if|if
condition|(
name|luaV_rawequalobj
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|,
name|key
argument_list|)
operator|||
operator|(
name|ttisdeadkey
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
operator|&&
name|iscollectable
argument_list|(
name|key
argument_list|)
operator|&&
name|deadvalue
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
operator|==
name|gcvalue
argument_list|(
name|key
argument_list|)
operator|)
condition|)
block|{
name|i
operator|=
name|cast_int
argument_list|(
name|n
operator|-
name|gnode
argument_list|(
name|t
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* key index in hash table */
comment|/* hash elements are numbered after array ones */
return|return
name|i
operator|+
name|t
operator|->
name|sizearray
return|;
block|}
else|else
name|n
operator|=
name|gnext
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"invalid key to "
name|LUA_QL
argument_list|(
literal|"next"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* key not found */
block|}
block|}
block|}
end_function

begin_function
name|int
name|luaH_next
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
name|StkId
name|key
parameter_list|)
block|{
name|int
name|i
init|=
name|findindex
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|key
argument_list|)
decl_stmt|;
comment|/* find original element */
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<
name|t
operator|->
name|sizearray
condition|;
name|i
operator|++
control|)
block|{
comment|/* try first array part */
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
operator|&
name|t
operator|->
name|array
index|[
name|i
index|]
argument_list|)
condition|)
block|{
comment|/* a non-nil value? */
name|setnvalue
argument_list|(
name|key
argument_list|,
name|cast_num
argument_list|(
name|i
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|setobj2s
argument_list|(
name|L
argument_list|,
name|key
operator|+
literal|1
argument_list|,
operator|&
name|t
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
for|for
control|(
name|i
operator|-=
name|t
operator|->
name|sizearray
init|;
name|i
operator|<
name|sizenode
argument_list|(
name|t
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
comment|/* then hash part */
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|gnode
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
condition|)
block|{
comment|/* a non-nil value? */
name|setobj2s
argument_list|(
name|L
argument_list|,
name|key
argument_list|,
name|gkey
argument_list|(
name|gnode
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|setobj2s
argument_list|(
name|L
argument_list|,
name|key
operator|+
literal|1
argument_list|,
name|gval
argument_list|(
name|gnode
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
comment|/* no more elements */
block|}
end_function

begin_comment
comment|/* ** {============================================================= ** Rehash ** ============================================================== */
end_comment

begin_function
specifier|static
name|int
name|computesizes
parameter_list|(
name|int
name|nums
index|[]
parameter_list|,
name|int
modifier|*
name|narray
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|twotoi
decl_stmt|;
comment|/* 2^i */
name|int
name|a
init|=
literal|0
decl_stmt|;
comment|/* number of elements smaller than 2^i */
name|int
name|na
init|=
literal|0
decl_stmt|;
comment|/* number of elements to go to array part */
name|int
name|n
init|=
literal|0
decl_stmt|;
comment|/* optimal size for array part */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|twotoi
operator|=
literal|1
init|;
name|twotoi
operator|/
literal|2
operator|<
operator|*
name|narray
condition|;
name|i
operator|++
operator|,
name|twotoi
operator|*=
literal|2
control|)
block|{
if|if
condition|(
name|nums
index|[
name|i
index|]
operator|>
literal|0
condition|)
block|{
name|a
operator|+=
name|nums
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|a
operator|>
name|twotoi
operator|/
literal|2
condition|)
block|{
comment|/* more than half elements present? */
name|n
operator|=
name|twotoi
expr_stmt|;
comment|/* optimal size (till now) */
name|na
operator|=
name|a
expr_stmt|;
comment|/* all elements smaller than n will go to array part */
block|}
block|}
if|if
condition|(
name|a
operator|==
operator|*
name|narray
condition|)
break|break;
comment|/* all elements already counted */
block|}
operator|*
name|narray
operator|=
name|n
expr_stmt|;
name|lua_assert
argument_list|(
operator|*
name|narray
operator|/
literal|2
operator|<=
name|na
operator|&&
name|na
operator|<=
operator|*
name|narray
argument_list|)
expr_stmt|;
return|return
name|na
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|countint
parameter_list|(
specifier|const
name|TValue
modifier|*
name|key
parameter_list|,
name|int
modifier|*
name|nums
parameter_list|)
block|{
name|int
name|k
init|=
name|arrayindex
argument_list|(
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
literal|0
operator|<
name|k
operator|&&
name|k
operator|<=
name|MAXASIZE
condition|)
block|{
comment|/* is `key' an appropriate array index? */
name|nums
index|[
name|luaO_ceillog2
argument_list|(
name|k
argument_list|)
index|]
operator|++
expr_stmt|;
comment|/* count as such */
return|return
literal|1
return|;
block|}
else|else
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|numusearray
parameter_list|(
specifier|const
name|Table
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|nums
parameter_list|)
block|{
name|int
name|lg
decl_stmt|;
name|int
name|ttlg
decl_stmt|;
comment|/* 2^lg */
name|int
name|ause
init|=
literal|0
decl_stmt|;
comment|/* summation of `nums' */
name|int
name|i
init|=
literal|1
decl_stmt|;
comment|/* count to traverse all array keys */
for|for
control|(
name|lg
operator|=
literal|0
operator|,
name|ttlg
operator|=
literal|1
init|;
name|lg
operator|<=
name|MAXBITS
condition|;
name|lg
operator|++
operator|,
name|ttlg
operator|*=
literal|2
control|)
block|{
comment|/* for each slice */
name|int
name|lc
init|=
literal|0
decl_stmt|;
comment|/* counter */
name|int
name|lim
init|=
name|ttlg
decl_stmt|;
if|if
condition|(
name|lim
operator|>
name|t
operator|->
name|sizearray
condition|)
block|{
name|lim
operator|=
name|t
operator|->
name|sizearray
expr_stmt|;
comment|/* adjust upper limit */
if|if
condition|(
name|i
operator|>
name|lim
condition|)
break|break;
comment|/* no more elements to count */
block|}
comment|/* count elements in range (2^(lg-1), 2^lg] */
for|for
control|(
init|;
name|i
operator|<=
name|lim
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
operator|&
name|t
operator|->
name|array
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|lc
operator|++
expr_stmt|;
block|}
name|nums
index|[
name|lg
index|]
operator|+=
name|lc
expr_stmt|;
name|ause
operator|+=
name|lc
expr_stmt|;
block|}
return|return
name|ause
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|numusehash
parameter_list|(
specifier|const
name|Table
modifier|*
name|t
parameter_list|,
name|int
modifier|*
name|nums
parameter_list|,
name|int
modifier|*
name|pnasize
parameter_list|)
block|{
name|int
name|totaluse
init|=
literal|0
decl_stmt|;
comment|/* total number of elements */
name|int
name|ause
init|=
literal|0
decl_stmt|;
comment|/* summation of `nums' */
name|int
name|i
init|=
name|sizenode
argument_list|(
name|t
argument_list|)
decl_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
block|{
name|Node
modifier|*
name|n
init|=
operator|&
name|t
operator|->
name|node
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
condition|)
block|{
name|ause
operator|+=
name|countint
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|,
name|nums
argument_list|)
expr_stmt|;
name|totaluse
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|pnasize
operator|+=
name|ause
expr_stmt|;
return|return
name|totaluse
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|setarrayvector
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|t
operator|->
name|array
argument_list|,
name|t
operator|->
name|sizearray
argument_list|,
name|size
argument_list|,
name|TValue
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|t
operator|->
name|sizearray
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
name|setnilvalue
argument_list|(
operator|&
name|t
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|t
operator|->
name|sizearray
operator|=
name|size
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|setnodevector
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
name|int
name|size
parameter_list|)
block|{
name|int
name|lsize
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
block|{
comment|/* no elements to hash part? */
name|t
operator|->
name|node
operator|=
name|cast
argument_list|(
name|Node
operator|*
argument_list|,
name|dummynode
argument_list|)
expr_stmt|;
comment|/* use common `dummynode' */
name|lsize
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|lsize
operator|=
name|luaO_ceillog2
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsize
operator|>
name|MAXBITS
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"table overflow"
argument_list|)
expr_stmt|;
name|size
operator|=
name|twoto
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|t
operator|->
name|node
operator|=
name|luaM_newvector
argument_list|(
name|L
argument_list|,
name|size
argument_list|,
name|Node
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
control|)
block|{
name|Node
modifier|*
name|n
init|=
name|gnode
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|gnext
argument_list|(
name|n
argument_list|)
operator|=
name|NULL
expr_stmt|;
name|setnilvalue
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|setnilvalue
argument_list|(
name|gval
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|t
operator|->
name|lsizenode
operator|=
name|cast_byte
argument_list|(
name|lsize
argument_list|)
expr_stmt|;
name|t
operator|->
name|lastfree
operator|=
name|gnode
argument_list|(
name|t
argument_list|,
name|size
argument_list|)
expr_stmt|;
comment|/* all positions are free */
block|}
end_function

begin_function
name|void
name|luaH_resize
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
name|int
name|nasize
parameter_list|,
name|int
name|nhsize
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|oldasize
init|=
name|t
operator|->
name|sizearray
decl_stmt|;
name|int
name|oldhsize
init|=
name|t
operator|->
name|lsizenode
decl_stmt|;
name|Node
modifier|*
name|nold
init|=
name|t
operator|->
name|node
decl_stmt|;
comment|/* save old hash ... */
if|if
condition|(
name|nasize
operator|>
name|oldasize
condition|)
comment|/* array part must grow? */
name|setarrayvector
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|nasize
argument_list|)
expr_stmt|;
comment|/* create new hash part with appropriate size */
name|setnodevector
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|nhsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|nasize
operator|<
name|oldasize
condition|)
block|{
comment|/* array part must shrink? */
name|t
operator|->
name|sizearray
operator|=
name|nasize
expr_stmt|;
comment|/* re-insert elements from vanishing slice */
for|for
control|(
name|i
operator|=
name|nasize
init|;
name|i
operator|<
name|oldasize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
operator|&
name|t
operator|->
name|array
index|[
name|i
index|]
argument_list|)
condition|)
name|luaH_setint
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|i
operator|+
literal|1
argument_list|,
operator|&
name|t
operator|->
name|array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* shrink array */
name|luaM_reallocvector
argument_list|(
name|L
argument_list|,
name|t
operator|->
name|array
argument_list|,
name|oldasize
argument_list|,
name|nasize
argument_list|,
name|TValue
argument_list|)
expr_stmt|;
block|}
comment|/* re-insert elements from hash part */
for|for
control|(
name|i
operator|=
name|twoto
argument_list|(
name|oldhsize
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|Node
modifier|*
name|old
init|=
name|nold
operator|+
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|old
argument_list|)
argument_list|)
condition|)
block|{
comment|/* doesn't need barrier/invalidate cache, as entry was          already present in the table */
name|setobjt2t
argument_list|(
name|L
argument_list|,
name|luaH_set
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|gkey
argument_list|(
name|old
argument_list|)
argument_list|)
argument_list|,
name|gval
argument_list|(
name|old
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|isdummy
argument_list|(
name|nold
argument_list|)
condition|)
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|nold
argument_list|,
name|cast
argument_list|(
name|size_t
argument_list|,
name|twoto
argument_list|(
name|oldhsize
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* free old array */
block|}
end_function

begin_function
name|void
name|luaH_resizearray
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
name|int
name|nasize
parameter_list|)
block|{
name|int
name|nsize
init|=
name|isdummy
argument_list|(
name|t
operator|->
name|node
argument_list|)
condition|?
literal|0
else|:
name|sizenode
argument_list|(
name|t
argument_list|)
decl_stmt|;
name|luaH_resize
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|nasize
argument_list|,
name|nsize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|rehash
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
specifier|const
name|TValue
modifier|*
name|ek
parameter_list|)
block|{
name|int
name|nasize
decl_stmt|,
name|na
decl_stmt|;
name|int
name|nums
index|[
name|MAXBITS
operator|+
literal|1
index|]
decl_stmt|;
comment|/* nums[i] = number of keys with 2^(i-1)< k<= 2^i */
name|int
name|i
decl_stmt|;
name|int
name|totaluse
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|MAXBITS
condition|;
name|i
operator|++
control|)
name|nums
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
comment|/* reset counts */
name|nasize
operator|=
name|numusearray
argument_list|(
name|t
argument_list|,
name|nums
argument_list|)
expr_stmt|;
comment|/* count keys in array part */
name|totaluse
operator|=
name|nasize
expr_stmt|;
comment|/* all those keys are integer keys */
name|totaluse
operator|+=
name|numusehash
argument_list|(
name|t
argument_list|,
name|nums
argument_list|,
operator|&
name|nasize
argument_list|)
expr_stmt|;
comment|/* count keys in hash part */
comment|/* count extra key */
name|nasize
operator|+=
name|countint
argument_list|(
name|ek
argument_list|,
name|nums
argument_list|)
expr_stmt|;
name|totaluse
operator|++
expr_stmt|;
comment|/* compute new size for array part */
name|na
operator|=
name|computesizes
argument_list|(
name|nums
argument_list|,
operator|&
name|nasize
argument_list|)
expr_stmt|;
comment|/* resize the table to new computed sizes */
name|luaH_resize
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|nasize
argument_list|,
name|totaluse
operator|-
name|na
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ** }============================================================= */
end_comment

begin_function
name|Table
modifier|*
name|luaH_new
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
name|Table
modifier|*
name|t
init|=
operator|&
name|luaC_newobj
argument_list|(
name|L
argument_list|,
name|LUA_TTABLE
argument_list|,
sizeof|sizeof
argument_list|(
name|Table
argument_list|)
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|->
name|h
decl_stmt|;
name|t
operator|->
name|metatable
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|flags
operator|=
name|cast_byte
argument_list|(
operator|~
literal|0
argument_list|)
expr_stmt|;
name|t
operator|->
name|array
operator|=
name|NULL
expr_stmt|;
name|t
operator|->
name|sizearray
operator|=
literal|0
expr_stmt|;
name|setnodevector
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|t
return|;
block|}
end_function

begin_function
name|void
name|luaH_free
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isdummy
argument_list|(
name|t
operator|->
name|node
argument_list|)
condition|)
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|t
operator|->
name|node
argument_list|,
name|cast
argument_list|(
name|size_t
argument_list|,
name|sizenode
argument_list|(
name|t
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|luaM_freearray
argument_list|(
name|L
argument_list|,
name|t
operator|->
name|array
argument_list|,
name|t
operator|->
name|sizearray
argument_list|)
expr_stmt|;
name|luaM_free
argument_list|(
name|L
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|Node
modifier|*
name|getfreepos
parameter_list|(
name|Table
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
name|t
operator|->
name|lastfree
operator|>
name|t
operator|->
name|node
condition|)
block|{
name|t
operator|->
name|lastfree
operator|--
expr_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|gkey
argument_list|(
name|t
operator|->
name|lastfree
argument_list|)
argument_list|)
condition|)
return|return
name|t
operator|->
name|lastfree
return|;
block|}
return|return
name|NULL
return|;
comment|/* could not find a free place */
block|}
end_function

begin_comment
comment|/* ** inserts a new key into a hash table; first, check whether key's main ** position is free. If not, check whether colliding node is in its main ** position or not: if it is not, move colliding node to an empty place and ** put new key in its main position; otherwise (colliding node is in its main ** position), new key goes to an empty position. */
end_comment

begin_function
name|TValue
modifier|*
name|luaH_newkey
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
specifier|const
name|TValue
modifier|*
name|key
parameter_list|)
block|{
name|Node
modifier|*
name|mp
decl_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|key
argument_list|)
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"table index is nil"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ttisnumber
argument_list|(
name|key
argument_list|)
operator|&&
name|luai_numisnan
argument_list|(
name|L
argument_list|,
name|nvalue
argument_list|(
name|key
argument_list|)
argument_list|)
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"table index is NaN"
argument_list|)
expr_stmt|;
name|mp
operator|=
name|mainposition
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|mp
argument_list|)
argument_list|)
operator|||
name|isdummy
argument_list|(
name|mp
argument_list|)
condition|)
block|{
comment|/* main position is taken? */
name|Node
modifier|*
name|othern
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|getfreepos
argument_list|(
name|t
argument_list|)
decl_stmt|;
comment|/* get a free place */
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
comment|/* cannot find a free place? */
name|rehash
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|key
argument_list|)
expr_stmt|;
comment|/* grow table */
comment|/* whatever called 'newkey' take care of TM cache and GC barrier */
return|return
name|luaH_set
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|key
argument_list|)
return|;
comment|/* insert key into grown table */
block|}
name|lua_assert
argument_list|(
operator|!
name|isdummy
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|othern
operator|=
name|mainposition
argument_list|(
name|t
argument_list|,
name|gkey
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|othern
operator|!=
name|mp
condition|)
block|{
comment|/* is colliding node out of its main position? */
comment|/* yes; move colliding node into free position */
while|while
condition|(
name|gnext
argument_list|(
name|othern
argument_list|)
operator|!=
name|mp
condition|)
name|othern
operator|=
name|gnext
argument_list|(
name|othern
argument_list|)
expr_stmt|;
comment|/* find previous */
name|gnext
argument_list|(
name|othern
argument_list|)
operator|=
name|n
expr_stmt|;
comment|/* redo the chain with `n' in place of `mp' */
operator|*
name|n
operator|=
operator|*
name|mp
expr_stmt|;
comment|/* copy colliding node into free pos. (mp->next also goes) */
name|gnext
argument_list|(
name|mp
argument_list|)
operator|=
name|NULL
expr_stmt|;
comment|/* now `mp' is free */
name|setnilvalue
argument_list|(
name|gval
argument_list|(
name|mp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* colliding node is in its own main position */
comment|/* new node will go into free position */
name|gnext
argument_list|(
name|n
argument_list|)
operator|=
name|gnext
argument_list|(
name|mp
argument_list|)
expr_stmt|;
comment|/* chain new position */
name|gnext
argument_list|(
name|mp
argument_list|)
operator|=
name|n
expr_stmt|;
name|mp
operator|=
name|n
expr_stmt|;
block|}
block|}
name|setobj2t
argument_list|(
name|L
argument_list|,
name|gkey
argument_list|(
name|mp
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|luaC_barrierback
argument_list|(
name|L
argument_list|,
name|obj2gco
argument_list|(
name|t
argument_list|)
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|lua_assert
argument_list|(
name|ttisnil
argument_list|(
name|gval
argument_list|(
name|mp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|gval
argument_list|(
name|mp
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* ** search function for integers */
end_comment

begin_function
specifier|const
name|TValue
modifier|*
name|luaH_getint
parameter_list|(
name|Table
modifier|*
name|t
parameter_list|,
name|int
name|key
parameter_list|)
block|{
comment|/* (1<= key&& key<= t->sizearray) */
if|if
condition|(
name|cast
argument_list|(
argument|unsigned int
argument_list|,
argument|key-
literal|1
argument_list|)
operator|<
name|cast
argument_list|(
argument|unsigned int
argument_list|,
argument|t->sizearray
argument_list|)
condition|)
return|return
operator|&
name|t
operator|->
name|array
index|[
name|key
operator|-
literal|1
index|]
return|;
else|else
block|{
name|lua_Number
name|nk
init|=
name|cast_num
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|Node
modifier|*
name|n
init|=
name|hashnum
argument_list|(
name|t
argument_list|,
name|nk
argument_list|)
decl_stmt|;
do|do
block|{
comment|/* check whether `key' is somewhere in the chain */
if|if
condition|(
name|ttisnumber
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
operator|&&
name|luai_numeq
argument_list|(
name|nvalue
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|nk
argument_list|)
condition|)
return|return
name|gval
argument_list|(
name|n
argument_list|)
return|;
comment|/* that's it */
else|else
name|n
operator|=
name|gnext
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
return|return
name|luaO_nilobject
return|;
block|}
block|}
end_function

begin_comment
comment|/* ** search function for short strings */
end_comment

begin_function
specifier|const
name|TValue
modifier|*
name|luaH_getstr
parameter_list|(
name|Table
modifier|*
name|t
parameter_list|,
name|TString
modifier|*
name|key
parameter_list|)
block|{
name|Node
modifier|*
name|n
init|=
name|hashstr
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|lua_assert
argument_list|(
name|key
operator|->
name|tsv
operator|.
name|tt
operator|==
name|LUA_TSHRSTR
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* check whether `key' is somewhere in the chain */
if|if
condition|(
name|ttisshrstring
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
operator|&&
name|eqshrstr
argument_list|(
name|rawtsvalue
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|,
name|key
argument_list|)
condition|)
return|return
name|gval
argument_list|(
name|n
argument_list|)
return|;
comment|/* that's it */
else|else
name|n
operator|=
name|gnext
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
return|return
name|luaO_nilobject
return|;
block|}
end_function

begin_comment
comment|/* ** main search function */
end_comment

begin_function
specifier|const
name|TValue
modifier|*
name|luaH_get
parameter_list|(
name|Table
modifier|*
name|t
parameter_list|,
specifier|const
name|TValue
modifier|*
name|key
parameter_list|)
block|{
switch|switch
condition|(
name|ttype
argument_list|(
name|key
argument_list|)
condition|)
block|{
case|case
name|LUA_TSHRSTR
case|:
return|return
name|luaH_getstr
argument_list|(
name|t
argument_list|,
name|rawtsvalue
argument_list|(
name|key
argument_list|)
argument_list|)
return|;
case|case
name|LUA_TNIL
case|:
return|return
name|luaO_nilobject
return|;
case|case
name|LUA_TNUMBER
case|:
block|{
name|int
name|k
decl_stmt|;
name|lua_Number
name|n
init|=
name|nvalue
argument_list|(
name|key
argument_list|)
decl_stmt|;
name|lua_number2int
argument_list|(
name|k
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|luai_numeq
argument_list|(
name|cast_num
argument_list|(
name|k
argument_list|)
argument_list|,
name|n
argument_list|)
condition|)
comment|/* index is int? */
return|return
name|luaH_getint
argument_list|(
name|t
argument_list|,
name|k
argument_list|)
return|;
comment|/* use specialized version */
comment|/* else go through */
block|}
default|default:
block|{
name|Node
modifier|*
name|n
init|=
name|mainposition
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
decl_stmt|;
do|do
block|{
comment|/* check whether `key' is somewhere in the chain */
if|if
condition|(
name|luaV_rawequalobj
argument_list|(
name|gkey
argument_list|(
name|n
argument_list|)
argument_list|,
name|key
argument_list|)
condition|)
return|return
name|gval
argument_list|(
name|n
argument_list|)
return|;
comment|/* that's it */
else|else
name|n
operator|=
name|gnext
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|n
condition|)
do|;
return|return
name|luaO_nilobject
return|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* ** beware: when using this function you probably need to check a GC ** barrier and invalidate the TM cache. */
end_comment

begin_function
name|TValue
modifier|*
name|luaH_set
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
specifier|const
name|TValue
modifier|*
name|key
parameter_list|)
block|{
specifier|const
name|TValue
modifier|*
name|p
init|=
name|luaH_get
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|luaO_nilobject
condition|)
return|return
name|cast
argument_list|(
name|TValue
operator|*
argument_list|,
name|p
argument_list|)
return|;
else|else
return|return
name|luaH_newkey
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|luaH_setint
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Table
modifier|*
name|t
parameter_list|,
name|int
name|key
parameter_list|,
name|TValue
modifier|*
name|value
parameter_list|)
block|{
specifier|const
name|TValue
modifier|*
name|p
init|=
name|luaH_getint
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
decl_stmt|;
name|TValue
modifier|*
name|cell
decl_stmt|;
if|if
condition|(
name|p
operator|!=
name|luaO_nilobject
condition|)
name|cell
operator|=
name|cast
argument_list|(
name|TValue
operator|*
argument_list|,
name|p
argument_list|)
expr_stmt|;
else|else
block|{
name|TValue
name|k
decl_stmt|;
name|setnvalue
argument_list|(
operator|&
name|k
argument_list|,
name|cast_num
argument_list|(
name|key
argument_list|)
argument_list|)
expr_stmt|;
name|cell
operator|=
name|luaH_newkey
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
operator|&
name|k
argument_list|)
expr_stmt|;
block|}
name|setobj2t
argument_list|(
name|L
argument_list|,
name|cell
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|unbound_search
parameter_list|(
name|Table
modifier|*
name|t
parameter_list|,
name|unsigned
name|int
name|j
parameter_list|)
block|{
name|unsigned
name|int
name|i
init|=
name|j
decl_stmt|;
comment|/* i is zero or a present index */
name|j
operator|++
expr_stmt|;
comment|/* find `i' and `j' such that i is present and j is not */
while|while
condition|(
operator|!
name|ttisnil
argument_list|(
name|luaH_getint
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
block|{
name|i
operator|=
name|j
expr_stmt|;
name|j
operator|*=
literal|2
expr_stmt|;
if|if
condition|(
name|j
operator|>
name|cast
argument_list|(
argument|unsigned int
argument_list|,
argument|MAX_INT
argument_list|)
condition|)
block|{
comment|/* overflow? */
comment|/* table was built with bad purposes: resort to linear search */
name|i
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|!
name|ttisnil
argument_list|(
name|luaH_getint
argument_list|(
name|t
argument_list|,
name|i
argument_list|)
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
return|return
name|i
operator|-
literal|1
return|;
block|}
block|}
comment|/* now do a binary search between them */
while|while
condition|(
name|j
operator|-
name|i
operator|>
literal|1
condition|)
block|{
name|unsigned
name|int
name|m
init|=
operator|(
name|i
operator|+
name|j
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
name|luaH_getint
argument_list|(
name|t
argument_list|,
name|m
argument_list|)
argument_list|)
condition|)
name|j
operator|=
name|m
expr_stmt|;
else|else
name|i
operator|=
name|m
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
end_function

begin_comment
comment|/* ** Try to find a boundary in table `t'. A `boundary' is an integer index ** such that t[i] is non-nil and t[i+1] is nil (and 0 if t[1] is nil). */
end_comment

begin_function
name|int
name|luaH_getn
parameter_list|(
name|Table
modifier|*
name|t
parameter_list|)
block|{
name|unsigned
name|int
name|j
init|=
name|t
operator|->
name|sizearray
decl_stmt|;
if|if
condition|(
name|j
operator|>
literal|0
operator|&&
name|ttisnil
argument_list|(
operator|&
name|t
operator|->
name|array
index|[
name|j
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
comment|/* there is a boundary in the array part: (binary) search for it */
name|unsigned
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|j
operator|-
name|i
operator|>
literal|1
condition|)
block|{
name|unsigned
name|int
name|m
init|=
operator|(
name|i
operator|+
name|j
operator|)
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|ttisnil
argument_list|(
operator|&
name|t
operator|->
name|array
index|[
name|m
operator|-
literal|1
index|]
argument_list|)
condition|)
name|j
operator|=
name|m
expr_stmt|;
else|else
name|i
operator|=
name|m
expr_stmt|;
block|}
return|return
name|i
return|;
block|}
comment|/* else must find a boundary in hash part */
elseif|else
if|if
condition|(
name|isdummy
argument_list|(
name|t
operator|->
name|node
argument_list|)
condition|)
comment|/* hash part is empty? */
return|return
name|j
return|;
comment|/* that is easy... */
else|else
return|return
name|unbound_search
argument_list|(
name|t
argument_list|,
name|j
argument_list|)
return|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|LUA_DEBUG
argument_list|)
end_if

begin_function
name|Node
modifier|*
name|luaH_mainposition
parameter_list|(
specifier|const
name|Table
modifier|*
name|t
parameter_list|,
specifier|const
name|TValue
modifier|*
name|key
parameter_list|)
block|{
return|return
name|mainposition
argument_list|(
name|t
argument_list|,
name|key
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|luaH_isdummy
parameter_list|(
name|Node
modifier|*
name|n
parameter_list|)
block|{
return|return
name|isdummy
argument_list|(
name|n
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

