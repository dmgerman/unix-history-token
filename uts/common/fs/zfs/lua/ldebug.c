begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ** $Id: ldebug.c,v 2.90.1.4 2015/02/19 17:05:13 roberto Exp $ ** Debug Interface ** See Copyright Notice in lua.h */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_define
define|#
directive|define
name|ldebug_c
end_define

begin_define
define|#
directive|define
name|LUA_CORE
end_define

begin_include
include|#
directive|include
file|"lua.h"
end_include

begin_include
include|#
directive|include
file|"lapi.h"
end_include

begin_include
include|#
directive|include
file|"lcode.h"
end_include

begin_include
include|#
directive|include
file|"ldebug.h"
end_include

begin_include
include|#
directive|include
file|"ldo.h"
end_include

begin_include
include|#
directive|include
file|"lfunc.h"
end_include

begin_include
include|#
directive|include
file|"lobject.h"
end_include

begin_include
include|#
directive|include
file|"lopcodes.h"
end_include

begin_include
include|#
directive|include
file|"lstate.h"
end_include

begin_include
include|#
directive|include
file|"lstring.h"
end_include

begin_include
include|#
directive|include
file|"ltable.h"
end_include

begin_include
include|#
directive|include
file|"ltm.h"
end_include

begin_include
include|#
directive|include
file|"lvm.h"
end_include

begin_define
define|#
directive|define
name|noLuaClosure
parameter_list|(
name|f
parameter_list|)
value|((f) == NULL || (f)->c.tt == LUA_TCCL)
end_define

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|getfuncname
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|CallInfo
modifier|*
name|ci
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|int
name|currentpc
parameter_list|(
name|CallInfo
modifier|*
name|ci
parameter_list|)
block|{
name|lua_assert
argument_list|(
name|isLua
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|pcRel
argument_list|(
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
argument_list|,
name|ci_func
argument_list|(
name|ci
argument_list|)
operator|->
name|p
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|currentline
parameter_list|(
name|CallInfo
modifier|*
name|ci
parameter_list|)
block|{
return|return
name|getfuncline
argument_list|(
name|ci_func
argument_list|(
name|ci
argument_list|)
operator|->
name|p
argument_list|,
name|currentpc
argument_list|(
name|ci
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|swapextra
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
if|if
condition|(
name|L
operator|->
name|status
operator|==
name|LUA_YIELD
condition|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
comment|/* get function that yielded */
name|StkId
name|temp
init|=
name|ci
operator|->
name|func
decl_stmt|;
comment|/* exchange its 'func' and 'extra' values */
name|ci
operator|->
name|func
operator|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|extra
argument_list|)
expr_stmt|;
name|ci
operator|->
name|extra
operator|=
name|savestack
argument_list|(
name|L
argument_list|,
name|temp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ** this function can be called asynchronous (e.g. during a signal) */
end_comment

begin_function
name|LUA_API
name|int
name|lua_sethook
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|lua_Hook
name|func
parameter_list|,
name|int
name|mask
parameter_list|,
name|int
name|count
parameter_list|)
block|{
if|if
condition|(
name|func
operator|==
name|NULL
operator|||
name|mask
operator|==
literal|0
condition|)
block|{
comment|/* turn off hooks? */
name|mask
operator|=
literal|0
expr_stmt|;
name|func
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|isLua
argument_list|(
name|L
operator|->
name|ci
argument_list|)
condition|)
name|L
operator|->
name|oldpc
operator|=
name|L
operator|->
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|savedpc
expr_stmt|;
name|L
operator|->
name|hook
operator|=
name|func
expr_stmt|;
name|L
operator|->
name|basehookcount
operator|=
name|count
expr_stmt|;
name|resethookcount
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|L
operator|->
name|hookmask
operator|=
name|cast_byte
argument_list|(
name|mask
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|LUA_API
name|lua_Hook
name|lua_gethook
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
return|return
name|L
operator|->
name|hook
return|;
block|}
end_function

begin_function
name|LUA_API
name|int
name|lua_gethookmask
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
return|return
name|L
operator|->
name|hookmask
return|;
block|}
end_function

begin_function
name|LUA_API
name|int
name|lua_gethookcount
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
return|return
name|L
operator|->
name|basehookcount
return|;
block|}
end_function

begin_function
name|LUA_API
name|int
name|lua_getstack
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|int
name|level
parameter_list|,
name|lua_Debug
modifier|*
name|ar
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|CallInfo
modifier|*
name|ci
decl_stmt|;
if|if
condition|(
name|level
operator|<
literal|0
condition|)
return|return
literal|0
return|;
comment|/* invalid (negative) level */
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
for|for
control|(
name|ci
operator|=
name|L
operator|->
name|ci
init|;
name|level
operator|>
literal|0
operator|&&
name|ci
operator|!=
operator|&
name|L
operator|->
name|base_ci
condition|;
name|ci
operator|=
name|ci
operator|->
name|previous
control|)
name|level
operator|--
expr_stmt|;
if|if
condition|(
name|level
operator|==
literal|0
operator|&&
name|ci
operator|!=
operator|&
name|L
operator|->
name|base_ci
condition|)
block|{
comment|/* level found? */
name|status
operator|=
literal|1
expr_stmt|;
name|ar
operator|->
name|i_ci
operator|=
name|ci
expr_stmt|;
block|}
else|else
name|status
operator|=
literal|0
expr_stmt|;
comment|/* no such level */
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|upvalname
parameter_list|(
name|Proto
modifier|*
name|p
parameter_list|,
name|int
name|uv
parameter_list|)
block|{
name|TString
modifier|*
name|s
init|=
name|check_exp
argument_list|(
name|uv
operator|<
name|p
operator|->
name|sizeupvalues
argument_list|,
name|p
operator|->
name|upvalues
index|[
name|uv
index|]
operator|.
name|name
argument_list|)
decl_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
return|return
literal|"?"
return|;
else|else
return|return
name|getstr
argument_list|(
name|s
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|findvararg
parameter_list|(
name|CallInfo
modifier|*
name|ci
parameter_list|,
name|int
name|n
parameter_list|,
name|StkId
modifier|*
name|pos
parameter_list|)
block|{
name|int
name|nparams
init|=
name|clLvalue
argument_list|(
name|ci
operator|->
name|func
argument_list|)
operator|->
name|p
operator|->
name|numparams
decl_stmt|;
if|if
condition|(
name|n
operator|>=
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
operator|-
name|ci
operator|->
name|func
operator|-
name|nparams
condition|)
return|return
name|NULL
return|;
comment|/* no such vararg */
else|else
block|{
operator|*
name|pos
operator|=
name|ci
operator|->
name|func
operator|+
name|nparams
operator|+
name|n
expr_stmt|;
return|return
literal|"(*vararg)"
return|;
comment|/* generic name for any vararg */
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|findlocal
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|CallInfo
modifier|*
name|ci
parameter_list|,
name|int
name|n
parameter_list|,
name|StkId
modifier|*
name|pos
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
name|StkId
name|base
decl_stmt|;
if|if
condition|(
name|isLua
argument_list|(
name|ci
argument_list|)
condition|)
block|{
if|if
condition|(
name|n
operator|<
literal|0
condition|)
comment|/* access to vararg values? */
return|return
name|findvararg
argument_list|(
name|ci
argument_list|,
operator|-
name|n
argument_list|,
name|pos
argument_list|)
return|;
else|else
block|{
name|base
operator|=
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
expr_stmt|;
name|name
operator|=
name|luaF_getlocalname
argument_list|(
name|ci_func
argument_list|(
name|ci
argument_list|)
operator|->
name|p
argument_list|,
name|n
argument_list|,
name|currentpc
argument_list|(
name|ci
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|base
operator|=
name|ci
operator|->
name|func
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
comment|/* no 'standard' name? */
name|StkId
name|limit
init|=
operator|(
name|ci
operator|==
name|L
operator|->
name|ci
operator|)
condition|?
name|L
operator|->
name|top
else|:
name|ci
operator|->
name|next
operator|->
name|func
decl_stmt|;
if|if
condition|(
name|limit
operator|-
name|base
operator|>=
name|n
operator|&&
name|n
operator|>
literal|0
condition|)
comment|/* is 'n' inside 'ci' stack? */
name|name
operator|=
literal|"(*temporary)"
expr_stmt|;
comment|/* generic name for any valid slot */
else|else
return|return
name|NULL
return|;
comment|/* no name */
block|}
operator|*
name|pos
operator|=
name|base
operator|+
operator|(
name|n
operator|-
literal|1
operator|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|LUA_API
specifier|const
name|char
modifier|*
name|lua_getlocal
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|lua_Debug
modifier|*
name|ar
parameter_list|,
name|int
name|n
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|swapextra
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|ar
operator|==
name|NULL
condition|)
block|{
comment|/* information about non-active function? */
if|if
condition|(
operator|!
name|isLfunction
argument_list|(
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
condition|)
comment|/* not a Lua function? */
name|name
operator|=
name|NULL
expr_stmt|;
else|else
comment|/* consider live variables at function start (parameters) */
name|name
operator|=
name|luaF_getlocalname
argument_list|(
name|clLvalue
argument_list|(
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
operator|->
name|p
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* active function; get information through 'ar' */
name|StkId
name|pos
init|=
literal|0
decl_stmt|;
comment|/* to avoid warnings */
name|name
operator|=
name|findlocal
argument_list|(
name|L
argument_list|,
name|ar
operator|->
name|i_ci
argument_list|,
name|n
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|setobj2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|pos
argument_list|)
expr_stmt|;
name|api_incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
block|}
name|swapextra
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_function
name|LUA_API
specifier|const
name|char
modifier|*
name|lua_setlocal
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|lua_Debug
modifier|*
name|ar
parameter_list|,
name|int
name|n
parameter_list|)
block|{
name|StkId
name|pos
init|=
literal|0
decl_stmt|;
comment|/* to avoid warnings */
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|swapextra
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|name
operator|=
name|findlocal
argument_list|(
name|L
argument_list|,
name|ar
operator|->
name|i_ci
argument_list|,
name|n
argument_list|,
operator|&
name|pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
condition|)
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|pos
argument_list|,
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
name|L
operator|->
name|top
operator|--
expr_stmt|;
comment|/* pop value */
name|swapextra
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|name
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|funcinfo
parameter_list|(
name|lua_Debug
modifier|*
name|ar
parameter_list|,
name|Closure
modifier|*
name|cl
parameter_list|)
block|{
if|if
condition|(
name|noLuaClosure
argument_list|(
name|cl
argument_list|)
condition|)
block|{
name|ar
operator|->
name|source
operator|=
literal|"=[C]"
expr_stmt|;
name|ar
operator|->
name|linedefined
operator|=
operator|-
literal|1
expr_stmt|;
name|ar
operator|->
name|lastlinedefined
operator|=
operator|-
literal|1
expr_stmt|;
name|ar
operator|->
name|what
operator|=
literal|"C"
expr_stmt|;
block|}
else|else
block|{
name|Proto
modifier|*
name|p
init|=
name|cl
operator|->
name|l
operator|.
name|p
decl_stmt|;
name|ar
operator|->
name|source
operator|=
name|p
operator|->
name|source
condition|?
name|getstr
argument_list|(
name|p
operator|->
name|source
argument_list|)
else|:
literal|"=?"
expr_stmt|;
name|ar
operator|->
name|linedefined
operator|=
name|p
operator|->
name|linedefined
expr_stmt|;
name|ar
operator|->
name|lastlinedefined
operator|=
name|p
operator|->
name|lastlinedefined
expr_stmt|;
name|ar
operator|->
name|what
operator|=
operator|(
name|ar
operator|->
name|linedefined
operator|==
literal|0
operator|)
condition|?
literal|"main"
else|:
literal|"Lua"
expr_stmt|;
block|}
name|luaO_chunkid
argument_list|(
name|ar
operator|->
name|short_src
argument_list|,
name|ar
operator|->
name|source
argument_list|,
name|LUA_IDSIZE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|collectvalidlines
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|Closure
modifier|*
name|f
parameter_list|)
block|{
if|if
condition|(
name|noLuaClosure
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|setnilvalue
argument_list|(
name|L
operator|->
name|top
argument_list|)
expr_stmt|;
name|api_incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|TValue
name|v
decl_stmt|;
name|int
modifier|*
name|lineinfo
init|=
name|f
operator|->
name|l
operator|.
name|p
operator|->
name|lineinfo
decl_stmt|;
name|Table
modifier|*
name|t
init|=
name|luaH_new
argument_list|(
name|L
argument_list|)
decl_stmt|;
comment|/* new table to store active lines */
name|sethvalue
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|t
argument_list|)
expr_stmt|;
comment|/* push it on stack */
name|api_incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|setbvalue
argument_list|(
operator|&
name|v
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* boolean 'true' to be the value of all indices */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|f
operator|->
name|l
operator|.
name|p
operator|->
name|sizelineinfo
condition|;
name|i
operator|++
control|)
comment|/* for all lines with code */
name|luaH_setint
argument_list|(
name|L
argument_list|,
name|t
argument_list|,
name|lineinfo
index|[
name|i
index|]
argument_list|,
operator|&
name|v
argument_list|)
expr_stmt|;
comment|/* table[line] = true */
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|auxgetinfo
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|lua_Debug
modifier|*
name|ar
parameter_list|,
name|Closure
modifier|*
name|f
parameter_list|,
name|CallInfo
modifier|*
name|ci
parameter_list|)
block|{
name|int
name|status
init|=
literal|1
decl_stmt|;
for|for
control|(
init|;
operator|*
name|what
condition|;
name|what
operator|++
control|)
block|{
switch|switch
condition|(
operator|*
name|what
condition|)
block|{
case|case
literal|'S'
case|:
block|{
name|funcinfo
argument_list|(
name|ar
argument_list|,
name|f
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
literal|'l'
case|:
block|{
name|ar
operator|->
name|currentline
operator|=
operator|(
name|ci
operator|&&
name|isLua
argument_list|(
name|ci
argument_list|)
operator|)
condition|?
name|currentline
argument_list|(
name|ci
argument_list|)
else|:
operator|-
literal|1
expr_stmt|;
break|break;
block|}
case|case
literal|'u'
case|:
block|{
name|ar
operator|->
name|nups
operator|=
operator|(
name|f
operator|==
name|NULL
operator|)
condition|?
literal|0
else|:
name|f
operator|->
name|c
operator|.
name|nupvalues
expr_stmt|;
if|if
condition|(
name|noLuaClosure
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|ar
operator|->
name|isvararg
operator|=
literal|1
expr_stmt|;
name|ar
operator|->
name|nparams
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|ar
operator|->
name|isvararg
operator|=
name|f
operator|->
name|l
operator|.
name|p
operator|->
name|is_vararg
expr_stmt|;
name|ar
operator|->
name|nparams
operator|=
name|f
operator|->
name|l
operator|.
name|p
operator|->
name|numparams
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'t'
case|:
block|{
name|ar
operator|->
name|istailcall
operator|=
operator|(
name|ci
operator|)
condition|?
name|ci
operator|->
name|callstatus
operator|&
name|CIST_TAIL
else|:
literal|0
expr_stmt|;
break|break;
block|}
case|case
literal|'n'
case|:
block|{
comment|/* calling function is a known Lua function? */
if|if
condition|(
name|ci
operator|&&
operator|!
operator|(
name|ci
operator|->
name|callstatus
operator|&
name|CIST_TAIL
operator|)
operator|&&
name|isLua
argument_list|(
name|ci
operator|->
name|previous
argument_list|)
condition|)
name|ar
operator|->
name|namewhat
operator|=
name|getfuncname
argument_list|(
name|L
argument_list|,
name|ci
operator|->
name|previous
argument_list|,
operator|&
name|ar
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|ar
operator|->
name|namewhat
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ar
operator|->
name|namewhat
operator|==
name|NULL
condition|)
block|{
name|ar
operator|->
name|namewhat
operator|=
literal|""
expr_stmt|;
comment|/* not found */
name|ar
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
block|}
case|case
literal|'L'
case|:
case|case
literal|'f'
case|:
comment|/* handled by lua_getinfo */
break|break;
default|default:
name|status
operator|=
literal|0
expr_stmt|;
comment|/* invalid option */
block|}
block|}
return|return
name|status
return|;
block|}
end_function

begin_function
name|LUA_API
name|int
name|lua_getinfo
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|what
parameter_list|,
name|lua_Debug
modifier|*
name|ar
parameter_list|)
block|{
name|int
name|status
decl_stmt|;
name|Closure
modifier|*
name|cl
decl_stmt|;
name|CallInfo
modifier|*
name|ci
decl_stmt|;
name|StkId
name|func
decl_stmt|;
name|lua_lock
argument_list|(
name|L
argument_list|)
expr_stmt|;
name|swapextra
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|what
operator|==
literal|'>'
condition|)
block|{
name|ci
operator|=
name|NULL
expr_stmt|;
name|func
operator|=
name|L
operator|->
name|top
operator|-
literal|1
expr_stmt|;
name|api_check
argument_list|(
name|L
argument_list|,
name|ttisfunction
argument_list|(
name|func
argument_list|)
argument_list|,
literal|"function expected"
argument_list|)
expr_stmt|;
name|what
operator|++
expr_stmt|;
comment|/* skip the '>' */
name|L
operator|->
name|top
operator|--
expr_stmt|;
comment|/* pop function */
block|}
else|else
block|{
name|ci
operator|=
name|ar
operator|->
name|i_ci
expr_stmt|;
name|func
operator|=
name|ci
operator|->
name|func
expr_stmt|;
name|lua_assert
argument_list|(
name|ttisfunction
argument_list|(
name|ci
operator|->
name|func
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|cl
operator|=
name|ttisclosure
argument_list|(
name|func
argument_list|)
condition|?
name|clvalue
argument_list|(
name|func
argument_list|)
else|:
name|NULL
expr_stmt|;
name|status
operator|=
name|auxgetinfo
argument_list|(
name|L
argument_list|,
name|what
argument_list|,
name|ar
argument_list|,
name|cl
argument_list|,
name|ci
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|what
argument_list|,
literal|'f'
argument_list|)
condition|)
block|{
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|api_incr_top
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
name|swapextra
argument_list|(
name|L
argument_list|)
expr_stmt|;
if|if
condition|(
name|strchr
argument_list|(
name|what
argument_list|,
literal|'L'
argument_list|)
condition|)
name|collectvalidlines
argument_list|(
name|L
argument_list|,
name|cl
argument_list|)
expr_stmt|;
name|lua_unlock
argument_list|(
name|L
argument_list|)
expr_stmt|;
return|return
name|status
return|;
block|}
end_function

begin_comment
comment|/* ** {====================================================== ** Symbolic Execution ** ======================================================= */
end_comment

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|getobjname
parameter_list|(
name|Proto
modifier|*
name|p
parameter_list|,
name|int
name|lastpc
parameter_list|,
name|int
name|reg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* ** find a "name" for the RK value 'c' */
end_comment

begin_function
specifier|static
name|void
name|kname
parameter_list|(
name|Proto
modifier|*
name|p
parameter_list|,
name|int
name|pc
parameter_list|,
name|int
name|c
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
if|if
condition|(
name|ISK
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* is 'c' a constant? */
name|TValue
modifier|*
name|kvalue
init|=
operator|&
name|p
operator|->
name|k
index|[
name|INDEXK
argument_list|(
name|c
argument_list|)
index|]
decl_stmt|;
if|if
condition|(
name|ttisstring
argument_list|(
name|kvalue
argument_list|)
condition|)
block|{
comment|/* literal constant? */
operator|*
name|name
operator|=
name|svalue
argument_list|(
name|kvalue
argument_list|)
expr_stmt|;
comment|/* it is its own name */
return|return;
block|}
comment|/* else no reasonable name found */
block|}
else|else
block|{
comment|/* 'c' is a register */
specifier|const
name|char
modifier|*
name|what
init|=
name|getobjname
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
name|c
argument_list|,
name|name
argument_list|)
decl_stmt|;
comment|/* search for 'c' */
if|if
condition|(
name|what
operator|&&
operator|*
name|what
operator|==
literal|'c'
condition|)
block|{
comment|/* found a constant name? */
return|return;
comment|/* 'name' already filled */
block|}
comment|/* else no reasonable name found */
block|}
operator|*
name|name
operator|=
literal|"?"
expr_stmt|;
comment|/* no reasonable name found */
block|}
end_function

begin_function
specifier|static
name|int
name|filterpc
parameter_list|(
name|int
name|pc
parameter_list|,
name|int
name|jmptarget
parameter_list|)
block|{
if|if
condition|(
name|pc
operator|<
name|jmptarget
condition|)
comment|/* is code conditional (inside a jump)? */
return|return
operator|-
literal|1
return|;
comment|/* cannot know who sets that register */
else|else
return|return
name|pc
return|;
comment|/* current position sets that register */
block|}
end_function

begin_comment
comment|/* ** try to find last instruction before 'lastpc' that modified register 'reg' */
end_comment

begin_function
specifier|static
name|int
name|findsetreg
parameter_list|(
name|Proto
modifier|*
name|p
parameter_list|,
name|int
name|lastpc
parameter_list|,
name|int
name|reg
parameter_list|)
block|{
name|int
name|pc
decl_stmt|;
name|int
name|setreg
init|=
operator|-
literal|1
decl_stmt|;
comment|/* keep last instruction that changed 'reg' */
name|int
name|jmptarget
init|=
literal|0
decl_stmt|;
comment|/* any code before this address is conditional */
for|for
control|(
name|pc
operator|=
literal|0
init|;
name|pc
operator|<
name|lastpc
condition|;
name|pc
operator|++
control|)
block|{
name|Instruction
name|i
init|=
name|p
operator|->
name|code
index|[
name|pc
index|]
decl_stmt|;
name|OpCode
name|op
init|=
name|GET_OPCODE
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|a
init|=
name|GETARG_A
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_LOADNIL
case|:
block|{
name|int
name|b
init|=
name|GETARG_B
argument_list|(
name|i
argument_list|)
decl_stmt|;
if|if
condition|(
name|a
operator|<=
name|reg
operator|&&
name|reg
operator|<=
name|a
operator|+
name|b
condition|)
comment|/* set registers from 'a' to 'a+b' */
name|setreg
operator|=
name|filterpc
argument_list|(
name|pc
argument_list|,
name|jmptarget
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_TFORCALL
case|:
block|{
if|if
condition|(
name|reg
operator|>=
name|a
operator|+
literal|2
condition|)
comment|/* affect all regs above its base */
name|setreg
operator|=
name|filterpc
argument_list|(
name|pc
argument_list|,
name|jmptarget
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_CALL
case|:
case|case
name|OP_TAILCALL
case|:
block|{
if|if
condition|(
name|reg
operator|>=
name|a
condition|)
comment|/* affect all registers above base */
name|setreg
operator|=
name|filterpc
argument_list|(
name|pc
argument_list|,
name|jmptarget
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|OP_JMP
case|:
block|{
name|int
name|b
init|=
name|GETARG_sBx
argument_list|(
name|i
argument_list|)
decl_stmt|;
name|int
name|dest
init|=
name|pc
operator|+
literal|1
operator|+
name|b
decl_stmt|;
comment|/* jump is forward and do not skip `lastpc'? */
if|if
condition|(
name|pc
operator|<
name|dest
operator|&&
name|dest
operator|<=
name|lastpc
condition|)
block|{
if|if
condition|(
name|dest
operator|>
name|jmptarget
condition|)
name|jmptarget
operator|=
name|dest
expr_stmt|;
comment|/* update 'jmptarget' */
block|}
break|break;
block|}
case|case
name|OP_TEST
case|:
block|{
if|if
condition|(
name|reg
operator|==
name|a
condition|)
comment|/* jumped code can change 'a' */
name|setreg
operator|=
name|filterpc
argument_list|(
name|pc
argument_list|,
name|jmptarget
argument_list|)
expr_stmt|;
break|break;
block|}
default|default:
if|if
condition|(
name|testAMode
argument_list|(
name|op
argument_list|)
operator|&&
name|reg
operator|==
name|a
condition|)
comment|/* any instruction that set A */
name|setreg
operator|=
name|filterpc
argument_list|(
name|pc
argument_list|,
name|jmptarget
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
name|setreg
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getobjname
parameter_list|(
name|Proto
modifier|*
name|p
parameter_list|,
name|int
name|lastpc
parameter_list|,
name|int
name|reg
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|int
name|pc
decl_stmt|;
operator|*
name|name
operator|=
name|luaF_getlocalname
argument_list|(
name|p
argument_list|,
name|reg
operator|+
literal|1
argument_list|,
name|lastpc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|name
condition|)
comment|/* is a local? */
return|return
literal|"local"
return|;
comment|/* else try symbolic execution */
name|pc
operator|=
name|findsetreg
argument_list|(
name|p
argument_list|,
name|lastpc
argument_list|,
name|reg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* could find instruction? */
name|Instruction
name|i
init|=
name|p
operator|->
name|code
index|[
name|pc
index|]
decl_stmt|;
name|OpCode
name|op
init|=
name|GET_OPCODE
argument_list|(
name|i
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|op
condition|)
block|{
case|case
name|OP_MOVE
case|:
block|{
name|int
name|b
init|=
name|GETARG_B
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* move from 'b' to 'a' */
if|if
condition|(
name|b
operator|<
name|GETARG_A
argument_list|(
name|i
argument_list|)
condition|)
return|return
name|getobjname
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
name|b
argument_list|,
name|name
argument_list|)
return|;
comment|/* get name for 'b' */
break|break;
block|}
case|case
name|OP_GETTABUP
case|:
case|case
name|OP_GETTABLE
case|:
block|{
name|int
name|k
init|=
name|GETARG_C
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* key index */
name|int
name|t
init|=
name|GETARG_B
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* table index */
specifier|const
name|char
modifier|*
name|vn
init|=
operator|(
name|op
operator|==
name|OP_GETTABLE
operator|)
comment|/* name of indexed variable */
condition|?
name|luaF_getlocalname
argument_list|(
name|p
argument_list|,
name|t
operator|+
literal|1
argument_list|,
name|pc
argument_list|)
else|:
name|upvalname
argument_list|(
name|p
argument_list|,
name|t
argument_list|)
decl_stmt|;
name|kname
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
name|k
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|vn
operator|&&
name|strcmp
argument_list|(
name|vn
argument_list|,
name|LUA_ENV
argument_list|)
operator|==
literal|0
operator|)
condition|?
literal|"global"
else|:
literal|"field"
return|;
block|}
case|case
name|OP_GETUPVAL
case|:
block|{
operator|*
name|name
operator|=
name|upvalname
argument_list|(
name|p
argument_list|,
name|GETARG_B
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|"upvalue"
return|;
block|}
case|case
name|OP_LOADK
case|:
case|case
name|OP_LOADKX
case|:
block|{
name|int
name|b
init|=
operator|(
name|op
operator|==
name|OP_LOADK
operator|)
condition|?
name|GETARG_Bx
argument_list|(
name|i
argument_list|)
else|:
name|GETARG_Ax
argument_list|(
name|p
operator|->
name|code
index|[
name|pc
operator|+
literal|1
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|ttisstring
argument_list|(
operator|&
name|p
operator|->
name|k
index|[
name|b
index|]
argument_list|)
condition|)
block|{
operator|*
name|name
operator|=
name|svalue
argument_list|(
operator|&
name|p
operator|->
name|k
index|[
name|b
index|]
argument_list|)
expr_stmt|;
return|return
literal|"constant"
return|;
block|}
break|break;
block|}
case|case
name|OP_SELF
case|:
block|{
name|int
name|k
init|=
name|GETARG_C
argument_list|(
name|i
argument_list|)
decl_stmt|;
comment|/* key index */
name|kname
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
name|k
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
literal|"method"
return|;
block|}
default|default:
break|break;
comment|/* go through to return NULL */
block|}
block|}
return|return
name|NULL
return|;
comment|/* could not find reasonable name */
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getfuncname
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|CallInfo
modifier|*
name|ci
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|TMS
name|tm
decl_stmt|;
name|Proto
modifier|*
name|p
init|=
name|ci_func
argument_list|(
name|ci
argument_list|)
operator|->
name|p
decl_stmt|;
comment|/* calling function */
name|int
name|pc
init|=
name|currentpc
argument_list|(
name|ci
argument_list|)
decl_stmt|;
comment|/* calling instruction index */
name|Instruction
name|i
init|=
name|p
operator|->
name|code
index|[
name|pc
index|]
decl_stmt|;
comment|/* calling instruction */
switch|switch
condition|(
name|GET_OPCODE
argument_list|(
name|i
argument_list|)
condition|)
block|{
case|case
name|OP_CALL
case|:
case|case
name|OP_TAILCALL
case|:
comment|/* get function name */
return|return
name|getobjname
argument_list|(
name|p
argument_list|,
name|pc
argument_list|,
name|GETARG_A
argument_list|(
name|i
argument_list|)
argument_list|,
name|name
argument_list|)
return|;
case|case
name|OP_TFORCALL
case|:
block|{
comment|/* for iterator */
operator|*
name|name
operator|=
literal|"for iterator"
expr_stmt|;
return|return
literal|"for iterator"
return|;
block|}
comment|/* all other instructions can call only through metamethods */
case|case
name|OP_SELF
case|:
case|case
name|OP_GETTABUP
case|:
case|case
name|OP_GETTABLE
case|:
name|tm
operator|=
name|TM_INDEX
expr_stmt|;
break|break;
case|case
name|OP_SETTABUP
case|:
case|case
name|OP_SETTABLE
case|:
name|tm
operator|=
name|TM_NEWINDEX
expr_stmt|;
break|break;
case|case
name|OP_EQ
case|:
name|tm
operator|=
name|TM_EQ
expr_stmt|;
break|break;
case|case
name|OP_ADD
case|:
name|tm
operator|=
name|TM_ADD
expr_stmt|;
break|break;
case|case
name|OP_SUB
case|:
name|tm
operator|=
name|TM_SUB
expr_stmt|;
break|break;
case|case
name|OP_MUL
case|:
name|tm
operator|=
name|TM_MUL
expr_stmt|;
break|break;
case|case
name|OP_DIV
case|:
name|tm
operator|=
name|TM_DIV
expr_stmt|;
break|break;
case|case
name|OP_MOD
case|:
name|tm
operator|=
name|TM_MOD
expr_stmt|;
break|break;
case|case
name|OP_POW
case|:
name|tm
operator|=
name|TM_POW
expr_stmt|;
break|break;
case|case
name|OP_UNM
case|:
name|tm
operator|=
name|TM_UNM
expr_stmt|;
break|break;
case|case
name|OP_LEN
case|:
name|tm
operator|=
name|TM_LEN
expr_stmt|;
break|break;
case|case
name|OP_LT
case|:
name|tm
operator|=
name|TM_LT
expr_stmt|;
break|break;
case|case
name|OP_LE
case|:
name|tm
operator|=
name|TM_LE
expr_stmt|;
break|break;
case|case
name|OP_CONCAT
case|:
name|tm
operator|=
name|TM_CONCAT
expr_stmt|;
break|break;
default|default:
return|return
name|NULL
return|;
comment|/* else no useful name can be found */
block|}
operator|*
name|name
operator|=
name|getstr
argument_list|(
name|G
argument_list|(
name|L
argument_list|)
operator|->
name|tmname
index|[
name|tm
index|]
argument_list|)
expr_stmt|;
return|return
literal|"metamethod"
return|;
block|}
end_function

begin_comment
comment|/* }====================================================== */
end_comment

begin_comment
comment|/* ** only ANSI way to check whether a pointer points to an array ** (used only for error messages, so efficiency is not a big concern) */
end_comment

begin_function
specifier|static
name|int
name|isinstack
parameter_list|(
name|CallInfo
modifier|*
name|ci
parameter_list|,
specifier|const
name|TValue
modifier|*
name|o
parameter_list|)
block|{
name|StkId
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
init|;
name|p
operator|<
name|ci
operator|->
name|top
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|o
operator|==
name|p
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getupvalname
parameter_list|(
name|CallInfo
modifier|*
name|ci
parameter_list|,
specifier|const
name|TValue
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|name
parameter_list|)
block|{
name|LClosure
modifier|*
name|c
init|=
name|ci_func
argument_list|(
name|ci
argument_list|)
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|nupvalues
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|->
name|upvals
index|[
name|i
index|]
operator|->
name|v
operator|==
name|o
condition|)
block|{
operator|*
name|name
operator|=
name|upvalname
argument_list|(
name|c
operator|->
name|p
argument_list|,
name|i
argument_list|)
expr_stmt|;
return|return
literal|"upvalue"
return|;
block|}
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_function
name|l_noret
name|luaG_typeerror
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|o
parameter_list|,
specifier|const
name|char
modifier|*
name|op
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|NULL
decl_stmt|;
specifier|const
name|char
modifier|*
name|t
init|=
name|objtypename
argument_list|(
name|o
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|kind
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isLua
argument_list|(
name|ci
argument_list|)
condition|)
block|{
name|kind
operator|=
name|getupvalname
argument_list|(
name|ci
argument_list|,
name|o
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
comment|/* check whether 'o' is an upvalue */
if|if
condition|(
operator|!
name|kind
operator|&&
name|isinstack
argument_list|(
name|ci
argument_list|,
name|o
argument_list|)
condition|)
comment|/* no? try a register */
name|kind
operator|=
name|getobjname
argument_list|(
name|ci_func
argument_list|(
name|ci
argument_list|)
operator|->
name|p
argument_list|,
name|currentpc
argument_list|(
name|ci
argument_list|)
argument_list|,
name|cast_int
argument_list|(
name|o
operator|-
name|ci
operator|->
name|u
operator|.
name|l
operator|.
name|base
argument_list|)
argument_list|,
operator|&
name|name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|kind
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to %s %s "
name|LUA_QS
literal|" (a %s value)"
argument_list|,
name|op
argument_list|,
name|kind
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
expr_stmt|;
else|else
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to %s a %s value"
argument_list|,
name|op
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|l_noret
name|luaG_concaterror
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
name|StkId
name|p1
parameter_list|,
name|StkId
name|p2
parameter_list|)
block|{
if|if
condition|(
name|ttisstring
argument_list|(
name|p1
argument_list|)
operator|||
name|ttisnumber
argument_list|(
name|p1
argument_list|)
condition|)
name|p1
operator|=
name|p2
expr_stmt|;
name|lua_assert
argument_list|(
operator|!
name|ttisstring
argument_list|(
name|p1
argument_list|)
operator|&&
operator|!
name|ttisnumber
argument_list|(
name|p1
argument_list|)
argument_list|)
expr_stmt|;
name|luaG_typeerror
argument_list|(
name|L
argument_list|,
name|p1
argument_list|,
literal|"concatenate"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|l_noret
name|luaG_aritherror
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p1
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p2
parameter_list|)
block|{
name|TValue
name|temp
decl_stmt|;
if|if
condition|(
name|luaV_tonumber
argument_list|(
name|p1
argument_list|,
operator|&
name|temp
argument_list|)
operator|==
name|NULL
condition|)
name|p2
operator|=
name|p1
expr_stmt|;
comment|/* first operand is wrong */
name|luaG_typeerror
argument_list|(
name|L
argument_list|,
name|p2
argument_list|,
literal|"perform arithmetic on"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|l_noret
name|luaG_ordererror
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p1
parameter_list|,
specifier|const
name|TValue
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|t1
init|=
name|objtypename
argument_list|(
name|p1
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|t2
init|=
name|objtypename
argument_list|(
name|p2
argument_list|)
decl_stmt|;
if|if
condition|(
name|t1
operator|==
name|t2
condition|)
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to compare two %s values"
argument_list|,
name|t1
argument_list|)
expr_stmt|;
else|else
name|luaG_runerror
argument_list|(
name|L
argument_list|,
literal|"attempt to compare %s with %s"
argument_list|,
name|t1
argument_list|,
name|t2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|addinfo
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|CallInfo
modifier|*
name|ci
init|=
name|L
operator|->
name|ci
decl_stmt|;
if|if
condition|(
name|isLua
argument_list|(
name|ci
argument_list|)
condition|)
block|{
comment|/* is Lua code? */
name|char
name|buff
index|[
name|LUA_IDSIZE
index|]
decl_stmt|;
comment|/* add file:line information */
name|int
name|line
init|=
name|currentline
argument_list|(
name|ci
argument_list|)
decl_stmt|;
name|TString
modifier|*
name|src
init|=
name|ci_func
argument_list|(
name|ci
argument_list|)
operator|->
name|p
operator|->
name|source
decl_stmt|;
if|if
condition|(
name|src
condition|)
name|luaO_chunkid
argument_list|(
name|buff
argument_list|,
name|getstr
argument_list|(
name|src
argument_list|)
argument_list|,
name|LUA_IDSIZE
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* no source available; use "?" instead */
name|buff
index|[
literal|0
index|]
operator|=
literal|'?'
expr_stmt|;
name|buff
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
name|luaO_pushfstring
argument_list|(
name|L
argument_list|,
literal|"%s:%d: %s"
argument_list|,
name|buff
argument_list|,
name|line
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|l_noret
name|luaG_errormsg
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|)
block|{
if|if
condition|(
name|L
operator|->
name|errfunc
operator|!=
literal|0
condition|)
block|{
comment|/* is there an error handling function? */
name|StkId
name|errfunc
init|=
name|restorestack
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|errfunc
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|ttisfunction
argument_list|(
name|errfunc
argument_list|)
condition|)
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|LUA_ERRERR
argument_list|)
expr_stmt|;
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
argument_list|,
name|L
operator|->
name|top
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/* move argument */
name|setobjs2s
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|-
literal|1
argument_list|,
name|errfunc
argument_list|)
expr_stmt|;
comment|/* push function */
name|L
operator|->
name|top
operator|++
expr_stmt|;
name|luaD_call
argument_list|(
name|L
argument_list|,
name|L
operator|->
name|top
operator|-
literal|2
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* call it */
block|}
name|luaD_throw
argument_list|(
name|L
argument_list|,
name|LUA_ERRRUN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|l_noret
name|luaG_runerror
parameter_list|(
name|lua_State
modifier|*
name|L
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|argp
decl_stmt|;
name|va_start
argument_list|(
name|argp
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|addinfo
argument_list|(
name|L
argument_list|,
name|luaO_pushvfstring
argument_list|(
name|L
argument_list|,
name|fmt
argument_list|,
name|argp
argument_list|)
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|argp
argument_list|)
expr_stmt|;
name|luaG_errormsg
argument_list|(
name|L
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

