begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright 2011 Nexenta Systems, Inc. All rights reserved.  * Copyright (c) 2011, 2015 by Delphix. All rights reserved.  * Copyright 2017 Joyent, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/utsname.h>
end_include

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/zone.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Pool configuration repository.  *  * Pool configuration is stored as a packed nvlist on the filesystem.  By  * default, all pools are stored in /etc/zfs/zpool.cache and loaded on boot  * (when the ZFS module is loaded).  Pools can also have the 'cachefile'  * property set that allows them to be stored in an alternate location until  * the control of external software.  *  * For each cache file, we have a single nvlist which holds all the  * configuration information.  When the module loads, we read this information  * from /etc/zfs/zpool.cache and populate the SPA namespace.  This namespace is  * maintained independently in spa.c.  Whenever the namespace is modified, or  * the configuration of a pool is changed, we call spa_config_sync(), which  * walks through all the active pools and writes the configuration to disk.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|spa_config_generation
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This can be overridden in userland to preserve an alternate namespace for  * userland pools when doing testing.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|spa_config_path
init|=
name|ZPOOL_CACHE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Called when the module is first loaded, this routine loads the configuration  * file into the SPA namespace.  It does not actually open or load the pools; it  * only populates the namespace.  */
end_comment

begin_function
name|void
name|spa_config_load
parameter_list|(
name|void
parameter_list|)
block|{
name|void
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|nvlist
decl_stmt|,
modifier|*
name|child
decl_stmt|;
name|nvpair_t
modifier|*
name|nvpair
decl_stmt|;
name|char
modifier|*
name|pathname
decl_stmt|;
name|struct
name|_buf
modifier|*
name|file
decl_stmt|;
name|uint64_t
name|fsize
decl_stmt|;
comment|/* 	 * Open the configuration file. 	 */
name|pathname
operator|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pathname
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s%s"
argument_list|,
operator|(
name|rootdir
operator|!=
name|NULL
operator|)
condition|?
literal|"./"
else|:
literal|""
argument_list|,
name|spa_config_path
argument_list|)
expr_stmt|;
name|file
operator|=
name|kobj_open_file
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|pathname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
if|if
condition|(
name|file
operator|==
operator|(
expr|struct
name|_buf
operator|*
operator|)
operator|-
literal|1
condition|)
return|return;
if|if
condition|(
name|kobj_get_filesize
argument_list|(
name|file
argument_list|,
operator|&
name|fsize
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|fsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Read the nvlist from the file. 	 */
if|if
condition|(
name|kobj_read_file
argument_list|(
name|file
argument_list|,
name|buf
argument_list|,
name|fsize
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Unpack the nvlist. 	 */
if|if
condition|(
name|nvlist_unpack
argument_list|(
name|buf
argument_list|,
name|fsize
argument_list|,
operator|&
name|nvlist
argument_list|,
name|KM_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Iterate over all elements in the nvlist, creating a new spa_t for 	 * each one with the specified configuration. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|nvpair
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|nvpair
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvlist
argument_list|,
name|nvpair
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvpair_type
argument_list|(
name|nvpair
argument_list|)
operator|!=
name|DATA_TYPE_NVLIST
condition|)
continue|continue;
name|child
operator|=
name|fnvpair_value_nvlist
argument_list|(
name|nvpair
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|nvpair_name
argument_list|(
name|nvpair
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
continue|continue;
operator|(
name|void
operator|)
name|spa_add
argument_list|(
name|nvpair_name
argument_list|(
name|nvpair
argument_list|)
argument_list|,
name|child
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvlist
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|fsize
argument_list|)
expr_stmt|;
name|kobj_close_file
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_config_write
parameter_list|(
name|spa_config_dirent_t
modifier|*
name|dp
parameter_list|,
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|size_t
name|buflen
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|int
name|oflags
init|=
name|FWRITE
operator||
name|FTRUNC
operator||
name|FCREAT
operator||
name|FOFFMAX
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * If the nvlist is empty (NULL), then remove the old cachefile. 	 */
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|vn_remove
argument_list|(
name|dp
operator|->
name|scd_path
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|RMFILE
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * Pack the configuration into a buffer. 	 */
name|buf
operator|=
name|fnvlist_pack
argument_list|(
name|nvl
argument_list|,
operator|&
name|buflen
argument_list|)
expr_stmt|;
name|temp
operator|=
name|kmem_zalloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Write the configuration to disk.  We need to do the traditional 	 * 'write to temporary file, sync, move over original' to make sure we 	 * always have a consistent view of the data. 	 */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|temp
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s.tmp"
argument_list|,
name|dp
operator|->
name|scd_path
argument_list|)
expr_stmt|;
name|err
operator|=
name|vn_open
argument_list|(
name|temp
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|oflags
argument_list|,
literal|0644
argument_list|,
operator|&
name|vp
argument_list|,
name|CRCREAT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|vn_rdwr
argument_list|(
name|UIO_WRITE
argument_list|,
name|vp
argument_list|,
name|buf
argument_list|,
name|buflen
argument_list|,
literal|0
argument_list|,
name|UIO_SYSSPACE
argument_list|,
literal|0
argument_list|,
name|RLIM64_INFINITY
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|VOP_FSYNC
argument_list|(
name|vp
argument_list|,
name|FSYNC
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|vn_rename
argument_list|(
name|temp
argument_list|,
name|dp
operator|->
name|scd_path
argument_list|,
name|UIO_SYSSPACE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|oflags
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|vn_remove
argument_list|(
name|temp
argument_list|,
name|UIO_SYSSPACE
argument_list|,
name|RMFILE
argument_list|)
expr_stmt|;
name|fnvlist_pack_free
argument_list|(
name|buf
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|temp
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Synchronize pool configuration to disk.  This must be called with the  * namespace lock held. Synchronizing the pool cache is typically done after  * the configuration has been synced to the MOS. This exposes a window where  * the MOS config will have been updated but the cache file has not. If  * the system were to crash at that instant then the cached config may not  * contain the correct information to open the pool and an explicity import  * would be required.  */
end_comment

begin_function
name|void
name|spa_config_sync
parameter_list|(
name|spa_t
modifier|*
name|target
parameter_list|,
name|boolean_t
name|removing
parameter_list|,
name|boolean_t
name|postsysevent
parameter_list|)
block|{
name|spa_config_dirent_t
modifier|*
name|dp
decl_stmt|,
modifier|*
name|tdp
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|boolean_t
name|ccw_failure
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rootdir
operator|==
name|NULL
operator|||
operator|!
operator|(
name|spa_mode_global
operator|&
name|FWRITE
operator|)
condition|)
return|return;
comment|/* 	 * Iterate over all cachefiles for the pool, past or present.  When the 	 * cachefile is changed, the new one is pushed onto this list, allowing 	 * us to update previous cachefiles that no longer contain this pool. 	 */
name|ccw_failure
operator|=
name|B_FALSE
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|list_head
argument_list|(
operator|&
name|target
operator|->
name|spa_config_list
argument_list|)
init|;
name|dp
operator|!=
name|NULL
condition|;
name|dp
operator|=
name|list_next
argument_list|(
operator|&
name|target
operator|->
name|spa_config_list
argument_list|,
name|dp
argument_list|)
control|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|scd_path
operator|==
name|NULL
condition|)
continue|continue;
comment|/* 		 * Iterate over all pools, adding any matching pools to 'nvl'. 		 */
name|nvl
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Skip over our own pool if we're about to remove 			 * ourselves from the spa namespace or any pool that 			 * is readonly. Since we cannot guarantee that a 			 * readonly pool would successfully import upon reboot, 			 * we don't allow them to be written to the cache file. 			 */
if|if
condition|(
operator|(
name|spa
operator|==
name|target
operator|&&
name|removing
operator|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|spa
argument_list|)
condition|)
continue|continue;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|tdp
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_config
operator|==
name|NULL
operator|||
name|tdp
operator|->
name|scd_path
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|tdp
operator|->
name|scd_path
argument_list|,
name|dp
operator|->
name|scd_path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|nvl
operator|==
name|NULL
condition|)
name|nvl
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|nvl
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|spa
operator|->
name|spa_config
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|spa_config_write
argument_list|(
name|dp
argument_list|,
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|ccw_failure
operator|=
name|B_TRUE
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ccw_failure
condition|)
block|{
comment|/* 		 * Keep trying so that configuration data is 		 * written if/when any temporary filesystem 		 * resource issues are resolved. 		 */
if|if
condition|(
name|target
operator|->
name|spa_ccw_fail_time
operator|==
literal|0
condition|)
block|{
name|zfs_ereport_post
argument_list|(
name|FM_EREPORT_ZFS_CONFIG_CACHE_WRITE
argument_list|,
name|target
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|target
operator|->
name|spa_ccw_fail_time
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|spa_async_request
argument_list|(
name|target
argument_list|,
name|SPA_ASYNC_CONFIG_UPDATE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Do not rate limit future attempts to update 		 * the config cache. 		 */
name|target
operator|->
name|spa_ccw_fail_time
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * Remove any config entries older than the current one. 	 */
name|dp
operator|=
name|list_head
argument_list|(
operator|&
name|target
operator|->
name|spa_config_list
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|tdp
operator|=
name|list_next
argument_list|(
operator|&
name|target
operator|->
name|spa_config_list
argument_list|,
name|dp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|target
operator|->
name|spa_config_list
argument_list|,
name|tdp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdp
operator|->
name|scd_path
operator|!=
name|NULL
condition|)
name|spa_strfree
argument_list|(
name|tdp
operator|->
name|scd_path
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tdp
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_config_dirent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_config_generation
operator|++
expr_stmt|;
if|if
condition|(
name|postsysevent
condition|)
name|spa_event_notify
argument_list|(
name|target
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_CONFIG_SYNC
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sigh.  Inside a local zone, we don't have access to /etc/zfs/zpool.cache,  * and we don't want to allow the local zone to see all the pools anyway.  * So we have to invent the ZFS_IOC_CONFIG ioctl to grab the configuration  * information for all pool visible within the zone.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|spa_all_configs
parameter_list|(
name|uint64_t
modifier|*
name|generation
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|pools
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
if|if
condition|(
operator|*
name|generation
operator|==
name|spa_config_generation
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|pools
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|INGLOBALZONE
argument_list|(
name|curproc
argument_list|)
operator|||
name|zone_dataset_visible
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|pools
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|spa
operator|->
name|spa_config
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|generation
operator|=
name|spa_config_generation
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|pools
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_config_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config
operator|=
name|config
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Generate the pool's configuration based on the current in-core state.  *  * We infer whether to generate a complete config or just one top-level config  * based on whether vd is the root vdev.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|spa_config_generate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|getstats
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|unsigned
name|long
name|hostid
init|=
literal|0
decl_stmt|;
name|boolean_t
name|locked
init|=
name|B_FALSE
decl_stmt|;
name|uint64_t
name|split_guid
decl_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
block|{
name|vd
operator|=
name|rvd
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|RW_READER
argument_list|)
operator|==
operator|(
name|SCL_CONFIG
operator||
name|SCL_STATE
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * If txg is -1, report the current value of spa->spa_config_txg. 	 */
if|if
condition|(
name|txg
operator|==
operator|-
literal|1ULL
condition|)
name|txg
operator|=
name|spa
operator|->
name|spa_config_txg
expr_stmt|;
name|config
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|fnvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|spa_state
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_comment
operator|!=
name|NULL
condition|)
block|{
name|fnvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_COMMENT
argument_list|,
name|spa
operator|->
name|spa_comment
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|_KERNEL
name|hostid
operator|=
name|zone_get_hostid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _KERNEL */
comment|/* 	 * We're emulating the system's hostid in userland, so we can't use 	 * zone_get_hostid(). 	 */
operator|(
name|void
operator|)
name|ddi_strtoul
argument_list|(
name|hw_serial
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|,
operator|&
name|hostid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
if|if
condition|(
name|hostid
operator|!=
literal|0
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
name|hostid
argument_list|)
expr_stmt|;
block|}
name|fnvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|)
expr_stmt|;
name|int
name|config_gen_flags
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|!=
name|rvd
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TOP_GUID
argument_list|,
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_guid
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_isspare
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_IS_SPARE
argument_list|,
literal|1ULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_islog
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_IS_LOG
argument_list|,
literal|1ULL
argument_list|)
expr_stmt|;
block|}
name|vd
operator|=
name|vd
operator|->
name|vdev_top
expr_stmt|;
comment|/* label contains top config */
block|}
else|else
block|{
comment|/* 		 * Only add the (potentially large) split information 		 * in the mos config, and not in the vdev labels 		 */
if|if
condition|(
name|spa
operator|->
name|spa_config_splitting
operator|!=
name|NULL
condition|)
name|fnvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_SPLIT
argument_list|,
name|spa
operator|->
name|spa_config_splitting
argument_list|)
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HAS_PER_VDEV_ZAPS
argument_list|)
expr_stmt|;
name|config_gen_flags
operator||=
name|VDEV_CONFIG_MOS
expr_stmt|;
block|}
comment|/* 	 * Add the top-level config.  We even add this on pools which 	 * don't support holes in the namespace. 	 */
name|vdev_top_config_generate
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
comment|/* 	 * If we're splitting, record the original pool's guid. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_config_splitting
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|spa
operator|->
name|spa_config_splitting
argument_list|,
name|ZPOOL_CONFIG_SPLIT_GUID
argument_list|,
operator|&
name|split_guid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_SPLIT_GUID
argument_list|,
name|split_guid
argument_list|)
expr_stmt|;
block|}
name|nvroot
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|getstats
argument_list|,
name|config_gen_flags
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|nvroot
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
comment|/* 	 * Store what's necessary for reading the MOS in the label. 	 */
name|fnvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_FEATURES_FOR_READ
argument_list|,
name|spa
operator|->
name|spa_label_features
argument_list|)
expr_stmt|;
if|if
condition|(
name|getstats
operator|&&
name|spa_load_state
argument_list|(
name|spa
argument_list|)
operator|==
name|SPA_LOAD_NONE
condition|)
block|{
name|ddt_histogram_t
modifier|*
name|ddh
decl_stmt|;
name|ddt_stat_t
modifier|*
name|dds
decl_stmt|;
name|ddt_object_t
modifier|*
name|ddo
decl_stmt|;
name|ddh
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ddt_histogram_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ddt_get_dedup_histogram
argument_list|(
name|spa
argument_list|,
name|ddh
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_DDT_HISTOGRAM
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
name|ddh
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ddh
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ddh
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_histogram_t
argument_list|)
argument_list|)
expr_stmt|;
name|ddo
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ddt_object_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ddt_get_dedup_object_stats
argument_list|(
name|spa
argument_list|,
name|ddo
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_DDT_OBJ_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
name|ddo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ddo
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ddo
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_object_t
argument_list|)
argument_list|)
expr_stmt|;
name|dds
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|ddt_stat_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ddt_get_dedup_stats
argument_list|(
name|spa
argument_list|,
name|dds
argument_list|)
expr_stmt|;
name|fnvlist_add_uint64_array
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_DDT_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|)
name|dds
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|dds
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dds
argument_list|,
sizeof|sizeof
argument_list|(
name|ddt_stat_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked
condition|)
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Update all disk labels, generate a fresh config based on the current  * in-core state, and sync the global config cache (do not sync the config  * cache if this is a booting rootpool).  */
end_comment

begin_function
name|void
name|spa_config_update
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|what
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|SPA_CONFIG_UPDATE_POOL
condition|)
block|{
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we have top-level vdevs that were added but have 		 * not yet been prepared for allocation, do that now. 		 * (It's safe now because the config cache is up to date, 		 * so it will be able to translate the new DVAs.) 		 * See comments in spa_vdev_add() for full details. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_ms_array
operator|==
literal|0
condition|)
name|vdev_metaslab_set_size
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
name|vdev_expand
argument_list|(
name|tvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Wait for the mosconfig to be regenerated and synced. 	 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Update the global config cache to reflect the new mosconfig. 	 */
if|if
condition|(
operator|!
name|spa
operator|->
name|spa_is_root
condition|)
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|what
operator|!=
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|what
operator|==
name|SPA_CONFIG_UPDATE_POOL
condition|)
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_VDEVS
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

