begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Portions Copyright 2011 Martin Matuska  * Copyright (c) 2012, 2017 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_comment
comment|/*  * ZFS Transaction Groups  * ----------------------  *  * ZFS transaction groups are, as the name implies, groups of transactions  * that act on persistent state. ZFS asserts consistency at the granularity of  * these transaction groups. Each successive transaction group (txg) is  * assigned a 64-bit consecutive identifier. There are three active  * transaction group states: open, quiescing, or syncing. At any given time,  * there may be an active txg associated with each state; each active txg may  * either be processing, or blocked waiting to enter the next state. There may  * be up to three active txgs, and there is always a txg in the open state  * (though it may be blocked waiting to enter the quiescing state). In broad  * strokes, transactions -- operations that change in-memory structures -- are  * accepted into the txg in the open state, and are completed while the txg is  * in the open or quiescing states. The accumulated changes are written to  * disk in the syncing state.  *  * Open  *  * When a new txg becomes active, it first enters the open state. New  * transactions -- updates to in-memory structures -- are assigned to the  * currently open txg. There is always a txg in the open state so that ZFS can  * accept new changes (though the txg may refuse new changes if it has hit  * some limit). ZFS advances the open txg to the next state for a variety of  * reasons such as it hitting a time or size threshold, or the execution of an  * administrative action that must be completed in the syncing state.  *  * Quiescing  *  * After a txg exits the open state, it enters the quiescing state. The  * quiescing state is intended to provide a buffer between accepting new  * transactions in the open state and writing them out to stable storage in  * the syncing state. While quiescing, transactions can continue their  * operation without delaying either of the other states. Typically, a txg is  * in the quiescing state very briefly since the operations are bounded by  * software latencies rather than, say, slower I/O latencies. After all  * transactions complete, the txg is ready to enter the next state.  *  * Syncing  *  * In the syncing state, the in-memory state built up during the open and (to  * a lesser degree) the quiescing states is written to stable storage. The  * process of writing out modified data can, in turn modify more data. For  * example when we write new blocks, we need to allocate space for them; those  * allocations modify metadata (space maps)... which themselves must be  * written to stable storage. During the sync state, ZFS iterates, writing out  * data until it converges and all in-memory changes have been written out.  * The first such pass is the largest as it encompasses all the modified user  * data (as opposed to filesystem metadata). Subsequent passes typically have  * far less data to write as they consist exclusively of filesystem metadata.  *  * To ensure convergence, after a certain number of passes ZFS begins  * overwriting locations on stable storage that had been allocated earlier in  * the syncing state (and subsequently freed). ZFS usually allocates new  * blocks to optimize for large, continuous, writes. For the syncing state to  * converge however it must complete a pass where no new blocks are allocated  * since each allocation requires a modification of persistent metadata.  * Further, to hasten convergence, after a prescribed number of passes, ZFS  * also defers frees, and stops compressing.  *  * In addition to writing out user data, we must also execute synctasks during  * the syncing context. A synctask is the mechanism by which some  * administrative activities work such as creating and destroying snapshots or  * datasets. Note that when a synctask is initiated it enters the open txg,  * and ZFS then pushes that txg as quickly as possible to completion of the  * syncing state in order to reduce the latency of the administrative  * activity. To complete the syncing state, ZFS writes out a new uberblock,  * the root of the tree of blocks that comprise all state stored on the ZFS  * pool. Finally, if there is a quiesced txg waiting, we signal that it can  * now transition to the syncing state.  */
end_comment

begin_function_decl
specifier|static
name|void
name|txg_sync_thread
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|txg_quiesce_thread
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|zfs_txg_timeout
init|=
literal|5
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max seconds worth of delta per txg */
end_comment

begin_comment
comment|/*  * Prepare the txg subsystem.  */
end_comment

begin_function
name|void
name|txg_init
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|int
name|c
decl_stmt|;
name|bzero
argument_list|(
name|tx
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_state_t
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_cpu
operator|=
name|kmem_zalloc
argument_list|(
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|tx_cpu_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_open_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_cv
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_callbacks
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_tx_callback_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_tx_callback_t
argument_list|,
name|dcb_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_open_txg
operator|=
name|txg
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Close down the txg subsystem.  */
end_comment

begin_function
name|void
name|txg_fini
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|int
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|int
name|i
decl_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_open_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|cv_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_cv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_callbacks
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|tx
operator|->
name|tx_commit_cb_taskq
operator|!=
name|NULL
condition|)
name|taskq_destroy
argument_list|(
name|tx
operator|->
name|tx_commit_cb_taskq
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|tx
operator|->
name|tx_cpu
argument_list|,
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|tx_cpu_t
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|tx
argument_list|,
sizeof|sizeof
argument_list|(
name|tx_state_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start syncing transaction groups.  */
end_comment

begin_function
name|void
name|txg_sync_start
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"pool %p\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_threads
operator|=
literal|2
expr_stmt|;
name|tx
operator|->
name|tx_quiesce_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|txg_quiesce_thread
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
comment|/* 	 * The sync thread can need a larger-than-default stack size on 	 * 32-bit x86.  This is due in part to nested pools and 	 * scrub_visitbp() recursion. 	 */
name|tx
operator|->
name|tx_sync_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|32
operator|<<
literal|10
argument_list|,
name|txg_sync_thread
argument_list|,
name|dp
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|minclsyspri
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txg_thread_enter
parameter_list|(
name|tx_state_t
modifier|*
name|tx
parameter_list|,
name|callb_cpr_t
modifier|*
name|cpr
parameter_list|)
block|{
name|CALLB_CPR_INIT
argument_list|(
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txg_thread_exit
parameter_list|(
name|tx_state_t
modifier|*
name|tx
parameter_list|,
name|callb_cpr_t
modifier|*
name|cpr
parameter_list|,
name|kthread_t
modifier|*
modifier|*
name|tpp
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|*
name|tpp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|tpp
operator|=
name|NULL
expr_stmt|;
name|tx
operator|->
name|tx_threads
operator|--
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
name|cpr
argument_list|)
expr_stmt|;
comment|/* drops&tx->tx_sync_lock */
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|txg_thread_wait
parameter_list|(
name|tx_state_t
modifier|*
name|tx
parameter_list|,
name|callb_cpr_t
modifier|*
name|cpr
parameter_list|,
name|kcondvar_t
modifier|*
name|cv
parameter_list|,
name|clock_t
name|time
parameter_list|)
block|{
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
name|cpr
argument_list|)
expr_stmt|;
if|if
condition|(
name|time
condition|)
operator|(
name|void
operator|)
name|cv_timedwait
argument_list|(
name|cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|ddi_get_lbolt
argument_list|()
operator|+
name|time
argument_list|)
expr_stmt|;
else|else
name|cv_wait
argument_list|(
name|cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_END
argument_list|(
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Stop syncing transaction groups.  */
end_comment

begin_function
name|void
name|txg_sync_stop
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|dprintf
argument_list|(
literal|"pool %p\n"
argument_list|,
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Finish off any work in progress. 	 */
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * We need to ensure that we've vacated the deferred space_maps. 	 */
name|txg_wait_synced
argument_list|(
name|dp
argument_list|,
name|tx
operator|->
name|tx_open_txg
operator|+
name|TXG_DEFER_SIZE
argument_list|)
expr_stmt|;
comment|/* 	 * Wake all sync threads and wait for them to die. 	 */
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_exiting
operator|=
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|tx_threads
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|tx
operator|->
name|tx_exit_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_exiting
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|txg_hold_open
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|txg_handle_t
modifier|*
name|th
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|tx_cpu_t
modifier|*
name|tc
init|=
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|CPU_SEQID
index|]
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_open_lock
argument_list|)
expr_stmt|;
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|tc
operator|->
name|tc_count
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_cpu
operator|=
name|tc
expr_stmt|;
name|th
operator|->
name|th_txg
operator|=
name|txg
expr_stmt|;
return|return
operator|(
name|txg
operator|)
return|;
block|}
end_function

begin_function
name|void
name|txg_rele_to_quiesce
parameter_list|(
name|txg_handle_t
modifier|*
name|th
parameter_list|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
name|th
operator|->
name|th_cpu
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|MUTEX_HELD
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_open_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_register_callbacks
parameter_list|(
name|txg_handle_t
modifier|*
name|th
parameter_list|,
name|list_t
modifier|*
name|tx_callbacks
parameter_list|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
name|th
operator|->
name|th_cpu
decl_stmt|;
name|int
name|g
init|=
name|th
operator|->
name|th_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
operator|&
name|tc
operator|->
name|tc_callbacks
index|[
name|g
index|]
argument_list|,
name|tx_callbacks
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_rele_to_sync
parameter_list|(
name|txg_handle_t
modifier|*
name|th
parameter_list|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
name|th
operator|->
name|th_cpu
decl_stmt|;
name|int
name|g
init|=
name|th
operator|->
name|th_txg
operator|&
name|TXG_MASK
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tc
operator|->
name|tc_count
index|[
name|g
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|tc
operator|->
name|tc_count
index|[
name|g
index|]
operator|==
literal|0
condition|)
name|cv_broadcast
argument_list|(
operator|&
name|tc
operator|->
name|tc_cv
index|[
name|g
index|]
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|th
operator|->
name|th_cpu
operator|=
name|NULL
expr_stmt|;
comment|/* defensive */
block|}
end_function

begin_comment
comment|/*  * Blocks until all transactions in the group are committed.  *  * On return, the transaction group has reached a stable state in which it can  * then be passed off to the syncing context.  */
end_comment

begin_function
specifier|static
name|void
name|txg_quiesce
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|int
name|g
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|int
name|c
decl_stmt|;
comment|/* 	 * Grab all tc_open_locks so nobody else can get into this txg. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_open_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg
operator|==
name|tx
operator|->
name|tx_open_txg
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_open_txg
operator|++
expr_stmt|;
name|tx
operator|->
name|tx_open_time
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|txg__quiescing
argument_list|,
name|dsl_pool_t
operator|*
argument_list|,
name|dp
argument_list|,
name|uint64_t
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|txg__opened
argument_list|,
name|dsl_pool_t
operator|*
argument_list|,
name|dp
argument_list|,
name|uint64_t
argument_list|,
name|tx
operator|->
name|tx_open_txg
argument_list|)
expr_stmt|;
comment|/* 	 * Now that we've incremented tx_open_txg, we can let threads 	 * enter the next transaction group. 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
operator|.
name|tc_open_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Quiesce the transaction group by waiting for everyone to txg_exit(). 	 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|tc
operator|->
name|tc_count
index|[
name|g
index|]
operator|!=
literal|0
condition|)
name|cv_wait
argument_list|(
operator|&
name|tc
operator|->
name|tc_cv
index|[
name|g
index|]
argument_list|,
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tc
operator|->
name|tc_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|txg_do_callbacks
parameter_list|(
name|list_t
modifier|*
name|cb_list
parameter_list|)
block|{
name|dmu_tx_do_callbacks
argument_list|(
name|cb_list
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
name|cb_list
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|cb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|list_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch the commit callbacks registered on this txg to worker threads.  *  * If no callbacks are registered for a given TXG, nothing happens.  * This function creates a taskq for the associated pool, if needed.  */
end_comment

begin_function
specifier|static
name|void
name|txg_dispatch_callbacks
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|list_t
modifier|*
name|cb_list
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|max_ncpus
condition|;
name|c
operator|++
control|)
block|{
name|tx_cpu_t
modifier|*
name|tc
init|=
operator|&
name|tx
operator|->
name|tx_cpu
index|[
name|c
index|]
decl_stmt|;
comment|/* 		 * No need to lock tx_cpu_t at this point, since this can 		 * only be called once a txg has been synced. 		 */
name|int
name|g
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|tc
operator|->
name|tc_callbacks
index|[
name|g
index|]
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|tx
operator|->
name|tx_commit_cb_taskq
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Commit callback taskq hasn't been created yet. 			 */
name|tx
operator|->
name|tx_commit_cb_taskq
operator|=
name|taskq_create
argument_list|(
literal|"tx_commit_cb"
argument_list|,
name|max_ncpus
argument_list|,
name|minclsyspri
argument_list|,
name|max_ncpus
argument_list|,
name|max_ncpus
operator|*
literal|2
argument_list|,
name|TASKQ_PREPOPULATE
argument_list|)
expr_stmt|;
block|}
name|cb_list
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|list_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
name|cb_list
argument_list|,
sizeof|sizeof
argument_list|(
name|dmu_tx_callback_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dmu_tx_callback_t
argument_list|,
name|dcb_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_move_tail
argument_list|(
name|cb_list
argument_list|,
operator|&
name|tc
operator|->
name|tc_callbacks
index|[
name|g
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|taskq_dispatch
argument_list|(
name|tx
operator|->
name|tx_commit_cb_taskq
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|txg_do_callbacks
argument_list|,
name|cb_list
argument_list|,
name|TQ_SLEEP
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|txg_sync_thread
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dp
operator|->
name|dp_spa
decl_stmt|;
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|callb_cpr_t
name|cpr
decl_stmt|;
name|uint64_t
name|start
decl_stmt|,
name|delta
decl_stmt|;
name|txg_thread_enter
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|)
expr_stmt|;
name|start
operator|=
name|delta
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|timeout
init|=
name|zfs_txg_timeout
operator|*
name|hz
decl_stmt|;
name|uint64_t
name|timer
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|;
comment|/* 		 * We sync when we're scanning, there's someone waiting 		 * on us, or the quiesce thread has handed off a txg to 		 * us, or we have reached our timeout. 		 */
name|timer
operator|=
operator|(
name|delta
operator|>=
name|timeout
condition|?
literal|0
else|:
name|timeout
operator|-
name|delta
operator|)
expr_stmt|;
while|while
condition|(
operator|!
name|dsl_scan_active
argument_list|(
name|dp
operator|->
name|dp_scan
argument_list|)
operator|&&
operator|!
name|tx
operator|->
name|tx_exiting
operator|&&
name|timer
operator|>
literal|0
operator|&&
name|tx
operator|->
name|tx_synced_txg
operator|>=
name|tx
operator|->
name|tx_sync_txg_waiting
operator|&&
name|tx
operator|->
name|tx_quiesced_txg
operator|==
literal|0
operator|&&
name|dp
operator|->
name|dp_dirty_total
operator|<
name|zfs_dirty_data_sync
condition|)
block|{
name|dprintf
argument_list|(
literal|"waiting; tx_synced=%llu waiting=%llu dp=%p\n"
argument_list|,
name|tx
operator|->
name|tx_synced_txg
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|txg_thread_wait
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|,
name|timer
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ddi_get_lbolt
argument_list|()
operator|-
name|start
expr_stmt|;
name|timer
operator|=
operator|(
name|delta
operator|>
name|timeout
condition|?
literal|0
else|:
name|timeout
operator|-
name|delta
operator|)
expr_stmt|;
block|}
comment|/* 		 * Wait until the quiesce thread hands off a txg to us, 		 * prompting it to do so if necessary. 		 */
while|while
condition|(
operator|!
name|tx
operator|->
name|tx_exiting
operator|&&
name|tx
operator|->
name|tx_quiesced_txg
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|<
name|tx
operator|->
name|tx_open_txg
operator|+
literal|1
condition|)
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|=
name|tx
operator|->
name|tx_open_txg
operator|+
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|txg_thread_wait
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tx
operator|->
name|tx_exiting
condition|)
name|txg_thread_exit
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_thread
argument_list|)
expr_stmt|;
comment|/* 		 * Consume the quiesced txg which has been handed off to 		 * us.  This may cause the quiescing thread to now be 		 * able to quiesce another txg, so we must signal it. 		 */
name|txg
operator|=
name|tx
operator|->
name|tx_quiesced_txg
expr_stmt|;
name|tx
operator|->
name|tx_quiesced_txg
operator|=
literal|0
expr_stmt|;
name|tx
operator|->
name|tx_syncing_txg
operator|=
name|txg
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|txg__syncing
argument_list|,
name|dsl_pool_t
operator|*
argument_list|,
name|dp
argument_list|,
name|uint64_t
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|start
operator|=
name|ddi_get_lbolt
argument_list|()
expr_stmt|;
name|spa_sync
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|delta
operator|=
name|ddi_get_lbolt
argument_list|()
operator|-
name|start
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_synced_txg
operator|=
name|txg
expr_stmt|;
name|tx
operator|->
name|tx_syncing_txg
operator|=
literal|0
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|txg__synced
argument_list|,
name|dsl_pool_t
operator|*
argument_list|,
name|dp
argument_list|,
name|uint64_t
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|)
expr_stmt|;
comment|/* 		 * Dispatch commit callbacks to worker threads. 		 */
name|txg_dispatch_callbacks
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|txg_quiesce_thread
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|callb_cpr_t
name|cpr
decl_stmt|;
name|txg_thread_enter
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|uint64_t
name|txg
decl_stmt|;
comment|/* 		 * We quiesce when there's someone waiting on us. 		 * However, we can only have one txg in "quiescing" or 		 * "quiesced, waiting to sync" state.  So we wait until 		 * the "quiesced, waiting to sync" txg has been consumed 		 * by the sync thread. 		 */
while|while
condition|(
operator|!
name|tx
operator|->
name|tx_exiting
operator|&&
operator|(
name|tx
operator|->
name|tx_open_txg
operator|>=
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|||
name|tx
operator|->
name|tx_quiesced_txg
operator|!=
literal|0
operator|)
condition|)
name|txg_thread_wait
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_exiting
condition|)
name|txg_thread_exit
argument_list|(
name|tx
argument_list|,
operator|&
name|cpr
argument_list|,
operator|&
name|tx
operator|->
name|tx_quiesce_thread
argument_list|)
expr_stmt|;
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|txg_quiesce
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Hand this txg off to the sync thread. 		 */
name|dprintf
argument_list|(
literal|"quiesce done, handing off txg %llu\n"
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|tx
operator|->
name|tx_quiesced_txg
operator|=
name|txg
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|txg__quiesced
argument_list|,
name|dsl_pool_t
operator|*
argument_list|,
name|dp
argument_list|,
name|uint64_t
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Delay this thread by delay nanoseconds if we are still in the open  * transaction group and there is already a waiting txg quiescing or quiesced.  * Abort the delay if this txg stalls or enters the quiescing state.  */
end_comment

begin_function
name|void
name|txg_delay
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|hrtime_t
name|delay
parameter_list|,
name|hrtime_t
name|resolution
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|hrtime_t
name|start
init|=
name|gethrtime
argument_list|()
decl_stmt|;
comment|/* don't delay if this txg could transition to quiescing immediately */
if|if
condition|(
name|tx
operator|->
name|tx_open_txg
operator|>
name|txg
operator|||
name|tx
operator|->
name|tx_syncing_txg
operator|==
name|txg
operator|-
literal|1
operator|||
name|tx
operator|->
name|tx_synced_txg
operator|==
name|txg
operator|-
literal|1
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_open_txg
operator|>
name|txg
operator|||
name|tx
operator|->
name|tx_synced_txg
operator|==
name|txg
operator|-
literal|1
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
name|gethrtime
argument_list|()
operator|-
name|start
operator|<
name|delay
operator|&&
name|tx
operator|->
name|tx_syncing_txg
operator|<
name|txg
operator|-
literal|1
operator|&&
operator|!
name|txg_stalled
argument_list|(
name|dp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|cv_timedwait_hires
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|,
name|delay
argument_list|,
name|resolution
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_wait_synced
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
operator|+
name|TXG_DEFER_SIZE
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_sync_txg_waiting
operator|<
name|txg
condition|)
name|tx
operator|->
name|tx_sync_txg_waiting
operator|=
name|txg
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|tx_synced_txg
operator|<
name|txg
condition|)
block|{
name|dprintf
argument_list|(
literal|"broadcasting sync more "
literal|"tx_synced=%llu waiting=%llu dp=%p\n"
argument_list|,
name|tx
operator|->
name|tx_synced_txg
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_more_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_done_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_wait_open
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_threads
operator|==
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|==
literal|0
condition|)
name|txg
operator|=
name|tx
operator|->
name|tx_open_txg
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|<
name|txg
condition|)
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|=
name|txg
expr_stmt|;
name|dprintf
argument_list|(
literal|"txg=%llu quiesce_txg=%llu sync_txg=%llu\n"
argument_list|,
name|txg
argument_list|,
name|tx
operator|->
name|tx_quiesce_txg_waiting
argument_list|,
name|tx
operator|->
name|tx_sync_txg_waiting
argument_list|)
expr_stmt|;
while|while
condition|(
name|tx
operator|->
name|tx_open_txg
operator|<
name|txg
condition|)
block|{
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_done_cv
argument_list|,
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If there isn't a txg syncing or in the pipeline, push another txg through  * the pipeline by queiscing the open txg.  */
end_comment

begin_function
name|void
name|txg_kick
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dsl_pool_config_held
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_syncing_txg
operator|==
literal|0
operator|&&
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|<=
name|tx
operator|->
name|tx_open_txg
operator|&&
name|tx
operator|->
name|tx_sync_txg_waiting
operator|<=
name|tx
operator|->
name|tx_synced_txg
operator|&&
name|tx
operator|->
name|tx_quiesced_txg
operator|<=
name|tx
operator|->
name|tx_synced_txg
condition|)
block|{
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|=
name|tx
operator|->
name|tx_open_txg
operator|+
literal|1
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|tx
operator|->
name|tx_quiesce_more_cv
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tx
operator|->
name|tx_sync_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|txg_stalled
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
return|return
operator|(
name|tx
operator|->
name|tx_quiesce_txg_waiting
operator|>
name|tx
operator|->
name|tx_open_txg
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|txg_sync_waiting
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|tx_state_t
modifier|*
name|tx
init|=
operator|&
name|dp
operator|->
name|dp_tx
decl_stmt|;
return|return
operator|(
name|tx
operator|->
name|tx_syncing_txg
operator|<=
name|tx
operator|->
name|tx_sync_txg_waiting
operator|||
name|tx
operator|->
name|tx_quiesced_txg
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Verify that this txg is active (open, quiescing, syncing).  Non-active  * txg's should not be manipulated.  */
end_comment

begin_function
name|void
name|txg_verify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
if|if
condition|(
name|txg
operator|<=
name|TXG_INITIAL
operator|||
name|txg
operator|==
name|ZILTEST_TXG
condition|)
return|return;
name|ASSERT3U
argument_list|(
name|txg
argument_list|,
operator|<=
argument_list|,
name|dp
operator|->
name|dp_tx
operator|.
name|tx_open_txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|txg
argument_list|,
operator|>=
argument_list|,
name|dp
operator|->
name|dp_tx
operator|.
name|tx_synced_txg
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|txg
argument_list|,
operator|>=
argument_list|,
name|dp
operator|->
name|dp_tx
operator|.
name|tx_open_txg
operator|-
name|TXG_CONCURRENT_STATES
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Per-txg object lists.  */
end_comment

begin_function
name|void
name|txg_list_create
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|spa_t
modifier|*
name|spa
parameter_list|,
name|size_t
name|offset
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|tl
operator|->
name|tl_offset
operator|=
name|offset
expr_stmt|;
name|tl
operator|->
name|tl_spa
operator|=
name|spa
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|void
name|txg_list_destroy
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|)
block|{
name|int
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
name|tl
argument_list|,
name|t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|txg_list_empty
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|tl
operator|->
name|tl_head
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns true if all txg lists are empty.  *  * Warning: this is inherently racy (an item could be added immediately  * after this function returns). We don't bother with the lock because  * it wouldn't change the semantics.  */
end_comment

begin_function
name|boolean_t
name|txg_all_lists_empty
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|txg_list_empty
argument_list|(
name|tl
argument_list|,
name|i
argument_list|)
condition|)
block|{
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
block|}
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an entry to the list (unless it's already on the list).  * Returns B_TRUE if it was actually added.  */
end_comment

begin_function
name|boolean_t
name|txg_list_add
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
name|boolean_t
name|add
decl_stmt|;
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
name|add
operator|=
operator|(
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|1
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
expr_stmt|;
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|=
name|tn
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|add
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add an entry to the end of the list, unless it's already on the list.  * (walks list to find end)  * Returns B_TRUE if it was actually added.  */
end_comment

begin_function
name|boolean_t
name|txg_list_add_tail
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
name|boolean_t
name|add
decl_stmt|;
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
name|add
operator|=
operator|(
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|==
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|add
condition|)
block|{
name|txg_node_t
modifier|*
modifier|*
name|tp
decl_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
init|;
operator|*
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
operator|&
operator|(
operator|*
name|tp
operator|)
operator|->
name|tn_next
index|[
name|t
index|]
control|)
continue|continue;
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|1
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|tp
operator|=
name|tn
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|add
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove the head of the list and return it.  */
end_comment

begin_function
name|void
modifier|*
name|txg_list_remove
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
decl_stmt|;
name|void
modifier|*
name|p
init|=
name|NULL
decl_stmt|;
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tn
operator|=
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|)
operator|!=
name|NULL
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
expr_stmt|;
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
operator|=
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a specific item from the list and return it.  */
end_comment

begin_function
name|void
modifier|*
name|txg_list_remove_this
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
decl_stmt|,
modifier|*
modifier|*
name|tp
decl_stmt|;
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
operator|&
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
init|;
operator|(
name|tn
operator|=
operator|*
name|tp
operator|)
operator|!=
name|NULL
condition|;
name|tp
operator|=
operator|&
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
control|)
block|{
if|if
condition|(
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
operator|==
name|p
condition|)
block|{
operator|*
name|tp
operator|=
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
expr_stmt|;
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
operator|=
name|NULL
expr_stmt|;
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|tl
operator|->
name|tl_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|txg_list_member
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|tn
operator|->
name|tn_member
index|[
name|t
index|]
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk a txg list -- only safe if you know it's not changing.  */
end_comment

begin_function
name|void
modifier|*
name|txg_list_head
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
name|tl
operator|->
name|tl_head
index|[
name|t
index|]
decl_stmt|;
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
name|tn
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
operator|)
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|txg_list_next
parameter_list|(
name|txg_list_t
modifier|*
name|tl
parameter_list|,
name|void
modifier|*
name|p
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|t
init|=
name|txg
operator|&
name|TXG_MASK
decl_stmt|;
name|txg_node_t
modifier|*
name|tn
init|=
operator|(
name|txg_node_t
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|tl
operator|->
name|tl_offset
operator|)
decl_stmt|;
name|txg_verify
argument_list|(
name|tl
operator|->
name|tl_spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|tn
operator|=
name|tn
operator|->
name|tn_next
index|[
name|t
index|]
expr_stmt|;
return|return
operator|(
name|tn
operator|==
name|NULL
condition|?
name|NULL
else|:
operator|(
name|char
operator|*
operator|)
name|tn
operator|-
name|tl
operator|->
name|tl_offset
operator|)
return|;
block|}
end_function

end_unit

