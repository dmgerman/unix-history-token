begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.  * Copyright (c) 2015, Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright 2013 Saso Kiselkov. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2016 Toomas Soome<tsoome@me.com>  */
end_comment

begin_comment
comment|/*  * SPA: Storage Pool Allocator  *  * This file contains all the routines used when modifying on-disk SPA state.  * This includes opening, importing, destroying, exporting a pool, and syncing a  * pool.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddt.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/uberblock_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/txg.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/unique.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_boot.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_destroy.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/bootprops.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpupart.h>
end_include

begin_include
include|#
directive|include
file|<sys/pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysdc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zone.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_include
include|#
directive|include
file|"zfs_prop.h"
end_include

begin_include
include|#
directive|include
file|"zfs_comutil.h"
end_include

begin_comment
comment|/*  * The interval, in seconds, at which failed configuration cache file writes  * should be retried.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|zfs_ccw_retry_interval
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
enum|enum
name|zti_modes
block|{
name|ZTI_MODE_FIXED
block|,
comment|/* value is # of threads (min 1) */
name|ZTI_MODE_BATCH
block|,
comment|/* cpu-intensive; value is ignored */
name|ZTI_MODE_NULL
block|,
comment|/* don't create a taskq */
name|ZTI_NMODES
block|}
name|zti_modes_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|ZTI_P
parameter_list|(
name|n
parameter_list|,
name|q
parameter_list|)
value|{ ZTI_MODE_FIXED, (n), (q) }
end_define

begin_define
define|#
directive|define
name|ZTI_BATCH
value|{ ZTI_MODE_BATCH, 0, 1 }
end_define

begin_define
define|#
directive|define
name|ZTI_NULL
value|{ ZTI_MODE_NULL, 0, 0 }
end_define

begin_define
define|#
directive|define
name|ZTI_N
parameter_list|(
name|n
parameter_list|)
value|ZTI_P(n, 1)
end_define

begin_define
define|#
directive|define
name|ZTI_ONE
value|ZTI_N(1)
end_define

begin_typedef
typedef|typedef
struct|struct
name|zio_taskq_info
block|{
name|zti_modes_t
name|zti_mode
decl_stmt|;
name|uint_t
name|zti_value
decl_stmt|;
name|uint_t
name|zti_count
decl_stmt|;
block|}
name|zio_taskq_info_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
specifier|const
name|zio_taskq_types
index|[
name|ZIO_TASKQ_TYPES
index|]
init|=
block|{
literal|"issue"
block|,
literal|"issue_high"
block|,
literal|"intr"
block|,
literal|"intr_high"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This table defines the taskq settings for each ZFS I/O type. When  * initializing a pool, we use this table to create an appropriately sized  * taskq. Some operations are low volume and therefore have a small, static  * number of threads assigned to their taskqs using the ZTI_N(#) or ZTI_ONE  * macros. Other operations process a large amount of data; the ZTI_BATCH  * macro causes us to create a taskq oriented for throughput. Some operations  * are so high frequency and short-lived that the taskq itself can become a a  * point of lock contention. The ZTI_P(#, #) macro indicates that we need an  * additional degree of parallelism specified by the number of threads per-  * taskq and the number of taskqs; when dispatching an event in this case, the  * particular taskq is chosen at random.  *  * The different taskq priorities are to handle the different contexts (issue  * and interrupt) and then to reserve threads for ZIO_PRIORITY_NOW I/Os that  * need to be handled with minimum delay.  */
end_comment

begin_decl_stmt
specifier|const
name|zio_taskq_info_t
name|zio_taskqs
index|[
name|ZIO_TYPES
index|]
index|[
name|ZIO_TASKQ_TYPES
index|]
init|=
block|{
comment|/* ISSUE	ISSUE_HIGH	INTR		INTR_HIGH */
block|{
name|ZTI_ONE
block|,
name|ZTI_NULL
block|,
name|ZTI_ONE
block|,
name|ZTI_NULL
block|}
block|,
comment|/* NULL */
block|{
name|ZTI_N
argument_list|(
literal|8
argument_list|)
block|,
name|ZTI_NULL
block|,
name|ZTI_P
argument_list|(
literal|12
argument_list|,
literal|8
argument_list|)
block|,
name|ZTI_NULL
block|}
block|,
comment|/* READ */
block|{
name|ZTI_BATCH
block|,
name|ZTI_N
argument_list|(
literal|5
argument_list|)
block|,
name|ZTI_N
argument_list|(
literal|8
argument_list|)
block|,
name|ZTI_N
argument_list|(
literal|5
argument_list|)
block|}
block|,
comment|/* WRITE */
block|{
name|ZTI_P
argument_list|(
literal|12
argument_list|,
literal|8
argument_list|)
block|,
name|ZTI_NULL
block|,
name|ZTI_ONE
block|,
name|ZTI_NULL
block|}
block|,
comment|/* FREE */
block|{
name|ZTI_ONE
block|,
name|ZTI_NULL
block|,
name|ZTI_ONE
block|,
name|ZTI_NULL
block|}
block|,
comment|/* CLAIM */
block|{
name|ZTI_ONE
block|,
name|ZTI_NULL
block|,
name|ZTI_ONE
block|,
name|ZTI_NULL
block|}
block|,
comment|/* IOCTL */
block|}
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|sysevent_t
modifier|*
name|spa_event_create
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spa_event_post
parameter_list|(
name|sysevent_t
modifier|*
name|ev
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spa_sync_version
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spa_sync_props
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|boolean_t
name|spa_has_active_shared_spare
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|spa_load_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|spa_load_state_t
name|state
parameter_list|,
name|spa_import_type_t
name|type
parameter_list|,
name|boolean_t
name|mosconfig
parameter_list|,
name|char
modifier|*
modifier|*
name|ereport
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|spa_vdev_resilver_done
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|uint_t
name|zio_taskq_batch_pct
init|=
literal|75
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1 thread per cpu in pset */
end_comment

begin_decl_stmt
name|id_t
name|zio_taskq_psrset_bind
init|=
name|PS_NONE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|zio_taskq_sysdc
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use SDC scheduling class */
end_comment

begin_decl_stmt
name|uint_t
name|zio_taskq_basedc
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* base duty cycle */
end_comment

begin_decl_stmt
name|boolean_t
name|spa_create_process
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no process ==> no sysdc */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|zfs_sync_pass_deferred_free
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This (illegal) pool name is used when temporarily importing a spa_t in order  * to get the vdev stats associated with the imported devices.  */
end_comment

begin_define
define|#
directive|define
name|TRYIMPORT_NAME
value|"$import"
end_define

begin_comment
comment|/*  * ==========================================================================  * SPA properties routines  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Add a (source=src, propname=propval) list to an nvlist.  */
end_comment

begin_function
specifier|static
name|void
name|spa_prop_add_list
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|char
modifier|*
name|strval
parameter_list|,
name|uint64_t
name|intval
parameter_list|,
name|zprop_source_t
name|src
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|propname
init|=
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|propval
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|propval
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZPROP_SOURCE
argument_list|,
name|src
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|strval
operator|!=
name|NULL
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|strval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|propval
argument_list|,
name|ZPROP_VALUE
argument_list|,
name|intval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nvl
argument_list|,
name|propname
argument_list|,
name|propval
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|propval
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get property values from the spa configuration.  */
end_comment

begin_function
specifier|static
name|void
name|spa_prop_get_config
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|dsl_pool_t
modifier|*
name|pool
init|=
name|spa
operator|->
name|spa_dsl_pool
decl_stmt|;
name|uint64_t
name|size
decl_stmt|,
name|alloc
decl_stmt|,
name|cap
decl_stmt|,
name|version
decl_stmt|;
name|zprop_source_t
name|src
init|=
name|ZPROP_SRC_NONE
decl_stmt|;
name|spa_config_dirent_t
modifier|*
name|dp
decl_stmt|;
name|metaslab_class_t
modifier|*
name|mc
init|=
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rvd
operator|!=
name|NULL
condition|)
block|{
name|alloc
operator|=
name|metaslab_class_get_alloc
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|size
operator|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_NAME
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_SIZE
argument_list|,
name|NULL
argument_list|,
name|size
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_ALLOCATED
argument_list|,
name|NULL
argument_list|,
name|alloc
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_FREE
argument_list|,
name|NULL
argument_list|,
name|size
operator|-
name|alloc
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_FRAGMENTATION
argument_list|,
name|NULL
argument_list|,
name|metaslab_class_fragmentation
argument_list|(
name|mc
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_EXPANDSZ
argument_list|,
name|NULL
argument_list|,
name|metaslab_class_expandable_space
argument_list|(
name|mc
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_READONLY
argument_list|,
name|NULL
argument_list|,
operator|(
name|spa_mode
argument_list|(
name|spa
argument_list|)
operator|==
name|FREAD
operator|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|cap
operator|=
operator|(
name|size
operator|==
literal|0
operator|)
condition|?
literal|0
else|:
operator|(
name|alloc
operator|*
literal|100
operator|/
name|size
operator|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_CAPACITY
argument_list|,
name|NULL
argument_list|,
name|cap
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_DEDUPRATIO
argument_list|,
name|NULL
argument_list|,
name|ddt_get_pool_dedup_ratio
argument_list|(
name|spa
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_HEALTH
argument_list|,
name|NULL
argument_list|,
name|rvd
operator|->
name|vdev_state
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|version
operator|=
name|spa_version
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|==
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_VERSION
argument_list|)
condition|)
name|src
operator|=
name|ZPROP_SRC_DEFAULT
expr_stmt|;
else|else
name|src
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_VERSION
argument_list|,
name|NULL
argument_list|,
name|version
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pool
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * The $FREE directory was introduced in SPA_VERSION_DEADLISTS, 		 * when opening pools before this version freedir will be NULL. 		 */
if|if
condition|(
name|pool
operator|->
name|dp_free_dir
operator|!=
name|NULL
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_FREEING
argument_list|,
name|NULL
argument_list|,
name|dsl_dir_phys
argument_list|(
name|pool
operator|->
name|dp_free_dir
argument_list|)
operator|->
name|dd_used_bytes
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_FREEING
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pool
operator|->
name|dp_leak_dir
operator|!=
name|NULL
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_LEAKED
argument_list|,
name|NULL
argument_list|,
name|dsl_dir_phys
argument_list|(
name|pool
operator|->
name|dp_leak_dir
argument_list|)
operator|->
name|dd_used_bytes
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_LEAKED
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
expr_stmt|;
block|}
block|}
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_GUID
argument_list|,
name|NULL
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_comment
operator|!=
name|NULL
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_COMMENT
argument_list|,
name|spa
operator|->
name|spa_comment
argument_list|,
literal|0
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_root
operator|!=
name|NULL
condition|)
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_ALTROOT
argument_list|,
name|spa
operator|->
name|spa_root
argument_list|,
literal|0
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_LARGE_BLOCKS
argument_list|)
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_MAXBLOCKSIZE
argument_list|,
name|NULL
argument_list|,
name|MIN
argument_list|(
name|zfs_max_recordsize
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
argument_list|,
name|ZPROP_SRC_NONE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_MAXBLOCKSIZE
argument_list|,
name|NULL
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
name|ZPROP_SRC_NONE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dp
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|dp
operator|->
name|scd_path
operator|==
name|NULL
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_CACHEFILE
argument_list|,
literal|"none"
argument_list|,
literal|0
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|dp
operator|->
name|scd_path
argument_list|,
name|spa_config_path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|ZPOOL_PROP_CACHEFILE
argument_list|,
name|dp
operator|->
name|scd_path
argument_list|,
literal|0
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Get zpool property values.  */
end_comment

begin_function
name|int
name|spa_prop_get
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|nvp
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|int
name|err
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
name|nvp
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Get properties from the spa config. 	 */
name|spa_prop_get_config
argument_list|(
name|spa
argument_list|,
name|nvp
argument_list|)
expr_stmt|;
comment|/* If no pool property object, no more prop to get. */
if|if
condition|(
name|mos
operator|==
name|NULL
operator|||
name|spa
operator|->
name|spa_pool_props_object
operator|==
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Get properties from the MOS pool property object. 	 */
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|)
init|;
operator|(
name|err
operator|=
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|uint64_t
name|intval
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|strval
init|=
name|NULL
decl_stmt|;
name|zprop_source_t
name|src
init|=
name|ZPROP_SRC_DEFAULT
decl_stmt|;
name|zpool_prop_t
name|prop
decl_stmt|;
if|if
condition|(
operator|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|za
operator|.
name|za_name
argument_list|)
operator|)
operator|==
name|ZPROP_INVAL
condition|)
continue|continue;
switch|switch
condition|(
name|za
operator|.
name|za_integer_length
condition|)
block|{
case|case
literal|8
case|:
comment|/* integer property */
if|if
condition|(
name|za
operator|.
name|za_first_integer
operator|!=
name|zpool_prop_default_numeric
argument_list|(
name|prop
argument_list|)
condition|)
name|src
operator|=
name|ZPROP_SRC_LOCAL
expr_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZPOOL_PROP_BOOTFS
condition|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|NULL
decl_stmt|;
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
condition|)
block|{
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
break|break;
block|}
name|strval
operator|=
name|kmem_alloc
argument_list|(
name|ZFS_MAX_DATASET_NAME_LEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dsl_dataset_name
argument_list|(
name|ds
argument_list|,
name|strval
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|strval
operator|=
name|NULL
expr_stmt|;
name|intval
operator|=
name|za
operator|.
name|za_first_integer
expr_stmt|;
block|}
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|prop
argument_list|,
name|strval
argument_list|,
name|intval
argument_list|,
name|src
argument_list|)
expr_stmt|;
if|if
condition|(
name|strval
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|ZFS_MAX_DATASET_NAME_LEN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* string property */
name|strval
operator|=
name|kmem_alloc
argument_list|(
name|za
operator|.
name|za_num_integers
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
literal|1
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|,
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
break|break;
block|}
name|spa_prop_add_list
argument_list|(
operator|*
name|nvp
argument_list|,
name|prop
argument_list|,
name|strval
argument_list|,
literal|0
argument_list|,
name|src
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|strval
argument_list|,
name|za
operator|.
name|za_num_integers
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|err
operator|&&
name|err
operator|!=
name|ENOENT
condition|)
block|{
name|nvlist_free
argument_list|(
operator|*
name|nvp
argument_list|)
expr_stmt|;
operator|*
name|nvp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate the given pool properties nvlist and modify the list  * for the property values to be set.  */
end_comment

begin_function
specifier|static
name|int
name|spa_prop_validate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|elem
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|,
name|reset_bootfs
init|=
literal|0
decl_stmt|;
name|uint64_t
name|objnum
init|=
literal|0
decl_stmt|;
name|boolean_t
name|has_feature
init|=
name|B_FALSE
decl_stmt|;
name|elem
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
modifier|*
name|check
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
init|=
name|nvpair_name
argument_list|(
name|elem
argument_list|)
decl_stmt|;
name|zpool_prop_t
name|prop
init|=
name|zpool_name_to_prop
argument_list|(
name|propname
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPROP_INVAL
case|:
if|if
condition|(
operator|!
name|zpool_prop_feature
argument_list|(
name|propname
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Sanitize the input. 			 */
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|!=
name|DATA_TYPE_UINT64
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|intval
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|fname
operator|=
name|strchr
argument_list|(
name|propname
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|zfeature_lookup_name
argument_list|(
name|fname
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|has_feature
operator|=
name|B_TRUE
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_VERSION
case|:
name|error
operator|=
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|intval
operator|<
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|||
name|intval
operator|>
name|SPA_VERSION_BEFORE_FEATURES
operator|||
name|has_feature
operator|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_DELEGATION
case|:
case|case
name|ZPOOL_PROP_AUTOREPLACE
case|:
case|case
name|ZPOOL_PROP_LISTSNAPS
case|:
case|case
name|ZPOOL_PROP_AUTOEXPAND
case|:
name|error
operator|=
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|intval
operator|>
literal|1
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_BOOTFS
case|:
comment|/* 			 * If the pool version is less than SPA_VERSION_BOOTFS, 			 * or the pool is still being created (version == 0), 			 * the bootfs property cannot be set. 			 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_BOOTFS
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * Make sure the vdev config is bootable 			 */
if|if
condition|(
operator|!
name|vdev_is_bootable
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
break|break;
block|}
name|reset_bootfs
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|propval
decl_stmt|;
if|if
condition|(
name|strval
operator|==
name|NULL
operator|||
name|strval
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|objnum
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
operator|=
name|dmu_objset_hold
argument_list|(
name|strval
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
condition|)
break|break;
comment|/* 				 * Must be ZPL, and its property settings 				 * must be supported by GRUB (compression 				 * is not gzip, and large blocks are not used). 				 */
if|if
condition|(
name|dmu_objset_type
argument_list|(
name|os
argument_list|)
operator|!=
name|DMU_OST_ZFS
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|error
operator|=
name|dsl_prop_get_int_ds
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
operator|&
name|propval
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|BOOTFS_COMPRESS_VALID
argument_list|(
name|propval
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|objnum
operator|=
name|dmu_objset_id
argument_list|(
name|os
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_rele
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_FAILUREMODE
case|:
name|error
operator|=
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
operator|(
name|intval
operator|<
name|ZIO_FAILURE_MODE_WAIT
operator|||
name|intval
operator|>
name|ZIO_FAILURE_MODE_PANIC
operator|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
comment|/* 			 * This is a special case which only occurs when 			 * the pool has completely failed. This allows 			 * the user to change the in-core failmode property 			 * without syncing it out to disk (I/Os might 			 * currently be blocked). We do this by returning 			 * EIO to the caller (spa_prop_set) to trick it 			 * into thinking we encountered a property validation 			 * error. 			 */
if|if
condition|(
operator|!
name|error
operator|&&
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|spa
operator|->
name|spa_failmode
operator|=
name|intval
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|strcmp
argument_list|(
name|strval
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|strval
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
name|slash
operator|=
name|strrchr
argument_list|(
name|strval
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|slash
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|slash
argument_list|,
literal|"/.."
argument_list|)
operator|==
literal|0
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_COMMENT
case|:
if|if
condition|(
operator|(
name|error
operator|=
name|nvpair_value_string
argument_list|(
name|elem
argument_list|,
operator|&
name|strval
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
for|for
control|(
name|check
operator|=
name|strval
init|;
operator|*
name|check
operator|!=
literal|'\0'
condition|;
name|check
operator|++
control|)
block|{
comment|/* 				 * The kernel doesn't have an easy isprint() 				 * check.  For this kernel check, we merely 				 * check ASCII apart from DEL.  Fix this if 				 * there is an easy-to-use kernel isprint(). 				 */
if|if
condition|(
operator|*
name|check
operator|>=
literal|0x7f
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|strlen
argument_list|(
name|strval
argument_list|)
operator|>
name|ZPROP_MAX_COMMENT
condition|)
name|error
operator|=
name|E2BIG
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_DEDUPDITTO
case|:
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_DEDUP
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|intval
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|intval
operator|!=
literal|0
operator|&&
name|intval
operator|<
name|ZIO_DEDUPDITTO_MIN
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|error
condition|)
break|break;
block|}
if|if
condition|(
operator|!
name|error
operator|&&
name|reset_bootfs
condition|)
block|{
name|error
operator|=
name|nvlist_remove
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
argument_list|,
name|DATA_TYPE_STRING
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|error
condition|)
block|{
name|error
operator|=
name|nvlist_add_uint64
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
argument_list|,
name|objnum
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_configfile_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|,
name|boolean_t
name|need_sync
parameter_list|)
block|{
name|char
modifier|*
name|cachefile
decl_stmt|;
name|spa_config_dirent_t
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nvp
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_CACHEFILE
argument_list|)
argument_list|,
operator|&
name|cachefile
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|dp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|spa_config_dirent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|cachefile
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|dp
operator|->
name|scd_path
operator|=
name|spa_strdup
argument_list|(
name|spa_config_path
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|cachefile
argument_list|,
literal|"none"
argument_list|)
operator|==
literal|0
condition|)
name|dp
operator|->
name|scd_path
operator|=
name|NULL
expr_stmt|;
else|else
name|dp
operator|->
name|scd_path
operator|=
name|spa_strdup
argument_list|(
name|cachefile
argument_list|)
expr_stmt|;
name|list_insert_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_list
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|need_sync
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_CONFIG_UPDATE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_prop_set
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvp
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
init|=
name|NULL
decl_stmt|;
name|boolean_t
name|need_sync
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_prop_validate
argument_list|(
name|spa
argument_list|,
name|nvp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvp
argument_list|,
name|elem
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|zpool_prop_t
name|prop
init|=
name|zpool_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZPOOL_PROP_CACHEFILE
operator|||
name|prop
operator|==
name|ZPOOL_PROP_ALTROOT
operator|||
name|prop
operator|==
name|ZPOOL_PROP_READONLY
condition|)
continue|continue;
if|if
condition|(
name|prop
operator|==
name|ZPOOL_PROP_VERSION
operator|||
name|prop
operator|==
name|ZPROP_INVAL
condition|)
block|{
name|uint64_t
name|ver
decl_stmt|;
if|if
condition|(
name|prop
operator|==
name|ZPOOL_PROP_VERSION
condition|)
block|{
name|VERIFY
argument_list|(
name|nvpair_value_uint64
argument_list|(
name|elem
argument_list|,
operator|&
name|ver
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zpool_prop_feature
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ver
operator|=
name|SPA_VERSION_FEATURES
expr_stmt|;
name|need_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* Save time if the version is already set. */
if|if
condition|(
name|ver
operator|==
name|spa_version
argument_list|(
name|spa
argument_list|)
condition|)
continue|continue;
comment|/* 			 * In addition to the pool directory object, we might 			 * create the pool properties object, the features for 			 * read object, the features for write object, or the 			 * feature descriptions object. 			 */
name|error
operator|=
name|dsl_sync_task
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|NULL
argument_list|,
name|spa_sync_version
argument_list|,
operator|&
name|ver
argument_list|,
literal|6
argument_list|,
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
continue|continue;
block|}
name|need_sync
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|need_sync
condition|)
block|{
return|return
operator|(
name|dsl_sync_task
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|NULL
argument_list|,
name|spa_sync_props
argument_list|,
name|nvp
argument_list|,
literal|6
argument_list|,
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If the bootfs property value is dsobj, clear it.  */
end_comment

begin_function
name|void
name|spa_prop_clear_bootfs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_bootfs
operator|==
name|dsobj
operator|&&
name|spa
operator|->
name|spa_pool_props_object
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|zap_remove
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_bootfs
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|spa_change_guid_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
modifier|*
name|newguid
init|=
name|arg
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|uint64_t
name|vdev_state
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|vdev_state
operator|=
name|rvd
operator|->
name|vdev_state
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
name|ASSERT3U
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|!=
argument_list|,
operator|*
name|newguid
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_change_guid_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
modifier|*
name|newguid
init|=
name|arg
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
name|uint64_t
name|oldguid
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|oldguid
operator|=
name|spa_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|rvd
operator|->
name|vdev_guid
operator|=
operator|*
name|newguid
expr_stmt|;
name|rvd
operator|->
name|vdev_guid_sum
operator|+=
operator|(
operator|*
name|newguid
operator|-
name|oldguid
operator|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"guid change"
argument_list|,
name|tx
argument_list|,
literal|"old=%llu new=%llu"
argument_list|,
name|oldguid
argument_list|,
operator|*
name|newguid
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Change the GUID for the pool.  This is done so that we can later  * re-import a pool built from a clone of our own vdevs.  We will modify  * the root vdev's guid, our own pool guid, and then mark all of our  * vdevs dirty.  Note that we must make sure that all our vdevs are  * online when we do this, or else any vdevs that weren't present  * would be orphaned from our pool.  We are also going to issue a  * sysevent to update any watchers.  */
end_comment

begin_function
name|int
name|spa_change_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|guid
operator|=
name|spa_generate_guid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dsl_sync_task
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|spa_change_guid_check
argument_list|,
name|spa_change_guid_sync
argument_list|,
operator|&
name|guid
argument_list|,
literal|5
argument_list|,
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_POOL_REGUID
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_top_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA state manipulation (open/create/destroy/import/export)  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|spa_error_entry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
name|spa_error_entry_t
modifier|*
name|sa
init|=
operator|(
name|spa_error_entry_t
operator|*
operator|)
name|a
decl_stmt|;
name|spa_error_entry_t
modifier|*
name|sb
init|=
operator|(
name|spa_error_entry_t
operator|*
operator|)
name|b
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ret
operator|=
name|bcmp
argument_list|(
operator|&
name|sa
operator|->
name|se_bookmark
argument_list|,
operator|&
name|sb
operator|->
name|se_bookmark
argument_list|,
sizeof|sizeof
argument_list|(
name|zbookmark_phys_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function which retrieves copies of the current logs and  * re-initializes them in the process.  */
end_comment

begin_function
name|void
name|spa_get_errlists
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|avl_tree_t
modifier|*
name|last
parameter_list|,
name|avl_tree_t
modifier|*
name|scrub
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_lock
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|last
argument_list|,
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|scrub
argument_list|,
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_taskqs_init
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_type_t
name|t
parameter_list|,
name|zio_taskq_type_t
name|q
parameter_list|)
block|{
specifier|const
name|zio_taskq_info_t
modifier|*
name|ztip
init|=
operator|&
name|zio_taskqs
index|[
name|t
index|]
index|[
name|q
index|]
decl_stmt|;
name|enum
name|zti_modes
name|mode
init|=
name|ztip
operator|->
name|zti_mode
decl_stmt|;
name|uint_t
name|value
init|=
name|ztip
operator|->
name|zti_value
decl_stmt|;
name|uint_t
name|count
init|=
name|ztip
operator|->
name|zti_count
decl_stmt|;
name|spa_taskqs_t
modifier|*
name|tqs
init|=
operator|&
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
decl_stmt|;
name|char
name|name
index|[
literal|32
index|]
decl_stmt|;
name|uint_t
name|flags
init|=
literal|0
decl_stmt|;
name|boolean_t
name|batch
init|=
name|B_FALSE
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|ZTI_MODE_NULL
condition|)
block|{
name|tqs
operator|->
name|stqs_count
operator|=
literal|0
expr_stmt|;
name|tqs
operator|->
name|stqs_taskq
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
name|ASSERT3U
argument_list|(
name|count
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tqs
operator|->
name|stqs_count
operator|=
name|count
expr_stmt|;
name|tqs
operator|->
name|stqs_taskq
operator|=
name|kmem_alloc
argument_list|(
name|count
operator|*
sizeof|sizeof
argument_list|(
name|taskq_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|ZTI_MODE_FIXED
case|:
name|ASSERT3U
argument_list|(
name|value
argument_list|,
operator|>=
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|value
operator|=
name|MAX
argument_list|(
name|value
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZTI_MODE_BATCH
case|:
name|batch
operator|=
name|B_TRUE
expr_stmt|;
name|flags
operator||=
name|TASKQ_THREADS_CPU_PCT
expr_stmt|;
name|value
operator|=
name|zio_taskq_batch_pct
expr_stmt|;
break|break;
default|default:
name|panic
argument_list|(
literal|"unrecognized mode for %s_%s taskq (%u:%u) in "
literal|"spa_activate()"
argument_list|,
name|zio_type_name
index|[
name|t
index|]
argument_list|,
name|zio_taskq_types
index|[
name|q
index|]
argument_list|,
name|mode
argument_list|,
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
for|for
control|(
name|uint_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|taskq_t
modifier|*
name|tq
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s_%s_%u"
argument_list|,
name|zio_type_name
index|[
name|t
index|]
argument_list|,
name|zio_taskq_types
index|[
name|q
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|,
literal|"%s_%s"
argument_list|,
name|zio_type_name
index|[
name|t
index|]
argument_list|,
name|zio_taskq_types
index|[
name|q
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|zio_taskq_sysdc
operator|&&
name|spa
operator|->
name|spa_proc
operator|!=
operator|&
name|p0
condition|)
block|{
if|if
condition|(
name|batch
condition|)
name|flags
operator||=
name|TASKQ_DC_BATCH
expr_stmt|;
name|tq
operator|=
name|taskq_create_sysdc
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
literal|50
argument_list|,
name|INT_MAX
argument_list|,
name|spa
operator|->
name|spa_proc
argument_list|,
name|zio_taskq_basedc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|pri_t
name|pri
init|=
name|maxclsyspri
decl_stmt|;
comment|/* 			 * The write issue taskq can be extremely CPU 			 * intensive.  Run it at slightly lower priority 			 * than the other taskqs. 			 */
if|if
condition|(
name|t
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|q
operator|==
name|ZIO_TASKQ_ISSUE
condition|)
name|pri
operator|--
expr_stmt|;
name|tq
operator|=
name|taskq_create_proc
argument_list|(
name|name
argument_list|,
name|value
argument_list|,
name|pri
argument_list|,
literal|50
argument_list|,
name|INT_MAX
argument_list|,
name|spa
operator|->
name|spa_proc
argument_list|,
name|flags
argument_list|)
expr_stmt|;
block|}
name|tqs
operator|->
name|stqs_taskq
index|[
name|i
index|]
operator|=
name|tq
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spa_taskqs_fini
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_type_t
name|t
parameter_list|,
name|zio_taskq_type_t
name|q
parameter_list|)
block|{
name|spa_taskqs_t
modifier|*
name|tqs
init|=
operator|&
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
decl_stmt|;
if|if
condition|(
name|tqs
operator|->
name|stqs_taskq
operator|==
name|NULL
condition|)
block|{
name|ASSERT0
argument_list|(
name|tqs
operator|->
name|stqs_count
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|uint_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|tqs
operator|->
name|stqs_count
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3P
argument_list|(
name|tqs
operator|->
name|stqs_taskq
index|[
name|i
index|]
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|tqs
operator|->
name|stqs_taskq
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|tqs
operator|->
name|stqs_taskq
argument_list|,
name|tqs
operator|->
name|stqs_count
operator|*
sizeof|sizeof
argument_list|(
name|taskq_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|tqs
operator|->
name|stqs_taskq
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dispatch a task to the appropriate taskq for the ZFS I/O type and priority.  * Note that a type may have multiple discrete taskqs to avoid lock contention  * on the taskq itself. In that case we choose which taskq at random by using  * the low bits of gethrtime().  */
end_comment

begin_function
name|void
name|spa_taskq_dispatch_ent
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_type_t
name|t
parameter_list|,
name|zio_taskq_type_t
name|q
parameter_list|,
name|task_func_t
modifier|*
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|taskq_ent_t
modifier|*
name|ent
parameter_list|)
block|{
name|spa_taskqs_t
modifier|*
name|tqs
init|=
operator|&
name|spa
operator|->
name|spa_zio_taskq
index|[
name|t
index|]
index|[
name|q
index|]
decl_stmt|;
name|taskq_t
modifier|*
name|tq
decl_stmt|;
name|ASSERT3P
argument_list|(
name|tqs
operator|->
name|stqs_taskq
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|tqs
operator|->
name|stqs_count
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|tqs
operator|->
name|stqs_count
operator|==
literal|1
condition|)
block|{
name|tq
operator|=
name|tqs
operator|->
name|stqs_taskq
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
block|{
name|tq
operator|=
name|tqs
operator|->
name|stqs_taskq
index|[
name|gethrtime
argument_list|()
operator|%
name|tqs
operator|->
name|stqs_count
index|]
expr_stmt|;
block|}
name|taskq_dispatch_ent
argument_list|(
name|tq
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|flags
argument_list|,
name|ent
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_create_zio_taskqs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|ZIO_TASKQ_TYPES
condition|;
name|q
operator|++
control|)
block|{
name|spa_taskqs_init
argument_list|(
name|spa
argument_list|,
name|t
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_function
specifier|static
name|void
name|spa_thread
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|callb_cpr_t
name|cprinfo
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|arg
decl_stmt|;
name|user_t
modifier|*
name|pu
init|=
name|PTOU
argument_list|(
name|curproc
argument_list|)
decl_stmt|;
name|CALLB_CPR_INIT
argument_list|(
operator|&
name|cprinfo
argument_list|,
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|,
name|callb_generic_cpr
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|curproc
operator|!=
operator|&
name|p0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|pu
operator|->
name|u_psargs
argument_list|,
sizeof|sizeof
argument_list|(
name|pu
operator|->
name|u_psargs
argument_list|)
argument_list|,
literal|"zpool-%s"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|pu
operator|->
name|u_comm
argument_list|,
name|pu
operator|->
name|u_psargs
argument_list|,
sizeof|sizeof
argument_list|(
name|pu
operator|->
name|u_comm
argument_list|)
argument_list|)
expr_stmt|;
comment|/* bind this thread to the requested psrset */
if|if
condition|(
name|zio_taskq_psrset_bind
operator|!=
name|PS_NONE
condition|)
block|{
name|pool_lock
argument_list|()
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|curproc
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpupart_bind_thread
argument_list|(
name|curthread
argument_list|,
name|zio_taskq_psrset_bind
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
block|{
name|curthread
operator|->
name|t_bind_pset
operator|=
name|zio_taskq_psrset_bind
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"Couldn't bind process for zfs pool \"%s\" to "
literal|"pset %d\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|zio_taskq_psrset_bind
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|curproc
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|pool_unlock
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|zio_taskq_sysdc
condition|)
block|{
name|sysdc_thread_enter
argument_list|(
name|curthread
argument_list|,
literal|100
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|spa
operator|->
name|spa_proc
operator|=
name|curproc
expr_stmt|;
name|spa
operator|->
name|spa_did
operator|=
name|curthread
operator|->
name|t_did
expr_stmt|;
name|spa_create_zio_taskqs
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_CREATED
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_proc_state
operator|=
name|SPA_PROC_ACTIVE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_BEGIN
argument_list|(
operator|&
name|cprinfo
argument_list|)
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_ACTIVE
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
name|CALLB_CPR_SAFE_END
argument_list|(
operator|&
name|cprinfo
argument_list|,
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_DEACTIVATE
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_proc_state
operator|=
name|SPA_PROC_GONE
expr_stmt|;
name|spa
operator|->
name|spa_proc
operator|=
operator|&
name|p0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|)
expr_stmt|;
name|CALLB_CPR_EXIT
argument_list|(
operator|&
name|cprinfo
argument_list|)
expr_stmt|;
comment|/* drops spa_proc_lock */
name|mutex_enter
argument_list|(
operator|&
name|curproc
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|lwp_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Activate an uninitialized pool.  */
end_comment

begin_function
specifier|static
name|void
name|spa_activate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
name|spa
operator|->
name|spa_mode
operator|=
name|mode
expr_stmt|;
name|spa
operator|->
name|spa_normal_class
operator|=
name|metaslab_class_create
argument_list|(
name|spa
argument_list|,
name|zfs_metaslab_ops
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_log_class
operator|=
name|metaslab_class_create
argument_list|(
name|spa
argument_list|,
name|zfs_metaslab_ops
argument_list|)
expr_stmt|;
comment|/* Try to create a covering process */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc
operator|==
operator|&
name|p0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_did
operator|=
literal|0
expr_stmt|;
comment|/* Only create a process if we're going to be around a while. */
if|if
condition|(
name|spa_create_process
operator|&&
name|strcmp
argument_list|(
name|spa
operator|->
name|spa_name
argument_list|,
name|TRYIMPORT_NAME
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|newproc
argument_list|(
name|spa_thread
argument_list|,
operator|(
name|caddr_t
operator|)
name|spa
argument_list|,
name|syscid
argument_list|,
name|maxclsyspri
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_proc_state
operator|=
name|SPA_PROC_CREATED
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_CREATED
condition|)
block|{
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_ACTIVE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc
operator|!=
operator|&
name|p0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_did
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"Couldn't create process for zfs pool \"%s\"\n"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
comment|/* If we didn't create a process, we need to create our taskqs. */
if|if
condition|(
name|spa
operator|->
name|spa_proc
operator|==
operator|&
name|p0
condition|)
block|{
name|spa_create_zio_taskqs
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|vdev_t
argument_list|,
name|vdev_config_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_list
argument_list|,
sizeof|sizeof
argument_list|(
name|objset_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|objset_t
argument_list|,
name|os_evicting_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|,
sizeof|sizeof
argument_list|(
name|vdev_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|vdev_t
argument_list|,
name|vdev_state_dirty_node
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|spa
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|vdev
argument_list|,
name|vdev_txg_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|,
name|spa_error_entry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|spa_error_entry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|spa_error_entry_t
argument_list|,
name|se_avl
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Opposite of spa_activate().  */
end_comment

begin_function
specifier|static
name|void
name|spa_deactivate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_sync_on
operator|==
name|B_FALSE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_async_zio_root
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
argument_list|)
expr_stmt|;
name|spa_evicting_os_wait
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_evicting_os_list
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|ZIO_TYPES
condition|;
name|t
operator|++
control|)
block|{
for|for
control|(
name|int
name|q
init|=
literal|0
init|;
name|q
operator|<
name|ZIO_TASKQ_TYPES
condition|;
name|q
operator|++
control|)
block|{
name|spa_taskqs_fini
argument_list|(
name|spa
argument_list|,
name|t
argument_list|,
name|q
argument_list|)
expr_stmt|;
block|}
block|}
name|metaslab_class_destroy
argument_list|(
name|spa
operator|->
name|spa_normal_class
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_normal_class
operator|=
name|NULL
expr_stmt|;
name|metaslab_class_destroy
argument_list|(
name|spa
operator|->
name|spa_log_class
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_log_class
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * If this was part of an import or the open otherwise failed, we may 	 * still have errors left in the queues.  Empty them just in case. 	 */
name|spa_errlog_drain
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_scrub
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|spa
operator|->
name|spa_errlist_last
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_UNINITIALIZED
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_proc_state
operator|!=
name|SPA_PROC_NONE
condition|)
block|{
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_ACTIVE
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_proc_state
operator|=
name|SPA_PROC_DEACTIVATE
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|)
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_DEACTIVATE
condition|)
block|{
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc
operator|!=
operator|&
name|p0
argument_list|)
expr_stmt|;
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc_state
operator|==
name|SPA_PROC_GONE
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_proc_state
operator|=
name|SPA_PROC_NONE
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_proc
operator|==
operator|&
name|p0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_proc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We want to make sure spa_thread() has actually exited the ZFS 	 * module, so that the module can't be unloaded out from underneath 	 * it. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_did
operator|!=
literal|0
condition|)
block|{
name|thread_join
argument_list|(
name|spa
operator|->
name|spa_did
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_did
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Verify a pool configuration, and construct the vdev tree appropriately.  This  * will create all the necessary vdevs in the appropriate layout, with each vdev  * in the CLOSED state.  This will prep the pool before open/creation/import.  * All vdev validation is done by the vdev_alloc() routine.  */
end_comment

begin_function
specifier|static
name|int
name|spa_config_parse
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
modifier|*
name|vdp
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|vdev_t
modifier|*
name|parent
parameter_list|,
name|uint_t
name|id
parameter_list|,
name|int
name|atype
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|;
name|uint_t
name|children
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_alloc
argument_list|(
name|spa
argument_list|,
name|vdp
argument_list|,
name|nv
argument_list|,
name|parent
argument_list|,
name|id
argument_list|,
name|atype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
operator|*
name|vdp
operator|)
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|nvlist_lookup_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|error
condition|)
block|{
name|vdev_free
argument_list|(
operator|*
name|vdp
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|child
index|[
name|c
index|]
argument_list|,
operator|*
name|vdp
argument_list|,
name|c
argument_list|,
name|atype
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|vdev_free
argument_list|(
operator|*
name|vdp
argument_list|)
expr_stmt|;
operator|*
name|vdp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
operator|*
name|vdp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Opposite of spa_load().  */
end_comment

begin_function
specifier|static
name|void
name|spa_unload
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Stop async tasks. 	 */
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Stop syncing. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_sync_on
condition|)
block|{
name|txg_sync_stop
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_FALSE
expr_stmt|;
block|}
comment|/* 	 * Even though vdev_free() also calls vdev_metaslab_fini, we need 	 * to call it earlier, before we wait for async i/o to complete. 	 * This ensures that there is no async metaslab prefetching, by 	 * calling taskq_wait(mg_taskq). 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_metaslab_fini
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Wait for any outstanding async I/O to complete. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_async_zio_root
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max_ncpus
condition|;
name|i
operator|++
control|)
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|spa
operator|->
name|spa_async_zio_root
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_async_zio_root
argument_list|,
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_zio_root
operator|=
name|NULL
expr_stmt|;
block|}
name|bpobj_close
argument_list|(
operator|&
name|spa
operator|->
name|spa_deferred_bpobj
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Close all vdevs. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
condition|)
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Close the dsl pool. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_dsl_pool
condition|)
block|{
name|dsl_pool_close
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_dsl_pool
operator|=
name|NULL
expr_stmt|;
name|spa
operator|->
name|spa_meta_objset
operator|=
name|NULL
expr_stmt|;
block|}
name|ddt_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Drop and purge level 2 cache 	 */
name|spa_l2cache_drop
argument_list|(
name|spa
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
condition|)
block|{
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
block|}
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|vdev_clear_stats
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
condition|)
block|{
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
argument_list|,
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
block|}
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_comment
operator|!=
name|NULL
condition|)
block|{
name|spa_strfree
argument_list|(
name|spa
operator|->
name|spa_comment
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_comment
operator|=
name|NULL
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load (or re-load) the current list of vdevs describing the active spares for  * this pool.  When this is called, we have some form of basic information in  * 'spa_spares.sav_config'.  We parse this into vdevs, try to open them, and  * then re-generate a more complete list including status information.  */
end_comment

begin_function
specifier|static
name|void
name|spa_load_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|;
name|int
name|i
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
comment|/* 	 * First, close and free any existing spare vdevs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
comment|/* Undo the call to spa_activate() below */
if|if
condition|(
operator|(
name|tvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|tvd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_remove
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
name|vdev_close
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
condition|)
name|kmem_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
operator|==
name|NULL
condition|)
name|nspares
operator|=
literal|0
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|=
operator|(
name|int
operator|)
name|nspares
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|nspares
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Construct the array of vdevs, opening them to get status in the 	 * process.   For each spare, there is potentially two different vdev_t 	 * structures associated with it: one in the list of spares (used only 	 * for basic validation purposes) and one in the active vdev 	 * configuration (if it's spared in).  During this phase we open and 	 * validate each vdev on the spare list.  If the vdev also exists in the 	 * active configuration, then we also mark this vdev as an active spare. 	 */
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|=
name|kmem_alloc
argument_list|(
name|nspares
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|spares
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_SPARE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
operator|=
name|vd
expr_stmt|;
if|if
condition|(
operator|(
name|tvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|tvd
operator|->
name|vdev_isspare
condition|)
name|spa_spare_add
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 			 * We only mark the spare active if we were successfully 			 * able to load the vdev.  Otherwise, importing a pool 			 * with a bad active spare would result in strange 			 * behavior, because multiple pool would think the spare 			 * is actively in use. 			 * 			 * There is a vulnerability here to an equally bizarre 			 * circumstance, where a dead active spare is later 			 * brought back to life (onlined or otherwise).  Given 			 * the rarity of this scenario, and the extra complexity 			 * it adds, we ignore the possibility. 			 */
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|tvd
argument_list|)
condition|)
name|spa_spare_activate
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
name|vd
operator|->
name|vdev_aux
operator|=
operator|&
name|spa
operator|->
name|spa_spares
expr_stmt|;
if|if
condition|(
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|vdev_validate_aux
argument_list|(
name|vd
argument_list|)
operator|==
literal|0
condition|)
name|spa_spare_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Recompute the stashed list of spares, with status information 	 * this time. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spares
operator|=
name|kmem_alloc
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|spares
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_CONFIG_SPARE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|spares
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Load (or re-load) the current list of vdevs describing the active l2cache for  * this pool.  When this is called, we have some form of basic information in  * 'spa_l2cache.sav_config'.  We parse this into vdevs, try to open them, and  * then re-generate a more complete list including status information.  * Devices which are already active have their details maintained, and are  * not re-opened.  */
end_comment

begin_function
specifier|static
name|void
name|spa_load_l2cache
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nl2cache
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|oldnvdevs
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
modifier|*
name|oldvdevs
decl_stmt|,
modifier|*
modifier|*
name|newvdevs
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_l2cache
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_config
operator|!=
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newvdevs
operator|=
name|kmem_alloc
argument_list|(
name|nl2cache
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nl2cache
operator|=
literal|0
expr_stmt|;
name|newvdevs
operator|=
name|NULL
expr_stmt|;
block|}
name|oldvdevs
operator|=
name|sav
operator|->
name|sav_vdevs
expr_stmt|;
name|oldnvdevs
operator|=
name|sav
operator|->
name|sav_count
expr_stmt|;
name|sav
operator|->
name|sav_vdevs
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|sav_count
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Process new nvlist of vdevs. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2cache
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newvdevs
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|oldnvdevs
condition|;
name|j
operator|++
control|)
block|{
name|vd
operator|=
name|oldvdevs
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|&&
name|guid
operator|==
name|vd
operator|->
name|vdev_guid
condition|)
block|{
comment|/* 				 * Retain previous vdev for add/remove ops. 				 */
name|newvdevs
index|[
name|i
index|]
operator|=
name|vd
expr_stmt|;
name|oldvdevs
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|newvdevs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Create new vdev 			 */
name|VERIFY
argument_list|(
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|l2cache
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_L2CACHE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|newvdevs
index|[
name|i
index|]
operator|=
name|vd
expr_stmt|;
comment|/* 			 * Commit this vdev as an l2cache device, 			 * even if it fails to open. 			 */
name|spa_l2cache_add
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
name|vd
operator|->
name|vdev_aux
operator|=
name|sav
expr_stmt|;
name|spa_l2cache_activate
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|vdev_validate_aux
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
condition|)
name|l2arc_add_vdev
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Purge vdevs that were dropped 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldnvdevs
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|pool
decl_stmt|;
name|vd
operator|=
name|oldvdevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_isl2cache
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_l2cache_exists
argument_list|(
name|vd
operator|->
name|vdev_guid
argument_list|,
operator|&
name|pool
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
operator|&&
name|l2arc_vdev_present
argument_list|(
name|vd
argument_list|)
condition|)
name|l2arc_remove_vdev
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_clear_stats
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|oldvdevs
condition|)
name|kmem_free
argument_list|(
name|oldvdevs
argument_list|,
name|oldnvdevs
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_config
operator|==
name|NULL
condition|)
goto|goto
name|out
goto|;
name|sav
operator|->
name|sav_vdevs
operator|=
name|newvdevs
expr_stmt|;
name|sav
operator|->
name|sav_count
operator|=
operator|(
name|int
operator|)
name|nl2cache
expr_stmt|;
comment|/* 	 * Recompute the stashed list of l2cache devices, with status 	 * information this time. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|l2cache
operator|=
name|kmem_alloc
argument_list|(
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|l2cache
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_CONFIG_L2CACHE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|sav
operator|->
name|sav_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
condition|)
name|kmem_free
argument_list|(
name|l2cache
argument_list|,
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|load_nvlist
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|value
parameter_list|)
block|{
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|value
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|nvsize
operator|=
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|nvsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_read
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|nvsize
argument_list|,
name|packed
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|nvlist_unpack
argument_list|(
name|packed
argument_list|,
name|nvsize
argument_list|,
name|value
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|nvsize
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Checks to see if the given vdev could not be opened, in which case we post a  * sysevent to notify the autoreplace code that the device has been removed.  */
end_comment

begin_function
specifier|static
name|void
name|spa_check_removed
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|spa_check_removed
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vdev_is_dead
argument_list|(
name|vd
argument_list|)
operator|&&
operator|!
name|vd
operator|->
name|vdev_ishole
condition|)
block|{
name|zfs_post_autoreplace
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_CHECK
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spa_config_valid_zaps
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_t
modifier|*
name|mvd
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|vd
operator|->
name|vdev_children
argument_list|,
operator|==
argument_list|,
name|mvd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_top_zap
operator|=
name|mvd
operator|->
name|vdev_top_zap
expr_stmt|;
name|vd
operator|->
name|vdev_leaf_zap
operator|=
name|mvd
operator|->
name|vdev_leaf_zap
expr_stmt|;
for|for
control|(
name|uint64_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|i
operator|++
control|)
block|{
name|spa_config_valid_zaps
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|i
index|]
argument_list|,
name|mvd
operator|->
name|vdev_child
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Validate the current config against the MOS config  */
end_comment

begin_function
specifier|static
name|boolean_t
name|spa_config_valid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|vdev_t
modifier|*
name|mrvd
decl_stmt|,
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|mrvd
argument_list|,
name|nv
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_LOAD
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rvd
operator|->
name|vdev_children
argument_list|,
operator|==
argument_list|,
name|mrvd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
comment|/* 	 * If we're doing a normal import, then build up any additional 	 * diagnostic information about missing devices in this config. 	 * We'll pass this up to the user for further processing. 	 */
if|if
condition|(
operator|!
operator|(
name|spa
operator|->
name|spa_import_flags
operator|&
name|ZFS_IMPORT_MISSING_LOG
operator|)
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|,
modifier|*
name|nv
decl_stmt|;
name|uint64_t
name|idx
init|=
literal|0
decl_stmt|;
name|child
operator|=
name|kmem_alloc
argument_list|(
name|rvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|nvlist_t
operator|*
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|vdev_t
modifier|*
name|mtvd
init|=
name|mrvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_missing_ops
operator|&&
name|mtvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_missing_ops
operator|&&
name|mtvd
operator|->
name|vdev_islog
condition|)
name|child
index|[
name|idx
operator|++
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|mtvd
argument_list|,
name|B_FALSE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|idx
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nv
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
name|child
argument_list|,
name|idx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_MISSING_DEVICES
argument_list|,
name|nv
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|idx
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|child
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|child
argument_list|,
name|rvd
operator|->
name|vdev_children
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Compare the root vdev tree with the information we have 	 * from the MOS config (mrvd). Check each top-level vdev 	 * with the corresponding MOS config top-level (mtvd). 	 */
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|vdev_t
modifier|*
name|mtvd
init|=
name|mrvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
comment|/* 		 * Resolve any "missing" vdevs in the current configuration. 		 * If we find that the MOS config has more accurate information 		 * about the top-level vdev then use that vdev instead. 		 */
if|if
condition|(
name|tvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_missing_ops
operator|&&
name|mtvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_missing_ops
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|spa
operator|->
name|spa_import_flags
operator|&
name|ZFS_IMPORT_MISSING_LOG
operator|)
condition|)
continue|continue;
comment|/* 			 * Device specific actions. 			 */
if|if
condition|(
name|mtvd
operator|->
name|vdev_islog
condition|)
block|{
name|spa_set_log_state
argument_list|(
name|spa
argument_list|,
name|SPA_LOG_CLEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 				 * XXX - once we have 'readonly' pool 				 * support we should be able to handle 				 * missing data devices by transitioning 				 * the pool to readonly. 				 */
continue|continue;
block|}
comment|/* 			 * Swap the missing vdev with the data we were 			 * able to obtain from the MOS config. 			 */
name|vdev_remove_child
argument_list|(
name|rvd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|mrvd
argument_list|,
name|mtvd
argument_list|)
expr_stmt|;
name|vdev_add_child
argument_list|(
name|rvd
argument_list|,
name|mtvd
argument_list|)
expr_stmt|;
name|vdev_add_child
argument_list|(
name|mrvd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|vdev_load
argument_list|(
name|mtvd
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|vdev_reopen
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|mtvd
operator|->
name|vdev_islog
condition|)
block|{
comment|/* 				 * Load the slog device's state from the MOS 				 * config since it's possible that the label 				 * does not contain the most up-to-date 				 * information. 				 */
name|vdev_load_log_state
argument_list|(
name|tvd
argument_list|,
name|mtvd
argument_list|)
expr_stmt|;
name|vdev_reopen
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Per-vdev ZAP info is stored exclusively in the MOS. 			 */
name|spa_config_valid_zaps
argument_list|(
name|tvd
argument_list|,
name|mtvd
argument_list|)
expr_stmt|;
block|}
block|}
name|vdev_free
argument_list|(
name|mrvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Ensure we were able to validate the config. 	 */
return|return
operator|(
name|rvd
operator|->
name|vdev_guid_sum
operator|==
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_guid_sum
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check for missing log devices  */
end_comment

begin_function
specifier|static
name|boolean_t
name|spa_check_logs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|boolean_t
name|rv
init|=
name|B_FALSE
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
switch|switch
condition|(
name|spa
operator|->
name|spa_log_state
condition|)
block|{
case|case
name|SPA_LOG_MISSING
case|:
comment|/* need to recheck in case slog has been restored */
case|case
name|SPA_LOG_UNKNOWN
case|:
name|rv
operator|=
operator|(
name|dmu_objset_find_dp
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|zil_check_log_chain
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
operator|!=
literal|0
operator|)
expr_stmt|;
if|if
condition|(
name|rv
condition|)
name|spa_set_log_state
argument_list|(
name|spa
argument_list|,
name|SPA_LOG_MISSING
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|spa_passivate_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|boolean_t
name|slog_found
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spa_has_slogs
argument_list|(
name|spa
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
init|=
name|tvd
operator|->
name|vdev_mg
decl_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_islog
condition|)
block|{
name|metaslab_group_passivate
argument_list|(
name|mg
argument_list|)
expr_stmt|;
name|slog_found
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|slog_found
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_activate_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
init|=
name|tvd
operator|->
name|vdev_mg
decl_stmt|;
if|if
condition|(
name|tvd
operator|->
name|vdev_islog
condition|)
name|metaslab_group_activate
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|spa_offline_log
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|error
operator|=
name|dmu_objset_find
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|zil_vdev_offline
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * We successfully offlined the log device, sync out the 		 * current txg so that the "stubby" block can be removed 		 * by zil_sync(). 		 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_aux_check_removed
parameter_list|(
name|spa_aux_vdev_t
modifier|*
name|sav
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|spa_check_removed
argument_list|(
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_claim_notify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
comment|/* any mutex will do */
if|if
condition|(
name|spa
operator|->
name|spa_claim_max_txg
operator|<
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
condition|)
name|spa
operator|->
name|spa_claim_max_txg
operator|=
name|zio
operator|->
name|io_bp
operator|->
name|blk_birth
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|spa_load_error
block|{
name|uint64_t
name|sle_meta_count
decl_stmt|;
name|uint64_t
name|sle_data_count
decl_stmt|;
block|}
name|spa_load_error_t
typedef|;
end_typedef

begin_function
specifier|static
name|void
name|spa_load_verify_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|spa_load_error_t
modifier|*
name|sle
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|dmu_object_type_t
name|type
init|=
name|BP_GET_TYPE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
name|zio
operator|->
name|io_error
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|abd_free
argument_list|(
name|zio
operator|->
name|io_abd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|(
name|BP_GET_LEVEL
argument_list|(
name|bp
argument_list|)
operator|!=
literal|0
operator|||
name|DMU_OT_IS_METADATA
argument_list|(
name|type
argument_list|)
operator|)
operator|&&
name|type
operator|!=
name|DMU_OT_INTENT_LOG
condition|)
name|atomic_inc_64
argument_list|(
operator|&
name|sle
operator|->
name|sle_meta_count
argument_list|)
expr_stmt|;
else|else
name|atomic_inc_64
argument_list|(
operator|&
name|sle
operator|->
name|sle_data_count
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_inflight
operator|--
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Maximum number of concurrent scrub i/os to create while verifying  * a pool while importing it.  */
end_comment

begin_decl_stmt
name|int
name|spa_load_verify_maxinflight
init|=
literal|10000
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|spa_load_verify_metadata
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean_t
name|spa_load_verify_data
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|spa_load_verify_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|==
name|NULL
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * Note: normally this routine will not be called if 	 * spa_load_verify_metadata is not set.  However, it may be useful 	 * to manually set the flag after the traversal has begun. 	 */
if|if
condition|(
operator|!
name|spa_load_verify_metadata
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|BP_IS_METADATA
argument_list|(
name|bp
argument_list|)
operator|&&
operator|!
name|spa_load_verify_data
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|zio_t
modifier|*
name|rio
init|=
name|arg
decl_stmt|;
name|size_t
name|size
init|=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_scrub_inflight
operator|>=
name|spa_load_verify_maxinflight
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_io_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_scrub_inflight
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_scrub_lock
argument_list|)
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_read
argument_list|(
name|rio
argument_list|,
name|spa
argument_list|,
name|bp
argument_list|,
name|abd_alloc_for_io
argument_list|(
name|size
argument_list|,
name|B_FALSE
argument_list|)
argument_list|,
name|size
argument_list|,
name|spa_load_verify_done
argument_list|,
name|rio
operator|->
name|io_private
argument_list|,
name|ZIO_PRIORITY_SCRUB
argument_list|,
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SCRUB
operator||
name|ZIO_FLAG_RAW
argument_list|,
name|zb
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|verify_dataset_name_len
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
if|if
condition|(
name|dsl_dataset_namelen
argument_list|(
name|ds
argument_list|)
operator|>=
name|ZFS_MAX_DATASET_NAME_LEN
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_load_verify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|zio_t
modifier|*
name|rio
decl_stmt|;
name|spa_load_error_t
name|sle
init|=
block|{
literal|0
block|}
decl_stmt|;
name|zpool_rewind_policy_t
name|policy
decl_stmt|;
name|boolean_t
name|verify_ok
init|=
name|B_FALSE
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|zpool_get_rewind_policy
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
operator|&
name|policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|.
name|zrp_request
operator|&
name|ZPOOL_NEVER_REWIND
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|dsl_pool_config_enter
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_objset_find_dp
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_root_dir_obj
argument_list|,
name|verify_dataset_name_len
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|rio
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|sle
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_load_verify_metadata
condition|)
block|{
name|error
operator|=
name|traverse_pool
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_verify_min_txg
argument_list|,
name|TRAVERSE_PRE
operator||
name|TRAVERSE_PREFETCH_METADATA
argument_list|,
name|spa_load_verify_cb
argument_list|,
name|rio
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zio_wait
argument_list|(
name|rio
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_meta_errors
operator|=
name|sle
operator|.
name|sle_meta_count
expr_stmt|;
name|spa
operator|->
name|spa_load_data_errors
operator|=
name|sle
operator|.
name|sle_data_count
expr_stmt|;
if|if
condition|(
operator|!
name|error
operator|&&
name|sle
operator|.
name|sle_meta_count
operator|<=
name|policy
operator|.
name|zrp_maxmeta
operator|&&
name|sle
operator|.
name|sle_data_count
operator|<=
name|policy
operator|.
name|zrp_maxdata
condition|)
block|{
name|int64_t
name|loss
init|=
literal|0
decl_stmt|;
name|verify_ok
operator|=
name|B_TRUE
expr_stmt|;
name|spa
operator|->
name|spa_load_txg
operator|=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
expr_stmt|;
name|spa
operator|->
name|spa_load_txg_ts
operator|=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_timestamp
expr_stmt|;
name|loss
operator|=
name|spa
operator|->
name|spa_last_ubsync_txg_ts
operator|-
name|spa
operator|->
name|spa_load_txg_ts
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_LOAD_TIME
argument_list|,
name|spa
operator|->
name|spa_load_txg_ts
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_int64
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_REWIND_TIME
argument_list|,
name|loss
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_LOAD_DATA_ERRORS
argument_list|,
name|sle
operator|.
name|sle_data_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa
operator|->
name|spa_load_max_txg
operator|=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|ENXIO
operator|&&
name|error
operator|!=
name|EIO
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|verify_ok
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find a value in the pool props object.  */
end_comment

begin_function
specifier|static
name|void
name|spa_prop_find
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zpool_prop_t
name|prop
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Find a value in the pool directory object.  */
end_comment

begin_function
specifier|static
name|int
name|spa_dir_prop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
modifier|*
name|val
parameter_list|)
block|{
return|return
operator|(
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
name|val
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_vdev_err
parameter_list|(
name|vdev_t
modifier|*
name|vdev
parameter_list|,
name|vdev_aux_t
name|aux
parameter_list|,
name|int
name|err
parameter_list|)
block|{
name|vdev_set_state
argument_list|(
name|vdev
argument_list|,
name|B_TRUE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|aux
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Fix up config after a partly-completed split.  This is done with the  * ZPOOL_CONFIG_SPLIT nvlist.  Both the splitting pool and the split-off  * pool have that entry in their config, but only the splitting one contains  * a list of all the guids of the vdevs that are being split off.  *  * This function determines what to do with that list: either rejoin  * all the disks to the pool, or complete the splitting process.  To attempt  * the rejoin, each disk that is offlined is marked online again, and  * we do a reopen() call.  If the vdev label for every disk that was  * marked online indicates it was successfully split off (VDEV_AUX_SPLIT_POOL)  * then we call vdev_split() on each disk, and complete the split.  *  * Otherwise we leave the config alone, with all the vdevs in place in  * the original pool.  */
end_comment

begin_function
specifier|static
name|void
name|spa_try_repair
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|uint_t
name|extracted
decl_stmt|;
name|uint64_t
modifier|*
name|glist
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|gcount
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|vdev_t
modifier|*
modifier|*
name|vd
decl_stmt|;
name|boolean_t
name|attempt_reopen
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_SPLIT
argument_list|,
operator|&
name|nvl
argument_list|)
operator|!=
literal|0
condition|)
return|return;
comment|/* check that the config is complete */
if|if
condition|(
name|nvlist_lookup_uint64_array
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_SPLIT_LIST
argument_list|,
operator|&
name|glist
argument_list|,
operator|&
name|gcount
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|vd
operator|=
name|kmem_zalloc
argument_list|(
name|gcount
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* attempt to online all the vdevs& validate */
name|attempt_reopen
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|glist
index|[
name|i
index|]
operator|==
literal|0
condition|)
comment|/* vdev is hole */
continue|continue;
name|vd
index|[
name|i
index|]
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|glist
index|[
name|i
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * Don't bother attempting to reopen the disks; 			 * just do the split. 			 */
name|attempt_reopen
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
comment|/* attempt to re-online it */
name|vd
index|[
name|i
index|]
operator|->
name|vdev_offline
operator|=
name|B_FALSE
expr_stmt|;
block|}
block|}
if|if
condition|(
name|attempt_reopen
condition|)
block|{
name|vdev_reopen
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
comment|/* check each device to see what state it's in */
for|for
control|(
name|extracted
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vd
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
name|vd
index|[
name|i
index|]
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|!=
name|VDEV_AUX_SPLIT_POOL
condition|)
break|break;
operator|++
name|extracted
expr_stmt|;
block|}
block|}
comment|/* 	 * If every disk has been moved to the new pool, or if we never 	 * even attempted to look at them, then we split them off for 	 * good. 	 */
if|if
condition|(
operator|!
name|attempt_reopen
operator|||
name|gcount
operator|==
name|extracted
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|gcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|vd
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|vdev_split
argument_list|(
name|vd
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vdev_reopen
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|vd
argument_list|,
name|gcount
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_load
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_load_state_t
name|state
parameter_list|,
name|spa_import_type_t
name|type
parameter_list|,
name|boolean_t
name|mosconfig
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
init|=
name|spa
operator|->
name|spa_config
decl_stmt|;
name|char
modifier|*
name|ereport
init|=
name|FM_EREPORT_ZFS_POOL
decl_stmt|;
name|char
modifier|*
name|comment
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|pool_guid
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pool_guid
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_comment
operator|==
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_COMMENT
argument_list|,
operator|&
name|comment
argument_list|)
operator|==
literal|0
condition|)
name|spa
operator|->
name|spa_comment
operator|=
name|spa_strdup
argument_list|(
name|comment
argument_list|)
expr_stmt|;
comment|/* 	 * Versioning wasn't explicitly added to the label until later, so if 	 * it's not present treat it as the initial version. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
operator|&
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
argument_list|)
operator|!=
literal|0
condition|)
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|=
name|SPA_VERSION_INITIAL
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_txg
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|state
operator|==
name|SPA_LOAD_IMPORT
operator|||
name|state
operator|==
name|SPA_LOAD_TRYIMPORT
operator|)
operator|&&
name|spa_guid_exists
argument_list|(
name|pool_guid
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa
operator|->
name|spa_config_guid
operator|=
name|pool_guid
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_SPLIT
argument_list|,
operator|&
name|nvl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|nvl
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_splitting
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_info
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|gethrestime
argument_list|(
operator|&
name|spa
operator|->
name|spa_loaded_ts
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_load_impl
argument_list|(
name|spa
argument_list|,
name|pool_guid
argument_list|,
name|config
argument_list|,
name|state
argument_list|,
name|type
argument_list|,
name|mosconfig
argument_list|,
operator|&
name|ereport
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Don't count references from objsets that are already closed 	 * and are making their way through the eviction process. 	 */
name|spa_evicting_os_wait
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_minref
operator|=
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|error
operator|!=
name|EEXIST
condition|)
block|{
name|spa
operator|->
name|spa_loaded_ts
operator|.
name|tv_sec
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_loaded_ts
operator|.
name|tv_nsec
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
name|EBADF
condition|)
block|{
name|zfs_ereport_post
argument_list|(
name|ereport
argument_list|,
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|spa
operator|->
name|spa_load_state
operator|=
name|error
condition|?
name|SPA_LOAD_ERROR
else|:
name|SPA_LOAD_NONE
expr_stmt|;
name|spa
operator|->
name|spa_ena
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Count the number of per-vdev ZAPs associated with all of the vdevs in the  * vdev tree rooted in the given vd, and ensure that each ZAP is present in the  * spa's per-vdev ZAP list.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|vdev_count_verify_zaps
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|uint64_t
name|total
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_top_zap
operator|!=
literal|0
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|ASSERT0
argument_list|(
name|zap_lookup_int
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|,
name|vd
operator|->
name|vdev_top_zap
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_leaf_zap
operator|!=
literal|0
condition|)
block|{
name|total
operator|++
expr_stmt|;
name|ASSERT0
argument_list|(
name|zap_lookup_int
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|,
name|vd
operator|->
name|vdev_leaf_zap
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|uint64_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|i
operator|++
control|)
block|{
name|total
operator|+=
name|vdev_count_verify_zaps
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Load an existing storage pool, using the pool's builtin spa_config as a  * source of configuration information.  */
end_comment

begin_function
specifier|static
name|int
name|spa_load_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|pool_guid
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|spa_load_state_t
name|state
parameter_list|,
name|spa_import_type_t
name|type
parameter_list|,
name|boolean_t
name|mosconfig
parameter_list|,
name|char
modifier|*
modifier|*
name|ereport
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|;
name|uberblock_t
modifier|*
name|ub
init|=
operator|&
name|spa
operator|->
name|spa_uberblock
decl_stmt|;
name|uint64_t
name|children
decl_stmt|,
name|config_cache_txg
init|=
name|spa
operator|->
name|spa_config_txg
decl_stmt|;
name|int
name|orig_mode
init|=
name|spa
operator|->
name|spa_mode
decl_stmt|;
name|int
name|parse
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|boolean_t
name|missing_feat_write
init|=
name|B_FALSE
decl_stmt|;
comment|/* 	 * If this is an untrusted config, access the pool in read-only mode. 	 * This prevents things like resilvering recently removed devices. 	 */
if|if
condition|(
operator|!
name|mosconfig
condition|)
name|spa
operator|->
name|spa_mode
operator|=
name|FREAD
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_state
operator|=
name|state
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|parse
operator|=
operator|(
name|type
operator|==
name|SPA_IMPORT_EXISTING
condition|?
name|VDEV_ALLOC_LOAD
else|:
name|VDEV_ALLOC_SPLIT
operator|)
expr_stmt|;
comment|/* 	 * Create "The Godfather" zio to hold all async IOs 	 */
name|spa
operator|->
name|spa_async_zio_root
operator|=
name|kmem_alloc
argument_list|(
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|spa
operator|->
name|spa_async_zio_root
index|[
name|i
index|]
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_GODFATHER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Parse the configuration into a vdev tree.  We explicitly set the 	 * value that will be returned by spa_version() since parsing the 	 * configuration requires knowing the version number. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|rvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|parse
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root_vdev
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_min_ashift
argument_list|,
operator|>=
argument_list|,
name|SPA_MINBLOCKSHIFT
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_max_ashift
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSHIFT
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|!=
name|SPA_IMPORT_ASSEMBLE
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|==
name|pool_guid
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Try to open all vdevs, loading each label in the process. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|vdev_open
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * We need to validate the vdev labels against the configuration that 	 * we have in hand, which is dependent on the setting of mosconfig. If 	 * mosconfig is true then we're validating the vdev labels based on 	 * that config.  Otherwise, we're validating against the cached config 	 * (zpool.cache) that was read when we loaded the zfs module, and then 	 * later we will recursively call spa_load() and validate against 	 * the vdev config. 	 * 	 * If we're assembling a new pool that's been split off from an 	 * existing pool, the labels haven't yet been updated so we skip 	 * validation for now. 	 */
if|if
condition|(
name|type
operator|!=
name|SPA_IMPORT_ASSEMBLE
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|vdev_validate
argument_list|(
name|rvd
argument_list|,
name|mosconfig
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|rvd
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Find the best uberblock. 	 */
name|vdev_uberblock_load
argument_list|(
name|rvd
argument_list|,
name|ub
argument_list|,
operator|&
name|label
argument_list|)
expr_stmt|;
comment|/* 	 * If we weren't able to find a single valid uberblock, return failure. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_txg
operator|==
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|ENXIO
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * If the pool has an unsupported version we can't open it. 	 */
if|if
condition|(
operator|!
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|ub
operator|->
name|ub_version
argument_list|)
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_VERSION_NEWER
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ub
operator|->
name|ub_version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|nvlist_t
modifier|*
name|features
decl_stmt|;
comment|/* 		 * If we weren't able to find what's necessary for reading the 		 * MOS in the label, return failure. 		 */
if|if
condition|(
name|label
operator|==
name|NULL
operator|||
name|nvlist_lookup_nvlist
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_FEATURES_FOR_READ
argument_list|,
operator|&
name|features
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|ENXIO
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Update our in-core representation with the definitive values 		 * from the label. 		 */
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_label_features
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|features
argument_list|,
operator|&
name|spa
operator|->
name|spa_label_features
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
comment|/* 	 * Look through entries in the label nvlist's features_for_read. If 	 * there is a feature listed there which we don't understand then we 	 * cannot open a pool. 	 */
if|if
condition|(
name|ub
operator|->
name|ub_version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|nvlist_t
modifier|*
name|unsup_feat
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|unsup_feat
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|nvpair_t
modifier|*
name|nvp
init|=
name|nvlist_next_nvpair
argument_list|(
name|spa
operator|->
name|spa_label_features
argument_list|,
name|NULL
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|spa
operator|->
name|spa_label_features
argument_list|,
name|nvp
argument_list|)
control|)
block|{
if|if
condition|(
operator|!
name|zfeature_is_supported
argument_list|(
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|)
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|unsup_feat
argument_list|,
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
argument_list|,
literal|""
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|nvlist_empty
argument_list|(
name|unsup_feat
argument_list|)
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_UNSUP_FEAT
argument_list|,
name|unsup_feat
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|unsup_feat
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_UNSUP_FEAT
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|unsup_feat
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the vdev guid sum doesn't match the uberblock, we have an 	 * incomplete configuration.  We first check to see if the pool 	 * is aware of the complete config (i.e ZPOOL_CONFIG_VDEV_CHILDREN). 	 * If it is, defer the vdev_guid_sum check till later so we 	 * can handle missing vdevs. 	 */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_CHILDREN
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
operator|&&
name|mosconfig
operator|&&
name|type
operator|!=
name|SPA_IMPORT_ASSEMBLE
operator|&&
name|rvd
operator|->
name|vdev_guid_sum
operator|!=
name|ub
operator|->
name|ub_guid_sum
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_BAD_GUID_SUM
argument_list|,
name|ENXIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|type
operator|!=
name|SPA_IMPORT_ASSEMBLE
operator|&&
name|spa
operator|->
name|spa_config_splitting
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_try_repair
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config_splitting
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_splitting
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * Initialize internal SPA structures. 	 */
name|spa
operator|->
name|spa_state
operator|=
name|POOL_STATE_ACTIVE
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|spa
operator|->
name|spa_verify_min_txg
operator|=
name|spa
operator|->
name|spa_extreme_rewind
condition|?
name|TXG_INITIAL
operator|-
literal|1
else|:
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|-
name|TXG_DEFER_SIZE
operator|-
literal|1
expr_stmt|;
name|spa
operator|->
name|spa_first_txg
operator|=
name|spa
operator|->
name|spa_last_ubsync_txg
condition|?
name|spa
operator|->
name|spa_last_ubsync_txg
else|:
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
literal|1
expr_stmt|;
name|spa
operator|->
name|spa_claim_max_txg
operator|=
name|spa
operator|->
name|spa_first_txg
expr_stmt|;
name|spa
operator|->
name|spa_prev_software_version
operator|=
name|ub
operator|->
name|ub_software_version
expr_stmt|;
name|error
operator|=
name|dsl_pool_init
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_first_txg
argument_list|,
operator|&
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|spa
operator|->
name|spa_meta_objset
operator|=
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_meta_objset
expr_stmt|;
if|if
condition|(
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_CONFIG
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_object
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|boolean_t
name|missing_feat_read
init|=
name|B_FALSE
decl_stmt|;
name|nvlist_t
modifier|*
name|unsup_feat
decl_stmt|,
modifier|*
name|enabled_feat
decl_stmt|;
if|if
condition|(
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_FEATURES_FOR_READ
argument_list|,
operator|&
name|spa
operator|->
name|spa_feat_for_read_obj
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_FEATURES_FOR_WRITE
argument_list|,
operator|&
name|spa
operator|->
name|spa_feat_for_write_obj
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_FEATURE_DESCRIPTIONS
argument_list|,
operator|&
name|spa
operator|->
name|spa_feat_desc_obj
argument_list|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
name|enabled_feat
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|unsup_feat
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|spa_features_check
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|unsup_feat
argument_list|,
name|enabled_feat
argument_list|)
condition|)
name|missing_feat_read
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|||
name|state
operator|==
name|SPA_LOAD_TRYIMPORT
condition|)
block|{
if|if
condition|(
operator|!
name|spa_features_check
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|,
name|unsup_feat
argument_list|,
name|enabled_feat
argument_list|)
condition|)
block|{
name|missing_feat_write
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
name|fnvlist_add_nvlist
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_ENABLED_FEAT
argument_list|,
name|enabled_feat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nvlist_empty
argument_list|(
name|unsup_feat
argument_list|)
condition|)
block|{
name|fnvlist_add_nvlist
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_UNSUP_FEAT
argument_list|,
name|unsup_feat
argument_list|)
expr_stmt|;
block|}
name|fnvlist_free
argument_list|(
name|enabled_feat
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|unsup_feat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|missing_feat_read
condition|)
block|{
name|fnvlist_add_boolean
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|,
name|ZPOOL_CONFIG_CAN_RDONLY
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * If the state is SPA_LOAD_TRYIMPORT, our objective is 		 * twofold: to determine whether the pool is available for 		 * import in read-write mode and (if it is not) whether the 		 * pool is available for import in read-only mode. If the pool 		 * is available for import in read-write mode, it is displayed 		 * as available in userland; if it is not available for import 		 * in read-only mode, it is displayed as unavailable in 		 * userland. If the pool is available for import in read-only 		 * mode but not read-write mode, it is displayed as unavailable 		 * in userland with a special note that the pool is actually 		 * available for open in read-only mode. 		 * 		 * As a result, if the state is SPA_LOAD_TRYIMPORT and we are 		 * missing a feature for write, we must first determine whether 		 * the pool can be opened read-only before returning to 		 * userland in order to know whether to display the 		 * abovementioned note. 		 */
if|if
condition|(
name|missing_feat_read
operator|||
operator|(
name|missing_feat_write
operator|&&
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|)
condition|)
block|{
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_UNSUP_FEAT
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Load refcounts for ZFS features from disk into an in-memory 		 * cache during SPA initialization. 		 */
for|for
control|(
name|spa_feature_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|SPA_FEATURES
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|refcount
decl_stmt|;
name|error
operator|=
name|feature_get_refcount_from_disk
argument_list|(
name|spa
argument_list|,
operator|&
name|spa_feature_table
index|[
name|i
index|]
argument_list|,
operator|&
name|refcount
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_feat_refcount_cache
index|[
name|i
index|]
operator|=
name|refcount
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOTSUP
condition|)
block|{
name|spa
operator|->
name|spa_feat_refcount_cache
index|[
name|i
index|]
operator|=
name|SPA_FEATURE_DISABLED
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
block|}
block|}
if|if
condition|(
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_ENABLED_TXG
argument_list|)
condition|)
block|{
if|if
condition|(
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_FEATURE_ENABLED_TXG
argument_list|,
operator|&
name|spa
operator|->
name|spa_feat_enabled_txg_obj
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
name|spa
operator|->
name|spa_is_initializing
operator|=
name|B_TRUE
expr_stmt|;
name|error
operator|=
name|dsl_pool_open
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_is_initializing
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|mosconfig
condition|)
block|{
name|uint64_t
name|hostid
decl_stmt|;
name|nvlist_t
modifier|*
name|policy
init|=
name|NULL
decl_stmt|,
modifier|*
name|nvconfig
decl_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
operator|&
name|nvconfig
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|spa_is_root
argument_list|(
name|spa
argument_list|)
operator|&&
name|nvlist_lookup_uint64
argument_list|(
name|nvconfig
argument_list|,
name|ZPOOL_CONFIG_HOSTID
argument_list|,
operator|&
name|hostid
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|hostname
decl_stmt|;
name|unsigned
name|long
name|myhostid
init|=
literal|0
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|nvconfig
argument_list|,
name|ZPOOL_CONFIG_HOSTNAME
argument_list|,
operator|&
name|hostname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|myhostid
operator|=
name|zone_get_hostid
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* _KERNEL */
comment|/* 			 * We're emulating the system's hostid in userland, so 			 * we can't use zone_get_hostid(). 			 */
operator|(
name|void
operator|)
name|ddi_strtoul
argument_list|(
name|hw_serial
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|,
operator|&
name|myhostid
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* _KERNEL */
if|if
condition|(
name|hostid
operator|!=
literal|0
operator|&&
name|myhostid
operator|!=
literal|0
operator|&&
name|hostid
operator|!=
name|myhostid
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvconfig
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"pool '%s' could not be "
literal|"loaded as it was last accessed by "
literal|"another system (host: %s hostid: 0x%lx). "
literal|"See: http://illumos.org/msg/ZFS-8000-EY"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|hostname
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|hostid
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBADF
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|ZPOOL_REWIND_POLICY
argument_list|,
operator|&
name|policy
argument_list|)
operator|==
literal|0
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|nvconfig
argument_list|,
name|ZPOOL_REWIND_POLICY
argument_list|,
name|policy
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|nvconfig
argument_list|)
expr_stmt|;
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|orig_mode
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_load
argument_list|(
name|spa
argument_list|,
name|state
argument_list|,
name|SPA_IMPORT_EXISTING
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
comment|/* Grab the secret checksum salt from the MOS. */
name|error
operator|=
name|zap_lookup
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CHECKSUM_SALT
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|)
argument_list|,
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
comment|/* Generate a new salt for subsequent use */
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_SYNC_BPOBJ
argument_list|,
operator|&
name|obj
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|error
operator|=
name|bpobj_open
argument_list|(
operator|&
name|spa
operator|->
name|spa_deferred_bpobj
argument_list|,
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
comment|/* 	 * Load the bit that tells us to use the new accounting function 	 * (raid-z deflation).  If we have an older pool, this will not 	 * be present. 	 */
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_CREATION_VERSION
argument_list|,
operator|&
name|spa
operator|->
name|spa_creation_version
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
comment|/* 	 * Load the persistent error log.  If we have an older pool, this will 	 * not be present. 	 */
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_ERRLOG_LAST
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_last
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_ERRLOG_SCRUB
argument_list|,
operator|&
name|spa
operator|->
name|spa_errlog_scrub
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
comment|/* 	 * Load the history object.  If we have an older pool, this 	 * will not be present. 	 */
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_HISTORY
argument_list|,
operator|&
name|spa
operator|->
name|spa_history
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
comment|/* 	 * Load the per-vdev ZAP map. If we have an older pool, this will not 	 * be present; in this case, defer its creation to a later time to 	 * avoid dirtying the MOS this early / out of sync context. See 	 * spa_sync_config_object. 	 */
comment|/* The sentinel is only available in the MOS config. */
name|nvlist_t
modifier|*
name|mos_config
decl_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
operator|&
name|mos_config
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_VDEV_ZAP_MAP
argument_list|,
operator|&
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
name|VERIFY
argument_list|(
operator|!
name|nvlist_exists
argument_list|(
name|mos_config
argument_list|,
name|ZPOOL_CONFIG_HAS_PER_VDEV_ZAPS
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_avz_action
operator|=
name|AVZ_ACTION_INITIALIZE
expr_stmt|;
name|ASSERT0
argument_list|(
name|vdev_count_verify_zaps
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|!
name|nvlist_exists
argument_list|(
name|mos_config
argument_list|,
name|ZPOOL_CONFIG_HAS_PER_VDEV_ZAPS
argument_list|)
condition|)
block|{
comment|/* 		 * An older version of ZFS overwrote the sentinel value, so 		 * we have orphaned per-vdev ZAPs in the MOS. Defer their 		 * destruction to later; see spa_sync_config_object. 		 */
name|spa
operator|->
name|spa_avz_action
operator|=
name|AVZ_ACTION_DESTROY
expr_stmt|;
comment|/* 		 * We're assuming that no vdevs have had their ZAPs created 		 * before this. Better be sure of it. 		 */
name|ASSERT0
argument_list|(
name|vdev_count_verify_zaps
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|mos_config
argument_list|)
expr_stmt|;
comment|/* 	 * If we're assembling the pool from the split-off vdevs of 	 * an existing pool, we don't want to attach the spares& cache 	 * devices. 	 */
comment|/* 	 * Load any hot spares for this pool. 	 */
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_SPARES
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|type
operator|!=
name|SPA_IMPORT_ASSEMBLE
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_SPARES
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_object
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * Load any level 2 ARC devices for this pool. 	 */
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_L2CACHE
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|type
operator|!=
name|SPA_IMPORT_ASSEMBLE
condition|)
block|{
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_L2CACHE
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_object
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|spa
operator|->
name|spa_delegation
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_DELEGATION
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_dir_prop
argument_list|(
name|spa
argument_list|,
name|DMU_POOL_PROPS
argument_list|,
operator|&
name|spa
operator|->
name|spa_pool_props_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
name|error
operator|!=
name|ENOENT
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|uint64_t
name|autoreplace
decl_stmt|;
name|spa_prop_find
argument_list|(
name|spa
argument_list|,
name|ZPOOL_PROP_BOOTFS
argument_list|,
operator|&
name|spa
operator|->
name|spa_bootfs
argument_list|)
expr_stmt|;
name|spa_prop_find
argument_list|(
name|spa
argument_list|,
name|ZPOOL_PROP_AUTOREPLACE
argument_list|,
operator|&
name|autoreplace
argument_list|)
expr_stmt|;
name|spa_prop_find
argument_list|(
name|spa
argument_list|,
name|ZPOOL_PROP_DELEGATION
argument_list|,
operator|&
name|spa
operator|->
name|spa_delegation
argument_list|)
expr_stmt|;
name|spa_prop_find
argument_list|(
name|spa
argument_list|,
name|ZPOOL_PROP_FAILUREMODE
argument_list|,
operator|&
name|spa
operator|->
name|spa_failmode
argument_list|)
expr_stmt|;
name|spa_prop_find
argument_list|(
name|spa
argument_list|,
name|ZPOOL_PROP_AUTOEXPAND
argument_list|,
operator|&
name|spa
operator|->
name|spa_autoexpand
argument_list|)
expr_stmt|;
name|spa_prop_find
argument_list|(
name|spa
argument_list|,
name|ZPOOL_PROP_BOOTSIZE
argument_list|,
operator|&
name|spa
operator|->
name|spa_bootsize
argument_list|)
expr_stmt|;
name|spa_prop_find
argument_list|(
name|spa
argument_list|,
name|ZPOOL_PROP_DEDUPDITTO
argument_list|,
operator|&
name|spa
operator|->
name|spa_dedup_ditto
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_autoreplace
operator|=
operator|(
name|autoreplace
operator|!=
literal|0
operator|)
expr_stmt|;
block|}
comment|/* 	 * If the 'autoreplace' property is set, then post a resource notifying 	 * the ZFS DE that it should not issue any faults for unopenable 	 * devices.  We also iterate over the vdevs, and post a sysevent for any 	 * unopenable vdevs so that the normal autoreplace handler can take 	 * over. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_autoreplace
operator|&&
name|state
operator|!=
name|SPA_LOAD_TRYIMPORT
condition|)
block|{
name|spa_check_removed
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
comment|/* 		 * For the import case, this is done in spa_import(), because 		 * at this point we're using the spare definitions from 		 * the MOS config, not necessarily from the userland config. 		 */
if|if
condition|(
name|state
operator|!=
name|SPA_LOAD_IMPORT
condition|)
block|{
name|spa_aux_check_removed
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
argument_list|)
expr_stmt|;
name|spa_aux_check_removed
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Load the vdev state for all toplevel vdevs. 	 */
name|vdev_load
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
comment|/* 	 * Propagate the leaf DTLs we just loaded all the way up the tree. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|vdev_dtl_reassess
argument_list|(
name|rvd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * Load the DDTs (dedup tables). 	 */
name|error
operator|=
name|ddt_load
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
name|spa_update_dspace
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Validate the config, using the MOS config to fill in any 	 * information which might be missing.  If we fail to validate 	 * the config then declare the pool unfit for use. If we're 	 * assembling a pool from a split, the log is not transferred 	 * over. 	 */
if|if
condition|(
name|type
operator|!=
name|SPA_IMPORT_ASSEMBLE
condition|)
block|{
name|nvlist_t
modifier|*
name|nvconfig
decl_stmt|;
if|if
condition|(
name|load_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
operator|&
name|nvconfig
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|spa_config_valid
argument_list|(
name|spa
argument_list|,
name|nvconfig
argument_list|)
condition|)
block|{
name|nvlist_free
argument_list|(
name|nvconfig
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_BAD_GUID_SUM
argument_list|,
name|ENXIO
argument_list|)
operator|)
return|;
block|}
name|nvlist_free
argument_list|(
name|nvconfig
argument_list|)
expr_stmt|;
comment|/* 		 * Now that we've validated the config, check the state of the 		 * root vdev.  If it can't be opened, it indicates one or 		 * more toplevel vdevs are faulted. 		 */
if|if
condition|(
name|rvd
operator|->
name|vdev_state
operator|<=
name|VDEV_STATE_CANT_OPEN
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|&&
name|spa_check_logs
argument_list|(
name|spa
argument_list|)
condition|)
block|{
operator|*
name|ereport
operator|=
name|FM_EREPORT_ZFS_LOG_REPLAY
expr_stmt|;
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_BAD_LOG
argument_list|,
name|ENXIO
argument_list|)
operator|)
return|;
block|}
block|}
if|if
condition|(
name|missing_feat_write
condition|)
block|{
name|ASSERT
argument_list|(
name|state
operator|==
name|SPA_LOAD_TRYIMPORT
argument_list|)
expr_stmt|;
comment|/* 		 * At this point, we know that we can open the pool in 		 * read-only mode but not read-write mode. We now have enough 		 * information and can return to userland. 		 */
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_UNSUP_FEAT
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * We've successfully opened the pool, verify that we're ready 	 * to start pushing transactions. 	 */
if|if
condition|(
name|state
operator|!=
name|SPA_LOAD_TRYIMPORT
condition|)
block|{
if|if
condition|(
name|error
operator|=
name|spa_load_verify
argument_list|(
name|spa
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_err
argument_list|(
name|rvd
argument_list|,
name|VDEV_AUX_CORRUPT_DATA
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|&&
operator|(
name|state
operator|==
name|SPA_LOAD_RECOVER
operator|||
name|spa
operator|->
name|spa_load_max_txg
operator|==
name|UINT64_MAX
operator|)
condition|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|need_update
init|=
name|B_FALSE
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|state
operator|!=
name|SPA_LOAD_TRYIMPORT
argument_list|)
expr_stmt|;
comment|/* 		 * Claim log blocks that haven't been committed yet. 		 * This must all happen in a single txg. 		 * Note: spa_claim_max_txg is updated by spa_claim_notify(), 		 * invoked from zil_claim_log_block()'s i/o done callback. 		 * Price of rollback is that we abandon the log. 		 */
name|spa
operator|->
name|spa_claiming
operator|=
name|B_TRUE
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|spa_first_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_objset_find_dp
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|zil_claim
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_claiming
operator|=
name|B_FALSE
expr_stmt|;
name|spa_set_log_state
argument_list|(
name|spa
argument_list|,
name|SPA_LOG_GOOD
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_TRUE
expr_stmt|;
name|txg_sync_start
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for all claims to sync.  We sync up to the highest 		 * claimed log block birth time so that claimed log blocks 		 * don't appear to be from the future.  spa_claim_max_txg 		 * will have been set for us by either zil_check_log_chain() 		 * (invoked from spa_check_logs()) or zil_claim() above. 		 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|spa
operator|->
name|spa_claim_max_txg
argument_list|)
expr_stmt|;
comment|/* 		 * If the config cache is stale, or we have uninitialized 		 * metaslabs (see spa_vdev_add()), then update the config. 		 * 		 * If this is a verbatim import, trust the current 		 * in-core spa_config and update the disk labels. 		 */
if|if
condition|(
name|config_cache_txg
operator|!=
name|spa
operator|->
name|spa_config_txg
operator|||
name|state
operator|==
name|SPA_LOAD_IMPORT
operator|||
name|state
operator|==
name|SPA_LOAD_RECOVER
operator|||
operator|(
name|spa
operator|->
name|spa_import_flags
operator|&
name|ZFS_IMPORT_VERBATIM
operator|)
condition|)
name|need_update
operator|=
name|B_TRUE
expr_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
if|if
condition|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_ms_array
operator|==
literal|0
condition|)
name|need_update
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 		 * Update the config cache asychronously in case we're the 		 * root pool, in which case the config cache isn't writable yet. 		 */
if|if
condition|(
name|need_update
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_CONFIG_UPDATE
argument_list|)
expr_stmt|;
comment|/* 		 * Check all DTLs to see if anything needs resilvering. 		 */
if|if
condition|(
operator|!
name|dsl_scan_resilvering
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
operator|&&
name|vdev_resilver_needed
argument_list|(
name|rvd
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_RESILVER
argument_list|)
expr_stmt|;
comment|/* 		 * Log the fact that we booted up (so that we can detect if 		 * we rebooted in the middle of an operation). 		 */
name|spa_history_log_version
argument_list|(
name|spa
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
comment|/* 		 * Delete any inconsistent datasets. 		 */
operator|(
name|void
operator|)
name|dmu_objset_find
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|dsl_destroy_inconsistent
argument_list|,
name|NULL
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
expr_stmt|;
comment|/* 		 * Clean up any stale temporary dataset userrefs. 		 */
name|dsl_pool_clean_tmp_userrefs
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_load_retry
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_load_state_t
name|state
parameter_list|,
name|int
name|mosconfig
parameter_list|)
block|{
name|int
name|mode
init|=
name|spa
operator|->
name|spa_mode
decl_stmt|;
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_max_txg
operator|=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|-
literal|1
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_load
argument_list|(
name|spa
argument_list|,
name|state
argument_list|,
name|SPA_IMPORT_EXISTING
argument_list|,
name|mosconfig
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If spa_load() fails this function will try loading prior txg's. If  * 'state' is SPA_LOAD_RECOVER and one of these loads succeeds the pool  * will be rewound to that txg. If 'state' is not SPA_LOAD_RECOVER this  * function will not rewind the pool and will return the same error as  * spa_load().  */
end_comment

begin_function
specifier|static
name|int
name|spa_load_best
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_load_state_t
name|state
parameter_list|,
name|int
name|mosconfig
parameter_list|,
name|uint64_t
name|max_request
parameter_list|,
name|int
name|rewind_flags
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|loadinfo
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|int
name|load_error
decl_stmt|,
name|rewind_error
decl_stmt|;
name|uint64_t
name|safe_rewind_txg
decl_stmt|;
name|uint64_t
name|min_txg
decl_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_load_txg
operator|&&
name|state
operator|==
name|SPA_LOAD_RECOVER
condition|)
block|{
name|spa
operator|->
name|spa_load_max_txg
operator|=
name|spa
operator|->
name|spa_load_txg
expr_stmt|;
name|spa_set_log_state
argument_list|(
name|spa
argument_list|,
name|SPA_LOG_CLEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa
operator|->
name|spa_load_max_txg
operator|=
name|max_request
expr_stmt|;
if|if
condition|(
name|max_request
operator|!=
name|UINT64_MAX
condition|)
name|spa
operator|->
name|spa_extreme_rewind
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|load_error
operator|=
name|rewind_error
operator|=
name|spa_load
argument_list|(
name|spa
argument_list|,
name|state
argument_list|,
name|SPA_IMPORT_EXISTING
argument_list|,
name|mosconfig
argument_list|)
expr_stmt|;
if|if
condition|(
name|load_error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_last_ubsync_txg
operator|=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
expr_stmt|;
name|spa
operator|->
name|spa_last_ubsync_txg_ts
operator|=
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_timestamp
expr_stmt|;
if|if
condition|(
name|rewind_flags
operator|&
name|ZPOOL_NEVER_REWIND
condition|)
block|{
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
name|load_error
operator|)
return|;
block|}
if|if
condition|(
name|state
operator|==
name|SPA_LOAD_RECOVER
condition|)
block|{
comment|/* Price of rolling back is discarding txgs, including log */
name|spa_set_log_state
argument_list|(
name|spa
argument_list|,
name|SPA_LOG_CLEAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If we aren't rolling back save the load info from our first 		 * import attempt so that we can restore it after attempting 		 * to rewind. 		 */
name|loadinfo
operator|=
name|spa
operator|->
name|spa_load_info
expr_stmt|;
name|spa
operator|->
name|spa_load_info
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
block|}
name|spa
operator|->
name|spa_load_max_txg
operator|=
name|spa
operator|->
name|spa_last_ubsync_txg
expr_stmt|;
name|safe_rewind_txg
operator|=
name|spa
operator|->
name|spa_last_ubsync_txg
operator|-
name|TXG_DEFER_SIZE
expr_stmt|;
name|min_txg
operator|=
operator|(
name|rewind_flags
operator|&
name|ZPOOL_EXTREME_REWIND
operator|)
condition|?
name|TXG_INITIAL
else|:
name|safe_rewind_txg
expr_stmt|;
comment|/* 	 * Continue as long as we're finding errors, we're still within 	 * the acceptable rewind range, and we're still finding uberblocks 	 */
while|while
condition|(
name|rewind_error
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|>=
name|min_txg
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|<=
name|spa
operator|->
name|spa_load_max_txg
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_load_max_txg
operator|<
name|safe_rewind_txg
condition|)
name|spa
operator|->
name|spa_extreme_rewind
operator|=
name|B_TRUE
expr_stmt|;
name|rewind_error
operator|=
name|spa_load_retry
argument_list|(
name|spa
argument_list|,
name|state
argument_list|,
name|mosconfig
argument_list|)
expr_stmt|;
block|}
name|spa
operator|->
name|spa_extreme_rewind
operator|=
name|B_FALSE
expr_stmt|;
name|spa
operator|->
name|spa_load_max_txg
operator|=
name|UINT64_MAX
expr_stmt|;
if|if
condition|(
name|config
operator|&&
operator|(
name|rewind_error
operator|||
name|state
operator|!=
name|SPA_LOAD_RECOVER
operator|)
condition|)
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|==
name|SPA_LOAD_RECOVER
condition|)
block|{
name|ASSERT3P
argument_list|(
name|loadinfo
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|rewind_error
operator|)
return|;
block|}
else|else
block|{
comment|/* Store the rewind info as part of the initial load info */
name|fnvlist_add_nvlist
argument_list|(
name|loadinfo
argument_list|,
name|ZPOOL_CONFIG_REWIND_INFO
argument_list|,
name|spa
operator|->
name|spa_load_info
argument_list|)
expr_stmt|;
comment|/* Restore the initial load info */
name|fnvlist_free
argument_list|(
name|spa
operator|->
name|spa_load_info
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_info
operator|=
name|loadinfo
expr_stmt|;
return|return
operator|(
name|load_error
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pool Open/Import  *  * The import case is identical to an open except that the configuration is sent  * down from userland, instead of grabbed from the configuration cache.  For the  * case of an open, the pool configuration will exist in the  * POOL_STATE_UNINITIALIZED state.  *  * The stats information (gen/count/ustats) is used to gather vdev statistics at  * the same time open the pool, without having to keep around the spa_t in some  * ambiguous state.  */
end_comment

begin_function
specifier|static
name|int
name|spa_open_common
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spapp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|nvlist_t
modifier|*
name|nvpolicy
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|spa_load_state_t
name|state
init|=
name|SPA_LOAD_OPEN
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|locked
init|=
name|B_FALSE
decl_stmt|;
operator|*
name|spapp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * As disgusting as this is, we need to support recursive calls to this 	 * function because dsl_dir_open() is called during spa_load(), and ends 	 * up calling spa_open() again.  The real fix is to figure out how to 	 * avoid dsl_dir_open() calling this in the first place. 	 */
if|if
condition|(
name|mutex_owner
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
operator|!=
name|curthread
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|locked
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|==
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|zpool_rewind_policy_t
name|policy
decl_stmt|;
name|zpool_get_rewind_policy
argument_list|(
name|nvpolicy
condition|?
name|nvpolicy
else|:
name|spa
operator|->
name|spa_config
argument_list|,
operator|&
name|policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|.
name|zrp_request
operator|&
name|ZPOOL_DO_REWIND
condition|)
name|state
operator|=
name|SPA_LOAD_RECOVER
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|spa_mode_global
argument_list|)
expr_stmt|;
if|if
condition|(
name|state
operator|!=
name|SPA_LOAD_RECOVER
condition|)
name|spa
operator|->
name|spa_last_ubsync_txg
operator|=
name|spa
operator|->
name|spa_load_txg
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|spa_load_best
argument_list|(
name|spa
argument_list|,
name|state
argument_list|,
name|B_FALSE
argument_list|,
name|policy
operator|.
name|zrp_txg
argument_list|,
name|policy
operator|.
name|zrp_request
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|EBADF
condition|)
block|{
comment|/* 			 * If vdev_validate() returns failure (indicated by 			 * EBADF), it indicates that one of the vdevs indicates 			 * that the pool has been exported or destroyed.  If 			 * this is the case, the config cache is out of sync and 			 * we should remove the pool from the namespace. 			 */
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* 			 * We can't open the pool, but we still have useful 			 * information: the state of each vdev after the 			 * attempted vdev_open().  Return this to the user. 			 */
if|if
condition|(
name|config
operator|!=
name|NULL
operator|&&
name|spa
operator|->
name|spa_config
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|config
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
name|spa
operator|->
name|spa_load_info
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_last_open_failed
operator|=
name|error
expr_stmt|;
if|if
condition|(
name|locked
condition|)
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|*
name|spapp
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|config
operator|!=
name|NULL
condition|)
operator|*
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * If we've recovered the pool, pass back any information we 	 * gathered while doing the load. 	 */
if|if
condition|(
name|state
operator|==
name|SPA_LOAD_RECOVER
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
name|spa
operator|->
name|spa_load_info
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|locked
condition|)
block|{
name|spa
operator|->
name|spa_last_open_failed
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_last_ubsync_txg
operator|=
literal|0
expr_stmt|;
name|spa
operator|->
name|spa_load_txg
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
operator|*
name|spapp
operator|=
name|spa
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_open_rewind
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spapp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|nvlist_t
modifier|*
name|policy
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|)
block|{
return|return
operator|(
name|spa_open_common
argument_list|(
name|name
argument_list|,
name|spapp
argument_list|,
name|tag
argument_list|,
name|policy
argument_list|,
name|config
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_open
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|spa_t
modifier|*
modifier|*
name|spapp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
return|return
operator|(
name|spa_open_common
argument_list|(
name|name
argument_list|,
name|spapp
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup the given spa_t, incrementing the inject count in the process,  * preventing it from being exported or destroyed.  */
end_comment

begin_function
name|spa_t
modifier|*
name|spa_inject_addref
parameter_list|(
name|char
modifier|*
name|name
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|spa
operator|->
name|spa_inject_ref
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_inject_delref
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_inject_ref
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add spares device information to the nvlist.  */
end_comment

begin_function
specifier|static
name|void
name|spa_add_spares
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nspares
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|uint64_t
name|pool
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
operator|==
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nspares
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Go through and find any spares which have since been 		 * repurposed as an active spare.  If this is the case, update 		 * their status appropriately. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nspares
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_spare_exists
argument_list|(
name|guid
argument_list|,
operator|&
name|pool
argument_list|,
name|NULL
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|spares
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vs
operator|->
name|vs_state
operator|=
name|VDEV_STATE_CANT_OPEN
expr_stmt|;
name|vs
operator|->
name|vs_aux
operator|=
name|VDEV_AUX_SPARED
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Add l2cache device information to the nvlist, including vdev stats.  */
end_comment

begin_function
specifier|static
name|void
name|spa_add_l2cache
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|j
decl_stmt|,
name|nl2cache
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|vdev_stat_t
modifier|*
name|vs
decl_stmt|;
name|uint_t
name|vsc
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
operator|==
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl2cache
operator|!=
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Update level 2 cache device stats. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nl2cache
condition|;
name|i
operator|++
control|)
block|{
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vd
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|guid
operator|==
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|j
index|]
operator|->
name|vdev_guid
condition|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|j
index|]
expr_stmt|;
break|break;
block|}
block|}
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64_array
argument_list|(
name|l2cache
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_VDEV_STATS
argument_list|,
operator|(
name|uint64_t
operator|*
operator|*
operator|)
operator|&
name|vs
argument_list|,
operator|&
name|vsc
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|vdev_get_stats
argument_list|(
name|vd
argument_list|,
name|vs
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spa_add_feature_stats
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|features
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|features
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_feat_for_read_obj
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_feat_for_read_obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT
argument_list|(
name|za
operator|.
name|za_integer_length
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|&&
name|za
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|nvlist_add_uint64
argument_list|(
name|features
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_feat_for_write_obj
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_feat_for_write_obj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|ASSERT
argument_list|(
name|za
operator|.
name|za_integer_length
operator|==
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|&&
name|za
operator|.
name|za_num_integers
operator|==
literal|1
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|nvlist_add_uint64
argument_list|(
name|features
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|za
operator|.
name|za_first_integer
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_FEATURE_STATS
argument_list|,
name|features
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|features
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|spa_get_stats
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|altroot
parameter_list|,
name|size_t
name|buflen
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
operator|*
name|config
operator|=
name|NULL
expr_stmt|;
name|error
operator|=
name|spa_open_common
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|FTAG
argument_list|,
name|NULL
argument_list|,
name|config
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * This still leaves a window of inconsistency where the spares 		 * or l2cache devices could change and the config would be 		 * self-inconsistent. 		 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|config
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|loadtimes
index|[
literal|2
index|]
decl_stmt|;
name|loadtimes
index|[
literal|0
index|]
operator|=
name|spa
operator|->
name|spa_loaded_ts
operator|.
name|tv_sec
expr_stmt|;
name|loadtimes
index|[
literal|1
index|]
operator|=
name|spa
operator|->
name|spa_loaded_ts
operator|.
name|tv_nsec
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64_array
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_LOADED_TIME
argument_list|,
name|loadtimes
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_ERRCOUNT
argument_list|,
name|spa_get_errlog_size
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
operator|*
name|config
argument_list|,
name|ZPOOL_CONFIG_SUSPENDED
argument_list|,
name|spa
operator|->
name|spa_failmode
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_add_spares
argument_list|(
name|spa
argument_list|,
operator|*
name|config
argument_list|)
expr_stmt|;
name|spa_add_l2cache
argument_list|(
name|spa
argument_list|,
operator|*
name|config
argument_list|)
expr_stmt|;
name|spa_add_feature_stats
argument_list|(
name|spa
argument_list|,
operator|*
name|config
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * We want to get the alternate root even for faulted pools, so we cheat 	 * and call spa_lookup() directly. 	 */
if|if
condition|(
name|altroot
condition|)
block|{
if|if
condition|(
name|spa
operator|==
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
condition|)
name|spa_altroot
argument_list|(
name|spa
argument_list|,
name|altroot
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
else|else
name|altroot
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|spa
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|spa_altroot
argument_list|(
name|spa
argument_list|,
name|altroot
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|spa
operator|!=
name|NULL
condition|)
block|{
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Validate that the auxiliary device array is well formed.  We must have an  * array of nvlists, each which describes a valid leaf vdev.  If this is an  * import (mode is VDEV_ALLOC_SPARE), then we allow corrupted spares to be  * specified, as long as they are well-formed.  */
end_comment

begin_function
specifier|static
name|int
name|spa_validate_aux_devs
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|int
name|mode
parameter_list|,
name|spa_aux_vdev_t
modifier|*
name|sav
parameter_list|,
specifier|const
name|char
modifier|*
name|config
parameter_list|,
name|uint64_t
name|version
parameter_list|,
name|vdev_labeltype_t
name|label
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|dev
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|ndev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
comment|/* 	 * It's acceptable to have no devs specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|config
argument_list|,
operator|&
name|dev
argument_list|,
operator|&
name|ndev
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|ndev
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* 	 * Make sure the pool is formatted with a version that supports this 	 * device type. 	 */
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|version
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 	 * Set the pending device list so we correctly handle device in-use 	 * checking. 	 */
name|sav
operator|->
name|sav_pending
operator|=
name|dev
expr_stmt|;
name|sav
operator|->
name|sav_npending
operator|=
name|ndev
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndev
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|dev
index|[
name|i
index|]
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|mode
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * The L2ARC currently only supports disk devices in 		 * kernel context.  For user-level testing, we allow it. 		 */
ifdef|#
directive|ifdef
name|_KERNEL
if|if
condition|(
operator|(
name|strcmp
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|)
operator|==
literal|0
operator|)
operator|&&
name|strcmp
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_type
argument_list|,
name|VDEV_TYPE_DISK
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTBLK
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
endif|#
directive|endif
name|vd
operator|->
name|vdev_top
operator|=
name|vd
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_open
argument_list|(
name|vd
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
name|crtxg
argument_list|,
name|label
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|dev
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|vd
operator|->
name|vdev_guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|&&
operator|(
name|mode
operator|!=
name|VDEV_ALLOC_SPARE
operator|&&
name|mode
operator|!=
name|VDEV_ALLOC_L2CACHE
operator|)
condition|)
goto|goto
name|out
goto|;
else|else
name|error
operator|=
literal|0
expr_stmt|;
block|}
name|out
label|:
name|sav
operator|->
name|sav_pending
operator|=
name|NULL
expr_stmt|;
name|sav
operator|->
name|sav_npending
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_validate_aux
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|uint64_t
name|crtxg
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_validate_aux_devs
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|crtxg
argument_list|,
name|mode
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|SPA_VERSION_SPARES
argument_list|,
name|VDEV_LABEL_SPARE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
name|error
operator|)
return|;
block|}
return|return
operator|(
name|spa_validate_aux_devs
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|crtxg
argument_list|,
name|mode
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|SPA_VERSION_L2CACHE
argument_list|,
name|VDEV_LABEL_L2CACHE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_set_aux_vdevs
parameter_list|(
name|spa_aux_vdev_t
modifier|*
name|sav
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|devs
parameter_list|,
name|int
name|ndevs
parameter_list|,
specifier|const
name|char
modifier|*
name|config
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_config
operator|!=
name|NULL
condition|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|olddevs
decl_stmt|;
name|uint_t
name|oldndevs
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|newdevs
decl_stmt|;
comment|/* 		 * Generate new dev list by concatentating with the 		 * current dev list. 		 */
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
operator|&
name|olddevs
argument_list|,
operator|&
name|oldndevs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|newdevs
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|*
operator|(
name|ndevs
operator|+
name|oldndevs
operator|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldndevs
condition|;
name|i
operator|++
control|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|olddevs
index|[
name|i
index|]
argument_list|,
operator|&
name|newdevs
index|[
name|i
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndevs
condition|;
name|i
operator|++
control|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|devs
index|[
name|i
index|]
argument_list|,
operator|&
name|newdevs
index|[
name|i
operator|+
name|oldndevs
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
name|newdevs
argument_list|,
name|ndevs
operator|+
name|oldndevs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oldndevs
operator|+
name|ndevs
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|newdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|newdevs
argument_list|,
operator|(
name|oldndevs
operator|+
name|ndevs
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Generate a new dev list. 		 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|sav
operator|->
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|sav
operator|->
name|sav_config
argument_list|,
name|config
argument_list|,
name|devs
argument_list|,
name|ndevs
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Stop and drop level 2 ARC devices  */
end_comment

begin_function
name|void
name|spa_l2cache_drop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|i
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_l2cache
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|pool
decl_stmt|;
name|vd
operator|=
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_l2cache_exists
argument_list|(
name|vd
operator|->
name|vdev_guid
argument_list|,
operator|&
name|pool
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
operator|&&
name|l2arc_vdev_present
argument_list|(
name|vd
argument_list|)
condition|)
name|l2arc_remove_vdev
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Pool Creation  */
end_comment

begin_function
name|int
name|spa_create
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|nvlist_t
modifier|*
name|zplprops
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|txg
init|=
name|TXG_INITIAL
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|uint64_t
name|version
decl_stmt|,
name|obj
decl_stmt|;
name|boolean_t
name|has_features
decl_stmt|;
comment|/* 	 * If this pool already exists, return failure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Allocate a new spa_t structure. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
operator|&
name|altroot
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|pool
argument_list|,
name|NULL
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|spa_mode_global
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|&&
operator|(
name|error
operator|=
name|spa_prop_validate
argument_list|(
name|spa
argument_list|,
name|props
argument_list|)
operator|)
condition|)
block|{
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|has_features
operator|=
name|B_FALSE
expr_stmt|;
for|for
control|(
name|nvpair_t
modifier|*
name|elem
init|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|NULL
argument_list|)
init|;
name|elem
operator|!=
name|NULL
condition|;
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|props
argument_list|,
name|elem
argument_list|)
control|)
block|{
if|if
condition|(
name|zpool_prop_feature
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
name|has_features
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|has_features
operator|||
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_VERSION
argument_list|)
argument_list|,
operator|&
name|version
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|version
operator|=
name|SPA_VERSION
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_first_txg
operator|=
name|txg
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_txg
operator|=
name|txg
operator|-
literal|1
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|version
expr_stmt|;
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|spa
operator|->
name|spa_load_state
operator|=
name|SPA_LOAD_CREATE
expr_stmt|;
comment|/* 	 * Create "The Godfather" zio to hold all async IOs 	 */
name|spa
operator|->
name|spa_async_zio_root
operator|=
name|kmem_alloc
argument_list|(
name|max_ncpus
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|max_ncpus
condition|;
name|i
operator|++
control|)
block|{
name|spa
operator|->
name|spa_async_zio_root
index|[
name|i
index|]
operator|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_CANFAIL
operator||
name|ZIO_FLAG_SPECULATIVE
operator||
name|ZIO_FLAG_GODFATHER
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Create the root vdev. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|rvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
operator|||
name|rvd
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|!=
literal|0
operator|||
name|spa
operator|->
name|spa_root_vdev
operator|==
name|rvd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|zfs_allocatable_devs
argument_list|(
name|nvroot
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|rvd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|txg
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_metaslab_set_size
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|vdev_expand
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Get the list of spares, if specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * Get the list of level 2 cache devices, if specified. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|spa
operator|->
name|spa_is_initializing
operator|=
name|B_TRUE
expr_stmt|;
name|spa
operator|->
name|spa_dsl_pool
operator|=
name|dp
operator|=
name|dsl_pool_create
argument_list|(
name|spa
argument_list|,
name|zplprops
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_meta_objset
operator|=
name|dp
operator|->
name|dp_meta_objset
expr_stmt|;
name|spa
operator|->
name|spa_is_initializing
operator|=
name|B_FALSE
expr_stmt|;
comment|/* 	 * Create DDTs (dedup tables). 	 */
name|ddt_create
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_update_dspace
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Create the pool config object. 	 */
name|spa
operator|->
name|spa_config_object
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_PACKED_NVLIST
argument_list|,
name|SPA_CONFIG_BLOCKSIZE
argument_list|,
name|DMU_OT_PACKED_NVLIST_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CONFIG
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_config_object
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add pool config"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_FEATURES
condition|)
name|spa_feature_create_zap_objects
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CREATION_VERSION
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|version
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add pool version"
argument_list|)
expr_stmt|;
block|}
comment|/* Newly created pools with the right version are always deflated. */
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_RAIDZ_DEFLATE
condition|)
block|{
name|spa
operator|->
name|spa_deflate
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add deflate"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Create the deferred-free bpobj.  Turn off compression 	 * because sync-to-convergence takes longer if the blocksize 	 * keeps changing. 	 */
name|obj
operator|=
name|bpobj_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_object_set_compress
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_SYNC_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|,
name|tx
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"failed to add bpobj"
argument_list|)
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_open
argument_list|(
operator|&
name|spa
operator|->
name|spa_deferred_bpobj
argument_list|,
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Create the pool's history object. 	 */
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_ZPOOL_HISTORY
condition|)
name|spa_history_create_obj
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Generate some random noise for salted checksums to operate on. 	 */
operator|(
name|void
operator|)
name|random_get_pseudo_bytes
argument_list|(
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|,
sizeof|sizeof
argument_list|(
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Set pool properties. 	 */
name|spa
operator|->
name|spa_bootfs
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_BOOTFS
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_delegation
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_DELEGATION
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_failmode
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_FAILUREMODE
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_autoexpand
operator|=
name|zpool_prop_default_numeric
argument_list|(
name|ZPOOL_PROP_AUTOEXPAND
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
block|{
name|spa_configfile_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_sync_props
argument_list|(
name|props
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_on
operator|=
name|B_TRUE
expr_stmt|;
name|txg_sync_start
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
expr_stmt|;
comment|/* 	 * We explicitly wait for the first transaction to complete so that our 	 * bean counters are appropriately updated. 	 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_POOL_CREATE
argument_list|)
expr_stmt|;
name|spa_history_log_version
argument_list|(
name|spa
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
comment|/* 	 * Don't count references from objsets that are already closed 	 * and are making their way through the eviction process. 	 */
name|spa_evicting_os_wait
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_minref
operator|=
name|refcount_count
argument_list|(
operator|&
name|spa
operator|->
name|spa_refcount
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_load_state
operator|=
name|SPA_LOAD_NONE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_comment
comment|/*  * Get the root pool information from the root disk, then import the root pool  * during the system boot up time.  */
end_comment

begin_function_decl
specifier|extern
name|int
name|vdev_disk_read_rootlabel
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|nvlist_t
modifier|*
name|spa_generate_rootconf
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|,
name|uint64_t
modifier|*
name|guid
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
name|nvlist_t
modifier|*
name|nvtop
decl_stmt|,
modifier|*
name|nvroot
decl_stmt|;
name|uint64_t
name|pgid
decl_stmt|;
if|if
condition|(
name|vdev_disk_read_rootlabel
argument_list|(
name|devpath
argument_list|,
name|devid
argument_list|,
operator|&
name|config
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Add this top-level vdev to the child array. 	 */
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvtop
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
operator|&
name|pgid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Put this pool's top-level vdevs into a root vdev. 	 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_TYPE
argument_list|,
name|VDEV_TYPE_ROOT
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_ID
argument_list|,
literal|0ULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
name|pgid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|nvtop
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Replace the existing vdev_tree with the new root vdev in 	 * this pool's configuration (remove the old, add the new). 	 */
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the vdev tree and see if we can find a device with "better"  * configuration. A configuration is "better" if the label on that  * device has a more recent txg.  */
end_comment

begin_function
specifier|static
name|void
name|spa_alt_rootvdev
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|vdev_t
modifier|*
modifier|*
name|avd
parameter_list|,
name|uint64_t
modifier|*
name|txg
parameter_list|)
block|{
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|spa_alt_rootvdev
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|avd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
block|{
name|nvlist_t
modifier|*
name|label
decl_stmt|;
name|uint64_t
name|label_txg
decl_stmt|;
if|if
condition|(
name|vdev_disk_read_rootlabel
argument_list|(
name|vd
operator|->
name|vdev_physpath
argument_list|,
name|vd
operator|->
name|vdev_devid
argument_list|,
operator|&
name|label
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|label
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|label_txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Do we have a better boot device? 		 */
if|if
condition|(
name|label_txg
operator|>
operator|*
name|txg
condition|)
block|{
operator|*
name|txg
operator|=
name|label_txg
expr_stmt|;
operator|*
name|avd
operator|=
name|vd
expr_stmt|;
block|}
name|nvlist_free
argument_list|(
name|label
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Import a root pool.  *  * For x86. devpath_list will consist of devid and/or physpath name of  * the vdev (e.g. "id1,sd@SSEAGATE..." or "/pci@1f,0/ide@d/disk@0,0:a").  * The GRUB "findroot" command will return the vdev we should boot.  *  * For Sparc, devpath_list consists the physpath name of the booting device  * no matter the rootpool is a single device pool or a mirrored pool.  * e.g.  *	"/pci@1f,0/ide@d/disk@0,0:a"  */
end_comment

begin_function
name|int
name|spa_import_rootpool
parameter_list|(
name|char
modifier|*
name|devpath
parameter_list|,
name|char
modifier|*
name|devid
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|,
modifier|*
name|bvd
decl_stmt|,
modifier|*
name|avd
init|=
name|NULL
decl_stmt|;
name|nvlist_t
modifier|*
name|config
decl_stmt|,
modifier|*
name|nvtop
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|txg
decl_stmt|;
name|char
modifier|*
name|pname
decl_stmt|;
name|int
name|error
decl_stmt|;
comment|/* 	 * Read the label from the boot device and generate a configuration. 	 */
name|config
operator|=
name|spa_generate_rootconf
argument_list|(
name|devpath
argument_list|,
name|devid
argument_list|,
operator|&
name|guid
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|_OBP
argument_list|)
operator|&&
name|defined
argument_list|(
name|_KERNEL
argument_list|)
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strstr
argument_list|(
name|devpath
argument_list|,
literal|"/iscsi/ssd"
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* iscsi boot */
name|get_iscsi_bootpath_phy
argument_list|(
name|devpath
argument_list|)
expr_stmt|;
name|config
operator|=
name|spa_generate_rootconf
argument_list|(
name|devpath
argument_list|,
name|devid
argument_list|,
operator|&
name|guid
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|config
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"Cannot read the pool label from '%s'"
argument_list|,
name|devpath
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
block|}
name|VERIFY
argument_list|(
name|nvlist_lookup_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|pname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
operator|&
name|txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pname
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Remove the existing root pool from the namespace so that we 		 * can replace it with the correct config we just read in. 		 */
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|spa
operator|=
name|spa_add
argument_list|(
name|pname
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_is_root
operator|=
name|B_TRUE
expr_stmt|;
name|spa
operator|->
name|spa_import_flags
operator|=
name|ZFS_IMPORT_VERBATIM
expr_stmt|;
comment|/* 	 * Build up a vdev tree based on the boot device's label config. 	 */
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvtop
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|rvd
argument_list|,
name|nvtop
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ROOTPOOL
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"Can not parse the config for pool '%s'"
argument_list|,
name|pname
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Get the boot vdev. 	 */
if|if
condition|(
operator|(
name|bvd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|rvd
argument_list|,
name|guid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"Can not find the boot vdev for guid %llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|guid
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Determine if there is a better boot device. 	 */
name|avd
operator|=
name|bvd
expr_stmt|;
name|spa_alt_rootvdev
argument_list|(
name|rvd
argument_list|,
operator|&
name|avd
argument_list|,
operator|&
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|avd
operator|!=
name|bvd
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"The boot device is 'degraded'. Please "
literal|"try booting from '%s'"
argument_list|,
name|avd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * If the boot device is part of a spare vdev then ensure that 	 * we're booting off the active spare. 	 */
if|if
condition|(
name|bvd
operator|->
name|vdev_parent
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
operator|!
name|bvd
operator|->
name|vdev_isspare
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"The boot device is currently spared. Please "
literal|"try booting from '%s'"
argument_list|,
name|bvd
operator|->
name|vdev_parent
operator|->
name|vdev_child
index|[
name|bvd
operator|->
name|vdev_parent
operator|->
name|vdev_children
operator|-
literal|1
index|]
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|error
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|config
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Import a non-root pool into the system.  */
end_comment

begin_function
name|int
name|spa_import
parameter_list|(
specifier|const
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|uint64_t
name|flags
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|spa_load_state_t
name|state
init|=
name|SPA_LOAD_IMPORT
decl_stmt|;
name|zpool_rewind_policy_t
name|policy
decl_stmt|;
name|uint64_t
name|mode
init|=
name|spa_mode_global
decl_stmt|;
name|uint64_t
name|readonly
init|=
name|B_FALSE
decl_stmt|;
name|int
name|error
decl_stmt|;
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
comment|/* 	 * If a pool with this name exists, return failure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Create and initialize the spa structure. 	 */
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
operator|&
name|altroot
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_READONLY
argument_list|)
argument_list|,
operator|&
name|readonly
argument_list|)
expr_stmt|;
if|if
condition|(
name|readonly
condition|)
name|mode
operator|=
name|FREAD
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|pool
argument_list|,
name|config
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_import_flags
operator|=
name|flags
expr_stmt|;
comment|/* 	 * Verbatim import - Take a pool and insert it into the namespace 	 * as if it had been loaded at boot. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_import_flags
operator|&
name|ZFS_IMPORT_VERBATIM
condition|)
block|{
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|spa_configfile_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_POOL_IMPORT
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|mode
argument_list|)
expr_stmt|;
comment|/* 	 * Don't start async tasks until we know everything is healthy. 	 */
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|zpool_get_rewind_policy
argument_list|(
name|config
argument_list|,
operator|&
name|policy
argument_list|)
expr_stmt|;
if|if
condition|(
name|policy
operator|.
name|zrp_request
operator|&
name|ZPOOL_DO_REWIND
condition|)
name|state
operator|=
name|SPA_LOAD_RECOVER
expr_stmt|;
comment|/* 	 * Pass off the heavy lifting to spa_load().  Pass TRUE for mosconfig 	 * because the user-supplied config is actually the one to trust when 	 * doing an import. 	 */
if|if
condition|(
name|state
operator|!=
name|SPA_LOAD_RECOVER
condition|)
name|spa
operator|->
name|spa_last_ubsync_txg
operator|=
name|spa
operator|->
name|spa_load_txg
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|spa_load_best
argument_list|(
name|spa
argument_list|,
name|state
argument_list|,
name|B_TRUE
argument_list|,
name|policy
operator|.
name|zrp_txg
argument_list|,
name|policy
operator|.
name|zrp_request
argument_list|)
expr_stmt|;
comment|/* 	 * Propagate anything learned while loading the pool and pass it 	 * back to caller (i.e. rewind info, missing devices, etc). 	 */
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
name|spa
operator|->
name|spa_load_info
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * Toss any existing sparelist, as it doesn't have any validity 	 * anymore, and conflicts with spa_has_spare(). 	 */
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
condition|)
block|{
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
operator|=
name|NULL
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvroot
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|VDEV_ALLOC_SPARE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|VDEV_ALLOC_L2CACHE
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
name|spa_configfile_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
operator|(
name|props
operator|&&
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|&&
operator|(
name|error
operator|=
name|spa_prop_set
argument_list|(
name|spa
argument_list|,
name|props
argument_list|)
operator|)
operator|)
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|spa_async_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Override any spares and level 2 cache devices as specified by 	 * the user, as these may have correct device names/devids, etc. 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
condition|)
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
condition|)
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
else|else
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * Check for any removed devices. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_autoreplace
condition|)
block|{
name|spa_aux_check_removed
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
argument_list|)
expr_stmt|;
name|spa_aux_check_removed
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
condition|)
block|{
comment|/* 		 * Update the config cache to include the newly-imported pool. 		 */
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * It's possible that the pool was expanded while it was exported. 	 * We kick off an async task to handle this for us. 	 */
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_AUTOEXPAND
argument_list|)
expr_stmt|;
name|spa_history_log_version
argument_list|(
name|spa
argument_list|,
literal|"import"
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_POOL_IMPORT
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|nvlist_t
modifier|*
name|spa_tryimport
parameter_list|(
name|nvlist_t
modifier|*
name|tryconfig
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|poolname
decl_stmt|;
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|uint64_t
name|state
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|tryconfig
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
operator|&
name|poolname
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|tryconfig
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
operator|&
name|state
argument_list|)
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Create and initialize the spa structure. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa
operator|=
name|spa_add
argument_list|(
name|TRYIMPORT_NAME
argument_list|,
name|tryconfig
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|spa
argument_list|,
name|FREAD
argument_list|)
expr_stmt|;
comment|/* 	 * Pass off the heavy lifting to spa_load(). 	 * Pass TRUE for mosconfig because the user-supplied config 	 * is actually the one to trust when doing an import. 	 */
name|error
operator|=
name|spa_load
argument_list|(
name|spa
argument_list|,
name|SPA_LOAD_TRYIMPORT
argument_list|,
name|SPA_IMPORT_EXISTING
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
comment|/* 	 * If 'tryconfig' was at least parsable, return the current config. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
block|{
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|poolname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|state
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_TIMESTAMP
argument_list|,
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_timestamp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_LOAD_INFO
argument_list|,
name|spa
operator|->
name|spa_load_info
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * If the bootfs property exists on this pool then we 		 * copy it out so that external consumers can tell which 		 * pools are bootable. 		 */
if|if
condition|(
operator|(
operator|!
name|error
operator|||
name|error
operator|==
name|EEXIST
operator|)
operator|&&
name|spa
operator|->
name|spa_bootfs
condition|)
block|{
name|char
modifier|*
name|tmpname
init|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
comment|/* 			 * We have to play games with the name since the 			 * pool was opened as TRYIMPORT_NAME. 			 */
if|if
condition|(
name|dsl_dsobj_to_dsname
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|spa
operator|->
name|spa_bootfs
argument_list|,
name|tmpname
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|dsname
init|=
name|kmem_alloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|cp
operator|=
name|strchr
argument_list|(
name|tmpname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|dsname
argument_list|,
name|tmpname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|dsname
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s/%s"
argument_list|,
name|poolname
argument_list|,
operator|++
name|cp
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_BOOTFS
argument_list|,
name|dsname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dsname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|tmpname
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Add the list of hot spares and level 2 cache devices. 		 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|spa_add_spares
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|spa_add_l2cache
argument_list|(
name|spa
argument_list|,
name|config
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|config
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Pool export/destroy  *  * The act of destroying or exporting a pool is very simple.  We make sure there  * is no more pending I/O and any references to the pool are gone.  Then, we  * update the pool state and sync all the labels to disk, removing the  * configuration from the cache afterwards. If the 'hardforce' flag is set, then  * we don't sync the labels or remove the configuration cache.  */
end_comment

begin_function
specifier|static
name|int
name|spa_export_common
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|int
name|new_state
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
if|if
condition|(
name|oldconfig
condition|)
operator|*
name|oldconfig
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|spa_mode_global
operator|&
name|FWRITE
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|spa
operator|=
name|spa_lookup
argument_list|(
name|pool
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
comment|/* 	 * Put a hold on the pool, drop the namespace lock, stop async tasks, 	 * reacquire the namespace lock, and see if we can export. 	 */
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 	 * The pool will be in core if it's openable, 	 * in which case we can modify its state. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|&&
name|spa
operator|->
name|spa_sync_on
condition|)
block|{
comment|/* 		 * Objsets may be open only because they're dirty, so we 		 * have to force it to sync before checking spa_refcnt. 		 */
name|txg_wait_synced
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa_evicting_os_wait
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 		 * A pool cannot be exported or destroyed if there are active 		 * references.  If we are resetting a pool, allow references by 		 * fault injection handlers. 		 */
if|if
condition|(
operator|!
name|spa_refcount_zero
argument_list|(
name|spa
argument_list|)
operator|||
operator|(
name|spa
operator|->
name|spa_inject_ref
operator|!=
literal|0
operator|&&
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|)
condition|)
block|{
name|spa_async_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * A pool cannot be exported if it has an active shared spare. 		 * This is to prevent other pools stealing the active spare 		 * from an exported pool. At user's own will, such pool can 		 * be forcedly exported. 		 */
if|if
condition|(
operator|!
name|force
operator|&&
name|new_state
operator|==
name|POOL_STATE_EXPORTED
operator|&&
name|spa_has_active_shared_spare
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|spa_async_resume
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EXDEV
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * We want this to be reflected on every label, 		 * so mark them all dirty.  spa_unload() will do the 		 * final sync that pushes these changes out. 		 */
if|if
condition|(
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
operator|&&
operator|!
name|hardforce
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_state
operator|=
name|new_state
expr_stmt|;
name|spa
operator|->
name|spa_final_txg
operator|=
name|spa_last_synced_txg
argument_list|(
name|spa
argument_list|)
operator|+
name|TXG_DEFER_SIZE
operator|+
literal|1
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
block|}
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_POOL_DESTROY
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|oldconfig
operator|&&
name|spa
operator|->
name|spa_config
condition|)
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|oldconfig
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
if|if
condition|(
operator|!
name|hardforce
condition|)
name|spa_config_sync
argument_list|(
name|spa
argument_list|,
name|B_TRUE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a storage pool.  */
end_comment

begin_function
name|int
name|spa_destroy
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_DESTROYED
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Export a storage pool.  */
end_comment

begin_function
name|int
name|spa_export
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|oldconfig
parameter_list|,
name|boolean_t
name|force
parameter_list|,
name|boolean_t
name|hardforce
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_EXPORTED
argument_list|,
name|oldconfig
argument_list|,
name|force
argument_list|,
name|hardforce
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Similar to spa_export(), this unloads the spa_t without actually removing it  * from the namespace in any way.  */
end_comment

begin_function
name|int
name|spa_reset
parameter_list|(
name|char
modifier|*
name|pool
parameter_list|)
block|{
return|return
operator|(
name|spa_export_common
argument_list|(
name|pool
argument_list|,
name|POOL_STATE_UNINITIALIZED
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Device manipulation  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Add a device to a storage pool.  */
end_comment

begin_function
name|int
name|spa_vdev_add
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|,
name|id
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|vd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
name|spa
operator|->
name|spa_pending_vdev
operator|=
name|vd
expr_stmt|;
comment|/* spa_vdev_exit() will clear this */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|!=
literal|0
condition|)
name|nspares
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|!=
literal|0
condition|)
name|nl2cache
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|==
literal|0
operator|&&
name|nspares
operator|==
literal|0
operator|&&
name|nl2cache
operator|==
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|!=
literal|0
operator|&&
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|,
name|B_FALSE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
comment|/* 	 * We must validate the spares and l2cache devices after checking the 	 * children.  Otherwise, vdev_inuse() will blindly overwrite the spare. 	 */
if|if
condition|(
operator|(
name|error
operator|=
name|spa_validate_aux
argument_list|(
name|spa
argument_list|,
name|nvroot
argument_list|,
name|txg
argument_list|,
name|VDEV_ALLOC_ADD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
comment|/* 	 * Transfer each new top-level vdev from vd to rvd. 	 */
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
comment|/* 		 * Set the vdev id to the first hole, if one exists. 		 */
for|for
control|(
name|id
operator|=
literal|0
init|;
name|id
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|id
operator|++
control|)
block|{
if|if
condition|(
name|rvd
operator|->
name|vdev_child
index|[
name|id
index|]
operator|->
name|vdev_ishole
condition|)
block|{
name|vdev_free
argument_list|(
name|rvd
operator|->
name|vdev_child
index|[
name|id
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|tvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
name|vdev_remove_child
argument_list|(
name|vd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|tvd
operator|->
name|vdev_id
operator|=
name|id
expr_stmt|;
name|vdev_add_child
argument_list|(
name|rvd
argument_list|,
name|tvd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nspares
operator|!=
literal|0
condition|)
block|{
name|spa_set_aux_vdevs
argument_list|(
operator|&
name|spa
operator|->
name|spa_spares
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
if|if
condition|(
name|nl2cache
operator|!=
literal|0
condition|)
block|{
name|spa_set_aux_vdevs
argument_list|(
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * We have to be careful when adding new vdevs to an existing pool. 	 * If other threads start allocating from these vdevs before we 	 * sync the config cache, and we lose power, then upon reboot we may 	 * fail to open the pool because there are DVAs that the config cache 	 * can't translate.  Therefore, we first add the vdevs without 	 * initializing metaslabs; sync the config cache (via spa_vdev_exit()); 	 * and then let spa_config_update() initialize the new metaslabs. 	 * 	 * spa_load() checks for added-but-not-initialized vdevs, so that 	 * if we lose power at any point in this sequence, the remaining 	 * steps will be completed the next time we load the pool. 	 */
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ESC_ZFS_VDEV_ADD
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Attach a device to a mirror.  The arguments are the path to any device  * in the mirror, and the nvroot for the new device.  If the path specifies  * a device that is not mirrored, we automatically insert the mirror vdev.  *  * If 'replacing' is specified, the new device is intended to replace the  * existing device; in this case the two devices are made into their own  * mirror using the 'replacing' vdev, which is functionally identical to  * the mirror vdev (it actually reuses all the same ops) but has a few  * extra rules: you can't attach to it after it's been created, and upon  * completion of resilvering, the first disk (the one being replaced)  * is automatically detached.  */
end_comment

begin_function
name|int
name|spa_vdev_attach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|nvlist_t
modifier|*
name|nvroot
parameter_list|,
name|int
name|replacing
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|,
name|dtl_max_txg
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|oldvd
decl_stmt|,
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|newrootvd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|vdev_ops_t
modifier|*
name|pvops
decl_stmt|;
name|char
modifier|*
name|oldvdpath
decl_stmt|,
modifier|*
name|newvdpath
decl_stmt|;
name|int
name|newvd_isspare
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|oldvd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|oldvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvd
operator|=
name|oldvd
operator|->
name|vdev_parent
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|spa_config_parse
argument_list|(
name|spa
argument_list|,
operator|&
name|newrootvd
argument_list|,
name|nvroot
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|VDEV_ALLOC_ATTACH
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|newrootvd
operator|->
name|vdev_children
operator|!=
literal|1
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|newvd
operator|=
name|newrootvd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|newvd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|vdev_create
argument_list|(
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|replacing
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
comment|/* 	 * Spares can't replace logs 	 */
if|if
condition|(
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_islog
operator|&&
name|newvd
operator|->
name|vdev_isspare
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|replacing
condition|)
block|{
comment|/* 		 * For attach, the only allowable parent is a mirror or the root 		 * vdev. 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_root_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvops
operator|=
operator|&
name|vdev_mirror_ops
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Active hot spares can only be replaced by inactive hot 		 * spares. 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|oldvd
operator|->
name|vdev_isspare
operator|&&
operator|!
name|spa_has_spare
argument_list|(
name|spa
argument_list|,
name|newvd
operator|->
name|vdev_guid
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 		 * If the source is a hot spare, and the parent isn't already a 		 * spare, then we want to create a new hot spare.  Otherwise, we 		 * want to create a replacing vdev.  The user is not allowed to 		 * attach to a spared vdev child unless the 'isspare' state is 		 * the same (spare replaces spare, non-spare replaces 		 * non-spare). 		 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|&&
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|<
name|SPA_VERSION_MULTI_REPLACE
condition|)
block|{
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|newvd
operator|->
name|vdev_isspare
operator|!=
name|oldvd
operator|->
name|vdev_isspare
condition|)
block|{
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|newvd
operator|->
name|vdev_isspare
condition|)
name|pvops
operator|=
operator|&
name|vdev_spare_ops
expr_stmt|;
else|else
name|pvops
operator|=
operator|&
name|vdev_replacing_ops
expr_stmt|;
block|}
comment|/* 	 * Make sure the new device is big enough. 	 */
if|if
condition|(
name|newvd
operator|->
name|vdev_asize
operator|<
name|vdev_get_min_asize
argument_list|(
name|oldvd
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EOVERFLOW
argument_list|)
operator|)
return|;
comment|/* 	 * The new device cannot have a higher alignment requirement 	 * than the top-level vdev. 	 */
if|if
condition|(
name|newvd
operator|->
name|vdev_ashift
operator|>
name|oldvd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|txg
argument_list|,
name|EDOM
argument_list|)
operator|)
return|;
comment|/* 	 * If this is an in-place replacement, update oldvd's path and devid 	 * to make it distinguishable from newvd, and unopenable from now on. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|oldvd
operator|->
name|vdev_path
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|newvd
operator|->
name|vdev_path
argument_list|)
operator|+
literal|5
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|,
literal|"%s/%s"
argument_list|,
name|newvd
operator|->
name|vdev_path
argument_list|,
literal|"old"
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|->
name|vdev_devid
operator|!=
name|NULL
condition|)
block|{
name|spa_strfree
argument_list|(
name|oldvd
operator|->
name|vdev_devid
argument_list|)
expr_stmt|;
name|oldvd
operator|->
name|vdev_devid
operator|=
name|NULL
expr_stmt|;
block|}
block|}
comment|/* mark the device being resilvered */
name|newvd
operator|->
name|vdev_resilver_txg
operator|=
name|txg
expr_stmt|;
comment|/* 	 * If the parent is not a mirror, or if we're replacing, insert the new 	 * mirror/replacing/spare vdev above oldvd. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
name|pvops
condition|)
name|pvd
operator|=
name|vdev_add_parent
argument_list|(
name|oldvd
argument_list|,
name|pvops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_top
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|==
name|pvops
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|oldvd
operator|->
name|vdev_parent
operator|==
name|pvd
argument_list|)
expr_stmt|;
comment|/* 	 * Extract the new device from its root and add it to pvd. 	 */
name|vdev_remove_child
argument_list|(
name|newrootvd
argument_list|,
name|newvd
argument_list|)
expr_stmt|;
name|newvd
operator|->
name|vdev_id
operator|=
name|pvd
operator|->
name|vdev_children
expr_stmt|;
name|newvd
operator|->
name|vdev_crtxg
operator|=
name|oldvd
operator|->
name|vdev_crtxg
expr_stmt|;
name|vdev_add_child
argument_list|(
name|pvd
argument_list|,
name|newvd
argument_list|)
expr_stmt|;
name|tvd
operator|=
name|newvd
operator|->
name|vdev_top
expr_stmt|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_top
operator|==
name|tvd
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 	 * Set newvd's DTL to [TXG_INITIAL, dtl_max_txg) so that we account 	 * for any dmu_sync-ed blocks.  It will propagate upward when 	 * spa_vdev_exit() calls vdev_dtl_reassess(). 	 */
name|dtl_max_txg
operator|=
name|txg
operator|+
name|TXG_CONCURRENT_STATES
expr_stmt|;
name|vdev_dtl_dirty
argument_list|(
name|newvd
argument_list|,
name|DTL_MISSING
argument_list|,
name|TXG_INITIAL
argument_list|,
name|dtl_max_txg
operator|-
name|TXG_INITIAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvd
operator|->
name|vdev_isspare
condition|)
block|{
name|spa_spare_activate
argument_list|(
name|newvd
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|newvd
argument_list|,
name|ESC_ZFS_VDEV_SPARE
argument_list|)
expr_stmt|;
block|}
name|oldvdpath
operator|=
name|spa_strdup
argument_list|(
name|oldvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|newvdpath
operator|=
name|spa_strdup
argument_list|(
name|newvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|newvd_isspare
operator|=
name|newvd
operator|->
name|vdev_isspare
expr_stmt|;
comment|/* 	 * Mark newvd's DTL dirty in this txg. 	 */
name|vdev_dirty
argument_list|(
name|tvd
argument_list|,
name|VDD_DTL
argument_list|,
name|newvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Schedule the resilver to restart in the future. We do this to 	 * ensure that dmu_sync-ed blocks have been stitched into the 	 * respective datasets. 	 */
name|dsl_resilver_restart
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|dtl_max_txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_bootfs
condition|)
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|newvd
argument_list|,
name|ESC_ZFS_BOOTFS_VDEV_ATTACH
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|newvd
argument_list|,
name|ESC_ZFS_VDEV_ATTACH
argument_list|)
expr_stmt|;
comment|/* 	 * Commit the config 	 */
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|newrootvd
argument_list|,
name|dtl_max_txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"vdev attach"
argument_list|,
name|NULL
argument_list|,
literal|"%s vdev=%s %s vdev=%s"
argument_list|,
name|replacing
operator|&&
name|newvd_isspare
condition|?
literal|"spare in"
else|:
name|replacing
condition|?
literal|"replace"
else|:
literal|"attach"
argument_list|,
name|newvdpath
argument_list|,
name|replacing
condition|?
literal|"for"
else|:
literal|"to"
argument_list|,
name|oldvdpath
argument_list|)
expr_stmt|;
name|spa_strfree
argument_list|(
name|oldvdpath
argument_list|)
expr_stmt|;
name|spa_strfree
argument_list|(
name|newvdpath
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Detach a device from a mirror or replacing vdev.  *  * If 'replace_done' is specified, only detach if the parent  * is a replacing vdev.  */
end_comment

begin_function
name|int
name|spa_vdev_detach
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|uint64_t
name|pguid
parameter_list|,
name|int
name|replace_done
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|int
name|error
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|cvd
decl_stmt|,
modifier|*
name|tvd
decl_stmt|;
name|boolean_t
name|unspare
init|=
name|B_FALSE
decl_stmt|;
name|uint64_t
name|unspare_guid
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|vdpath
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENODEV
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|pvd
operator|=
name|vd
operator|->
name|vdev_parent
expr_stmt|;
comment|/* 	 * If the parent/child relationship is not as expected, don't do it. 	 * Consider M(A,R(B,C)) -- that is, a mirror of A with a replacing 	 * vdev that's replacing B with C.  The user's intent in replacing 	 * is to go from M(A,B) to M(A,C).  If the user decides to cancel 	 * the replace by detaching C, the expected behavior is to end up 	 * M(A,B).  But suppose that right after deciding to detach C, 	 * the replacement of B completes.  We would have M(A,C), and then 	 * ask to detach C, which would leave us with just A -- not what 	 * the user wanted.  To prevent this, we make sure that the 	 * parent/child relationship hasn't changed -- in this example, 	 * that C's parent is still the replacing vdev R. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_guid
operator|!=
name|pguid
operator|&&
name|pguid
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
comment|/* 	 * Only 'replacing' or 'spare' vdevs can be replaced. 	 */
if|if
condition|(
name|replace_done
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_replacing_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
operator|||
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_SPARES
argument_list|)
expr_stmt|;
comment|/* 	 * Only mirror, replacing, and spare vdevs support detach. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_replacing_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|&&
name|pvd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_spare_ops
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 	 * If this device has the only valid copy of some data, 	 * we cannot safely detach it. 	 */
if|if
condition|(
name|vdev_dtl_required
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EBUSY
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_children
operator|>=
literal|2
argument_list|)
expr_stmt|;
comment|/* 	 * If we are detaching the second disk from a replacing vdev, then 	 * check to see if we changed the original vdev's path to have "/old" 	 * at the end in spa_vdev_attach().  If so, undo that change now. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|&&
name|vd
operator|->
name|vdev_id
operator|>
literal|0
operator|&&
name|vd
operator|->
name|vdev_path
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|pvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|cvd
operator|==
name|vd
operator|||
name|cvd
operator|->
name|vdev_path
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|cvd
operator|->
name|vdev_path
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|,
name|len
argument_list|)
operator|==
literal|0
operator|&&
name|strcmp
argument_list|(
name|cvd
operator|->
name|vdev_path
operator|+
name|len
argument_list|,
literal|"/old"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|cvd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_path
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* 	 * If we are detaching the original disk from a spare, then it implies 	 * that the spare should become a real disk, and be removed from the 	 * active spare list for the pool. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|vd
operator|->
name|vdev_id
operator|==
literal|0
operator|&&
name|pvd
operator|->
name|vdev_child
index|[
name|pvd
operator|->
name|vdev_children
operator|-
literal|1
index|]
operator|->
name|vdev_isspare
condition|)
name|unspare
operator|=
name|B_TRUE
expr_stmt|;
comment|/* 	 * Erase the disk labels so the disk can be used for other things. 	 * This must be done after all other error cases are handled, 	 * but before we disembowel vd (so we can still do I/O to it). 	 * But if we can't do it, don't treat the error as fatal -- 	 * it may be that the unwritability of the disk is the reason 	 * it's being detached! 	 */
name|error
operator|=
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|VDEV_LABEL_REMOVE
argument_list|)
expr_stmt|;
comment|/* 	 * Remove vd from its parent and compact the parent's children. 	 */
name|vdev_remove_child
argument_list|(
name|pvd
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|vdev_compact_children
argument_list|(
name|pvd
argument_list|)
expr_stmt|;
comment|/* 	 * Remember one of the remaining children so we can get tvd below. 	 */
name|cvd
operator|=
name|pvd
operator|->
name|vdev_child
index|[
name|pvd
operator|->
name|vdev_children
operator|-
literal|1
index|]
expr_stmt|;
comment|/* 	 * If we need to remove the remaining child from the list of hot spares, 	 * do it now, marking the vdev as no longer a spare in the process. 	 * We must do this before vdev_remove_parent(), because that can 	 * change the GUID if it creates a new toplevel GUID.  For a similar 	 * reason, we must remove the spare now, in the same txg as the detach; 	 * otherwise someone could attach a new sibling, change the GUID, and 	 * the subsequent attempt to spa_vdev_remove(unspare_guid) would fail. 	 */
if|if
condition|(
name|unspare
condition|)
block|{
name|ASSERT
argument_list|(
name|cvd
operator|->
name|vdev_isspare
argument_list|)
expr_stmt|;
name|spa_spare_remove
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
name|unspare_guid
operator|=
name|cvd
operator|->
name|vdev_guid
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_remove
argument_list|(
name|spa
argument_list|,
name|unspare_guid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|cvd
operator|->
name|vdev_unspare
operator|=
name|B_TRUE
expr_stmt|;
block|}
comment|/* 	 * If the parent mirror/replacing vdev only has one child, 	 * the parent is no longer needed.  Remove it from the tree. 	 */
if|if
condition|(
name|pvd
operator|->
name|vdev_children
operator|==
literal|1
condition|)
block|{
if|if
condition|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
condition|)
name|cvd
operator|->
name|vdev_unspare
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_remove_parent
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * We don't set tvd until now because the parent we just removed 	 * may have been the previous top-level vdev. 	 */
name|tvd
operator|=
name|cvd
operator|->
name|vdev_top
expr_stmt|;
name|ASSERT
argument_list|(
name|tvd
operator|->
name|vdev_parent
operator|==
name|rvd
argument_list|)
expr_stmt|;
comment|/* 	 * Reevaluate the parent vdev state. 	 */
name|vdev_propagate_state
argument_list|(
name|cvd
argument_list|)
expr_stmt|;
comment|/* 	 * If the 'autoexpand' property is set on the pool then automatically 	 * try to expand the size of the pool. For example if the device we 	 * just detached was smaller than the others, it may be possible to 	 * add metaslabs (i.e. grow the pool). We need to reopen the vdev 	 * first so that we can obtain the updated sizes of the leaf vdevs. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_autoexpand
condition|)
block|{
name|vdev_reopen
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
name|vdev_expand
argument_list|(
name|tvd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
name|vdev_config_dirty
argument_list|(
name|tvd
argument_list|)
expr_stmt|;
comment|/* 	 * Mark vd's DTL as dirty in this txg.  vdev_dtl_sync() will see that 	 * vd->vdev_detached is set and free vd's DTL object in syncing context. 	 * But first make sure we're not on any *other* txg's DTL list, to 	 * prevent vd from being accessed after it's freed. 	 */
name|vdpath
operator|=
name|spa_strdup
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
operator|(
name|void
operator|)
name|txg_list_remove_this
argument_list|(
operator|&
name|tvd
operator|->
name|vdev_dtl_list
argument_list|,
name|vd
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_detached
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_dirty
argument_list|(
name|tvd
argument_list|,
name|VDD_DTL
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa_event_notify
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_REMOVE
argument_list|)
expr_stmt|;
comment|/* hang on to the spa before we release the lock */
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"detach"
argument_list|,
name|NULL
argument_list|,
literal|"vdev=%s"
argument_list|,
name|vdpath
argument_list|)
expr_stmt|;
name|spa_strfree
argument_list|(
name|vdpath
argument_list|)
expr_stmt|;
comment|/* 	 * If this was the removal of the original device in a hot spare vdev, 	 * then we want to go through and remove the device from the hot spare 	 * list of every other pool. 	 */
if|if
condition|(
name|unspare
condition|)
block|{
name|spa_t
modifier|*
name|altspa
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|altspa
operator|=
name|spa_next
argument_list|(
name|altspa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|altspa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_ACTIVE
operator|||
name|altspa
operator|==
name|spa
condition|)
continue|continue;
name|spa_open_ref
argument_list|(
name|altspa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_remove
argument_list|(
name|altspa
argument_list|,
name|unspare_guid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|altspa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
comment|/* search the rest of the vdevs for spares to remove */
name|spa_vdev_resilver_done
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
comment|/* all done with the spa; OK to release */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Split a set of devices from their mirrors, and create a new pool from them.  */
end_comment

begin_function
name|int
name|spa_vdev_split_mirror
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|char
modifier|*
name|newname
parameter_list|,
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|nvlist_t
modifier|*
name|props
parameter_list|,
name|boolean_t
name|exp
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|txg
decl_stmt|,
modifier|*
name|glist
decl_stmt|;
name|spa_t
modifier|*
name|newspa
decl_stmt|;
name|uint_t
name|c
decl_stmt|,
name|children
decl_stmt|,
name|lastlog
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|child
decl_stmt|,
modifier|*
name|nvl
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|char
modifier|*
name|altroot
init|=
name|NULL
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
decl_stmt|,
modifier|*
modifier|*
name|vml
init|=
name|NULL
decl_stmt|;
comment|/* vdev modify list */
name|boolean_t
name|activate_slog
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* clear the log and flush everything up to now */
name|activate_slog
operator|=
name|spa_passivate_log
argument_list|(
name|spa
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_config_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_offline_log
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_config_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|activate_slog
condition|)
name|spa_activate_log
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
comment|/* check new spa name before going any further */
if|if
condition|(
name|spa_lookup
argument_list|(
name|newname
argument_list|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EEXIST
argument_list|)
operator|)
return|;
comment|/* 	 * scan through all the children to ensure they're all mirrors 	 */
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VDEV_TREE
argument_list|,
operator|&
name|nvl
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_lookup_nvlist_array
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_CHILDREN
argument_list|,
operator|&
name|child
argument_list|,
operator|&
name|children
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* first, check to ensure we've got the right child count */
name|rvd
operator|=
name|spa
operator|->
name|spa_root_vdev
expr_stmt|;
name|lastlog
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
comment|/* don't count the holes& logs as children */
if|if
condition|(
name|vd
operator|->
name|vdev_islog
operator|||
name|vd
operator|->
name|vdev_ishole
condition|)
block|{
if|if
condition|(
name|lastlog
operator|==
literal|0
condition|)
name|lastlog
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
name|lastlog
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|children
operator|!=
operator|(
name|lastlog
operator|!=
literal|0
condition|?
name|lastlog
else|:
name|rvd
operator|->
name|vdev_children
operator|)
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
comment|/* next, ensure no spare or cache devices are part of the split */
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
operator|||
name|nvlist_lookup_nvlist
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|tmp
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|EINVAL
argument_list|)
operator|)
return|;
name|vml
operator|=
name|kmem_zalloc
argument_list|(
name|children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|glist
operator|=
name|kmem_zalloc
argument_list|(
name|children
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* then, loop over each vdev and validate it */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|is_hole
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_IS_HOLE
argument_list|,
operator|&
name|is_hole
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_hole
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_ishole
operator|||
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_islog
condition|)
block|{
continue|continue;
block|}
else|else
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* which disk is going to be split? */
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|glist
index|[
name|c
index|]
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* look it up in the spa */
name|vml
index|[
name|c
index|]
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|glist
index|[
name|c
index|]
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|vml
index|[
name|c
index|]
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENODEV
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* make sure there's nothing stopping the split */
if|if
condition|(
name|vml
index|[
name|c
index|]
operator|->
name|vdev_parent
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_mirror_ops
operator|||
name|vml
index|[
name|c
index|]
operator|->
name|vdev_islog
operator|||
name|vml
index|[
name|c
index|]
operator|->
name|vdev_ishole
operator|||
name|vml
index|[
name|c
index|]
operator|->
name|vdev_isspare
operator|||
name|vml
index|[
name|c
index|]
operator|->
name|vdev_isl2cache
operator|||
operator|!
name|vdev_writeable
argument_list|(
name|vml
index|[
name|c
index|]
argument_list|)
operator|||
name|vml
index|[
name|c
index|]
operator|->
name|vdev_children
operator|!=
literal|0
operator|||
name|vml
index|[
name|c
index|]
operator|->
name|vdev_state
operator|!=
name|VDEV_STATE_HEALTHY
operator|||
name|c
operator|!=
name|spa
operator|->
name|spa_root_vdev
operator|->
name|vdev_child
index|[
name|c
index|]
operator|->
name|vdev_id
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|vdev_dtl_required
argument_list|(
name|vml
index|[
name|c
index|]
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* we need certain info from the top level */
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_METASLAB_ARRAY
argument_list|,
name|vml
index|[
name|c
index|]
operator|->
name|vdev_top
operator|->
name|vdev_ms_array
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_METASLAB_SHIFT
argument_list|,
name|vml
index|[
name|c
index|]
operator|->
name|vdev_top
operator|->
name|vdev_ms_shift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_ASIZE
argument_list|,
name|vml
index|[
name|c
index|]
operator|->
name|vdev_top
operator|->
name|vdev_asize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_ASHIFT
argument_list|,
name|vml
index|[
name|c
index|]
operator|->
name|vdev_top
operator|->
name|vdev_ashift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* transfer per-vdev ZAPs */
name|ASSERT3U
argument_list|(
name|vml
index|[
name|c
index|]
operator|->
name|vdev_leaf_zap
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_VDEV_LEAF_ZAP
argument_list|,
name|vml
index|[
name|c
index|]
operator|->
name|vdev_leaf_zap
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|vml
index|[
name|c
index|]
operator|->
name|vdev_top
operator|->
name|vdev_top_zap
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|child
index|[
name|c
index|]
argument_list|,
name|ZPOOL_CONFIG_VDEV_TOP_ZAP
argument_list|,
name|vml
index|[
name|c
index|]
operator|->
name|vdev_parent
operator|->
name|vdev_top_zap
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|vml
argument_list|,
name|children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|glist
argument_list|,
name|children
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* stop writers from using the disks */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|vml
index|[
name|c
index|]
operator|!=
name|NULL
condition|)
name|vml
index|[
name|c
index|]
operator|->
name|vdev_offline
operator|=
name|B_TRUE
expr_stmt|;
block|}
name|vdev_reopen
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
comment|/* 	 * Temporarily record the splitting vdevs in the spa config.  This 	 * will disappear once the config is regenerated. 	 */
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64_array
argument_list|(
name|nvl
argument_list|,
name|ZPOOL_CONFIG_SPLIT_LIST
argument_list|,
name|glist
argument_list|,
name|children
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|glist
argument_list|,
name|children
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist
argument_list|(
name|spa
operator|->
name|spa_config
argument_list|,
name|ZPOOL_CONFIG_SPLIT
argument_list|,
name|nvl
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_splitting
operator|=
name|nvl
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
comment|/* configure and create the new pool */
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_NAME
argument_list|,
name|newname
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_STATE
argument_list|,
name|exp
condition|?
name|POOL_STATE_EXPORTED
else|:
name|POOL_STATE_ACTIVE
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_TXG
argument_list|,
name|spa
operator|->
name|spa_config_txg
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_POOL_GUID
argument_list|,
name|spa_generate_guid
argument_list|(
name|NULL
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|nvlist_add_boolean
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_HAS_PER_VDEV_ZAPS
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_lookup_string
argument_list|(
name|props
argument_list|,
name|zpool_prop_to_name
argument_list|(
name|ZPOOL_PROP_ALTROOT
argument_list|)
argument_list|,
operator|&
name|altroot
argument_list|)
expr_stmt|;
comment|/* add the new pool to the namespace */
name|newspa
operator|=
name|spa_add
argument_list|(
name|newname
argument_list|,
name|config
argument_list|,
name|altroot
argument_list|)
expr_stmt|;
name|newspa
operator|->
name|spa_avz_action
operator|=
name|AVZ_ACTION_REBUILD
expr_stmt|;
name|newspa
operator|->
name|spa_config_txg
operator|=
name|spa
operator|->
name|spa_config_txg
expr_stmt|;
name|spa_set_log_state
argument_list|(
name|newspa
argument_list|,
name|SPA_LOG_CLEAR
argument_list|)
expr_stmt|;
comment|/* release the spa config lock, retaining the namespace lock */
name|spa_vdev_config_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
condition|)
name|zio_handle_panic_injection
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|spa_activate
argument_list|(
name|newspa
argument_list|,
name|spa_mode_global
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|newspa
argument_list|)
expr_stmt|;
comment|/* create the new pool from the disks of the original pool */
name|error
operator|=
name|spa_load
argument_list|(
name|newspa
argument_list|,
name|SPA_LOAD_IMPORT
argument_list|,
name|SPA_IMPORT_ASSEMBLE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
comment|/* if that worked, generate a real config for the new pool */
if|if
condition|(
name|newspa
operator|->
name|spa_root_vdev
operator|!=
name|NULL
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|newspa
operator|->
name|spa_config_splitting
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|newspa
operator|->
name|spa_config_splitting
argument_list|,
name|ZPOOL_CONFIG_SPLIT_GUID
argument_list|,
name|spa_guid
argument_list|(
name|spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_set
argument_list|(
name|newspa
argument_list|,
name|spa_config_generate
argument_list|(
name|newspa
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|B_TRUE
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* set the props */
if|if
condition|(
name|props
operator|!=
name|NULL
condition|)
block|{
name|spa_configfile_set
argument_list|(
name|newspa
argument_list|,
name|props
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|error
operator|=
name|spa_prop_set
argument_list|(
name|newspa
argument_list|,
name|props
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* flush everything */
name|txg
operator|=
name|spa_vdev_config_enter
argument_list|(
name|newspa
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|newspa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_config_exit
argument_list|(
name|newspa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
condition|)
name|zio_handle_panic_injection
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|spa_async_resume
argument_list|(
name|newspa
argument_list|)
expr_stmt|;
comment|/* finally, update the original pool's config */
name|txg
operator|=
name|spa_vdev_config_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_dd
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
operator|->
name|dp_mos_dir
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|vml
index|[
name|c
index|]
operator|!=
name|NULL
condition|)
block|{
name|vdev_split
argument_list|(
name|vml
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"detach"
argument_list|,
name|tx
argument_list|,
literal|"vdev=%s"
argument_list|,
name|vml
index|[
name|c
index|]
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vml
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
block|}
name|spa
operator|->
name|spa_avz_action
operator|=
name|AVZ_ACTION_REBUILD
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_splitting
operator|=
name|NULL
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio_injection_enabled
condition|)
name|zio_handle_panic_injection
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|,
literal|3
argument_list|)
expr_stmt|;
comment|/* split is complete; log a history record */
name|spa_history_log_internal
argument_list|(
name|newspa
argument_list|,
literal|"split"
argument_list|,
name|NULL
argument_list|,
literal|"from pool %s"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vml
argument_list|,
name|children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* if we're not going to mount the filesystems in userland, export */
if|if
condition|(
name|exp
condition|)
name|error
operator|=
name|spa_export_common
argument_list|(
name|newname
argument_list|,
name|POOL_STATE_EXPORTED
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
name|out
label|:
name|spa_unload
argument_list|(
name|newspa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|newspa
argument_list|)
expr_stmt|;
name|spa_remove
argument_list|(
name|newspa
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_config_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* re-online all offlined disks */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|vml
index|[
name|c
index|]
operator|!=
name|NULL
condition|)
name|vml
index|[
name|c
index|]
operator|->
name|vdev_offline
operator|=
name|B_FALSE
expr_stmt|;
block|}
name|vdev_reopen
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config_splitting
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_splitting
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vml
argument_list|,
name|children
operator|*
sizeof|sizeof
argument_list|(
name|vdev_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|nvlist_t
modifier|*
name|spa_nvlist_lookup_by_guid
parameter_list|(
name|nvlist_t
modifier|*
modifier|*
name|nvpp
parameter_list|,
name|int
name|count
parameter_list|,
name|uint64_t
name|target_guid
parameter_list|)
block|{
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|uint64_t
name|guid
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvpp
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|guid
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|guid
operator|==
name|target_guid
condition|)
return|return
operator|(
name|nvpp
index|[
name|i
index|]
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_vdev_remove_aux
parameter_list|(
name|nvlist_t
modifier|*
name|config
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|nvlist_t
modifier|*
modifier|*
name|dev
parameter_list|,
name|int
name|count
parameter_list|,
name|nvlist_t
modifier|*
name|dev_to_remove
parameter_list|)
block|{
name|nvlist_t
modifier|*
modifier|*
name|newdev
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|newdev
operator|=
name|kmem_alloc
argument_list|(
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|,
name|j
init|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dev
index|[
name|i
index|]
operator|==
name|dev_to_remove
condition|)
continue|continue;
name|VERIFY
argument_list|(
name|nvlist_dup
argument_list|(
name|dev
index|[
name|i
index|]
argument_list|,
operator|&
name|newdev
index|[
name|j
operator|++
index|]
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_remove
argument_list|(
name|config
argument_list|,
name|name
argument_list|,
name|DATA_TYPE_NVLIST_ARRAY
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|config
argument_list|,
name|name
argument_list|,
name|newdev
argument_list|,
name|count
operator|-
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|count
operator|-
literal|1
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|newdev
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
operator|>
literal|1
condition|)
name|kmem_free
argument_list|(
name|newdev
argument_list|,
operator|(
name|count
operator|-
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Evacuate the device.  */
end_comment

begin_function
specifier|static
name|int
name|spa_vdev_remove_evacuate
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|uint64_t
name|txg
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
comment|/* 	 * Evacuate the device.  We don't hold the config lock as writer 	 * since we need to do I/O but we do keep the 	 * spa_namespace_lock held.  Once this completes the device 	 * should no longer have any blocks allocated on it. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_islog
condition|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|!=
literal|0
condition|)
name|error
operator|=
name|spa_offline_log
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* 	 * The evacuation succeeded.  Remove any remaining MOS metadata 	 * associated with this vdev, and wait for these changes to sync. 	 */
name|ASSERT0
argument_list|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_config_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_removing
operator|=
name|B_TRUE
expr_stmt|;
name|vdev_dirty_leaves
argument_list|(
name|vd
argument_list|,
name|VDD_DTL
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|spa_vdev_config_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complete the removal by cleaning up the namespace.  */
end_comment

begin_function
specifier|static
name|void
name|spa_vdev_remove_from_namespace
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|uint64_t
name|id
init|=
name|vd
operator|->
name|vdev_id
decl_stmt|;
name|boolean_t
name|last_vdev
init|=
operator|(
name|id
operator|==
operator|(
name|rvd
operator|->
name|vdev_children
operator|-
literal|1
operator|)
operator|)
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
name|SCL_ALL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
comment|/* 	 * Only remove any devices which are empty. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_alloc
operator|!=
literal|0
condition|)
return|return;
operator|(
name|void
operator|)
name|vdev_label_init
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|VDEV_LABEL_REMOVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_state_dirty_node
argument_list|)
condition|)
name|vdev_state_clean
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_link_active
argument_list|(
operator|&
name|vd
operator|->
name|vdev_config_dirty_node
argument_list|)
condition|)
name|vdev_config_clean
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_free
argument_list|(
name|vd
argument_list|)
expr_stmt|;
if|if
condition|(
name|last_vdev
condition|)
block|{
name|vdev_compact_children
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vd
operator|=
name|vdev_alloc_common
argument_list|(
name|spa
argument_list|,
name|id
argument_list|,
literal|0
argument_list|,
operator|&
name|vdev_hole_ops
argument_list|)
expr_stmt|;
name|vdev_add_child
argument_list|(
name|rvd
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
name|vdev_config_dirty
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
comment|/* 	 * Reassess the health of our root vdev. 	 */
name|vdev_reopen
argument_list|(
name|rvd
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Remove a device from the pool -  *  * Removing a device from the vdev namespace requires several steps  * and can take a significant amount of time.  As a result we use  * the spa_vdev_config_[enter/exit] functions which allow us to  * grab and release the spa_config_lock while still holding the namespace  * lock.  During each step the configuration is synced out.  *  * Currently, this supports removing only hot spares, slogs, and level 2 ARC  * devices.  */
end_comment

begin_function
name|int
name|spa_vdev_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|unspare
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|sysevent_t
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|spares
decl_stmt|,
modifier|*
modifier|*
name|l2cache
decl_stmt|,
modifier|*
name|nv
decl_stmt|;
name|uint64_t
name|txg
init|=
literal|0
decl_stmt|;
name|uint_t
name|nspares
decl_stmt|,
name|nl2cache
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|locked
init|=
name|MUTEX_HELD
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|locked
condition|)
name|txg
operator|=
name|spa_vdev_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
operator|&
name|spares
argument_list|,
operator|&
name|nspares
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|nv
operator|=
name|spa_nvlist_lookup_by_guid
argument_list|(
name|spares
argument_list|,
name|nspares
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Only remove the hot spare if it's not currently in use 		 * in this pool. 		 */
if|if
condition|(
name|vd
operator|==
name|NULL
operator|||
name|unspare
condition|)
block|{
if|if
condition|(
name|vd
operator|==
name|NULL
condition|)
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|ev
operator|=
name|spa_event_create
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_REMOVE_AUX
argument_list|)
expr_stmt|;
name|spa_vdev_remove_aux
argument_list|(
name|spa
operator|->
name|spa_spares
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|spares
argument_list|,
name|nspares
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|spa_load_spares
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_spares
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
operator|!=
name|NULL
operator|&&
name|nvlist_lookup_nvlist_array
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
operator|&
name|l2cache
argument_list|,
operator|&
name|nl2cache
argument_list|)
operator|==
literal|0
operator|&&
operator|(
name|nv
operator|=
name|spa_nvlist_lookup_by_guid
argument_list|(
name|l2cache
argument_list|,
name|nl2cache
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Cache devices can always be removed. 		 */
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|ev
operator|=
name|spa_event_create
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_REMOVE_AUX
argument_list|)
expr_stmt|;
name|spa_vdev_remove_aux
argument_list|(
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_config
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|l2cache
argument_list|,
name|nl2cache
argument_list|,
name|nv
argument_list|)
expr_stmt|;
name|spa_load_l2cache
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vd
operator|!=
name|NULL
operator|&&
name|vd
operator|->
name|vdev_islog
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|locked
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|==
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
name|mg
operator|=
name|vd
operator|->
name|vdev_mg
expr_stmt|;
comment|/* 		 * Stop allocating from this vdev. 		 */
name|metaslab_group_passivate
argument_list|(
name|mg
argument_list|)
expr_stmt|;
comment|/* 		 * Wait for the youngest allocations and frees to sync, 		 * and then wait for the deferral of those frees to finish. 		 */
name|spa_vdev_config_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
operator|+
name|TXG_CONCURRENT_STATES
operator|+
name|TXG_DEFER_SIZE
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* 		 * Attempt to evacuate the vdev. 		 */
name|error
operator|=
name|spa_vdev_remove_evacuate
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|txg
operator|=
name|spa_vdev_config_enter
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 		 * If we couldn't evacuate the vdev, unwind. 		 */
if|if
condition|(
name|error
condition|)
block|{
name|metaslab_group_activate
argument_list|(
name|mg
argument_list|)
expr_stmt|;
return|return
operator|(
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
operator|)
return|;
block|}
comment|/* 		 * Clean up the vdev namespace. 		 */
name|ev
operator|=
name|spa_event_create
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|ESC_ZFS_VDEV_REMOVE_DEV
argument_list|)
expr_stmt|;
name|spa_vdev_remove_from_namespace
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Normal vdevs cannot be removed (yet). 		 */
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * There is no vdev of any kind with the specified guid. 		 */
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|locked
condition|)
name|error
operator|=
name|spa_vdev_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|ev
condition|)
name|spa_event_post
argument_list|(
name|ev
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Find any device that's done replacing, or a vdev marked 'unspare' that's  * currently spared, so we can detach it.  */
end_comment

begin_function
specifier|static
name|vdev_t
modifier|*
name|spa_vdev_resilver_done_hunt
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_t
modifier|*
name|newvd
decl_stmt|,
modifier|*
name|oldvd
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|oldvd
operator|=
name|spa_vdev_resilver_done_hunt
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldvd
operator|!=
name|NULL
condition|)
return|return
operator|(
name|oldvd
operator|)
return|;
block|}
comment|/* 	 * Check for a completed replacement.  We always consider the first 	 * vdev in the list to be the oldest vdev, and the last one to be 	 * the newest (see spa_vdev_attach() for how that works).  In 	 * the case where the newest vdev is faulted, we will not automatically 	 * remove it after a resilver completes.  This is OK as it will require 	 * user intervention to determine which disk the admin wishes to keep. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
condition|)
block|{
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_children
operator|>
literal|1
argument_list|)
expr_stmt|;
name|newvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|vd
operator|->
name|vdev_children
operator|-
literal|1
index|]
expr_stmt|;
name|oldvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|vdev_dtl_empty
argument_list|(
name|newvd
argument_list|,
name|DTL_MISSING
argument_list|)
operator|&&
name|vdev_dtl_empty
argument_list|(
name|newvd
argument_list|,
name|DTL_OUTAGE
argument_list|)
operator|&&
operator|!
name|vdev_dtl_required
argument_list|(
name|oldvd
argument_list|)
condition|)
return|return
operator|(
name|oldvd
operator|)
return|;
block|}
comment|/* 	 * Check for a completed resilver with the 'unspare' flag set. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
condition|)
block|{
name|vdev_t
modifier|*
name|first
init|=
name|vd
operator|->
name|vdev_child
index|[
literal|0
index|]
decl_stmt|;
name|vdev_t
modifier|*
name|last
init|=
name|vd
operator|->
name|vdev_child
index|[
name|vd
operator|->
name|vdev_children
operator|-
literal|1
index|]
decl_stmt|;
if|if
condition|(
name|last
operator|->
name|vdev_unspare
condition|)
block|{
name|oldvd
operator|=
name|first
expr_stmt|;
name|newvd
operator|=
name|last
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|first
operator|->
name|vdev_unspare
condition|)
block|{
name|oldvd
operator|=
name|last
expr_stmt|;
name|newvd
operator|=
name|first
expr_stmt|;
block|}
else|else
block|{
name|oldvd
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|oldvd
operator|!=
name|NULL
operator|&&
name|vdev_dtl_empty
argument_list|(
name|newvd
argument_list|,
name|DTL_MISSING
argument_list|)
operator|&&
name|vdev_dtl_empty
argument_list|(
name|newvd
argument_list|,
name|DTL_OUTAGE
argument_list|)
operator|&&
operator|!
name|vdev_dtl_required
argument_list|(
name|oldvd
argument_list|)
condition|)
return|return
operator|(
name|oldvd
operator|)
return|;
comment|/* 		 * If there are more than two spares attached to a disk, 		 * and those spares are not required, then we want to 		 * attempt to free them up now so that they can be used 		 * by other pools.  Once we're back down to a single 		 * disk+spare, we stop removing them. 		 */
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|>
literal|2
condition|)
block|{
name|newvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|newvd
operator|->
name|vdev_isspare
operator|&&
name|last
operator|->
name|vdev_isspare
operator|&&
name|vdev_dtl_empty
argument_list|(
name|last
argument_list|,
name|DTL_MISSING
argument_list|)
operator|&&
name|vdev_dtl_empty
argument_list|(
name|last
argument_list|,
name|DTL_OUTAGE
argument_list|)
operator|&&
operator|!
name|vdev_dtl_required
argument_list|(
name|newvd
argument_list|)
condition|)
return|return
operator|(
name|newvd
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_vdev_resilver_done
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|,
modifier|*
name|pvd
decl_stmt|,
modifier|*
name|ppvd
decl_stmt|;
name|uint64_t
name|guid
decl_stmt|,
name|sguid
decl_stmt|,
name|pguid
decl_stmt|,
name|ppguid
decl_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vd
operator|=
name|spa_vdev_resilver_done_hunt
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|pvd
operator|=
name|vd
operator|->
name|vdev_parent
expr_stmt|;
name|ppvd
operator|=
name|pvd
operator|->
name|vdev_parent
expr_stmt|;
name|guid
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
name|pguid
operator|=
name|pvd
operator|->
name|vdev_guid
expr_stmt|;
name|ppguid
operator|=
name|ppvd
operator|->
name|vdev_guid
expr_stmt|;
name|sguid
operator|=
literal|0
expr_stmt|;
comment|/* 		 * If we have just finished replacing a hot spared device, then 		 * we need to detach the parent's first child (the original hot 		 * spare) as well. 		 */
if|if
condition|(
name|ppvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
operator|&&
name|pvd
operator|->
name|vdev_id
operator|==
literal|0
operator|&&
name|ppvd
operator|->
name|vdev_children
operator|==
literal|2
condition|)
block|{
name|ASSERT
argument_list|(
name|pvd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
argument_list|)
expr_stmt|;
name|sguid
operator|=
name|ppvd
operator|->
name|vdev_child
index|[
literal|1
index|]
operator|->
name|vdev_guid
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_resilver_txg
operator|==
literal|0
operator|||
operator|!
name|vdev_dtl_required
argument_list|(
name|vd
argument_list|)
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|pguid
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
if|if
condition|(
name|sguid
operator|&&
name|spa_vdev_detach
argument_list|(
name|spa
argument_list|,
name|sguid
argument_list|,
name|ppguid
argument_list|,
name|B_TRUE
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Update the stored path or FRU for this vdev.  */
end_comment

begin_function
name|int
name|spa_vdev_set_common
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|value
parameter_list|,
name|boolean_t
name|ispath
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|boolean_t
name|sync
init|=
name|B_FALSE
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|spa_lookup_by_guid
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|B_TRUE
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENOENT
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
condition|)
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|ENOTSUP
argument_list|)
operator|)
return|;
if|if
condition|(
name|ispath
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|vd
operator|->
name|vdev_path
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_path
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_path
operator|=
name|spa_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_fru
operator|==
name|NULL
condition|)
block|{
name|vd
operator|->
name|vdev_fru
operator|=
name|spa_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|value
argument_list|,
name|vd
operator|->
name|vdev_fru
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|spa_strfree
argument_list|(
name|vd
operator|->
name|vdev_fru
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_fru
operator|=
name|spa_strdup
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|sync
operator|=
name|B_TRUE
expr_stmt|;
block|}
block|}
return|return
operator|(
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|sync
condition|?
name|vd
else|:
name|NULL
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_vdev_setpath
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newpath
parameter_list|)
block|{
return|return
operator|(
name|spa_vdev_set_common
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|newpath
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_vdev_setfru
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
specifier|const
name|char
modifier|*
name|newfru
parameter_list|)
block|{
return|return
operator|(
name|spa_vdev_set_common
argument_list|(
name|spa
argument_list|,
name|guid
argument_list|,
name|newfru
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA Scanning  * ==========================================================================  */
end_comment

begin_function
name|int
name|spa_scan_stop
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_scan_resilvering
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
return|return
operator|(
name|dsl_scan_cancel
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|spa_scan
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|pool_scan_func_t
name|func
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|func
operator|>=
name|POOL_SCAN_FUNCS
operator|||
name|func
operator|==
name|POOL_SCAN_NONE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
comment|/* 	 * If a resilver was requested, but there is no DTL on a 	 * writeable leaf device, we have nothing to do. 	 */
if|if
condition|(
name|func
operator|==
name|POOL_SCAN_RESILVER
operator|&&
operator|!
name|vdev_resilver_needed
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_RESILVER_DONE
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|dsl_scan
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
name|func
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA async task processing  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|void
name|spa_async_remove
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_remove_wanted
condition|)
block|{
name|vd
operator|->
name|vdev_remove_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|vd
operator|->
name|vdev_delayed_close
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_REMOVED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
comment|/* 		 * We want to clear the stats, but we don't want to do a full 		 * vdev_clear() as that will cause us to throw away 		 * degraded/faulted state as well as attempt to reopen the 		 * device, all of which is a waste. 		 */
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_read_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_write_errors
operator|=
literal|0
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_checksum_errors
operator|=
literal|0
expr_stmt|;
name|vdev_state_dirty
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_probe
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
if|if
condition|(
name|vd
operator|->
name|vdev_probe_wanted
condition|)
block|{
name|vd
operator|->
name|vdev_probe_wanted
operator|=
name|B_FALSE
expr_stmt|;
name|vdev_reopen
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* vdev_open() does the actual probe */
block|}
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|spa_async_probe
argument_list|(
name|spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_autoexpand
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|sysevent_id_t
name|eid
decl_stmt|;
name|nvlist_t
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|physpath
decl_stmt|;
if|if
condition|(
operator|!
name|spa
operator|->
name|spa_autoexpand
condition|)
return|return;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|cvd
init|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|spa_async_autoexpand
argument_list|(
name|spa
argument_list|,
name|cvd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|||
name|vd
operator|->
name|vdev_physpath
operator|==
name|NULL
condition|)
return|return;
name|physpath
operator|=
name|kmem_zalloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"/devices%s"
argument_list|,
name|vd
operator|->
name|vdev_physpath
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|attr
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|attr
argument_list|,
name|DEV_PHYS_PATH
argument_list|,
name|physpath
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_log_sysevent
argument_list|(
name|zfs_dip
argument_list|,
name|SUNW_VENDOR
argument_list|,
name|EC_DEV_STATUS
argument_list|,
name|ESC_DEV_DLE
argument_list|,
name|attr
argument_list|,
operator|&
name|eid
argument_list|,
name|DDI_SLEEP
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_thread
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|tasks
decl_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_sync_on
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|tasks
operator|=
name|spa
operator|->
name|spa_async_tasks
expr_stmt|;
name|spa
operator|->
name|spa_async_tasks
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
comment|/* 	 * See if the config needs to be updated. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_CONFIG_UPDATE
condition|)
block|{
name|uint64_t
name|old_space
decl_stmt|,
name|new_space
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|old_space
operator|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa_config_update
argument_list|(
name|spa
argument_list|,
name|SPA_CONFIG_UPDATE_POOL
argument_list|)
expr_stmt|;
name|new_space
operator|=
name|metaslab_class_get_space
argument_list|(
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
comment|/* 		 * If the pool grew as a result of the config update, 		 * then log an internal history event. 		 */
if|if
condition|(
name|new_space
operator|!=
name|old_space
condition|)
block|{
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"vdev online"
argument_list|,
name|NULL
argument_list|,
literal|"pool '%s' size: %llu(+%llu)"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|new_space
argument_list|,
name|new_space
operator|-
name|old_space
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * See if any devices need to be marked REMOVED. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_REMOVE
condition|)
block|{
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_NONE
argument_list|)
expr_stmt|;
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
name|spa_async_remove
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tasks
operator|&
name|SPA_ASYNC_AUTOEXPAND
operator|)
operator|&&
operator|!
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|spa_async_autoexpand
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * See if any devices need to be probed. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_PROBE
condition|)
block|{
name|spa_vdev_state_enter
argument_list|(
name|spa
argument_list|,
name|SCL_NONE
argument_list|)
expr_stmt|;
name|spa_async_probe
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|spa_vdev_state_exit
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If any devices are done replacing, detach them. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_RESILVER_DONE
condition|)
name|spa_vdev_resilver_done
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * Kick off a resilver. 	 */
if|if
condition|(
name|tasks
operator|&
name|SPA_ASYNC_RESILVER
condition|)
name|dsl_resilver_restart
argument_list|(
name|spa
operator|->
name|spa_dsl_pool
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Let the world know that we're done. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_thread
operator|=
name|NULL
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|thread_exit
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_suspend
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|++
expr_stmt|;
while|while
condition|(
name|spa
operator|->
name|spa_async_thread
operator|!=
name|NULL
condition|)
name|cv_wait
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_cv
argument_list|,
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_resume
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_async_suspended
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_suspended
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|spa_async_tasks_pending
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|uint_t
name|non_config_tasks
decl_stmt|;
name|uint_t
name|config_task
decl_stmt|;
name|boolean_t
name|config_task_suspended
decl_stmt|;
name|non_config_tasks
operator|=
name|spa
operator|->
name|spa_async_tasks
operator|&
operator|~
name|SPA_ASYNC_CONFIG_UPDATE
expr_stmt|;
name|config_task
operator|=
name|spa
operator|->
name|spa_async_tasks
operator|&
name|SPA_ASYNC_CONFIG_UPDATE
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_ccw_fail_time
operator|==
literal|0
condition|)
block|{
name|config_task_suspended
operator|=
name|B_FALSE
expr_stmt|;
block|}
else|else
block|{
name|config_task_suspended
operator|=
operator|(
name|gethrtime
argument_list|()
operator|-
name|spa
operator|->
name|spa_ccw_fail_time
operator|)
operator|<
operator|(
name|zfs_ccw_retry_interval
operator|*
name|NANOSEC
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|non_config_tasks
operator|||
operator|(
name|config_task
operator|&&
operator|!
name|config_task_suspended
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_async_dispatch
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_async_tasks_pending
argument_list|(
name|spa
argument_list|)
operator|&&
operator|!
name|spa
operator|->
name|spa_async_suspended
operator|&&
name|spa
operator|->
name|spa_async_thread
operator|==
name|NULL
operator|&&
name|rootdir
operator|!=
name|NULL
condition|)
name|spa
operator|->
name|spa_async_thread
operator|=
name|thread_create
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
name|spa_async_thread
argument_list|,
name|spa
argument_list|,
literal|0
argument_list|,
operator|&
name|p0
argument_list|,
name|TS_RUN
argument_list|,
name|maxclsyspri
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|spa_async_request
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|int
name|task
parameter_list|)
block|{
name|zfs_dbgmsg
argument_list|(
literal|"spa=%s async request task=%u"
argument_list|,
name|spa
operator|->
name|spa_name
argument_list|,
name|task
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_async_tasks
operator||=
name|task
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_async_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * SPA syncing routines  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|bpobj_enqueue_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|bpobj_t
modifier|*
name|bpo
init|=
name|arg
decl_stmt|;
name|bpobj_enqueue
argument_list|(
name|bpo
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|spa_free_sync_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
init|=
name|arg
decl_stmt|;
name|zio_nowait
argument_list|(
name|zio_free_sync
argument_list|(
name|zio
argument_list|,
name|zio
operator|->
name|io_spa
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|bp
argument_list|,
name|zio
operator|->
name|io_flags
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Note: this simple function is not inlined to make it easier to dtrace the  * amount of time spent syncing frees.  */
end_comment

begin_function
specifier|static
name|void
name|spa_sync_frees
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|bplist_t
modifier|*
name|bpl
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
init|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|bplist_iterate
argument_list|(
name|bpl
argument_list|,
name|spa_free_sync_cb
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Note: this simple function is not inlined to make it easier to dtrace the  * amount of time spent syncing deferred frees.  */
end_comment

begin_function
specifier|static
name|void
name|spa_sync_deferred_frees
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
init|=
name|zio_root
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|VERIFY3U
argument_list|(
name|bpobj_iterate
argument_list|(
operator|&
name|spa
operator|->
name|spa_deferred_bpobj
argument_list|,
name|spa_free_sync_cb
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_nvlist
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|char
modifier|*
name|packed
init|=
name|NULL
decl_stmt|;
name|size_t
name|bufsize
decl_stmt|;
name|size_t
name|nvsize
init|=
literal|0
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_size
argument_list|(
name|nv
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Write full (SPA_CONFIG_BLOCKSIZE) blocks of configuration 	 * information.  This avoids the dmu_buf_will_dirty() path and 	 * saves us a pre-read to get data we don't actually care about. 	 */
name|bufsize
operator|=
name|P2ROUNDUP
argument_list|(
operator|(
name|uint64_t
operator|)
name|nvsize
argument_list|,
name|SPA_CONFIG_BLOCKSIZE
argument_list|)
expr_stmt|;
name|packed
operator|=
name|kmem_alloc
argument_list|(
name|bufsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_pack
argument_list|(
name|nv
argument_list|,
operator|&
name|packed
argument_list|,
operator|&
name|nvsize
argument_list|,
name|NV_ENCODE_XDR
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|packed
operator|+
name|nvsize
argument_list|,
name|bufsize
operator|-
name|nvsize
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
literal|0
argument_list|,
name|bufsize
argument_list|,
name|packed
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|packed
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
operator|*
operator|(
name|uint64_t
operator|*
operator|)
name|db
operator|->
name|db_data
operator|=
name|nvsize
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_aux_dev
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|spa_aux_vdev_t
modifier|*
name|sav
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
specifier|const
name|char
modifier|*
name|config
parameter_list|,
specifier|const
name|char
modifier|*
name|entry
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvroot
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|list
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|sav
operator|->
name|sav_sync
condition|)
return|return;
comment|/* 	 * Update the MOS nvlist describing the list of available devices. 	 * spa_validate_aux() will have already made sure this nvlist is 	 * valid and the vdevs are labeled appropriately. 	 */
if|if
condition|(
name|sav
operator|->
name|sav_object
operator|==
literal|0
condition|)
block|{
name|sav
operator|->
name|sav_object
operator|=
name|dmu_object_alloc
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OT_PACKED_NVLIST
argument_list|,
literal|1
operator|<<
literal|14
argument_list|,
name|DMU_OT_PACKED_NVLIST_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_update
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|entry
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|sav
operator|->
name|sav_object
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nvroot
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|sav
operator|->
name|sav_count
operator|==
literal|0
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|config
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|list
operator|=
name|kmem_alloc
argument_list|(
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|list
index|[
name|i
index|]
operator|=
name|vdev_config_generate
argument_list|(
name|spa
argument_list|,
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_CONFIG_L2CACHE
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_nvlist_array
argument_list|(
name|nvroot
argument_list|,
name|config
argument_list|,
name|list
argument_list|,
name|sav
operator|->
name|sav_count
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
name|nvlist_free
argument_list|(
name|list
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|list
argument_list|,
name|sav
operator|->
name|sav_count
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_sync_nvlist
argument_list|(
name|spa
argument_list|,
name|sav
operator|->
name|sav_object
argument_list|,
name|nvroot
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nvroot
argument_list|)
expr_stmt|;
name|sav
operator|->
name|sav_sync
operator|=
name|B_FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Rebuild spa's all-vdev ZAP from the vdev ZAPs indicated in each vdev_t.  * The all-vdev ZAP must be empty.  */
end_comment

begin_function
specifier|static
name|void
name|spa_avz_build
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|avz
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_top_zap
operator|!=
literal|0
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|avz
argument_list|,
name|vd
operator|->
name|vdev_top_zap
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vd
operator|->
name|vdev_leaf_zap
operator|!=
literal|0
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|avz
argument_list|,
name|vd
operator|->
name|vdev_leaf_zap
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|uint64_t
name|i
init|=
literal|0
init|;
name|i
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|i
operator|++
control|)
block|{
name|spa_avz_build
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|i
index|]
argument_list|,
name|avz
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_config_object
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|config
decl_stmt|;
comment|/* 	 * If the pool is being imported from a pre-per-vdev-ZAP version of ZFS, 	 * its config may not be dirty but we still need to build per-vdev ZAPs. 	 * Similarly, if the pool is being assembled (e.g. after a split), we 	 * need to rebuild the AVZ although the config may not be dirty. 	 */
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
operator|&&
name|spa
operator|->
name|spa_avz_action
operator|==
name|AVZ_ACTION_NONE
condition|)
return|return;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_avz_action
operator|==
name|AVZ_ACTION_NONE
operator|||
name|spa
operator|->
name|spa_avz_action
operator|==
name|AVZ_ACTION_INITIALIZE
operator|||
name|spa
operator|->
name|spa_all_vdev_zaps
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_avz_action
operator|==
name|AVZ_ACTION_REBUILD
condition|)
block|{
comment|/* Make and build the new AVZ */
name|uint64_t
name|new_avz
init|=
name|zap_create
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OTN_ZAP_METADATA
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
decl_stmt|;
name|spa_avz_build
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|new_avz
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Diff old AVZ with new one */
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|uint64_t
name|vdzap
init|=
name|za
operator|.
name|za_first_integer
decl_stmt|;
if|if
condition|(
name|zap_lookup_int
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|new_avz
argument_list|,
name|vdzap
argument_list|)
operator|==
name|ENOENT
condition|)
block|{
comment|/* 				 * ZAP is listed in old AVZ but not in new one; 				 * destroy it 				 */
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|vdzap
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* Destroy the old AVZ */
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Replace the old AVZ in the dir obj with the new one */
name|VERIFY0
argument_list|(
name|zap_update
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_VDEV_ZAP_MAP
argument_list|,
sizeof|sizeof
argument_list|(
name|new_avz
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|new_avz
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_all_vdev_zaps
operator|=
name|new_avz
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|spa
operator|->
name|spa_avz_action
operator|==
name|AVZ_ACTION_DESTROY
condition|)
block|{
name|zap_cursor_t
name|zc
decl_stmt|;
name|zap_attribute_t
name|za
decl_stmt|;
comment|/* Walk through the AVZ and destroy all listed ZAPs */
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|uint64_t
name|zap
init|=
name|za
operator|.
name|za_first_integer
decl_stmt|;
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|zap
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
comment|/* Destroy and unlink the AVZ itself */
name|VERIFY0
argument_list|(
name|zap_destroy
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_remove
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_VDEV_ZAP_MAP
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_all_vdev_zaps
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_all_vdev_zaps
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_all_vdev_zaps
operator|=
name|zap_create_link
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_OTN_ZAP_METADATA
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_VDEV_ZAP_MAP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|spa
operator|->
name|spa_avz_action
operator|=
name|AVZ_ACTION_NONE
expr_stmt|;
comment|/* Create ZAPs for vdevs that don't have them. */
name|vdev_construct_zaps
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|config
operator|=
name|spa_config_generate
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|dmu_tx_get_txg
argument_list|(
name|tx
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
comment|/* 	 * If we're upgrading the spa version then make sure that 	 * the config object gets updated with the correct version. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
condition|)
name|fnvlist_add_uint64
argument_list|(
name|config
argument_list|,
name|ZPOOL_CONFIG_VERSION
argument_list|,
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|spa
operator|->
name|spa_config_syncing
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_syncing
operator|=
name|config
expr_stmt|;
name|spa_sync_nvlist
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_object
argument_list|,
name|config
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_sync_version
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
modifier|*
name|versionp
init|=
name|arg
decl_stmt|;
name|uint64_t
name|version
init|=
operator|*
name|versionp
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
comment|/* 	 * Setting the version is special cased when first creating the pool. 	 */
name|ASSERT
argument_list|(
name|tx
operator|->
name|tx_txg
operator|!=
name|TXG_INITIAL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|version
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|version
operator|>=
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|version
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"set"
argument_list|,
name|tx
argument_list|,
literal|"version=%lld"
argument_list|,
name|version
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set zpool properties.  */
end_comment

begin_function
specifier|static
name|void
name|spa_sync_props
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvp
init|=
name|arg
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|nvpair_t
modifier|*
name|elem
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|elem
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvp
argument_list|,
name|elem
argument_list|)
operator|)
condition|)
block|{
name|uint64_t
name|intval
decl_stmt|;
name|char
modifier|*
name|strval
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|zpool_prop_t
name|prop
decl_stmt|;
specifier|const
name|char
modifier|*
name|propname
decl_stmt|;
name|zprop_type_t
name|proptype
decl_stmt|;
name|spa_feature_t
name|fid
decl_stmt|;
switch|switch
condition|(
name|prop
operator|=
name|zpool_name_to_prop
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|ZPROP_INVAL
case|:
comment|/* 			 * We checked this earlier in spa_prop_validate(). 			 */
name|ASSERT
argument_list|(
name|zpool_prop_feature
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|fname
operator|=
name|strchr
argument_list|(
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
literal|'@'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|VERIFY0
argument_list|(
name|zfeature_lookup_name
argument_list|(
name|fname
argument_list|,
operator|&
name|fid
argument_list|)
argument_list|)
expr_stmt|;
name|spa_feature_enable
argument_list|(
name|spa
argument_list|,
name|fid
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"set"
argument_list|,
name|tx
argument_list|,
literal|"%s=enabled"
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_VERSION
case|:
name|intval
operator|=
name|fnvpair_value_uint64
argument_list|(
name|elem
argument_list|)
expr_stmt|;
comment|/* 			 * The version is synced seperatly before other 			 * properties and should be correct by now. 			 */
name|ASSERT3U
argument_list|(
name|spa_version
argument_list|(
name|spa
argument_list|)
argument_list|,
operator|>=
argument_list|,
name|intval
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_ALTROOT
case|:
comment|/* 			 * 'altroot' is a non-persistent property. It should 			 * have been set temporarily at creation or import time. 			 */
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_root
operator|!=
name|NULL
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_READONLY
case|:
case|case
name|ZPOOL_PROP_CACHEFILE
case|:
comment|/* 			 * 'readonly' and 'cachefile' are also non-persisitent 			 * properties. 			 */
break|break;
case|case
name|ZPOOL_PROP_COMMENT
case|:
name|strval
operator|=
name|fnvpair_value_string
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_comment
operator|!=
name|NULL
condition|)
name|spa_strfree
argument_list|(
name|spa
operator|->
name|spa_comment
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_comment
operator|=
name|spa_strdup
argument_list|(
name|strval
argument_list|)
expr_stmt|;
comment|/* 			 * We need to dirty the configuration on all the vdevs 			 * so that their labels get updated.  It's unnecessary 			 * to do this for pool creation since the vdev's 			 * configuratoin has already been dirtied. 			 */
if|if
condition|(
name|tx
operator|->
name|tx_txg
operator|!=
name|TXG_INITIAL
condition|)
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"set"
argument_list|,
name|tx
argument_list|,
literal|"%s=%s"
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
break|break;
default|default:
comment|/* 			 * Set pool property values in the poolprops mos object. 			 */
if|if
condition|(
name|spa
operator|->
name|spa_pool_props_object
operator|==
literal|0
condition|)
block|{
name|spa
operator|->
name|spa_pool_props_object
operator|=
name|zap_create_link
argument_list|(
name|mos
argument_list|,
name|DMU_OT_POOL_PROPS
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_PROPS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* normalize the property name */
name|propname
operator|=
name|zpool_prop_to_name
argument_list|(
name|prop
argument_list|)
expr_stmt|;
name|proptype
operator|=
name|zpool_prop_get_type
argument_list|(
name|prop
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|==
name|DATA_TYPE_STRING
condition|)
block|{
name|ASSERT
argument_list|(
name|proptype
operator|==
name|PROP_TYPE_STRING
argument_list|)
expr_stmt|;
name|strval
operator|=
name|fnvpair_value_string
argument_list|(
name|elem
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|propname
argument_list|,
literal|1
argument_list|,
name|strlen
argument_list|(
name|strval
argument_list|)
operator|+
literal|1
argument_list|,
name|strval
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"set"
argument_list|,
name|tx
argument_list|,
literal|"%s=%s"
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|strval
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|nvpair_type
argument_list|(
name|elem
argument_list|)
operator|==
name|DATA_TYPE_UINT64
condition|)
block|{
name|intval
operator|=
name|fnvpair_value_uint64
argument_list|(
name|elem
argument_list|)
expr_stmt|;
if|if
condition|(
name|proptype
operator|==
name|PROP_TYPE_INDEX
condition|)
block|{
specifier|const
name|char
modifier|*
name|unused
decl_stmt|;
name|VERIFY0
argument_list|(
name|zpool_prop_index_to_string
argument_list|(
name|prop
argument_list|,
name|intval
argument_list|,
operator|&
name|unused
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zap_update
argument_list|(
name|mos
argument_list|,
name|spa
operator|->
name|spa_pool_props_object
argument_list|,
name|propname
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|intval
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|spa_history_log_internal
argument_list|(
name|spa
argument_list|,
literal|"set"
argument_list|,
name|tx
argument_list|,
literal|"%s=%lld"
argument_list|,
name|nvpair_name
argument_list|(
name|elem
argument_list|)
argument_list|,
name|intval
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* not allowed */
block|}
switch|switch
condition|(
name|prop
condition|)
block|{
case|case
name|ZPOOL_PROP_DELEGATION
case|:
name|spa
operator|->
name|spa_delegation
operator|=
name|intval
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_BOOTFS
case|:
name|spa
operator|->
name|spa_bootfs
operator|=
name|intval
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_FAILUREMODE
case|:
name|spa
operator|->
name|spa_failmode
operator|=
name|intval
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_AUTOEXPAND
case|:
name|spa
operator|->
name|spa_autoexpand
operator|=
name|intval
expr_stmt|;
if|if
condition|(
name|tx
operator|->
name|tx_txg
operator|!=
name|TXG_INITIAL
condition|)
name|spa_async_request
argument_list|(
name|spa
argument_list|,
name|SPA_ASYNC_AUTOEXPAND
argument_list|)
expr_stmt|;
break|break;
case|case
name|ZPOOL_PROP_DEDUPDITTO
case|:
name|spa
operator|->
name|spa_dedup_ditto
operator|=
name|intval
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_props_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform one-time upgrade on-disk changes.  spa_version() does not  * reflect the new version this txg, so there must be no changes this  * txg to anything that the upgrade code depends on after it executes.  * Therefore this must be called after dsl_pool_sync() does the sync  * tasks.  */
end_comment

begin_function
specifier|static
name|void
name|spa_sync_upgrades
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa
operator|->
name|spa_dsl_pool
decl_stmt|;
name|ASSERT
argument_list|(
name|spa
operator|->
name|spa_sync_pass
operator|==
literal|1
argument_list|)
expr_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_ORIGIN
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_ORIGIN
condition|)
block|{
name|dsl_pool_create_origin
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Keeping the origin open increases spa_minref */
name|spa
operator|->
name|spa_minref
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_NEXT_CLONES
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_NEXT_CLONES
condition|)
block|{
name|dsl_pool_upgrade_clones
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_DIR_CLONES
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_DIR_CLONES
condition|)
block|{
name|dsl_pool_upgrade_dir_clones
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* Keeping the freedir open increases spa_minref */
name|spa
operator|->
name|spa_minref
operator|+=
literal|3
expr_stmt|;
block|}
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_FEATURES
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|spa_feature_create_zap_objects
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * LZ4_COMPRESS feature's behaviour was changed to activate_on_enable 	 * when possibility to use lz4 compression for metadata was added 	 * Old pools that have this feature enabled must be upgraded to have 	 * this feature active 	 */
if|if
condition|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_FEATURES
condition|)
block|{
name|boolean_t
name|lz4_en
init|=
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_LZ4_COMPRESS
argument_list|)
decl_stmt|;
name|boolean_t
name|lz4_ac
init|=
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_LZ4_COMPRESS
argument_list|)
decl_stmt|;
if|if
condition|(
name|lz4_en
operator|&&
operator|!
name|lz4_ac
condition|)
name|spa_feature_incr
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_LZ4_COMPRESS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we haven't written the salt, do so now.  Note that the 	 * feature may not be activated yet, but that's fine since 	 * the presence of this ZAP entry is backwards compatible. 	 */
if|if
condition|(
name|zap_contains
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CHECKSUM_SALT
argument_list|)
operator|==
name|ENOENT
condition|)
block|{
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_CHECKSUM_SALT
argument_list|,
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|)
argument_list|,
name|spa
operator|->
name|spa_cksum_salt
operator|.
name|zcs_bytes
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|rrw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sync the specified transaction group.  New blocks may be dirtied as  * part of the process, so we iterate until it converges.  */
end_comment

begin_function
name|void
name|spa_sync
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa
operator|->
name|spa_dsl_pool
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa
operator|->
name|spa_meta_objset
decl_stmt|;
name|bplist_t
modifier|*
name|free_bpl
init|=
operator|&
name|spa
operator|->
name|spa_free_bplist
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|vdev_t
modifier|*
name|rvd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint32_t
name|max_queue_depth
init|=
name|zfs_vdev_async_write_max_active
operator|*
name|zfs_vdev_queue_depth_pct
operator|/
literal|100
decl_stmt|;
name|VERIFY
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Lock out configuration changes. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_syncing_txg
operator|=
name|txg
expr_stmt|;
name|spa
operator|->
name|spa_sync_pass
operator|=
literal|0
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_lock
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_tree
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If there are any pending vdev state changes, convert them 	 * into config changes that go out with this transaction group. 	 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
while|while
condition|(
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We need the write lock here because, for aux vdevs, 		 * calling vdev_config_dirty() modifies sav_config. 		 * This is ugly and will become unnecessary when we 		 * eliminate the aux vdev wart by integrating all vdevs 		 * into the root vdev tree. 		 */
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_state_dirty_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|vdev_state_clean
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
operator||
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_starttime
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|VERIFY
argument_list|(
name|cyclic_reprogram
argument_list|(
name|spa
operator|->
name|spa_deadman_cycid
argument_list|,
name|spa
operator|->
name|spa_sync_starttime
operator|+
name|spa
operator|->
name|spa_deadman_synctime
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If we are upgrading to SPA_VERSION_RAIDZ_DEFLATE this txg, 	 * set spa_deflate if we have no raid-z vdevs. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_ubsync
operator|.
name|ub_version
operator|<
name|SPA_VERSION_RAIDZ_DEFLATE
operator|&&
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|>=
name|SPA_VERSION_RAIDZ_DEFLATE
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_deflate_ratio
operator|!=
name|SPA_MINBLOCKSIZE
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|==
name|rvd
operator|->
name|vdev_children
condition|)
block|{
name|spa
operator|->
name|spa_deflate
operator|=
name|TRUE
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_DEFLATE
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|spa
operator|->
name|spa_deflate
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * Set the top-level vdev's max queue depth. Evaluate each 	 * top-level's async write queue depth in case it changed. 	 * The max queue depth will not change in the middle of syncing 	 * out this txg. 	 */
name|uint64_t
name|queue_depth_total
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rvd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|rvd
operator|->
name|vdev_child
index|[
name|c
index|]
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
init|=
name|tvd
operator|->
name|vdev_mg
decl_stmt|;
if|if
condition|(
name|mg
operator|==
name|NULL
operator|||
name|mg
operator|->
name|mg_class
operator|!=
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
operator|||
operator|!
name|metaslab_group_initialized
argument_list|(
name|mg
argument_list|)
condition|)
continue|continue;
comment|/* 		 * It is safe to do a lock-free check here because only async 		 * allocations look at mg_max_alloc_queue_depth, and async 		 * allocations all happen from spa_sync(). 		 */
name|ASSERT0
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|mg
operator|->
name|mg_alloc_queue_depth
argument_list|)
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_max_alloc_queue_depth
operator|=
name|max_queue_depth
expr_stmt|;
name|queue_depth_total
operator|+=
name|mg
operator|->
name|mg_max_alloc_queue_depth
expr_stmt|;
block|}
name|metaslab_class_t
modifier|*
name|mc
init|=
name|spa_normal_class
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|ASSERT0
argument_list|(
name|refcount_count
argument_list|(
operator|&
name|mc
operator|->
name|mc_alloc_slots
argument_list|)
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_alloc_max_slots
operator|=
name|queue_depth_total
expr_stmt|;
name|mc
operator|->
name|mc_alloc_throttle_enabled
operator|=
name|zio_dva_throttle_enabled
expr_stmt|;
name|ASSERT3U
argument_list|(
name|mc
operator|->
name|mc_alloc_max_slots
argument_list|,
operator|<=
argument_list|,
name|max_queue_depth
operator|*
name|rvd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate to convergence. 	 */
do|do
block|{
name|int
name|pass
init|=
operator|++
name|spa
operator|->
name|spa_sync_pass
decl_stmt|;
name|spa_sync_config_object
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|spa_sync_aux_dev
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_spares
argument_list|,
name|tx
argument_list|,
name|ZPOOL_CONFIG_SPARES
argument_list|,
name|DMU_POOL_SPARES
argument_list|)
expr_stmt|;
name|spa_sync_aux_dev
argument_list|(
name|spa
argument_list|,
operator|&
name|spa
operator|->
name|spa_l2cache
argument_list|,
name|tx
argument_list|,
name|ZPOOL_CONFIG_L2CACHE
argument_list|,
name|DMU_POOL_L2CACHE
argument_list|)
expr_stmt|;
name|spa_errlog_sync
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dsl_pool_sync
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|<
name|zfs_sync_pass_deferred_free
condition|)
block|{
name|spa_sync_frees
argument_list|(
name|spa
argument_list|,
name|free_bpl
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * We can not defer frees in pass 1, because 			 * we sync the deferred frees later in pass 1. 			 */
name|ASSERT3U
argument_list|(
name|pass
argument_list|,
operator|>
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|bplist_iterate
argument_list|(
name|free_bpl
argument_list|,
name|bpobj_enqueue_cb
argument_list|,
operator|&
name|spa
operator|->
name|spa_deferred_bpobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|ddt_sync
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dsl_scan_sync
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
while|while
condition|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|txg
argument_list|)
condition|)
name|vdev_sync
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|pass
operator|==
literal|1
condition|)
block|{
name|spa_sync_upgrades
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|txg
argument_list|,
operator|>=
argument_list|,
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_rootbp
operator|.
name|blk_birth
argument_list|)
expr_stmt|;
comment|/* 			 * Note: We need to check if the MOS is dirty 			 * because we could have marked the MOS dirty 			 * without updating the uberblock (e.g. if we 			 * have sync tasks but no dirty user data).  We 			 * need to check the uberblock's rootbp because 			 * it is updated if we have synced out dirty 			 * data (though in this case the MOS will most 			 * likely also be dirty due to second order 			 * effects, we don't want to rely on that here). 			 */
if|if
condition|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_rootbp
operator|.
name|blk_birth
operator|<
name|txg
operator|&&
operator|!
name|dmu_objset_is_dirty
argument_list|(
name|mos
argument_list|,
name|txg
argument_list|)
condition|)
block|{
comment|/* 				 * Nothing changed on the first pass, 				 * therefore this TXG is a no-op.  Avoid 				 * syncing deferred frees, so that we 				 * can keep this TXG as a no-op. 				 */
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|spa_sync_deferred_frees
argument_list|(
name|spa
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|dmu_objset_is_dirty
argument_list|(
name|mos
argument_list|,
name|txg
argument_list|)
condition|)
do|;
if|if
condition|(
operator|!
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
condition|)
block|{
comment|/* 		 * Make sure that the number of ZAPs for all the vdevs matches 		 * the number of ZAPs in the per-vdev ZAP list. This only gets 		 * called if the config is dirty; otherwise there may be 		 * outstanding AVZ operations that weren't completed in 		 * spa_sync_config_object. 		 */
name|uint64_t
name|all_vdev_zap_entry_count
decl_stmt|;
name|ASSERT0
argument_list|(
name|zap_count
argument_list|(
name|spa
operator|->
name|spa_meta_objset
argument_list|,
name|spa
operator|->
name|spa_all_vdev_zaps
argument_list|,
operator|&
name|all_vdev_zap_entry_count
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|vdev_count_verify_zaps
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
argument_list|,
operator|==
argument_list|,
name|all_vdev_zap_entry_count
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Rewrite the vdev configuration (which includes the uberblock) 	 * to commit the transaction group. 	 * 	 * If there are no dirty vdevs, we sync the uberblock to a few 	 * random top-level vdevs that are known to be visible in the 	 * config cache (see spa_vdev_add() for a complete description). 	 * If there *are* dirty vdevs, sync the uberblock to all vdevs. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 		 * We hold SCL_STATE to prevent vdev open/close/etc. 		 * while we're attempting to write the vdev labels. 		 */
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|list_is_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
condition|)
block|{
name|vdev_t
modifier|*
name|svd
index|[
name|SPA_DVAS_PER_BP
index|]
decl_stmt|;
name|int
name|svdcount
init|=
literal|0
decl_stmt|;
name|int
name|children
init|=
name|rvd
operator|->
name|vdev_children
decl_stmt|;
name|int
name|c0
init|=
name|spa_get_random
argument_list|(
name|children
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|children
condition|;
name|c
operator|++
control|)
block|{
name|vd
operator|=
name|rvd
operator|->
name|vdev_child
index|[
operator|(
name|c0
operator|+
name|c
operator|)
operator|%
name|children
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ms_array
operator|==
literal|0
operator|||
name|vd
operator|->
name|vdev_islog
condition|)
continue|continue;
name|svd
index|[
name|svdcount
operator|++
index|]
operator|=
name|vd
expr_stmt|;
if|if
condition|(
name|svdcount
operator|==
name|SPA_DVAS_PER_BP
condition|)
break|break;
block|}
name|error
operator|=
name|vdev_config_sync
argument_list|(
name|svd
argument_list|,
name|svdcount
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|vdev_config_sync
argument_list|(
name|rvd
operator|->
name|vdev_child
argument_list|,
name|rvd
operator|->
name|vdev_children
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|spa
operator|->
name|spa_last_synced_guid
operator|=
name|rvd
operator|->
name|vdev_guid
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
break|break;
name|zio_suspend
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio_resume_wait
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|cyclic_reprogram
argument_list|(
name|spa
operator|->
name|spa_deadman_cycid
argument_list|,
name|CY_INFINITY
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Clear the dirty config list. 	 */
while|while
condition|(
operator|(
name|vd
operator|=
name|list_head
argument_list|(
operator|&
name|spa
operator|->
name|spa_config_dirty_list
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|vdev_config_clean
argument_list|(
name|vd
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the new config has synced transactionally, 	 * let it become visible to the config cache. 	 */
if|if
condition|(
name|spa
operator|->
name|spa_config_syncing
operator|!=
name|NULL
condition|)
block|{
name|spa_config_set
argument_list|(
name|spa
argument_list|,
name|spa
operator|->
name|spa_config_syncing
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_config_txg
operator|=
name|txg
expr_stmt|;
name|spa
operator|->
name|spa_config_syncing
operator|=
name|NULL
expr_stmt|;
block|}
name|dsl_pool_sync_done
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_lock
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_tree
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_alloc_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Update usable space statistics. 	 */
while|while
condition|(
name|vd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
argument_list|)
condition|)
name|vdev_sync_done
argument_list|(
name|vd
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|spa_update_dspace
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * It had better be the case that we didn't dirty anything 	 * since vdev_config_sync(). 	 */
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|txg_list_empty
argument_list|(
operator|&
name|spa
operator|->
name|spa_vdev_txg_list
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_sync_pass
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Update the last synced uberblock here. We want to do this at 	 * the end of spa_sync() so that consumers of spa_last_synced_txg() 	 * will be guaranteed that all the processing associated with 	 * that txg has been completed. 	 */
name|spa
operator|->
name|spa_ubsync
operator|=
name|spa
operator|->
name|spa_uberblock
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_CONFIG
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|spa_handle_ignored_writes
argument_list|(
name|spa
argument_list|)
expr_stmt|;
comment|/* 	 * If any async tasks have been requested, kick them off. 	 */
name|spa_async_dispatch
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Sync all pools.  We don't want to hold the namespace lock across these  * operations, so we take a reference on the spa_t and drop the lock during the  * sync.  */
end_comment

begin_function
name|void
name|spa_sync_allpools
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|spa
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|spa_state
argument_list|(
name|spa
argument_list|)
operator|!=
name|POOL_STATE_ACTIVE
operator|||
operator|!
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|||
name|spa_suspended
argument_list|(
name|spa
argument_list|)
condition|)
continue|continue;
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Miscellaneous routines  * ==========================================================================  */
end_comment

begin_comment
comment|/*  * Remove all pools in the system.  */
end_comment

begin_function
name|void
name|spa_evict_all
parameter_list|(
name|void
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
comment|/* 	 * Remove all cached state.  All pools should be closed now, 	 * so every spa in the AVL tree should be unreferenced. 	 */
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|spa
operator|=
name|spa_next
argument_list|(
name|NULL
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Stop async tasks.  The async thread may need to detach 		 * a device that's been replaced, which requires grabbing 		 * spa_namespace_lock, so we must drop it here. 		 */
name|spa_open_ref
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_async_suspend
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|spa
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_state
operator|!=
name|POOL_STATE_UNINITIALIZED
condition|)
block|{
name|spa_unload
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|spa_deactivate
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|spa_remove
argument_list|(
name|spa
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa_namespace_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vdev_t
modifier|*
name|spa_lookup_by_guid
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|,
name|boolean_t
name|aux
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_by_guid
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|,
name|guid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
return|return
operator|(
name|vd
operator|)
return|;
if|if
condition|(
name|aux
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_l2cache
operator|.
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|vd
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|spa
operator|->
name|spa_spares
operator|.
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
name|vd
operator|=
name|spa
operator|->
name|spa_spares
operator|.
name|sav_vdevs
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|vd
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|void
name|spa_upgrade
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|version
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 	 * This should only be called for a non-faulted pool, and since a 	 * future version would result in an unopenable pool, this shouldn't be 	 * possible. 	 */
name|ASSERT
argument_list|(
name|SPA_VERSION_IS_SUPPORTED
argument_list|(
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|version
argument_list|,
operator|>=
argument_list|,
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_uberblock
operator|.
name|ub_version
operator|=
name|version
expr_stmt|;
name|vdev_config_dirty
argument_list|(
name|spa
operator|->
name|spa_root_vdev
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALL
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|txg_wait_synced
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|spa_has_spare
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|guid
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint64_t
name|spareguid
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_spares
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
operator|->
name|vdev_guid
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_npending
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|sav
operator|->
name|sav_pending
index|[
name|i
index|]
argument_list|,
name|ZPOOL_CONFIG_GUID
argument_list|,
operator|&
name|spareguid
argument_list|)
operator|==
literal|0
operator|&&
name|spareguid
operator|==
name|guid
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if a pool has an active shared spare device.  * Note: reference count of an active spare is 2, as a spare and as a replace  */
end_comment

begin_function
specifier|static
name|boolean_t
name|spa_has_active_shared_spare
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|refcnt
decl_stmt|;
name|uint64_t
name|pool
decl_stmt|;
name|spa_aux_vdev_t
modifier|*
name|sav
init|=
operator|&
name|spa
operator|->
name|spa_spares
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|sav
operator|->
name|sav_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|spa_spare_exists
argument_list|(
name|sav
operator|->
name|sav_vdevs
index|[
name|i
index|]
operator|->
name|vdev_guid
argument_list|,
operator|&
name|pool
argument_list|,
operator|&
name|refcnt
argument_list|)
operator|&&
name|pool
operator|!=
literal|0ULL
operator|&&
name|pool
operator|==
name|spa_guid
argument_list|(
name|spa
argument_list|)
operator|&&
name|refcnt
operator|>
literal|2
condition|)
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
return|return
operator|(
name|B_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|sysevent_t
modifier|*
name|spa_event_create
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|sysevent_t
modifier|*
name|ev
init|=
name|NULL
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|sysevent_attr_list_t
modifier|*
name|attr
init|=
name|NULL
decl_stmt|;
name|sysevent_value_t
name|value
decl_stmt|;
name|ev
operator|=
name|sysevent_alloc
argument_list|(
name|EC_ZFS
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
name|SUNW_KERN_PUB
literal|"zfs"
argument_list|,
name|SE_SLEEP
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ev
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|value
operator|.
name|value_type
operator|=
name|SE_DATA_TYPE_STRING
expr_stmt|;
name|value
operator|.
name|value
operator|.
name|sv_string
operator|=
name|spa_name
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysevent_add_attr
argument_list|(
operator|&
name|attr
argument_list|,
name|ZFS_EV_POOL_NAME
argument_list|,
operator|&
name|value
argument_list|,
name|SE_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|value
operator|.
name|value_type
operator|=
name|SE_DATA_TYPE_UINT64
expr_stmt|;
name|value
operator|.
name|value
operator|.
name|sv_uint64
operator|=
name|spa_guid
argument_list|(
name|spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysevent_add_attr
argument_list|(
operator|&
name|attr
argument_list|,
name|ZFS_EV_POOL_GUID
argument_list|,
operator|&
name|value
argument_list|,
name|SE_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|vd
condition|)
block|{
name|value
operator|.
name|value_type
operator|=
name|SE_DATA_TYPE_UINT64
expr_stmt|;
name|value
operator|.
name|value
operator|.
name|sv_uint64
operator|=
name|vd
operator|->
name|vdev_guid
expr_stmt|;
if|if
condition|(
name|sysevent_add_attr
argument_list|(
operator|&
name|attr
argument_list|,
name|ZFS_EV_VDEV_GUID
argument_list|,
operator|&
name|value
argument_list|,
name|SE_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|vd
operator|->
name|vdev_path
condition|)
block|{
name|value
operator|.
name|value_type
operator|=
name|SE_DATA_TYPE_STRING
expr_stmt|;
name|value
operator|.
name|value
operator|.
name|sv_string
operator|=
name|vd
operator|->
name|vdev_path
expr_stmt|;
if|if
condition|(
name|sysevent_add_attr
argument_list|(
operator|&
name|attr
argument_list|,
name|ZFS_EV_VDEV_PATH
argument_list|,
operator|&
name|value
argument_list|,
name|SE_SLEEP
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
block|}
block|}
if|if
condition|(
name|sysevent_attach_attributes
argument_list|(
name|ev
argument_list|,
name|attr
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
name|attr
operator|=
name|NULL
expr_stmt|;
name|done
label|:
if|if
condition|(
name|attr
condition|)
name|sysevent_free_attr
argument_list|(
name|attr
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|ev
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|spa_event_post
parameter_list|(
name|sysevent_t
modifier|*
name|ev
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|_KERNEL
name|sysevent_id_t
name|eid
decl_stmt|;
operator|(
name|void
operator|)
name|log_sysevent
argument_list|(
name|ev
argument_list|,
name|SE_SLEEP
argument_list|,
operator|&
name|eid
argument_list|)
expr_stmt|;
name|sysevent_free
argument_list|(
name|ev
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/*  * Post a sysevent corresponding to the given event.  The 'name' must be one of  * the event definitions in sys/sysevent/eventdefs.h.  The payload will be  * filled in from the spa and (optionally) the vdev.  This doesn't do anything  * in the userland libzpool, as we don't want consumers to misinterpret ztest  * or zdb as real changes.  */
end_comment

begin_function
name|void
name|spa_event_notify
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|spa_event_post
argument_list|(
name|spa_event_create
argument_list|(
name|spa
argument_list|,
name|vd
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

