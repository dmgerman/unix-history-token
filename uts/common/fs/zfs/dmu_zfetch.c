begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_zfetch.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kstat.h>
end_include

begin_comment
comment|/*  * I'm against tune-ables, but these should probably exist as tweakable globals  * until we can get this working the way we want it to.  */
end_comment

begin_decl_stmt
name|int
name|zfs_prefetch_disable
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max # of streams per zfetch */
end_comment

begin_decl_stmt
name|uint32_t
name|zfetch_max_streams
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min time before stream reclaim */
end_comment

begin_decl_stmt
name|uint32_t
name|zfetch_min_sec_reap
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max number of blocks to fetch at a time */
end_comment

begin_decl_stmt
name|uint32_t
name|zfetch_block_cap
init|=
literal|256
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of bytes in a array_read at which we stop prefetching (1Mb) */
end_comment

begin_decl_stmt
name|uint64_t
name|zfetch_array_rd_sz
init|=
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* forward decls for static routines */
end_comment

begin_function_decl
specifier|static
name|int
name|dmu_zfetch_colinear
parameter_list|(
name|zfetch_t
modifier|*
parameter_list|,
name|zstream_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dmu_zfetch_dofetch
parameter_list|(
name|zfetch_t
modifier|*
parameter_list|,
name|zstream_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|dmu_zfetch_fetch
parameter_list|(
name|dnode_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|uint64_t
name|dmu_zfetch_fetchsz
parameter_list|(
name|dnode_t
modifier|*
parameter_list|,
name|uint64_t
parameter_list|,
name|uint64_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dmu_zfetch_find
parameter_list|(
name|zfetch_t
modifier|*
parameter_list|,
name|zstream_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dmu_zfetch_stream_insert
parameter_list|(
name|zfetch_t
modifier|*
parameter_list|,
name|zstream_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|zstream_t
modifier|*
name|dmu_zfetch_stream_reclaim
parameter_list|(
name|zfetch_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|dmu_zfetch_stream_remove
parameter_list|(
name|zfetch_t
modifier|*
parameter_list|,
name|zstream_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|dmu_zfetch_streams_equal
parameter_list|(
name|zstream_t
modifier|*
parameter_list|,
name|zstream_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
struct|struct
name|zfetch_stats
block|{
name|kstat_named_t
name|zfetchstat_hits
decl_stmt|;
name|kstat_named_t
name|zfetchstat_misses
decl_stmt|;
name|kstat_named_t
name|zfetchstat_colinear_hits
decl_stmt|;
name|kstat_named_t
name|zfetchstat_colinear_misses
decl_stmt|;
name|kstat_named_t
name|zfetchstat_stride_hits
decl_stmt|;
name|kstat_named_t
name|zfetchstat_stride_misses
decl_stmt|;
name|kstat_named_t
name|zfetchstat_reclaim_successes
decl_stmt|;
name|kstat_named_t
name|zfetchstat_reclaim_failures
decl_stmt|;
name|kstat_named_t
name|zfetchstat_stream_resets
decl_stmt|;
name|kstat_named_t
name|zfetchstat_stream_noresets
decl_stmt|;
name|kstat_named_t
name|zfetchstat_bogus_streams
decl_stmt|;
block|}
name|zfetch_stats_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|zfetch_stats_t
name|zfetch_stats
init|=
block|{
block|{
literal|"hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"colinear_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"colinear_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"stride_hits"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"stride_misses"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"reclaim_successes"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"reclaim_failures"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"streams_resets"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"streams_noresets"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"bogus_streams"
block|,
name|KSTAT_DATA_UINT64
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZFETCHSTAT_INCR
parameter_list|(
name|stat
parameter_list|,
name|val
parameter_list|)
define|\
value|atomic_add_64(&zfetch_stats.stat.value.ui64, (val));
end_define

begin_define
define|#
directive|define
name|ZFETCHSTAT_BUMP
parameter_list|(
name|stat
parameter_list|)
value|ZFETCHSTAT_INCR(stat, 1);
end_define

begin_decl_stmt
name|kstat_t
modifier|*
name|zfetch_ksp
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Given a zfetch structure and a zstream structure, determine whether the  * blocks to be read are part of a co-linear pair of existing prefetch  * streams.  If a set is found, coalesce the streams, removing one, and  * configure the prefetch so it looks for a strided access pattern.  *  * In other words: if we find two sequential access streams that are  * the same length and distance N appart, and this read is N from the  * last stream, then we are probably in a strided access pattern.  So  * combine the two sequential streams into a single strided stream.  *  * If no co-linear streams are found, return NULL.  */
end_comment

begin_function
specifier|static
name|int
name|dmu_zfetch_colinear
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|zstream_t
modifier|*
name|zh
parameter_list|)
block|{
name|zstream_t
modifier|*
name|z_walk
decl_stmt|;
name|zstream_t
modifier|*
name|z_comp
decl_stmt|;
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zh
operator|==
name|NULL
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|z_walk
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|z_walk
condition|;
name|z_walk
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|z_walk
argument_list|)
control|)
block|{
for|for
control|(
name|z_comp
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|z_walk
argument_list|)
init|;
name|z_comp
condition|;
name|z_comp
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|z_comp
argument_list|)
control|)
block|{
name|int64_t
name|diff
decl_stmt|;
if|if
condition|(
name|z_walk
operator|->
name|zst_len
operator|!=
name|z_walk
operator|->
name|zst_stride
operator|||
name|z_comp
operator|->
name|zst_len
operator|!=
name|z_comp
operator|->
name|zst_stride
condition|)
block|{
continue|continue;
block|}
name|diff
operator|=
name|z_comp
operator|->
name|zst_offset
operator|-
name|z_walk
operator|->
name|zst_offset
expr_stmt|;
if|if
condition|(
name|z_comp
operator|->
name|zst_offset
operator|+
name|diff
operator|==
name|zh
operator|->
name|zst_offset
condition|)
block|{
name|z_walk
operator|->
name|zst_offset
operator|=
name|zh
operator|->
name|zst_offset
expr_stmt|;
name|z_walk
operator|->
name|zst_direction
operator|=
name|diff
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|z_walk
operator|->
name|zst_stride
operator|=
name|diff
operator|*
name|z_walk
operator|->
name|zst_direction
expr_stmt|;
name|z_walk
operator|->
name|zst_ph_offset
operator|=
name|zh
operator|->
name|zst_offset
operator|+
name|z_walk
operator|->
name|zst_stride
expr_stmt|;
name|dmu_zfetch_stream_remove
argument_list|(
name|zf
argument_list|,
name|z_comp
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|z_comp
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|z_comp
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_zfetch_dofetch
argument_list|(
name|zf
argument_list|,
name|z_walk
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|diff
operator|=
name|z_walk
operator|->
name|zst_offset
operator|-
name|z_comp
operator|->
name|zst_offset
expr_stmt|;
if|if
condition|(
name|z_walk
operator|->
name|zst_offset
operator|+
name|diff
operator|==
name|zh
operator|->
name|zst_offset
condition|)
block|{
name|z_walk
operator|->
name|zst_offset
operator|=
name|zh
operator|->
name|zst_offset
expr_stmt|;
name|z_walk
operator|->
name|zst_direction
operator|=
name|diff
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
name|z_walk
operator|->
name|zst_stride
operator|=
name|diff
operator|*
name|z_walk
operator|->
name|zst_direction
expr_stmt|;
name|z_walk
operator|->
name|zst_ph_offset
operator|=
name|zh
operator|->
name|zst_offset
operator|+
name|z_walk
operator|->
name|zst_stride
expr_stmt|;
name|dmu_zfetch_stream_remove
argument_list|(
name|zf
argument_list|,
name|z_comp
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|z_comp
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|z_comp
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_zfetch_dofetch
argument_list|(
name|zf
argument_list|,
name|z_walk
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
block|}
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a zstream_t, determine the bounds of the prefetch.  Then call the  * routine that actually prefetches the individual blocks.  */
end_comment

begin_function
specifier|static
name|void
name|dmu_zfetch_dofetch
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|zstream_t
modifier|*
name|zs
parameter_list|)
block|{
name|uint64_t
name|prefetch_tail
decl_stmt|;
name|uint64_t
name|prefetch_limit
decl_stmt|;
name|uint64_t
name|prefetch_ofst
decl_stmt|;
name|uint64_t
name|prefetch_len
decl_stmt|;
name|uint64_t
name|blocks_fetched
decl_stmt|;
name|zs
operator|->
name|zst_stride
operator|=
name|MAX
argument_list|(
operator|(
name|int64_t
operator|)
name|zs
operator|->
name|zst_stride
argument_list|,
name|zs
operator|->
name|zst_len
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zst_cap
operator|=
name|MIN
argument_list|(
name|zfetch_block_cap
argument_list|,
literal|2
operator|*
name|zs
operator|->
name|zst_cap
argument_list|)
expr_stmt|;
name|prefetch_tail
operator|=
name|MAX
argument_list|(
operator|(
name|int64_t
operator|)
name|zs
operator|->
name|zst_ph_offset
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_stride
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * XXX: use a faster division method? 	 */
name|prefetch_limit
operator|=
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_len
operator|+
operator|(
name|zs
operator|->
name|zst_cap
operator|*
name|zs
operator|->
name|zst_stride
operator|)
operator|/
name|zs
operator|->
name|zst_len
expr_stmt|;
while|while
condition|(
name|prefetch_tail
operator|<
name|prefetch_limit
condition|)
block|{
name|prefetch_ofst
operator|=
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_direction
operator|*
operator|(
name|prefetch_tail
operator|-
name|zs
operator|->
name|zst_offset
operator|)
expr_stmt|;
name|prefetch_len
operator|=
name|zs
operator|->
name|zst_len
expr_stmt|;
comment|/* 		 * Don't prefetch beyond the end of the file, if working 		 * backwards. 		 */
if|if
condition|(
operator|(
name|zs
operator|->
name|zst_direction
operator|==
name|ZFETCH_BACKWARD
operator|)
operator|&&
operator|(
name|prefetch_ofst
operator|>
name|prefetch_tail
operator|)
condition|)
block|{
name|prefetch_len
operator|+=
name|prefetch_ofst
expr_stmt|;
name|prefetch_ofst
operator|=
literal|0
expr_stmt|;
block|}
comment|/* don't prefetch more than we're supposed to */
if|if
condition|(
name|prefetch_len
operator|>
name|zs
operator|->
name|zst_len
condition|)
break|break;
name|blocks_fetched
operator|=
name|dmu_zfetch_fetch
argument_list|(
name|zf
operator|->
name|zf_dnode
argument_list|,
name|prefetch_ofst
argument_list|,
name|zs
operator|->
name|zst_len
argument_list|)
expr_stmt|;
name|prefetch_tail
operator|+=
name|zs
operator|->
name|zst_stride
expr_stmt|;
comment|/* stop if we've run out of stuff to prefetch */
if|if
condition|(
name|blocks_fetched
operator|<
name|zs
operator|->
name|zst_len
condition|)
break|break;
block|}
name|zs
operator|->
name|zst_ph_offset
operator|=
name|prefetch_tail
expr_stmt|;
name|zs
operator|->
name|zst_last
operator|=
name|ddi_get_lbolt
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfetch_init
parameter_list|(
name|void
parameter_list|)
block|{
name|zfetch_ksp
operator|=
name|kstat_create
argument_list|(
literal|"zfs"
argument_list|,
literal|0
argument_list|,
literal|"zfetchstats"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|zfetch_stats
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfetch_ksp
operator|!=
name|NULL
condition|)
block|{
name|zfetch_ksp
operator|->
name|ks_data
operator|=
operator|&
name|zfetch_stats
expr_stmt|;
name|kstat_install
argument_list|(
name|zfetch_ksp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|zfetch_fini
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|zfetch_ksp
operator|!=
name|NULL
condition|)
block|{
name|kstat_delete
argument_list|(
name|zfetch_ksp
argument_list|)
expr_stmt|;
name|zfetch_ksp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This takes a pointer to a zfetch structure and a dnode.  It performs the  * necessary setup for the zfetch structure, grokking data from the  * associated dnode.  */
end_comment

begin_function
name|void
name|dmu_zfetch_init
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|dnode_t
modifier|*
name|dno
parameter_list|)
block|{
if|if
condition|(
name|zf
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|zf
operator|->
name|zf_dnode
operator|=
name|dno
expr_stmt|;
name|zf
operator|->
name|zf_stream_cnt
operator|=
literal|0
expr_stmt|;
name|zf
operator|->
name|zf_alloc_fail
operator|=
literal|0
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zstream_t
argument_list|,
name|zst_node
argument_list|)
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function computes the actual size, in blocks, that can be prefetched,  * and fetches it.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|dmu_zfetch_fetch
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|)
block|{
name|uint64_t
name|fetchsz
decl_stmt|;
name|uint64_t
name|i
decl_stmt|;
name|fetchsz
operator|=
name|dmu_zfetch_fetchsz
argument_list|(
name|dn
argument_list|,
name|blkid
argument_list|,
name|nblks
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fetchsz
condition|;
name|i
operator|++
control|)
block|{
name|dbuf_prefetch
argument_list|(
name|dn
argument_list|,
name|blkid
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fetchsz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * this function returns the number of blocks that would be prefetched, based  * upon the supplied dnode, blockid, and nblks.  This is used so that we can  * update streams in place, and then prefetch with their old value after the  * fact.  This way, we can delay the prefetch, but subsequent accesses to the  * stream won't result in the same data being prefetched multiple times.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|dmu_zfetch_fetchsz
parameter_list|(
name|dnode_t
modifier|*
name|dn
parameter_list|,
name|uint64_t
name|blkid
parameter_list|,
name|uint64_t
name|nblks
parameter_list|)
block|{
name|uint64_t
name|fetchsz
decl_stmt|;
if|if
condition|(
name|blkid
operator|>
name|dn
operator|->
name|dn_maxblkid
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* compute fetch size */
if|if
condition|(
name|blkid
operator|+
name|nblks
operator|+
literal|1
operator|>
name|dn
operator|->
name|dn_maxblkid
condition|)
block|{
name|fetchsz
operator|=
operator|(
name|dn
operator|->
name|dn_maxblkid
operator|-
name|blkid
operator|)
operator|+
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|blkid
operator|+
name|fetchsz
operator|-
literal|1
operator|<=
name|dn
operator|->
name|dn_maxblkid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fetchsz
operator|=
name|nblks
expr_stmt|;
block|}
return|return
operator|(
name|fetchsz
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * given a zfetch and a zstream structure, see if there is an associated zstream  * for this block read.  If so, it starts a prefetch for the stream it  * located and returns true, otherwise it returns false  */
end_comment

begin_function
specifier|static
name|int
name|dmu_zfetch_find
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|zstream_t
modifier|*
name|zh
parameter_list|,
name|int
name|prefetched
parameter_list|)
block|{
name|zstream_t
modifier|*
name|zs
decl_stmt|;
name|int64_t
name|diff
decl_stmt|;
name|int
name|reset
init|=
operator|!
name|prefetched
decl_stmt|;
name|int
name|rc
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|zh
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * XXX: This locking strategy is a bit coarse; however, it's impact has 	 * yet to be tested.  If this turns out to be an issue, it can be 	 * modified in a number of different ways. 	 */
name|rw_enter
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|top
label|:
for|for
control|(
name|zs
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|zs
condition|;
name|zs
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
control|)
block|{
comment|/* 		 * XXX - should this be an assert? 		 */
if|if
condition|(
name|zs
operator|->
name|zst_len
operator|==
literal|0
condition|)
block|{
comment|/* bogus stream */
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_bogus_streams
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 		 * We hit this case when we are in a strided prefetch stream: 		 * we will read "len" blocks before "striding". 		 */
if|if
condition|(
name|zh
operator|->
name|zst_offset
operator|>=
name|zs
operator|->
name|zst_offset
operator|&&
name|zh
operator|->
name|zst_offset
operator|<
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_len
condition|)
block|{
if|if
condition|(
name|prefetched
condition|)
block|{
comment|/* already fetched */
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_stride_hits
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_stride_misses
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 		 * This is the forward sequential read case: we increment 		 * len by one each time we hit here, so we will enter this 		 * case on every read. 		 */
if|if
condition|(
name|zh
operator|->
name|zst_offset
operator|==
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_len
condition|)
block|{
name|reset
operator|=
operator|!
name|prefetched
operator|&&
name|zs
operator|->
name|zst_len
operator|>
literal|1
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zst_offset
operator|!=
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_len
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|zs
operator|->
name|zst_len
operator|+=
name|zh
operator|->
name|zst_len
expr_stmt|;
name|diff
operator|=
name|zs
operator|->
name|zst_len
operator|-
name|zfetch_block_cap
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|zs
operator|->
name|zst_offset
operator|+=
name|diff
expr_stmt|;
name|zs
operator|->
name|zst_len
operator|=
name|zs
operator|->
name|zst_len
operator|>
name|diff
condition|?
name|zs
operator|->
name|zst_len
operator|-
name|diff
else|:
literal|0
expr_stmt|;
block|}
name|zs
operator|->
name|zst_direction
operator|=
name|ZFETCH_FORWARD
expr_stmt|;
break|break;
comment|/* 		 * Same as above, but reading backwards through the file. 		 */
block|}
elseif|else
if|if
condition|(
name|zh
operator|->
name|zst_offset
operator|==
name|zs
operator|->
name|zst_offset
operator|-
name|zh
operator|->
name|zst_len
condition|)
block|{
comment|/* backwards sequential access */
name|reset
operator|=
operator|!
name|prefetched
operator|&&
name|zs
operator|->
name|zst_len
operator|>
literal|1
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zh
operator|->
name|zst_offset
operator|!=
name|zs
operator|->
name|zst_offset
operator|-
name|zh
operator|->
name|zst_len
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|zs
operator|->
name|zst_offset
operator|=
name|zs
operator|->
name|zst_offset
operator|>
name|zh
operator|->
name|zst_len
condition|?
name|zs
operator|->
name|zst_offset
operator|-
name|zh
operator|->
name|zst_len
else|:
literal|0
expr_stmt|;
name|zs
operator|->
name|zst_ph_offset
operator|=
name|zs
operator|->
name|zst_ph_offset
operator|>
name|zh
operator|->
name|zst_len
condition|?
name|zs
operator|->
name|zst_ph_offset
operator|-
name|zh
operator|->
name|zst_len
else|:
literal|0
expr_stmt|;
name|zs
operator|->
name|zst_len
operator|+=
name|zh
operator|->
name|zst_len
expr_stmt|;
name|diff
operator|=
name|zs
operator|->
name|zst_len
operator|-
name|zfetch_block_cap
expr_stmt|;
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
name|zs
operator|->
name|zst_ph_offset
operator|=
name|zs
operator|->
name|zst_ph_offset
operator|>
name|diff
condition|?
name|zs
operator|->
name|zst_ph_offset
operator|-
name|diff
else|:
literal|0
expr_stmt|;
name|zs
operator|->
name|zst_len
operator|=
name|zs
operator|->
name|zst_len
operator|>
name|diff
condition|?
name|zs
operator|->
name|zst_len
operator|-
name|diff
else|:
name|zs
operator|->
name|zst_len
expr_stmt|;
block|}
name|zs
operator|->
name|zst_direction
operator|=
name|ZFETCH_BACKWARD
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|zh
operator|->
name|zst_offset
operator|-
name|zs
operator|->
name|zst_offset
operator|-
name|zs
operator|->
name|zst_stride
operator|<
name|zs
operator|->
name|zst_len
operator|)
operator|&&
operator|(
name|zs
operator|->
name|zst_len
operator|!=
name|zs
operator|->
name|zst_stride
operator|)
condition|)
block|{
comment|/* strided forward access */
name|mutex_enter
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zh
operator|->
name|zst_offset
operator|-
name|zs
operator|->
name|zst_offset
operator|-
name|zs
operator|->
name|zst_stride
operator|>=
name|zs
operator|->
name|zst_len
operator|)
operator|||
operator|(
name|zs
operator|->
name|zst_len
operator|==
name|zs
operator|->
name|zst_stride
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|zs
operator|->
name|zst_offset
operator|+=
name|zs
operator|->
name|zst_stride
expr_stmt|;
name|zs
operator|->
name|zst_direction
operator|=
name|ZFETCH_FORWARD
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
operator|(
name|zh
operator|->
name|zst_offset
operator|-
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_stride
operator|<
name|zs
operator|->
name|zst_len
operator|)
operator|&&
operator|(
name|zs
operator|->
name|zst_len
operator|!=
name|zs
operator|->
name|zst_stride
operator|)
condition|)
block|{
comment|/* strided reverse access */
name|mutex_enter
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zh
operator|->
name|zst_offset
operator|-
name|zs
operator|->
name|zst_offset
operator|+
name|zs
operator|->
name|zst_stride
operator|>=
name|zs
operator|->
name|zst_len
operator|)
operator|||
operator|(
name|zs
operator|->
name|zst_len
operator|==
name|zs
operator|->
name|zst_stride
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|zs
operator|->
name|zst_offset
operator|=
name|zs
operator|->
name|zst_offset
operator|>
name|zs
operator|->
name|zst_stride
condition|?
name|zs
operator|->
name|zst_offset
operator|-
name|zs
operator|->
name|zst_stride
else|:
literal|0
expr_stmt|;
name|zs
operator|->
name|zst_ph_offset
operator|=
operator|(
name|zs
operator|->
name|zst_ph_offset
operator|>
operator|(
literal|2
operator|*
name|zs
operator|->
name|zst_stride
operator|)
operator|)
condition|?
operator|(
name|zs
operator|->
name|zst_ph_offset
operator|-
operator|(
literal|2
operator|*
name|zs
operator|->
name|zst_stride
operator|)
operator|)
else|:
literal|0
expr_stmt|;
name|zs
operator|->
name|zst_direction
operator|=
name|ZFETCH_BACKWARD
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|zs
condition|)
block|{
if|if
condition|(
name|reset
condition|)
block|{
name|zstream_t
modifier|*
name|remove
init|=
name|zs
decl_stmt|;
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_stream_resets
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
comment|/* 			 * Relocate the stream, in case someone removes 			 * it while we were acquiring the WRITER lock. 			 */
for|for
control|(
name|zs
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|zs
condition|;
name|zs
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
control|)
block|{
if|if
condition|(
name|zs
operator|==
name|remove
condition|)
block|{
name|dmu_zfetch_stream_remove
argument_list|(
name|zf
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_stream_noresets
argument_list|)
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
name|dmu_zfetch_dofetch
argument_list|(
name|zf
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Clean-up state associated with a zfetch structure.  This frees allocated  * structure members, empties the zf_stream tree, and generally makes things  * nice.  This doesn't free the zfetch_t itself, that's left to the caller.  */
end_comment

begin_function
name|void
name|dmu_zfetch_rele
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|)
block|{
name|zstream_t
modifier|*
name|zs
decl_stmt|;
name|zstream_t
modifier|*
name|zs_next
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|RW_LOCK_HELD
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|zs
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|zs
condition|;
name|zs
operator|=
name|zs_next
control|)
block|{
name|zs_next
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|list_destroy
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
name|zf
operator|->
name|zf_dnode
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a zfetch and zstream structure, insert the zstream structure into the  * AVL tree contained within the zfetch structure.  Peform the appropriate  * book-keeping.  It is possible that another thread has inserted a stream which  * matches one that we are about to insert, so we must be sure to check for this  * case.  If one is found, return failure, and let the caller cleanup the  * duplicates.  */
end_comment

begin_function
specifier|static
name|int
name|dmu_zfetch_stream_insert
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|zstream_t
modifier|*
name|zs
parameter_list|)
block|{
name|zstream_t
modifier|*
name|zs_walk
decl_stmt|;
name|zstream_t
modifier|*
name|zs_next
decl_stmt|;
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|zs_walk
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|zs_walk
condition|;
name|zs_walk
operator|=
name|zs_next
control|)
block|{
name|zs_next
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs_walk
argument_list|)
expr_stmt|;
if|if
condition|(
name|dmu_zfetch_streams_equal
argument_list|(
name|zs_walk
argument_list|,
name|zs
argument_list|)
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|list_insert_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|zf
operator|->
name|zf_stream_cnt
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk the list of zstreams in the given zfetch, find an old one (by time), and  * reclaim it for use by the caller.  */
end_comment

begin_function
specifier|static
name|zstream_t
modifier|*
name|dmu_zfetch_stream_reclaim
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|)
block|{
name|zstream_t
modifier|*
name|zs
decl_stmt|;
if|if
condition|(
operator|!
name|rw_tryenter
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
for|for
control|(
name|zs
operator|=
name|list_head
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|)
init|;
name|zs
condition|;
name|zs
operator|=
name|list_next
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
control|)
block|{
if|if
condition|(
operator|(
operator|(
name|ddi_get_lbolt
argument_list|()
operator|-
name|zs
operator|->
name|zst_last
operator|)
operator|/
name|hz
operator|)
operator|>
name|zfetch_min_sec_reap
condition|)
break|break;
block|}
if|if
condition|(
name|zs
condition|)
block|{
name|dmu_zfetch_stream_remove
argument_list|(
name|zf
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zs
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|zs
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zf
operator|->
name|zf_alloc_fail
operator|++
expr_stmt|;
block|}
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|zs
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a zfetch and zstream structure, remove the zstream structure from its  * container in the zfetch structure.  Perform the appropriate book-keeping.  */
end_comment

begin_function
specifier|static
name|void
name|dmu_zfetch_stream_remove
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|zstream_t
modifier|*
name|zs
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|RW_WRITE_HELD
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
argument_list|)
expr_stmt|;
name|list_remove
argument_list|(
operator|&
name|zf
operator|->
name|zf_stream
argument_list|,
name|zs
argument_list|)
expr_stmt|;
name|zf
operator|->
name|zf_stream_cnt
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dmu_zfetch_streams_equal
parameter_list|(
name|zstream_t
modifier|*
name|zs1
parameter_list|,
name|zstream_t
modifier|*
name|zs2
parameter_list|)
block|{
if|if
condition|(
name|zs1
operator|->
name|zst_offset
operator|!=
name|zs2
operator|->
name|zst_offset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zs1
operator|->
name|zst_len
operator|!=
name|zs2
operator|->
name|zst_len
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zs1
operator|->
name|zst_stride
operator|!=
name|zs2
operator|->
name|zst_stride
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zs1
operator|->
name|zst_ph_offset
operator|!=
name|zs2
operator|->
name|zst_ph_offset
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zs1
operator|->
name|zst_cap
operator|!=
name|zs2
operator|->
name|zst_cap
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|zs1
operator|->
name|zst_direction
operator|!=
name|zs2
operator|->
name|zst_direction
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is the prefetch entry point.  It calls all of the other dmu_zfetch  * routines to create, delete, find, or operate upon prefetch streams.  */
end_comment

begin_function
name|void
name|dmu_zfetch
parameter_list|(
name|zfetch_t
modifier|*
name|zf
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|int
name|prefetched
parameter_list|)
block|{
name|zstream_t
name|zst
decl_stmt|;
name|zstream_t
modifier|*
name|newstream
decl_stmt|;
name|int
name|fetched
decl_stmt|;
name|int
name|inserted
decl_stmt|;
name|unsigned
name|int
name|blkshft
decl_stmt|;
name|uint64_t
name|blksz
decl_stmt|;
if|if
condition|(
name|zfs_prefetch_disable
condition|)
return|return;
comment|/* files that aren't ln2 blocksz are only one block -- nothing to do */
if|if
condition|(
operator|!
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_datablkshift
condition|)
return|return;
comment|/* convert offset and size, into blockid and nblocks */
name|blkshft
operator|=
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_datablkshift
expr_stmt|;
name|blksz
operator|=
operator|(
literal|1
operator|<<
name|blkshft
operator|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|zst
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|)
expr_stmt|;
name|zst
operator|.
name|zst_offset
operator|=
name|offset
operator|>>
name|blkshft
expr_stmt|;
name|zst
operator|.
name|zst_len
operator|=
operator|(
name|P2ROUNDUP
argument_list|(
name|offset
operator|+
name|size
argument_list|,
name|blksz
argument_list|)
operator|-
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
name|blksz
argument_list|)
operator|)
operator|>>
name|blkshft
expr_stmt|;
name|fetched
operator|=
name|dmu_zfetch_find
argument_list|(
name|zf
argument_list|,
operator|&
name|zst
argument_list|,
name|prefetched
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetched
condition|)
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_hits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_misses
argument_list|)
expr_stmt|;
if|if
condition|(
name|fetched
operator|=
name|dmu_zfetch_colinear
argument_list|(
name|zf
argument_list|,
operator|&
name|zst
argument_list|)
condition|)
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_colinear_hits
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_colinear_misses
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|fetched
condition|)
block|{
name|newstream
operator|=
name|dmu_zfetch_stream_reclaim
argument_list|(
name|zf
argument_list|)
expr_stmt|;
comment|/* 		 * we still couldn't find a stream, drop the lock, and allocate 		 * one if possible.  Otherwise, give up and go home. 		 */
if|if
condition|(
name|newstream
condition|)
block|{
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_reclaim_successes
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uint64_t
name|maxblocks
decl_stmt|;
name|uint32_t
name|max_streams
decl_stmt|;
name|uint32_t
name|cur_streams
decl_stmt|;
name|ZFETCHSTAT_BUMP
argument_list|(
name|zfetchstat_reclaim_failures
argument_list|)
expr_stmt|;
name|cur_streams
operator|=
name|zf
operator|->
name|zf_stream_cnt
expr_stmt|;
name|maxblocks
operator|=
name|zf
operator|->
name|zf_dnode
operator|->
name|dn_maxblkid
expr_stmt|;
name|max_streams
operator|=
name|MIN
argument_list|(
name|zfetch_max_streams
argument_list|,
operator|(
name|maxblocks
operator|/
name|zfetch_block_cap
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_streams
operator|==
literal|0
condition|)
block|{
name|max_streams
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|cur_streams
operator|>=
name|max_streams
condition|)
block|{
return|return;
block|}
name|newstream
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
name|newstream
operator|->
name|zst_offset
operator|=
name|zst
operator|.
name|zst_offset
expr_stmt|;
name|newstream
operator|->
name|zst_len
operator|=
name|zst
operator|.
name|zst_len
expr_stmt|;
name|newstream
operator|->
name|zst_stride
operator|=
name|zst
operator|.
name|zst_len
expr_stmt|;
name|newstream
operator|->
name|zst_ph_offset
operator|=
name|zst
operator|.
name|zst_len
operator|+
name|zst
operator|.
name|zst_offset
expr_stmt|;
name|newstream
operator|->
name|zst_cap
operator|=
name|zst
operator|.
name|zst_len
expr_stmt|;
name|newstream
operator|->
name|zst_direction
operator|=
name|ZFETCH_FORWARD
expr_stmt|;
name|newstream
operator|->
name|zst_last
operator|=
name|ddi_get_lbolt
argument_list|()
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|newstream
operator|->
name|zst_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_enter
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|inserted
operator|=
name|dmu_zfetch_stream_insert
argument_list|(
name|zf
argument_list|,
name|newstream
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|zf
operator|->
name|zf_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|inserted
condition|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|newstream
operator|->
name|zst_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|newstream
argument_list|,
sizeof|sizeof
argument_list|(
name|zstream_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

end_unit

