begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2016 by Delphix. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/bpobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_comment
comment|/*  * Return an empty bpobj, preferably the empty dummy one (dp_empty_bpobj).  */
end_comment

begin_function
name|uint64_t
name|bpobj_alloc_empty
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
decl_stmt|;
if|if
condition|(
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_EMPTY_BPOBJ
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_EMPTY_BPOBJ
argument_list|)
condition|)
block|{
name|ASSERT0
argument_list|(
name|dp
operator|->
name|dp_empty_bpobj
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_empty_bpobj
operator|=
name|bpobj_alloc
argument_list|(
name|os
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|os
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_EMPTY_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_empty_bpobj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|spa_feature_incr
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_EMPTY_BPOBJ
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_empty_bpobj
operator|!=
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|->
name|dp_empty_bpobj
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|bpobj_alloc
argument_list|(
name|os
argument_list|,
name|blocksize
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|bpobj_decr_empty
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|spa_feature_decr
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|,
name|SPA_FEATURE_EMPTY_BPOBJ
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|spa_feature_is_active
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|,
name|SPA_FEATURE_EMPTY_BPOBJ
argument_list|)
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_remove
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_EMPTY_BPOBJ
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|dp
operator|->
name|dp_empty_bpobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_empty_bpobj
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_function
name|uint64_t
name|bpobj_alloc
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|int
name|blocksize
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
operator|<
name|SPA_VERSION_BPOBJ_ACCOUNT
condition|)
name|size
operator|=
name|BPOBJ_SIZE_V0
expr_stmt|;
elseif|else
if|if
condition|(
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
operator|<
name|SPA_VERSION_DEADLISTS
condition|)
name|size
operator|=
name|BPOBJ_SIZE_V1
expr_stmt|;
else|else
name|size
operator|=
sizeof|sizeof
argument_list|(
name|bpobj_phys_t
argument_list|)
expr_stmt|;
return|return
operator|(
name|dmu_object_alloc
argument_list|(
name|os
argument_list|,
name|DMU_OT_BPOBJ
argument_list|,
name|blocksize
argument_list|,
name|DMU_OT_BPOBJ_HDR
argument_list|,
name|size
argument_list|,
name|tx
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bpobj_free
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|obj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|int64_t
name|i
decl_stmt|;
name|bpobj_t
name|bpo
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|int
name|epb
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|obj
operator|!=
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
operator|->
name|dp_empty_bpobj
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_open
argument_list|(
operator|&
name|bpo
argument_list|,
name|os
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bpo
operator|.
name|bpo_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bpo
operator|.
name|bpo_havesubobj
operator|||
name|bpo
operator|.
name|bpo_phys
operator|->
name|bpo_subobjs
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|bpo
operator|.
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
operator|&
name|doi
argument_list|)
argument_list|)
expr_stmt|;
name|epb
operator|=
name|doi
operator|.
name|doi_data_block_size
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bpo
operator|.
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|uint64_t
modifier|*
name|objarray
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|,
name|blkoff
decl_stmt|;
name|offset
operator|=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|P2PHASE
argument_list|(
name|i
argument_list|,
name|epb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
operator|||
name|dbuf
operator|->
name|db_offset
operator|>
name|offset
condition|)
block|{
if|if
condition|(
name|dbuf
condition|)
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|bpo
operator|.
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
name|offset
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|>=
argument_list|,
name|dbuf
operator|->
name|db_offset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|<
argument_list|,
name|dbuf
operator|->
name|db_offset
operator|+
name|dbuf
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|objarray
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bpobj_free
argument_list|(
name|os
argument_list|,
name|objarray
index|[
name|blkoff
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dbuf
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|bpo
operator|.
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|out
label|:
name|mutex_exit
argument_list|(
operator|&
name|bpo
operator|.
name|bpo_lock
argument_list|)
expr_stmt|;
name|bpobj_close
argument_list|(
operator|&
name|bpo
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_free
argument_list|(
name|os
argument_list|,
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|bpobj_open
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|object
parameter_list|)
block|{
name|dmu_object_info_t
name|doi
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|bzero
argument_list|(
name|bpo
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|bpo
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bpo
operator|->
name|bpo_dbuf
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|.
name|doi_type
argument_list|,
operator|==
argument_list|,
name|DMU_OT_BPOBJ
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|.
name|doi_bonus_type
argument_list|,
operator|==
argument_list|,
name|DMU_OT_BPOBJ_HDR
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|bpo
argument_list|,
operator|&
name|bpo
operator|->
name|bpo_dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|bpo
operator|->
name|bpo_os
operator|=
name|os
expr_stmt|;
name|bpo
operator|->
name|bpo_object
operator|=
name|object
expr_stmt|;
name|bpo
operator|->
name|bpo_epb
operator|=
name|doi
operator|.
name|doi_data_block_size
operator|>>
name|SPA_BLKPTRSHIFT
expr_stmt|;
name|bpo
operator|->
name|bpo_havecomp
operator|=
operator|(
name|doi
operator|.
name|doi_bonus_size
operator|>
name|BPOBJ_SIZE_V0
operator|)
expr_stmt|;
name|bpo
operator|->
name|bpo_havesubobj
operator|=
operator|(
name|doi
operator|.
name|doi_bonus_size
operator|>
name|BPOBJ_SIZE_V1
operator|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|=
name|bpo
operator|->
name|bpo_dbuf
operator|->
name|db_data
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bpobj_close
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|)
block|{
comment|/* Lame workaround for closing a bpobj that was never opened. */
if|if
condition|(
name|bpo
operator|->
name|bpo_object
operator|==
literal|0
condition|)
return|return;
name|dmu_buf_rele
argument_list|(
name|bpo
operator|->
name|bpo_dbuf
argument_list|,
name|bpo
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo
operator|->
name|bpo_cached_dbuf
operator|!=
name|NULL
condition|)
name|dmu_buf_rele
argument_list|(
name|bpo
operator|->
name|bpo_cached_dbuf
argument_list|,
name|bpo
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_dbuf
operator|=
name|NULL
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|=
name|NULL
expr_stmt|;
name|bpo
operator|->
name|bpo_cached_dbuf
operator|=
name|NULL
expr_stmt|;
name|bpo
operator|->
name|bpo_object
operator|=
literal|0
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|bpobj_hasentries
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|)
block|{
return|return
operator|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_blkptrs
operator|!=
literal|0
operator|||
operator|(
name|bpo
operator|->
name|bpo_havesubobj
operator|&&
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|!=
literal|0
operator|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|bpobj_iterate_impl
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
name|bpobj_itor_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|free
parameter_list|)
block|{
name|dmu_object_info_t
name|doi
decl_stmt|;
name|int
name|epb
decl_stmt|;
name|int64_t
name|i
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|dmu_buf_t
modifier|*
name|dbuf
init|=
name|NULL
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
condition|)
name|dmu_buf_will_dirty
argument_list|(
name|bpo
operator|->
name|bpo_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_blkptrs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|blkptr_t
modifier|*
name|bparray
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|,
name|blkoff
decl_stmt|;
name|offset
operator|=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|P2PHASE
argument_list|(
name|i
argument_list|,
name|bpo
operator|->
name|bpo_epb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
operator|||
name|dbuf
operator|->
name|db_offset
operator|>
name|offset
condition|)
block|{
if|if
condition|(
name|dbuf
condition|)
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_object
argument_list|,
name|offset
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|>=
argument_list|,
name|dbuf
operator|->
name|db_offset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|<
argument_list|,
name|dbuf
operator|->
name|db_offset
operator|+
name|dbuf
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|bparray
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|bp
operator|=
operator|&
name|bparray
index|[
name|blkoff
index|]
expr_stmt|;
name|err
operator|=
name|func
argument_list|(
name|arg
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
name|free
condition|)
block|{
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
operator|-=
name|bp_get_dsize_sync
argument_list|(
name|dmu_objset_spa
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo
operator|->
name|bpo_havecomp
condition|)
block|{
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_comp
operator|-=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_uncomp
operator|-=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_blkptrs
operator|--
expr_stmt|;
name|ASSERT3S
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_blkptrs
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dbuf
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_free_range
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_object
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|blkptr_t
argument_list|)
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|||
operator|!
name|bpo
operator|->
name|bpo_havesubobj
operator|||
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|ASSERT
argument_list|(
name|bpo
operator|->
name|bpo_havecomp
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_object_info
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
name|ASSERT3U
argument_list|(
name|doi
operator|.
name|doi_type
argument_list|,
operator|==
argument_list|,
name|DMU_OT_BPOBJ_SUBOBJ
argument_list|)
expr_stmt|;
name|epb
operator|=
name|doi
operator|.
name|doi_data_block_size
operator|/
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|uint64_t
modifier|*
name|objarray
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|,
name|blkoff
decl_stmt|;
name|bpobj_t
name|sublist
decl_stmt|;
name|uint64_t
name|used_before
decl_stmt|,
name|comp_before
decl_stmt|,
name|uncomp_before
decl_stmt|;
name|uint64_t
name|used_after
decl_stmt|,
name|comp_after
decl_stmt|,
name|uncomp_after
decl_stmt|;
name|offset
operator|=
name|i
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|P2PHASE
argument_list|(
name|i
argument_list|,
name|epb
argument_list|)
expr_stmt|;
if|if
condition|(
name|dbuf
operator|==
name|NULL
operator|||
name|dbuf
operator|->
name|db_offset
operator|>
name|offset
condition|)
block|{
if|if
condition|(
name|dbuf
condition|)
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_buf_hold
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
name|offset
argument_list|,
name|FTAG
argument_list|,
operator|&
name|dbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
block|}
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|>=
argument_list|,
name|dbuf
operator|->
name|db_offset
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|<
argument_list|,
name|dbuf
operator|->
name|db_offset
operator|+
name|dbuf
operator|->
name|db_size
argument_list|)
expr_stmt|;
name|objarray
operator|=
name|dbuf
operator|->
name|db_data
expr_stmt|;
name|err
operator|=
name|bpobj_open
argument_list|(
operator|&
name|sublist
argument_list|,
name|bpo
operator|->
name|bpo_os
argument_list|,
name|objarray
index|[
name|blkoff
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
name|free
condition|)
block|{
name|err
operator|=
name|bpobj_space
argument_list|(
operator|&
name|sublist
argument_list|,
operator|&
name|used_before
argument_list|,
operator|&
name|comp_before
argument_list|,
operator|&
name|uncomp_before
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|bpobj_close
argument_list|(
operator|&
name|sublist
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|err
operator|=
name|bpobj_iterate_impl
argument_list|(
operator|&
name|sublist
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|tx
argument_list|,
name|free
argument_list|)
expr_stmt|;
if|if
condition|(
name|free
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_space
argument_list|(
operator|&
name|sublist
argument_list|,
operator|&
name|used_after
argument_list|,
operator|&
name|comp_after
argument_list|,
operator|&
name|uncomp_after
argument_list|)
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
operator|-=
name|used_before
operator|-
name|used_after
expr_stmt|;
name|ASSERT3S
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_comp
operator|-=
name|comp_before
operator|-
name|comp_after
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_uncomp
operator|-=
name|uncomp_before
operator|-
name|uncomp_after
expr_stmt|;
block|}
name|bpobj_close
argument_list|(
operator|&
name|sublist
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
if|if
condition|(
name|free
condition|)
block|{
name|err
operator|=
name|dmu_object_free
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|objarray
index|[
name|blkoff
index|]
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
break|break;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|--
expr_stmt|;
name|ASSERT3S
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dbuf
condition|)
block|{
name|dmu_buf_rele
argument_list|(
name|dbuf
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dbuf
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|free
condition|)
block|{
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_free_range
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
operator|(
name|i
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|-
literal|1ULL
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|out
label|:
comment|/* If there are no entries, there should be no bytes. */
if|if
condition|(
operator|!
name|bpobj_hasentries
argument_list|(
name|bpo
argument_list|)
condition|)
block|{
name|ASSERT0
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_comp
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_uncomp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate and remove the entries.  If func returns nonzero, iteration  * will stop and that entry will not be removed.  */
end_comment

begin_function
name|int
name|bpobj_iterate
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
name|bpobj_itor_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
name|bpobj_iterate_impl
argument_list|(
name|bpo
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|tx
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate the entries.  If func returns nonzero, iteration will stop.  */
end_comment

begin_function
name|int
name|bpobj_iterate_nofree
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
name|bpobj_itor_t
name|func
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
name|bpobj_iterate_impl
argument_list|(
name|bpo
argument_list|,
name|func
argument_list|,
name|arg
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|bpobj_enqueue_subobj
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
name|uint64_t
name|subobj
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|bpobj_t
name|subbpo
decl_stmt|;
name|uint64_t
name|used
decl_stmt|,
name|comp
decl_stmt|,
name|uncomp
decl_stmt|,
name|subsubobjs
decl_stmt|;
name|ASSERT
argument_list|(
name|bpo
operator|->
name|bpo_havesubobj
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bpo
operator|->
name|bpo_havecomp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bpo
operator|->
name|bpo_object
operator|!=
name|dmu_objset_pool
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|)
operator|->
name|dp_empty_bpobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|subobj
operator|==
name|dmu_objset_pool
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|)
operator|->
name|dp_empty_bpobj
condition|)
block|{
name|bpobj_decr_empty
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_open
argument_list|(
operator|&
name|subbpo
argument_list|,
name|bpo
operator|->
name|bpo_os
argument_list|,
name|subobj
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_space
argument_list|(
operator|&
name|subbpo
argument_list|,
operator|&
name|used
argument_list|,
operator|&
name|comp
argument_list|,
operator|&
name|uncomp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|bpobj_hasentries
argument_list|(
operator|&
name|subbpo
argument_list|)
condition|)
block|{
comment|/* No point in having an empty subobj. */
name|bpobj_close
argument_list|(
operator|&
name|subbpo
argument_list|)
expr_stmt|;
name|bpobj_free
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|subobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_enter
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|bpo
operator|->
name|bpo_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
operator|==
literal|0
condition|)
block|{
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
operator|=
name|dmu_object_alloc
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|DMU_OT_BPOBJ_SUBOBJ
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_object_info_t
name|doi
decl_stmt|;
name|ASSERT0
argument_list|(
name|dmu_object_info
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
operator|&
name|doi
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|doi
operator|.
name|doi_type
argument_list|,
operator|==
argument_list|,
name|DMU_OT_BPOBJ_SUBOBJ
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|*
sizeof|sizeof
argument_list|(
name|subobj
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|subobj
argument_list|)
argument_list|,
operator|&
name|subobj
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|++
expr_stmt|;
comment|/* 	 * If subobj has only one block of subobjs, then move subobj's 	 * subobjs to bpo's subobj list directly.  This reduces 	 * recursion in bpobj_iterate due to nested subobjs. 	 */
name|subsubobjs
operator|=
name|subbpo
operator|.
name|bpo_phys
operator|->
name|bpo_subobjs
expr_stmt|;
if|if
condition|(
name|subsubobjs
operator|!=
literal|0
condition|)
block|{
name|dmu_object_info_t
name|doi
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_info
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|subsubobjs
argument_list|,
operator|&
name|doi
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|doi
operator|.
name|doi_max_offset
operator|==
name|doi
operator|.
name|doi_data_block_size
condition|)
block|{
name|dmu_buf_t
modifier|*
name|subdb
decl_stmt|;
name|uint64_t
name|numsubsub
init|=
name|subbpo
operator|.
name|bpo_phys
operator|->
name|bpo_num_subobjs
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_buf_hold
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|subsubobjs
argument_list|,
literal|0
argument_list|,
name|FTAG
argument_list|,
operator|&
name|subdb
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 			 * Make sure that we are not asking dmu_write() 			 * to write more data than we have in our buffer. 			 */
name|VERIFY3U
argument_list|(
name|subdb
operator|->
name|db_size
argument_list|,
operator|>=
argument_list|,
name|numsubsub
operator|*
sizeof|sizeof
argument_list|(
name|subobj
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_subobjs
argument_list|,
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|*
sizeof|sizeof
argument_list|(
name|subobj
argument_list|)
argument_list|,
name|numsubsub
operator|*
sizeof|sizeof
argument_list|(
name|subobj
argument_list|)
argument_list|,
name|subdb
operator|->
name|db_data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|subdb
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_subobjs
operator|+=
name|numsubsub
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|subbpo
operator|.
name|bpo_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|subbpo
operator|.
name|bpo_phys
operator|->
name|bpo_subobjs
operator|=
literal|0
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_object_free
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|subsubobjs
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
operator|+=
name|used
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_comp
operator|+=
name|comp
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_uncomp
operator|+=
name|uncomp
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
name|bpobj_close
argument_list|(
operator|&
name|subbpo
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bpobj_enqueue
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|blkptr_t
name|stored_bp
init|=
operator|*
name|bp
decl_stmt|;
name|uint64_t
name|offset
decl_stmt|;
name|int
name|blkoff
decl_stmt|;
name|blkptr_t
modifier|*
name|bparray
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|bpo
operator|->
name|bpo_object
operator|!=
name|dmu_objset_pool
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|)
operator|->
name|dp_empty_bpobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* 		 * The bpobj will compress better without the payload. 		 * 		 * Note that we store EMBEDDED bp's because they have an 		 * uncompressed size, which must be accounted for.  An 		 * alternative would be to add their size to bpo_uncomp 		 * without storing the bp, but that would create additional 		 * complications: bpo_uncomp would be inconsistent with the 		 * set of BP's stored, and bpobj_iterate() wouldn't visit 		 * all the space accounted for in the bpobj. 		 */
name|bzero
argument_list|(
operator|&
name|stored_bp
argument_list|,
sizeof|sizeof
argument_list|(
name|stored_bp
argument_list|)
argument_list|)
expr_stmt|;
name|stored_bp
operator|.
name|blk_prop
operator|=
name|bp
operator|->
name|blk_prop
expr_stmt|;
name|stored_bp
operator|.
name|blk_birth
operator|=
name|bp
operator|->
name|blk_birth
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|BP_GET_DEDUP
argument_list|(
name|bp
argument_list|)
condition|)
block|{
comment|/* The bpobj will compress better without the checksum */
name|bzero
argument_list|(
operator|&
name|stored_bp
operator|.
name|blk_cksum
argument_list|,
sizeof|sizeof
argument_list|(
name|stored_bp
operator|.
name|blk_cksum
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* We never need the fill count. */
name|stored_bp
operator|.
name|blk_fill
operator|=
literal|0
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
name|offset
operator|=
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_blkptrs
operator|*
sizeof|sizeof
argument_list|(
name|stored_bp
argument_list|)
expr_stmt|;
name|blkoff
operator|=
name|P2PHASE
argument_list|(
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_blkptrs
argument_list|,
name|bpo
operator|->
name|bpo_epb
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo
operator|->
name|bpo_cached_dbuf
operator|==
name|NULL
operator|||
name|offset
operator|<
name|bpo
operator|->
name|bpo_cached_dbuf
operator|->
name|db_offset
operator|||
name|offset
operator|>=
name|bpo
operator|->
name|bpo_cached_dbuf
operator|->
name|db_offset
operator|+
name|bpo
operator|->
name|bpo_cached_dbuf
operator|->
name|db_size
condition|)
block|{
if|if
condition|(
name|bpo
operator|->
name|bpo_cached_dbuf
condition|)
name|dmu_buf_rele
argument_list|(
name|bpo
operator|->
name|bpo_cached_dbuf
argument_list|,
name|bpo
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_buf_hold
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|,
name|bpo
operator|->
name|bpo_object
argument_list|,
name|offset
argument_list|,
name|bpo
argument_list|,
operator|&
name|bpo
operator|->
name|bpo_cached_dbuf
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|bpo
operator|->
name|bpo_cached_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bparray
operator|=
name|bpo
operator|->
name|bpo_cached_dbuf
operator|->
name|db_data
expr_stmt|;
name|bparray
index|[
name|blkoff
index|]
operator|=
name|stored_bp
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|bpo
operator|->
name|bpo_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_num_blkptrs
operator|++
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
operator|+=
name|bp_get_dsize_sync
argument_list|(
name|dmu_objset_spa
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|)
argument_list|,
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bpo
operator|->
name|bpo_havecomp
condition|)
block|{
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_comp
operator|+=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_uncomp
operator|+=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|space_range_arg
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|uint64_t
name|mintxg
decl_stmt|;
name|uint64_t
name|maxtxg
decl_stmt|;
name|uint64_t
name|used
decl_stmt|;
name|uint64_t
name|comp
decl_stmt|;
name|uint64_t
name|uncomp
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|space_range_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|struct
name|space_range_arg
modifier|*
name|sra
init|=
name|arg
decl_stmt|;
if|if
condition|(
name|bp
operator|->
name|blk_birth
operator|>
name|sra
operator|->
name|mintxg
operator|&&
name|bp
operator|->
name|blk_birth
operator|<=
name|sra
operator|->
name|maxtxg
condition|)
block|{
if|if
condition|(
name|dsl_pool_sync_context
argument_list|(
name|spa_get_dsl
argument_list|(
name|sra
operator|->
name|spa
argument_list|)
argument_list|)
condition|)
name|sra
operator|->
name|used
operator|+=
name|bp_get_dsize_sync
argument_list|(
name|sra
operator|->
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
else|else
name|sra
operator|->
name|used
operator|+=
name|bp_get_dsize
argument_list|(
name|sra
operator|->
name|spa
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|sra
operator|->
name|comp
operator|+=
name|BP_GET_PSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|sra
operator|->
name|uncomp
operator|+=
name|BP_GET_UCSIZE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|bpobj_space
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|,
name|uint64_t
modifier|*
name|compp
parameter_list|,
name|uint64_t
modifier|*
name|uncompp
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
operator|*
name|usedp
operator|=
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_bytes
expr_stmt|;
if|if
condition|(
name|bpo
operator|->
name|bpo_havecomp
condition|)
block|{
operator|*
name|compp
operator|=
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_comp
expr_stmt|;
operator|*
name|uncompp
operator|=
name|bpo
operator|->
name|bpo_phys
operator|->
name|bpo_uncomp
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|mutex_exit
argument_list|(
operator|&
name|bpo
operator|->
name|bpo_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|bpobj_space_range
argument_list|(
name|bpo
argument_list|,
literal|0
argument_list|,
name|UINT64_MAX
argument_list|,
name|usedp
argument_list|,
name|compp
argument_list|,
name|uncompp
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the amount of space in the bpobj which is:  * mintxg< blk_birth<= maxtxg  */
end_comment

begin_function
name|int
name|bpobj_space_range
parameter_list|(
name|bpobj_t
modifier|*
name|bpo
parameter_list|,
name|uint64_t
name|mintxg
parameter_list|,
name|uint64_t
name|maxtxg
parameter_list|,
name|uint64_t
modifier|*
name|usedp
parameter_list|,
name|uint64_t
modifier|*
name|compp
parameter_list|,
name|uint64_t
modifier|*
name|uncompp
parameter_list|)
block|{
name|struct
name|space_range_arg
name|sra
init|=
block|{
literal|0
block|}
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * As an optimization, if they want the whole txg range, just 	 * get bpo_bytes rather than iterating over the bps. 	 */
if|if
condition|(
name|mintxg
operator|<
name|TXG_INITIAL
operator|&&
name|maxtxg
operator|==
name|UINT64_MAX
operator|&&
name|bpo
operator|->
name|bpo_havecomp
condition|)
return|return
operator|(
name|bpobj_space
argument_list|(
name|bpo
argument_list|,
name|usedp
argument_list|,
name|compp
argument_list|,
name|uncompp
argument_list|)
operator|)
return|;
name|sra
operator|.
name|spa
operator|=
name|dmu_objset_spa
argument_list|(
name|bpo
operator|->
name|bpo_os
argument_list|)
expr_stmt|;
name|sra
operator|.
name|mintxg
operator|=
name|mintxg
expr_stmt|;
name|sra
operator|.
name|maxtxg
operator|=
name|maxtxg
expr_stmt|;
name|err
operator|=
name|bpobj_iterate_nofree
argument_list|(
name|bpo
argument_list|,
name|space_range_cb
argument_list|,
operator|&
name|sra
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|usedp
operator|=
name|sra
operator|.
name|used
expr_stmt|;
operator|*
name|compp
operator|=
name|sra
operator|.
name|comp
expr_stmt|;
operator|*
name|uncompp
operator|=
name|sra
operator|.
name|uncomp
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

end_unit

