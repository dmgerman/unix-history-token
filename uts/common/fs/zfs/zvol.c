begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  *  * Portions Copyright 2010 Robert Milkowski  *  * Copyright 2011 Nexenta Systems, Inc.  All rights reserved.  * Copyright (c) 2012, 2017 by Delphix. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_comment
comment|/*  * ZFS volume emulation driver.  *  * Makes a DMU object look like a volume of arbitrary size, up to 2^64 bytes.  * Volumes are accessed through the symbolic links named:  *  * /dev/zvol/dsk/<pool_name>/<dataset_name>  * /dev/zvol/rdsk/<pool_name>/<dataset_name>  *  * These links are created by the /dev filesystem (sdev_zvolops.c).  * Volumes are persistent through reboot.  No user command needs to be  * run before opening and using a device.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/open.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_traverse.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkio.h>
end_include

begin_include
include|#
directive|include
file|<sys/efi_partition.h>
end_include

begin_include
include|#
directive|include
file|<sys/byteorder.h>
end_include

begin_include
include|#
directive|include
file|<sys/pathname.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/crc32.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/mkdev.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil.h>
end_include

begin_include
include|#
directive|include
file|<sys/refcount.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_rlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_raidz.h>
end_include

begin_include
include|#
directive|include
file|<sys/zvol.h>
end_include

begin_include
include|#
directive|include
file|<sys/dumphdr.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dbuf.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_decl_stmt
name|void
modifier|*
name|zfsdev_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|zvol_tag
init|=
literal|"zvol_tag"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ZVOL_DUMPSIZE
value|"dumpsize"
end_define

begin_comment
comment|/*  * This lock protects the zfsdev_state structure from being modified  * while it's being used, e.g. an open that comes in before a create  * finishes.  It also protects temporary opens of the dataset so that,  * e.g., an open doesn't get a spurious EBUSY.  */
end_comment

begin_decl_stmt
name|kmutex_t
name|zfsdev_state_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|zvol_minors
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
struct|struct
name|zvol_extent
block|{
name|list_node_t
name|ze_node
decl_stmt|;
name|dva_t
name|ze_dva
decl_stmt|;
comment|/* dva associated with this extent */
name|uint64_t
name|ze_nblks
decl_stmt|;
comment|/* number of blocks in extent */
block|}
name|zvol_extent_t
typedef|;
end_typedef

begin_comment
comment|/*  * The in-core state of each volume.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|zvol_state
block|{
name|char
name|zv_name
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
comment|/* pool/dd name */
name|uint64_t
name|zv_volsize
decl_stmt|;
comment|/* amount of space we advertise */
name|uint64_t
name|zv_volblocksize
decl_stmt|;
comment|/* volume block size */
name|minor_t
name|zv_minor
decl_stmt|;
comment|/* minor number */
name|uint8_t
name|zv_min_bs
decl_stmt|;
comment|/* minimum addressable block shift */
name|uint8_t
name|zv_flags
decl_stmt|;
comment|/* readonly, dumpified, etc. */
name|objset_t
modifier|*
name|zv_objset
decl_stmt|;
comment|/* objset handle */
name|uint32_t
name|zv_open_count
index|[
name|OTYPCNT
index|]
decl_stmt|;
comment|/* open counts */
name|uint32_t
name|zv_total_opens
decl_stmt|;
comment|/* total open count */
name|zilog_t
modifier|*
name|zv_zilog
decl_stmt|;
comment|/* ZIL handle */
name|list_t
name|zv_extents
decl_stmt|;
comment|/* List of extents for dump */
name|znode_t
name|zv_znode
decl_stmt|;
comment|/* for range locking */
name|dmu_buf_t
modifier|*
name|zv_dbuf
decl_stmt|;
comment|/* bonus handle */
block|}
name|zvol_state_t
typedef|;
end_typedef

begin_comment
comment|/*  * zvol specific flags  */
end_comment

begin_define
define|#
directive|define
name|ZVOL_RDONLY
value|0x1
end_define

begin_define
define|#
directive|define
name|ZVOL_DUMPIFIED
value|0x2
end_define

begin_define
define|#
directive|define
name|ZVOL_EXCL
value|0x4
end_define

begin_define
define|#
directive|define
name|ZVOL_WCE
value|0x8
end_define

begin_comment
comment|/*  * zvol maximum transfer in one DMU tx.  */
end_comment

begin_decl_stmt
name|int
name|zvol_maxphys
init|=
name|DMU_MAX_ACCESS
operator|/
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Toggle unmap functionality.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zvol_unmap_enabled
init|=
name|B_TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If true, unmaps requested as synchronous are executed synchronously,  * otherwise all unmaps are asynchronous.  */
end_comment

begin_decl_stmt
name|boolean_t
name|zvol_unmap_sync_enabled
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|int
name|zfs_set_prop_nvlist
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|zprop_source_t
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|,
name|nvlist_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_remove_zv
parameter_list|(
name|zvol_state_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dumpify
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dump_fini
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zvol_dump_init
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|boolean_t
name|resize
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|zvol_size_changed
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|dev_t
name|dev
init|=
name|makedevice
argument_list|(
name|ddi_driver_major
argument_list|(
name|zfs_dip
argument_list|)
argument_list|,
name|zv
operator|->
name|zv_minor
argument_list|)
decl_stmt|;
name|zv
operator|->
name|zv_volsize
operator|=
name|volsize
expr_stmt|;
name|VERIFY
argument_list|(
name|ddi_prop_update_int64
argument_list|(
name|dev
argument_list|,
name|zfs_dip
argument_list|,
literal|"Size"
argument_list|,
name|volsize
argument_list|)
operator|==
name|DDI_SUCCESS
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|ddi_prop_update_int64
argument_list|(
name|dev
argument_list|,
name|zfs_dip
argument_list|,
literal|"Nblocks"
argument_list|,
name|lbtodb
argument_list|(
name|volsize
argument_list|)
argument_list|)
operator|==
name|DDI_SUCCESS
argument_list|)
expr_stmt|;
comment|/* Notify specfs to invalidate the cached size */
name|spec_size_invalidate
argument_list|(
name|dev
argument_list|,
name|VBLK
argument_list|)
expr_stmt|;
name|spec_size_invalidate
argument_list|(
name|dev
argument_list|,
name|VCHR
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zvol_check_volsize
parameter_list|(
name|uint64_t
name|volsize
parameter_list|,
name|uint64_t
name|blocksize
parameter_list|)
block|{
if|if
condition|(
name|volsize
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|volsize
operator|%
name|blocksize
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|volsize
operator|-
literal|1
operator|>
name|SPEC_MAXOFFSET_T
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EOVERFLOW
argument_list|)
operator|)
return|;
endif|#
directive|endif
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_check_volblocksize
parameter_list|(
name|uint64_t
name|volblocksize
parameter_list|)
block|{
if|if
condition|(
name|volblocksize
operator|<
name|SPA_MINBLOCKSIZE
operator|||
name|volblocksize
operator|>
name|SPA_OLD_MAXBLOCKSIZE
operator|||
operator|!
name|ISP2
argument_list|(
name|volblocksize
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EDOM
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_get_stats
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|nvlist_t
modifier|*
name|nv
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|val
decl_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLSIZE
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|dsl_prop_nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zvol_state_t
modifier|*
name|zvol_minor_lookup
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|minor_t
name|minor
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|minor
operator|=
literal|1
init|;
name|minor
operator|<=
name|ZFSDEV_MAX_MINOR
condition|;
name|minor
operator|++
control|)
block|{
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strcmp
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|zv
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* extent mapping arg */
end_comment

begin_struct
struct|struct
name|maparg
block|{
name|zvol_state_t
modifier|*
name|ma_zv
decl_stmt|;
name|uint64_t
name|ma_blks
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zvol_map_block
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zilog_t
modifier|*
name|zilog
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
specifier|const
name|zbookmark_phys_t
modifier|*
name|zb
parameter_list|,
specifier|const
name|dnode_phys_t
modifier|*
name|dnp
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|struct
name|maparg
modifier|*
name|ma
init|=
name|arg
decl_stmt|;
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
name|int
name|bs
init|=
name|ma
operator|->
name|ma_zv
operator|->
name|zv_volblocksize
decl_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
operator|||
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
operator|||
name|zb
operator|->
name|zb_object
operator|!=
name|ZVOL_OBJ
operator|||
name|zb
operator|->
name|zb_level
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|VERIFY
argument_list|(
operator|!
name|BP_IS_EMBEDDED
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|ma
operator|->
name|ma_blks
argument_list|,
operator|==
argument_list|,
name|zb
operator|->
name|zb_blkid
argument_list|)
expr_stmt|;
name|ma
operator|->
name|ma_blks
operator|++
expr_stmt|;
comment|/* Abort immediately if we have encountered gang blocks */
if|if
condition|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFRAGS
argument_list|)
operator|)
return|;
comment|/* 	 * See if the block is at the end of the previous extent. 	 */
name|ze
operator|=
name|list_tail
argument_list|(
operator|&
name|ma
operator|->
name|ma_zv
operator|->
name|zv_extents
argument_list|)
expr_stmt|;
if|if
condition|(
name|ze
operator|&&
name|DVA_GET_VDEV
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|==
name|DVA_GET_VDEV
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
operator|&&
name|DVA_GET_OFFSET
argument_list|(
name|BP_IDENTITY
argument_list|(
name|bp
argument_list|)
argument_list|)
operator|==
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
operator|+
name|ze
operator|->
name|ze_nblks
operator|*
name|bs
condition|)
block|{
name|ze
operator|->
name|ze_nblks
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dprintf_bp
argument_list|(
name|bp
argument_list|,
literal|"%s"
argument_list|,
literal|"next blkptr:"
argument_list|)
expr_stmt|;
comment|/* start a new extent */
name|ze
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ze
operator|->
name|ze_dva
operator|=
name|bp
operator|->
name|blk_dva
index|[
literal|0
index|]
expr_stmt|;
comment|/* structure assignment */
name|ze
operator|->
name|ze_nblks
operator|=
literal|1
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|ma
operator|->
name|ma_zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_free_extents
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
while|while
condition|(
name|ze
operator|=
name|list_head
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|ze
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_get_lbas
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|struct
name|maparg
name|ma
decl_stmt|;
name|int
name|err
decl_stmt|;
name|ma
operator|.
name|ma_zv
operator|=
name|zv
expr_stmt|;
name|ma
operator|.
name|ma_blks
operator|=
literal|0
expr_stmt|;
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
comment|/* commit any in-flight changes before traversing the dataset */
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|err
operator|=
name|traverse_dataset
argument_list|(
name|dmu_objset_ds
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|,
name|TRAVERSE_PRE
operator||
name|TRAVERSE_PREFETCH_METADATA
argument_list|,
name|zvol_map_block
argument_list|,
operator|&
name|ma
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|||
name|ma
operator|.
name|ma_blks
operator|!=
operator|(
name|zv
operator|->
name|zv_volsize
operator|/
name|zv
operator|->
name|zv_volblocksize
operator|)
condition|)
block|{
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
condition|?
name|err
else|:
name|EIO
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|zvol_create_cb
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zfs_creat_t
modifier|*
name|zct
init|=
name|arg
decl_stmt|;
name|nvlist_t
modifier|*
name|nvprops
init|=
name|zct
operator|->
name|zct_props
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|volblocksize
decl_stmt|,
name|volsize
decl_stmt|;
name|VERIFY
argument_list|(
name|nvlist_lookup_uint64
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|,
operator|&
name|volsize
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_uint64
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|volblocksize
argument_list|)
operator|!=
literal|0
condition|)
name|volblocksize
operator|=
name|zfs_prop_default_numeric
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
expr_stmt|;
comment|/* 	 * These properties must be removed from the list so the generic 	 * property setting step won't apply to them. 	 */
name|VERIFY
argument_list|(
name|nvlist_remove_all
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLSIZE
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_remove_all
argument_list|(
name|nvprops
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_object_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|DMU_OT_ZVOL
argument_list|,
name|volblocksize
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_create_claim
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|DMU_OT_ZVOL_PROP
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Replay a TX_TRUNCATE ZIL transaction if asked.  TX_TRUNCATE is how we  * implement DKIOCFREE/free-long-range.  */
end_comment

begin_function
specifier|static
name|int
name|zvol_replay_truncate
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_truncate_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|uint64_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lr
operator|->
name|lr_offset
expr_stmt|;
name|length
operator|=
name|lr
operator|->
name|lr_length
expr_stmt|;
return|return
operator|(
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Replay a TX_WRITE ZIL transaction that didn't get committed  * after a system failure  */
end_comment

begin_function
specifier|static
name|int
name|zvol_replay_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|char
modifier|*
name|data
init|=
operator|(
name|char
operator|*
operator|)
operator|(
name|lr
operator|+
literal|1
operator|)
decl_stmt|;
comment|/* data follows lr_write_t */
name|uint64_t
name|offset
decl_stmt|,
name|length
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
if|if
condition|(
name|byteswap
condition|)
name|byteswap_uint64_array
argument_list|(
name|lr
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|=
name|lr
operator|->
name|lr_offset
expr_stmt|;
name|length
operator|=
name|lr
operator|->
name|lr_length
expr_stmt|;
comment|/* If it's a dmu_sync() block, write the whole block */
if|if
condition|(
name|lr
operator|->
name|lr_common
operator|.
name|lrc_reclen
operator|==
sizeof|sizeof
argument_list|(
name|lr_write_t
argument_list|)
condition|)
block|{
name|uint64_t
name|blocksize
init|=
name|BP_GET_LSIZE
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
decl_stmt|;
if|if
condition|(
name|length
operator|<
name|blocksize
condition|)
block|{
name|offset
operator|-=
name|offset
operator|%
name|blocksize
expr_stmt|;
name|length
operator|=
name|blocksize
expr_stmt|;
block|}
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|offset
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
name|data
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zvol_replay_err
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|lr_t
modifier|*
name|lr
parameter_list|,
name|boolean_t
name|byteswap
parameter_list|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Callback vectors for replaying records.  * Only TX_WRITE and TX_TRUNCATE are needed for zvol.  */
end_comment

begin_decl_stmt
name|zil_replay_func_t
modifier|*
name|zvol_replay_vector
index|[
name|TX_MAX_TYPE
index|]
init|=
block|{
name|zvol_replay_err
block|,
comment|/* 0 no such transaction type */
name|zvol_replay_err
block|,
comment|/* TX_CREATE */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR */
name|zvol_replay_err
block|,
comment|/* TX_MKXATTR */
name|zvol_replay_err
block|,
comment|/* TX_SYMLINK */
name|zvol_replay_err
block|,
comment|/* TX_REMOVE */
name|zvol_replay_err
block|,
comment|/* TX_RMDIR */
name|zvol_replay_err
block|,
comment|/* TX_LINK */
name|zvol_replay_err
block|,
comment|/* TX_RENAME */
name|zvol_replay_write
block|,
comment|/* TX_WRITE */
name|zvol_replay_truncate
block|,
comment|/* TX_TRUNCATE */
name|zvol_replay_err
block|,
comment|/* TX_SETATTR */
name|zvol_replay_err
block|,
comment|/* TX_ACL */
name|zvol_replay_err
block|,
comment|/* TX_CREATE_ACL */
name|zvol_replay_err
block|,
comment|/* TX_CREATE_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_CREATE_ACL_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR_ACL */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_MKDIR_ACL_ATTR */
name|zvol_replay_err
block|,
comment|/* TX_WRITE2 */
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zvol_name2minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|minor_t
modifier|*
name|minor
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|minor
operator|&&
name|zv
condition|)
operator|*
name|minor
operator|=
name|zv
operator|->
name|zv_minor
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|zv
condition|?
literal|0
else|:
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a minor node (plus a whole lot more) for the specified volume.  */
end_comment

begin_function
name|int
name|zvol_create_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|zfs_soft_state_t
modifier|*
name|zs
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|minor_t
name|minor
init|=
literal|0
decl_stmt|;
name|char
name|chrbuf
index|[
literal|30
index|]
decl_stmt|,
name|blkbuf
index|[
literal|30
index|]
decl_stmt|;
name|int
name|error
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EEXIST
argument_list|)
operator|)
return|;
block|}
comment|/* lie and say we're read-only */
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|B_TRUE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|minor
operator|=
name|zfsdev_minor_alloc
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|ddi_soft_state_zalloc
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
operator|!=
name|DDI_SUCCESS
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|ddi_prop_update_string
argument_list|(
name|minor
argument_list|,
name|zfs_dip
argument_list|,
name|ZVOL_PROP_NAME
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|chrbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|chrbuf
argument_list|)
argument_list|,
literal|"%u,raw"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|chrbuf
argument_list|,
name|S_IFCHR
argument_list|,
name|minor
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_soft_state_free
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|blkbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|blkbuf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|blkbuf
argument_list|,
name|S_IFBLK
argument_list|,
name|minor
argument_list|,
name|DDI_PSEUDO
argument_list|,
literal|0
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|chrbuf
argument_list|)
expr_stmt|;
name|ddi_soft_state_free
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EAGAIN
argument_list|)
operator|)
return|;
block|}
name|zs
operator|=
name|ddi_get_soft_state
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|zs
operator|->
name|zss_type
operator|=
name|ZSST_ZVOL
expr_stmt|;
name|zv
operator|=
name|zs
operator|->
name|zss_data
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zvol_state_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|name
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_min_bs
operator|=
name|DEV_BSHIFT
expr_stmt|;
name|zv
operator|->
name|zv_minor
operator|=
name|minor
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
if|if
condition|(
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_RDONLY
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|,
name|zfs_range_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|rl_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|rl_t
argument_list|,
name|r_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_extent_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zvol_extent_t
argument_list|,
name|ze_node
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get and cache the blocksize */
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_volblocksize
operator|=
name|doi
operator|.
name|doi_data_block_size
expr_stmt|;
if|if
condition|(
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
block|{
if|if
condition|(
name|zil_replay_disable
condition|)
name|zil_destroy
argument_list|(
name|dmu_objset_zil
argument_list|(
name|os
argument_list|)
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
else|else
name|zil_replay
argument_list|(
name|os
argument_list|,
name|zv
argument_list|,
name|zvol_replay_vector
argument_list|)
expr_stmt|;
block|}
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
name|zvol_minors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove minor node for the specified volume.  */
end_comment

begin_function
specifier|static
name|int
name|zvol_remove_zv
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|char
name|nmbuf
index|[
literal|20
index|]
decl_stmt|;
name|minor_t
name|minor
init|=
name|zv
operator|->
name|zv_minor
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|nmbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nmbuf
argument_list|)
argument_list|,
literal|"%u,raw"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|nmbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|nmbuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nmbuf
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|zfs_dip
argument_list|,
name|nmbuf
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_avl
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
operator|.
name|z_range_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zv
argument_list|,
sizeof|sizeof
argument_list|(
name|zvol_state_t
argument_list|)
argument_list|)
expr_stmt|;
name|ddi_soft_state_free
argument_list|(
name|zfsdev_state
argument_list|,
name|minor
argument_list|)
expr_stmt|;
name|zvol_minors
operator|--
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_remove_minor
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|rc
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
name|rc
operator|=
name|zvol_remove_zv
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_first_open
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|int
name|error
decl_stmt|;
name|uint64_t
name|readonly
decl_stmt|;
comment|/* lie and say we're read-only */
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|B_TRUE
argument_list|,
name|zvol_tag
argument_list|,
operator|&
name|os
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
name|error
operator|=
name|zap_lookup
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|dmu_bonus_hold
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|zvol_tag
argument_list|,
operator|&
name|zv
operator|->
name|zv_dbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|zil_open
argument_list|(
name|os
argument_list|,
name|zvol_get_data
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
literal|"readonly"
argument_list|,
operator|&
name|readonly
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|readonly
operator|||
name|dmu_objset_is_snapshot
argument_list|(
name|os
argument_list|)
operator|||
operator|!
name|spa_writeable
argument_list|(
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
argument_list|)
condition|)
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_RDONLY
expr_stmt|;
else|else
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_RDONLY
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zvol_last_close
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|zil_close
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_zilog
operator|=
name|NULL
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|zv
operator|->
name|zv_dbuf
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_dbuf
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * Evict cached data 	 */
if|if
condition|(
name|dsl_dataset_is_dirty
argument_list|(
name|dmu_objset_ds
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|)
operator|&&
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dmu_objset_evict_dbufs
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_objset_disown
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|zvol_tag
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zvol_prealloc
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|uint64_t
name|refd
decl_stmt|,
name|avail
decl_stmt|,
name|usedobjs
decl_stmt|,
name|availobjs
decl_stmt|;
name|uint64_t
name|resid
init|=
name|zv
operator|->
name|zv_volsize
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
comment|/* Check the space usage before attempting to allocate the space */
name|dmu_objset_space
argument_list|(
name|os
argument_list|,
operator|&
name|refd
argument_list|,
operator|&
name|avail
argument_list|,
operator|&
name|usedobjs
argument_list|,
operator|&
name|availobjs
argument_list|)
expr_stmt|;
if|if
condition|(
name|avail
operator|<
name|zv
operator|->
name|zv_volsize
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
comment|/* Free old extents if they exist */
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
condition|)
block|{
name|int
name|error
decl_stmt|;
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
decl_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|off
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|dmu_prealloc
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|bytes
expr_stmt|;
name|resid
operator|-=
name|bytes
expr_stmt|;
block|}
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_update_volsize
parameter_list|(
name|objset_t
modifier|*
name|os
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
literal|"size"
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|volsize
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zvol_remove_minors
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|;
name|minor_t
name|minor
decl_stmt|;
name|namebuf
operator|=
name|kmem_zalloc
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|namebuf
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|namebuf
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|minor
operator|=
literal|1
init|;
name|minor
operator|<=
name|ZFSDEV_MAX_MINOR
condition|;
name|minor
operator|++
control|)
block|{
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
continue|continue;
if|if
condition|(
name|strncmp
argument_list|(
name|namebuf
argument_list|,
name|zv
operator|->
name|zv_name
argument_list|,
name|strlen
argument_list|(
name|namebuf
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|zvol_remove_zv
argument_list|(
name|zv
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|namebuf
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_update_live_volsize
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|uint64_t
name|old_volsize
init|=
literal|0ULL
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Reinitialize the dump area to the new size. If we 	 * failed to resize the dump area then restore it back to 	 * its original size.  We must set the new volsize prior 	 * to calling dumpvp_resize() to ensure that the devices' 	 * size(9P) is not visible by the dump subsystem. 	 */
name|old_volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|zvol_dumpify
argument_list|(
name|zv
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|dumpvp_resize
argument_list|()
operator|)
operator|!=
literal|0
condition|)
block|{
name|int
name|dumpify_error
decl_stmt|;
operator|(
name|void
operator|)
name|zvol_update_volsize
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|old_volsize
argument_list|)
expr_stmt|;
name|zvol_size_changed
argument_list|(
name|zv
argument_list|,
name|old_volsize
argument_list|)
expr_stmt|;
name|dumpify_error
operator|=
name|zvol_dumpify
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|error
operator|=
name|dumpify_error
condition|?
name|dumpify_error
else|:
name|error
expr_stmt|;
block|}
block|}
comment|/* 	 * Generate a LUN expansion event. 	 */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|sysevent_id_t
name|eid
decl_stmt|;
name|nvlist_t
modifier|*
name|attr
decl_stmt|;
name|char
modifier|*
name|physpath
init|=
name|kmem_zalloc
argument_list|(
name|MAXPATHLEN
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|,
literal|"%s%u"
argument_list|,
name|ZVOL_PSEUDO_DEV
argument_list|,
name|zv
operator|->
name|zv_minor
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|attr
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_string
argument_list|(
name|attr
argument_list|,
name|DEV_PHYS_PATH
argument_list|,
name|physpath
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ddi_log_sysevent
argument_list|(
name|zfs_dip
argument_list|,
name|SUNW_VENDOR
argument_list|,
name|EC_DEV_STATUS
argument_list|,
name|ESC_DEV_DLE
argument_list|,
name|attr
argument_list|,
operator|&
name|eid
argument_list|,
name|DDI_SLEEP
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|attr
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|physpath
argument_list|,
name|MAXPATHLEN
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_set_volsize
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|uint64_t
name|volsize
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|NULL
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|int
name|error
decl_stmt|;
name|dmu_object_info_t
name|doi
decl_stmt|;
name|uint64_t
name|readonly
decl_stmt|;
name|boolean_t
name|owned
init|=
name|B_FALSE
decl_stmt|;
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_READONLY
argument_list|)
argument_list|,
operator|&
name|readonly
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|readonly
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zvol_minor_lookup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
operator|||
name|zv
operator|->
name|zv_objset
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_objset_own
argument_list|(
name|name
argument_list|,
name|DMU_OST_ZVOL
argument_list|,
name|B_FALSE
argument_list|,
name|FTAG
argument_list|,
operator|&
name|os
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|owned
operator|=
name|B_TRUE
expr_stmt|;
if|if
condition|(
name|zv
operator|!=
name|NULL
condition|)
name|zv
operator|->
name|zv_objset
operator|=
name|os
expr_stmt|;
block|}
else|else
block|{
name|os
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|dmu_object_info
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
operator|&
name|doi
argument_list|)
operator|)
operator|!=
literal|0
operator|||
operator|(
name|error
operator|=
name|zvol_check_volsize
argument_list|(
name|volsize
argument_list|,
name|doi
operator|.
name|doi_data_block_size
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
name|error
operator|=
name|zvol_update_volsize
argument_list|(
name|os
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zv
operator|!=
name|NULL
condition|)
name|error
operator|=
name|zvol_update_live_volsize
argument_list|(
name|zv
argument_list|,
name|volsize
argument_list|)
expr_stmt|;
name|out
label|:
if|if
condition|(
name|owned
condition|)
block|{
name|dmu_objset_disown
argument_list|(
name|os
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|!=
name|NULL
condition|)
name|zv
operator|->
name|zv_objset
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|zvol_open
parameter_list|(
name|dev_t
modifier|*
name|devp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|err
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|getminor
argument_list|(
operator|*
name|devp
argument_list|)
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|err
operator|=
name|zvol_first_open
argument_list|(
name|zv
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|flag
operator|&
name|FWRITE
operator|)
operator|&&
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_EXCL
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|flag
operator|&
name|FEXCL
condition|)
block|{
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|EBUSY
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_EXCL
expr_stmt|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|==
literal|0
operator|||
name|otyp
operator|==
name|OTYP_LYR
condition|)
block|{
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|++
expr_stmt|;
name|zv
operator|->
name|zv_total_opens
operator|++
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
name|out
label|:
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|zvol_last_close
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|zvol_close
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_EXCL
condition|)
block|{
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|1
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_EXCL
expr_stmt|;
block|}
comment|/* 	 * If the open count is zero, this is a spurious close. 	 * That indicates a bug in the kernel / DDI framework. 	 */
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * You may get multiple opens, but only one close. 	 */
name|zv
operator|->
name|zv_open_count
index|[
name|otyp
index|]
operator|--
expr_stmt|;
name|zv
operator|->
name|zv_total_opens
operator|--
expr_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_total_opens
operator|==
literal|0
condition|)
name|zvol_last_close
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zvol_get_done
parameter_list|(
name|zgd_t
modifier|*
name|zgd
parameter_list|,
name|int
name|error
parameter_list|)
block|{
if|if
condition|(
name|zgd
operator|->
name|zgd_db
condition|)
name|dmu_buf_rele
argument_list|(
name|zgd
operator|->
name|zgd_db
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|zgd
operator|->
name|zgd_rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
name|zgd
operator|->
name|zgd_bp
condition|)
name|zil_add_block
argument_list|(
name|zgd
operator|->
name|zgd_zilog
argument_list|,
name|zgd
operator|->
name|zgd_bp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|zgd
argument_list|,
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Get data to generate a TX_WRITE intent log record.  */
end_comment

begin_function
specifier|static
name|int
name|zvol_get_data
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|lr_write_t
modifier|*
name|lr
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|uint64_t
name|object
init|=
name|ZVOL_OBJ
decl_stmt|;
name|uint64_t
name|offset
init|=
name|lr
operator|->
name|lr_offset
decl_stmt|;
name|uint64_t
name|size
init|=
name|lr
operator|->
name|lr_length
decl_stmt|;
comment|/* length of user data */
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|zgd_t
modifier|*
name|zgd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|size
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|zgd
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zgd_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|zgd
operator|->
name|zgd_zilog
operator|=
name|zv
operator|->
name|zv_zilog
expr_stmt|;
name|zgd
operator|->
name|zgd_rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
comment|/* 	 * Write records come in two flavors: immediate and indirect. 	 * For small writes it's cheaper to store the data with the 	 * log record (immediate); for large writes it's cheaper to 	 * sync the data and get a pointer to it (indirect) so that 	 * we don't have to write the data twice. 	 */
if|if
condition|(
name|buf
operator|!=
name|NULL
condition|)
block|{
comment|/* immediate write */
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|size
argument_list|,
name|buf
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
name|offset
operator|=
name|P2ALIGN
argument_list|(
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_buf_hold
argument_list|(
name|os
argument_list|,
name|object
argument_list|,
name|offset
argument_list|,
name|zgd
argument_list|,
operator|&
name|db
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|blkptr_t
modifier|*
name|bp
init|=
operator|&
name|lr
operator|->
name|lr_blkptr
decl_stmt|;
name|zgd
operator|->
name|zgd_db
operator|=
name|db
expr_stmt|;
name|zgd
operator|->
name|zgd_bp
operator|=
name|bp
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_offset
operator|==
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|db
operator|->
name|db_size
operator|==
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_sync
argument_list|(
name|zio
argument_list|,
name|lr
operator|->
name|lr_common
operator|.
name|lrc_txg
argument_list|,
name|zvol_get_done
argument_list|,
name|zgd
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|zvol_get_done
argument_list|(
name|zgd
argument_list|,
name|error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * zvol_log_write() handles synchronous writes using TX_WRITE ZIL transactions.  *  * We store data in the log buffers if it's small enough.  * Otherwise we will later flush the data out via dmu_sync().  */
end_comment

begin_decl_stmt
name|ssize_t
name|zvol_immediate_write_sz
init|=
literal|32768
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|zvol_log_write
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|resid
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
block|{
name|uint32_t
name|blocksize
init|=
name|zv
operator|->
name|zv_volblocksize
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zv
operator|->
name|zv_zilog
decl_stmt|;
name|itx_wr_state_t
name|write_state
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
if|if
condition|(
name|zilog
operator|->
name|zl_logbias
operator|==
name|ZFS_LOGBIAS_THROUGHPUT
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|spa_has_slogs
argument_list|(
name|zilog
operator|->
name|zl_spa
argument_list|)
operator|&&
name|resid
operator|>=
name|blocksize
operator|&&
name|blocksize
operator|>
name|zvol_immediate_write_sz
condition|)
name|write_state
operator|=
name|WR_INDIRECT
expr_stmt|;
elseif|else
if|if
condition|(
name|sync
condition|)
name|write_state
operator|=
name|WR_COPIED
expr_stmt|;
else|else
name|write_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
while|while
condition|(
name|resid
condition|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_write_t
modifier|*
name|lr
decl_stmt|;
name|itx_wr_state_t
name|wr_state
init|=
name|write_state
decl_stmt|;
name|ssize_t
name|len
init|=
name|resid
decl_stmt|;
if|if
condition|(
name|wr_state
operator|==
name|WR_COPIED
operator|&&
name|resid
operator|>
name|ZIL_MAX_COPIED_DATA
condition|)
name|wr_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
elseif|else
if|if
condition|(
name|wr_state
operator|==
name|WR_INDIRECT
condition|)
name|len
operator|=
name|MIN
argument_list|(
name|blocksize
operator|-
name|P2PHASE
argument_list|(
name|off
argument_list|,
name|blocksize
argument_list|)
argument_list|,
name|resid
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
operator|+
operator|(
name|wr_state
operator|==
name|WR_COPIED
condition|?
name|len
else|:
literal|0
operator|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
if|if
condition|(
name|wr_state
operator|==
name|WR_COPIED
operator|&&
name|dmu_read
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|len
argument_list|,
name|lr
operator|+
literal|1
argument_list|,
name|DMU_READ_NO_PREFETCH
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|zil_itx_destroy
argument_list|(
name|itx
argument_list|)
expr_stmt|;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_WRITE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_write_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|wr_state
operator|=
name|WR_NEED_COPY
expr_stmt|;
block|}
name|itx
operator|->
name|itx_wr_state
operator|=
name|wr_state
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|ZVOL_OBJ
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|lr
operator|->
name|lr_blkoff
operator|=
literal|0
expr_stmt|;
name|BP_ZERO
argument_list|(
operator|&
name|lr
operator|->
name|lr_blkptr
argument_list|)
expr_stmt|;
name|itx
operator|->
name|itx_private
operator|=
name|zv
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
name|sync
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|off
operator|+=
name|len
expr_stmt|;
name|resid
operator|-=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dumpio_vdev
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|origoffset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|boolean_t
name|doread
parameter_list|,
name|boolean_t
name|isdump
parameter_list|)
block|{
name|vdev_disk_t
modifier|*
name|dvd
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|numerrors
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_mirror_ops
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_replacing_ops
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_spare_ops
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|int
name|err
init|=
name|zvol_dumpio_vdev
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|origoffset
argument_list|,
name|size
argument_list|,
name|doread
argument_list|,
name|isdump
argument_list|)
decl_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|numerrors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doread
condition|)
block|{
break|break;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|vd
operator|->
name|vdev_ops
operator|->
name|vdev_op_leaf
operator|&&
name|vd
operator|->
name|vdev_ops
operator|!=
operator|&
name|vdev_raidz_ops
condition|)
return|return
operator|(
name|numerrors
operator|<
name|vd
operator|->
name|vdev_children
condition|?
literal|0
else|:
name|EIO
operator|)
return|;
if|if
condition|(
name|doread
operator|&&
operator|!
name|vdev_readable
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
elseif|else
if|if
condition|(
operator|!
name|doread
operator|&&
operator|!
name|vdev_writeable
argument_list|(
name|vd
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_raidz_ops
condition|)
block|{
return|return
operator|(
name|vdev_raidz_physio
argument_list|(
name|vd
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|origoffset
argument_list|,
name|doread
argument_list|,
name|isdump
argument_list|)
operator|)
return|;
block|}
name|offset
operator|+=
name|VDEV_LABEL_START_SIZE
expr_stmt|;
if|if
condition|(
name|ddi_in_panic
argument_list|()
operator|||
name|isdump
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
name|doread
argument_list|)
expr_stmt|;
if|if
condition|(
name|doread
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
name|dvd
operator|=
name|vd
operator|->
name|vdev_tsd
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dvd
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|ldi_dump
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|addr
argument_list|,
name|lbtodb
argument_list|(
name|offset
argument_list|)
argument_list|,
name|lbtodb
argument_list|(
name|size
argument_list|)
argument_list|)
operator|)
return|;
block|}
else|else
block|{
name|dvd
operator|=
name|vd
operator|->
name|vdev_tsd
expr_stmt|;
name|ASSERT3P
argument_list|(
name|dvd
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|vdev_disk_ldi_physio
argument_list|(
name|dvd
operator|->
name|vd_lh
argument_list|,
name|addr
argument_list|,
name|size
argument_list|,
name|offset
argument_list|,
name|doread
condition|?
name|B_READ
else|:
name|B_WRITE
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dumpio
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|void
modifier|*
name|addr
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|boolean_t
name|doread
parameter_list|,
name|boolean_t
name|isdump
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|error
decl_stmt|;
name|zvol_extent_t
modifier|*
name|ze
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
comment|/* Must be sector aligned, and not stradle a block boundary. */
if|if
condition|(
name|P2PHASE
argument_list|(
name|offset
argument_list|,
name|DEV_BSIZE
argument_list|)
operator|||
name|P2PHASE
argument_list|(
name|size
argument_list|,
name|DEV_BSIZE
argument_list|)
operator|||
name|P2BOUNDARY
argument_list|(
name|offset
argument_list|,
name|size
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|)
condition|)
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|size
operator|<=
name|zv
operator|->
name|zv_volblocksize
argument_list|)
expr_stmt|;
comment|/* Locate the extent this belongs to */
name|ze
operator|=
name|list_head
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|)
expr_stmt|;
while|while
condition|(
name|offset
operator|>=
name|ze
operator|->
name|ze_nblks
operator|*
name|zv
operator|->
name|zv_volblocksize
condition|)
block|{
name|offset
operator|-=
name|ze
operator|->
name|ze_nblks
operator|*
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
name|ze
operator|=
name|list_next
argument_list|(
operator|&
name|zv
operator|->
name|zv_extents
argument_list|,
name|ze
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ze
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
operator|!
name|ddi_in_panic
argument_list|()
condition|)
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpio_vdev
argument_list|(
name|vd
argument_list|,
name|addr
argument_list|,
name|offset
argument_list|,
name|DVA_GET_OFFSET
argument_list|(
operator|&
name|ze
operator|->
name|ze_dva
argument_list|)
argument_list|,
name|size
argument_list|,
name|doread
argument_list|,
name|isdump
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ddi_in_panic
argument_list|()
condition|)
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_STATE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_strategy
parameter_list|(
name|buf_t
modifier|*
name|bp
parameter_list|)
block|{
name|zfs_soft_state_t
modifier|*
name|zs
init|=
name|NULL
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|uint64_t
name|off
decl_stmt|,
name|volsize
decl_stmt|;
name|size_t
name|resid
decl_stmt|;
name|char
modifier|*
name|addr
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|doread
init|=
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
decl_stmt|;
name|boolean_t
name|is_dumpified
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
if|if
condition|(
name|getminor
argument_list|(
name|bp
operator|->
name|b_edev
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zs
operator|=
name|ddi_get_soft_state
argument_list|(
name|zfsdev_state
argument_list|,
name|getminor
argument_list|(
name|bp
operator|->
name|b_edev
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zs
operator|==
name|NULL
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|zs
operator|->
name|zss_type
operator|!=
name|ZSST_ZVOL
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
name|bioerror
argument_list|(
name|bp
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|zv
operator|=
name|zs
operator|->
name|zss_data
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_READ
operator|)
operator|&&
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
operator|)
condition|)
block|{
name|bioerror
argument_list|(
name|bp
argument_list|,
name|EROFS
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|off
operator|=
name|ldbtob
argument_list|(
name|bp
operator|->
name|b_blkno
argument_list|)
expr_stmt|;
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
name|os
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
name|ASSERT
argument_list|(
name|os
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bp_mapin
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|bp
operator|->
name|b_un
operator|.
name|b_addr
expr_stmt|;
name|resid
operator|=
name|bp
operator|->
name|b_bcount
expr_stmt|;
if|if
condition|(
name|resid
operator|>
literal|0
operator|&&
operator|(
name|off
operator|<
literal|0
operator|||
name|off
operator|>=
name|volsize
operator|)
condition|)
block|{
name|bioerror
argument_list|(
name|bp
argument_list|,
name|EIO
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|is_dumpified
operator|=
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
expr_stmt|;
name|sync
operator|=
operator|(
operator|(
operator|!
operator|(
name|bp
operator|->
name|b_flags
operator|&
name|B_ASYNC
operator|)
operator|&&
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
operator|)
operator|||
operator|(
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
operator|)
operator|&&
operator|!
name|doread
operator|&&
operator|!
name|is_dumpified
expr_stmt|;
comment|/* 	 * There must be no buffer changes when doing a dmu_sync() because 	 * we can't change the data whilst calculating the checksum. 	 */
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
name|doread
condition|?
name|RL_READER
else|:
name|RL_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
operator|!=
literal|0
operator|&&
name|off
operator|<
name|volsize
condition|)
block|{
name|size_t
name|size
init|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|zvol_maxphys
argument_list|)
decl_stmt|;
if|if
condition|(
name|is_dumpified
condition|)
block|{
name|size
operator|=
name|MIN
argument_list|(
name|size
argument_list|,
name|P2END
argument_list|(
name|off
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|)
operator|-
name|off
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpio
argument_list|(
name|zv
argument_list|,
name|addr
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|doread
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|doread
condition|)
block|{
name|error
operator|=
name|dmu_read
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|,
name|DMU_READ_PREFETCH
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dmu_write
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|addr
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|size
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
name|off
operator|+=
name|size
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
name|resid
operator|-=
name|size
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|->
name|b_resid
operator|=
name|resid
operator|)
operator|==
name|bp
operator|->
name|b_bcount
condition|)
name|bioerror
argument_list|(
name|bp
argument_list|,
name|off
operator|>
name|volsize
condition|?
name|EINVAL
else|:
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
condition|)
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|biodone
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the buffer count to the zvol maximum transfer.  * Using our own routine instead of the default minphys()  * means that for larger writes we write bigger buffers on X86  * (128K instead of 56K) and flush the disk write cache less often  * (every zvol_maxphys - currently 1MB) instead of minphys (currently  * 56K on X86 and 128K on sparc).  */
end_comment

begin_function
name|void
name|zvol_minphys
parameter_list|(
name|struct
name|buf
modifier|*
name|bp
parameter_list|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_bcount
operator|>
name|zvol_maxphys
condition|)
name|bp
operator|->
name|b_bcount
operator|=
name|zvol_maxphys
expr_stmt|;
block|}
end_function

begin_function
name|int
name|zvol_dump
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|daddr_t
name|blkno
parameter_list|,
name|int
name|nblocks
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|uint64_t
name|boff
decl_stmt|;
name|uint64_t
name|resid
decl_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
if|if
condition|(
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|boff
operator|=
name|ldbtob
argument_list|(
name|blkno
argument_list|)
expr_stmt|;
name|resid
operator|=
name|ldbtob
argument_list|(
name|nblocks
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|boff
operator|+
name|resid
argument_list|,
operator|<=
argument_list|,
name|zv
operator|->
name|zv_volsize
argument_list|)
expr_stmt|;
while|while
condition|(
name|resid
condition|)
block|{
name|size
operator|=
name|MIN
argument_list|(
name|resid
argument_list|,
name|P2END
argument_list|(
name|boff
argument_list|,
name|zv
operator|->
name|zv_volblocksize
argument_list|)
operator|-
name|boff
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpio
argument_list|(
name|zv
argument_list|,
name|addr
argument_list|,
name|boff
argument_list|,
name|size
argument_list|,
name|B_FALSE
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
name|boff
operator|+=
name|size
expr_stmt|;
name|addr
operator|+=
name|size
expr_stmt|;
name|resid
operator|-=
name|size
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|zvol_read
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|(
name|uio
operator|->
name|uio_loffset
operator|<
literal|0
operator|||
name|uio
operator|->
name|uio_loffset
operator|>=
name|volsize
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
block|{
name|error
operator|=
name|physio
argument_list|(
name|zvol_strategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_READ
argument_list|,
name|zvol_minphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|RL_READER
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_loffset
operator|<
name|volsize
condition|)
block|{
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|DMU_MAX_ACCESS
operator|>>
literal|1
argument_list|)
decl_stmt|;
comment|/* don't read past the end */
if|if
condition|(
name|bytes
operator|>
name|volsize
operator|-
name|uio
operator|->
name|uio_loffset
condition|)
name|bytes
operator|=
name|volsize
operator|-
name|uio
operator|->
name|uio_loffset
expr_stmt|;
name|error
operator|=
name|dmu_read_uio
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|uio
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
comment|/* convert checksum errors into IO errors */
if|if
condition|(
name|error
operator|==
name|ECKSUM
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|zvol_write
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|uio_t
modifier|*
name|uio
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|minor_t
name|minor
init|=
name|getminor
argument_list|(
name|dev
argument_list|)
decl_stmt|;
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|uint64_t
name|volsize
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|boolean_t
name|sync
decl_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
name|volsize
operator|=
name|zv
operator|->
name|zv_volsize
expr_stmt|;
if|if
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
operator|(
name|uio
operator|->
name|uio_loffset
operator|<
literal|0
operator|||
name|uio
operator|->
name|uio_loffset
operator|>=
name|volsize
operator|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
block|{
name|error
operator|=
name|physio
argument_list|(
name|zvol_strategy
argument_list|,
name|NULL
argument_list|,
name|dev
argument_list|,
name|B_WRITE
argument_list|,
name|zvol_minphys
argument_list|,
name|uio
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|sync
operator|=
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
operator|||
operator|(
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|uio
operator|->
name|uio_loffset
argument_list|,
name|uio
operator|->
name|uio_resid
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
while|while
condition|(
name|uio
operator|->
name|uio_resid
operator|>
literal|0
operator|&&
name|uio
operator|->
name|uio_loffset
operator|<
name|volsize
condition|)
block|{
name|uint64_t
name|bytes
init|=
name|MIN
argument_list|(
name|uio
operator|->
name|uio_resid
argument_list|,
name|DMU_MAX_ACCESS
operator|>>
literal|1
argument_list|)
decl_stmt|;
name|uint64_t
name|off
init|=
name|uio
operator|->
name|uio_loffset
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
decl_stmt|;
if|if
condition|(
name|bytes
operator|>
name|volsize
operator|-
name|off
condition|)
comment|/* don't write past the end */
name|bytes
operator|=
name|volsize
operator|-
name|off
expr_stmt|;
name|dmu_tx_hold_write
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
break|break;
block|}
name|error
operator|=
name|dmu_write_uio_dbuf
argument_list|(
name|zv
operator|->
name|zv_dbuf
argument_list|,
name|uio
argument_list|,
name|bytes
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|bytes
argument_list|,
name|sync
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
if|if
condition|(
name|sync
condition|)
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_getefi
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|uint64_t
name|vs
parameter_list|,
name|uint8_t
name|bs
parameter_list|)
block|{
name|struct
name|uuid
name|uuid
init|=
name|EFI_RESERVED
decl_stmt|;
name|efi_gpe_t
name|gpe
init|=
block|{
literal|0
block|}
decl_stmt|;
name|uint32_t
name|crc
decl_stmt|;
name|dk_efi_t
name|efi
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|ddi_copyin
argument_list|(
name|arg
argument_list|,
operator|&
name|efi
argument_list|,
sizeof|sizeof
argument_list|(
name|dk_efi_t
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
name|ptr
operator|=
operator|(
name|char
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|efi
operator|.
name|dki_data_64
expr_stmt|;
name|length
operator|=
name|efi
operator|.
name|dki_length
expr_stmt|;
comment|/* 	 * Some clients may attempt to request a PMBR for the 	 * zvol.  Currently this interface will return EINVAL to 	 * such requests.  These requests could be supported by 	 * adding a check for lba == 0 and consing up an appropriate 	 * PMBR. 	 */
if|if
condition|(
name|efi
operator|.
name|dki_lba
operator|<
literal|1
operator|||
name|efi
operator|.
name|dki_lba
operator|>
literal|2
operator|||
name|length
operator|<=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|gpe
operator|.
name|efi_gpe_StartingLBA
operator|=
name|LE_64
argument_list|(
literal|34ULL
argument_list|)
expr_stmt|;
name|gpe
operator|.
name|efi_gpe_EndingLBA
operator|=
name|LE_64
argument_list|(
operator|(
name|vs
operator|>>
name|bs
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|UUID_LE_CONVERT
argument_list|(
name|gpe
operator|.
name|efi_gpe_PartitionTypeGUID
argument_list|,
name|uuid
argument_list|)
expr_stmt|;
if|if
condition|(
name|efi
operator|.
name|dki_lba
operator|==
literal|1
condition|)
block|{
name|efi_gpt_t
name|gpt
init|=
block|{
literal|0
block|}
decl_stmt|;
name|gpt
operator|.
name|efi_gpt_Signature
operator|=
name|LE_64
argument_list|(
name|EFI_SIGNATURE
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_Revision
operator|=
name|LE_32
argument_list|(
name|EFI_VERSION_CURRENT
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_HeaderSize
operator|=
name|LE_32
argument_list|(
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_MyLBA
operator|=
name|LE_64
argument_list|(
literal|1ULL
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_FirstUsableLBA
operator|=
name|LE_64
argument_list|(
literal|34ULL
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_LastUsableLBA
operator|=
name|LE_64
argument_list|(
operator|(
name|vs
operator|>>
name|bs
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_PartitionEntryLBA
operator|=
name|LE_64
argument_list|(
literal|2ULL
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_NumberOfPartitionEntries
operator|=
name|LE_32
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_SizeOfPartitionEntry
operator|=
name|LE_32
argument_list|(
sizeof|sizeof
argument_list|(
name|efi_gpe_t
argument_list|)
argument_list|)
expr_stmt|;
name|CRC32
argument_list|(
name|crc
argument_list|,
operator|&
name|gpe
argument_list|,
sizeof|sizeof
argument_list|(
name|gpe
argument_list|)
argument_list|,
operator|-
literal|1U
argument_list|,
name|crc32_table
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_PartitionEntryArrayCRC32
operator|=
name|LE_32
argument_list|(
operator|~
name|crc
argument_list|)
expr_stmt|;
name|CRC32
argument_list|(
name|crc
argument_list|,
operator|&
name|gpt
argument_list|,
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
argument_list|,
operator|-
literal|1U
argument_list|,
name|crc32_table
argument_list|)
expr_stmt|;
name|gpt
operator|.
name|efi_gpt_HeaderCRC32
operator|=
name|LE_32
argument_list|(
operator|~
name|crc
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|gpt
argument_list|,
name|ptr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
argument_list|,
name|length
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
name|ptr
operator|+=
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
expr_stmt|;
name|length
operator|-=
sizeof|sizeof
argument_list|(
name|gpt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|length
operator|>
literal|0
operator|&&
name|ddi_copyout
argument_list|(
operator|&
name|gpe
argument_list|,
name|ptr
argument_list|,
name|MIN
argument_list|(
sizeof|sizeof
argument_list|(
name|gpe
argument_list|)
argument_list|,
name|length
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * BEGIN entry points to allow external callers access to the volume.  */
end_comment

begin_comment
comment|/*  * Return the volume parameters needed for access from an external caller.  * These values are invariant as long as the volume is held open.  */
end_comment

begin_function
name|int
name|zvol_get_volume_params
parameter_list|(
name|minor_t
name|minor
parameter_list|,
name|uint64_t
modifier|*
name|blksize
parameter_list|,
name|uint64_t
modifier|*
name|max_xfer_len
parameter_list|,
name|void
modifier|*
modifier|*
name|minor_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|objset_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|zil_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|rl_hdl
parameter_list|,
name|void
modifier|*
modifier|*
name|bonus_hdl
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|minor
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|blksize
operator|&&
name|max_xfer_len
operator|&&
name|minor_hdl
operator|&&
name|objset_hdl
operator|&&
name|zil_hdl
operator|&&
name|rl_hdl
operator|&&
name|bonus_hdl
argument_list|)
expr_stmt|;
operator|*
name|blksize
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
operator|*
name|max_xfer_len
operator|=
operator|(
name|uint64_t
operator|)
name|zvol_maxphys
expr_stmt|;
operator|*
name|minor_hdl
operator|=
name|zv
expr_stmt|;
operator|*
name|objset_hdl
operator|=
name|zv
operator|->
name|zv_objset
expr_stmt|;
operator|*
name|zil_hdl
operator|=
name|zv
operator|->
name|zv_zilog
expr_stmt|;
operator|*
name|rl_hdl
operator|=
operator|&
name|zv
operator|->
name|zv_znode
expr_stmt|;
operator|*
name|bonus_hdl
operator|=
name|zv
operator|->
name|zv_dbuf
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current volume size to an external caller.  * The size can change while the volume is open.  */
end_comment

begin_function
name|uint64_t
name|zvol_get_volume_size
parameter_list|(
name|void
modifier|*
name|minor_hdl
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|minor_hdl
decl_stmt|;
return|return
operator|(
name|zv
operator|->
name|zv_volsize
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the current WCE setting to an external caller.  * The WCE setting can change while the volume is open.  */
end_comment

begin_function
name|int
name|zvol_get_volume_wce
parameter_list|(
name|void
modifier|*
name|minor_hdl
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|minor_hdl
decl_stmt|;
return|return
operator|(
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Entry point for external callers to zvol_log_write  */
end_comment

begin_function
name|void
name|zvol_log_write_minor
parameter_list|(
name|void
modifier|*
name|minor_hdl
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|ssize_t
name|resid
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
init|=
name|minor_hdl
decl_stmt|;
name|zvol_log_write
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|off
argument_list|,
name|resid
argument_list|,
name|sync
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * END entry points to allow external callers access to the volume.  */
end_comment

begin_comment
comment|/*  * Log a DKIOCFREE/free-long-range to the ZIL with TX_TRUNCATE.  */
end_comment

begin_function
specifier|static
name|void
name|zvol_log_truncate
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|uint64_t
name|off
parameter_list|,
name|uint64_t
name|len
parameter_list|,
name|boolean_t
name|sync
parameter_list|)
block|{
name|itx_t
modifier|*
name|itx
decl_stmt|;
name|lr_truncate_t
modifier|*
name|lr
decl_stmt|;
name|zilog_t
modifier|*
name|zilog
init|=
name|zv
operator|->
name|zv_zilog
decl_stmt|;
if|if
condition|(
name|zil_replaying
argument_list|(
name|zilog
argument_list|,
name|tx
argument_list|)
condition|)
return|return;
name|itx
operator|=
name|zil_itx_create
argument_list|(
name|TX_TRUNCATE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|lr
argument_list|)
argument_list|)
expr_stmt|;
name|lr
operator|=
operator|(
name|lr_truncate_t
operator|*
operator|)
operator|&
name|itx
operator|->
name|itx_lr
expr_stmt|;
name|lr
operator|->
name|lr_foid
operator|=
name|ZVOL_OBJ
expr_stmt|;
name|lr
operator|->
name|lr_offset
operator|=
name|off
expr_stmt|;
name|lr
operator|->
name|lr_length
operator|=
name|len
expr_stmt|;
name|itx
operator|->
name|itx_sync
operator|=
name|sync
expr_stmt|;
name|zil_itx_assign
argument_list|(
name|zilog
argument_list|,
name|itx
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Dirtbag ioctls to support mkfs(1M) for UFS filesystems.  See dkio(7I).  * Also a dirtbag dkio ioctl for unmap/free-block functionality.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|zvol_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|intptr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|rvalp
parameter_list|)
block|{
name|zvol_state_t
modifier|*
name|zv
decl_stmt|;
name|struct
name|dk_callback
modifier|*
name|dkc
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|rl_t
modifier|*
name|rl
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zv
operator|=
name|zfsdev_get_soft_state
argument_list|(
name|getminor
argument_list|(
name|dev
argument_list|)
argument_list|,
name|ZSST_ZVOL
argument_list|)
expr_stmt|;
if|if
condition|(
name|zv
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|zv
operator|->
name|zv_total_opens
operator|>
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DKIOCINFO
case|:
block|{
name|struct
name|dk_cinfo
name|dki
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dki
argument_list|,
sizeof|sizeof
argument_list|(
name|dki
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dki
operator|.
name|dki_cname
argument_list|,
literal|"zvol"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dki
operator|.
name|dki_dname
argument_list|,
literal|"zvol"
argument_list|)
expr_stmt|;
name|dki
operator|.
name|dki_ctype
operator|=
name|DKC_UNKNOWN
expr_stmt|;
name|dki
operator|.
name|dki_unit
operator|=
name|getminor
argument_list|(
name|dev
argument_list|)
expr_stmt|;
name|dki
operator|.
name|dki_maxtransfer
operator|=
literal|1
operator|<<
operator|(
name|SPA_OLD_MAXBLOCKSHIFT
operator|-
name|zv
operator|->
name|zv_min_bs
operator|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|dki
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dki
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCGMEDIAINFO
case|:
block|{
name|struct
name|dk_minfo
name|dkm
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dkm
argument_list|,
sizeof|sizeof
argument_list|(
name|dkm
argument_list|)
argument_list|)
expr_stmt|;
name|dkm
operator|.
name|dki_lbsize
operator|=
literal|1U
operator|<<
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkm
operator|.
name|dki_capacity
operator|=
name|zv
operator|->
name|zv_volsize
operator|>>
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkm
operator|.
name|dki_media_type
operator|=
name|DK_UNKNOWN
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|dkm
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dkm
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCGMEDIAINFOEXT
case|:
block|{
name|struct
name|dk_minfo_ext
name|dkmext
decl_stmt|;
name|bzero
argument_list|(
operator|&
name|dkmext
argument_list|,
sizeof|sizeof
argument_list|(
name|dkmext
argument_list|)
argument_list|)
expr_stmt|;
name|dkmext
operator|.
name|dki_lbsize
operator|=
literal|1U
operator|<<
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkmext
operator|.
name|dki_pbsize
operator|=
name|zv
operator|->
name|zv_volblocksize
expr_stmt|;
name|dkmext
operator|.
name|dki_capacity
operator|=
name|zv
operator|->
name|zv_volsize
operator|>>
name|zv
operator|->
name|zv_min_bs
expr_stmt|;
name|dkmext
operator|.
name|dki_media_type
operator|=
name|DK_UNKNOWN
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|dkmext
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|dkmext
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCGETEFI
case|:
block|{
name|uint64_t
name|vs
init|=
name|zv
operator|->
name|zv_volsize
decl_stmt|;
name|uint8_t
name|bs
init|=
name|zv
operator|->
name|zv_min_bs
decl_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_getefi
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
name|flag
argument_list|,
name|vs
argument_list|,
name|bs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
case|case
name|DKIOCFLUSHWRITECACHE
case|:
name|dkc
operator|=
operator|(
expr|struct
name|dk_callback
operator|*
operator|)
name|arg
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flag
operator|&
name|FKIOCTL
operator|)
operator|&&
name|dkc
operator|!=
name|NULL
operator|&&
name|dkc
operator|->
name|dkc_callback
condition|)
block|{
call|(
modifier|*
name|dkc
operator|->
name|dkc_callback
call|)
argument_list|(
name|dkc
operator|->
name|dkc_cookie
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|error
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
case|case
name|DKIOCGETWCE
case|:
block|{
name|int
name|wce
init|=
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
condition|?
literal|1
else|:
literal|0
decl_stmt|;
if|if
condition|(
name|ddi_copyout
argument_list|(
operator|&
name|wce
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|DKIOCSETWCE
case|:
block|{
name|int
name|wce
decl_stmt|;
if|if
condition|(
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|wce
argument_list|,
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|wce
condition|)
block|{
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_WCE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_WCE
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
case|case
name|DKIOCGGEOM
case|:
case|case
name|DKIOCGVTOC
case|:
comment|/* 		 * commands using these (like prtvtoc) expect ENOTSUP 		 * since we're emulating an EFI label 		 */
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCDUMPINIT
case|:
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
literal|0
argument_list|,
name|zv
operator|->
name|zv_volsize
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dumpify
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCDUMPFINI
case|:
if|if
condition|(
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_DUMPIFIED
operator|)
condition|)
break|break;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
literal|0
argument_list|,
name|zv
operator|->
name|zv_volsize
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|error
operator|=
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
break|break;
case|case
name|DKIOCFREE
case|:
block|{
name|dkioc_free_t
name|df
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
if|if
condition|(
operator|!
name|zvol_unmap_enabled
condition|)
break|break;
if|if
condition|(
name|ddi_copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|df
argument_list|,
sizeof|sizeof
argument_list|(
name|df
argument_list|)
argument_list|,
name|flag
argument_list|)
condition|)
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EFAULT
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 		 * Apply Postel's Law to length-checking.  If they overshoot, 		 * just blank out until the end, if there's a need to blank 		 * out anything. 		 */
if|if
condition|(
name|df
operator|.
name|df_start
operator|>=
name|zv
operator|->
name|zv_volsize
condition|)
break|break;
comment|/* No need to do anything... */
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|rl
operator|=
name|zfs_range_lock
argument_list|(
operator|&
name|zv
operator|->
name|zv_znode
argument_list|,
name|df
operator|.
name|df_start
argument_list|,
name|df
operator|.
name|df_length
argument_list|,
name|RL_WRITER
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
expr_stmt|;
name|dmu_tx_mark_netfree
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zvol_log_truncate
argument_list|(
name|zv
argument_list|,
name|tx
argument_list|,
name|df
operator|.
name|df_start
argument_list|,
name|df
operator|.
name|df_length
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|df
operator|.
name|df_start
argument_list|,
name|df
operator|.
name|df_length
argument_list|)
expr_stmt|;
block|}
name|zfs_range_unlock
argument_list|(
name|rl
argument_list|)
expr_stmt|;
comment|/* 		 * If the write-cache is disabled, 'sync' property 		 * is set to 'always', or if the caller is asking for 		 * a synchronous free, commit this operation to the zil. 		 * This will sync any previous uncommitted writes to the 		 * zvol object. 		 * Can be overridden by the zvol_unmap_sync_enabled tunable. 		 */
if|if
condition|(
operator|(
name|error
operator|==
literal|0
operator|)
operator|&&
name|zvol_unmap_sync_enabled
operator|&&
operator|(
operator|!
operator|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_WCE
operator|)
operator|||
operator|(
name|zv
operator|->
name|zv_objset
operator|->
name|os_sync
operator|==
name|ZFS_SYNC_ALWAYS
operator|)
operator|||
operator|(
name|df
operator|.
name|df_flags
operator|&
name|DF_WAIT_SYNC
operator|)
operator|)
condition|)
block|{
name|zil_commit
argument_list|(
name|zv
operator|->
name|zv_zilog
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
default|default:
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOTTY
argument_list|)
expr_stmt|;
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|zvol_busy
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|zvol_minors
operator|!=
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|zvol_init
parameter_list|(
name|void
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|ddi_soft_state_init
argument_list|(
operator|&
name|zfsdev_state
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_soft_state_t
argument_list|)
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zvol_fini
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
expr_stmt|;
name|ddi_soft_state_fini
argument_list|(
operator|&
name|zfsdev_state
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfs_mvdev_dump_feature_check
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
if|if
condition|(
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|zfs_mvdev_dump_activate_feature_sync
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|dmu_tx_pool
argument_list|(
name|tx
argument_list|)
operator|->
name|dp_spa
decl_stmt|;
name|spa_feature_incr
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dump_init
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|,
name|boolean_t
name|resize
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|int
name|error
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|dmu_objset_spa
argument_list|(
name|os
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|spa
operator|->
name|spa_root_vdev
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|version
init|=
name|spa_version
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|uint64_t
name|checksum
decl_stmt|,
name|compress
decl_stmt|,
name|refresrv
decl_stmt|,
name|vbs
decl_stmt|,
name|dedup
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|zfsdev_state_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_root_ops
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_free_long_range
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
comment|/* wait for dmu_free_long_range to actually free the blocks */
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the pool on which the dump device is being initialized has more 	 * than one child vdev, check that the MULTI_VDEV_CRASH_DUMP feature is 	 * enabled.  If so, bump that feature's counter to indicate that the 	 * feature is active. We also check the vdev type to handle the 	 * following case: 	 *   # zpool create test raidz disk1 disk2 disk3 	 *   Now have spa_root_vdev->vdev_children == 1 (the raidz vdev), 	 *   the raidz vdev itself has 3 children. 	 */
if|if
condition|(
name|vd
operator|->
name|vdev_children
operator|>
literal|1
operator|||
name|vd
operator|->
name|vdev_ops
operator|==
operator|&
name|vdev_raidz_ops
condition|)
block|{
if|if
condition|(
operator|!
name|spa_feature_is_enabled
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|dsl_sync_task
argument_list|(
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|zfs_mvdev_dump_feature_check
argument_list|,
name|zfs_mvdev_dump_activate_feature_sync
argument_list|,
name|NULL
argument_list|,
literal|2
argument_list|,
name|ZFS_SPACE_CHECK_RESERVED
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|resize
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
operator|&
name|compress
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
operator|&
name|checksum
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
operator|&
name|refresrv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
operator|&
name|vbs
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dsl_prop_get_integer
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
operator|&
name|dedup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * If we are resizing the dump device then we only need to 	 * update the refreservation to match the newly updated 	 * zvolsize. Otherwise, we save off the original state of the 	 * zvol so that we can restore them if the zvol is ever undumpified. 	 */
if|if
condition|(
name|resize
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zv
operator|->
name|zv_volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|compress
argument_list|,
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|refresrv
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|vbs
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|dmu_object_set_blocksize
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
operator|&&
name|error
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dedup
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|zv
operator|->
name|zv_volblocksize
operator|=
name|SPA_OLD_MAXBLOCKSIZE
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * We only need update the zvol's property if we are initializing 	 * the dump area for the first time. 	 */
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|resize
condition|)
block|{
comment|/* 		 * If MULTI_VDEV_CRASH_DUMP is active, use the NOPARITY checksum 		 * function.  Otherwise, use the old default -- OFF. 		 */
name|checksum
operator|=
name|spa_feature_is_active
argument_list|(
name|spa
argument_list|,
name|SPA_FEATURE_MULTI_VDEV_CRASH_DUMP
argument_list|)
condition|?
name|ZIO_CHECKSUM_NOPARITY
else|:
name|ZIO_CHECKSUM_OFF
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|ZIO_COMPRESS_OFF
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
name|checksum
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
condition|)
block|{
name|VERIFY
argument_list|(
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
name|ZIO_CHECKSUM_OFF
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
name|error
operator|=
name|zfs_set_prop_nvlist
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|,
name|nv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
block|}
comment|/* Allocate the space for the dump */
if|if
condition|(
name|error
operator|==
literal|0
condition|)
name|error
operator|=
name|zvol_prealloc
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dumpify
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|dumpsize
init|=
literal|0
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
if|if
condition|(
name|zv
operator|->
name|zv_flags
operator|&
name|ZVOL_RDONLY
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EROFS
argument_list|)
operator|)
return|;
if|if
condition|(
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dumpsize
argument_list|)
operator|!=
literal|0
operator|||
name|dumpsize
operator|!=
name|zv
operator|->
name|zv_volsize
condition|)
block|{
name|boolean_t
name|resize
init|=
operator|(
name|dumpsize
operator|>
literal|0
operator|)
decl_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|zvol_dump_init
argument_list|(
name|zv
argument_list|,
name|resize
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
comment|/* 	 * Build up our lba mapping. 	 */
name|error
operator|=
name|zvol_get_lbas
argument_list|(
name|zv
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|zv
operator|->
name|zv_flags
operator||=
name|ZVOL_DUMPIFIED
expr_stmt|;
name|error
operator|=
name|zap_update
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|zv
operator|->
name|zv_volsize
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|zvol_dump_fini
argument_list|(
name|zv
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|os
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zvol_dump_fini
parameter_list|(
name|zvol_state_t
modifier|*
name|zv
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|objset_t
modifier|*
name|os
init|=
name|zv
operator|->
name|zv_objset
decl_stmt|;
name|nvlist_t
modifier|*
name|nv
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|uint64_t
name|checksum
decl_stmt|,
name|compress
decl_stmt|,
name|refresrv
decl_stmt|,
name|vbs
decl_stmt|,
name|dedup
decl_stmt|;
name|uint64_t
name|version
init|=
name|spa_version
argument_list|(
name|dmu_objset_spa
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|)
decl_stmt|;
comment|/* 	 * Attempt to restore the zvol back to its pre-dumpified state. 	 * This is a best-effort attempt as it's possible that not all 	 * of these properties were initialized during the dumpify process 	 * (i.e. error during zvol_dump_init). 	 */
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_zap
argument_list|(
name|tx
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|TRUE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|zap_remove
argument_list|(
name|os
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|ZVOL_DUMPSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|checksum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|compress
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|refresrv
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_VOLBLOCKSIZE
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|vbs
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|nvlist_alloc
argument_list|(
operator|&
name|nv
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|KM_SLEEP
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_CHECKSUM
argument_list|)
argument_list|,
name|checksum
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_COMPRESSION
argument_list|)
argument_list|,
name|compress
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_REFRESERVATION
argument_list|)
argument_list|,
name|refresrv
argument_list|)
expr_stmt|;
if|if
condition|(
name|version
operator|>=
name|SPA_VERSION_DEDUP
operator|&&
name|zap_lookup
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|,
name|ZVOL_ZAP_OBJ
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|dedup
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|nvlist_add_uint64
argument_list|(
name|nv
argument_list|,
name|zfs_prop_to_name
argument_list|(
name|ZFS_PROP_DEDUP
argument_list|)
argument_list|,
name|dedup
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|zfs_set_prop_nvlist
argument_list|(
name|zv
operator|->
name|zv_name
argument_list|,
name|ZPROP_SRC_LOCAL
argument_list|,
name|nv
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|nvlist_free
argument_list|(
name|nv
argument_list|)
expr_stmt|;
name|zvol_free_extents
argument_list|(
name|zv
argument_list|)
expr_stmt|;
name|zv
operator|->
name|zv_flags
operator|&=
operator|~
name|ZVOL_DUMPIFIED
expr_stmt|;
operator|(
name|void
operator|)
name|dmu_free_long_range
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
literal|0
argument_list|,
name|DMU_OBJECT_END
argument_list|)
expr_stmt|;
comment|/* wait for dmu_free_long_range to actually free the blocks */
name|txg_wait_synced
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zv
operator|->
name|zv_objset
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create
argument_list|(
name|os
argument_list|)
expr_stmt|;
name|dmu_tx_hold_bonus
argument_list|(
name|tx
argument_list|,
name|ZVOL_OBJ
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_tx_assign
argument_list|(
name|tx
argument_list|,
name|TXG_WAIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|dmu_tx_abort
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|dmu_object_set_blocksize
argument_list|(
name|os
argument_list|,
name|ZVOL_OBJ
argument_list|,
name|vbs
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
condition|)
name|zv
operator|->
name|zv_volblocksize
operator|=
name|vbs
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

