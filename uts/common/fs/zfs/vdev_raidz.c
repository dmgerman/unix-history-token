begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2017 by Delphix. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_disk.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_file.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_raidz.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio_checksum.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/fs/zfs.h>
end_include

begin_comment
comment|/*  * Virtual device vector for RAID-Z.  *  * This vdev supports single, double, and triple parity. For single parity,  * we use a simple XOR of all the data columns. For double or triple parity,  * we use a special case of Reed-Solomon coding. This extends the  * technique described in "The mathematics of RAID-6" by H. Peter Anvin by  * drawing on the system described in "A Tutorial on Reed-Solomon Coding for  * Fault-Tolerance in RAID-like Systems" by James S. Plank on which the  * former is also based. The latter is designed to provide higher performance  * for writes.  *  * Note that the Plank paper claimed to support arbitrary N+M, but was then  * amended six years later identifying a critical flaw that invalidates its  * claims. Nevertheless, the technique can be adapted to work for up to  * triple parity. For additional parity, the amendment "Note: Correction to  * the 1997 Tutorial on Reed-Solomon Coding" by James S. Plank and Ying Ding  * is viable, but the additional complexity means that write performance will  * suffer.  *  * All of the methods above operate on a Galois field, defined over the  * integers mod 2^N. In our case we choose N=8 for GF(8) so that all elements  * can be expressed with a single byte. Briefly, the operations on the  * field are defined as follows:  *  *   o addition (+) is represented by a bitwise XOR  *   o subtraction (-) is therefore identical to addition: A + B = A - B  *   o multiplication of A by 2 is defined by the following bitwise expression:  *  *	(A * 2)_7 = A_6  *	(A * 2)_6 = A_5  *	(A * 2)_5 = A_4  *	(A * 2)_4 = A_3 + A_7  *	(A * 2)_3 = A_2 + A_7  *	(A * 2)_2 = A_1 + A_7  *	(A * 2)_1 = A_0  *	(A * 2)_0 = A_7  *  * In C, multiplying by 2 is therefore ((a<< 1) ^ ((a& 0x80) ? 0x1d : 0)).  * As an aside, this multiplication is derived from the error correcting  * primitive polynomial x^8 + x^4 + x^3 + x^2 + 1.  *  * Observe that any number in the field (except for 0) can be expressed as a  * power of 2 -- a generator for the field. We store a table of the powers of  * 2 and logs base 2 for quick look ups, and exploit the fact that A * B can  * be rewritten as 2^(log_2(A) + log_2(B)) (where '+' is normal addition rather  * than field addition). The inverse of a field element A (A^-1) is therefore  * A ^ (255 - 1) = A^254.  *  * The up-to-three parity columns, P, Q, R over several data columns,  * D_0, ... D_n-1, can be expressed by field operations:  *  *	P = D_0 + D_1 + ... + D_n-2 + D_n-1  *	Q = 2^n-1 * D_0 + 2^n-2 * D_1 + ... + 2^1 * D_n-2 + 2^0 * D_n-1  *	  = ((...((D_0) * 2 + D_1) * 2 + ...) * 2 + D_n-2) * 2 + D_n-1  *	R = 4^n-1 * D_0 + 4^n-2 * D_1 + ... + 4^1 * D_n-2 + 4^0 * D_n-1  *	  = ((...((D_0) * 4 + D_1) * 4 + ...) * 4 + D_n-2) * 4 + D_n-1  *  * We chose 1, 2, and 4 as our generators because 1 corresponds to the trival  * XOR operation, and 2 and 4 can be computed quickly and generate linearly-  * independent coefficients. (There are no additional coefficients that have  * this property which is why the uncorrected Plank method breaks down.)  *  * See the reconstruction code below for how P, Q and R can used individually  * or in concert to recover missing data columns.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|raidz_col
block|{
name|uint64_t
name|rc_devidx
decl_stmt|;
comment|/* child device index for I/O */
name|uint64_t
name|rc_offset
decl_stmt|;
comment|/* device offset */
name|uint64_t
name|rc_size
decl_stmt|;
comment|/* I/O size */
name|abd_t
modifier|*
name|rc_abd
decl_stmt|;
comment|/* I/O data */
name|void
modifier|*
name|rc_gdata
decl_stmt|;
comment|/* used to store the "good" version */
name|int
name|rc_error
decl_stmt|;
comment|/* I/O error for this device */
name|uint8_t
name|rc_tried
decl_stmt|;
comment|/* Did we attempt this I/O column? */
name|uint8_t
name|rc_skipped
decl_stmt|;
comment|/* Did we skip this I/O column? */
block|}
name|raidz_col_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|raidz_map
block|{
name|uint64_t
name|rm_cols
decl_stmt|;
comment|/* Regular column count */
name|uint64_t
name|rm_scols
decl_stmt|;
comment|/* Count including skipped columns */
name|uint64_t
name|rm_bigcols
decl_stmt|;
comment|/* Number of oversized columns */
name|uint64_t
name|rm_asize
decl_stmt|;
comment|/* Actual total I/O size */
name|uint64_t
name|rm_missingdata
decl_stmt|;
comment|/* Count of missing data devices */
name|uint64_t
name|rm_missingparity
decl_stmt|;
comment|/* Count of missing parity devices */
name|uint64_t
name|rm_firstdatacol
decl_stmt|;
comment|/* First data column/parity count */
name|uint64_t
name|rm_nskip
decl_stmt|;
comment|/* Skipped sectors for padding */
name|uint64_t
name|rm_skipstart
decl_stmt|;
comment|/* Column index of padding start */
name|abd_t
modifier|*
name|rm_abd_copy
decl_stmt|;
comment|/* rm_asize-buffer of copied data */
name|uintptr_t
name|rm_reports
decl_stmt|;
comment|/* # of referencing checksum reports */
name|uint8_t
name|rm_freed
decl_stmt|;
comment|/* map no longer has referencing ZIO */
name|uint8_t
name|rm_ecksuminjected
decl_stmt|;
comment|/* checksum error was injected */
name|raidz_col_t
name|rm_col
index|[
literal|1
index|]
decl_stmt|;
comment|/* Flexible array of I/O columns */
block|}
name|raidz_map_t
typedef|;
end_typedef

begin_define
define|#
directive|define
name|VDEV_RAIDZ_P
value|0
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_Q
value|1
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_R
value|2
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_MUL_2
parameter_list|(
name|x
parameter_list|)
value|(((x)<< 1) ^ (((x)& 0x80) ? 0x1d : 0))
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_MUL_4
parameter_list|(
name|x
parameter_list|)
value|(VDEV_RAIDZ_MUL_2(VDEV_RAIDZ_MUL_2(x)))
end_define

begin_comment
comment|/*  * We provide a mechanism to perform the field multiplication operation on a  * 64-bit value all at once rather than a byte at a time. This works by  * creating a mask from the top bit in each byte and using that to  * conditionally apply the XOR of 0x1d.  */
end_comment

begin_define
define|#
directive|define
name|VDEV_RAIDZ_64MUL_2
parameter_list|(
name|x
parameter_list|,
name|mask
parameter_list|)
define|\
value|{ \ 	(mask) = (x)& 0x8080808080808080ULL; \ 	(mask) = ((mask)<< 1) - ((mask)>> 7); \ 	(x) = (((x)<< 1)& 0xfefefefefefefefeULL) ^ \ 	    ((mask)& 0x1d1d1d1d1d1d1d1d); \ }
end_define

begin_define
define|#
directive|define
name|VDEV_RAIDZ_64MUL_4
parameter_list|(
name|x
parameter_list|,
name|mask
parameter_list|)
define|\
value|{ \ 	VDEV_RAIDZ_64MUL_2((x), mask); \ 	VDEV_RAIDZ_64MUL_2((x), mask); \ }
end_define

begin_define
define|#
directive|define
name|VDEV_LABEL_OFFSET
parameter_list|(
name|x
parameter_list|)
value|(x + VDEV_LABEL_START_SIZE)
end_define

begin_comment
comment|/*  * Force reconstruction to use the general purpose method.  */
end_comment

begin_decl_stmt
name|int
name|vdev_raidz_default_to_general
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Powers of 2 in the Galois field defined above. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_pow2
index|[
literal|256
index|]
init|=
block|{
literal|0x01
block|,
literal|0x02
block|,
literal|0x04
block|,
literal|0x08
block|,
literal|0x10
block|,
literal|0x20
block|,
literal|0x40
block|,
literal|0x80
block|,
literal|0x1d
block|,
literal|0x3a
block|,
literal|0x74
block|,
literal|0xe8
block|,
literal|0xcd
block|,
literal|0x87
block|,
literal|0x13
block|,
literal|0x26
block|,
literal|0x4c
block|,
literal|0x98
block|,
literal|0x2d
block|,
literal|0x5a
block|,
literal|0xb4
block|,
literal|0x75
block|,
literal|0xea
block|,
literal|0xc9
block|,
literal|0x8f
block|,
literal|0x03
block|,
literal|0x06
block|,
literal|0x0c
block|,
literal|0x18
block|,
literal|0x30
block|,
literal|0x60
block|,
literal|0xc0
block|,
literal|0x9d
block|,
literal|0x27
block|,
literal|0x4e
block|,
literal|0x9c
block|,
literal|0x25
block|,
literal|0x4a
block|,
literal|0x94
block|,
literal|0x35
block|,
literal|0x6a
block|,
literal|0xd4
block|,
literal|0xb5
block|,
literal|0x77
block|,
literal|0xee
block|,
literal|0xc1
block|,
literal|0x9f
block|,
literal|0x23
block|,
literal|0x46
block|,
literal|0x8c
block|,
literal|0x05
block|,
literal|0x0a
block|,
literal|0x14
block|,
literal|0x28
block|,
literal|0x50
block|,
literal|0xa0
block|,
literal|0x5d
block|,
literal|0xba
block|,
literal|0x69
block|,
literal|0xd2
block|,
literal|0xb9
block|,
literal|0x6f
block|,
literal|0xde
block|,
literal|0xa1
block|,
literal|0x5f
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xc2
block|,
literal|0x99
block|,
literal|0x2f
block|,
literal|0x5e
block|,
literal|0xbc
block|,
literal|0x65
block|,
literal|0xca
block|,
literal|0x89
block|,
literal|0x0f
block|,
literal|0x1e
block|,
literal|0x3c
block|,
literal|0x78
block|,
literal|0xf0
block|,
literal|0xfd
block|,
literal|0xe7
block|,
literal|0xd3
block|,
literal|0xbb
block|,
literal|0x6b
block|,
literal|0xd6
block|,
literal|0xb1
block|,
literal|0x7f
block|,
literal|0xfe
block|,
literal|0xe1
block|,
literal|0xdf
block|,
literal|0xa3
block|,
literal|0x5b
block|,
literal|0xb6
block|,
literal|0x71
block|,
literal|0xe2
block|,
literal|0xd9
block|,
literal|0xaf
block|,
literal|0x43
block|,
literal|0x86
block|,
literal|0x11
block|,
literal|0x22
block|,
literal|0x44
block|,
literal|0x88
block|,
literal|0x0d
block|,
literal|0x1a
block|,
literal|0x34
block|,
literal|0x68
block|,
literal|0xd0
block|,
literal|0xbd
block|,
literal|0x67
block|,
literal|0xce
block|,
literal|0x81
block|,
literal|0x1f
block|,
literal|0x3e
block|,
literal|0x7c
block|,
literal|0xf8
block|,
literal|0xed
block|,
literal|0xc7
block|,
literal|0x93
block|,
literal|0x3b
block|,
literal|0x76
block|,
literal|0xec
block|,
literal|0xc5
block|,
literal|0x97
block|,
literal|0x33
block|,
literal|0x66
block|,
literal|0xcc
block|,
literal|0x85
block|,
literal|0x17
block|,
literal|0x2e
block|,
literal|0x5c
block|,
literal|0xb8
block|,
literal|0x6d
block|,
literal|0xda
block|,
literal|0xa9
block|,
literal|0x4f
block|,
literal|0x9e
block|,
literal|0x21
block|,
literal|0x42
block|,
literal|0x84
block|,
literal|0x15
block|,
literal|0x2a
block|,
literal|0x54
block|,
literal|0xa8
block|,
literal|0x4d
block|,
literal|0x9a
block|,
literal|0x29
block|,
literal|0x52
block|,
literal|0xa4
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0x49
block|,
literal|0x92
block|,
literal|0x39
block|,
literal|0x72
block|,
literal|0xe4
block|,
literal|0xd5
block|,
literal|0xb7
block|,
literal|0x73
block|,
literal|0xe6
block|,
literal|0xd1
block|,
literal|0xbf
block|,
literal|0x63
block|,
literal|0xc6
block|,
literal|0x91
block|,
literal|0x3f
block|,
literal|0x7e
block|,
literal|0xfc
block|,
literal|0xe5
block|,
literal|0xd7
block|,
literal|0xb3
block|,
literal|0x7b
block|,
literal|0xf6
block|,
literal|0xf1
block|,
literal|0xff
block|,
literal|0xe3
block|,
literal|0xdb
block|,
literal|0xab
block|,
literal|0x4b
block|,
literal|0x96
block|,
literal|0x31
block|,
literal|0x62
block|,
literal|0xc4
block|,
literal|0x95
block|,
literal|0x37
block|,
literal|0x6e
block|,
literal|0xdc
block|,
literal|0xa5
block|,
literal|0x57
block|,
literal|0xae
block|,
literal|0x41
block|,
literal|0x82
block|,
literal|0x19
block|,
literal|0x32
block|,
literal|0x64
block|,
literal|0xc8
block|,
literal|0x8d
block|,
literal|0x07
block|,
literal|0x0e
block|,
literal|0x1c
block|,
literal|0x38
block|,
literal|0x70
block|,
literal|0xe0
block|,
literal|0xdd
block|,
literal|0xa7
block|,
literal|0x53
block|,
literal|0xa6
block|,
literal|0x51
block|,
literal|0xa2
block|,
literal|0x59
block|,
literal|0xb2
block|,
literal|0x79
block|,
literal|0xf2
block|,
literal|0xf9
block|,
literal|0xef
block|,
literal|0xc3
block|,
literal|0x9b
block|,
literal|0x2b
block|,
literal|0x56
block|,
literal|0xac
block|,
literal|0x45
block|,
literal|0x8a
block|,
literal|0x09
block|,
literal|0x12
block|,
literal|0x24
block|,
literal|0x48
block|,
literal|0x90
block|,
literal|0x3d
block|,
literal|0x7a
block|,
literal|0xf4
block|,
literal|0xf5
block|,
literal|0xf7
block|,
literal|0xf3
block|,
literal|0xfb
block|,
literal|0xeb
block|,
literal|0xcb
block|,
literal|0x8b
block|,
literal|0x0b
block|,
literal|0x16
block|,
literal|0x2c
block|,
literal|0x58
block|,
literal|0xb0
block|,
literal|0x7d
block|,
literal|0xfa
block|,
literal|0xe9
block|,
literal|0xcf
block|,
literal|0x83
block|,
literal|0x1b
block|,
literal|0x36
block|,
literal|0x6c
block|,
literal|0xd8
block|,
literal|0xad
block|,
literal|0x47
block|,
literal|0x8e
block|,
literal|0x01
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Logs of 2 in the Galois field defined above. */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|uint8_t
name|vdev_raidz_log2
index|[
literal|256
index|]
init|=
block|{
literal|0x00
block|,
literal|0x00
block|,
literal|0x01
block|,
literal|0x19
block|,
literal|0x02
block|,
literal|0x32
block|,
literal|0x1a
block|,
literal|0xc6
block|,
literal|0x03
block|,
literal|0xdf
block|,
literal|0x33
block|,
literal|0xee
block|,
literal|0x1b
block|,
literal|0x68
block|,
literal|0xc7
block|,
literal|0x4b
block|,
literal|0x04
block|,
literal|0x64
block|,
literal|0xe0
block|,
literal|0x0e
block|,
literal|0x34
block|,
literal|0x8d
block|,
literal|0xef
block|,
literal|0x81
block|,
literal|0x1c
block|,
literal|0xc1
block|,
literal|0x69
block|,
literal|0xf8
block|,
literal|0xc8
block|,
literal|0x08
block|,
literal|0x4c
block|,
literal|0x71
block|,
literal|0x05
block|,
literal|0x8a
block|,
literal|0x65
block|,
literal|0x2f
block|,
literal|0xe1
block|,
literal|0x24
block|,
literal|0x0f
block|,
literal|0x21
block|,
literal|0x35
block|,
literal|0x93
block|,
literal|0x8e
block|,
literal|0xda
block|,
literal|0xf0
block|,
literal|0x12
block|,
literal|0x82
block|,
literal|0x45
block|,
literal|0x1d
block|,
literal|0xb5
block|,
literal|0xc2
block|,
literal|0x7d
block|,
literal|0x6a
block|,
literal|0x27
block|,
literal|0xf9
block|,
literal|0xb9
block|,
literal|0xc9
block|,
literal|0x9a
block|,
literal|0x09
block|,
literal|0x78
block|,
literal|0x4d
block|,
literal|0xe4
block|,
literal|0x72
block|,
literal|0xa6
block|,
literal|0x06
block|,
literal|0xbf
block|,
literal|0x8b
block|,
literal|0x62
block|,
literal|0x66
block|,
literal|0xdd
block|,
literal|0x30
block|,
literal|0xfd
block|,
literal|0xe2
block|,
literal|0x98
block|,
literal|0x25
block|,
literal|0xb3
block|,
literal|0x10
block|,
literal|0x91
block|,
literal|0x22
block|,
literal|0x88
block|,
literal|0x36
block|,
literal|0xd0
block|,
literal|0x94
block|,
literal|0xce
block|,
literal|0x8f
block|,
literal|0x96
block|,
literal|0xdb
block|,
literal|0xbd
block|,
literal|0xf1
block|,
literal|0xd2
block|,
literal|0x13
block|,
literal|0x5c
block|,
literal|0x83
block|,
literal|0x38
block|,
literal|0x46
block|,
literal|0x40
block|,
literal|0x1e
block|,
literal|0x42
block|,
literal|0xb6
block|,
literal|0xa3
block|,
literal|0xc3
block|,
literal|0x48
block|,
literal|0x7e
block|,
literal|0x6e
block|,
literal|0x6b
block|,
literal|0x3a
block|,
literal|0x28
block|,
literal|0x54
block|,
literal|0xfa
block|,
literal|0x85
block|,
literal|0xba
block|,
literal|0x3d
block|,
literal|0xca
block|,
literal|0x5e
block|,
literal|0x9b
block|,
literal|0x9f
block|,
literal|0x0a
block|,
literal|0x15
block|,
literal|0x79
block|,
literal|0x2b
block|,
literal|0x4e
block|,
literal|0xd4
block|,
literal|0xe5
block|,
literal|0xac
block|,
literal|0x73
block|,
literal|0xf3
block|,
literal|0xa7
block|,
literal|0x57
block|,
literal|0x07
block|,
literal|0x70
block|,
literal|0xc0
block|,
literal|0xf7
block|,
literal|0x8c
block|,
literal|0x80
block|,
literal|0x63
block|,
literal|0x0d
block|,
literal|0x67
block|,
literal|0x4a
block|,
literal|0xde
block|,
literal|0xed
block|,
literal|0x31
block|,
literal|0xc5
block|,
literal|0xfe
block|,
literal|0x18
block|,
literal|0xe3
block|,
literal|0xa5
block|,
literal|0x99
block|,
literal|0x77
block|,
literal|0x26
block|,
literal|0xb8
block|,
literal|0xb4
block|,
literal|0x7c
block|,
literal|0x11
block|,
literal|0x44
block|,
literal|0x92
block|,
literal|0xd9
block|,
literal|0x23
block|,
literal|0x20
block|,
literal|0x89
block|,
literal|0x2e
block|,
literal|0x37
block|,
literal|0x3f
block|,
literal|0xd1
block|,
literal|0x5b
block|,
literal|0x95
block|,
literal|0xbc
block|,
literal|0xcf
block|,
literal|0xcd
block|,
literal|0x90
block|,
literal|0x87
block|,
literal|0x97
block|,
literal|0xb2
block|,
literal|0xdc
block|,
literal|0xfc
block|,
literal|0xbe
block|,
literal|0x61
block|,
literal|0xf2
block|,
literal|0x56
block|,
literal|0xd3
block|,
literal|0xab
block|,
literal|0x14
block|,
literal|0x2a
block|,
literal|0x5d
block|,
literal|0x9e
block|,
literal|0x84
block|,
literal|0x3c
block|,
literal|0x39
block|,
literal|0x53
block|,
literal|0x47
block|,
literal|0x6d
block|,
literal|0x41
block|,
literal|0xa2
block|,
literal|0x1f
block|,
literal|0x2d
block|,
literal|0x43
block|,
literal|0xd8
block|,
literal|0xb7
block|,
literal|0x7b
block|,
literal|0xa4
block|,
literal|0x76
block|,
literal|0xc4
block|,
literal|0x17
block|,
literal|0x49
block|,
literal|0xec
block|,
literal|0x7f
block|,
literal|0x0c
block|,
literal|0x6f
block|,
literal|0xf6
block|,
literal|0x6c
block|,
literal|0xa1
block|,
literal|0x3b
block|,
literal|0x52
block|,
literal|0x29
block|,
literal|0x9d
block|,
literal|0x55
block|,
literal|0xaa
block|,
literal|0xfb
block|,
literal|0x60
block|,
literal|0x86
block|,
literal|0xb1
block|,
literal|0xbb
block|,
literal|0xcc
block|,
literal|0x3e
block|,
literal|0x5a
block|,
literal|0xcb
block|,
literal|0x59
block|,
literal|0x5f
block|,
literal|0xb0
block|,
literal|0x9c
block|,
literal|0xa9
block|,
literal|0xa0
block|,
literal|0x51
block|,
literal|0x0b
block|,
literal|0xf5
block|,
literal|0x16
block|,
literal|0xeb
block|,
literal|0x7a
block|,
literal|0x75
block|,
literal|0x2c
block|,
literal|0xd7
block|,
literal|0x4f
block|,
literal|0xae
block|,
literal|0xd5
block|,
literal|0xe9
block|,
literal|0xe6
block|,
literal|0xe7
block|,
literal|0xad
block|,
literal|0xe8
block|,
literal|0x74
block|,
literal|0xd6
block|,
literal|0xf4
block|,
literal|0xea
block|,
literal|0xa8
block|,
literal|0x50
block|,
literal|0x58
block|,
literal|0xaf
block|, }
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|vdev_raidz_generate_parity
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Multiply a given number by 2 raised to the given power.  */
end_comment

begin_function
specifier|static
name|uint8_t
name|vdev_raidz_exp2
parameter_list|(
name|uint_t
name|a
parameter_list|,
name|int
name|exp
parameter_list|)
block|{
if|if
condition|(
name|a
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|ASSERT
argument_list|(
name|exp
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vdev_raidz_log2
index|[
name|a
index|]
operator|>
literal|0
operator|||
name|a
operator|==
literal|1
argument_list|)
expr_stmt|;
name|exp
operator|+=
name|vdev_raidz_log2
index|[
name|a
index|]
expr_stmt|;
if|if
condition|(
name|exp
operator|>
literal|255
condition|)
name|exp
operator|-=
literal|255
expr_stmt|;
return|return
operator|(
name|vdev_raidz_pow2
index|[
name|exp
index|]
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_map_free
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|size_t
name|size
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
block|{
name|abd_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_gdata
operator|!=
name|NULL
condition|)
name|zio_buf_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_gdata
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|abd_put
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|size
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
if|if
condition|(
name|rm
operator|->
name|rm_abd_copy
operator|!=
name|NULL
condition|)
name|abd_free
argument_list|(
name|rm
operator|->
name|rm_abd_copy
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rm
argument_list|,
name|offsetof
argument_list|(
name|raidz_map_t
argument_list|,
name|rm_col
index|[
name|rm
operator|->
name|rm_scols
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_map_free_vsd
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|ASSERT0
argument_list|(
name|rm
operator|->
name|rm_freed
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_freed
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_reports
operator|==
literal|0
condition|)
name|vdev_raidz_map_free
argument_list|(
name|rm
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_cksum_free
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|size_t
name|ignored
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
init|=
name|arg
decl_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_reports
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|rm
operator|->
name|rm_reports
operator|==
literal|0
operator|&&
name|rm
operator|->
name|rm_freed
operator|!=
literal|0
condition|)
name|vdev_raidz_map_free
argument_list|(
name|rm
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_cksum_finish
parameter_list|(
name|zio_cksum_report_t
modifier|*
name|zcr
parameter_list|,
specifier|const
name|void
modifier|*
name|good_data
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
init|=
name|zcr
operator|->
name|zcr_cbdata
decl_stmt|;
name|size_t
name|c
init|=
name|zcr
operator|->
name|zcr_cbinfo
decl_stmt|;
name|size_t
name|x
decl_stmt|;
specifier|const
name|char
modifier|*
name|good
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|bad
decl_stmt|;
if|if
condition|(
name|good_data
operator|==
name|NULL
condition|)
block|{
name|zfs_ereport_finish_checksum
argument_list|(
name|zcr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
comment|/* 		 * The first time through, calculate the parity blocks for 		 * the good data (this relies on the fact that the good 		 * data never changes for a given logical ZIO) 		 */
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_gdata
operator|==
name|NULL
condition|)
block|{
name|abd_t
modifier|*
name|bad_parity
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|offset
decl_stmt|;
comment|/* 			 * Set up the rm_col[]s to generate the parity for 			 * good_data, first saving the parity bufs and 			 * replacing them with buffers to hold the result. 			 */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|x
operator|++
control|)
block|{
name|bad_parity
index|[
name|x
index|]
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_gdata
operator|=
name|zio_buf_alloc
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
operator|=
name|abd_get_from_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_gdata
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
comment|/* fill in the data columns from good_data */
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|good_data
expr_stmt|;
for|for
control|(
init|;
name|x
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|x
operator|++
control|)
block|{
name|abd_put
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
operator|=
name|abd_get_from_buf
argument_list|(
name|buf
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|buf
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
comment|/* 			 * Construct the parity from the good data. 			 */
name|vdev_raidz_generate_parity
argument_list|(
name|rm
argument_list|)
expr_stmt|;
comment|/* restore everything back to its original state */
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|x
operator|++
control|)
block|{
name|abd_put
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
operator|=
name|bad_parity
index|[
name|x
index|]
expr_stmt|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|x
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|x
operator|++
control|)
block|{
name|abd_put
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
operator|=
name|abd_get_offset
argument_list|(
name|rm
operator|->
name|rm_abd_copy
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|offset
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
block|}
name|ASSERT3P
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_gdata
argument_list|,
operator|!=
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|good
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_gdata
expr_stmt|;
block|}
else|else
block|{
comment|/* adjust good_data to point at the start of our column */
name|good
operator|=
name|good_data
expr_stmt|;
for|for
control|(
name|x
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|x
operator|<
name|c
condition|;
name|x
operator|++
control|)
name|good
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
name|bad
operator|=
name|abd_borrow_buf_copy
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
comment|/* we drop the ereport if it ends up that the data was good */
name|zfs_ereport_finish_checksum
argument_list|(
name|zcr
argument_list|,
name|good
argument_list|,
name|bad
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|abd_return_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
argument_list|,
name|bad
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Invoked indirectly by zfs_ereport_start_checksum(), called  * below when our read operation fails completely.  The main point  * is to keep a copy of everything we read from disk, so that at  * vdev_raidz_cksum_finish() time we can compare it with the good data.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_cksum_report
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|zio_cksum_report_t
modifier|*
name|zcr
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|size_t
name|c
init|=
operator|(
name|size_t
operator|)
operator|(
name|uintptr_t
operator|)
name|arg
decl_stmt|;
name|size_t
name|offset
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|size_t
name|size
decl_stmt|;
comment|/* set up the report and bump the refcount  */
name|zcr
operator|->
name|zcr_cbdata
operator|=
name|rm
expr_stmt|;
name|zcr
operator|->
name|zcr_cbinfo
operator|=
name|c
expr_stmt|;
name|zcr
operator|->
name|zcr_finish
operator|=
name|vdev_raidz_cksum_finish
expr_stmt|;
name|zcr
operator|->
name|zcr_free
operator|=
name|vdev_raidz_cksum_free
expr_stmt|;
name|rm
operator|->
name|rm_reports
operator|++
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_reports
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_abd_copy
operator|!=
name|NULL
condition|)
return|return;
comment|/* 	 * It's the first time we're called for this raidz_map_t, so we need 	 * to copy the data aside; there's no guarantee that our zio's buffer 	 * won't be re-used for something else. 	 * 	 * Our parity data is already in separate buffers, so there's no need 	 * to copy them. 	 */
name|size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
name|size
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
name|rm
operator|->
name|rm_abd_copy
operator|=
name|abd_alloc_sametype
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|rm
operator|->
name|rm_firstdatacol
index|]
operator|.
name|rc_abd
argument_list|,
name|size
argument_list|)
expr_stmt|;
for|for
control|(
name|offset
operator|=
literal|0
operator|,
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|raidz_col_t
modifier|*
name|col
init|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
decl_stmt|;
name|abd_t
modifier|*
name|tmp
init|=
name|abd_get_offset
argument_list|(
name|rm
operator|->
name|rm_abd_copy
argument_list|,
name|offset
argument_list|)
decl_stmt|;
name|abd_copy
argument_list|(
name|tmp
argument_list|,
name|col
operator|->
name|rc_abd
argument_list|,
name|col
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|abd_put
argument_list|(
name|col
operator|->
name|rc_abd
argument_list|)
expr_stmt|;
name|col
operator|->
name|rc_abd
operator|=
name|tmp
expr_stmt|;
name|offset
operator|+=
name|col
operator|->
name|rc_size
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|offset
argument_list|,
operator|==
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|zio_vsd_ops_t
name|vdev_raidz_vsd_ops
init|=
block|{
name|vdev_raidz_map_free_vsd
block|,
name|vdev_raidz_cksum_report
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Divides the IO evenly across all child vdevs; usually, dcols is  * the number of children in the target vdev.  */
end_comment

begin_function
specifier|static
name|raidz_map_t
modifier|*
name|vdev_raidz_map_alloc
parameter_list|(
name|abd_t
modifier|*
name|abd
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|unit_shift
parameter_list|,
name|uint64_t
name|dcols
parameter_list|,
name|uint64_t
name|nparity
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
decl_stmt|;
comment|/* The starting RAIDZ (parent) vdev sector of the block. */
name|uint64_t
name|b
init|=
name|offset
operator|>>
name|unit_shift
decl_stmt|;
comment|/* The zio's size in units of the vdev's minimum sector size. */
name|uint64_t
name|s
init|=
name|size
operator|>>
name|unit_shift
decl_stmt|;
comment|/* The first column for this stripe. */
name|uint64_t
name|f
init|=
name|b
operator|%
name|dcols
decl_stmt|;
comment|/* The starting byte offset on each child vdev. */
name|uint64_t
name|o
init|=
operator|(
name|b
operator|/
name|dcols
operator|)
operator|<<
name|unit_shift
decl_stmt|;
name|uint64_t
name|q
decl_stmt|,
name|r
decl_stmt|,
name|c
decl_stmt|,
name|bc
decl_stmt|,
name|col
decl_stmt|,
name|acols
decl_stmt|,
name|scols
decl_stmt|,
name|coff
decl_stmt|,
name|devidx
decl_stmt|,
name|asize
decl_stmt|,
name|tot
decl_stmt|;
name|uint64_t
name|off
init|=
literal|0
decl_stmt|;
comment|/* 	 * "Quotient": The number of data sectors for this stripe on all but 	 * the "big column" child vdevs that also contain "remainder" data. 	 */
name|q
operator|=
name|s
operator|/
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
comment|/* 	 * "Remainder": The number of partial stripe data sectors in this I/O. 	 * This will add a sector to some, but not all, child vdevs. 	 */
name|r
operator|=
name|s
operator|-
name|q
operator|*
operator|(
name|dcols
operator|-
name|nparity
operator|)
expr_stmt|;
comment|/* The number of "big columns" - those which contain remainder data. */
name|bc
operator|=
operator|(
name|r
operator|==
literal|0
condition|?
literal|0
else|:
name|r
operator|+
name|nparity
operator|)
expr_stmt|;
comment|/* 	 * The total number of data and parity sectors associated with 	 * this I/O. 	 */
name|tot
operator|=
name|s
operator|+
name|nparity
operator|*
operator|(
name|q
operator|+
operator|(
name|r
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
operator|)
expr_stmt|;
comment|/* acols: The columns that will be accessed. */
comment|/* scols: The columns that will be accessed or skipped. */
if|if
condition|(
name|q
operator|==
literal|0
condition|)
block|{
comment|/* Our I/O request doesn't span all child vdevs. */
name|acols
operator|=
name|bc
expr_stmt|;
name|scols
operator|=
name|MIN
argument_list|(
name|dcols
argument_list|,
name|roundup
argument_list|(
name|bc
argument_list|,
name|nparity
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|acols
operator|=
name|dcols
expr_stmt|;
name|scols
operator|=
name|dcols
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|acols
argument_list|,
operator|<=
argument_list|,
name|scols
argument_list|)
expr_stmt|;
name|rm
operator|=
name|kmem_alloc
argument_list|(
name|offsetof
argument_list|(
name|raidz_map_t
argument_list|,
name|rm_col
index|[
name|scols
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_cols
operator|=
name|acols
expr_stmt|;
name|rm
operator|->
name|rm_scols
operator|=
name|scols
expr_stmt|;
name|rm
operator|->
name|rm_bigcols
operator|=
name|bc
expr_stmt|;
name|rm
operator|->
name|rm_skipstart
operator|=
name|bc
expr_stmt|;
name|rm
operator|->
name|rm_missingdata
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_missingparity
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_firstdatacol
operator|=
name|nparity
expr_stmt|;
name|rm
operator|->
name|rm_abd_copy
operator|=
name|NULL
expr_stmt|;
name|rm
operator|->
name|rm_reports
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_freed
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_ecksuminjected
operator|=
literal|0
expr_stmt|;
name|asize
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|scols
condition|;
name|c
operator|++
control|)
block|{
name|col
operator|=
name|f
operator|+
name|c
expr_stmt|;
name|coff
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|col
operator|>=
name|dcols
condition|)
block|{
name|col
operator|-=
name|dcols
expr_stmt|;
name|coff
operator|+=
literal|1ULL
operator|<<
name|unit_shift
expr_stmt|;
block|}
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_devidx
operator|=
name|col
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_offset
operator|=
name|coff
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
operator|=
name|NULL
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_gdata
operator|=
name|NULL
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_tried
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_skipped
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|c
operator|>=
name|acols
condition|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|<
name|bc
condition|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
operator|(
name|q
operator|+
literal|1
operator|)
operator|<<
name|unit_shift
expr_stmt|;
else|else
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|=
name|q
operator|<<
name|unit_shift
expr_stmt|;
name|asize
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|asize
argument_list|,
operator|==
argument_list|,
name|tot
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_asize
operator|=
name|roundup
argument_list|(
name|asize
argument_list|,
operator|(
name|nparity
operator|+
literal|1
operator|)
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_nskip
operator|=
name|roundup
argument_list|(
name|tot
argument_list|,
name|nparity
operator|+
literal|1
argument_list|)
operator|-
name|tot
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_asize
operator|-
name|asize
argument_list|,
operator|==
argument_list|,
name|rm
operator|->
name|rm_nskip
operator|<<
name|unit_shift
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_nskip
argument_list|,
operator|<=
argument_list|,
name|nparity
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
operator|=
name|abd_alloc_linear
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
operator|=
name|abd_get_offset
argument_list|(
name|abd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|off
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
for|for
control|(
name|c
operator|=
name|c
operator|+
literal|1
init|;
name|c
operator|<
name|acols
condition|;
name|c
operator|++
control|)
block|{
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
operator|=
name|abd_get_offset
argument_list|(
name|abd
argument_list|,
name|off
argument_list|)
expr_stmt|;
name|off
operator|+=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
comment|/* 	 * If all data stored spans all columns, there's a danger that parity 	 * will always be on the same device and, since parity isn't read 	 * during normal operation, that that device's I/O bandwidth won't be 	 * used effectively. We therefore switch the parity every 1MB. 	 * 	 * ... at least that was, ostensibly, the theory. As a practical 	 * matter unless we juggle the parity between all devices evenly, we 	 * won't see any benefit. Further, occasional writes that aren't a 	 * multiple of the LCM of the number of children and the minimum 	 * stripe width are sufficient to avoid pessimal behavior. 	 * Unfortunately, this decision created an implicit on-disk format 	 * requirement that we need to support for all eternity, but only 	 * for single-parity RAID-Z. 	 * 	 * If we intend to skip a sector in the zeroth column for padding 	 * we must make sure to note this swap. We will never intend to 	 * skip the first column since at least one data and one parity 	 * column must appear in each row. 	 */
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_cols
operator|>=
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_firstdatacol
operator|==
literal|1
operator|&&
operator|(
name|offset
operator|&
operator|(
literal|1ULL
operator|<<
literal|20
operator|)
operator|)
condition|)
block|{
name|devidx
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|o
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_offset
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_devidx
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_devidx
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_offset
operator|=
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_offset
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_devidx
operator|=
name|devidx
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
literal|1
index|]
operator|.
name|rc_offset
operator|=
name|o
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_skipstart
operator|==
literal|0
condition|)
name|rm
operator|->
name|rm_skipstart
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rm
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|pqr_struct
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|;
name|uint64_t
modifier|*
name|q
decl_stmt|;
name|uint64_t
modifier|*
name|r
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|vdev_raidz_p_func
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|pqr_struct
modifier|*
name|pqr
init|=
name|private
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|src
init|=
name|buf
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|pqr
operator|->
name|p
operator|&&
operator|!
name|pqr
operator|->
name|q
operator|&&
operator|!
name|pqr
operator|->
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|pqr
operator|->
name|p
operator|++
control|)
operator|*
name|pqr
operator|->
name|p
operator|^=
operator|*
name|src
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_pq_func
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|pqr_struct
modifier|*
name|pqr
init|=
name|private
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|src
init|=
name|buf
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|pqr
operator|->
name|p
operator|&&
name|pqr
operator|->
name|q
operator|&&
operator|!
name|pqr
operator|->
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|pqr
operator|->
name|p
operator|++
operator|,
name|pqr
operator|->
name|q
operator|++
control|)
block|{
operator|*
name|pqr
operator|->
name|p
operator|^=
operator|*
name|src
expr_stmt|;
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|pqr
operator|->
name|q
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|pqr
operator|->
name|q
operator|^=
operator|*
name|src
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_pqr_func
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|pqr_struct
modifier|*
name|pqr
init|=
name|private
decl_stmt|;
specifier|const
name|uint64_t
modifier|*
name|src
init|=
name|buf
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|;
name|int
name|i
decl_stmt|,
name|cnt
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|pqr
operator|->
name|p
operator|&&
name|pqr
operator|->
name|q
operator|&&
name|pqr
operator|->
name|r
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|src
operator|++
operator|,
name|pqr
operator|->
name|p
operator|++
operator|,
name|pqr
operator|->
name|q
operator|++
operator|,
name|pqr
operator|->
name|r
operator|++
control|)
block|{
operator|*
name|pqr
operator|->
name|p
operator|^=
operator|*
name|src
expr_stmt|;
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|pqr
operator|->
name|q
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|pqr
operator|->
name|q
operator|^=
operator|*
name|src
expr_stmt|;
name|VDEV_RAIDZ_64MUL_4
argument_list|(
operator|*
name|pqr
operator|->
name|r
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|pqr
operator|->
name|r
operator|^=
operator|*
name|src
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_p
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|abd_t
modifier|*
name|src
decl_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
expr_stmt|;
name|p
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|abd_copy_to_buf
argument_list|(
name|p
argument_list|,
name|src
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|pqr_struct
name|pqr
init|=
block|{
name|p
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|,
name|vdev_raidz_p_func
argument_list|,
operator|&
name|pqr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_pq
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
name|pcnt
decl_stmt|,
name|ccnt
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|abd_t
modifier|*
name|src
decl_stmt|;
name|pcnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
expr_stmt|;
name|p
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|q
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|ccnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|abd_copy_to_buf
argument_list|(
name|p
argument_list|,
name|src
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|pqr_struct
name|pqr
init|=
block|{
name|p
block|,
name|q
block|,
name|NULL
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|,
name|vdev_raidz_pq_func
argument_list|,
operator|&
name|pqr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ccnt
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|q
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Treat short columns as though they are full of 0s. 			 * Note that there's therefore nothing needed for P. 			 */
for|for
control|(
name|i
operator|=
name|ccnt
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
control|)
block|{
name|VDEV_RAIDZ_64MUL_2
argument_list|(
name|q
index|[
name|i
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity_pqr
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|uint64_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|r
decl_stmt|,
name|pcnt
decl_stmt|,
name|ccnt
decl_stmt|,
name|mask
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|;
name|abd_t
modifier|*
name|src
decl_stmt|;
name|pcnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
operator|==
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_R
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
expr_stmt|;
name|p
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|q
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|r
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_R
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|ccnt
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
operator|/
sizeof|sizeof
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|abd_copy_to_buf
argument_list|(
name|p
argument_list|,
name|src
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memcpy
argument_list|(
name|r
argument_list|,
name|p
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|struct
name|pqr_struct
name|pqr
init|=
block|{
name|p
block|,
name|q
block|,
name|r
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|src
argument_list|,
literal|0
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|,
name|vdev_raidz_pqr_func
argument_list|,
operator|&
name|pqr
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
for|for
control|(
name|i
operator|=
name|ccnt
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
control|)
block|{
name|p
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|q
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|r
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 			 * Treat short columns as though they are full of 0s. 			 * Note that there's therefore nothing needed for P. 			 */
for|for
control|(
name|i
operator|=
name|ccnt
init|;
name|i
operator|<
name|pcnt
condition|;
name|i
operator|++
control|)
block|{
name|VDEV_RAIDZ_64MUL_2
argument_list|(
name|q
index|[
name|i
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
name|VDEV_RAIDZ_64MUL_4
argument_list|(
name|r
index|[
name|i
index|]
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Generate RAID parity in the first virtual columns according to the number of  * parity columns available.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_generate_parity
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
switch|switch
condition|(
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
case|case
literal|1
case|:
name|vdev_raidz_generate_parity_p
argument_list|(
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|vdev_raidz_generate_parity_pq
argument_list|(
name|rm
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|vdev_raidz_generate_parity_pqr
argument_list|(
name|rm
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"invalid RAID-Z configuration"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_raidz_reconst_p_func
parameter_list|(
name|void
modifier|*
name|dbuf
parameter_list|,
name|void
modifier|*
name|sbuf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|uint64_t
modifier|*
name|dst
init|=
name|dbuf
decl_stmt|;
name|uint64_t
modifier|*
name|src
init|=
name|sbuf
decl_stmt|;
name|int
name|cnt
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|src
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
control|)
block|{
name|dst
index|[
name|i
index|]
operator|^=
name|src
index|[
name|i
index|]
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_raidz_reconst_q_pre_func
parameter_list|(
name|void
modifier|*
name|dbuf
parameter_list|,
name|void
modifier|*
name|sbuf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|uint64_t
modifier|*
name|dst
init|=
name|dbuf
decl_stmt|;
name|uint64_t
modifier|*
name|src
init|=
name|sbuf
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|;
name|int
name|cnt
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|dst
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|src
operator|++
control|)
block|{
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|dst
argument_list|,
name|mask
argument_list|)
expr_stmt|;
operator|*
name|dst
operator|^=
operator|*
name|src
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vdev_raidz_reconst_q_pre_tail_func
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|uint64_t
modifier|*
name|dst
init|=
name|buf
decl_stmt|;
name|uint64_t
name|mask
decl_stmt|;
name|int
name|cnt
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|dst
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
control|)
block|{
comment|/* same operation as vdev_raidz_reconst_q_pre_func() on dst */
name|VDEV_RAIDZ_64MUL_2
argument_list|(
operator|*
name|dst
argument_list|,
name|mask
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|reconst_q_struct
block|{
name|uint64_t
modifier|*
name|q
decl_stmt|;
name|int
name|exp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|vdev_raidz_reconst_q_post_func
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|reconst_q_struct
modifier|*
name|rq
init|=
name|private
decl_stmt|;
name|uint64_t
modifier|*
name|dst
init|=
name|buf
decl_stmt|;
name|int
name|cnt
init|=
name|size
operator|/
sizeof|sizeof
argument_list|(
name|dst
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|cnt
condition|;
name|i
operator|++
operator|,
name|dst
operator|++
operator|,
name|rq
operator|->
name|q
operator|++
control|)
block|{
operator|*
name|dst
operator|^=
operator|*
name|rq
operator|->
name|q
expr_stmt|;
name|int
name|j
decl_stmt|;
name|uint8_t
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|b
operator|=
operator|(
name|uint8_t
operator|*
operator|)
name|dst
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
operator|,
name|b
operator|++
control|)
block|{
operator|*
name|b
operator|=
name|vdev_raidz_exp2
argument_list|(
operator|*
name|b
argument_list|,
name|rq
operator|->
name|exp
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_struct
struct|struct
name|reconst_pq_struct
block|{
name|uint8_t
modifier|*
name|p
decl_stmt|;
name|uint8_t
modifier|*
name|q
decl_stmt|;
name|uint8_t
modifier|*
name|pxy
decl_stmt|;
name|uint8_t
modifier|*
name|qxy
decl_stmt|;
name|int
name|aexp
decl_stmt|;
name|int
name|bexp
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|int
name|vdev_raidz_reconst_pq_func
parameter_list|(
name|void
modifier|*
name|xbuf
parameter_list|,
name|void
modifier|*
name|ybuf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|reconst_pq_struct
modifier|*
name|rpq
init|=
name|private
decl_stmt|;
name|uint8_t
modifier|*
name|xd
init|=
name|xbuf
decl_stmt|;
name|uint8_t
modifier|*
name|yd
init|=
name|ybuf
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|rpq
operator|->
name|p
operator|++
operator|,
name|rpq
operator|->
name|q
operator|++
operator|,
name|rpq
operator|->
name|pxy
operator|++
operator|,
name|rpq
operator|->
name|qxy
operator|++
operator|,
name|xd
operator|++
operator|,
name|yd
operator|++
control|)
block|{
operator|*
name|xd
operator|=
name|vdev_raidz_exp2
argument_list|(
operator|*
name|rpq
operator|->
name|p
operator|^
operator|*
name|rpq
operator|->
name|pxy
argument_list|,
name|rpq
operator|->
name|aexp
argument_list|)
operator|^
name|vdev_raidz_exp2
argument_list|(
operator|*
name|rpq
operator|->
name|q
operator|^
operator|*
name|rpq
operator|->
name|qxy
argument_list|,
name|rpq
operator|->
name|bexp
argument_list|)
expr_stmt|;
operator|*
name|yd
operator|=
operator|*
name|rpq
operator|->
name|p
operator|^
operator|*
name|rpq
operator|->
name|pxy
operator|^
operator|*
name|xd
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconst_pq_tail_func
parameter_list|(
name|void
modifier|*
name|xbuf
parameter_list|,
name|size_t
name|size
parameter_list|,
name|void
modifier|*
name|private
parameter_list|)
block|{
name|struct
name|reconst_pq_struct
modifier|*
name|rpq
init|=
name|private
decl_stmt|;
name|uint8_t
modifier|*
name|xd
init|=
name|xbuf
decl_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|size
condition|;
name|i
operator|++
operator|,
name|rpq
operator|->
name|p
operator|++
operator|,
name|rpq
operator|->
name|q
operator|++
operator|,
name|rpq
operator|->
name|pxy
operator|++
operator|,
name|rpq
operator|->
name|qxy
operator|++
operator|,
name|xd
operator|++
control|)
block|{
comment|/* same operation as vdev_raidz_reconst_pq_func() on xd */
operator|*
name|xd
operator|=
name|vdev_raidz_exp2
argument_list|(
operator|*
name|rpq
operator|->
name|p
operator|^
operator|*
name|rpq
operator|->
name|pxy
argument_list|,
name|rpq
operator|->
name|aexp
argument_list|)
operator|^
name|vdev_raidz_exp2
argument_list|(
operator|*
name|rpq
operator|->
name|q
operator|^
operator|*
name|rpq
operator|->
name|qxy
argument_list|,
name|rpq
operator|->
name|bexp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconstruct_p
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
modifier|*
name|tgts
parameter_list|,
name|int
name|ntgts
parameter_list|)
block|{
name|int
name|x
init|=
name|tgts
index|[
literal|0
index|]
decl_stmt|;
name|int
name|c
decl_stmt|;
name|abd_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|ASSERT
argument_list|(
name|ntgts
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|x
operator|>=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|x
operator|<
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|<=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|>
literal|0
argument_list|)
expr_stmt|;
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
expr_stmt|;
name|abd_copy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|size
init|=
name|MIN
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
decl_stmt|;
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|x
condition|)
continue|continue;
operator|(
name|void
operator|)
name|abd_iterate_func2
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|vdev_raidz_reconst_p_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|1
operator|<<
name|VDEV_RAIDZ_P
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconstruct_q
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
modifier|*
name|tgts
parameter_list|,
name|int
name|ntgts
parameter_list|)
block|{
name|int
name|x
init|=
name|tgts
index|[
literal|0
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|exp
decl_stmt|;
name|abd_t
modifier|*
name|dst
decl_stmt|,
modifier|*
name|src
decl_stmt|;
name|ASSERT
argument_list|(
name|ntgts
operator|==
literal|1
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|<=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|uint64_t
name|size
init|=
operator|(
name|c
operator|==
name|x
operator|)
condition|?
literal|0
else|:
name|MIN
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
argument_list|)
decl_stmt|;
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|abd_copy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|>
name|size
condition|)
name|abd_zero_off
argument_list|(
name|dst
argument_list|,
name|size
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|-
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func2
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|size
argument_list|,
name|vdev_raidz_reconst_q_pre_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|dst
argument_list|,
name|size
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|-
name|size
argument_list|,
name|vdev_raidz_reconst_q_pre_tail_func
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|src
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
expr_stmt|;
name|dst
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
expr_stmt|;
name|exp
operator|=
literal|255
operator|-
operator|(
name|rm
operator|->
name|rm_cols
operator|-
literal|1
operator|-
name|x
operator|)
expr_stmt|;
name|struct
name|reconst_q_struct
name|rq
init|=
block|{
name|abd_to_buf
argument_list|(
name|src
argument_list|)
block|,
name|exp
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|dst
argument_list|,
literal|0
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
argument_list|,
name|vdev_raidz_reconst_q_post_func
argument_list|,
operator|&
name|rq
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|<<
name|VDEV_RAIDZ_Q
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconstruct_pq
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
modifier|*
name|tgts
parameter_list|,
name|int
name|ntgts
parameter_list|)
block|{
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|,
modifier|*
name|pxy
decl_stmt|,
modifier|*
name|qxy
decl_stmt|,
name|tmp
decl_stmt|,
name|a
decl_stmt|,
name|b
decl_stmt|,
name|aexp
decl_stmt|,
name|bexp
decl_stmt|;
name|abd_t
modifier|*
name|pdata
decl_stmt|,
modifier|*
name|qdata
decl_stmt|;
name|uint64_t
name|xsize
decl_stmt|,
name|ysize
decl_stmt|;
name|int
name|x
init|=
name|tgts
index|[
literal|0
index|]
decl_stmt|;
name|int
name|y
init|=
name|tgts
index|[
literal|1
index|]
decl_stmt|;
name|abd_t
modifier|*
name|xd
decl_stmt|,
modifier|*
name|yd
decl_stmt|;
name|ASSERT
argument_list|(
name|ntgts
operator|==
literal|2
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|x
operator|<
name|y
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|x
operator|>=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|y
operator|<
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|>=
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
comment|/* 	 * Move the parity data aside -- we're going to compute parity as 	 * though columns x and y were full of zeros -- Pxy and Qxy. We want to 	 * reuse the parity generation mechanism without trashing the actual 	 * parity so we make those columns appear to be full of zeros by 	 * setting their lengths to zero. 	 */
name|pdata
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
expr_stmt|;
name|qdata
operator|=
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
expr_stmt|;
name|xsize
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
expr_stmt|;
name|ysize
operator|=
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
operator|=
name|abd_alloc_linear
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_size
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
operator|=
name|abd_alloc_linear
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_size
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
operator|=
literal|0
expr_stmt|;
name|vdev_raidz_generate_parity_pq
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_size
operator|=
name|xsize
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_size
operator|=
name|ysize
expr_stmt|;
name|p
operator|=
name|abd_to_buf
argument_list|(
name|pdata
argument_list|)
expr_stmt|;
name|q
operator|=
name|abd_to_buf
argument_list|(
name|qdata
argument_list|)
expr_stmt|;
name|pxy
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|qxy
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|xd
operator|=
name|rm
operator|->
name|rm_col
index|[
name|x
index|]
operator|.
name|rc_abd
expr_stmt|;
name|yd
operator|=
name|rm
operator|->
name|rm_col
index|[
name|y
index|]
operator|.
name|rc_abd
expr_stmt|;
comment|/* 	 * We now have: 	 *	Pxy = P + D_x + D_y 	 *	Qxy = Q + 2^(ndevs - 1 - x) * D_x + 2^(ndevs - 1 - y) * D_y 	 * 	 * We can then solve for D_x: 	 *	D_x = A * (P + Pxy) + B * (Q + Qxy) 	 * where 	 *	A = 2^(x - y) * (2^(x - y) + 1)^-1 	 *	B = 2^(ndevs - 1 - x) * (2^(x - y) + 1)^-1 	 * 	 * With D_x in hand, we can easily solve for D_y: 	 *	D_y = P + Pxy + D_x 	 */
name|a
operator|=
name|vdev_raidz_pow2
index|[
literal|255
operator|+
name|x
operator|-
name|y
index|]
expr_stmt|;
name|b
operator|=
name|vdev_raidz_pow2
index|[
literal|255
operator|-
operator|(
name|rm
operator|->
name|rm_cols
operator|-
literal|1
operator|-
name|x
operator|)
index|]
expr_stmt|;
name|tmp
operator|=
literal|255
operator|-
name|vdev_raidz_log2
index|[
name|a
operator|^
literal|1
index|]
expr_stmt|;
name|aexp
operator|=
name|vdev_raidz_log2
index|[
name|vdev_raidz_exp2
argument_list|(
name|a
argument_list|,
name|tmp
argument_list|)
index|]
expr_stmt|;
name|bexp
operator|=
name|vdev_raidz_log2
index|[
name|vdev_raidz_exp2
argument_list|(
name|b
argument_list|,
name|tmp
argument_list|)
index|]
expr_stmt|;
name|ASSERT3U
argument_list|(
name|xsize
argument_list|,
operator|>=
argument_list|,
name|ysize
argument_list|)
expr_stmt|;
name|struct
name|reconst_pq_struct
name|rpq
init|=
block|{
name|p
block|,
name|q
block|,
name|pxy
block|,
name|qxy
block|,
name|aexp
block|,
name|bexp
block|}
decl_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func2
argument_list|(
name|xd
argument_list|,
name|yd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|ysize
argument_list|,
name|vdev_raidz_reconst_pq_func
argument_list|,
operator|&
name|rpq
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|abd_iterate_func
argument_list|(
name|xd
argument_list|,
name|ysize
argument_list|,
name|xsize
operator|-
name|ysize
argument_list|,
name|vdev_raidz_reconst_pq_tail_func
argument_list|,
operator|&
name|rpq
argument_list|)
expr_stmt|;
name|abd_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|abd_free
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
comment|/* 	 * Restore the saved parity data. 	 */
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_P
index|]
operator|.
name|rc_abd
operator|=
name|pdata
expr_stmt|;
name|rm
operator|->
name|rm_col
index|[
name|VDEV_RAIDZ_Q
index|]
operator|.
name|rc_abd
operator|=
name|qdata
expr_stmt|;
return|return
operator|(
operator|(
literal|1
operator|<<
name|VDEV_RAIDZ_P
operator|)
operator||
operator|(
literal|1
operator|<<
name|VDEV_RAIDZ_Q
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* BEGIN CSTYLED */
end_comment

begin_comment
comment|/*  * In the general case of reconstruction, we must solve the system of linear  * equations defined by the coeffecients used to generate parity as well as  * the contents of the data and parity disks. This can be expressed with  * vectors for the original data (D) and the actual data (d) and parity (p)  * and a matrix composed of the identity matrix (I) and a dispersal matrix (V):  *  *            __   __                     __     __  *            |     |         __     __   |  p_0  |  *            |  V  |         |  D_0  |   | p_m-1 |  *            |     |    x    |   :   | = |  d_0  |  *            |  I  |         | D_n-1 |   |   :   |  *            |     |         ~~     ~~   | d_n-1 |  *            ~~   ~~                     ~~     ~~  *  * I is simply a square identity matrix of size n, and V is a vandermonde  * matrix defined by the coeffecients we chose for the various parity columns  * (1, 2, 4). Note that these values were chosen both for simplicity, speedy  * computation as well as linear separability.  *  *      __               __               __     __  *      |   1   ..  1 1 1 |               |  p_0  |  *      | 2^n-1 ..  4 2 1 |   __     __   |   :   |  *      | 4^n-1 .. 16 4 1 |   |  D_0  |   | p_m-1 |  *      |   1   ..  0 0 0 |   |  D_1  |   |  d_0  |  *      |   0   ..  0 0 0 | x |  D_2  | = |  d_1  |  *      |   :       : : : |   |   :   |   |  d_2  |  *      |   0   ..  1 0 0 |   | D_n-1 |   |   :   |  *      |   0   ..  0 1 0 |   ~~     ~~   |   :   |  *      |   0   ..  0 0 1 |               | d_n-1 |  *      ~~               ~~               ~~     ~~  *  * Note that I, V, d, and p are known. To compute D, we must invert the  * matrix and use the known data and parity values to reconstruct the unknown  * data values. We begin by removing the rows in V|I and d|p that correspond  * to failed or missing columns; we then make V|I square (n x n) and d|p  * sized n by removing rows corresponding to unused parity from the bottom up  * to generate (V|I)' and (d|p)'. We can then generate the inverse of (V|I)'  * using Gauss-Jordan elimination. In the example below we use m=3 parity  * columns, n=8 data columns, with errors in d_1, d_2, and p_1:  *           __                               __  *           |  1   1   1   1   1   1   1   1  |  *           | 128  64  32  16  8   4   2   1  |<-----+-+-- missing disks  *           |  19 205 116  29  64  16  4   1  |      / /  *           |  1   0   0   0   0   0   0   0  |     / /  *           |  0   1   0   0   0   0   0   0  |<--' /  *  (V|I)  = |  0   0   1   0   0   0   0   0  |<---'  *           |  0   0   0   1   0   0   0   0  |  *           |  0   0   0   0   1   0   0   0  |  *           |  0   0   0   0   0   1   0   0  |  *           |  0   0   0   0   0   0   1   0  |  *           |  0   0   0   0   0   0   0   1  |  *           ~~                               ~~  *           __                               __  *           |  1   1   1   1   1   1   1   1  |  *           |  19 205 116  29  64  16  4   1  |  *           |  1   0   0   0   0   0   0   0  |  *  (V|I)' = |  0   0   0   1   0   0   0   0  |  *           |  0   0   0   0   1   0   0   0  |  *           |  0   0   0   0   0   1   0   0  |  *           |  0   0   0   0   0   0   1   0  |  *           |  0   0   0   0   0   0   0   1  |  *           ~~                               ~~  *  * Here we employ Gauss-Jordan elimination to find the inverse of (V|I)'. We  * have carefully chosen the seed values 1, 2, and 4 to ensure that this  * matrix is not singular.  * __                                                                 __  * |  1   1   1   1   1   1   1   1     1   0   0   0   0   0   0   0  |  * |  19 205 116  29  64  16  4   1     0   1   0   0   0   0   0   0  |  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  1   1   1   1   1   1   1   1     1   0   0   0   0   0   0   0  |  * |  19 205 116  29  64  16  4   1     0   1   0   0   0   0   0   0  |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   1   0   0   0   0   0     1   0   1   1   1   1   1   1  |  * |  0  205 116  0   0   0   0   0     0   1   19  29  64  16  4   1  |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   1   0   0   0   0   0     1   0   1   1   1   1   1   1  |  * |  0   0  185  0   0   0   0   0    205  1  222 208 141 221 201 204 |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   1   0   0   0   0   0     1   0   1   1   1   1   1   1  |  * |  0   0   1   0   0   0   0   0    166 100  4   40 158 168 216 209 |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  * __                                                                 __  * |  1   0   0   0   0   0   0   0     0   0   1   0   0   0   0   0  |  * |  0   1   0   0   0   0   0   0    167 100  5   41 159 169 217 208 |  * |  0   0   1   0   0   0   0   0    166 100  4   40 158 168 216 209 |  * |  0   0   0   1   0   0   0   0     0   0   0   1   0   0   0   0  |  * |  0   0   0   0   1   0   0   0     0   0   0   0   1   0   0   0  |  * |  0   0   0   0   0   1   0   0     0   0   0   0   0   1   0   0  |  * |  0   0   0   0   0   0   1   0     0   0   0   0   0   0   1   0  |  * |  0   0   0   0   0   0   0   1     0   0   0   0   0   0   0   1  |  * ~~                                                                 ~~  *                   __                               __  *                   |  0   0   1   0   0   0   0   0  |  *                   | 167 100  5   41 159 169 217 208 |  *                   | 166 100  4   40 158 168 216 209 |  *       (V|I)'^-1 = |  0   0   0   1   0   0   0   0  |  *                   |  0   0   0   0   1   0   0   0  |  *                   |  0   0   0   0   0   1   0   0  |  *                   |  0   0   0   0   0   0   1   0  |  *                   |  0   0   0   0   0   0   0   1  |  *                   ~~                               ~~  *  * We can then simply compute D = (V|I)'^-1 x (d|p)' to discover the values  * of the missing data.  *  * As is apparent from the example above, the only non-trivial rows in the  * inverse matrix correspond to the data disks that we're trying to  * reconstruct. Indeed, those are the only rows we need as the others would  * only be useful for reconstructing data known or assumed to be valid. For  * that reason, we only build the coefficients in the rows that correspond to  * targeted columns.  */
end_comment

begin_comment
comment|/* END CSTYLED */
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_matrix_init
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|nmap
parameter_list|,
name|int
modifier|*
name|map
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rows
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|pow
decl_stmt|;
name|ASSERT
argument_list|(
name|n
operator|==
name|rm
operator|->
name|rm_cols
operator|-
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 	 * Fill in the missing rows of interest. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmap
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3S
argument_list|(
literal|0
argument_list|,
operator|<=
argument_list|,
name|map
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|map
index|[
name|i
index|]
argument_list|,
operator|<=
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|pow
operator|=
name|map
index|[
name|i
index|]
operator|*
name|n
expr_stmt|;
if|if
condition|(
name|pow
operator|>
literal|255
condition|)
name|pow
operator|-=
literal|255
expr_stmt|;
name|ASSERT
argument_list|(
name|pow
operator|<=
literal|255
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|pow
operator|-=
name|map
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|pow
operator|<
literal|0
condition|)
name|pow
operator|+=
literal|255
expr_stmt|;
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_pow2
index|[
name|pow
index|]
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_matrix_invert
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|nmissing
parameter_list|,
name|int
modifier|*
name|missing
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|rows
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|invrows
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|used
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|ii
decl_stmt|,
name|jj
decl_stmt|;
name|uint8_t
name|log
decl_stmt|;
comment|/* 	 * Assert that the first nmissing entries from the array of used 	 * columns correspond to parity columns and that subsequent entries 	 * correspond to data columns. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3S
argument_list|(
name|used
index|[
name|i
index|]
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT3S
argument_list|(
name|used
index|[
name|i
index|]
argument_list|,
operator|>=
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * First initialize the storage where we'll compute the inverse rows. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|(
name|i
operator|==
name|j
operator|)
condition|?
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * Subtract all trivial rows from the rows of consequence. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|nmissing
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|used
index|[
name|j
index|]
argument_list|,
operator|>=
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|jj
operator|=
name|used
index|[
name|j
index|]
operator|-
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
name|ASSERT3S
argument_list|(
name|jj
argument_list|,
operator|<
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|rows
index|[
name|i
index|]
index|[
name|jj
index|]
expr_stmt|;
name|rows
index|[
name|i
index|]
index|[
name|jj
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* 	 * For each of the rows of interest, we must normalize it and subtract 	 * a multiple of it from the other rows. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|missing
index|[
name|i
index|]
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT0
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * Compute the inverse of the first element and multiply each 		 * element in the row by that value. 		 */
name|log
operator|=
literal|255
operator|-
name|vdev_raidz_log2
index|[
name|rows
index|[
name|i
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_exp2
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_exp2
argument_list|(
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|ii
operator|=
literal|0
init|;
name|ii
operator|<
name|nmissing
condition|;
name|ii
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|ii
condition|)
continue|continue;
name|ASSERT3U
argument_list|(
name|rows
index|[
name|ii
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|log
operator|=
name|vdev_raidz_log2
index|[
name|rows
index|[
name|ii
index|]
index|[
name|missing
index|[
name|i
index|]
index|]
index|]
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|rows
index|[
name|ii
index|]
index|[
name|j
index|]
operator|^=
name|vdev_raidz_exp2
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
name|invrows
index|[
name|ii
index|]
index|[
name|j
index|]
operator|^=
name|vdev_raidz_exp2
argument_list|(
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
name|log
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * Verify that the data that is left in the rows are properly part of 	 * an identity matrix. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
name|missing
index|[
name|i
index|]
condition|)
block|{
name|ASSERT3U
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT0
argument_list|(
name|rows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_matrix_reconstruct
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
name|n
parameter_list|,
name|int
name|nmissing
parameter_list|,
name|int
modifier|*
name|missing
parameter_list|,
name|uint8_t
modifier|*
modifier|*
name|invrows
parameter_list|,
specifier|const
name|uint8_t
modifier|*
name|used
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|x
decl_stmt|,
name|cc
decl_stmt|,
name|c
decl_stmt|;
name|uint8_t
modifier|*
name|src
decl_stmt|;
name|uint64_t
name|ccount
decl_stmt|;
name|uint8_t
modifier|*
name|dst
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint64_t
name|dcount
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
name|log
init|=
literal|0
decl_stmt|;
name|uint8_t
name|val
decl_stmt|;
name|int
name|ll
decl_stmt|;
name|uint8_t
modifier|*
name|invlog
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|psize
operator|=
sizeof|sizeof
argument_list|(
name|invlog
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|*
name|n
operator|*
name|nmissing
expr_stmt|;
name|p
operator|=
name|kmem_alloc
argument_list|(
name|psize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|p
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
name|invlog
index|[
name|i
index|]
operator|=
name|pp
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|n
condition|;
name|j
operator|++
control|)
block|{
name|ASSERT3U
argument_list|(
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
argument_list|,
operator|!=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|invlog
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
name|vdev_raidz_log2
index|[
name|invrows
index|[
name|i
index|]
index|[
name|j
index|]
index|]
expr_stmt|;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|used
index|[
name|i
index|]
expr_stmt|;
name|ASSERT3U
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|src
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|ccount
operator|=
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_size
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nmissing
condition|;
name|j
operator|++
control|)
block|{
name|cc
operator|=
name|missing
index|[
name|j
index|]
operator|+
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
name|ASSERT3U
argument_list|(
name|cc
argument_list|,
operator|>=
argument_list|,
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|cc
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|cc
argument_list|,
operator|!=
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|dst
index|[
name|j
index|]
operator|=
name|abd_to_buf
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|cc
index|]
operator|.
name|rc_abd
argument_list|)
expr_stmt|;
name|dcount
index|[
name|j
index|]
operator|=
name|rm
operator|->
name|rm_col
index|[
name|cc
index|]
operator|.
name|rc_size
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|ccount
operator|>=
name|rm
operator|->
name|rm_col
index|[
name|missing
index|[
literal|0
index|]
index|]
operator|.
name|rc_size
operator|||
name|i
operator|>
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|ccount
condition|;
name|x
operator|++
operator|,
name|src
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|!=
literal|0
condition|)
name|log
operator|=
name|vdev_raidz_log2
index|[
operator|*
name|src
index|]
expr_stmt|;
for|for
control|(
name|cc
operator|=
literal|0
init|;
name|cc
operator|<
name|nmissing
condition|;
name|cc
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|>=
name|dcount
index|[
name|cc
index|]
condition|)
continue|continue;
if|if
condition|(
operator|*
name|src
operator|==
literal|0
condition|)
block|{
name|val
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|ll
operator|=
name|log
operator|+
name|invlog
index|[
name|cc
index|]
index|[
name|i
index|]
operator|)
operator|>=
literal|255
condition|)
name|ll
operator|-=
literal|255
expr_stmt|;
name|val
operator|=
name|vdev_raidz_pow2
index|[
name|ll
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|dst
index|[
name|cc
index|]
index|[
name|x
index|]
operator|=
name|val
expr_stmt|;
else|else
name|dst
index|[
name|cc
index|]
index|[
name|x
index|]
operator|^=
name|val
expr_stmt|;
block|}
block|}
block|}
name|kmem_free
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconstruct_general
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
modifier|*
name|tgts
parameter_list|,
name|int
name|ntgts
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|,
name|t
decl_stmt|,
name|tt
decl_stmt|;
name|int
name|nmissing_rows
decl_stmt|;
name|int
name|missing_rows
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|parity_map
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|p
decl_stmt|,
modifier|*
name|pp
decl_stmt|;
name|size_t
name|psize
decl_stmt|;
name|uint8_t
modifier|*
name|rows
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|invrows
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|uint8_t
modifier|*
name|used
decl_stmt|;
name|abd_t
modifier|*
modifier|*
name|bufs
init|=
name|NULL
decl_stmt|;
name|int
name|code
init|=
literal|0
decl_stmt|;
comment|/* 	 * Matrix reconstruction can't use scatter ABDs yet, so we allocate 	 * temporary linear ABDs. 	 */
if|if
condition|(
operator|!
name|abd_is_linear
argument_list|(
name|rm
operator|->
name|rm_col
index|[
name|rm
operator|->
name|rm_firstdatacol
index|]
operator|.
name|rc_abd
argument_list|)
condition|)
block|{
name|bufs
operator|=
name|kmem_alloc
argument_list|(
name|rm
operator|->
name|rm_cols
operator|*
sizeof|sizeof
argument_list|(
name|abd_t
operator|*
argument_list|)
argument_list|,
name|KM_PUSHPAGE
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|raidz_col_t
modifier|*
name|col
init|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
decl_stmt|;
name|bufs
index|[
name|c
index|]
operator|=
name|col
operator|->
name|rc_abd
expr_stmt|;
name|col
operator|->
name|rc_abd
operator|=
name|abd_alloc_linear
argument_list|(
name|col
operator|->
name|rc_size
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|abd_copy
argument_list|(
name|col
operator|->
name|rc_abd
argument_list|,
name|bufs
index|[
name|c
index|]
argument_list|,
name|col
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
name|n
operator|=
name|rm
operator|->
name|rm_cols
operator|-
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
comment|/* 	 * Figure out which data columns are missing. 	 */
name|nmissing_rows
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|t
operator|=
literal|0
init|;
name|t
operator|<
name|ntgts
condition|;
name|t
operator|++
control|)
block|{
if|if
condition|(
name|tgts
index|[
name|t
index|]
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|missing_rows
index|[
name|nmissing_rows
operator|++
index|]
operator|=
name|tgts
index|[
name|t
index|]
operator|-
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
block|}
block|}
comment|/* 	 * Figure out which parity columns to use to help generate the missing 	 * data columns. 	 */
for|for
control|(
name|tt
operator|=
literal|0
operator|,
name|c
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing_rows
condition|;
name|c
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|tt
operator|<
name|ntgts
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 		 * Skip any targeted parity columns. 		 */
if|if
condition|(
name|c
operator|==
name|tgts
index|[
name|tt
index|]
condition|)
block|{
name|tt
operator|++
expr_stmt|;
continue|continue;
block|}
name|code
operator||=
literal|1
operator|<<
name|c
expr_stmt|;
name|parity_map
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|code
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|code
argument_list|,
operator|<
argument_list|,
literal|1
operator|<<
name|VDEV_RAIDZ_MAXPARITY
argument_list|)
expr_stmt|;
name|psize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|rows
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|invrows
index|[
literal|0
index|]
index|[
literal|0
index|]
argument_list|)
operator|)
operator|*
name|nmissing_rows
operator|*
name|n
operator|+
sizeof|sizeof
argument_list|(
name|used
index|[
literal|0
index|]
argument_list|)
operator|*
name|n
expr_stmt|;
name|p
operator|=
name|kmem_alloc
argument_list|(
name|psize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|p
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing_rows
condition|;
name|i
operator|++
control|)
block|{
name|rows
index|[
name|i
index|]
operator|=
name|pp
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
name|invrows
index|[
name|i
index|]
operator|=
name|pp
expr_stmt|;
name|pp
operator|+=
name|n
expr_stmt|;
block|}
name|used
operator|=
name|pp
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nmissing_rows
condition|;
name|i
operator|++
control|)
block|{
name|used
index|[
name|i
index|]
operator|=
name|parity_map
index|[
name|i
index|]
expr_stmt|;
block|}
for|for
control|(
name|tt
operator|=
literal|0
operator|,
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|tt
operator|<
name|nmissing_rows
operator|&&
name|c
operator|==
name|missing_rows
index|[
name|tt
index|]
operator|+
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|tt
operator|++
expr_stmt|;
continue|continue;
block|}
name|ASSERT3S
argument_list|(
name|i
argument_list|,
operator|<
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|used
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
comment|/* 	 * Initialize the interesting rows of the matrix. 	 */
name|vdev_raidz_matrix_init
argument_list|(
name|rm
argument_list|,
name|n
argument_list|,
name|nmissing_rows
argument_list|,
name|parity_map
argument_list|,
name|rows
argument_list|)
expr_stmt|;
comment|/* 	 * Invert the matrix. 	 */
name|vdev_raidz_matrix_invert
argument_list|(
name|rm
argument_list|,
name|n
argument_list|,
name|nmissing_rows
argument_list|,
name|missing_rows
argument_list|,
name|rows
argument_list|,
name|invrows
argument_list|,
name|used
argument_list|)
expr_stmt|;
comment|/* 	 * Reconstruct the missing data using the generated matrix. 	 */
name|vdev_raidz_matrix_reconstruct
argument_list|(
name|rm
argument_list|,
name|n
argument_list|,
name|nmissing_rows
argument_list|,
name|missing_rows
argument_list|,
name|invrows
argument_list|,
name|used
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|p
argument_list|,
name|psize
argument_list|)
expr_stmt|;
comment|/* 	 * copy back from temporary linear abds and free them 	 */
if|if
condition|(
name|bufs
condition|)
block|{
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|raidz_col_t
modifier|*
name|col
init|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
decl_stmt|;
name|abd_copy
argument_list|(
name|bufs
index|[
name|c
index|]
argument_list|,
name|col
operator|->
name|rc_abd
argument_list|,
name|col
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|abd_free
argument_list|(
name|col
operator|->
name|rc_abd
argument_list|)
expr_stmt|;
name|col
operator|->
name|rc_abd
operator|=
name|bufs
index|[
name|c
index|]
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|bufs
argument_list|,
name|rm
operator|->
name|rm_cols
operator|*
sizeof|sizeof
argument_list|(
name|abd_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_reconstruct
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|,
name|int
modifier|*
name|t
parameter_list|,
name|int
name|nt
parameter_list|)
block|{
name|int
name|tgts
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|,
modifier|*
name|dt
decl_stmt|;
name|int
name|ntgts
decl_stmt|;
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
name|int
name|code
decl_stmt|;
name|int
name|nbadparity
decl_stmt|,
name|nbaddata
decl_stmt|;
name|int
name|parity_valid
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
comment|/* 	 * The tgts list must already be sorted. 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|nt
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|t
index|[
name|i
index|]
operator|>
name|t
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|nbadparity
operator|=
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
name|nbaddata
operator|=
name|rm
operator|->
name|rm_cols
operator|-
name|nbadparity
expr_stmt|;
name|ntgts
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|parity_valid
index|[
name|c
index|]
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|nt
operator|&&
name|c
operator|==
name|t
index|[
name|i
index|]
condition|)
block|{
name|tgts
index|[
name|ntgts
operator|++
index|]
operator|=
name|c
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|)
block|{
name|tgts
index|[
name|ntgts
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|nbaddata
operator|--
expr_stmt|;
block|}
else|else
block|{
name|parity_valid
index|[
name|c
index|]
operator|=
name|B_TRUE
expr_stmt|;
name|nbadparity
operator|--
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|ntgts
operator|>=
name|nt
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nbaddata
operator|>=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|nbaddata
operator|+
name|nbadparity
operator|==
name|ntgts
argument_list|)
expr_stmt|;
name|dt
operator|=
operator|&
name|tgts
index|[
name|nbadparity
index|]
expr_stmt|;
comment|/* 	 * See if we can use any of our optimized reconstruction routines. 	 */
if|if
condition|(
operator|!
name|vdev_raidz_default_to_general
condition|)
block|{
switch|switch
condition|(
name|nbaddata
condition|)
block|{
case|case
literal|1
case|:
if|if
condition|(
name|parity_valid
index|[
name|VDEV_RAIDZ_P
index|]
condition|)
return|return
operator|(
name|vdev_raidz_reconstruct_p
argument_list|(
name|rm
argument_list|,
name|dt
argument_list|,
literal|1
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parity_valid
index|[
name|VDEV_RAIDZ_Q
index|]
condition|)
return|return
operator|(
name|vdev_raidz_reconstruct_q
argument_list|(
name|rm
argument_list|,
name|dt
argument_list|,
literal|1
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|>
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|parity_valid
index|[
name|VDEV_RAIDZ_P
index|]
operator|&&
name|parity_valid
index|[
name|VDEV_RAIDZ_Q
index|]
condition|)
return|return
operator|(
name|vdev_raidz_reconstruct_pq
argument_list|(
name|rm
argument_list|,
name|dt
argument_list|,
literal|2
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|>
literal|2
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|code
operator|=
name|vdev_raidz_reconstruct_general
argument_list|(
name|rm
argument_list|,
name|tgts
argument_list|,
name|ntgts
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|code
operator|<
operator|(
literal|1
operator|<<
name|VDEV_RAIDZ_MAXPARITY
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|code
operator|>
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_raidz_open
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
modifier|*
name|asize
parameter_list|,
name|uint64_t
modifier|*
name|max_asize
parameter_list|,
name|uint64_t
modifier|*
name|ashift
parameter_list|)
block|{
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|uint64_t
name|nparity
init|=
name|vd
operator|->
name|vdev_nparity
decl_stmt|;
name|int
name|c
decl_stmt|;
name|int
name|lasterror
init|=
literal|0
decl_stmt|;
name|int
name|numerrors
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|nparity
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|nparity
operator|>
name|VDEV_RAIDZ_MAXPARITY
operator|||
name|vd
operator|->
name|vdev_children
operator|<
name|nparity
operator|+
literal|1
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_BAD_LABEL
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
block|}
name|vdev_open_children
argument_list|(
name|vd
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
block|{
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|cvd
operator|->
name|vdev_open_error
operator|!=
literal|0
condition|)
block|{
name|lasterror
operator|=
name|cvd
operator|->
name|vdev_open_error
expr_stmt|;
name|numerrors
operator|++
expr_stmt|;
continue|continue;
block|}
operator|*
name|asize
operator|=
name|MIN
argument_list|(
operator|*
name|asize
operator|-
literal|1
argument_list|,
name|cvd
operator|->
name|vdev_asize
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|max_asize
operator|=
name|MIN
argument_list|(
operator|*
name|max_asize
operator|-
literal|1
argument_list|,
name|cvd
operator|->
name|vdev_max_asize
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|*
name|ashift
operator|=
name|MAX
argument_list|(
operator|*
name|ashift
argument_list|,
name|cvd
operator|->
name|vdev_ashift
argument_list|)
expr_stmt|;
block|}
operator|*
name|asize
operator|*=
name|vd
operator|->
name|vdev_children
expr_stmt|;
operator|*
name|max_asize
operator|*=
name|vd
operator|->
name|vdev_children
expr_stmt|;
if|if
condition|(
name|numerrors
operator|>
name|nparity
condition|)
block|{
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_aux
operator|=
name|VDEV_AUX_NO_REPLICAS
expr_stmt|;
return|return
operator|(
name|lasterror
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_close
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|vd
operator|->
name|vdev_children
condition|;
name|c
operator|++
control|)
name|vdev_close
argument_list|(
name|vd
operator|->
name|vdev_child
index|[
name|c
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Handle a read or write I/O to a RAID-Z dump device.  *  * The dump device is in a unique situation compared to other ZFS datasets:  * writing to this device should be as simple and fast as possible.  In  * addition, durability matters much less since the dump will be extracted  * once the machine reboots.  For that reason, this function eschews parity for  * performance and simplicity.  The dump device uses the checksum setting  * ZIO_CHECKSUM_NOPARITY to indicate that parity is not maintained for this  * dataset.  *  * Blocks of size 128 KB have been preallocated for this volume.  I/Os less than  * 128 KB will not fill an entire block; in addition, they may not be properly  * aligned.  In that case, this function uses the preallocated 128 KB block and  * omits reading or writing any "empty" portions of that block, as opposed to  * allocating a fresh appropriately-sized block.  *  * Looking at an example of a 32 KB I/O to a RAID-Z vdev with 5 child vdevs:  *  *     vdev_raidz_io_start(data, size: 32 KB, offset: 64 KB)  *  * If this were a standard RAID-Z dataset, a block of at least 40 KB would be  * allocated which spans all five child vdevs.  8 KB of data would be written to  * each of four vdevs, with the fifth containing the parity bits.  *  *       parity    data     data     data     data  *     |   PP   |   XX   |   XX   |   XX   |   XX   |  *         ^        ^        ^        ^        ^  *         |        |        |        |        |  *   8 KB parity    ------8 KB data blocks------  *  * However, when writing to the dump device, the behavior is different:  *  *     vdev_raidz_physio(data, size: 32 KB, offset: 64 KB)  *  * Unlike the normal RAID-Z case in which the block is allocated based on the  * I/O size, reads and writes here always use a 128 KB logical I/O size.  If the  * I/O size is less than 128 KB, only the actual portions of data are written.  * In this example the data is written to the third data vdev since that vdev  * contains the offset [64 KB, 96 KB).  *  *       parity    data     data     data     data  *     |        |        |        |   XX   |        |  *                                    ^  *                                    |  *                             32 KB data block  *  * As a result, an individual I/O may not span all child vdevs; moreover, a  * small I/O may only operate on a single child vdev.  *  * Note that since there are no parity bits calculated or written, this format  * remains the same no matter how many parity bits are used in a normal RAID-Z  * stripe.  On a RAID-Z3 configuration with seven child vdevs, the example above  * would look like:  *  *       parity   parity   parity    data     data     data     data  *     |        |        |        |        |        |   XX   |        |  *                                                      ^  *                                                      |  *                                               32 KB data block  */
end_comment

begin_function
name|int
name|vdev_raidz_physio
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|caddr_t
name|data
parameter_list|,
name|size_t
name|size
parameter_list|,
name|uint64_t
name|offset
parameter_list|,
name|uint64_t
name|origoffset
parameter_list|,
name|boolean_t
name|doread
parameter_list|,
name|boolean_t
name|isdump
parameter_list|)
block|{
name|vdev_t
modifier|*
name|tvd
init|=
name|vd
operator|->
name|vdev_top
decl_stmt|;
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|int
name|c
decl_stmt|,
name|err
init|=
literal|0
decl_stmt|;
name|uint64_t
name|start
decl_stmt|,
name|end
decl_stmt|,
name|colstart
decl_stmt|,
name|colend
decl_stmt|;
name|uint64_t
name|coloffset
decl_stmt|,
name|colsize
decl_stmt|,
name|colskip
decl_stmt|;
name|int
name|flags
init|=
name|doread
condition|?
name|B_READ
else|:
name|B_WRITE
decl_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
comment|/* 	 * Don't write past the end of the block 	 */
name|VERIFY3U
argument_list|(
name|offset
operator|+
name|size
argument_list|,
operator|<=
argument_list|,
name|origoffset
operator|+
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|start
operator|=
name|offset
expr_stmt|;
name|end
operator|=
name|start
operator|+
name|size
expr_stmt|;
comment|/* 	 * Allocate a RAID-Z map for this block.  Note that this block starts 	 * from the "original" offset, this is, the offset of the extent which 	 * contains the requisite offset of the data being read or written. 	 * 	 * Even if this I/O operation doesn't span the full block size, let's 	 * treat the on-disk format as if the only blocks are the complete 128 	 * KB size. 	 */
name|abd_t
modifier|*
name|abd
init|=
name|abd_get_from_buf
argument_list|(
name|data
operator|-
operator|(
name|offset
operator|-
name|origoffset
operator|)
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|)
decl_stmt|;
name|rm
operator|=
name|vdev_raidz_map_alloc
argument_list|(
name|abd
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
name|origoffset
argument_list|,
name|tvd
operator|->
name|vdev_ashift
argument_list|,
name|vd
operator|->
name|vdev_children
argument_list|,
name|vd
operator|->
name|vdev_nparity
argument_list|)
expr_stmt|;
name|coloffset
operator|=
name|origoffset
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
operator|,
name|coloffset
operator|+=
name|rc
operator|->
name|rc_size
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
comment|/* 		 * Find the start and end of this column in the RAID-Z map, 		 * keeping in mind that the stated size and offset of the 		 * operation may not fill the entire column for this vdev. 		 * 		 * If any portion of the data spans this column, issue the 		 * appropriate operation to the vdev. 		 */
if|if
condition|(
name|coloffset
operator|+
name|rc
operator|->
name|rc_size
operator|<=
name|start
condition|)
continue|continue;
if|if
condition|(
name|coloffset
operator|>=
name|end
condition|)
continue|continue;
name|colstart
operator|=
name|MAX
argument_list|(
name|coloffset
argument_list|,
name|start
argument_list|)
expr_stmt|;
name|colend
operator|=
name|MIN
argument_list|(
name|end
argument_list|,
name|coloffset
operator|+
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|colsize
operator|=
name|colend
operator|-
name|colstart
expr_stmt|;
name|colskip
operator|=
name|colstart
operator|-
name|coloffset
expr_stmt|;
name|VERIFY3U
argument_list|(
name|colsize
argument_list|,
operator|<=
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
name|colskip
argument_list|,
operator|<=
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
comment|/* 		 * Note that the child vdev will have a vdev label at the start 		 * of its range of offsets, hence the need for 		 * VDEV_LABEL_OFFSET().  See zio_vdev_child_io() for another 		 * example of why this calculation is needed. 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|vdev_disk_physio
argument_list|(
name|cvd
argument_list|,
operator|(
operator|(
name|char
operator|*
operator|)
name|abd_to_buf
argument_list|(
name|rc
operator|->
name|rc_abd
argument_list|)
operator|)
operator|+
name|colskip
argument_list|,
name|colsize
argument_list|,
name|VDEV_LABEL_OFFSET
argument_list|(
name|rc
operator|->
name|rc_offset
argument_list|)
operator|+
name|colskip
argument_list|,
name|flags
argument_list|,
name|isdump
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
name|vdev_raidz_map_free
argument_list|(
name|rm
argument_list|)
expr_stmt|;
name|abd_put
argument_list|(
name|abd
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* KERNEL */
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|vdev_raidz_asize
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|uint64_t
name|psize
parameter_list|)
block|{
name|uint64_t
name|asize
decl_stmt|;
name|uint64_t
name|ashift
init|=
name|vd
operator|->
name|vdev_top
operator|->
name|vdev_ashift
decl_stmt|;
name|uint64_t
name|cols
init|=
name|vd
operator|->
name|vdev_children
decl_stmt|;
name|uint64_t
name|nparity
init|=
name|vd
operator|->
name|vdev_nparity
decl_stmt|;
name|asize
operator|=
operator|(
operator|(
name|psize
operator|-
literal|1
operator|)
operator|>>
name|ashift
operator|)
operator|+
literal|1
expr_stmt|;
name|asize
operator|+=
name|nparity
operator|*
operator|(
operator|(
name|asize
operator|+
name|cols
operator|-
name|nparity
operator|-
literal|1
operator|)
operator|/
operator|(
name|cols
operator|-
name|nparity
operator|)
operator|)
expr_stmt|;
name|asize
operator|=
name|roundup
argument_list|(
name|asize
argument_list|,
name|nparity
operator|+
literal|1
argument_list|)
operator|<<
name|ashift
expr_stmt|;
return|return
operator|(
name|asize
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_child_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|raidz_col_t
modifier|*
name|rc
init|=
name|zio
operator|->
name|io_private
decl_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|zio
operator|->
name|io_error
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Start an IO operation on a RAIDZ VDev  *  * Outline:  * - For write operations:  *   1. Generate the parity data  *   2. Create child zio write operations to each column's vdev, for both  *      data and parity.  *   3. If the column skips any sectors for padding, create optional dummy  *      write zio children for those areas to improve aggregation continuity.  * - For read operations:  *   1. Create child zio read operations to each data column's vdev to read  *      the range of data required for zio.  *   2. If this is a scrub or resilver operation, or if any of the data  *      vdevs have had errors, then create zio read operations to the parity  *      columns' VDevs as well.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_io_start
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_t
modifier|*
name|tvd
init|=
name|vd
operator|->
name|vdev_top
decl_stmt|;
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|rm
operator|=
name|vdev_raidz_map_alloc
argument_list|(
name|zio
operator|->
name|io_abd
argument_list|,
name|zio
operator|->
name|io_size
argument_list|,
name|zio
operator|->
name|io_offset
argument_list|,
name|tvd
operator|->
name|vdev_ashift
argument_list|,
name|vd
operator|->
name|vdev_children
argument_list|,
name|vd
operator|->
name|vdev_nparity
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_vsd
operator|=
name|rm
expr_stmt|;
name|zio
operator|->
name|io_vsd_ops
operator|=
operator|&
name|vdev_raidz_vsd_ops
expr_stmt|;
name|ASSERT3U
argument_list|(
name|rm
operator|->
name|rm_asize
argument_list|,
operator|==
argument_list|,
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|zio
operator|->
name|io_size
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|vdev_raidz_generate_parity
argument_list|(
name|rm
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|cvd
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_abd
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_raidz_child_done
argument_list|,
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Generate optional I/Os for any skipped sectors to improve 		 * aggregation contiguity. 		 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_skipstart
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|rm
operator|->
name|rm_nskip
condition|;
name|c
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|c
operator|<=
name|rm
operator|->
name|rm_scols
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|rm
operator|->
name|rm_scols
condition|)
name|c
operator|=
literal|0
expr_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|cvd
argument_list|,
name|rc
operator|->
name|rc_offset
operator|+
name|rc
operator|->
name|rc_size
argument_list|,
name|NULL
argument_list|,
literal|1
operator|<<
name|tvd
operator|->
name|vdev_ashift
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|ZIO_FLAG_NODATA
operator||
name|ZIO_FLAG_OPTIONAL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over the columns in reverse order so that we hit the parity 	 * last -- any errors along the way will force us to read the parity. 	 */
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_cols
operator|-
literal|1
init|;
name|c
operator|>=
literal|0
condition|;
name|c
operator|--
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|vdev_readable
argument_list|(
name|cvd
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|rm
operator|->
name|rm_missingdata
operator|++
expr_stmt|;
else|else
name|rm
operator|->
name|rm_missingparity
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|SET_ERROR
argument_list|(
name|ENXIO
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_tried
operator|=
literal|1
expr_stmt|;
comment|/* don't even try */
name|rc
operator|->
name|rc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|vdev_dtl_contains
argument_list|(
name|cvd
argument_list|,
name|DTL_MISSING
argument_list|,
name|zio
operator|->
name|io_txg
argument_list|,
literal|1
argument_list|)
condition|)
block|{
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|rm
operator|->
name|rm_missingdata
operator|++
expr_stmt|;
else|else
name|rm
operator|->
name|rm_missingparity
operator|++
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|SET_ERROR
argument_list|(
name|ESTALE
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_skipped
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|>=
name|rm
operator|->
name|rm_firstdatacol
operator|||
name|rm
operator|->
name|rm_missingdata
operator|>
literal|0
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
operator|(
name|ZIO_FLAG_SCRUB
operator||
name|ZIO_FLAG_RESILVER
operator|)
operator|)
condition|)
block|{
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|cvd
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_abd
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_raidz_child_done
argument_list|,
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Report a checksum error for a child of a RAID-Z device.  */
end_comment

begin_function
specifier|static
name|void
name|raidz_checksum_error
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|raidz_col_t
modifier|*
name|rc
parameter_list|,
name|void
modifier|*
name|bad_data
parameter_list|)
block|{
name|void
modifier|*
name|buf
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
block|{
name|zio_bad_cksum_t
name|zbc
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_checksum_errors
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vd
operator|->
name|vdev_stat_lock
argument_list|)
expr_stmt|;
name|zbc
operator|.
name|zbc_has_cksum
operator|=
literal|0
expr_stmt|;
name|zbc
operator|.
name|zbc_injected
operator|=
name|rm
operator|->
name|rm_ecksuminjected
expr_stmt|;
name|buf
operator|=
name|abd_borrow_buf_copy
argument_list|(
name|rc
operator|->
name|rc_abd
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|zfs_ereport_post_checksum
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|vd
argument_list|,
name|zio
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|buf
argument_list|,
name|bad_data
argument_list|,
operator|&
name|zbc
argument_list|)
expr_stmt|;
name|abd_return_buf
argument_list|(
name|rc
operator|->
name|rc_abd
argument_list|,
name|buf
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * We keep track of whether or not there were any injected errors, so that  * any ereports we generate can note it.  */
end_comment

begin_function
specifier|static
name|int
name|raidz_checksum_verify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_bad_cksum_t
name|zbc
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|int
name|ret
init|=
name|zio_checksum_error
argument_list|(
name|zio
argument_list|,
operator|&
name|zbc
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|!=
literal|0
operator|&&
name|zbc
operator|.
name|zbc_injected
operator|!=
literal|0
condition|)
name|rm
operator|->
name|rm_ecksuminjected
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate the parity from the data columns. If we tried and were able to  * read the parity without error, verify that the generated parity matches the  * data we read. If it doesn't, we fire off a checksum error. Return the  * number such failures.  */
end_comment

begin_function
specifier|static
name|int
name|raidz_parity_verify
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|void
modifier|*
name|orig
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|zio
operator|->
name|io_bp
decl_stmt|;
name|enum
name|zio_checksum
name|checksum
init|=
operator|(
name|bp
operator|==
name|NULL
condition|?
name|zio
operator|->
name|io_prop
operator|.
name|zp_checksum
else|:
operator|(
name|BP_IS_GANG
argument_list|(
name|bp
argument_list|)
condition|?
name|ZIO_CHECKSUM_GANG_HEADER
else|:
name|BP_GET_CHECKSUM
argument_list|(
name|bp
argument_list|)
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|checksum
operator|==
name|ZIO_CHECKSUM_NOPARITY
condition|)
return|return
operator|(
name|ret
operator|)
return|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_tried
operator|||
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
continue|continue;
name|orig
index|[
name|c
index|]
operator|=
name|zio_buf_alloc
argument_list|(
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
name|abd_copy_to_buf
argument_list|(
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_abd
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
name|vdev_raidz_generate_parity
argument_list|(
name|rm
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_tried
operator|||
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|abd_cmp_buf
argument_list|(
name|rc
operator|->
name|rc_abd
argument_list|,
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|raidz_checksum_error
argument_list|(
name|zio
argument_list|,
name|rc
argument_list|,
name|orig
index|[
name|c
index|]
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
expr_stmt|;
name|ret
operator|++
expr_stmt|;
block|}
name|zio_buf_free
argument_list|(
name|orig
index|[
name|c
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Keep statistics on all the ways that we used parity to correct data.  */
end_comment

begin_decl_stmt
specifier|static
name|uint64_t
name|raidz_corrected
index|[
literal|1
operator|<<
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|vdev_raidz_worst_error
parameter_list|(
name|raidz_map_t
modifier|*
name|rm
parameter_list|)
block|{
name|int
name|error
init|=
literal|0
decl_stmt|;
for|for
control|(
name|int
name|c
init|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
name|error
operator|=
name|zio_worst_error
argument_list|(
name|error
argument_list|,
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Iterate over all combinations of bad data and attempt a reconstruction.  * Note that the algorithm below is non-optimal because it doesn't take into  * account how reconstruction is actually performed. For example, with  * triple-parity RAID-Z the reconstruction procedure is the same if column 4  * is targeted as invalid as if columns 1 and 4 are targeted since in both  * cases we'd only use parity information in column 0.  */
end_comment

begin_function
specifier|static
name|int
name|vdev_raidz_combrec
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|,
name|int
name|total_errors
parameter_list|,
name|int
name|data_errors
parameter_list|)
block|{
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|void
modifier|*
name|orig
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|tstore
index|[
name|VDEV_RAIDZ_MAXPARITY
operator|+
literal|2
index|]
decl_stmt|;
name|int
modifier|*
name|tgts
init|=
operator|&
name|tstore
index|[
literal|1
index|]
decl_stmt|;
name|int
name|current
decl_stmt|,
name|next
decl_stmt|,
name|i
decl_stmt|,
name|c
decl_stmt|,
name|n
decl_stmt|;
name|int
name|code
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|total_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 	 * This simplifies one edge condition. 	 */
name|tgts
index|[
operator|-
literal|1
index|]
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
operator|-
name|total_errors
condition|;
name|n
operator|++
control|)
block|{
comment|/* 		 * Initialize the targets array by finding the first n columns 		 * that contain no error. 		 * 		 * If there were no data errors, we need to ensure that we're 		 * always explicitly attempting to reconstruct at least one 		 * data column. To do this, we simply push the highest target 		 * up into the data columns. 		 */
for|for
control|(
name|c
operator|=
literal|0
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|1
operator|&&
name|data_errors
operator|==
literal|0
operator|&&
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
expr_stmt|;
block|}
while|while
condition|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|)
block|{
name|c
operator|++
expr_stmt|;
name|ASSERT3S
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
block|}
name|tgts
index|[
name|i
index|]
operator|=
name|c
operator|++
expr_stmt|;
block|}
comment|/* 		 * Setting tgts[n] simplifies the other edge condition. 		 */
name|tgts
index|[
name|n
index|]
operator|=
name|rm
operator|->
name|rm_cols
expr_stmt|;
comment|/* 		 * These buffers were allocated in previous iterations. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|-
literal|1
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|orig
index|[
name|i
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|orig
index|[
name|n
operator|-
literal|1
index|]
operator|=
name|zio_buf_alloc
argument_list|(
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
name|next
operator|=
name|tgts
index|[
name|current
index|]
expr_stmt|;
while|while
condition|(
name|current
operator|!=
name|n
condition|)
block|{
name|tgts
index|[
name|current
index|]
operator|=
name|next
expr_stmt|;
name|current
operator|=
literal|0
expr_stmt|;
comment|/* 			 * Save off the original data that we're going to 			 * attempt to reconstruct. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|ASSERT
argument_list|(
name|orig
index|[
name|i
index|]
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|c
operator|=
name|tgts
index|[
name|i
index|]
expr_stmt|;
name|ASSERT3S
argument_list|(
name|c
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|c
argument_list|,
operator|<
argument_list|,
name|rm
operator|->
name|rm_cols
argument_list|)
expr_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|abd_copy_to_buf
argument_list|(
name|orig
index|[
name|i
index|]
argument_list|,
name|rc
operator|->
name|rc_abd
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * Attempt a reconstruction and exit the outer loop on 			 * success. 			 */
name|code
operator|=
name|vdev_raidz_reconstruct
argument_list|(
name|rm
argument_list|,
name|tgts
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidz_checksum_verify
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected
index|[
name|code
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|tgts
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|ASSERT
argument_list|(
name|rc
operator|->
name|rc_error
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_tried
condition|)
name|raidz_checksum_error
argument_list|(
name|zio
argument_list|,
name|rc
argument_list|,
name|orig
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|rc
operator|->
name|rc_error
operator|=
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|code
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* 			 * Restore the original data. 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|tgts
index|[
name|i
index|]
expr_stmt|;
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|abd_copy_from_buf
argument_list|(
name|rc
operator|->
name|rc_abd
argument_list|,
name|orig
index|[
name|i
index|]
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* 				 * Find the next valid column after the current 				 * position.. 				 */
for|for
control|(
name|next
operator|=
name|tgts
index|[
name|current
index|]
operator|+
literal|1
init|;
name|next
operator|<
name|rm
operator|->
name|rm_cols
operator|&&
name|rm
operator|->
name|rm_col
index|[
name|next
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|;
name|next
operator|++
control|)
continue|continue;
name|ASSERT
argument_list|(
name|next
operator|<=
name|tgts
index|[
name|current
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * If that spot is available, we're done here. 				 */
if|if
condition|(
name|next
operator|!=
name|tgts
index|[
name|current
operator|+
literal|1
index|]
condition|)
break|break;
comment|/* 				 * Otherwise, find the next valid column after 				 * the previous position. 				 */
for|for
control|(
name|c
operator|=
name|tgts
index|[
name|current
operator|-
literal|1
index|]
operator|+
literal|1
init|;
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_error
operator|!=
literal|0
condition|;
name|c
operator|++
control|)
continue|continue;
name|tgts
index|[
name|current
index|]
operator|=
name|c
expr_stmt|;
name|current
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|current
operator|!=
name|n
condition|)
do|;
block|}
block|}
name|n
operator|--
expr_stmt|;
name|done
label|:
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
name|zio_buf_free
argument_list|(
name|orig
index|[
name|i
index|]
argument_list|,
name|rm
operator|->
name|rm_col
index|[
literal|0
index|]
operator|.
name|rc_size
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Complete an IO operation on a RAIDZ VDev  *  * Outline:  * - For write operations:  *   1. Check for errors on the child IOs.  *   2. Return, setting an error code if too few child VDevs were written  *      to reconstruct the data later.  Note that partial writes are  *      considered successful if they can be reconstructed at all.  * - For read operations:  *   1. Check for errors on the child IOs.  *   2. If data errors occurred:  *      a. Try to reassemble the data from the parity available.  *      b. If we haven't yet read the parity drives, read them now.  *      c. If all parity drives have been read but the data still doesn't  *         reassemble with a correct checksum, then try combinatorial  *         reconstruction.  *      d. If that doesn't work, return an error.  *   3. If there were unexpected errors or this is a resilver operation,  *      rewrite the vdevs that had errors.  */
end_comment

begin_function
specifier|static
name|void
name|vdev_raidz_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|zio
operator|->
name|io_vd
decl_stmt|;
name|vdev_t
modifier|*
name|cvd
decl_stmt|;
name|raidz_map_t
modifier|*
name|rm
init|=
name|zio
operator|->
name|io_vsd
decl_stmt|;
name|raidz_col_t
modifier|*
name|rc
decl_stmt|;
name|int
name|unexpected_errors
init|=
literal|0
decl_stmt|;
name|int
name|parity_errors
init|=
literal|0
decl_stmt|;
name|int
name|parity_untried
init|=
literal|0
decl_stmt|;
name|int
name|data_errors
init|=
literal|0
decl_stmt|;
name|int
name|total_errors
init|=
literal|0
decl_stmt|;
name|int
name|n
decl_stmt|,
name|c
decl_stmt|;
name|int
name|tgts
index|[
name|VDEV_RAIDZ_MAXPARITY
index|]
decl_stmt|;
name|int
name|code
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_bp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* XXX need to add code to enforce this */
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_missingparity
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_missingdata
operator|<=
name|rm
operator|->
name|rm_cols
operator|-
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
condition|)
block|{
name|ASSERT
argument_list|(
name|rc
operator|->
name|rc_error
operator|!=
name|ECKSUM
argument_list|)
expr_stmt|;
comment|/* child has no bp */
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|parity_errors
operator|++
expr_stmt|;
else|else
name|data_errors
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|rc
operator|->
name|rc_skipped
condition|)
name|unexpected_errors
operator|++
expr_stmt|;
name|total_errors
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|&&
operator|!
name|rc
operator|->
name|rc_tried
condition|)
block|{
name|parity_untried
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
comment|/* 		 * XXX -- for now, treat partial writes as a success. 		 * (If we couldn't write enough columns to reconstruct 		 * the data, the I/O failed.  Otherwise, good enough.) 		 * 		 * Now that we support write reallocation, it would be better 		 * to treat partial failure as real failure unless there are 		 * no non-degraded top-level vdevs left, and not update DTLs 		 * if we intend to reallocate. 		 */
comment|/* XXPOLICY */
if|if
condition|(
name|total_errors
operator|>
name|rm
operator|->
name|rm_firstdatacol
condition|)
name|zio
operator|->
name|io_error
operator|=
name|vdev_raidz_worst_error
argument_list|(
name|rm
argument_list|)
expr_stmt|;
return|return;
block|}
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
argument_list|)
expr_stmt|;
comment|/* 	 * There are three potential phases for a read: 	 *	1. produce valid data from the columns read 	 *	2. read all disks and try again 	 *	3. perform combinatorial reconstruction 	 * 	 * Each phase is progressively both more expensive and less likely to 	 * occur. If we encounter more errors than we can repair or all phases 	 * fail, we have no choice but to return an error. 	 */
comment|/* 	 * If the number of errors we saw was correctable -- less than or equal 	 * to the number of parity disks read -- attempt to produce data that 	 * has a valid checksum. Naturally, this case applies in the absence of 	 * any errors. 	 */
if|if
condition|(
name|total_errors
operator|<=
name|rm
operator|->
name|rm_firstdatacol
operator|-
name|parity_untried
condition|)
block|{
if|if
condition|(
name|data_errors
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|raidz_checksum_verify
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 				 * If we read parity information (unnecessarily 				 * as it happens since no reconstruction was 				 * needed) regenerate and verify the parity. 				 * We also regenerate parity when resilvering 				 * so we can write it out to the failed device 				 * later. 				 */
if|if
condition|(
name|parity_errors
operator|+
name|parity_untried
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
condition|)
block|{
name|n
operator|=
name|raidz_parity_verify
argument_list|(
name|zio
argument_list|,
name|rm
argument_list|)
expr_stmt|;
name|unexpected_errors
operator|+=
name|n
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|+
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
block|}
else|else
block|{
comment|/* 			 * We either attempt to read all the parity columns or 			 * none of them. If we didn't try to read parity, we 			 * wouldn't be here in the correctable case. There must 			 * also have been fewer parity errors than parity 			 * columns or, again, we wouldn't be in this code path. 			 */
name|ASSERT
argument_list|(
name|parity_untried
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
comment|/* 			 * Identify the data columns that reported an error. 			 */
name|n
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
name|rm
operator|->
name|rm_firstdatacol
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|n
operator|<
name|VDEV_RAIDZ_MAXPARITY
argument_list|)
expr_stmt|;
name|tgts
index|[
name|n
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|rm
operator|->
name|rm_firstdatacol
operator|>=
name|n
argument_list|)
expr_stmt|;
name|code
operator|=
name|vdev_raidz_reconstruct
argument_list|(
name|rm
argument_list|,
name|tgts
argument_list|,
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|raidz_checksum_verify
argument_list|(
name|zio
argument_list|)
operator|==
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|raidz_corrected
index|[
name|code
index|]
argument_list|)
expr_stmt|;
comment|/* 				 * If we read more parity disks than were used 				 * for reconstruction, confirm that the other 				 * parity disks produced correct data. This 				 * routine is suboptimal in that it regenerates 				 * the parity that we already used in addition 				 * to the parity that we're attempting to 				 * verify, but this should be a relatively 				 * uncommon case, and can be optimized if it 				 * becomes a problem. Note that we regenerate 				 * parity when resilvering so we can write it 				 * out to failed devices later. 				 */
if|if
condition|(
name|parity_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|-
name|n
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
condition|)
block|{
name|n
operator|=
name|raidz_parity_verify
argument_list|(
name|zio
argument_list|,
name|rm
argument_list|)
expr_stmt|;
name|unexpected_errors
operator|+=
name|n
expr_stmt|;
name|ASSERT
argument_list|(
name|parity_errors
operator|+
name|n
operator|<=
name|rm
operator|->
name|rm_firstdatacol
argument_list|)
expr_stmt|;
block|}
goto|goto
name|done
goto|;
block|}
block|}
block|}
comment|/* 	 * This isn't a typical situation -- either we got a read error or 	 * a child silently returned bad data. Read every block so we can 	 * try again with as much data and parity as we can track down. If 	 * we've already been through once before, all children will be marked 	 * as tried so we'll proceed to combinatorial reconstruction. 	 */
name|unexpected_errors
operator|=
literal|1
expr_stmt|;
name|rm
operator|->
name|rm_missingdata
operator|=
literal|0
expr_stmt|;
name|rm
operator|->
name|rm_missingparity
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
operator|.
name|rc_tried
condition|)
continue|continue;
name|zio_vdev_io_redone
argument_list|(
name|zio
argument_list|)
expr_stmt|;
do|do
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_tried
condition|)
continue|continue;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_abd
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|zio
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
literal|0
argument_list|,
name|vdev_raidz_child_done
argument_list|,
name|rc
argument_list|)
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|)
do|;
return|return;
block|}
comment|/* 	 * At this point we've attempted to reconstruct the data given the 	 * errors we detected, and we've attempted to read all columns. There 	 * must, therefore, be one or more additional problems -- silent errors 	 * resulting in invalid data rather than explicit I/O errors resulting 	 * in absent data. We check if there is enough additional data to 	 * possibly reconstruct the data and then perform combinatorial 	 * reconstruction over all possible combinations. If that fails, 	 * we're cooked. 	 */
if|if
condition|(
name|total_errors
operator|>
name|rm
operator|->
name|rm_firstdatacol
condition|)
block|{
name|zio
operator|->
name|io_error
operator|=
name|vdev_raidz_worst_error
argument_list|(
name|rm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|total_errors
operator|<
name|rm
operator|->
name|rm_firstdatacol
operator|&&
operator|(
name|code
operator|=
name|vdev_raidz_combrec
argument_list|(
name|zio
argument_list|,
name|total_errors
argument_list|,
name|data_errors
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * If we didn't use all the available parity for the 		 * combinatorial reconstruction, verify that the remaining 		 * parity is correct. 		 */
if|if
condition|(
name|code
operator|!=
operator|(
literal|1
operator|<<
name|rm
operator|->
name|rm_firstdatacol
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|raidz_parity_verify
argument_list|(
name|zio
argument_list|,
name|rm
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * We're here because either: 		 * 		 *	total_errors == rm_first_datacol, or 		 *	vdev_raidz_combrec() failed 		 * 		 * In either case, there is enough bad data to prevent 		 * reconstruction. 		 * 		 * Start checksum ereports for all children which haven't 		 * failed, and the IO wasn't speculative. 		 */
name|zio
operator|->
name|io_error
operator|=
name|SET_ERROR
argument_list|(
name|ECKSUM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_SPECULATIVE
operator|)
condition|)
block|{
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
block|{
name|zio_bad_cksum_t
name|zbc
decl_stmt|;
name|zbc
operator|.
name|zbc_has_cksum
operator|=
literal|0
expr_stmt|;
name|zbc
operator|.
name|zbc_injected
operator|=
name|rm
operator|->
name|rm_ecksuminjected
expr_stmt|;
name|zfs_ereport_start_checksum
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|,
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
argument_list|,
name|zio
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|(
name|uintptr_t
operator|)
name|c
argument_list|,
operator|&
name|zbc
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|done
label|:
name|zio_checksum_verified
argument_list|(
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_error
operator|==
literal|0
operator|&&
name|spa_writeable
argument_list|(
name|zio
operator|->
name|io_spa
argument_list|)
operator|&&
operator|(
name|unexpected_errors
operator|||
operator|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_RESILVER
operator|)
operator|)
condition|)
block|{
comment|/* 		 * Use the good data we have in hand to repair damaged children. 		 */
for|for
control|(
name|c
operator|=
literal|0
init|;
name|c
operator|<
name|rm
operator|->
name|rm_cols
condition|;
name|c
operator|++
control|)
block|{
name|rc
operator|=
operator|&
name|rm
operator|->
name|rm_col
index|[
name|c
index|]
expr_stmt|;
name|cvd
operator|=
name|vd
operator|->
name|vdev_child
index|[
name|rc
operator|->
name|rc_devidx
index|]
expr_stmt|;
if|if
condition|(
name|rc
operator|->
name|rc_error
operator|==
literal|0
condition|)
continue|continue;
name|zio_nowait
argument_list|(
name|zio_vdev_child_io
argument_list|(
name|zio
argument_list|,
name|NULL
argument_list|,
name|cvd
argument_list|,
name|rc
operator|->
name|rc_offset
argument_list|,
name|rc
operator|->
name|rc_abd
argument_list|,
name|rc
operator|->
name|rc_size
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|,
name|ZIO_PRIORITY_ASYNC_WRITE
argument_list|,
name|ZIO_FLAG_IO_REPAIR
operator||
operator|(
name|unexpected_errors
condition|?
name|ZIO_FLAG_SELF_HEAL
else|:
literal|0
operator|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_raidz_state_change
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|,
name|int
name|faulted
parameter_list|,
name|int
name|degraded
parameter_list|)
block|{
if|if
condition|(
name|faulted
operator|>
name|vd
operator|->
name|vdev_nparity
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_CANT_OPEN
argument_list|,
name|VDEV_AUX_NO_REPLICAS
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|degraded
operator|+
name|faulted
operator|!=
literal|0
condition|)
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_DEGRADED
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
else|else
name|vdev_set_state
argument_list|(
name|vd
argument_list|,
name|B_FALSE
argument_list|,
name|VDEV_STATE_HEALTHY
argument_list|,
name|VDEV_AUX_NONE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|vdev_ops_t
name|vdev_raidz_ops
init|=
block|{
name|vdev_raidz_open
block|,
name|vdev_raidz_close
block|,
name|vdev_raidz_asize
block|,
name|vdev_raidz_io_start
block|,
name|vdev_raidz_io_done
block|,
name|vdev_raidz_state_change
block|,
name|NULL
block|,
name|NULL
block|,
name|VDEV_TYPE_RAIDZ
block|,
comment|/* name of this vdev type */
name|B_FALSE
comment|/* not a leaf vdev */
block|}
decl_stmt|;
end_decl_stmt

end_unit

