begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012, 2015 by Delphix. All rights reserved.  * Copyright 2015, OmniTI Computer Consulting, Inc. All rights reserved.  */
end_comment

begin_comment
comment|/*  * ZFS control directory (a.k.a. ".zfs")  *  * This directory provides a common location for all ZFS meta-objects.  * Currently, this is only the 'snapshot' directory, but this may expand in the  * future.  The elements are built using the GFS primitives, as the hierarchy  * does not actually exist on disk.  *  * For 'snapshot', we don't want to have all snapshots always mounted, because  * this would take up a huge amount of space in /etc/mnttab.  We have three  * types of objects:  *  * 	ctldir ------> snapshotdir -------> snapshot  *                                             |  *                                             |  *                                             V  *                                         mounted fs  *  * The 'snapshot' node contains just enough information to lookup '..' and act  * as a mountpoint for the snapshot.  Whenever we lookup a specific snapshot, we  * perform an automount of the underlying filesystem and return the  * corresponding vnode.  *  * All mounts are handled automatically by the kernel, but unmounts are  * (currently) handled from user land.  The main reason is that there is no  * reliable way to auto-unmount the filesystem when it's "no longer in use".  * When the user unmounts a filesystem, we call zfsctl_unmount(), which  * unmounts any snapshots within the snapshot directory.  *  * The '.zfs', '.zfs/snapshot', and all directories created under  * '.zfs/snapshot' (ie: '.zfs/snapshot/<snapname>') are all GFS nodes and  * share the same vfs_t as the head filesystem (what '.zfs' lives under).  *  * File systems mounted ontop of the GFS nodes '.zfs/snapshot/<snapname>'  * (ie: snapshots) are ZFS nodes and have their own unique vfs_t.  * However, vnodes within these mounted on file systems have their v_vfsp  * fields set to the head filesystem to make NFS happy (see  * zfsctl_snapdir_lookup()). We VFS_HOLD the head filesystem's vfs_t  * so that it cannot be freed until all snapshots have been unmounted.  */
end_comment

begin_include
include|#
directive|include
file|<fs/fs_subr.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ctldir.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_ioctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_vfsops.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs_opreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/gfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_destroy.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deleg.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|"zfs_namecheck.h"
end_include

begin_typedef
typedef|typedef
struct|struct
name|zfsctl_node
block|{
name|gfs_dir_t
name|zc_gfs_private
decl_stmt|;
name|uint64_t
name|zc_id
decl_stmt|;
name|timestruc_t
name|zc_cmtime
decl_stmt|;
comment|/* ctime and mtime, always the same */
block|}
name|zfsctl_node_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|zfsctl_snapdir
block|{
name|zfsctl_node_t
name|sd_node
decl_stmt|;
name|kmutex_t
name|sd_lock
decl_stmt|;
name|avl_tree_t
name|sd_snaps
decl_stmt|;
block|}
name|zfsctl_snapdir_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|char
modifier|*
name|se_name
decl_stmt|;
name|vnode_t
modifier|*
name|se_root
decl_stmt|;
name|avl_node_t
name|se_node
decl_stmt|;
block|}
name|zfs_snapentry_t
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|snapentry_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
block|{
specifier|const
name|zfs_snapentry_t
modifier|*
name|sa
init|=
name|a
decl_stmt|;
specifier|const
name|zfs_snapentry_t
modifier|*
name|sb
init|=
name|b
decl_stmt|;
name|int
name|ret
init|=
name|strcmp
argument_list|(
name|sa
operator|->
name|se_name
argument_list|,
name|sb
operator|->
name|se_name
argument_list|)
decl_stmt|;
if|if
condition|(
name|ret
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
elseif|else
if|if
condition|(
name|ret
operator|>
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfsctl_ops_root
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfsctl_ops_snapdir
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfsctl_ops_snapshot
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|vnodeops_t
modifier|*
name|zfsctl_ops_shares
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_root
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_snapdir
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_snapshot
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_shares
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|vnode_t
modifier|*
name|zfsctl_mknode_snapdir
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vnode_t
modifier|*
name|zfsctl_mknode_shares
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|vnode_t
modifier|*
name|zfsctl_snapshot_mknode
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|uint64_t
name|objset
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|zfsctl_unmount_snap
parameter_list|(
name|zfs_snapentry_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|gfs_opsvec_t
name|zfsctl_opsvec
index|[]
init|=
block|{
block|{
literal|".zfs"
block|,
name|zfsctl_tops_root
block|,
operator|&
name|zfsctl_ops_root
block|}
block|,
block|{
literal|".zfs/snapshot"
block|,
name|zfsctl_tops_snapdir
block|,
operator|&
name|zfsctl_ops_snapdir
block|}
block|,
block|{
literal|".zfs/snapshot/vnode"
block|,
name|zfsctl_tops_snapshot
block|,
operator|&
name|zfsctl_ops_snapshot
block|}
block|,
block|{
literal|".zfs/shares"
block|,
name|zfsctl_tops_shares
block|,
operator|&
name|zfsctl_ops_shares
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Root directory elements.  We only have two entries  * snapshot and shares.  */
end_comment

begin_decl_stmt
specifier|static
name|gfs_dirent_t
name|zfsctl_root_entries
index|[]
init|=
block|{
block|{
literal|"snapshot"
block|,
name|zfsctl_mknode_snapdir
block|,
name|GFS_CACHE_VNODE
block|}
block|,
block|{
literal|"shares"
block|,
name|zfsctl_mknode_shares
block|,
name|GFS_CACHE_VNODE
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* include . and .. in the calculation */
end_comment

begin_define
define|#
directive|define
name|NROOT_ENTRIES
value|((sizeof (zfsctl_root_entries) / \     sizeof (gfs_dirent_t)) + 1)
end_define

begin_comment
comment|/*  * Initialize the various GFS pieces we'll need to create and manipulate .zfs  * directories.  This is called from the ZFS init routine, and initializes the  * vnode ops vectors that we'll be using.  */
end_comment

begin_function
name|void
name|zfsctl_init
parameter_list|(
name|void
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|gfs_make_opsvec
argument_list|(
name|zfsctl_opsvec
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zfsctl_fini
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * Remove vfsctl vnode ops 	 */
if|if
condition|(
name|zfsctl_ops_root
condition|)
name|vn_freevnodeops
argument_list|(
name|zfsctl_ops_root
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsctl_ops_snapdir
condition|)
name|vn_freevnodeops
argument_list|(
name|zfsctl_ops_snapdir
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsctl_ops_snapshot
condition|)
name|vn_freevnodeops
argument_list|(
name|zfsctl_ops_snapshot
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsctl_ops_shares
condition|)
name|vn_freevnodeops
argument_list|(
name|zfsctl_ops_shares
argument_list|)
expr_stmt|;
name|zfsctl_ops_root
operator|=
name|NULL
expr_stmt|;
name|zfsctl_ops_snapdir
operator|=
name|NULL
expr_stmt|;
name|zfsctl_ops_snapshot
operator|=
name|NULL
expr_stmt|;
name|zfsctl_ops_shares
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|zfsctl_is_node
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|vn_matchops
argument_list|(
name|vp
argument_list|,
name|zfsctl_ops_root
argument_list|)
operator|||
name|vn_matchops
argument_list|(
name|vp
argument_list|,
name|zfsctl_ops_snapdir
argument_list|)
operator|||
name|vn_matchops
argument_list|(
name|vp
argument_list|,
name|zfsctl_ops_snapshot
argument_list|)
operator|||
name|vn_matchops
argument_list|(
name|vp
argument_list|,
name|zfsctl_ops_shares
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the inode number associated with the 'snapshot' or  * 'shares' directory.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|ino64_t
name|zfsctl_root_inode_cb
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|index
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|ASSERT
argument_list|(
name|index
operator|<
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|index
operator|==
literal|0
condition|)
return|return
operator|(
name|ZFSCTL_INO_SNAPDIR
operator|)
return|;
return|return
operator|(
name|zfsvfs
operator|->
name|z_shares_dir
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create the '.zfs' directory.  This directory is cached as part of the VFS  * structure.  This results in a hold on the vfs_t.  The code in zfs_umount()  * therefore checks against a vfs_count of 2 instead of 1.  This reference  * is removed when the ctldir is destroyed in the unmount.  */
end_comment

begin_function
name|void
name|zfsctl_create
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|,
modifier|*
name|rvp
decl_stmt|;
name|zfsctl_node_t
modifier|*
name|zcp
decl_stmt|;
name|uint64_t
name|crtime
index|[
literal|2
index|]
decl_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|=
name|gfs_root_create
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsctl_node_t
argument_list|)
argument_list|,
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
name|zfsctl_ops_root
argument_list|,
name|ZFSCTL_INO_ROOT
argument_list|,
name|zfsctl_root_entries
argument_list|,
name|zfsctl_root_inode_cb
argument_list|,
name|MAXNAMELEN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zcp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
name|zcp
operator|->
name|zc_id
operator|=
name|ZFSCTL_INO_ROOT
expr_stmt|;
name|VERIFY
argument_list|(
name|VFS_ROOT
argument_list|(
name|zfsvfs
operator|->
name|z_vfs
argument_list|,
operator|&
name|rvp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|sa_lookup
argument_list|(
name|VTOZ
argument_list|(
name|rvp
argument_list|)
operator|->
name|z_sa_hdl
argument_list|,
name|SA_ZPL_CRTIME
argument_list|(
name|zfsvfs
argument_list|)
argument_list|,
operator|&
name|crtime
argument_list|,
sizeof|sizeof
argument_list|(
name|crtime
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ZFS_TIME_DECODE
argument_list|(
operator|&
name|zcp
operator|->
name|zc_cmtime
argument_list|,
name|crtime
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|rvp
argument_list|)
expr_stmt|;
comment|/* 	 * We're only faking the fact that we have a root of a filesystem for 	 * the sake of the GFS interfaces.  Undo the flag manipulation it did 	 * for us. 	 */
name|vp
operator|->
name|v_flag
operator|&=
operator|~
operator|(
name|VROOT
operator||
name|VNOCACHE
operator||
name|VNOMAP
operator||
name|VNOSWAP
operator||
name|VNOMOUNT
operator|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_ctldir
operator|=
name|vp
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroy the '.zfs' directory.  Only called when the filesystem is unmounted.  * There might still be more references if we were force unmounted, but only  * new zfs_inactive() calls can occur and they don't reference .zfs  */
end_comment

begin_function
name|void
name|zfsctl_destroy
parameter_list|(
name|zfsvfs_t
modifier|*
name|zfsvfs
parameter_list|)
block|{
name|VN_RELE
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
argument_list|)
expr_stmt|;
name|zfsvfs
operator|->
name|z_ctldir
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Given a root znode, retrieve the associated .zfs directory.  * Add a hold to the vnode and return it.  */
end_comment

begin_function
name|vnode_t
modifier|*
name|zfsctl_root
parameter_list|(
name|znode_t
modifier|*
name|zp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|zfs_has_ctldir
argument_list|(
name|zp
argument_list|)
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_ctldir
argument_list|)
expr_stmt|;
return|return
operator|(
name|zp
operator|->
name|z_zfsvfs
operator|->
name|z_ctldir
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common open routine.  Disallow any write access.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_common_open
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|FWRITE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common close routine.  Nothing to do here.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_common_close
parameter_list|(
name|vnode_t
modifier|*
name|vpp
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
name|count
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common access routine.  Disallow writes.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_common_access
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|flags
operator|&
name|V_ACE_MASK
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|ACE_ALL_WRITE_PERMS
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|mode
operator|&
name|VWRITE
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EACCES
argument_list|)
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Common getattr function.  Fill in basic information.  */
end_comment

begin_function
specifier|static
name|void
name|zfsctl_common_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|)
block|{
name|timestruc_t
name|now
decl_stmt|;
name|vap
operator|->
name|va_uid
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_gid
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_rdev
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We are a purely virtual object, so we have no 	 * blocksize or allocated blocks. 	 */
name|vap
operator|->
name|va_blksize
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_nblocks
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_seq
operator|=
literal|0
expr_stmt|;
name|vap
operator|->
name|va_fsid
operator|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_dev
expr_stmt|;
name|vap
operator|->
name|va_mode
operator|=
name|S_IRUSR
operator||
name|S_IXUSR
operator||
name|S_IRGRP
operator||
name|S_IXGRP
operator||
name|S_IROTH
operator||
name|S_IXOTH
expr_stmt|;
name|vap
operator|->
name|va_type
operator|=
name|VDIR
expr_stmt|;
comment|/* 	 * We live in the now (for atime). 	 */
name|gethrestime
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_atime
operator|=
name|now
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfsctl_common_fid
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|zfsctl_node_t
modifier|*
name|zcp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|uint64_t
name|object
init|=
name|zcp
operator|->
name|zc_id
decl_stmt|;
name|zfid_short_t
modifier|*
name|zfid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fidp
operator|->
name|fid_len
operator|<
name|SHORT_FID_LEN
condition|)
block|{
name|fidp
operator|->
name|fid_len
operator|=
name|SHORT_FID_LEN
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOSPC
argument_list|)
operator|)
return|;
block|}
name|zfid
operator|=
operator|(
name|zfid_short_t
operator|*
operator|)
name|fidp
expr_stmt|;
name|zfid
operator|->
name|zf_len
operator|=
name|SHORT_FID_LEN
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_object
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_object
index|[
name|i
index|]
operator|=
call|(
name|uint8_t
call|)
argument_list|(
name|object
operator|>>
operator|(
literal|8
operator|*
name|i
operator|)
argument_list|)
expr_stmt|;
comment|/* .zfs znodes always have a generation number of 0 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|zfid
operator|->
name|zf_gen
argument_list|)
condition|;
name|i
operator|++
control|)
name|zfid
operator|->
name|zf_gen
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfsctl_shares_fid
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_shares_dir
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_shares_dir
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_FID
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|fidp
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * .zfs inode namespace  *  * We need to generate unique inode numbers for all files and directories  * within the .zfs pseudo-filesystem.  We use the following scheme:  *  * 	ENTRY			ZFSCTL_INODE  * 	.zfs			1  * 	.zfs/snapshot		2  * 	.zfs/snapshot/<snap>	objectid(snap)  */
end_comment

begin_define
define|#
directive|define
name|ZFSCTL_INO_SNAP
parameter_list|(
name|id
parameter_list|)
value|(id)
end_define

begin_comment
comment|/*  * Get root directory attributes.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_root_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|zfsctl_node_t
modifier|*
name|zcp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_nodeid
operator|=
name|ZFSCTL_INO_ROOT
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|vap
operator|->
name|va_size
operator|=
name|NROOT_ENTRIES
expr_stmt|;
name|vap
operator|->
name|va_mtime
operator|=
name|vap
operator|->
name|va_ctime
operator|=
name|zcp
operator|->
name|zc_cmtime
expr_stmt|;
name|zfsctl_common_getattr
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Special case the handling of "..".  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|zfsctl_root_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|pathname_t
modifier|*
name|pnp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
name|rdir
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * No extended attributes allowed under .zfs 	 */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_XATTR
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|VFS_ROOT
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|vpp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|gfs_vop_lookup
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|vpp
argument_list|,
name|pnp
argument_list|,
name|flags
argument_list|,
name|rdir
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|,
name|direntflags
argument_list|,
name|realpnp
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfsctl_pathconf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|ulong_t
modifier|*
name|valp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
comment|/* 	 * We only care about ACL_ENABLED so that libsec can 	 * display ACL correctly and not default to POSIX draft. 	 */
if|if
condition|(
name|cmd
operator|==
name|_PC_ACL_ENABLED
condition|)
block|{
operator|*
name|valp
operator|=
name|_ACL_ACE_ENABLED
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|fs_pathconf
argument_list|(
name|vp
argument_list|,
name|cmd
argument_list|,
name|valp
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_root
index|[]
init|=
block|{
block|{
name|VOPNAME_OPEN
block|,
block|{
operator|.
name|vop_open
operator|=
name|zfsctl_common_open
block|}
block|}
block|,
block|{
name|VOPNAME_CLOSE
block|,
block|{
operator|.
name|vop_close
operator|=
name|zfsctl_common_close
block|}
block|}
block|,
block|{
name|VOPNAME_IOCTL
block|,
block|{
operator|.
name|error
operator|=
name|fs_inval
block|}
block|}
block|,
block|{
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfsctl_root_getattr
block|}
block|}
block|,
block|{
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfsctl_common_access
block|}
block|}
block|,
block|{
name|VOPNAME_READDIR
block|,
block|{
operator|.
name|vop_readdir
operator|=
name|gfs_vop_readdir
block|}
block|}
block|,
block|{
name|VOPNAME_LOOKUP
block|,
block|{
operator|.
name|vop_lookup
operator|=
name|zfsctl_root_lookup
block|}
block|}
block|,
block|{
name|VOPNAME_SEEK
block|,
block|{
operator|.
name|vop_seek
operator|=
name|fs_seek
block|}
block|}
block|,
block|{
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|gfs_vop_inactive
block|}
block|}
block|,
block|{
name|VOPNAME_PATHCONF
block|,
block|{
operator|.
name|vop_pathconf
operator|=
name|zfsctl_pathconf
block|}
block|}
block|,
block|{
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfsctl_common_fid
block|}
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Gets the full dataset name that corresponds to the given snapshot name  * Example:  * 	zfsctl_snapshot_zname("snap1") -> "mypool/myfs@snap1"  */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_snapshot_zname
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|len
parameter_list|,
name|char
modifier|*
name|zname
parameter_list|)
block|{
name|objset_t
modifier|*
name|os
init|=
operator|(
operator|(
name|zfsvfs_t
operator|*
operator|)
operator|(
operator|(
name|vp
operator|)
operator|->
name|v_vfsp
operator|->
name|vfs_data
operator|)
operator|)
operator|->
name|z_os
decl_stmt|;
if|if
condition|(
name|zfs_component_namecheck
argument_list|(
name|name
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
name|dmu_objset_name
argument_list|(
name|os
argument_list|,
name|zname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|zname
argument_list|)
operator|+
literal|1
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|>=
name|len
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENAMETOOLONG
argument_list|)
operator|)
return|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zname
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|zname
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|zfsctl_unmount_snap
parameter_list|(
name|zfs_snapentry_t
modifier|*
name|sep
parameter_list|,
name|int
name|fflags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|vnode_t
modifier|*
name|svp
init|=
name|sep
operator|->
name|se_root
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|vn_ismntpt
argument_list|(
name|svp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* this will be dropped by dounmount() */
if|if
condition|(
operator|(
name|error
operator|=
name|vn_vfswlock
argument_list|(
name|svp
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|VN_HOLD
argument_list|(
name|svp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dounmount
argument_list|(
name|vn_mountedvfs
argument_list|(
name|svp
argument_list|)
argument_list|,
name|fflags
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|VN_RELE
argument_list|(
name|svp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * We can't use VN_RELE(), as that will try to invoke 	 * zfsctl_snapdir_inactive(), which would cause us to destroy 	 * the sd_lock mutex held by our caller. 	 */
name|ASSERT
argument_list|(
name|svp
operator|->
name|v_count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|gfs_vop_inactive
argument_list|(
name|svp
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sep
operator|->
name|se_name
argument_list|,
name|strlen
argument_list|(
name|sep
operator|->
name|se_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sep
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_snapentry_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfsctl_rename_snap
parameter_list|(
name|zfsctl_snapdir_t
modifier|*
name|sdp
parameter_list|,
name|zfs_snapentry_t
modifier|*
name|sep
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|)
block|{
name|avl_index_t
name|where
decl_stmt|;
name|vfs_t
modifier|*
name|vfsp
decl_stmt|;
name|refstr_t
modifier|*
name|pathref
decl_stmt|;
name|char
name|newpath
index|[
name|MAXNAMELEN
index|]
decl_stmt|;
name|char
modifier|*
name|tail
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|sep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vfsp
operator|=
name|vn_mountedvfs
argument_list|(
name|sep
operator|->
name|se_root
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vfsp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vfs_lock_wait
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
comment|/* 	 * Change the name in the AVL tree. 	 */
name|avl_remove
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sep
operator|->
name|se_name
argument_list|,
name|strlen
argument_list|(
name|sep
operator|->
name|se_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|sep
operator|->
name|se_name
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|nm
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sep
operator|->
name|se_name
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|avl_find
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|,
operator|&
name|where
argument_list|)
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|avl_insert
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|,
name|where
argument_list|)
expr_stmt|;
comment|/* 	 * Change the current mountpoint info: 	 * 	- update the tail of the mntpoint path 	 *	- update the tail of the resource path 	 */
name|pathref
operator|=
name|vfs_getmntpoint
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|newpath
argument_list|,
name|refstr_value
argument_list|(
name|pathref
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|newpath
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|(
name|tail
operator|=
name|strrchr
argument_list|(
name|newpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tail
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|ASSERT3U
argument_list|(
name|strlen
argument_list|(
name|newpath
argument_list|)
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
argument_list|,
operator|<
argument_list|,
sizeof|sizeof
argument_list|(
name|newpath
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|newpath
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|refstr_rele
argument_list|(
name|pathref
argument_list|)
expr_stmt|;
name|vfs_setmntpoint
argument_list|(
name|vfsp
argument_list|,
name|newpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|pathref
operator|=
name|vfs_getresource
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|newpath
argument_list|,
name|refstr_value
argument_list|(
name|pathref
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|newpath
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
operator|(
name|tail
operator|=
name|strrchr
argument_list|(
name|newpath
argument_list|,
literal|'@'
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
operator|(
name|tail
operator|+
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
name|ASSERT3U
argument_list|(
name|strlen
argument_list|(
name|newpath
argument_list|)
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
argument_list|,
operator|<
argument_list|,
sizeof|sizeof
argument_list|(
name|newpath
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|newpath
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|refstr_rele
argument_list|(
name|pathref
argument_list|)
expr_stmt|;
name|vfs_setresource
argument_list|(
name|vfsp
argument_list|,
name|newpath
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vfs_unlock
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|zfsctl_snapdir_rename
parameter_list|(
name|vnode_t
modifier|*
name|sdvp
parameter_list|,
name|char
modifier|*
name|snm
parameter_list|,
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|char
modifier|*
name|tnm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zfsctl_snapdir_t
modifier|*
name|sdp
init|=
name|sdvp
operator|->
name|v_data
decl_stmt|;
name|zfs_snapentry_t
name|search
decl_stmt|,
modifier|*
name|sep
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|char
name|from
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|,
name|to
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|real
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|,
name|fsname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zfsvfs
operator|=
name|sdvp
operator|->
name|v_vfsp
operator|->
name|vfs_data
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FIGNORECASE
operator|)
operator|||
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
condition|)
block|{
name|err
operator|=
name|dmu_snapshot_realname
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|snm
argument_list|,
name|real
argument_list|,
sizeof|sizeof
argument_list|(
name|real
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|snm
operator|=
name|real
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|ENOTSUP
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|dmu_objset_name
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfsctl_snapshot_zname
argument_list|(
name|sdvp
argument_list|,
name|snm
argument_list|,
sizeof|sizeof
argument_list|(
name|from
argument_list|)
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|zfsctl_snapshot_zname
argument_list|(
name|tdvp
argument_list|,
name|tnm
argument_list|,
sizeof|sizeof
argument_list|(
name|to
argument_list|)
argument_list|,
name|to
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|zfs_secpolicy_rename_perms
argument_list|(
name|from
argument_list|,
name|to
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
comment|/* 	 * Cannot move snapshots out of the snapdir. 	 */
if|if
condition|(
name|sdvp
operator|!=
name|tdvp
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
if|if
condition|(
name|strcmp
argument_list|(
name|snm
argument_list|,
name|tnm
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|search
operator|.
name|se_name
operator|=
operator|(
name|char
operator|*
operator|)
name|snm
expr_stmt|;
if|if
condition|(
operator|(
name|sep
operator|=
name|avl_find
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
name|err
operator|=
name|dsl_dataset_rename_snapshot
argument_list|(
name|fsname
argument_list|,
name|snm
argument_list|,
name|tnm
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|zfsctl_rename_snap
argument_list|(
name|sdp
argument_list|,
name|sep
argument_list|,
name|tnm
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_snapdir_remove
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vnode_t
modifier|*
name|cwd
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zfsctl_snapdir_t
modifier|*
name|sdp
init|=
name|dvp
operator|->
name|v_data
decl_stmt|;
name|zfs_snapentry_t
modifier|*
name|sep
decl_stmt|;
name|zfs_snapentry_t
name|search
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
decl_stmt|;
name|char
name|snapname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|real
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
name|zfsvfs
operator|=
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_data
expr_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|FIGNORECASE
operator|)
operator|||
name|zfsvfs
operator|->
name|z_case
operator|==
name|ZFS_CASE_INSENSITIVE
condition|)
block|{
name|err
operator|=
name|dmu_snapshot_realname
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|name
argument_list|,
name|real
argument_list|,
sizeof|sizeof
argument_list|(
name|real
argument_list|)
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|name
operator|=
name|real
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|ENOTSUP
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfsctl_snapshot_zname
argument_list|(
name|dvp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
name|err
operator|=
name|zfs_secpolicy_destroy_perms
argument_list|(
name|snapname
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|search
operator|.
name|se_name
operator|=
name|name
expr_stmt|;
name|sep
operator|=
name|avl_find
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
operator|&
name|search
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
condition|)
block|{
name|avl_remove
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|err
operator|=
name|zfsctl_unmount_snap
argument_list|(
name|sep
argument_list|,
name|MS_FORCE
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|avl_add
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
else|else
name|err
operator|=
name|dsl_destroy_snapshot
argument_list|(
name|snapname
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|err
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This creates a snapshot under '.zfs/snapshot'.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_snapdir_mkdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|cc
parameter_list|,
name|int
name|flags
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|char
name|name
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|int
name|err
decl_stmt|;
specifier|static
name|enum
name|symfollow
name|follow
init|=
name|NO_FOLLOW
decl_stmt|;
specifier|static
name|enum
name|uio_seg
name|seg
init|=
name|UIO_SYSSPACE
decl_stmt|;
if|if
condition|(
name|zfs_component_namecheck
argument_list|(
name|dirname
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EILSEQ
argument_list|)
operator|)
return|;
name|dmu_objset_name
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|name
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
name|err
operator|=
name|zfs_secpolicy_snapshot_perms
argument_list|(
name|name
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dmu_objset_snapshot_one
argument_list|(
name|name
argument_list|,
name|dirname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
return|return
operator|(
name|err
operator|)
return|;
name|err
operator|=
name|lookupnameat
argument_list|(
name|dirname
argument_list|,
name|seg
argument_list|,
name|follow
argument_list|,
name|NULL
argument_list|,
name|vpp
argument_list|,
name|dvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Lookup entry point for the 'snapshot' directory.  Try to open the  * snapshot if it exist, creating the pseudo filesystem vnode as necessary.  * Perform a mount of the associated dataset on top of the vnode.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_snapdir_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|pathname_t
modifier|*
name|pnp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
name|rdir
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
name|zfsctl_snapdir_t
modifier|*
name|sdp
init|=
name|dvp
operator|->
name|v_data
decl_stmt|;
name|objset_t
modifier|*
name|snap
decl_stmt|;
name|char
name|snapname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
name|real
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|mountpoint
decl_stmt|;
name|zfs_snapentry_t
modifier|*
name|sep
decl_stmt|,
name|search
decl_stmt|;
name|struct
name|mounta
name|margs
decl_stmt|;
name|vfs_t
modifier|*
name|vfsp
decl_stmt|;
name|size_t
name|mountpoint_len
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * No extended attributes allowed under .zfs 	 */
if|if
condition|(
name|flags
operator|&
name|LOOKUP_XATTR
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
operator|)
return|;
name|ASSERT
argument_list|(
name|dvp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
comment|/* 	 * If we get a recursive call, that means we got called 	 * from the domount() code while it was trying to look up the 	 * spec (which looks like a local path for zfs).  We need to 	 * add some flag to domount() to tell it not to do this lookup. 	 */
if|if
condition|(
name|MUTEX_HELD
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
condition|)
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfs_lookup_dot
argument_list|(
name|vpp
argument_list|,
name|dvp
argument_list|,
name|zfsvfs
operator|->
name|z_ctldir
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
condition|)
block|{
name|boolean_t
name|conflict
init|=
name|B_FALSE
decl_stmt|;
name|err
operator|=
name|dmu_snapshot_realname
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
name|nm
argument_list|,
name|real
argument_list|,
sizeof|sizeof
argument_list|(
name|real
argument_list|)
argument_list|,
operator|&
name|conflict
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|nm
operator|=
name|real
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|err
operator|!=
name|ENOTSUP
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|realpnp
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|realpnp
operator|->
name|pn_buf
argument_list|,
name|nm
argument_list|,
name|realpnp
operator|->
name|pn_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|conflict
operator|&&
name|direntflags
condition|)
operator|*
name|direntflags
operator|=
name|ED_CASE_CONFLICT
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|search
operator|.
name|se_name
operator|=
operator|(
name|char
operator|*
operator|)
name|nm
expr_stmt|;
if|if
condition|(
operator|(
name|sep
operator|=
name|avl_find
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|where
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|vpp
operator|=
name|sep
operator|->
name|se_root
expr_stmt|;
name|VN_HOLD
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|err
operator|=
name|traverse
argument_list|(
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|vpp
operator|==
name|sep
operator|->
name|se_root
condition|)
block|{
comment|/* 			 * The snapshot was unmounted behind our backs, 			 * try to remount it. 			 */
goto|goto
name|domount
goto|;
block|}
else|else
block|{
comment|/* 			 * VROOT was set during the traverse call.  We need 			 * to clear it since we're pretending to be part 			 * of our parent's vfs. 			 */
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_flag
operator|&=
operator|~
name|VROOT
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
comment|/* 	 * The requested snapshot is not currently mounted, look it up. 	 */
name|err
operator|=
name|zfsctl_snapshot_zname
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 		 * handle "ls *" or "?" in a graceful manner, 		 * forcing EILSEQ to ENOENT. 		 * Since shell ultimately passes "*" or "?" as name to lookup 		 */
return|return
operator|(
name|err
operator|==
name|EILSEQ
condition|?
name|ENOENT
else|:
name|err
operator|)
return|;
block|}
if|if
condition|(
name|dmu_objset_hold
argument_list|(
name|snapname
argument_list|,
name|FTAG
argument_list|,
operator|&
name|snap
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
name|sep
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|zfs_snapentry_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|sep
operator|->
name|se_name
operator|=
name|kmem_alloc
argument_list|(
name|strlen
argument_list|(
name|nm
argument_list|)
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|sep
operator|->
name|se_name
argument_list|,
name|nm
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|sep
operator|->
name|se_root
operator|=
name|zfsctl_snapshot_mknode
argument_list|(
name|dvp
argument_list|,
name|dmu_objset_id
argument_list|(
name|snap
argument_list|)
argument_list|)
expr_stmt|;
name|avl_insert
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|dmu_objset_rele
argument_list|(
name|snap
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|domount
label|:
name|mountpoint_len
operator|=
name|strlen
argument_list|(
name|refstr_value
argument_list|(
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_mntpt
argument_list|)
argument_list|)
operator|+
name|strlen
argument_list|(
literal|"/.zfs/snapshot/"
argument_list|)
operator|+
name|strlen
argument_list|(
name|nm
argument_list|)
operator|+
literal|1
expr_stmt|;
name|mountpoint
operator|=
name|kmem_alloc
argument_list|(
name|mountpoint_len
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|mountpoint
argument_list|,
name|mountpoint_len
argument_list|,
literal|"%s/.zfs/snapshot/%s"
argument_list|,
name|refstr_value
argument_list|(
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_mntpt
argument_list|)
argument_list|,
name|nm
argument_list|)
expr_stmt|;
name|margs
operator|.
name|spec
operator|=
name|snapname
expr_stmt|;
name|margs
operator|.
name|dir
operator|=
name|mountpoint
expr_stmt|;
name|margs
operator|.
name|flags
operator|=
name|MS_SYSSPACE
operator||
name|MS_NOMNTTAB
expr_stmt|;
name|margs
operator|.
name|fstype
operator|=
literal|"zfs"
expr_stmt|;
name|margs
operator|.
name|dataptr
operator|=
name|NULL
expr_stmt|;
name|margs
operator|.
name|datalen
operator|=
literal|0
expr_stmt|;
name|margs
operator|.
name|optptr
operator|=
name|NULL
expr_stmt|;
name|margs
operator|.
name|optlen
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|domount
argument_list|(
literal|"zfs"
argument_list|,
operator|&
name|margs
argument_list|,
operator|*
name|vpp
argument_list|,
name|kcred
argument_list|,
operator|&
name|vfsp
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mountpoint
argument_list|,
name|mountpoint_len
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Return the mounted root rather than the covered mount point. 		 * Takes the GFS vnode at .zfs/snapshot/<snapname> and returns 		 * the ZFS vnode mounted on top of the GFS node.  This ZFS 		 * vnode is the root of the newly created vfsp. 		 */
name|VFS_RELE
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|err
operator|=
name|traverse
argument_list|(
name|vpp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Fix up the root vnode mounted on .zfs/snapshot/<snapname>. 		 * 		 * This is where we lie about our v_vfsp in order to 		 * make .zfs/snapshot/<snapname> accessible over NFS 		 * without requiring manual mounts of<snapname>. 		 */
name|ASSERT
argument_list|(
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|z_zfsvfs
operator|!=
name|zfsvfs
argument_list|)
expr_stmt|;
name|VTOZ
argument_list|(
operator|*
name|vpp
argument_list|)
operator|->
name|z_zfsvfs
operator|->
name|z_parent
operator|=
name|zfsvfs
expr_stmt|;
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_vfsp
operator|=
name|zfsvfs
operator|->
name|z_vfs
expr_stmt|;
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_flag
operator|&=
operator|~
name|VROOT
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
comment|/* 	 * If we had an error, drop our hold on the vnode and 	 * zfsctl_snapshot_inactive() will clean up. 	 */
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
block|{
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_shares_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|pathname_t
modifier|*
name|pnp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
name|rdir
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfs_lookup_dot
argument_list|(
name|vpp
argument_list|,
name|dvp
argument_list|,
name|zfsvfs
operator|->
name|z_ctldir
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|zfsvfs
operator|->
name|z_shares_dir
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_shares_dir
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_LOOKUP
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|nm
argument_list|,
name|vpp
argument_list|,
name|pnp
argument_list|,
name|flags
argument_list|,
name|rdir
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|,
name|direntflags
argument_list|,
name|realpnp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_snapdir_readdir_cb
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|void
modifier|*
name|dp
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|offset_t
modifier|*
name|offp
parameter_list|,
name|offset_t
modifier|*
name|nextp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|char
name|snapname
index|[
name|ZFS_MAX_DATASET_NAME_LEN
index|]
decl_stmt|;
name|uint64_t
name|id
decl_stmt|,
name|cookie
decl_stmt|;
name|boolean_t
name|case_conflict
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|cookie
operator|=
operator|*
name|offp
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|error
operator|=
name|dmu_snapshot_list_next
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|,
sizeof|sizeof
argument_list|(
name|snapname
argument_list|)
argument_list|,
name|snapname
argument_list|,
operator|&
name|id
argument_list|,
operator|&
name|cookie
argument_list|,
operator|&
name|case_conflict
argument_list|)
expr_stmt|;
name|dsl_pool_config_exit
argument_list|(
name|dmu_objset_pool
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
block|{
name|edirent_t
modifier|*
name|eodp
init|=
name|dp
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|eodp
operator|->
name|ed_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|eodp
operator|->
name|ed_ino
operator|=
name|ZFSCTL_INO_SNAP
argument_list|(
name|id
argument_list|)
expr_stmt|;
name|eodp
operator|->
name|ed_eflags
operator|=
name|case_conflict
condition|?
name|ED_CASE_CONFLICT
else|:
literal|0
expr_stmt|;
block|}
else|else
block|{
name|struct
name|dirent64
modifier|*
name|odp
init|=
name|dp
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|odp
operator|->
name|d_name
argument_list|,
name|snapname
argument_list|)
expr_stmt|;
name|odp
operator|->
name|d_ino
operator|=
name|ZFSCTL_INO_SNAP
argument_list|(
name|id
argument_list|)
expr_stmt|;
block|}
operator|*
name|nextp
operator|=
name|cookie
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_shares_readdir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_shares_dir
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_shares_dir
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_READDIR
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|uiop
argument_list|,
name|cr
argument_list|,
name|eofp
argument_list|,
name|ct
argument_list|,
name|flags
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * pvp is the '.zfs' directory (zfsctl_node_t).  *  * Creates vp, which is '.zfs/snapshot' (zfsctl_snapdir_t).  *  * This function is the callback to create a GFS vnode for '.zfs/snapshot'  * when a lookup is performed on .zfs for "snapshot".  */
end_comment

begin_function
name|vnode_t
modifier|*
name|zfsctl_mknode_snapdir
parameter_list|(
name|vnode_t
modifier|*
name|pvp
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|zfsctl_snapdir_t
modifier|*
name|sdp
decl_stmt|;
name|vp
operator|=
name|gfs_dir_create
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsctl_snapdir_t
argument_list|)
argument_list|,
name|pvp
argument_list|,
name|zfsctl_ops_snapdir
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAXNAMELEN
argument_list|,
name|zfsctl_snapdir_readdir_cb
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sdp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
name|sdp
operator|->
name|sd_node
operator|.
name|zc_id
operator|=
name|ZFSCTL_INO_SNAPDIR
expr_stmt|;
name|sdp
operator|->
name|sd_node
operator|.
name|zc_cmtime
operator|=
operator|(
operator|(
name|zfsctl_node_t
operator|*
operator|)
name|pvp
operator|->
name|v_data
operator|)
operator|->
name|zc_cmtime
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|snapentry_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_snapentry_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|zfs_snapentry_t
argument_list|,
name|se_node
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_function
name|vnode_t
modifier|*
name|zfsctl_mknode_shares
parameter_list|(
name|vnode_t
modifier|*
name|pvp
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|zfsctl_node_t
modifier|*
name|sdp
decl_stmt|;
name|vp
operator|=
name|gfs_dir_create
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsctl_node_t
argument_list|)
argument_list|,
name|pvp
argument_list|,
name|zfsctl_ops_shares
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAXNAMELEN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|sdp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
name|sdp
operator|->
name|zc_cmtime
operator|=
operator|(
operator|(
name|zfsctl_node_t
operator|*
operator|)
name|pvp
operator|->
name|v_data
operator|)
operator|->
name|zc_cmtime
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_shares_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|znode_t
modifier|*
name|dzp
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
if|if
condition|(
name|zfsvfs
operator|->
name|z_shares_dir
operator|==
literal|0
condition|)
block|{
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOTSUP
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|error
operator|=
name|zfs_zget
argument_list|(
name|zfsvfs
argument_list|,
name|zfsvfs
operator|->
name|z_shares_dir
argument_list|,
operator|&
name|dzp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|,
name|vap
argument_list|,
name|flags
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|ZTOV
argument_list|(
name|dzp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|zfsctl_snapdir_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_data
decl_stmt|;
name|zfsctl_snapdir_t
modifier|*
name|sdp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|ZFS_ENTER
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
name|zfsctl_common_getattr
argument_list|(
name|vp
argument_list|,
name|vap
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_nodeid
operator|=
name|gfs_file_inode
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vap
operator|->
name|va_nlink
operator|=
name|vap
operator|->
name|va_size
operator|=
name|avl_numnodes
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|)
operator|+
literal|2
expr_stmt|;
name|vap
operator|->
name|va_ctime
operator|=
name|vap
operator|->
name|va_mtime
operator|=
name|dmu_objset_snap_cmtime
argument_list|(
name|zfsvfs
operator|->
name|z_os
argument_list|)
expr_stmt|;
name|ZFS_EXIT
argument_list|(
name|zfsvfs
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|zfsctl_snapdir_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|zfsctl_snapdir_t
modifier|*
name|sdp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|void
modifier|*
name|private
decl_stmt|;
name|private
operator|=
name|gfs_dir_inactive
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|private
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|private
argument_list|,
sizeof|sizeof
argument_list|(
name|zfsctl_snapdir_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_snapdir
index|[]
init|=
block|{
block|{
name|VOPNAME_OPEN
block|,
block|{
operator|.
name|vop_open
operator|=
name|zfsctl_common_open
block|}
block|}
block|,
block|{
name|VOPNAME_CLOSE
block|,
block|{
operator|.
name|vop_close
operator|=
name|zfsctl_common_close
block|}
block|}
block|,
block|{
name|VOPNAME_IOCTL
block|,
block|{
operator|.
name|error
operator|=
name|fs_inval
block|}
block|}
block|,
block|{
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfsctl_snapdir_getattr
block|}
block|}
block|,
block|{
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfsctl_common_access
block|}
block|}
block|,
block|{
name|VOPNAME_RENAME
block|,
block|{
operator|.
name|vop_rename
operator|=
name|zfsctl_snapdir_rename
block|}
block|}
block|,
block|{
name|VOPNAME_RMDIR
block|,
block|{
operator|.
name|vop_rmdir
operator|=
name|zfsctl_snapdir_remove
block|}
block|}
block|,
block|{
name|VOPNAME_MKDIR
block|,
block|{
operator|.
name|vop_mkdir
operator|=
name|zfsctl_snapdir_mkdir
block|}
block|}
block|,
block|{
name|VOPNAME_READDIR
block|,
block|{
operator|.
name|vop_readdir
operator|=
name|gfs_vop_readdir
block|}
block|}
block|,
block|{
name|VOPNAME_LOOKUP
block|,
block|{
operator|.
name|vop_lookup
operator|=
name|zfsctl_snapdir_lookup
block|}
block|}
block|,
block|{
name|VOPNAME_SEEK
block|,
block|{
operator|.
name|vop_seek
operator|=
name|fs_seek
block|}
block|}
block|,
block|{
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfsctl_snapdir_inactive
block|}
block|}
block|,
block|{
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfsctl_common_fid
block|}
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_shares
index|[]
init|=
block|{
block|{
name|VOPNAME_OPEN
block|,
block|{
operator|.
name|vop_open
operator|=
name|zfsctl_common_open
block|}
block|}
block|,
block|{
name|VOPNAME_CLOSE
block|,
block|{
operator|.
name|vop_close
operator|=
name|zfsctl_common_close
block|}
block|}
block|,
block|{
name|VOPNAME_IOCTL
block|,
block|{
operator|.
name|error
operator|=
name|fs_inval
block|}
block|}
block|,
block|{
name|VOPNAME_GETATTR
block|,
block|{
operator|.
name|vop_getattr
operator|=
name|zfsctl_shares_getattr
block|}
block|}
block|,
block|{
name|VOPNAME_ACCESS
block|,
block|{
operator|.
name|vop_access
operator|=
name|zfsctl_common_access
block|}
block|}
block|,
block|{
name|VOPNAME_READDIR
block|,
block|{
operator|.
name|vop_readdir
operator|=
name|zfsctl_shares_readdir
block|}
block|}
block|,
block|{
name|VOPNAME_LOOKUP
block|,
block|{
operator|.
name|vop_lookup
operator|=
name|zfsctl_shares_lookup
block|}
block|}
block|,
block|{
name|VOPNAME_SEEK
block|,
block|{
operator|.
name|vop_seek
operator|=
name|fs_seek
block|}
block|}
block|,
block|{
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|gfs_vop_inactive
block|}
block|}
block|,
block|{
name|VOPNAME_FID
block|,
block|{
operator|.
name|vop_fid
operator|=
name|zfsctl_shares_fid
block|}
block|}
block|,
block|{
name|NULL
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * pvp is the GFS vnode '.zfs/snapshot'.  *  * This creates a GFS node under '.zfs/snapshot' representing each  * snapshot.  This newly created GFS node is what we mount snapshot  * vfs_t's ontop of.  */
end_comment

begin_function
specifier|static
name|vnode_t
modifier|*
name|zfsctl_snapshot_mknode
parameter_list|(
name|vnode_t
modifier|*
name|pvp
parameter_list|,
name|uint64_t
name|objset
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|zfsctl_node_t
modifier|*
name|zcp
decl_stmt|;
name|vp
operator|=
name|gfs_dir_create
argument_list|(
sizeof|sizeof
argument_list|(
name|zfsctl_node_t
argument_list|)
argument_list|,
name|pvp
argument_list|,
name|zfsctl_ops_snapshot
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MAXNAMELEN
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zcp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
name|zcp
operator|->
name|zc_id
operator|=
name|objset
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|zfsctl_snapshot_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|zfsctl_snapdir_t
modifier|*
name|sdp
decl_stmt|;
name|zfs_snapentry_t
modifier|*
name|sep
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|vnode_t
modifier|*
name|dvp
decl_stmt|;
name|VERIFY
argument_list|(
name|gfs_dir_lookup
argument_list|(
name|vp
argument_list|,
literal|".."
argument_list|,
operator|&
name|dvp
argument_list|,
name|cr
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|sdp
operator|=
name|dvp
operator|->
name|v_data
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_count
operator|>
literal|1
condition|)
block|{
name|vp
operator|->
name|v_count
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vn_ismntpt
argument_list|(
name|vp
argument_list|)
argument_list|)
expr_stmt|;
name|sep
operator|=
name|avl_first
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|)
expr_stmt|;
while|while
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
if|if
condition|(
name|sep
operator|->
name|se_root
operator|==
name|vp
condition|)
block|{
name|avl_remove
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sep
operator|->
name|se_name
argument_list|,
name|strlen
argument_list|(
name|sep
operator|->
name|se_name
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sep
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_snapentry_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|sep
operator|=
name|next
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|sep
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * Dispose of the vnode for the snapshot mount point. 	 * This is safe to do because once this entry has been removed 	 * from the AVL tree, it can't be found again, so cannot become 	 * "active".  If we lookup the same name again we will end up 	 * creating a new vnode. 	 */
name|gfs_vop_inactive
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * These VP's should never see the light of day.  They should always  * be covered.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_def_t
name|zfsctl_tops_snapshot
index|[]
init|=
block|{
name|VOPNAME_INACTIVE
block|,
block|{
operator|.
name|vop_inactive
operator|=
name|zfsctl_snapshot_inactive
block|}
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|zfsctl_lookup_objset
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|uint64_t
name|objsetid
parameter_list|,
name|zfsvfs_t
modifier|*
modifier|*
name|zfsvfsp
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|vnode_t
modifier|*
name|dvp
decl_stmt|,
modifier|*
name|vp
decl_stmt|;
name|zfsctl_snapdir_t
modifier|*
name|sdp
decl_stmt|;
name|zfsctl_node_t
modifier|*
name|zcp
decl_stmt|;
name|zfs_snapentry_t
modifier|*
name|sep
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfsctl_root_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
argument_list|,
literal|"snapshot"
argument_list|,
operator|&
name|dvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|kcred
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sdp
operator|=
name|dvp
operator|->
name|v_data
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|sep
operator|=
name|avl_first
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|)
expr_stmt|;
while|while
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
name|vp
operator|=
name|sep
operator|->
name|se_root
expr_stmt|;
name|zcp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
if|if
condition|(
name|zcp
operator|->
name|zc_id
operator|==
name|objsetid
condition|)
break|break;
name|sep
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 		 * Return the mounted root rather than the covered mount point. 		 * Takes the GFS vnode at .zfs/snapshot/<snapshot objsetid> 		 * and returns the ZFS vnode mounted on top of the GFS node. 		 * This ZFS vnode is the root of the vfs for objset 'objsetid'. 		 */
name|error
operator|=
name|traverse
argument_list|(
operator|&
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|==
name|sep
operator|->
name|se_root
condition|)
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
else|else
operator|*
name|zfsvfsp
operator|=
name|VTOZ
argument_list|(
name|vp
argument_list|)
operator|->
name|z_zfsvfs
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
operator|=
name|SET_ERROR
argument_list|(
name|EINVAL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
block|}
name|VN_RELE
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Unmount any snapshots for the given filesystem.  This is called from  * zfs_umount() - if we have a ctldir, then go through and unmount all the  * snapshots.  */
end_comment

begin_function
name|int
name|zfsctl_umount_snapshots
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|int
name|fflags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|)
block|{
name|zfsvfs_t
modifier|*
name|zfsvfs
init|=
name|vfsp
operator|->
name|vfs_data
decl_stmt|;
name|vnode_t
modifier|*
name|dvp
decl_stmt|;
name|zfsctl_snapdir_t
modifier|*
name|sdp
decl_stmt|;
name|zfs_snapentry_t
modifier|*
name|sep
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfsctl_root_lookup
argument_list|(
name|zfsvfs
operator|->
name|z_ctldir
argument_list|,
literal|"snapshot"
argument_list|,
operator|&
name|dvp
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|sdp
operator|=
name|dvp
operator|->
name|v_data
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|sep
operator|=
name|avl_first
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|)
expr_stmt|;
while|while
condition|(
name|sep
operator|!=
name|NULL
condition|)
block|{
name|next
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
comment|/* 		 * If this snapshot is not mounted, then it must 		 * have just been unmounted by somebody else, and 		 * will be cleaned up by zfsctl_snapdir_inactive(). 		 */
if|if
condition|(
name|vn_ismntpt
argument_list|(
name|sep
operator|->
name|se_root
argument_list|)
condition|)
block|{
name|avl_remove
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
name|error
operator|=
name|zfsctl_unmount_snap
argument_list|(
name|sep
argument_list|,
name|fflags
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|avl_add
argument_list|(
operator|&
name|sdp
operator|->
name|sd_snaps
argument_list|,
name|sep
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|sep
operator|=
name|next
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|sdp
operator|->
name|sd_lock
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

