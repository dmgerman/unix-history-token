begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2011, 2017 by Delphix. All rights reserved.  * Copyright (c) 2013 Steven Hartland. All rights reserved.  * Copyright (c) 2014 Spectra Logic Corporation, All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  * Copyright 2016 Nexenta Systems, Inc.  All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deadlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/bptree.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfeature.h>
end_include

begin_include
include|#
directive|include
file|<sys/zil_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_userhold.h>
end_include

begin_comment
comment|/*  * ZFS Write Throttle  * ------------------  *  * ZFS must limit the rate of incoming writes to the rate at which it is able  * to sync data modifications to the backend storage. Throttling by too much  * creates an artificial limit; throttling by too little can only be sustained  * for short periods and would lead to highly lumpy performance. On a per-pool  * basis, ZFS tracks the amount of modified (dirty) data. As operations change  * data, the amount of dirty data increases; as ZFS syncs out data, the amount  * of dirty data decreases. When the amount of dirty data exceeds a  * predetermined threshold further modifications are blocked until the amount  * of dirty data decreases (as data is synced out).  *  * The limit on dirty data is tunable, and should be adjusted according to  * both the IO capacity and available memory of the system. The larger the  * window, the more ZFS is able to aggregate and amortize metadata (and data)  * changes. However, memory is a limited resource, and allowing for more dirty  * data comes at the cost of keeping other useful data in memory (for example  * ZFS data cached by the ARC).  *  * Implementation  *  * As buffers are modified dsl_pool_willuse_space() increments both the per-  * txg (dp_dirty_pertxg[]) and poolwide (dp_dirty_total) accounting of  * dirty space used; dsl_pool_dirty_space() decrements those values as data  * is synced out from dsl_pool_sync(). While only the poolwide value is  * relevant, the per-txg value is useful for debugging. The tunable  * zfs_dirty_data_max determines the dirty space limit. Once that value is  * exceeded, new writes are halted until space frees up.  *  * The zfs_dirty_data_sync tunable dictates the threshold at which we  * ensure that there is a txg syncing (see the comment in txg.c for a full  * description of transaction group stages).  *  * The IO scheduler uses both the dirty space limit and current amount of  * dirty data as inputs. Those values affect the number of concurrent IOs ZFS  * issues. See the comment in vdev_queue.c for details of the IO scheduler.  *  * The delay is also calculated based on the amount of dirty data.  See the  * comment above dmu_tx_delay() for details.  */
end_comment

begin_comment
comment|/*  * zfs_dirty_data_max will be set to zfs_dirty_data_max_percent% of all memory,  * capped at zfs_dirty_data_max_max.  It can also be overridden in /etc/system.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_dirty_data_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zfs_dirty_data_max_max
init|=
literal|4ULL
operator|*
literal|1024
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_dirty_data_max_percent
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * If there is at least this much dirty data, push out a txg.  */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_dirty_data_sync
init|=
literal|64
operator|*
literal|1024
operator|*
literal|1024
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Once there is this amount of dirty data, the dmu_tx_delay() will kick in  * and delay each transaction.  * This value should be>= zfs_vdev_async_write_active_max_dirty_percent.  */
end_comment

begin_decl_stmt
name|int
name|zfs_delay_min_dirty_percent
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This controls how quickly the delay approaches infinity.  * Larger values cause it to delay more for a given amount of dirty data.  * Therefore larger values will cause there to be less dirty data for a  * given throughput.  *  * For the smoothest delay, this value should be about 1 billion divided  * by the maximum number of operations per second.  This will smoothly  * handle between 10x and 1/10th this number.  *  * Note: zfs_delay_scale * zfs_dirty_data_max must be< 2^64, due to the  * multiply in dmu_tx_delay().  */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_delay_scale
init|=
literal|1000
operator|*
literal|1000
operator|*
literal|1000
operator|/
literal|2000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * This determines the number of threads used by the dp_sync_taskq.  */
end_comment

begin_decl_stmt
name|int
name|zfs_sync_taskq_batch_pct
init|=
literal|75
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hrtime_t
name|zfs_throttle_delay
init|=
name|MSEC2NSEC
argument_list|(
literal|10
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|hrtime_t
name|zfs_throttle_resolution
init|=
name|MSEC2NSEC
argument_list|(
literal|10
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dsl_pool_open_special_dir
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dsl_dir_t
modifier|*
modifier|*
name|ddp
parameter_list|)
block|{
name|uint64_t
name|obj
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|)
operator|->
name|dd_child_dir_zapobj
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|name
argument_list|,
name|dp
argument_list|,
name|ddp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dsl_pool_t
modifier|*
name|dsl_pool_open_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|spa_get_rootblkptr
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|dp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_pool_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|=
name|spa
expr_stmt|;
name|dp
operator|->
name|dp_meta_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
name|rrw_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|txg_init
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|offsetof
argument_list|(
name|dsl_dataset_t
argument_list|,
name|ds_dirty_link
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|offsetof
argument_list|(
name|zilog_t
argument_list|,
name|zl_dirty_link
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|offsetof
argument_list|(
name|dsl_dir_t
argument_list|,
name|dd_dirty_link
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|offsetof
argument_list|(
name|dsl_sync_task_t
argument_list|,
name|dst_node
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_sync_taskq
operator|=
name|taskq_create
argument_list|(
literal|"dp_sync_taskq"
argument_list|,
name|zfs_sync_taskq_batch_pct
argument_list|,
name|minclsyspri
argument_list|,
literal|1
argument_list|,
name|INT_MAX
argument_list|,
name|TASKQ_THREADS_CPU_PCT
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_spaceavail_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_vnrele_taskq
operator|=
name|taskq_create
argument_list|(
literal|"zfs_vn_rele_taskq"
argument_list|,
literal|1
argument_list|,
name|minclsyspri
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_pool_init
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|dsl_pool_t
modifier|*
modifier|*
name|dpp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dsl_pool_open_impl
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|err
operator|=
name|dmu_objset_open_impl
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_objset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
name|dsl_pool_close
argument_list|(
name|dp
argument_list|)
expr_stmt|;
else|else
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_pool_open
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ROOT_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|MOS_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_mos_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_ORIGIN
condition|)
block|{
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dir_phys
argument_list|(
name|dd
argument_list|)
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_origin_snap
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|dsl_dir_rele
argument_list|(
name|dd
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_DEADLISTS
condition|)
block|{
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|FREE_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FREE_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|VERIFY0
argument_list|(
name|bpobj_open
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Note: errors ignored, because the leak dir will not exist if we 	 * have not encountered a leak yet. 	 */
operator|(
name|void
operator|)
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|LEAK_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_leak_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_feature_is_active
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_FEATURE_ASYNC_DESTROY
argument_list|)
condition|)
block|{
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_BPTREE_OBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_bptree_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|spa_feature_is_active
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|SPA_FEATURE_EMPTY_BPOBJ
argument_list|)
condition|)
block|{
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_EMPTY_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_empty_bpobj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_TMP_USERREFS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_tmp_userrefs_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_scan_init
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_tx
operator|.
name|tx_open_txg
argument_list|)
expr_stmt|;
name|out
label|:
name|rrw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_close
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
comment|/* 	 * Drop our references from dsl_pool_open(). 	 * 	 * Since we held the origin_snap from "syncing" context (which 	 * includes pool-opening context), it actually only got a "ref" 	 * and not a hold, so just drop that here. 	 */
if|if
condition|(
name|dp
operator|->
name|dp_origin_snap
condition|)
name|dsl_dataset_rele
argument_list|(
name|dp
operator|->
name|dp_origin_snap
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_mos_dir
condition|)
name|dsl_dir_rele
argument_list|(
name|dp
operator|->
name|dp_mos_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_free_dir
condition|)
name|dsl_dir_rele
argument_list|(
name|dp
operator|->
name|dp_free_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_leak_dir
condition|)
name|dsl_dir_rele
argument_list|(
name|dp
operator|->
name|dp_leak_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_root_dir
condition|)
name|dsl_dir_rele
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|bpobj_close
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|)
expr_stmt|;
comment|/* undo the dmu_objset_open_impl(mos) from dsl_pool_open() */
if|if
condition|(
name|dp
operator|->
name|dp_meta_objset
condition|)
name|dmu_objset_evict
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|dp
operator|->
name|dp_sync_taskq
argument_list|)
expr_stmt|;
comment|/* 	 * We can't set retry to TRUE since we're explicitly specifying 	 * a spa to flush. This is good enough; any missed buffers for 	 * this spa won't cause trouble, and they'll eventually fall 	 * out of the ARC just like any other unused buffer. 	 */
name|arc_flush
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|txg_fini
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dsl_scan_fini
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dmu_buf_user_evict_wait
argument_list|()
expr_stmt|;
name|rrw_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|dp
operator|->
name|dp_vnrele_taskq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_blkstats
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|dp_blkstats
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_all_blkstats_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_pool_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dsl_pool_t
modifier|*
name|dsl_pool_create
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|zplprops
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dsl_pool_open_impl
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* create and open the MOS (meta-objset) */
name|dp
operator|->
name|dp_meta_objset
operator|=
name|dmu_objset_create_impl
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
name|DMU_OST_META
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the pool directory */
name|err
operator|=
name|zap_create_claim
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_OT_OBJECT_DIRECTORY
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|err
argument_list|)
expr_stmt|;
comment|/* Initialize scan structures */
name|VERIFY0
argument_list|(
name|dsl_scan_init
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and open the root dir */
name|dp
operator|->
name|dp_root_dir_obj
operator|=
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dir_hold_obj
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and open the meta-objset dir */
operator|(
name|void
operator|)
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|MOS_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|MOS_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_mos_dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_DEADLISTS
condition|)
block|{
comment|/* create and open the free dir */
operator|(
name|void
operator|)
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|FREE_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|FREE_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and open the free_bplist */
name|obj
operator|=
name|bpobj_alloc
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FREE_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|bpobj_open
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_DSL_SCRUB
condition|)
name|dsl_pool_create_origin
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the root dataset */
name|obj
operator|=
name|dsl_dataset_create_sync_dd
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the root objset */
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|os
operator|=
name|dmu_objset_create_impl
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
argument_list|,
name|dsl_dataset_get_blkptr
argument_list|(
name|ds
argument_list|)
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_create_fs
argument_list|(
name|os
argument_list|,
name|kcred
argument_list|,
name|zplprops
argument_list|,
name|tx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Account for the meta-objset space in its placeholder dsl_dir.  */
end_comment

begin_function
name|void
name|dsl_pool_mos_diduse_space
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|used
parameter_list|,
name|int64_t
name|comp
parameter_list|,
name|int64_t
name|uncomp
parameter_list|)
block|{
name|ASSERT3U
argument_list|(
name|comp
argument_list|,
operator|==
argument_list|,
name|uncomp
argument_list|)
expr_stmt|;
comment|/* it's all metadata */
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_mos_used_delta
operator|+=
name|used
expr_stmt|;
name|dp
operator|->
name|dp_mos_compressed_delta
operator|+=
name|comp
expr_stmt|;
name|dp
operator|->
name|dp_mos_uncompressed_delta
operator|+=
name|uncomp
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_pool_sync_mos
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
init|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
decl_stmt|;
name|dmu_objset_sync
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
name|dprintf_bp
argument_list|(
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
literal|"meta objset rootbp is %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|spa_set_rootblkptr
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|dsl_pool_dirty_delta
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|delta
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|<
literal|0
condition|)
name|ASSERT3U
argument_list|(
operator|-
name|delta
argument_list|,
operator|<=
argument_list|,
name|dp
operator|->
name|dp_dirty_total
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_dirty_total
operator|+=
name|delta
expr_stmt|;
comment|/* 	 * Note: we signal even when increasing dp_dirty_total. 	 * This ensures forward progress -- each thread wakes the next waiter. 	 */
if|if
condition|(
name|dp
operator|->
name|dp_dirty_total
operator|<=
name|zfs_dirty_data_max
condition|)
name|cv_signal
argument_list|(
operator|&
name|dp
operator|->
name|dp_spaceavail_cv
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_sync
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|list_t
name|synced_datasets
decl_stmt|;
name|list_create
argument_list|(
operator|&
name|synced_datasets
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dsl_dataset_t
argument_list|,
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Write out all dirty blocks of dirty datasets. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ds
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * We must not sync any non-MOS datasets twice, because 		 * we may have taken a snapshot of them.  However, we 		 * may sync newly-created datasets on pass 2. 		 */
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|synced_datasets
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_sync
argument_list|(
name|ds
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We have written all of the accounted dirty data, so our 	 * dp_space_towrite should now be zero.  However, some seldom-used 	 * code paths do not adhere to this (e.g. dbuf_undirty(), also 	 * rounding error in dbuf_write_physdone). 	 * Shore up the accounting of any dirtied space now. 	 */
name|dsl_pool_undirty_space
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_dirty_pertxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|txg
argument_list|)
expr_stmt|;
comment|/* 	 * Update the long range free counter after 	 * we're done syncing user data 	 */
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|spa_sync_pass
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|==
literal|1
operator|||
name|dp
operator|->
name|dp_long_free_dirty_pertxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_long_free_dirty_pertxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
comment|/* 	 * After the data blocks have been written (ensured by the zio_wait() 	 * above), update the user/group space accounting.  This happens 	 * in tasks dispatched to dp_sync_taskq, so wait for them before 	 * continuing. 	 */
for|for
control|(
name|ds
operator|=
name|list_head
argument_list|(
operator|&
name|synced_datasets
argument_list|)
init|;
name|ds
operator|!=
name|NULL
condition|;
name|ds
operator|=
name|list_next
argument_list|(
operator|&
name|synced_datasets
argument_list|,
name|ds
argument_list|)
control|)
block|{
name|dmu_objset_do_userquota_updates
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|taskq_wait
argument_list|(
name|dp
operator|->
name|dp_sync_taskq
argument_list|)
expr_stmt|;
comment|/* 	 * Sync the datasets again to push out the changes due to 	 * userspace updates.  This must be done before we process the 	 * sync tasks, so that any snapshots will have the correct 	 * user accounting information (and we won't get confused 	 * about which blocks are part of the snapshot). 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|ds
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_sync
argument_list|(
name|ds
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zio_wait
argument_list|(
name|zio
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Now that the datasets have been completely synced, we can 	 * clean up our in-memory structures accumulated while syncing: 	 * 	 *  - move dead blocks from the pending deadlist to the on-disk deadlist 	 *  - release hold from dsl_dataset_dirty() 	 */
while|while
condition|(
operator|(
name|ds
operator|=
name|list_remove_head
argument_list|(
operator|&
name|synced_datasets
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dsl_dataset_sync_done
argument_list|(
name|ds
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|dd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|dsl_dir_sync
argument_list|(
name|dd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * The MOS's space is accounted for in the pool/$MOS 	 * (dp_mos_dir).  We can't modify the mos while we're syncing 	 * it, so we remember the deltas and apply them here. 	 */
if|if
condition|(
name|dp
operator|->
name|dp_mos_used_delta
operator|!=
literal|0
operator|||
name|dp
operator|->
name|dp_mos_compressed_delta
operator|!=
literal|0
operator|||
name|dp
operator|->
name|dp_mos_uncompressed_delta
operator|!=
literal|0
condition|)
block|{
name|dsl_dir_diduse_space
argument_list|(
name|dp
operator|->
name|dp_mos_dir
argument_list|,
name|DD_USED_HEAD
argument_list|,
name|dp
operator|->
name|dp_mos_used_delta
argument_list|,
name|dp
operator|->
name|dp_mos_compressed_delta
argument_list|,
name|dp
operator|->
name|dp_mos_uncompressed_delta
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_mos_used_delta
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|dp_mos_compressed_delta
operator|=
literal|0
expr_stmt|;
name|dp
operator|->
name|dp_mos_uncompressed_delta
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|multilist_is_empty
argument_list|(
name|mos
operator|->
name|os_dirty_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
condition|)
block|{
name|dsl_pool_sync_mos
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we modify a dataset in the same txg that we want to destroy it, 	 * its dsl_dir's dd_dbuf will be dirty, and thus have a hold on it. 	 * dsl_dir_destroy_check() will fail if there are unexpected holds. 	 * Therefore, we want to sync the MOS (thus syncing the dd_dbuf 	 * and clearing the hold on it) before we process the sync_tasks. 	 * The MOS data dirtied by the sync_tasks will be synced on the next 	 * pass. 	 */
if|if
condition|(
operator|!
name|txg_list_empty
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|txg
argument_list|)
condition|)
block|{
name|dsl_sync_task_t
modifier|*
name|dst
decl_stmt|;
comment|/* 		 * No more sync tasks should have been added while we 		 * were syncing. 		 */
name|ASSERT3U
argument_list|(
name|spa_sync_pass
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
argument_list|,
operator|==
argument_list|,
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|dst
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|dsl_sync_task_sync
argument_list|(
name|dst
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|dsl_pool_sync__done
argument_list|,
name|dsl_pool_t
operator|*
name|dp
argument_list|,
name|dp
argument_list|,
name|uint64_t
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_sync_done
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|zilog_t
modifier|*
name|zilog
decl_stmt|;
while|while
condition|(
name|zilog
operator|=
name|txg_list_head
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|txg
argument_list|)
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
init|=
name|dmu_objset_ds
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|)
decl_stmt|;
comment|/* 		 * We don't remove the zilog from the dp_dirty_zilogs 		 * list until after we've cleaned it. This ensures that 		 * callers of zilog_is_dirty() receive an accurate 		 * answer when they are racing with the spa sync thread. 		 */
name|zil_clean
argument_list|(
name|zilog
argument_list|,
name|txg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|txg_list_remove_this
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_zilogs
argument_list|,
name|zilog
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dmu_objset_is_dirty
argument_list|(
name|zilog
operator|->
name|zl_os
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|zilog
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|dmu_objset_is_dirty
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TRUE if the current thread is the tx_sync_thread or if we  * are being called from SPA context during pool initialization.  */
end_comment

begin_function
name|int
name|dsl_pool_sync_context
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|curthread
operator|==
name|dp
operator|->
name|dp_tx
operator|.
name|tx_sync_thread
operator|||
name|spa_is_initializing
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|||
name|taskq_member
argument_list|(
name|dp
operator|->
name|dp_sync_taskq
argument_list|,
name|curthread
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_pool_adjustedsize
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|boolean_t
name|netfree
parameter_list|)
block|{
name|uint64_t
name|space
decl_stmt|,
name|resv
decl_stmt|;
comment|/* 	 * If we're trying to assess whether it's OK to do a free, 	 * cut the reservation in half to allow forward progress 	 * (e.g. make it possible to rm(1) files from a full pool). 	 */
name|space
operator|=
name|spa_get_dspace
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
name|resv
operator|=
name|spa_get_slop_space
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
if|if
condition|(
name|netfree
condition|)
name|resv
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|space
operator|-
name|resv
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_pool_need_dirty_delay
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|uint64_t
name|delay_min_bytes
init|=
name|zfs_dirty_data_max
operator|*
name|zfs_delay_min_dirty_percent
operator|/
literal|100
decl_stmt|;
name|boolean_t
name|rv
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_dirty_total
operator|>
name|zfs_dirty_data_sync
condition|)
name|txg_kick
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|rv
operator|=
operator|(
name|dp
operator|->
name|dp_dirty_total
operator|>
name|delay_min_bytes
operator|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_dirty_space
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_dirty_pertxg
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|+=
name|space
expr_stmt|;
name|dsl_pool_dirty_delta
argument_list|(
name|dp
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsl_pool_undirty_space
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|ASSERT3S
argument_list|(
name|space
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|space
operator|==
literal|0
condition|)
return|return;
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_dirty_pertxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|<
name|space
condition|)
block|{
comment|/* XXX writing something we didn't dirty? */
name|space
operator|=
name|dp
operator|->
name|dp_dirty_pertxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
name|dp
operator|->
name|dp_dirty_pertxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
operator|>=
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_dirty_pertxg
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|-=
name|space
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dp
operator|->
name|dp_dirty_total
argument_list|,
operator|>=
argument_list|,
name|space
argument_list|)
expr_stmt|;
name|dsl_pool_dirty_delta
argument_list|(
name|dp
argument_list|,
operator|-
name|space
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|upgrade_clones_cb
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|hds
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|hds
operator|->
name|ds_object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
while|while
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|prev
argument_list|)
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
condition|)
break|break;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ds
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|prev
operator|=
name|dp
operator|->
name|dp_origin_snap
expr_stmt|;
comment|/* 		 * The $ORIGIN can't have any data, or the accounting 		 * will be wrong. 		 */
name|rrw_enter
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|prev
argument_list|)
operator|->
name|ds_bp
operator|.
name|blk_birth
argument_list|)
expr_stmt|;
name|rrw_exit
argument_list|(
operator|&
name|ds
operator|->
name|ds_bp_rwlock
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
comment|/* The origin doesn't get attached to itself */
if|if
condition|(
name|ds
operator|->
name|ds_object
operator|==
name|prev
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
operator|=
name|prev
operator|->
name|ds_object
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_txg
operator|=
name|dsl_dataset_phys
argument_list|(
name|prev
argument_list|)
operator|->
name|ds_creation_txg
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_origin_obj
operator|=
name|prev
operator|->
name|ds_object
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|prev
argument_list|)
operator|->
name|ds_num_children
operator|++
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT3U
argument_list|(
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_origin_obj
argument_list|,
operator|==
argument_list|,
name|prev
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
operator|==
argument_list|,
name|prev
operator|->
name|ds_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dataset_phys
argument_list|(
name|prev
argument_list|)
operator|->
name|ds_next_clones_obj
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dataset_phys
argument_list|(
name|prev
argument_list|)
operator|->
name|ds_next_clones_obj
operator|=
name|zap_create
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_OT_NEXT_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|prev
argument_list|)
operator|->
name|ds_next_clones_obj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|dp
operator|->
name|dp_origin_snap
condition|)
name|dsl_dataset_rele
argument_list|(
name|prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_upgrade_clones
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_origin_snap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_objset_find_dp
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|upgrade_clones_cb
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
operator||
name|DS_FIND_SERIALIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|upgrade_dir_clones_cb
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dsl_dataset_t
modifier|*
name|ds
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|arg
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
if|if
condition|(
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_origin_obj
operator|!=
literal|0
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|origin
decl_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dir_phys
argument_list|(
name|ds
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dsl_dir_phys
argument_list|(
name|origin
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_clones
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|dsl_dir_phys
argument_list|(
name|origin
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_clones
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY0
argument_list|(
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dsl_dir_phys
argument_list|(
name|origin
operator|->
name|ds_dir
argument_list|)
operator|->
name|dd_clones
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_upgrade_dir_clones
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|uint64_t
name|obj
decl_stmt|;
operator|(
name|void
operator|)
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|FREE_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|FREE_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We can't use bpobj_alloc(), because spa_version() still 	 * returns the old version, and we need a new-version bpobj with 	 * subobj support.  So call dmu_object_alloc() directly. 	 */
name|obj
operator|=
name|dmu_object_alloc
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_OT_BPOBJ
argument_list|,
name|SPA_OLD_MAXBLOCKSIZE
argument_list|,
name|DMU_OT_BPOBJ_HDR
argument_list|,
sizeof|sizeof
argument_list|(
name|bpobj_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FREE_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|bpobj_open
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dmu_objset_find_dp
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|upgrade_dir_clones_cb
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
operator||
name|DS_FIND_SERIALIZE
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_create_origin
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|dsobj
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_origin_snap
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|rrw_held
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create the origin dir, ds,& snap-ds */
name|dsobj
operator|=
name|dsl_dataset_create_sync
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kcred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_snapshot_sync_impl
argument_list|(
name|ds
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY0
argument_list|(
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsl_dataset_phys
argument_list|(
name|ds
argument_list|)
operator|->
name|ds_prev_snap_obj
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_origin_snap
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|taskq_t
modifier|*
name|dsl_pool_vnrele_taskq
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|dp
operator|->
name|dp_vnrele_taskq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk through the pool-wide zap object of temporary snapshot user holds  * and release them.  */
end_comment

begin_function
name|void
name|dsl_pool_clean_tmp_userrefs
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|zap_attribute_t
name|za
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|dp
operator|->
name|dp_tmp_userrefs_obj
decl_stmt|;
name|nvlist_t
modifier|*
name|holds
decl_stmt|;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
return|return;
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_USERREFS
argument_list|)
expr_stmt|;
name|holds
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|char
modifier|*
name|htag
decl_stmt|;
name|nvlist_t
modifier|*
name|tags
decl_stmt|;
name|htag
operator|=
name|strchr
argument_list|(
name|za
operator|.
name|za_name
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
operator|*
name|htag
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|htag
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_nvlist
argument_list|(
name|holds
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
operator|&
name|tags
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|tags
operator|=
name|fnvlist_alloc
argument_list|()
expr_stmt|;
name|fnvlist_add_boolean
argument_list|(
name|tags
argument_list|,
name|htag
argument_list|)
expr_stmt|;
name|fnvlist_add_nvlist
argument_list|(
name|holds
argument_list|,
name|za
operator|.
name|za_name
argument_list|,
name|tags
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|tags
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fnvlist_add_boolean
argument_list|(
name|tags
argument_list|,
name|htag
argument_list|)
expr_stmt|;
block|}
block|}
name|dsl_dataset_user_release_tmp
argument_list|(
name|dp
argument_list|,
name|holds
argument_list|)
expr_stmt|;
name|fnvlist_free
argument_list|(
name|holds
argument_list|)
expr_stmt|;
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create the pool-wide zap object for storing temporary snapshot holds.  */
end_comment

begin_function
name|void
name|dsl_pool_user_hold_create_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_tmp_userrefs_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_tmp_userrefs_obj
operator|=
name|zap_create_link
argument_list|(
name|mos
argument_list|,
name|DMU_OT_USERREFS
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_TMP_USERREFS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_pool_user_hold_rele_impl
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|uint64_t
name|now
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|holding
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|dp
operator|->
name|dp_tmp_userrefs_obj
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_USERREFS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the pool was created prior to SPA_VERSION_USERREFS, the 	 * zap object for temporary holds might not exist yet. 	 */
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|holding
condition|)
block|{
name|dsl_pool_user_hold_create_obj
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|dp
operator|->
name|dp_tmp_userrefs_obj
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|SET_ERROR
argument_list|(
name|ENOENT
argument_list|)
operator|)
return|;
block|}
block|}
name|name
operator|=
name|kmem_asprintf
argument_list|(
literal|"%llx-%s"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|dsobj
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|holding
condition|)
name|error
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
operator|&
name|now
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a temporary hold for the given dataset object and tag.  */
end_comment

begin_function
name|int
name|dsl_pool_user_hold
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|uint64_t
name|now
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
name|dsl_pool_user_hold_rele_impl
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|now
argument_list|,
name|tx
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a temporary hold for the given dataset object and tag.  */
end_comment

begin_function
name|int
name|dsl_pool_user_release
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
name|dsl_pool_user_hold_rele_impl
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * DSL Pool Configuration Lock  *  * The dp_config_rwlock protects against changes to DSL state (e.g. dataset  * creation / destruction / rename / property setting).  It must be held for  * read to hold a dataset or dsl_dir.  I.e. you must call  * dsl_pool_config_enter() or dsl_pool_hold() before calling  * dsl_{dataset,dir}_hold{_obj}.  In most circumstances, the dp_config_rwlock  * must be held continuously until all datasets and dsl_dirs are released.  *  * The only exception to this rule is that if a "long hold" is placed on  * a dataset, then the dp_config_rwlock may be dropped while the dataset  * is still held.  The long hold will prevent the dataset from being  * destroyed -- the destroy will fail with EBUSY.  A long hold can be  * obtained by calling dsl_dataset_long_hold(), or by "owning" a dataset  * (by calling dsl_{dataset,objset}_{try}own{_obj}).  *  * Legitimate long-holders (including owners) should be long-running, cancelable  * tasks that should cause "zfs destroy" to fail.  This includes DMU  * consumers (i.e. a ZPL filesystem being mounted or ZVOL being open),  * "zfs send", and "zfs diff".  There are several other long-holders whose  * uses are suboptimal (e.g. "zfs promote", and zil_suspend()).  *  * The usual formula for long-holding would be:  * dsl_pool_hold()  * dsl_dataset_hold()  * ... perform checks ...  * dsl_dataset_long_hold()  * dsl_pool_rele()  * ... perform long-running task ...  * dsl_dataset_long_rele()  * dsl_dataset_rele()  *  * Note that when the long hold is released, the dataset is still held but  * the pool is not held.  The dataset may change arbitrarily during this time  * (e.g. it could be destroyed).  Therefore you shouldn't do anything to the  * dataset except release it.  *  * User-initiated operations (e.g. ioctls, zfs_ioc_*()) are either read-only  * or modifying operations.  *  * Modifying operations should generally use dsl_sync_task().  The synctask  * infrastructure enforces proper locking strategy with respect to the  * dp_config_rwlock.  See the comment above dsl_sync_task() for details.  *  * Read-only operations will manually hold the pool, then the dataset, obtain  * information from the dataset, then release the pool and dataset.  * dmu_objset_{hold,rele}() are convenience routines that also do the pool  * hold/rele.  */
end_comment

begin_function
name|int
name|dsl_pool_hold
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|,
name|dsl_pool_t
modifier|*
modifier|*
name|dp
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
decl_stmt|;
name|int
name|error
decl_stmt|;
name|error
operator|=
name|spa_open
argument_list|(
name|name
argument_list|,
operator|&
name|spa
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|*
name|dp
operator|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
expr_stmt|;
name|dsl_pool_config_enter
argument_list|(
operator|*
name|dp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_rele
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|dsl_pool_config_exit
argument_list|(
name|dp
argument_list|,
name|tag
argument_list|)
expr_stmt|;
name|spa_close
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_config_enter
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
comment|/* 	 * We use a "reentrant" reader-writer lock, but not reentrantly. 	 * 	 * The rrwlock can (with the track_all flag) track all reading threads, 	 * which is very useful for debugging which code path failed to release 	 * the lock, and for verifying that the *current* thread does hold 	 * the lock. 	 * 	 * (Unlike a rwlock, which knows that N threads hold it for 	 * read, but not *which* threads, so rw_held(RW_READER) returns TRUE 	 * if any thread holds it for read, even if this thread doesn't). 	 */
name|ASSERT
argument_list|(
operator|!
name|rrw_held
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
name|rrw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_config_enter_prio
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|ASSERT
argument_list|(
operator|!
name|rrw_held
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_READER
argument_list|)
argument_list|)
expr_stmt|;
name|rrw_enter_read_prio
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_config_exit
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|void
modifier|*
name|tag
parameter_list|)
block|{
name|rrw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|tag
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_pool_config_held
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|RRW_LOCK_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|boolean_t
name|dsl_pool_config_held_writer
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|RRW_WRITE_HELD
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

