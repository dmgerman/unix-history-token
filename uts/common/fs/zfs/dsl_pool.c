begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dataset.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_prop.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_dir.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_synctask.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_scan.h>
end_include

begin_include
include|#
directive|include
file|<sys/dnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_objset.h>
end_include

begin_include
include|#
directive|include
file|<sys/arc.h>
end_include

begin_include
include|#
directive|include
file|<sys/zap.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/fs/zfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/zfs_znode.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_deadlist.h>
end_include

begin_decl_stmt
name|int
name|zfs_no_write_throttle
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_write_limit_shift
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1/8th of physical memory */
end_comment

begin_decl_stmt
name|int
name|zfs_txg_synctime_ms
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* target millisecs to sync a txg */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_min
init|=
literal|32
operator|<<
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* min write limit is 32MB */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max data payload per txg */
end_comment

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_inflated
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|zfs_write_limit_override
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmutex_t
name|zfs_write_limit_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|pgcnt_t
name|old_physmem
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|dsl_pool_open_special_dir
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|dsl_dir_t
modifier|*
modifier|*
name|ddp
parameter_list|)
block|{
name|uint64_t
name|obj
decl_stmt|;
name|int
name|err
decl_stmt|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|dp
operator|->
name|dp_root_dir
operator|->
name|dd_phys
operator|->
name|dd_child_dir_zapobj
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|obj
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
return|return
operator|(
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|name
argument_list|,
name|dp
argument_list|,
name|ddp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|dsl_pool_t
modifier|*
name|dsl_pool_open_impl
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_pool_t
modifier|*
name|dp
decl_stmt|;
name|blkptr_t
modifier|*
name|bp
init|=
name|spa_get_rootblkptr
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|dp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dsl_pool_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_spa
operator|=
name|spa
expr_stmt|;
name|dp
operator|->
name|dp_meta_rootbp
operator|=
operator|*
name|bp
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_write_limit
operator|=
name|zfs_write_limit_min
expr_stmt|;
name|txg_init
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|offsetof
argument_list|(
name|dsl_dataset_t
argument_list|,
name|ds_dirty_link
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|offsetof
argument_list|(
name|dsl_dir_t
argument_list|,
name|dd_dirty_link
argument_list|)
argument_list|)
expr_stmt|;
name|txg_list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|offsetof
argument_list|(
name|dsl_sync_task_group_t
argument_list|,
name|dstg_node
argument_list|)
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_dataset_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|dsl_dataset_t
argument_list|,
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_vnrele_taskq
operator|=
name|taskq_create
argument_list|(
literal|"zfs_vn_rele_taskq"
argument_list|,
literal|1
argument_list|,
name|minclsyspri
argument_list|,
literal|1
argument_list|,
literal|4
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_pool_open
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|dsl_pool_t
modifier|*
modifier|*
name|dpp
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dsl_pool_open_impl
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|err
operator|=
name|dmu_objset_open_impl
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_objset
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_ROOT_DATASET
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|MOS_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_mos_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_ORIGIN
condition|)
block|{
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dd
operator|->
name|dd_phys
operator|->
name|dd_head_dataset_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_origin_snap
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|dsl_dir_close
argument_list|(
name|dd
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_DEADLISTS
condition|)
block|{
name|err
operator|=
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|FREE_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FREE_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_open
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|zap_lookup
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_TMP_USERREFS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_tmp_userrefs_obj
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|ENOENT
condition|)
name|err
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|err
condition|)
goto|goto
name|out
goto|;
name|err
operator|=
name|dsl_scan_init
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|out
label|:
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|dsl_pool_close
argument_list|(
name|dp
argument_list|)
expr_stmt|;
else|else
operator|*
name|dpp
operator|=
name|dp
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_close
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
comment|/* drop our references from dsl_pool_open() */
comment|/* 	 * Since we held the origin_snap from "syncing" context (which 	 * includes pool-opening context), it actually only got a "ref" 	 * and not a hold, so just drop that here. 	 */
if|if
condition|(
name|dp
operator|->
name|dp_origin_snap
condition|)
name|dsl_dataset_drop_ref
argument_list|(
name|dp
operator|->
name|dp_origin_snap
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_mos_dir
condition|)
name|dsl_dir_close
argument_list|(
name|dp
operator|->
name|dp_mos_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_free_dir
condition|)
name|dsl_dir_close
argument_list|(
name|dp
operator|->
name|dp_free_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_root_dir
condition|)
name|dsl_dir_close
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|dp
argument_list|)
expr_stmt|;
name|bpobj_close
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|)
expr_stmt|;
comment|/* undo the dmu_objset_open_impl(mos) from dsl_pool_open() */
if|if
condition|(
name|dp
operator|->
name|dp_meta_objset
condition|)
name|dmu_objset_evict
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|)
expr_stmt|;
name|txg_list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|)
expr_stmt|;
name|list_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|)
expr_stmt|;
name|arc_flush
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
name|txg_fini
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|dsl_scan_fini
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|taskq_destroy
argument_list|(
name|dp
operator|->
name|dp_vnrele_taskq
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_blkstats
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|dp_blkstats
argument_list|,
sizeof|sizeof
argument_list|(
name|zfs_all_blkstats_t
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dp
argument_list|,
sizeof|sizeof
argument_list|(
name|dsl_pool_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|dsl_pool_t
modifier|*
name|dsl_pool_create
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|nvlist_t
modifier|*
name|zplprops
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|dsl_pool_open_impl
argument_list|(
name|spa
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
init|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|uint64_t
name|obj
decl_stmt|;
comment|/* create and open the MOS (meta-objset) */
name|dp
operator|->
name|dp_meta_objset
operator|=
name|dmu_objset_create_impl
argument_list|(
name|spa
argument_list|,
name|NULL
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
name|DMU_OST_META
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the pool directory */
name|err
operator|=
name|zap_create_claim
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_OT_OBJECT_DIRECTORY
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|err
argument_list|,
operator|==
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Initialize scan structures */
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_scan_init
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and open the root dir */
name|dp
operator|->
name|dp_root_dir_obj
operator|=
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dir_open_obj
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir_obj
argument_list|,
name|NULL
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_root_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and open the meta-objset dir */
operator|(
name|void
operator|)
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|MOS_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|MOS_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_mos_dir
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_DEADLISTS
condition|)
block|{
comment|/* create and open the free dir */
operator|(
name|void
operator|)
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|FREE_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|FREE_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* create and open the free_bplist */
name|obj
operator|=
name|bpobj_alloc
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FREE_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_open
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|spa_version
argument_list|(
name|spa
argument_list|)
operator|>=
name|SPA_VERSION_DSL_SCRUB
condition|)
name|dsl_pool_create_origin
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the root dataset */
name|obj
operator|=
name|dsl_dataset_create_sync_dd
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* create the root objset */
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|os
operator|=
name|dmu_objset_create_impl
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|ds
argument_list|,
name|dsl_dataset_get_blkptr
argument_list|(
name|ds
argument_list|)
argument_list|,
name|DMU_OST_ZFS
argument_list|,
name|tx
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|_KERNEL
name|zfs_create_fs
argument_list|(
name|os
argument_list|,
name|kcred
argument_list|,
name|zplprops
argument_list|,
name|tx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|deadlist_enqueue_cb
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|dsl_deadlist_t
modifier|*
name|dl
init|=
name|arg
decl_stmt|;
name|dsl_deadlist_insert
argument_list|(
name|dl
argument_list|,
name|bp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_sync
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|dsl_dir_t
modifier|*
name|dd
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_sync_task_group_t
modifier|*
name|dstg
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|hrtime_t
name|start
decl_stmt|,
name|write_time
decl_stmt|;
name|uint64_t
name|data_written
decl_stmt|;
name|int
name|err
decl_stmt|;
comment|/* 	 * We need to copy dp_space_towrite() before doing 	 * dsl_sync_task_group_sync(), because 	 * dsl_dataset_snapshot_reserve_space() will increase 	 * dp_space_towrite but not actually write anything. 	 */
name|data_written
operator|=
name|dp
operator|->
name|dp_space_towrite
index|[
name|txg
operator|&
name|TXG_MASK
index|]
expr_stmt|;
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|dp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_read_overhead
operator|=
literal|0
expr_stmt|;
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
while|while
condition|(
name|ds
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
condition|)
block|{
comment|/* 		 * We must not sync any non-MOS datasets twice, because 		 * we may have taken a snapshot of them.  However, we 		 * may sync newly-created datasets on pass 2. 		 */
name|ASSERT
argument_list|(
operator|!
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|list_insert_tail
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_sync
argument_list|(
name|ds
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|DTRACE_PROBE
argument_list|(
name|pool_sync__1setup
argument_list|)
expr_stmt|;
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|write_time
operator|=
name|gethrtime
argument_list|()
operator|-
name|start
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|DTRACE_PROBE
argument_list|(
name|pool_sync__2rootzio
argument_list|)
expr_stmt|;
for|for
control|(
name|ds
operator|=
name|list_head
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|)
init|;
name|ds
condition|;
name|ds
operator|=
name|list_next
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
name|ds
argument_list|)
control|)
name|dmu_objset_do_userquota_updates
argument_list|(
name|ds
operator|->
name|ds_objset
argument_list|,
name|tx
argument_list|)
expr_stmt|;
comment|/* 	 * Sync the datasets again to push out the changes due to 	 * userspace updates.  This must be done before we process the 	 * sync tasks, because that could cause a snapshot of a dataset 	 * whose ds_bp will be rewritten when we do this 2nd sync. 	 */
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
while|while
condition|(
name|ds
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_datasets
argument_list|,
name|txg
argument_list|)
condition|)
block|{
name|ASSERT
argument_list|(
name|list_link_active
argument_list|(
operator|&
name|ds
operator|->
name|ds_synced_link
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|dsl_dataset_sync
argument_list|(
name|ds
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * Move dead blocks from the pending deadlist to the on-disk 	 * deadlist. 	 */
for|for
control|(
name|ds
operator|=
name|list_head
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|)
init|;
name|ds
condition|;
name|ds
operator|=
name|list_next
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
name|ds
argument_list|)
control|)
block|{
name|bplist_iterate
argument_list|(
operator|&
name|ds
operator|->
name|ds_pending_deadlist
argument_list|,
name|deadlist_enqueue_cb
argument_list|,
operator|&
name|ds
operator|->
name|ds_deadlist
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|dstg
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_sync_tasks
argument_list|,
name|txg
argument_list|)
condition|)
block|{
comment|/* 		 * No more sync tasks should have been added while we 		 * were syncing. 		 */
name|ASSERT
argument_list|(
name|spa_sync_pass
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dsl_sync_task_group_sync
argument_list|(
name|dstg
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|DTRACE_PROBE
argument_list|(
name|pool_sync__3task
argument_list|)
expr_stmt|;
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
while|while
condition|(
name|dd
operator|=
name|txg_list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_dirty_dirs
argument_list|,
name|txg
argument_list|)
condition|)
name|dsl_dir_sync
argument_list|(
name|dd
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|write_time
operator|+=
name|gethrtime
argument_list|()
operator|-
name|start
expr_stmt|;
name|start
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
if|if
condition|(
name|list_head
argument_list|(
operator|&
name|mos
operator|->
name|os_dirty_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
operator|!=
name|NULL
operator|||
name|list_head
argument_list|(
operator|&
name|mos
operator|->
name|os_free_dnodes
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|zio
operator|=
name|zio_root
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ZIO_FLAG_MUSTSUCCEED
argument_list|)
expr_stmt|;
name|dmu_objset_sync
argument_list|(
name|mos
argument_list|,
name|zio
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|err
operator|=
name|zio_wait
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|err
operator|==
literal|0
argument_list|)
expr_stmt|;
name|dprintf_bp
argument_list|(
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|,
literal|"meta objset rootbp is %s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|spa_set_rootblkptr
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
operator|&
name|dp
operator|->
name|dp_meta_rootbp
argument_list|)
expr_stmt|;
block|}
name|write_time
operator|+=
name|gethrtime
argument_list|()
operator|-
name|start
expr_stmt|;
name|DTRACE_PROBE2
argument_list|(
name|pool_sync__4io
argument_list|,
name|hrtime_t
argument_list|,
name|write_time
argument_list|,
name|hrtime_t
argument_list|,
name|dp
operator|->
name|dp_read_overhead
argument_list|)
expr_stmt|;
name|write_time
operator|-=
name|dp
operator|->
name|dp_read_overhead
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_space_towrite
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_tempreserved
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If the write limit max has not been explicitly set, set it 	 * to a fraction of available physical memory (default 1/8th). 	 * Note that we must inflate the limit because the spa 	 * inflates write sizes to account for data replication. 	 * Check this each sync phase to catch changing memory size. 	 */
if|if
condition|(
name|physmem
operator|!=
name|old_physmem
operator|&&
name|zfs_write_limit_shift
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|zfs_write_limit_lock
argument_list|)
expr_stmt|;
name|old_physmem
operator|=
name|physmem
expr_stmt|;
name|zfs_write_limit_max
operator|=
name|ptob
argument_list|(
name|physmem
argument_list|)
operator|>>
name|zfs_write_limit_shift
expr_stmt|;
name|zfs_write_limit_inflated
operator|=
name|MAX
argument_list|(
name|zfs_write_limit_min
argument_list|,
name|spa_get_asize
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|zfs_write_limit_max
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|zfs_write_limit_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Attempt to keep the sync time consistent by adjusting the 	 * amount of write traffic allowed into each transaction group. 	 * Weight the throughput calculation towards the current value: 	 * 	thru = 3/4 old_thru + 1/4 new_thru 	 * 	 * Note: write_time is in nanosecs, so write_time/MICROSEC 	 * yields millisecs 	 */
name|ASSERT
argument_list|(
name|zfs_write_limit_min
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data_written
operator|>
name|zfs_write_limit_min
operator|/
literal|8
operator|&&
name|write_time
operator|>
name|MICROSEC
condition|)
block|{
name|uint64_t
name|throughput
init|=
name|data_written
operator|/
operator|(
name|write_time
operator|/
name|MICROSEC
operator|)
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_throughput
condition|)
name|dp
operator|->
name|dp_throughput
operator|=
name|throughput
operator|/
literal|4
operator|+
literal|3
operator|*
name|dp
operator|->
name|dp_throughput
operator|/
literal|4
expr_stmt|;
else|else
name|dp
operator|->
name|dp_throughput
operator|=
name|throughput
expr_stmt|;
name|dp
operator|->
name|dp_write_limit
operator|=
name|MIN
argument_list|(
name|zfs_write_limit_inflated
argument_list|,
name|MAX
argument_list|(
name|zfs_write_limit_min
argument_list|,
name|dp
operator|->
name|dp_throughput
operator|*
name|zfs_txg_synctime_ms
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|dsl_pool_sync_done
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|objset_t
modifier|*
name|os
decl_stmt|;
while|while
condition|(
name|ds
operator|=
name|list_head
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|)
condition|)
block|{
name|list_remove
argument_list|(
operator|&
name|dp
operator|->
name|dp_synced_datasets
argument_list|,
name|ds
argument_list|)
expr_stmt|;
name|os
operator|=
name|ds
operator|->
name|ds_objset
expr_stmt|;
name|zil_clean
argument_list|(
name|os
operator|->
name|os_zil
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|dmu_objset_is_dirty
argument_list|(
name|os
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|ds
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
name|dmu_objset_is_dirty
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|txg
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * TRUE if the current thread is the tx_sync_thread or if we  * are being called from SPA context during pool initialization.  */
end_comment

begin_function
name|int
name|dsl_pool_sync_context
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|curthread
operator|==
name|dp
operator|->
name|dp_tx
operator|.
name|tx_sync_thread
operator|||
name|spa_get_dsl
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|==
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|dsl_pool_adjustedsize
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|boolean_t
name|netfree
parameter_list|)
block|{
name|uint64_t
name|space
decl_stmt|,
name|resv
decl_stmt|;
comment|/* 	 * Reserve about 1.6% (1/64), or at least 32MB, for allocation 	 * efficiency. 	 * XXX The intent log is not accounted for, so it must fit 	 * within this slop. 	 * 	 * If we're trying to assess whether it's OK to do a free, 	 * cut the reservation in half to allow forward progress 	 * (e.g. make it possible to rm(1) files from a full pool). 	 */
name|space
operator|=
name|spa_get_dspace
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
expr_stmt|;
name|resv
operator|=
name|MAX
argument_list|(
name|space
operator|>>
literal|6
argument_list|,
name|SPA_MINDEVSIZE
operator|>>
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|netfree
condition|)
name|resv
operator|>>=
literal|1
expr_stmt|;
return|return
operator|(
name|space
operator|-
name|resv
operator|)
return|;
block|}
end_function

begin_function
name|int
name|dsl_pool_tempreserve_space
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|reserved
init|=
literal|0
decl_stmt|;
name|uint64_t
name|write_limit
init|=
operator|(
name|zfs_write_limit_override
condition|?
name|zfs_write_limit_override
else|:
name|dp
operator|->
name|dp_write_limit
operator|)
decl_stmt|;
if|if
condition|(
name|zfs_no_write_throttle
condition|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|space
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Check to see if we have exceeded the maximum allowed IO for 	 * this transaction group.  We can do this without locks since 	 * a little slop here is ok.  Note that we do the reserved check 	 * with only half the requested reserve: this is because the 	 * reserve requests are worst-case, and we really don't want to 	 * throttle based off of worst-case estimates. 	 */
if|if
condition|(
name|write_limit
operator|>
literal|0
condition|)
block|{
name|reserved
operator|=
name|dp
operator|->
name|dp_space_towrite
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|+
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|reserved
operator|&&
name|reserved
operator|>
name|write_limit
condition|)
return|return
operator|(
name|ERESTART
operator|)
return|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|space
argument_list|)
expr_stmt|;
comment|/* 	 * If this transaction group is over 7/8ths capacity, delay 	 * the caller 1 clock tick.  This will slow down the "fill" 	 * rate until the sync process can catch up with us. 	 */
if|if
condition|(
name|reserved
operator|&&
name|reserved
operator|>
operator|(
name|write_limit
operator|-
operator|(
name|write_limit
operator|>>
literal|3
operator|)
operator|)
condition|)
name|txg_delay
argument_list|(
name|dp
argument_list|,
name|tx
operator|->
name|tx_txg
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_tempreserve_clear
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|>=
name|space
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|dp
operator|->
name|dp_tempreserved
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
argument_list|,
operator|-
name|space
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_memory_pressure
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|uint64_t
name|space_inuse
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|dp
operator|->
name|dp_write_limit
operator|==
name|zfs_write_limit_min
condition|)
return|return;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TXG_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|space_inuse
operator|+=
name|dp
operator|->
name|dp_space_towrite
index|[
name|i
index|]
expr_stmt|;
name|space_inuse
operator|+=
name|dp
operator|->
name|dp_tempreserved
index|[
name|i
index|]
expr_stmt|;
block|}
name|dp
operator|->
name|dp_write_limit
operator|=
name|MAX
argument_list|(
name|zfs_write_limit_min
argument_list|,
name|MIN
argument_list|(
name|dp
operator|->
name|dp_write_limit
argument_list|,
name|space_inuse
operator|/
literal|4
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_willuse_space
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|int64_t
name|space
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
if|if
condition|(
name|space
operator|>
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_space_towrite
index|[
name|tx
operator|->
name|tx_txg
operator|&
name|TXG_MASK
index|]
operator|+=
name|space
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|upgrade_clones_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|,
modifier|*
name|prev
init|=
name|NULL
decl_stmt|;
name|int
name|err
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
return|return
operator|(
name|err
operator|)
return|;
while|while
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|!=
literal|0
condition|)
block|{
name|err
operator|=
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|prev
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
if|if
condition|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|!=
name|ds
operator|->
name|ds_object
condition|)
break|break;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ds
operator|=
name|prev
expr_stmt|;
name|prev
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|prev
operator|==
name|NULL
condition|)
block|{
name|prev
operator|=
name|dp
operator|->
name|dp_origin_snap
expr_stmt|;
comment|/* 		 * The $ORIGIN can't have any data, or the accounting 		 * will be wrong. 		 */
name|ASSERT
argument_list|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_bp
operator|.
name|blk_birth
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* The origin doesn't get attached to itself */
if|if
condition|(
name|ds
operator|->
name|ds_object
operator|==
name|prev
operator|->
name|ds_object
condition|)
block|{
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|=
name|prev
operator|->
name|ds_object
expr_stmt|;
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_txg
operator|=
name|prev
operator|->
name|ds_phys
operator|->
name|ds_creation_txg
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|=
name|prev
operator|->
name|ds_object
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|prev
operator|->
name|ds_phys
operator|->
name|ds_num_children
operator|++
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_next_snap_obj
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|ds
argument_list|,
operator|&
name|ds
operator|->
name|ds_prev
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
operator|==
name|prev
operator|->
name|ds_object
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
operator|==
name|prev
operator|->
name|ds_object
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|prev
operator|->
name|ds_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
operator|=
name|zap_create
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_OT_NEXT_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY
argument_list|(
literal|0
operator|==
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|prev
operator|->
name|ds_phys
operator|->
name|ds_next_clones_obj
argument_list|,
name|ds
operator|->
name|ds_object
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|dp
operator|->
name|dp_origin_snap
condition|)
name|dsl_dataset_rele
argument_list|(
name|prev
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_upgrade_clones
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_origin_snap
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_objset_find_spa
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|upgrade_clones_cb
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|upgrade_dir_clones_cb
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|dsname
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|dmu_tx_t
modifier|*
name|tx
init|=
name|arg
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|dsl_pool_t
modifier|*
name|dp
init|=
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
condition|)
block|{
name|dsl_dataset_t
modifier|*
name|origin
decl_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_origin_obj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|origin
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|==
literal|0
condition|)
block|{
name|dmu_buf_will_dirty
argument_list|(
name|origin
operator|->
name|ds_dir
operator|->
name|dd_dbuf
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_DSL_CLONES
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add_int
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|origin
operator|->
name|ds_dir
operator|->
name|dd_phys
operator|->
name|dd_clones
argument_list|,
name|dsobj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|origin
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|dsl_pool_upgrade_dir_clones
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|uint64_t
name|obj
decl_stmt|;
operator|(
name|void
operator|)
name|dsl_dir_create_sync
argument_list|(
name|dp
argument_list|,
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|FREE_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_pool_open_special_dir
argument_list|(
name|dp
argument_list|,
name|FREE_DIR_NAME
argument_list|,
operator|&
name|dp
operator|->
name|dp_free_dir
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * We can't use bpobj_alloc(), because spa_version() still 	 * returns the old version, and we need a new-version bpobj with 	 * subobj support.  So call dmu_object_alloc() directly. 	 */
name|obj
operator|=
name|dmu_object_alloc
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_OT_BPOBJ
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|,
name|DMU_OT_BPOBJ_HDR
argument_list|,
sizeof|sizeof
argument_list|(
name|bpobj_phys_t
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|zap_add
argument_list|(
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_FREE_BPOBJ
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|obj
argument_list|,
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|bpobj_open
argument_list|(
operator|&
name|dp
operator|->
name|dp_free_bpobj
argument_list|,
name|dp
operator|->
name|dp_meta_objset
argument_list|,
name|obj
argument_list|)
argument_list|)
expr_stmt|;
name|VERIFY3U
argument_list|(
literal|0
argument_list|,
operator|==
argument_list|,
name|dmu_objset_find_spa
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|,
name|NULL
argument_list|,
name|upgrade_dir_clones_cb
argument_list|,
name|tx
argument_list|,
name|DS_FIND_CHILDREN
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|dsl_pool_create_origin
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|uint64_t
name|dsobj
decl_stmt|;
name|dsl_dataset_t
modifier|*
name|ds
decl_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_origin_snap
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* create the origin dir, ds,& snap-ds */
name|rw_enter
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|dsobj
operator|=
name|dsl_dataset_create_sync
argument_list|(
name|dp
operator|->
name|dp_root_dir
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|kcred
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|FTAG
argument_list|,
operator|&
name|ds
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_snapshot_sync
argument_list|(
name|ds
argument_list|,
name|ORIGIN_DIR_NAME
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dsl_dataset_hold_obj
argument_list|(
name|dp
argument_list|,
name|ds
operator|->
name|ds_phys
operator|->
name|ds_prev_snap_obj
argument_list|,
name|dp
argument_list|,
operator|&
name|dp
operator|->
name|dp_origin_snap
argument_list|)
argument_list|)
expr_stmt|;
name|dsl_dataset_rele
argument_list|(
name|ds
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|dp
operator|->
name|dp_config_rwlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|taskq_t
modifier|*
name|dsl_pool_vnrele_taskq
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
return|return
operator|(
name|dp
operator|->
name|dp_vnrele_taskq
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Walk through the pool-wide zap object of temporary snapshot user holds  * and release them.  */
end_comment

begin_function
name|void
name|dsl_pool_clean_tmp_userrefs
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|)
block|{
name|zap_attribute_t
name|za
decl_stmt|;
name|zap_cursor_t
name|zc
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|dp
operator|->
name|dp_tmp_userrefs_obj
decl_stmt|;
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
return|return;
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_USERREFS
argument_list|)
expr_stmt|;
for|for
control|(
name|zap_cursor_init
argument_list|(
operator|&
name|zc
argument_list|,
name|mos
argument_list|,
name|zapobj
argument_list|)
init|;
name|zap_cursor_retrieve
argument_list|(
operator|&
name|zc
argument_list|,
operator|&
name|za
argument_list|)
operator|==
literal|0
condition|;
name|zap_cursor_advance
argument_list|(
operator|&
name|zc
argument_list|)
control|)
block|{
name|char
modifier|*
name|htag
decl_stmt|;
name|uint64_t
name|dsobj
decl_stmt|;
name|htag
operator|=
name|strchr
argument_list|(
name|za
operator|.
name|za_name
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
operator|*
name|htag
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|htag
expr_stmt|;
name|dsobj
operator|=
name|strtonum
argument_list|(
name|za
operator|.
name|za_name
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dsl_dataset_user_release_tmp
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|htag
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
block|}
name|zap_cursor_fini
argument_list|(
operator|&
name|zc
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create the pool-wide zap object for storing temporary snapshot holds.  */
end_comment

begin_function
name|void
name|dsl_pool_user_hold_create_obj
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|ASSERT
argument_list|(
name|dp
operator|->
name|dp_tmp_userrefs_obj
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
name|dp
operator|->
name|dp_tmp_userrefs_obj
operator|=
name|zap_create
argument_list|(
name|mos
argument_list|,
name|DMU_OT_USERREFS
argument_list|,
name|DMU_OT_NONE
argument_list|,
literal|0
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|zap_add
argument_list|(
name|mos
argument_list|,
name|DMU_POOL_DIRECTORY_OBJECT
argument_list|,
name|DMU_POOL_TMP_USERREFS
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
literal|1
argument_list|,
operator|&
name|dp
operator|->
name|dp_tmp_userrefs_obj
argument_list|,
name|tx
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|dsl_pool_user_hold_rele_impl
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|uint64_t
modifier|*
name|now
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|,
name|boolean_t
name|holding
parameter_list|)
block|{
name|objset_t
modifier|*
name|mos
init|=
name|dp
operator|->
name|dp_meta_objset
decl_stmt|;
name|uint64_t
name|zapobj
init|=
name|dp
operator|->
name|dp_tmp_userrefs_obj
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|error
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_version
argument_list|(
name|dp
operator|->
name|dp_spa
argument_list|)
operator|>=
name|SPA_VERSION_USERREFS
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dmu_tx_is_syncing
argument_list|(
name|tx
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * If the pool was created prior to SPA_VERSION_USERREFS, the 	 * zap object for temporary holds might not exist yet. 	 */
if|if
condition|(
name|zapobj
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|holding
condition|)
block|{
name|dsl_pool_user_hold_create_obj
argument_list|(
name|dp
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|zapobj
operator|=
name|dp
operator|->
name|dp_tmp_userrefs_obj
expr_stmt|;
block|}
else|else
block|{
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
block|}
name|name
operator|=
name|kmem_asprintf
argument_list|(
literal|"%llx-%s"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|dsobj
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|holding
condition|)
name|error
operator|=
name|zap_add
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|name
argument_list|,
literal|8
argument_list|,
literal|1
argument_list|,
name|now
argument_list|,
name|tx
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|zap_remove
argument_list|(
name|mos
argument_list|,
name|zapobj
argument_list|,
name|name
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|strfree
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a temporary hold for the given dataset object and tag.  */
end_comment

begin_function
name|int
name|dsl_pool_user_hold
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|uint64_t
modifier|*
name|now
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
name|dsl_pool_user_hold_rele_impl
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|now
argument_list|,
name|tx
argument_list|,
name|B_TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a temporary hold for the given dataset object and tag.  */
end_comment

begin_function
name|int
name|dsl_pool_user_release
parameter_list|(
name|dsl_pool_t
modifier|*
name|dp
parameter_list|,
name|uint64_t
name|dsobj
parameter_list|,
specifier|const
name|char
modifier|*
name|tag
parameter_list|,
name|dmu_tx_t
modifier|*
name|tx
parameter_list|)
block|{
return|return
operator|(
name|dsl_pool_user_hold_rele_impl
argument_list|(
name|dp
argument_list|,
name|dsobj
argument_list|,
name|tag
argument_list|,
name|NULL
argument_list|,
name|tx
argument_list|,
name|B_FALSE
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

