begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012, 2017 by Delphix. All rights reserved.  * Copyright (c) 2014 Integros [integros.com]  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dsl_pool.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/abd.h>
end_include

begin_comment
comment|/*  * ZFS I/O Scheduler  * ---------------  *  * ZFS issues I/O operations to leaf vdevs to satisfy and complete zios.  The  * I/O scheduler determines when and in what order those operations are  * issued.  The I/O scheduler divides operations into five I/O classes  * prioritized in the following order: sync read, sync write, async read,  * async write, and scrub/resilver.  Each queue defines the minimum and  * maximum number of concurrent operations that may be issued to the device.  * In addition, the device has an aggregate maximum. Note that the sum of the  * per-queue minimums must not exceed the aggregate maximum, and if the  * aggregate maximum is equal to or greater than the sum of the per-queue  * maximums, the per-queue minimum has no effect.  *  * For many physical devices, throughput increases with the number of  * concurrent operations, but latency typically suffers. Further, physical  * devices typically have a limit at which more concurrent operations have no  * effect on throughput or can actually cause it to decrease.  *  * The scheduler selects the next operation to issue by first looking for an  * I/O class whose minimum has not been satisfied. Once all are satisfied and  * the aggregate maximum has not been hit, the scheduler looks for classes  * whose maximum has not been satisfied. Iteration through the I/O classes is  * done in the order specified above. No further operations are issued if the  * aggregate maximum number of concurrent operations has been hit or if there  * are no operations queued for an I/O class that has not hit its maximum.  * Every time an i/o is queued or an operation completes, the I/O scheduler  * looks for new operations to issue.  *  * All I/O classes have a fixed maximum number of outstanding operations  * except for the async write class. Asynchronous writes represent the data  * that is committed to stable storage during the syncing stage for  * transaction groups (see txg.c). Transaction groups enter the syncing state  * periodically so the number of queued async writes will quickly burst up and  * then bleed down to zero. Rather than servicing them as quickly as possible,  * the I/O scheduler changes the maximum number of active async write i/os  * according to the amount of dirty data in the pool (see dsl_pool.c). Since  * both throughput and latency typically increase with the number of  * concurrent operations issued to physical devices, reducing the burstiness  * in the number of concurrent operations also stabilizes the response time of  * operations from other -- and in particular synchronous -- queues. In broad  * strokes, the I/O scheduler will issue more concurrent operations from the  * async write queue as there's more dirty data in the pool.  *  * Async Writes  *  * The number of concurrent operations issued for the async write I/O class  * follows a piece-wise linear function defined by a few adjustable points.  *  *        |                   o---------|<-- zfs_vdev_async_write_max_active  *   ^    |                  /^         |  *   |    |                 / |         |  * active |                /  |         |  *  I/O   |               /   |         |  * count  |              /    |         |  *        |             /     |         |  *        |------------o      |         |<-- zfs_vdev_async_write_min_active  *       0|____________^______|_________|  *        0%           |      |       100% of zfs_dirty_data_max  *                     |      |  *                     |      `-- zfs_vdev_async_write_active_max_dirty_percent  *                     `--------- zfs_vdev_async_write_active_min_dirty_percent  *  * Until the amount of dirty data exceeds a minimum percentage of the dirty  * data allowed in the pool, the I/O scheduler will limit the number of  * concurrent operations to the minimum. As that threshold is crossed, the  * number of concurrent operations issued increases linearly to the maximum at  * the specified maximum percentage of the dirty data allowed in the pool.  *  * Ideally, the amount of dirty data on a busy pool will stay in the sloped  * part of the function between zfs_vdev_async_write_active_min_dirty_percent  * and zfs_vdev_async_write_active_max_dirty_percent. If it exceeds the  * maximum percentage, this indicates that the rate of incoming data is  * greater than the rate that the backend storage can handle. In this case, we  * must further throttle incoming writes (see dmu_tx_delay() for details).  */
end_comment

begin_comment
comment|/*  * The maximum number of i/os active to each device.  Ideally, this will be>=  * the sum of each queue's max_active.  It must be at least the sum of each  * queue's min_active.  */
end_comment

begin_decl_stmt
name|uint32_t
name|zfs_vdev_max_active
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Per-queue limits on the number of i/os active to each device.  If the  * sum of the queue's max_active is< zfs_vdev_max_active, then the  * min_active comes into play.  We will send min_active from each queue,  * and then select from queues in the order defined by zio_priority_t.  *  * In general, smaller max_active's will lead to lower latency of synchronous  * operations.  Larger max_active's may lead to higher overall throughput,  * depending on underlying storage.  *  * The ratio of the queues' max_actives determines the balance of performance  * between reads, writes, and scrubs.  E.g., increasing  * zfs_vdev_scrub_max_active will cause the scrub or resilver to complete  * more quickly, but reads and writes to have higher latency and lower  * throughput.  */
end_comment

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_read_min_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_read_max_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_write_min_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_sync_write_max_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_read_min_active
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_read_max_active
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_write_min_active
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_async_write_max_active
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_scrub_min_active
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint32_t
name|zfs_vdev_scrub_max_active
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When the pool has less than zfs_vdev_async_write_active_min_dirty_percent  * dirty data, use zfs_vdev_async_write_min_active.  When it has more than  * zfs_vdev_async_write_active_max_dirty_percent, use  * zfs_vdev_async_write_max_active. The value is linearly interpolated  * between min and max.  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_async_write_active_min_dirty_percent
init|=
literal|30
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_async_write_active_max_dirty_percent
init|=
literal|60
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To reduce IOPs, we aggregate small adjacent I/Os into one large I/O.  * For read I/Os, we also aggregate across small adjacency gaps; for writes  * we include spans of optional I/Os to aid aggregation at the disk even when  * they aren't able to help us aggregate at this level.  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_aggregation_limit
init|=
name|SPA_OLD_MAXBLOCKSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_read_gap_limit
init|=
literal|32
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_write_gap_limit
init|=
literal|4
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Define the queue depth percentage for each top-level. This percentage is  * used in conjunction with zfs_vdev_async_max_active to determine how many  * allocations a specific top-level vdev should handle. Once the queue depth  * reaches zfs_vdev_queue_depth_pct * zfs_vdev_async_write_max_active / 100  * then allocator will stop allocating blocks on that top-level device.  * The default kernel setting is 1000% which will yield 100 allocations per  * device. For userland testing, the default setting is 300% which equates  * to 30 allocations per device.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_decl_stmt
name|int
name|zfs_vdev_queue_depth_pct
init|=
literal|1000
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|int
name|zfs_vdev_queue_depth_pct
init|=
literal|300
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|vdev_queue_offset_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|<
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|>
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|avl_tree_t
modifier|*
name|vdev_queue_class_tree
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_priority_t
name|p
parameter_list|)
block|{
return|return
operator|(
operator|&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_queued_tree
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|avl_tree_t
modifier|*
name|vdev_queue_type_tree
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_type_t
name|t
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|t
operator|==
name|ZIO_TYPE_READ
operator|||
name|t
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|ZIO_TYPE_READ
condition|)
return|return
operator|(
operator|&
name|vq
operator|->
name|vq_read_offset_tree
operator|)
return|;
else|else
return|return
operator|(
operator|&
name|vq
operator|->
name|vq_write_offset_tree
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_queue_timestamp_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_timestamp
operator|<
name|z2
operator|->
name|io_timestamp
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_timestamp
operator|>
name|z2
operator|->
name|io_timestamp
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_vdev
operator|=
name|vd
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_queue_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
name|vdev_queue_type_tree
argument_list|(
name|vq
argument_list|,
name|ZIO_TYPE_READ
argument_list|)
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
name|vdev_queue_type_tree
argument_list|(
name|vq
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|)
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|zio_priority_t
name|p
init|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
block|{
name|int
function_decl|(
modifier|*
name|compfn
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
function_decl|;
comment|/* 		 * The synchronous i/o queues are dispatched in FIFO rather 		 * than LBA order.  This provides more consistent latency for 		 * these i/os. 		 */
if|if
condition|(
name|p
operator|==
name|ZIO_PRIORITY_SYNC_READ
operator|||
name|p
operator|==
name|ZIO_PRIORITY_SYNC_WRITE
condition|)
name|compfn
operator|=
name|vdev_queue_timestamp_compare
expr_stmt|;
else|else
name|compfn
operator|=
name|vdev_queue_offset_compare
expr_stmt|;
name|avl_create
argument_list|(
name|vdev_queue_class_tree
argument_list|(
name|vq
argument_list|,
name|p
argument_list|)
argument_list|,
name|compfn
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_queue_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|vdev_queue_fini
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
for|for
control|(
name|zio_priority_t
name|p
init|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
name|avl_destroy
argument_list|(
name|vdev_queue_class_tree
argument_list|(
name|vq
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|vdev_queue_type_tree
argument_list|(
name|vq
argument_list|,
name|ZIO_TYPE_READ
argument_list|)
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
name|vdev_queue_type_tree
argument_list|(
name|vq
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_add
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
name|vdev_queue_class_tree
argument_list|(
name|vq
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|)
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
name|vdev_queue_type_tree
argument_list|(
name|vq
argument_list|,
name|zio
operator|->
name|io_type
argument_list|)
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_queued
operator|++
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
name|kstat_waitq_enter
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_remove
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
name|vdev_queue_class_tree
argument_list|(
name|vq
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|)
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
name|vdev_queue_type_tree
argument_list|(
name|vq
argument_list|,
name|zio
operator|->
name|io_type
argument_list|)
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_queued
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_queued
operator|--
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
name|kstat_waitq_exit
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_pending_add
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_class
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|vqc_active
operator|++
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_active
operator|++
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
name|kstat_runq_enter
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_pending_remove
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|<
argument_list|,
name|ZIO_PRIORITY_NUM_QUEUEABLE
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_class
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|vqc_active
operator|--
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_active
argument_list|,
operator|>
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|spa
operator|->
name|spa_queue_stats
index|[
name|zio
operator|->
name|io_priority
index|]
operator|.
name|spa_active
operator|--
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
block|{
name|kstat_io_t
modifier|*
name|ksio
init|=
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
decl_stmt|;
name|kstat_runq_exit
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
name|ksio
operator|->
name|reads
operator|++
expr_stmt|;
name|ksio
operator|->
name|nread
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|ksio
operator|->
name|writes
operator|++
expr_stmt|;
name|ksio
operator|->
name|nwritten
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_agg_io_done
parameter_list|(
name|zio_t
modifier|*
name|aio
parameter_list|)
block|{
if|if
condition|(
name|aio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|;
name|zio_link_t
modifier|*
name|zl
init|=
name|NULL
decl_stmt|;
while|while
condition|(
operator|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|aio
argument_list|,
operator|&
name|zl
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|abd_copy_off
argument_list|(
name|pio
operator|->
name|io_abd
argument_list|,
name|aio
operator|->
name|io_abd
argument_list|,
literal|0
argument_list|,
name|pio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
block|}
name|abd_free
argument_list|(
name|aio
operator|->
name|io_abd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_queue_class_min_active
parameter_list|(
name|zio_priority_t
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|ZIO_PRIORITY_SYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_sync_read_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_SYNC_WRITE
case|:
return|return
operator|(
name|zfs_vdev_sync_write_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_async_read_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_WRITE
case|:
return|return
operator|(
name|zfs_vdev_async_write_min_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_SCRUB
case|:
return|return
operator|(
name|zfs_vdev_scrub_min_active
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"invalid priority %u"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_queue_max_async_writes
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|)
block|{
name|int
name|writes
decl_stmt|;
name|uint64_t
name|dirty
init|=
name|spa
operator|->
name|spa_dsl_pool
operator|->
name|dp_dirty_total
decl_stmt|;
name|uint64_t
name|min_bytes
init|=
name|zfs_dirty_data_max
operator|*
name|zfs_vdev_async_write_active_min_dirty_percent
operator|/
literal|100
decl_stmt|;
name|uint64_t
name|max_bytes
init|=
name|zfs_dirty_data_max
operator|*
name|zfs_vdev_async_write_active_max_dirty_percent
operator|/
literal|100
decl_stmt|;
comment|/* 	 * Sync tasks correspond to interactive user actions. To reduce the 	 * execution time of those actions we push data out as fast as possible. 	 */
if|if
condition|(
name|spa_has_pending_synctask
argument_list|(
name|spa
argument_list|)
condition|)
block|{
return|return
operator|(
name|zfs_vdev_async_write_max_active
operator|)
return|;
block|}
if|if
condition|(
name|dirty
operator|<
name|min_bytes
condition|)
return|return
operator|(
name|zfs_vdev_async_write_min_active
operator|)
return|;
if|if
condition|(
name|dirty
operator|>
name|max_bytes
condition|)
return|return
operator|(
name|zfs_vdev_async_write_max_active
operator|)
return|;
comment|/* 	 * linear interpolation: 	 * slope = (max_writes - min_writes) / (max_bytes - min_bytes) 	 * move right by min_bytes 	 * move up by min_writes 	 */
name|writes
operator|=
operator|(
name|dirty
operator|-
name|min_bytes
operator|)
operator|*
operator|(
name|zfs_vdev_async_write_max_active
operator|-
name|zfs_vdev_async_write_min_active
operator|)
operator|/
operator|(
name|max_bytes
operator|-
name|min_bytes
operator|)
operator|+
name|zfs_vdev_async_write_min_active
expr_stmt|;
name|ASSERT3U
argument_list|(
name|writes
argument_list|,
operator|>=
argument_list|,
name|zfs_vdev_async_write_min_active
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|writes
argument_list|,
operator|<=
argument_list|,
name|zfs_vdev_async_write_max_active
argument_list|)
expr_stmt|;
return|return
operator|(
name|writes
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|vdev_queue_class_max_active
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|zio_priority_t
name|p
parameter_list|)
block|{
switch|switch
condition|(
name|p
condition|)
block|{
case|case
name|ZIO_PRIORITY_SYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_sync_read_max_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_SYNC_WRITE
case|:
return|return
operator|(
name|zfs_vdev_sync_write_max_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_READ
case|:
return|return
operator|(
name|zfs_vdev_async_read_max_active
operator|)
return|;
case|case
name|ZIO_PRIORITY_ASYNC_WRITE
case|:
return|return
operator|(
name|vdev_queue_max_async_writes
argument_list|(
name|spa
argument_list|)
operator|)
return|;
case|case
name|ZIO_PRIORITY_SCRUB
case|:
return|return
operator|(
name|zfs_vdev_scrub_max_active
operator|)
return|;
default|default:
name|panic
argument_list|(
literal|"invalid priority %u"
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Return the i/o class to issue from, or ZIO_PRIORITY_MAX_QUEUEABLE if  * there is no eligible class.  */
end_comment

begin_function
specifier|static
name|zio_priority_t
name|vdev_queue_class_to_issue
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|vq
operator|->
name|vq_vdev
operator|->
name|vdev_spa
decl_stmt|;
name|zio_priority_t
name|p
decl_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_active_tree
argument_list|)
operator|>=
name|zfs_vdev_max_active
condition|)
return|return
operator|(
name|ZIO_PRIORITY_NUM_QUEUEABLE
operator|)
return|;
comment|/* find a queue that has not reached its minimum # outstanding i/os */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|avl_numnodes
argument_list|(
name|vdev_queue_class_tree
argument_list|(
name|vq
argument_list|,
name|p
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_active
operator|<
name|vdev_queue_class_min_active
argument_list|(
name|p
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* 	 * If we haven't found a queue, look for one that hasn't reached its 	 * maximum # outstanding i/os. 	 */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
name|avl_numnodes
argument_list|(
name|vdev_queue_class_tree
argument_list|(
name|vq
argument_list|,
name|p
argument_list|)
argument_list|)
operator|>
literal|0
operator|&&
name|vq
operator|->
name|vq_class
index|[
name|p
index|]
operator|.
name|vqc_active
operator|<
name|vdev_queue_class_max_active
argument_list|(
name|spa
argument_list|,
name|p
argument_list|)
condition|)
return|return
operator|(
name|p
operator|)
return|;
block|}
comment|/* No eligible queued i/os */
return|return
operator|(
name|ZIO_PRIORITY_NUM_QUEUEABLE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the range spanned by two i/os, which is the endpoint of the last  * (lio->io_offset + lio->io_size) minus start of the first (fio->io_offset).  * Conveniently, the gap between fio and lio is given by -IO_SPAN(lio, fio);  * thus fio and lio are adjacent if and only if IO_SPAN(lio, fio) == 0.  */
end_comment

begin_define
define|#
directive|define
name|IO_SPAN
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|((lio)->io_offset + (lio)->io_size - (fio)->io_offset)
end_define

begin_define
define|#
directive|define
name|IO_GAP
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|(-IO_SPAN(lio, fio))
end_define

begin_function
specifier|static
name|zio_t
modifier|*
name|vdev_queue_aggregate
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|zio_t
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|,
modifier|*
name|aio
decl_stmt|,
modifier|*
name|dio
decl_stmt|,
modifier|*
name|mandatory
decl_stmt|,
modifier|*
name|nio
decl_stmt|;
name|uint64_t
name|maxgap
init|=
literal|0
decl_stmt|;
name|uint64_t
name|size
decl_stmt|;
name|boolean_t
name|stretch
init|=
name|B_FALSE
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
name|vdev_queue_type_tree
argument_list|(
name|vq
argument_list|,
name|zio
operator|->
name|io_type
argument_list|)
decl_stmt|;
name|enum
name|zio_flag
name|flags
init|=
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_AGGREGATE
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|first
operator|=
name|last
operator|=
name|zio
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|maxgap
operator|=
name|zfs_vdev_read_gap_limit
expr_stmt|;
comment|/* 	 * We can aggregate I/Os that are sufficiently adjacent and of 	 * the same flavor, as expressed by the AGG_INHERIT flags. 	 * The latter requirement is necessary so that certain 	 * attributes of the I/O, such as whether it's a normal I/O 	 * or a scrub/resilver, can be preserved in the aggregate. 	 * We can include optional I/Os, but don't allow them 	 * to begin a range as they add no benefit in that situation. 	 */
comment|/* 	 * We keep track of the last non-optional I/O. 	 */
name|mandatory
operator|=
operator|(
name|first
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|?
name|NULL
else|:
name|first
expr_stmt|;
comment|/* 	 * Walk backwards through sufficiently contiguous I/Os 	 * recording the last non-optional I/O. 	 */
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|first
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
name|IO_SPAN
argument_list|(
name|dio
argument_list|,
name|last
argument_list|)
operator|<=
name|zfs_vdev_aggregation_limit
operator|&&
name|IO_GAP
argument_list|(
name|dio
argument_list|,
name|first
argument_list|)
operator|<=
name|maxgap
condition|)
block|{
name|first
operator|=
name|dio
expr_stmt|;
if|if
condition|(
name|mandatory
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|first
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
name|mandatory
operator|=
name|first
expr_stmt|;
block|}
comment|/* 	 * Skip any initial optional I/Os. 	 */
while|while
condition|(
operator|(
name|first
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
operator|&&
name|first
operator|!=
name|last
condition|)
block|{
name|first
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|first
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Walk forward through sufficiently contiguous I/Os. 	 * The aggregation limit does not apply to optional i/os, so that 	 * we can issue contiguous writes even if they are larger than the 	 * aggregation limit. 	 */
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
operator|(
name|IO_SPAN
argument_list|(
name|first
argument_list|,
name|dio
argument_list|)
operator|<=
name|zfs_vdev_aggregation_limit
operator|||
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
operator|)
operator|&&
name|IO_GAP
argument_list|(
name|last
argument_list|,
name|dio
argument_list|)
operator|<=
name|maxgap
condition|)
block|{
name|last
operator|=
name|dio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|last
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
name|mandatory
operator|=
name|last
expr_stmt|;
block|}
comment|/* 	 * Now that we've established the range of the I/O aggregation 	 * we must decide what to do with trailing optional I/Os. 	 * For reads, there's nothing to do. While we are unable to 	 * aggregate further, it's possible that a trailing optional 	 * I/O would allow the underlying device to aggregate with 	 * subsequent I/Os. We must therefore determine if the next 	 * non-optional I/O is close enough to make aggregation 	 * worthwhile. 	 */
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
operator|&&
name|mandatory
operator|!=
name|NULL
condition|)
block|{
name|zio_t
modifier|*
name|nio
init|=
name|last
decl_stmt|;
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|nio
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|IO_GAP
argument_list|(
name|nio
argument_list|,
name|dio
argument_list|)
operator|==
literal|0
operator|&&
name|IO_GAP
argument_list|(
name|mandatory
argument_list|,
name|dio
argument_list|)
operator|<=
name|zfs_vdev_write_gap_limit
condition|)
block|{
name|nio
operator|=
name|dio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
block|{
name|stretch
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|stretch
condition|)
block|{
comment|/* 		 * We are going to include an optional io in our aggregated 		 * span, thus closing the write gap.  Only mandatory i/os can 		 * start aggregated spans, so make sure that the next i/o 		 * after our span is mandatory. 		 */
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|dio
operator|->
name|io_flags
operator|&=
operator|~
name|ZIO_FLAG_OPTIONAL
expr_stmt|;
block|}
else|else
block|{
comment|/* do not include the optional i/o */
while|while
condition|(
name|last
operator|!=
name|mandatory
operator|&&
name|last
operator|!=
name|first
condition|)
block|{
name|ASSERT
argument_list|(
name|last
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
argument_list|)
expr_stmt|;
name|last
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|last
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
operator|==
name|last
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|size
operator|=
name|IO_SPAN
argument_list|(
name|first
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|size
argument_list|,
operator|<=
argument_list|,
name|SPA_MAXBLOCKSIZE
argument_list|)
expr_stmt|;
name|aio
operator|=
name|zio_vdev_delegated_io
argument_list|(
name|first
operator|->
name|io_vd
argument_list|,
name|first
operator|->
name|io_offset
argument_list|,
name|abd_alloc_for_io
argument_list|(
name|size
argument_list|,
name|B_TRUE
argument_list|)
argument_list|,
name|size
argument_list|,
name|first
operator|->
name|io_type
argument_list|,
name|zio
operator|->
name|io_priority
argument_list|,
name|flags
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
argument_list|,
name|vdev_queue_agg_io_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|aio
operator|->
name|io_timestamp
operator|=
name|first
operator|->
name|io_timestamp
expr_stmt|;
name|nio
operator|=
name|first
expr_stmt|;
do|do
block|{
name|dio
operator|=
name|nio
expr_stmt|;
name|nio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|dio
operator|->
name|io_type
argument_list|,
operator|==
argument_list|,
name|aio
operator|->
name|io_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
condition|)
block|{
name|ASSERT3U
argument_list|(
name|dio
operator|->
name|io_type
argument_list|,
operator|==
argument_list|,
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
name|abd_zero_off
argument_list|(
name|aio
operator|->
name|io_abd
argument_list|,
name|dio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
argument_list|,
name|dio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|abd_copy_off
argument_list|(
name|aio
operator|->
name|io_abd
argument_list|,
name|dio
operator|->
name|io_abd
argument_list|,
name|dio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
argument_list|,
literal|0
argument_list|,
name|dio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
name|zio_add_child
argument_list|(
name|dio
argument_list|,
name|aio
argument_list|)
expr_stmt|;
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|dio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|dio
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dio
operator|!=
name|last
condition|)
do|;
return|return
operator|(
name|aio
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|zio_t
modifier|*
name|vdev_queue_io_to_issue
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|)
block|{
name|zio_t
modifier|*
name|zio
decl_stmt|,
modifier|*
name|aio
decl_stmt|;
name|zio_priority_t
name|p
decl_stmt|;
name|avl_index_t
name|idx
decl_stmt|;
name|avl_tree_t
modifier|*
name|tree
decl_stmt|;
name|zio_t
name|search
decl_stmt|;
name|again
label|:
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
name|p
operator|=
name|vdev_queue_class_to_issue
argument_list|(
name|vq
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|ZIO_PRIORITY_NUM_QUEUEABLE
condition|)
block|{
comment|/* No eligible queued i/os */
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * For LBA-ordered queues (async / scrub), issue the i/o which follows 	 * the most recently issued i/o in LBA (offset) order. 	 * 	 * For FIFO queues (sync), issue the i/o with the lowest timestamp. 	 */
name|tree
operator|=
name|vdev_queue_class_tree
argument_list|(
name|vq
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|search
operator|.
name|io_timestamp
operator|=
literal|0
expr_stmt|;
name|search
operator|.
name|io_offset
operator|=
name|vq
operator|->
name|vq_last_offset
operator|+
literal|1
expr_stmt|;
name|VERIFY3P
argument_list|(
name|avl_find
argument_list|(
name|tree
argument_list|,
operator|&
name|search
argument_list|,
operator|&
name|idx
argument_list|)
argument_list|,
operator|==
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|zio
operator|=
name|avl_nearest
argument_list|(
name|tree
argument_list|,
name|idx
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|==
name|NULL
condition|)
name|zio
operator|=
name|avl_first
argument_list|(
name|tree
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|zio
operator|->
name|io_priority
argument_list|,
operator|==
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|aio
operator|=
name|vdev_queue_aggregate
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|aio
operator|!=
name|NULL
condition|)
name|zio
operator|=
name|aio
expr_stmt|;
else|else
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O is or was optional and therefore has no data, we need to 	 * simply discard it. We need to drop the vdev queue's lock to avoid a 	 * deadlock that we could encounter since this I/O will complete 	 * immediately. 	 */
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|zio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|vdev_queue_pending_add
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_last_offset
operator|=
name|zio
operator|->
name|io_offset
expr_stmt|;
return|return
operator|(
name|zio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|vdev_queue_io
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
name|zio_t
modifier|*
name|nio
decl_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_QUEUE
condition|)
return|return
operator|(
name|zio
operator|)
return|;
comment|/* 	 * Children i/os inherent their parent's priority, which might 	 * not match the child's i/o type.  Fix it up here. 	 */
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
if|if
condition|(
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_SYNC_READ
operator|&&
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_ASYNC_READ
operator|&&
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_SCRUB
condition|)
name|zio
operator|->
name|io_priority
operator|=
name|ZIO_PRIORITY_ASYNC_READ
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_SYNC_WRITE
operator|&&
name|zio
operator|->
name|io_priority
operator|!=
name|ZIO_PRIORITY_ASYNC_WRITE
condition|)
name|zio
operator|->
name|io_priority
operator|=
name|ZIO_PRIORITY_ASYNC_WRITE
expr_stmt|;
block|}
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_timestamp
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
name|vdev_queue_io_add
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|nio
operator|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
name|zio_t
modifier|*
name|nio
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|vdev_queue_pending_remove
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_io_complete_ts
operator|=
name|gethrtime
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|nio
operator|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio_vdev_io_reissue
argument_list|(
name|nio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

