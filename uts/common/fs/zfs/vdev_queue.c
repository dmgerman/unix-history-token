begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2012 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spa_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_include
include|#
directive|include
file|<sys/avl.h>
end_include

begin_comment
comment|/*  * These tunables are for performance analysis.  */
end_comment

begin_comment
comment|/*  * zfs_vdev_max_pending is the maximum number of i/os concurrently  * pending to each device.  zfs_vdev_min_pending is the initial number  * of i/os pending to each device (before it starts ramping up to  * max_pending).  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_max_pending
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_min_pending
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* deadline = pri + ddi_get_lbolt64()>> time_shift) */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_time_shift
init|=
literal|6
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exponential I/O issue ramp-up rate */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_ramp_rate
init|=
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * To reduce IOPs, we aggregate small adjacent I/Os into one large I/O.  * For read I/Os, we also aggregate across small adjacency gaps; for writes  * we include spans of optional I/Os to aid aggregation at the disk even when  * they aren't able to help us aggregate at this level.  */
end_comment

begin_decl_stmt
name|int
name|zfs_vdev_aggregation_limit
init|=
name|SPA_MAXBLOCKSIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_read_gap_limit
init|=
literal|32
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|zfs_vdev_write_gap_limit
init|=
literal|4
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Virtual device vector for disk I/O scheduling.  */
end_comment

begin_function
name|int
name|vdev_queue_deadline_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_deadline
operator|<
name|z2
operator|->
name|io_deadline
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_deadline
operator|>
name|z2
operator|->
name|io_deadline
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|<
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|>
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vdev_queue_offset_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|zio_t
modifier|*
name|z1
init|=
name|x1
decl_stmt|;
specifier|const
name|zio_t
modifier|*
name|z2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|<
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|->
name|io_offset
operator|>
name|z2
operator|->
name|io_offset
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|<
name|z2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|z1
operator|>
name|z2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_init
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|,
name|vdev_queue_deadline_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_deadline_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_read_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_write_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|,
name|vdev_queue_offset_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|zio_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|zio
argument_list|,
name|io_offset_node
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vdev_queue_fini
parameter_list|(
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|vd
operator|->
name|vdev_queue
decl_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_read_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_write_tree
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_add
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|avl_add
argument_list|(
name|zio
operator|->
name|io_vdev_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|kstat_waitq_enter
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_io_remove
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|avl_remove
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
name|zio
operator|->
name|io_vdev_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|kstat_waitq_exit
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_pending_add
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|avl_add
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|kstat_runq_enter
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_pending_remove
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|zio
operator|->
name|io_spa
decl_stmt|;
name|avl_remove
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|,
name|zio
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa
operator|->
name|spa_iokstat
operator|!=
name|NULL
condition|)
block|{
name|kstat_io_t
modifier|*
name|ksio
init|=
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
name|kstat_runq_exit
argument_list|(
name|spa
operator|->
name|spa_iokstat
operator|->
name|ks_data
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
block|{
name|ksio
operator|->
name|reads
operator|++
expr_stmt|;
name|ksio
operator|->
name|nread
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|ksio
operator|->
name|writes
operator|++
expr_stmt|;
name|ksio
operator|->
name|nwritten
operator|+=
name|zio
operator|->
name|io_size
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|spa
operator|->
name|spa_iokstat_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|vdev_queue_agg_io_done
parameter_list|(
name|zio_t
modifier|*
name|aio
parameter_list|)
block|{
name|zio_t
modifier|*
name|pio
decl_stmt|;
while|while
condition|(
operator|(
name|pio
operator|=
name|zio_walk_parents
argument_list|(
name|aio
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|aio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|pio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|pio
operator|->
name|io_data
argument_list|,
name|pio
operator|->
name|io_size
argument_list|)
expr_stmt|;
name|zio_buf_free
argument_list|(
name|aio
operator|->
name|io_data
argument_list|,
name|aio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compute the range spanned by two i/os, which is the endpoint of the last  * (lio->io_offset + lio->io_size) minus start of the first (fio->io_offset).  * Conveniently, the gap between fio and lio is given by -IO_SPAN(lio, fio);  * thus fio and lio are adjacent if and only if IO_SPAN(lio, fio) == 0.  */
end_comment

begin_define
define|#
directive|define
name|IO_SPAN
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|((lio)->io_offset + (lio)->io_size - (fio)->io_offset)
end_define

begin_define
define|#
directive|define
name|IO_GAP
parameter_list|(
name|fio
parameter_list|,
name|lio
parameter_list|)
value|(-IO_SPAN(lio, fio))
end_define

begin_function
specifier|static
name|zio_t
modifier|*
name|vdev_queue_io_to_issue
parameter_list|(
name|vdev_queue_t
modifier|*
name|vq
parameter_list|,
name|uint64_t
name|pending_limit
parameter_list|)
block|{
name|zio_t
modifier|*
name|fio
decl_stmt|,
modifier|*
name|lio
decl_stmt|,
modifier|*
name|aio
decl_stmt|,
modifier|*
name|dio
decl_stmt|,
modifier|*
name|nio
decl_stmt|,
modifier|*
name|mio
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|uint64_t
name|maxspan
init|=
name|zfs_vdev_aggregation_limit
decl_stmt|;
name|uint64_t
name|maxgap
decl_stmt|;
name|int
name|stretch
decl_stmt|;
name|again
label|:
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_pending_tree
argument_list|)
operator|>=
name|pending_limit
operator|||
name|avl_numnodes
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|fio
operator|=
name|lio
operator|=
name|avl_first
argument_list|(
operator|&
name|vq
operator|->
name|vq_deadline_tree
argument_list|)
expr_stmt|;
name|t
operator|=
name|fio
operator|->
name|io_vdev_tree
expr_stmt|;
name|flags
operator|=
name|fio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
expr_stmt|;
name|maxgap
operator|=
operator|(
name|t
operator|==
operator|&
name|vq
operator|->
name|vq_read_tree
operator|)
condition|?
name|zfs_vdev_read_gap_limit
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|ZIO_FLAG_DONT_AGGREGATE
operator|)
condition|)
block|{
comment|/* 		 * We can aggregate I/Os that are sufficiently adjacent and of 		 * the same flavor, as expressed by the AGG_INHERIT flags. 		 * The latter requirement is necessary so that certain 		 * attributes of the I/O, such as whether it's a normal I/O 		 * or a scrub/resilver, can be preserved in the aggregate. 		 * We can include optional I/Os, but don't allow them 		 * to begin a range as they add no benefit in that situation. 		 */
comment|/* 		 * We keep track of the last non-optional I/O. 		 */
name|mio
operator|=
operator|(
name|fio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|?
name|NULL
else|:
name|fio
expr_stmt|;
comment|/* 		 * Walk backwards through sufficiently contiguous I/Os 		 * recording the last non-option I/O. 		 */
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|fio
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
name|IO_SPAN
argument_list|(
name|dio
argument_list|,
name|lio
argument_list|)
operator|<=
name|maxspan
operator|&&
name|IO_GAP
argument_list|(
name|dio
argument_list|,
name|fio
argument_list|)
operator|<=
name|maxgap
condition|)
block|{
name|fio
operator|=
name|dio
expr_stmt|;
if|if
condition|(
name|mio
operator|==
name|NULL
operator|&&
operator|!
operator|(
name|fio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
name|mio
operator|=
name|fio
expr_stmt|;
block|}
comment|/* 		 * Skip any initial optional I/Os. 		 */
while|while
condition|(
operator|(
name|fio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
operator|&&
name|fio
operator|!=
name|lio
condition|)
block|{
name|fio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|fio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Walk forward through sufficiently contiguous I/Os. 		 */
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|lio
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_AGG_INHERIT
operator|)
operator|==
name|flags
operator|&&
name|IO_SPAN
argument_list|(
name|fio
argument_list|,
name|dio
argument_list|)
operator|<=
name|maxspan
operator|&&
name|IO_GAP
argument_list|(
name|lio
argument_list|,
name|dio
argument_list|)
operator|<=
name|maxgap
condition|)
block|{
name|lio
operator|=
name|dio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|lio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
name|mio
operator|=
name|lio
expr_stmt|;
block|}
comment|/* 		 * Now that we've established the range of the I/O aggregation 		 * we must decide what to do with trailing optional I/Os. 		 * For reads, there's nothing to do. While we are unable to 		 * aggregate further, it's possible that a trailing optional 		 * I/O would allow the underlying device to aggregate with 		 * subsequent I/Os. We must therefore determine if the next 		 * non-optional I/O is close enough to make aggregation 		 * worthwhile. 		 */
name|stretch
operator|=
name|B_FALSE
expr_stmt|;
if|if
condition|(
name|t
operator|!=
operator|&
name|vq
operator|->
name|vq_read_tree
operator|&&
name|mio
operator|!=
name|NULL
condition|)
block|{
name|nio
operator|=
name|lio
expr_stmt|;
while|while
condition|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|nio
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
name|IO_GAP
argument_list|(
name|nio
argument_list|,
name|dio
argument_list|)
operator|==
literal|0
operator|&&
name|IO_GAP
argument_list|(
name|mio
argument_list|,
name|dio
argument_list|)
operator|<=
name|zfs_vdev_write_gap_limit
condition|)
block|{
name|nio
operator|=
name|dio
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
operator|)
condition|)
block|{
name|stretch
operator|=
name|B_TRUE
expr_stmt|;
break|break;
block|}
block|}
block|}
if|if
condition|(
name|stretch
condition|)
block|{
comment|/* This may be a no-op. */
name|VERIFY
argument_list|(
operator|(
name|dio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|lio
argument_list|)
operator|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|dio
operator|->
name|io_flags
operator|&=
operator|~
name|ZIO_FLAG_OPTIONAL
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|lio
operator|!=
name|mio
operator|&&
name|lio
operator|!=
name|fio
condition|)
block|{
name|ASSERT
argument_list|(
name|lio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_OPTIONAL
argument_list|)
expr_stmt|;
name|lio
operator|=
name|AVL_PREV
argument_list|(
name|t
argument_list|,
name|lio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|lio
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|fio
operator|!=
name|lio
condition|)
block|{
name|uint64_t
name|size
init|=
name|IO_SPAN
argument_list|(
name|fio
argument_list|,
name|lio
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|size
operator|<=
name|zfs_vdev_aggregation_limit
argument_list|)
expr_stmt|;
name|aio
operator|=
name|zio_vdev_delegated_io
argument_list|(
name|fio
operator|->
name|io_vd
argument_list|,
name|fio
operator|->
name|io_offset
argument_list|,
name|zio_buf_alloc
argument_list|(
name|size
argument_list|)
argument_list|,
name|size
argument_list|,
name|fio
operator|->
name|io_type
argument_list|,
name|ZIO_PRIORITY_AGG
argument_list|,
name|flags
operator||
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
argument_list|,
name|vdev_queue_agg_io_done
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|aio
operator|->
name|io_timestamp
operator|=
name|fio
operator|->
name|io_timestamp
expr_stmt|;
name|nio
operator|=
name|fio
expr_stmt|;
do|do
block|{
name|dio
operator|=
name|nio
expr_stmt|;
name|nio
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dio
operator|->
name|io_type
operator|==
name|aio
operator|->
name|io_type
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dio
operator|->
name|io_vdev_tree
operator|==
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|dio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
condition|)
block|{
name|ASSERT
argument_list|(
name|dio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|dio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|dio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|dio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
condition|)
block|{
name|bcopy
argument_list|(
name|dio
operator|->
name|io_data
argument_list|,
operator|(
name|char
operator|*
operator|)
name|aio
operator|->
name|io_data
operator|+
operator|(
name|dio
operator|->
name|io_offset
operator|-
name|aio
operator|->
name|io_offset
operator|)
argument_list|,
name|dio
operator|->
name|io_size
argument_list|)
expr_stmt|;
block|}
name|zio_add_child
argument_list|(
name|dio
argument_list|,
name|aio
argument_list|)
expr_stmt|;
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|dio
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|dio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|dio
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|dio
operator|!=
name|lio
condition|)
do|;
name|vdev_queue_pending_add
argument_list|(
name|vq
argument_list|,
name|aio
argument_list|)
expr_stmt|;
return|return
operator|(
name|aio
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|fio
operator|->
name|io_vdev_tree
operator|==
name|t
argument_list|)
expr_stmt|;
name|vdev_queue_io_remove
argument_list|(
name|vq
argument_list|,
name|fio
argument_list|)
expr_stmt|;
comment|/* 	 * If the I/O is or was optional and therefore has no data, we need to 	 * simply discard it. We need to drop the vdev queue's lock to avoid a 	 * deadlock that we could encounter since this I/O will complete 	 * immediately. 	 */
if|if
condition|(
name|fio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_NODATA
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|zio_vdev_io_bypass
argument_list|(
name|fio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|fio
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|vdev_queue_pending_add
argument_list|(
name|vq
argument_list|,
name|fio
argument_list|)
expr_stmt|;
return|return
operator|(
name|fio
operator|)
return|;
block|}
end_function

begin_function
name|zio_t
modifier|*
name|vdev_queue_io
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
name|zio_t
modifier|*
name|nio
decl_stmt|;
name|ASSERT
argument_list|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
operator|||
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_flags
operator|&
name|ZIO_FLAG_DONT_QUEUE
condition|)
return|return
operator|(
name|zio
operator|)
return|;
name|zio
operator|->
name|io_flags
operator||=
name|ZIO_FLAG_DONT_CACHE
operator||
name|ZIO_FLAG_DONT_QUEUE
expr_stmt|;
if|if
condition|(
name|zio
operator|->
name|io_type
operator|==
name|ZIO_TYPE_READ
condition|)
name|zio
operator|->
name|io_vdev_tree
operator|=
operator|&
name|vq
operator|->
name|vq_read_tree
expr_stmt|;
else|else
name|zio
operator|->
name|io_vdev_tree
operator|=
operator|&
name|vq
operator|->
name|vq_write_tree
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|zio
operator|->
name|io_timestamp
operator|=
name|ddi_get_lbolt64
argument_list|()
expr_stmt|;
name|zio
operator|->
name|io_deadline
operator|=
operator|(
name|zio
operator|->
name|io_timestamp
operator|>>
name|zfs_vdev_time_shift
operator|)
operator|+
name|zio
operator|->
name|io_priority
expr_stmt|;
name|vdev_queue_io_add
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|nio
operator|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|,
name|zfs_vdev_min_pending
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nio
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vdev_queue_io_done
parameter_list|(
name|zio_t
modifier|*
name|zio
parameter_list|)
block|{
name|vdev_queue_t
modifier|*
name|vq
init|=
operator|&
name|zio
operator|->
name|io_vd
operator|->
name|vdev_queue
decl_stmt|;
if|if
condition|(
name|zio_injection_enabled
condition|)
name|delay
argument_list|(
name|SEC_TO_TICK
argument_list|(
name|zio_handle_io_delay
argument_list|(
name|zio
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
name|vdev_queue_pending_remove
argument_list|(
name|vq
argument_list|,
name|zio
argument_list|)
expr_stmt|;
name|vq
operator|->
name|vq_io_complete_ts
operator|=
name|ddi_get_lbolt64
argument_list|()
expr_stmt|;
name|vq
operator|->
name|vq_io_delta_ts
operator|=
name|vq
operator|->
name|vq_io_complete_ts
operator|-
name|zio
operator|->
name|io_timestamp
expr_stmt|;
for|for
control|(
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|zfs_vdev_ramp_rate
condition|;
name|i
operator|++
control|)
block|{
name|zio_t
modifier|*
name|nio
init|=
name|vdev_queue_io_to_issue
argument_list|(
name|vq
argument_list|,
name|zfs_vdev_max_pending
argument_list|)
decl_stmt|;
if|if
condition|(
name|nio
operator|==
name|NULL
condition|)
break|break;
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|nio
operator|->
name|io_done
operator|==
name|vdev_queue_agg_io_done
condition|)
block|{
name|zio_nowait
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|zio_vdev_io_reissue
argument_list|(
name|nio
argument_list|)
expr_stmt|;
name|zio_execute
argument_list|(
name|nio
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vq
operator|->
name|vq_lock
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

