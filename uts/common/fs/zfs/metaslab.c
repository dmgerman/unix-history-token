begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2005, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2012 by Delphix. All rights reserved.  * Copyright (c) 2013 by Saso Kiselkov. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/zfs_context.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu.h>
end_include

begin_include
include|#
directive|include
file|<sys/dmu_tx.h>
end_include

begin_include
include|#
directive|include
file|<sys/space_map.h>
end_include

begin_include
include|#
directive|include
file|<sys/metaslab_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/vdev_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/zio.h>
end_include

begin_comment
comment|/*  * Allow allocations to switch to gang blocks quickly. We do this to  * avoid having to load lots of space_maps in a given txg. There are,  * however, some cases where we want to avoid "fast" ganging and instead  * we want to do an exhaustive search of all metaslabs on this device.  * Currently we don't allow any gang, zil, or dump device related allocations  * to "fast" gang.  */
end_comment

begin_define
define|#
directive|define
name|CAN_FASTGANG
parameter_list|(
name|flags
parameter_list|)
define|\
value|(!((flags)& (METASLAB_GANG_CHILD | METASLAB_GANG_HEADER | \ 	METASLAB_GANG_AVOID)))
end_define

begin_decl_stmt
name|uint64_t
name|metaslab_aliquot
init|=
literal|512ULL
operator|<<
literal|10
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|metaslab_gang_bang
init|=
name|SPA_MAXBLOCKSIZE
operator|+
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* force gang blocks */
end_comment

begin_comment
comment|/*  * This value defines the number of allowed allocation failures per vdev.  * If a device reaches this threshold in a given txg then we consider skipping  * allocations on that device.  */
end_comment

begin_decl_stmt
name|int
name|zfs_mg_alloc_failures
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Metaslab debugging: when set, keeps all space maps in core to verify frees.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|metaslab_debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Minimum size which forces the dynamic allocator to change  * it's allocation strategy.  Once the space map cannot satisfy  * an allocation of this size then it switches to using more  * aggressive strategy (i.e search by size rather than offset).  */
end_comment

begin_decl_stmt
name|uint64_t
name|metaslab_df_alloc_threshold
init|=
name|SPA_MAXBLOCKSIZE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The minimum free space, in percent, which must be available  * in a space map to continue allocations in a first-fit fashion.  * Once the space_map's free space drops below this level we dynamically  * switch to using best-fit allocations.  */
end_comment

begin_decl_stmt
name|int
name|metaslab_df_free_pct
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * A metaslab is considered "free" if it contains a contiguous  * segment which is greater than metaslab_min_alloc_size.  */
end_comment

begin_decl_stmt
name|uint64_t
name|metaslab_min_alloc_size
init|=
name|DMU_MAX_ACCESS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Max number of space_maps to prefetch.  */
end_comment

begin_decl_stmt
name|int
name|metaslab_prefetch_limit
init|=
name|SPA_DVAS_PER_BP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Percentage bonus multiplier for metaslabs that are in the bonus area.  */
end_comment

begin_decl_stmt
name|int
name|metaslab_smo_bonus_pct
init|=
literal|150
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Should we be willing to write data to degraded vdevs?  */
end_comment

begin_decl_stmt
name|boolean_t
name|zfs_write_to_degraded
init|=
name|B_FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * Metaslab classes  * ==========================================================================  */
end_comment

begin_function
name|metaslab_class_t
modifier|*
name|metaslab_class_create
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|space_map_ops_t
modifier|*
name|ops
parameter_list|)
block|{
name|metaslab_class_t
modifier|*
name|mc
decl_stmt|;
name|mc
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|metaslab_class_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mc
operator|->
name|mc_spa
operator|=
name|spa
expr_stmt|;
name|mc
operator|->
name|mc_rotor
operator|=
name|NULL
expr_stmt|;
name|mc
operator|->
name|mc_ops
operator|=
name|ops
expr_stmt|;
return|return
operator|(
name|mc
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_class_destroy
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mc
operator|->
name|mc_rotor
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mc
operator|->
name|mc_alloc
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mc
operator|->
name|mc_deferred
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mc
operator|->
name|mc_space
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mc
operator|->
name|mc_dspace
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mc
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_class_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|metaslab_class_validate
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
comment|/* 	 * Must hold one of the spa_config locks. 	 */
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|mc
operator|->
name|mc_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_READER
argument_list|)
operator|||
name|spa_config_held
argument_list|(
name|mc
operator|->
name|mc_spa
argument_list|,
name|SCL_ALL
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mg
operator|=
name|mc
operator|->
name|mc_rotor
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
do|do
block|{
name|vd
operator|=
name|mg
operator|->
name|mg_vd
expr_stmt|;
name|ASSERT
argument_list|(
name|vd
operator|->
name|vdev_mg
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|vd
operator|->
name|vdev_top
argument_list|,
operator|==
argument_list|,
name|vd
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|mg
operator|->
name|mg_class
argument_list|,
operator|==
argument_list|,
name|mc
argument_list|)
expr_stmt|;
name|ASSERT3P
argument_list|(
name|vd
operator|->
name|vdev_ops
argument_list|,
operator|!=
argument_list|,
operator|&
name|vdev_hole_ops
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|mg
operator|=
name|mg
operator|->
name|mg_next
operator|)
operator|!=
name|mc
operator|->
name|mc_rotor
condition|)
do|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_class_space_update
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|,
name|int64_t
name|alloc_delta
parameter_list|,
name|int64_t
name|defer_delta
parameter_list|,
name|int64_t
name|space_delta
parameter_list|,
name|int64_t
name|dspace_delta
parameter_list|)
block|{
name|atomic_add_64
argument_list|(
operator|&
name|mc
operator|->
name|mc_alloc
argument_list|,
name|alloc_delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|mc
operator|->
name|mc_deferred
argument_list|,
name|defer_delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|mc
operator|->
name|mc_space
argument_list|,
name|space_delta
argument_list|)
expr_stmt|;
name|atomic_add_64
argument_list|(
operator|&
name|mc
operator|->
name|mc_dspace
argument_list|,
name|dspace_delta
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|uint64_t
name|metaslab_class_get_alloc
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|)
block|{
return|return
operator|(
name|mc
operator|->
name|mc_alloc
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|metaslab_class_get_deferred
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|)
block|{
return|return
operator|(
name|mc
operator|->
name|mc_deferred
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|metaslab_class_get_space
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|)
block|{
return|return
operator|(
name|mc
operator|->
name|mc_space
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|metaslab_class_get_dspace
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|)
block|{
return|return
operator|(
name|spa_deflate
argument_list|(
name|mc
operator|->
name|mc_spa
argument_list|)
condition|?
name|mc
operator|->
name|mc_dspace
else|:
name|mc
operator|->
name|mc_space
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Metaslab groups  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|metaslab_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|metaslab_t
modifier|*
name|m1
init|=
name|x1
decl_stmt|;
specifier|const
name|metaslab_t
modifier|*
name|m2
init|=
name|x2
decl_stmt|;
if|if
condition|(
name|m1
operator|->
name|ms_weight
operator|<
name|m2
operator|->
name|ms_weight
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|m1
operator|->
name|ms_weight
operator|>
name|m2
operator|->
name|ms_weight
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* 	 * If the weights are identical, use the offset to force uniqueness. 	 */
if|if
condition|(
name|m1
operator|->
name|ms_map
operator|.
name|sm_start
operator|<
name|m2
operator|->
name|ms_map
operator|.
name|sm_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|m1
operator|->
name|ms_map
operator|.
name|sm_start
operator|>
name|m2
operator|->
name|ms_map
operator|.
name|sm_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
name|ASSERT3P
argument_list|(
name|m1
argument_list|,
operator|==
argument_list|,
name|m2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|metaslab_group_t
modifier|*
name|metaslab_group_create
parameter_list|(
name|metaslab_class_t
modifier|*
name|mc
parameter_list|,
name|vdev_t
modifier|*
name|vd
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|;
name|mg
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|metaslab_group_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|metaslab_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|metaslab
argument_list|,
name|ms_group_node
argument_list|)
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_vd
operator|=
name|vd
expr_stmt|;
name|mg
operator|->
name|mg_class
operator|=
name|mc
expr_stmt|;
name|mg
operator|->
name|mg_activation_count
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|mg
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_group_destroy
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * We may have gone below zero with the activation count 	 * either because we never activated in the first place or 	 * because we're done, and possibly removing the vdev. 	 */
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_activation_count
operator|<=
literal|0
argument_list|)
expr_stmt|;
name|avl_destroy
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|mg
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_group_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|metaslab_group_activate
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|metaslab_class_t
modifier|*
name|mc
init|=
name|mg
operator|->
name|mg_class
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mgprev
decl_stmt|,
modifier|*
name|mgnext
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|mc
operator|->
name|mc_spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mc
operator|->
name|mc_rotor
operator|!=
name|mg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_activation_count
operator|<=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|mg
operator|->
name|mg_activation_count
operator|<=
literal|0
condition|)
return|return;
name|mg
operator|->
name|mg_aliquot
operator|=
name|metaslab_aliquot
operator|*
name|MAX
argument_list|(
literal|1
argument_list|,
name|mg
operator|->
name|mg_vd
operator|->
name|vdev_children
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mgprev
operator|=
name|mc
operator|->
name|mc_rotor
operator|)
operator|==
name|NULL
condition|)
block|{
name|mg
operator|->
name|mg_prev
operator|=
name|mg
expr_stmt|;
name|mg
operator|->
name|mg_next
operator|=
name|mg
expr_stmt|;
block|}
else|else
block|{
name|mgnext
operator|=
name|mgprev
operator|->
name|mg_next
expr_stmt|;
name|mg
operator|->
name|mg_prev
operator|=
name|mgprev
expr_stmt|;
name|mg
operator|->
name|mg_next
operator|=
name|mgnext
expr_stmt|;
name|mgprev
operator|->
name|mg_next
operator|=
name|mg
expr_stmt|;
name|mgnext
operator|->
name|mg_prev
operator|=
name|mg
expr_stmt|;
block|}
name|mc
operator|->
name|mc_rotor
operator|=
name|mg
expr_stmt|;
block|}
end_function

begin_function
name|void
name|metaslab_group_passivate
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|metaslab_class_t
modifier|*
name|mc
init|=
name|mg
operator|->
name|mg_class
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mgprev
decl_stmt|,
modifier|*
name|mgnext
decl_stmt|;
name|ASSERT
argument_list|(
name|spa_config_held
argument_list|(
name|mc
operator|->
name|mc_spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|RW_WRITER
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|mg
operator|->
name|mg_activation_count
operator|!=
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|mc
operator|->
name|mc_rotor
operator|!=
name|mg
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_prev
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_next
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_activation_count
operator|<
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|mgprev
operator|=
name|mg
operator|->
name|mg_prev
expr_stmt|;
name|mgnext
operator|=
name|mg
operator|->
name|mg_next
expr_stmt|;
if|if
condition|(
name|mg
operator|==
name|mgnext
condition|)
block|{
name|mc
operator|->
name|mc_rotor
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|mc
operator|->
name|mc_rotor
operator|=
name|mgnext
expr_stmt|;
name|mgprev
operator|->
name|mg_next
operator|=
name|mgnext
expr_stmt|;
name|mgnext
operator|->
name|mg_prev
operator|=
name|mgprev
expr_stmt|;
block|}
name|mg
operator|->
name|mg_prev
operator|=
name|NULL
expr_stmt|;
name|mg
operator|->
name|mg_next
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_group_add
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_group
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_group
operator|=
name|mg
expr_stmt|;
name|msp
operator|->
name|ms_weight
operator|=
literal|0
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_group_remove
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_group
operator|==
name|mg
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_group
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_group_sort
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|weight
parameter_list|)
block|{
comment|/* 	 * Although in principle the weight can be any value, in 	 * practice we do not use values in the range [1, 510]. 	 */
name|ASSERT
argument_list|(
name|weight
operator|>=
name|SPA_MINBLOCKSIZE
operator|-
literal|1
operator|||
name|weight
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_group
operator|==
name|mg
argument_list|)
expr_stmt|;
name|avl_remove
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_weight
operator|=
name|weight
expr_stmt|;
name|avl_add
argument_list|(
operator|&
name|mg
operator|->
name|mg_metaslab_tree
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * Common allocator routines  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|int
name|metaslab_segsize_compare
parameter_list|(
specifier|const
name|void
modifier|*
name|x1
parameter_list|,
specifier|const
name|void
modifier|*
name|x2
parameter_list|)
block|{
specifier|const
name|space_seg_t
modifier|*
name|s1
init|=
name|x1
decl_stmt|;
specifier|const
name|space_seg_t
modifier|*
name|s2
init|=
name|x2
decl_stmt|;
name|uint64_t
name|ss_size1
init|=
name|s1
operator|->
name|ss_end
operator|-
name|s1
operator|->
name|ss_start
decl_stmt|;
name|uint64_t
name|ss_size2
init|=
name|s2
operator|->
name|ss_end
operator|-
name|s2
operator|->
name|ss_start
decl_stmt|;
if|if
condition|(
name|ss_size1
operator|<
name|ss_size2
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|ss_size1
operator|>
name|ss_size2
condition|)
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|s1
operator|->
name|ss_start
operator|<
name|s2
operator|->
name|ss_start
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|s1
operator|->
name|ss_start
operator|>
name|s2
operator|->
name|ss_start
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * This is a helper function that can be used by the allocator to find  * a suitable block to allocate. This will search the specified AVL  * tree looking for a block that matches the specified criteria.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|metaslab_block_picker
parameter_list|(
name|avl_tree_t
modifier|*
name|t
parameter_list|,
name|uint64_t
modifier|*
name|cursor
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|align
parameter_list|)
block|{
name|space_seg_t
modifier|*
name|ss
decl_stmt|,
name|ssearch
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|ssearch
operator|.
name|ss_start
operator|=
operator|*
name|cursor
expr_stmt|;
name|ssearch
operator|.
name|ss_end
operator|=
operator|*
name|cursor
operator|+
name|size
expr_stmt|;
name|ss
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|ssearch
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
name|ss
operator|=
name|avl_nearest
argument_list|(
name|t
argument_list|,
name|where
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
while|while
condition|(
name|ss
operator|!=
name|NULL
condition|)
block|{
name|uint64_t
name|offset
init|=
name|P2ROUNDUP
argument_list|(
name|ss
operator|->
name|ss_start
argument_list|,
name|align
argument_list|)
decl_stmt|;
if|if
condition|(
name|offset
operator|+
name|size
operator|<=
name|ss
operator|->
name|ss_end
condition|)
block|{
operator|*
name|cursor
operator|=
name|offset
operator|+
name|size
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
name|ss
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we know we've searched the whole map (*cursor == 0), give up. 	 * Otherwise, reset the cursor to the beginning and try again. 	 */
if|if
condition|(
operator|*
name|cursor
operator|==
literal|0
condition|)
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
operator|*
name|cursor
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|metaslab_block_picker
argument_list|(
name|t
argument_list|,
name|cursor
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_pp_load
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|space_seg_t
modifier|*
name|ss
decl_stmt|;
name|ASSERT
argument_list|(
name|sm
operator|->
name|sm_ppd
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_ppd
operator|=
name|kmem_zalloc
argument_list|(
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_pp_root
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|avl_create
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|,
name|metaslab_segsize_compare
argument_list|,
sizeof|sizeof
argument_list|(
name|space_seg_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|space_seg
argument_list|,
name|ss_pp_node
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ss
operator|=
name|avl_first
argument_list|(
operator|&
name|sm
operator|->
name|sm_root
argument_list|)
init|;
name|ss
condition|;
name|ss
operator|=
name|AVL_NEXT
argument_list|(
operator|&
name|sm
operator|->
name|sm_root
argument_list|,
name|ss
argument_list|)
control|)
name|avl_add
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|,
name|ss
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_pp_unload
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|void
modifier|*
name|cookie
init|=
name|NULL
decl_stmt|;
name|kmem_free
argument_list|(
name|sm
operator|->
name|sm_ppd
argument_list|,
literal|64
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_ppd
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|avl_destroy_nodes
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|,
operator|&
name|cookie
argument_list|)
operator|!=
name|NULL
condition|)
block|{
comment|/* tear down the tree */
block|}
name|avl_destroy
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|,
sizeof|sizeof
argument_list|(
name|avl_tree_t
argument_list|)
argument_list|)
expr_stmt|;
name|sm
operator|->
name|sm_pp_root
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|metaslab_pp_claim
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
comment|/* No need to update cursor */
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|metaslab_pp_free
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
comment|/* No need to update cursor */
block|}
end_function

begin_comment
comment|/*  * Return the maximum contiguous segment within the metaslab.  */
end_comment

begin_function
name|uint64_t
name|metaslab_pp_maxsize
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
name|sm
operator|->
name|sm_pp_root
decl_stmt|;
name|space_seg_t
modifier|*
name|ss
decl_stmt|;
if|if
condition|(
name|t
operator|==
name|NULL
operator|||
operator|(
name|ss
operator|=
name|avl_last
argument_list|(
name|t
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0ULL
operator|)
return|;
return|return
operator|(
name|ss
operator|->
name|ss_end
operator|-
name|ss
operator|->
name|ss_start
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ==========================================================================  * The first-fit block allocator  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|uint64_t
name|metaslab_ff_alloc
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|sm
operator|->
name|sm_root
decl_stmt|;
name|uint64_t
name|align
init|=
name|size
operator|&
operator|-
name|size
decl_stmt|;
name|uint64_t
modifier|*
name|cursor
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|sm
operator|->
name|sm_ppd
operator|+
name|highbit
argument_list|(
name|align
argument_list|)
operator|-
literal|1
decl_stmt|;
return|return
operator|(
name|metaslab_block_picker
argument_list|(
name|t
argument_list|,
name|cursor
argument_list|,
name|size
argument_list|,
name|align
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|boolean_t
name|metaslab_ff_fragmented
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|space_map_ops_t
name|metaslab_ff_ops
init|=
block|{
name|metaslab_pp_load
block|,
name|metaslab_pp_unload
block|,
name|metaslab_ff_alloc
block|,
name|metaslab_pp_claim
block|,
name|metaslab_pp_free
block|,
name|metaslab_pp_maxsize
block|,
name|metaslab_ff_fragmented
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * Dynamic block allocator -  * Uses the first fit allocation scheme until space get low and then  * adjusts to a best fit allocation method. Uses metaslab_df_alloc_threshold  * and metaslab_df_free_pct to determine when to switch the allocation scheme.  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|uint64_t
name|metaslab_df_alloc
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|sm
operator|->
name|sm_root
decl_stmt|;
name|uint64_t
name|align
init|=
name|size
operator|&
operator|-
name|size
decl_stmt|;
name|uint64_t
modifier|*
name|cursor
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|sm
operator|->
name|sm_ppd
operator|+
name|highbit
argument_list|(
name|align
argument_list|)
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|max_size
init|=
name|metaslab_pp_maxsize
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|int
name|free_pct
init|=
name|sm
operator|->
name|sm_space
operator|*
literal|100
operator|/
name|sm
operator|->
name|sm_size
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|sm
operator|->
name|sm_root
argument_list|)
argument_list|,
operator|==
argument_list|,
name|avl_numnodes
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_size
operator|<
name|size
condition|)
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
comment|/* 	 * If we're running low on space switch to using the size 	 * sorted AVL tree (best-fit). 	 */
if|if
condition|(
name|max_size
operator|<
name|metaslab_df_alloc_threshold
operator|||
name|free_pct
operator|<
name|metaslab_df_free_pct
condition|)
block|{
name|t
operator|=
name|sm
operator|->
name|sm_pp_root
expr_stmt|;
operator|*
name|cursor
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|metaslab_block_picker
argument_list|(
name|t
argument_list|,
name|cursor
argument_list|,
name|size
argument_list|,
literal|1ULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|metaslab_df_fragmented
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|uint64_t
name|max_size
init|=
name|metaslab_pp_maxsize
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|int
name|free_pct
init|=
name|sm
operator|->
name|sm_space
operator|*
literal|100
operator|/
name|sm
operator|->
name|sm_size
decl_stmt|;
if|if
condition|(
name|max_size
operator|>=
name|metaslab_df_alloc_threshold
operator|&&
name|free_pct
operator|>=
name|metaslab_df_free_pct
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|space_map_ops_t
name|metaslab_df_ops
init|=
block|{
name|metaslab_pp_load
block|,
name|metaslab_pp_unload
block|,
name|metaslab_df_alloc
block|,
name|metaslab_pp_claim
block|,
name|metaslab_pp_free
block|,
name|metaslab_pp_maxsize
block|,
name|metaslab_df_fragmented
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * Other experimental allocators  * ==========================================================================  */
end_comment

begin_function
specifier|static
name|uint64_t
name|metaslab_cdf_alloc
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|sm
operator|->
name|sm_root
decl_stmt|;
name|uint64_t
modifier|*
name|cursor
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|sm
operator|->
name|sm_ppd
decl_stmt|;
name|uint64_t
modifier|*
name|extent_end
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|sm
operator|->
name|sm_ppd
operator|+
literal|1
decl_stmt|;
name|uint64_t
name|max_size
init|=
name|metaslab_pp_maxsize
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|uint64_t
name|rsize
init|=
name|size
decl_stmt|;
name|uint64_t
name|offset
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|sm
operator|->
name|sm_root
argument_list|)
argument_list|,
operator|==
argument_list|,
name|avl_numnodes
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_size
operator|<
name|size
condition|)
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
name|ASSERT3U
argument_list|(
operator|*
name|extent_end
argument_list|,
operator|>=
argument_list|,
operator|*
name|cursor
argument_list|)
expr_stmt|;
comment|/* 	 * If we're running low on space switch to using the size 	 * sorted AVL tree (best-fit). 	 */
if|if
condition|(
operator|(
operator|*
name|cursor
operator|+
name|size
operator|)
operator|>
operator|*
name|extent_end
condition|)
block|{
name|t
operator|=
name|sm
operator|->
name|sm_pp_root
expr_stmt|;
operator|*
name|cursor
operator|=
operator|*
name|extent_end
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|max_size
operator|>
literal|2
operator|*
name|SPA_MAXBLOCKSIZE
condition|)
name|rsize
operator|=
name|MIN
argument_list|(
name|metaslab_min_alloc_size
argument_list|,
name|max_size
argument_list|)
expr_stmt|;
name|offset
operator|=
name|metaslab_block_picker
argument_list|(
name|t
argument_list|,
name|extent_end
argument_list|,
name|rsize
argument_list|,
literal|1ULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1
condition|)
operator|*
name|cursor
operator|=
name|offset
operator|+
name|size
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|metaslab_block_picker
argument_list|(
name|t
argument_list|,
name|cursor
argument_list|,
name|rsize
argument_list|,
literal|1ULL
argument_list|)
expr_stmt|;
block|}
name|ASSERT3U
argument_list|(
operator|*
name|cursor
argument_list|,
operator|<=
argument_list|,
operator|*
name|extent_end
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|metaslab_cdf_fragmented
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|uint64_t
name|max_size
init|=
name|metaslab_pp_maxsize
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|max_size
operator|>
operator|(
name|metaslab_min_alloc_size
operator|*
literal|10
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|space_map_ops_t
name|metaslab_cdf_ops
init|=
block|{
name|metaslab_pp_load
block|,
name|metaslab_pp_unload
block|,
name|metaslab_cdf_alloc
block|,
name|metaslab_pp_claim
block|,
name|metaslab_pp_free
block|,
name|metaslab_pp_maxsize
block|,
name|metaslab_cdf_fragmented
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|uint64_t
name|metaslab_ndf_clump_shift
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|uint64_t
name|metaslab_ndf_alloc
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|sm
operator|->
name|sm_root
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
name|space_seg_t
modifier|*
name|ss
decl_stmt|,
name|ssearch
decl_stmt|;
name|uint64_t
name|hbit
init|=
name|highbit
argument_list|(
name|size
argument_list|)
decl_stmt|;
name|uint64_t
modifier|*
name|cursor
init|=
operator|(
name|uint64_t
operator|*
operator|)
name|sm
operator|->
name|sm_ppd
operator|+
name|hbit
operator|-
literal|1
decl_stmt|;
name|uint64_t
name|max_size
init|=
name|metaslab_pp_maxsize
argument_list|(
name|sm
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
name|sm
operator|->
name|sm_lock
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|avl_numnodes
argument_list|(
operator|&
name|sm
operator|->
name|sm_root
argument_list|)
argument_list|,
operator|==
argument_list|,
name|avl_numnodes
argument_list|(
name|sm
operator|->
name|sm_pp_root
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|max_size
operator|<
name|size
condition|)
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
name|ssearch
operator|.
name|ss_start
operator|=
operator|*
name|cursor
expr_stmt|;
name|ssearch
operator|.
name|ss_end
operator|=
operator|*
name|cursor
operator|+
name|size
expr_stmt|;
name|ss
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|ssearch
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
operator|||
operator|(
name|ss
operator|->
name|ss_start
operator|+
name|size
operator|>
name|ss
operator|->
name|ss_end
operator|)
condition|)
block|{
name|t
operator|=
name|sm
operator|->
name|sm_pp_root
expr_stmt|;
name|ssearch
operator|.
name|ss_start
operator|=
literal|0
expr_stmt|;
name|ssearch
operator|.
name|ss_end
operator|=
name|MIN
argument_list|(
name|max_size
argument_list|,
literal|1ULL
operator|<<
operator|(
name|hbit
operator|+
name|metaslab_ndf_clump_shift
operator|)
argument_list|)
expr_stmt|;
name|ss
operator|=
name|avl_find
argument_list|(
name|t
argument_list|,
operator|&
name|ssearch
argument_list|,
operator|&
name|where
argument_list|)
expr_stmt|;
if|if
condition|(
name|ss
operator|==
name|NULL
condition|)
name|ss
operator|=
name|avl_nearest
argument_list|(
name|t
argument_list|,
name|where
argument_list|,
name|AVL_AFTER
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ss
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ss
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ss
operator|->
name|ss_start
operator|+
name|size
operator|<=
name|ss
operator|->
name|ss_end
condition|)
block|{
operator|*
name|cursor
operator|=
name|ss
operator|->
name|ss_start
operator|+
name|size
expr_stmt|;
return|return
operator|(
name|ss
operator|->
name|ss_start
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|boolean_t
name|metaslab_ndf_fragmented
parameter_list|(
name|space_map_t
modifier|*
name|sm
parameter_list|)
block|{
name|uint64_t
name|max_size
init|=
name|metaslab_pp_maxsize
argument_list|(
name|sm
argument_list|)
decl_stmt|;
if|if
condition|(
name|max_size
operator|>
operator|(
name|metaslab_min_alloc_size
operator|<<
name|metaslab_ndf_clump_shift
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|space_map_ops_t
name|metaslab_ndf_ops
init|=
block|{
name|metaslab_pp_load
block|,
name|metaslab_pp_unload
block|,
name|metaslab_ndf_alloc
block|,
name|metaslab_pp_claim
block|,
name|metaslab_pp_free
block|,
name|metaslab_pp_maxsize
block|,
name|metaslab_ndf_fragmented
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|space_map_ops_t
modifier|*
name|zfs_metaslab_ops
init|=
operator|&
name|metaslab_df_ops
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * ==========================================================================  * Metaslabs  * ==========================================================================  */
end_comment

begin_function
name|metaslab_t
modifier|*
name|metaslab_init
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|space_map_obj_t
modifier|*
name|smo
parameter_list|,
name|uint64_t
name|start
parameter_list|,
name|uint64_t
name|size
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|mg
operator|->
name|mg_vd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|msp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|metaslab_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msp
operator|->
name|ms_smo_syncing
operator|=
operator|*
name|smo
expr_stmt|;
comment|/* 	 * We create the main space map here, but we don't create the 	 * allocmaps and freemaps until metaslab_sync_done().  This serves 	 * two purposes: it allows metaslab_sync_done() to detect the 	 * addition of new space; and for debugging, it ensures that we'd 	 * data fault on any attempt to use this metaslab before it's ready. 	 */
name|space_map_create
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|start
argument_list|,
name|size
argument_list|,
name|vd
operator|->
name|vdev_ashift
argument_list|,
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|metaslab_group_add
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|)
expr_stmt|;
if|if
condition|(
name|metaslab_debug
operator|&&
name|smo
operator|->
name|smo_object
operator|!=
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|space_map_load
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|mg
operator|->
name|mg_class
operator|->
name|mc_ops
argument_list|,
name|SM_FREE
argument_list|,
name|smo
argument_list|,
name|spa_meta_objset
argument_list|(
name|vd
operator|->
name|vdev_spa
argument_list|)
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If we're opening an existing pool (txg == 0) or creating 	 * a new one (txg == TXG_INITIAL), all space is available now. 	 * If we're adding space to an existing pool, the new space 	 * does not become available until after this txg has synced. 	 */
if|if
condition|(
name|txg
operator|<=
name|TXG_INITIAL
condition|)
name|metaslab_sync_done
argument_list|(
name|msp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|!=
literal|0
condition|)
block|{
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|msp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_fini
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
init|=
name|msp
operator|->
name|ms_group
decl_stmt|;
name|vdev_space_update
argument_list|(
name|mg
operator|->
name|mg_vd
argument_list|,
operator|-
name|msp
operator|->
name|ms_smo
operator|.
name|smo_alloc
argument_list|,
literal|0
argument_list|,
operator|-
name|msp
operator|->
name|ms_map
operator|.
name|sm_size
argument_list|)
expr_stmt|;
name|metaslab_group_remove
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|space_map_unload
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|)
expr_stmt|;
name|space_map_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
name|space_map_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|space_map_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|t
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_DEFER_SIZE
condition|;
name|t
operator|++
control|)
name|space_map_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_defermap
index|[
name|t
index|]
argument_list|)
expr_stmt|;
name|ASSERT0
argument_list|(
name|msp
operator|->
name|ms_deferspace
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|msp
argument_list|,
sizeof|sizeof
argument_list|(
name|metaslab_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|METASLAB_WEIGHT_PRIMARY
value|(1ULL<< 63)
end_define

begin_define
define|#
directive|define
name|METASLAB_WEIGHT_SECONDARY
value|(1ULL<< 62)
end_define

begin_define
define|#
directive|define
name|METASLAB_ACTIVE_MASK
define|\
value|(METASLAB_WEIGHT_PRIMARY | METASLAB_WEIGHT_SECONDARY)
end_define

begin_function
specifier|static
name|uint64_t
name|metaslab_weight
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
init|=
name|msp
operator|->
name|ms_group
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|mg
operator|->
name|mg_vd
decl_stmt|;
name|uint64_t
name|weight
decl_stmt|,
name|space
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * The baseline weight is the metaslab's free space. 	 */
name|space
operator|=
name|sm
operator|->
name|sm_size
operator|-
name|smo
operator|->
name|smo_alloc
expr_stmt|;
name|weight
operator|=
name|space
expr_stmt|;
comment|/* 	 * Modern disks have uniform bit density and constant angular velocity. 	 * Therefore, the outer recording zones are faster (higher bandwidth) 	 * than the inner zones by the ratio of outer to inner track diameter, 	 * which is typically around 2:1.  We account for this by assigning 	 * higher weight to lower metaslabs (multiplier ranging from 2x to 1x). 	 * In effect, this means that we'll select the metaslab with the most 	 * free bandwidth rather than simply the one with the most free space. 	 */
name|weight
operator|=
literal|2
operator|*
name|weight
operator|-
operator|(
operator|(
name|sm
operator|->
name|sm_start
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
operator|*
name|weight
operator|)
operator|/
name|vd
operator|->
name|vdev_ms_count
expr_stmt|;
name|ASSERT
argument_list|(
name|weight
operator|>=
name|space
operator|&&
name|weight
operator|<=
literal|2
operator|*
name|space
argument_list|)
expr_stmt|;
comment|/* 	 * For locality, assign higher weight to metaslabs which have 	 * a lower offset than what we've already activated. 	 */
if|if
condition|(
name|sm
operator|->
name|sm_start
operator|<=
name|mg
operator|->
name|mg_bonus_area
condition|)
name|weight
operator|*=
operator|(
name|metaslab_smo_bonus_pct
operator|/
literal|100
operator|)
expr_stmt|;
name|ASSERT
argument_list|(
name|weight
operator|>=
name|space
operator|&&
name|weight
operator|<=
literal|2
operator|*
operator|(
name|metaslab_smo_bonus_pct
operator|/
literal|100
operator|)
operator|*
name|space
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|sm_loaded
operator|&&
operator|!
name|sm
operator|->
name|sm_ops
operator|->
name|smop_fragmented
argument_list|(
name|sm
argument_list|)
condition|)
block|{
comment|/* 		 * If this metaslab is one we're actively using, adjust its 		 * weight to make it preferable to any inactive metaslab so 		 * we'll polish it off. 		 */
name|weight
operator||=
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
expr_stmt|;
block|}
return|return
operator|(
name|weight
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_prefetch
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|mg
operator|->
name|mg_vd
operator|->
name|vdev_spa
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|mg
operator|->
name|mg_metaslab_tree
decl_stmt|;
name|int
name|m
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Prefetch the next potential metaslabs 	 */
for|for
control|(
name|msp
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
operator|,
name|m
operator|=
literal|0
init|;
name|msp
condition|;
name|msp
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|msp
argument_list|)
operator|,
name|m
operator|++
control|)
block|{
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo
decl_stmt|;
comment|/* If we have reached our prefetch limit then we're done */
if|if
condition|(
name|m
operator|>=
name|metaslab_prefetch_limit
condition|)
break|break;
if|if
condition|(
operator|!
name|sm
operator|->
name|sm_loaded
operator|&&
name|smo
operator|->
name|smo_object
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|dmu_prefetch
argument_list|(
name|spa_meta_objset
argument_list|(
name|spa
argument_list|)
argument_list|,
name|smo
operator|->
name|smo_object
argument_list|,
literal|0ULL
argument_list|,
name|smo
operator|->
name|smo_objsize
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|metaslab_activate
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|activation_weight
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
init|=
name|msp
operator|->
name|ms_group
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_ops_t
modifier|*
name|sm_ops
init|=
name|msp
operator|->
name|ms_group
operator|->
name|mg_class
operator|->
name|mc_ops
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|space_map_load_wait
argument_list|(
name|sm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sm
operator|->
name|sm_loaded
condition|)
block|{
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo
decl_stmt|;
name|int
name|error
init|=
name|space_map_load
argument_list|(
name|sm
argument_list|,
name|sm_ops
argument_list|,
name|SM_FREE
argument_list|,
name|smo
argument_list|,
name|spa_meta_objset
argument_list|(
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
operator|->
name|vdev_spa
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|metaslab_group_sort
argument_list|(
name|msp
operator|->
name|ms_group
argument_list|,
name|msp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_DEFER_SIZE
condition|;
name|t
operator|++
control|)
name|space_map_walk
argument_list|(
operator|&
name|msp
operator|->
name|ms_defermap
index|[
name|t
index|]
argument_list|,
name|space_map_claim
argument_list|,
name|sm
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * Track the bonus area as we activate new metaslabs. 		 */
if|if
condition|(
name|sm
operator|->
name|sm_start
operator|>
name|mg
operator|->
name|mg_bonus_area
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
name|mg
operator|->
name|mg_bonus_area
operator|=
name|sm
operator|->
name|sm_start
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
block|}
name|metaslab_group_sort
argument_list|(
name|msp
operator|->
name|ms_group
argument_list|,
name|msp
argument_list|,
name|msp
operator|->
name|ms_weight
operator||
name|activation_weight
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|sm
operator|->
name|sm_loaded
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|metaslab_passivate
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|size
parameter_list|)
block|{
comment|/* 	 * If size< SPA_MINBLOCKSIZE, then we will not allocate from 	 * this metaslab again.  In that case, it had better be empty, 	 * or we would be leaving space on the table. 	 */
name|ASSERT
argument_list|(
name|size
operator|>=
name|SPA_MINBLOCKSIZE
operator|||
name|msp
operator|->
name|ms_map
operator|.
name|sm_space
operator|==
literal|0
argument_list|)
expr_stmt|;
name|metaslab_group_sort
argument_list|(
name|msp
operator|->
name|ms_group
argument_list|,
name|msp
argument_list|,
name|MIN
argument_list|(
name|msp
operator|->
name|ms_weight
argument_list|,
name|size
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a metaslab to disk in the context of the specified transaction group.  */
end_comment

begin_function
name|void
name|metaslab_sync
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
decl_stmt|;
name|spa_t
modifier|*
name|spa
init|=
name|vd
operator|->
name|vdev_spa
decl_stmt|;
name|objset_t
modifier|*
name|mos
init|=
name|spa_meta_objset
argument_list|(
name|spa
argument_list|)
decl_stmt|;
name|space_map_t
modifier|*
name|allocmap
init|=
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|space_map_t
modifier|*
name|freemap
init|=
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|space_map_t
modifier|*
name|freed_map
init|=
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo_syncing
decl_stmt|;
name|dmu_buf_t
modifier|*
name|db
decl_stmt|;
name|dmu_tx_t
modifier|*
name|tx
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
if|if
condition|(
name|allocmap
operator|->
name|sm_space
operator|==
literal|0
operator|&&
name|freemap
operator|->
name|sm_space
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * The only state that can actually be changing concurrently with 	 * metaslab_sync() is the metaslab's ms_map.  No other thread can 	 * be modifying this txg's allocmap, freemap, freed_map, or smo. 	 * Therefore, we only hold ms_lock to satify space_map ASSERTs. 	 * We drop it whenever we call into the DMU, because the DMU 	 * can call down to us (e.g. via zio_free()) at any time. 	 */
name|tx
operator|=
name|dmu_tx_create_assigned
argument_list|(
name|spa_get_dsl
argument_list|(
name|spa
argument_list|)
argument_list|,
name|txg
argument_list|)
expr_stmt|;
if|if
condition|(
name|smo
operator|->
name|smo_object
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_objsize
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_alloc
operator|==
literal|0
argument_list|)
expr_stmt|;
name|smo
operator|->
name|smo_object
operator|=
name|dmu_object_alloc
argument_list|(
name|mos
argument_list|,
name|DMU_OT_SPACE_MAP
argument_list|,
literal|1
operator|<<
name|SPACE_MAP_BLOCKSHIFT
argument_list|,
name|DMU_OT_SPACE_MAP_HEADER
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|smo
operator|->
name|smo_object
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|dmu_write
argument_list|(
name|mos
argument_list|,
name|vd
operator|->
name|vdev_ms_array
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
operator|(
name|sm
operator|->
name|sm_start
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
operator|&
name|smo
operator|->
name|smo_object
argument_list|,
name|tx
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|space_map_walk
argument_list|(
name|freemap
argument_list|,
name|space_map_add
argument_list|,
name|freed_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|sm
operator|->
name|sm_loaded
operator|&&
name|spa_sync_pass
argument_list|(
name|spa
argument_list|)
operator|==
literal|1
operator|&&
name|smo
operator|->
name|smo_objsize
operator|>=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
operator|*
name|avl_numnodes
argument_list|(
operator|&
name|sm
operator|->
name|sm_root
argument_list|)
condition|)
block|{
comment|/* 		 * The in-core space map representation is twice as compact 		 * as the on-disk one, so it's time to condense the latter 		 * by generating a pure allocmap from first principles. 		 * 		 * This metaslab is 100% allocated, 		 * minus the content of the in-core map (sm), 		 * minus what's been freed this txg (freed_map), 		 * minus deferred frees (ms_defermap[]), 		 * minus allocations from txgs in the future 		 * (because they haven't been committed yet). 		 */
name|space_map_vacate
argument_list|(
name|allocmap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
name|freemap
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
name|allocmap
argument_list|,
name|allocmap
operator|->
name|sm_start
argument_list|,
name|allocmap
operator|->
name|sm_size
argument_list|)
expr_stmt|;
name|space_map_walk
argument_list|(
name|sm
argument_list|,
name|space_map_remove
argument_list|,
name|allocmap
argument_list|)
expr_stmt|;
name|space_map_walk
argument_list|(
name|freed_map
argument_list|,
name|space_map_remove
argument_list|,
name|allocmap
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_DEFER_SIZE
condition|;
name|t
operator|++
control|)
name|space_map_walk
argument_list|(
operator|&
name|msp
operator|->
name|ms_defermap
index|[
name|t
index|]
argument_list|,
name|space_map_remove
argument_list|,
name|allocmap
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|1
init|;
name|t
operator|<
name|TXG_CONCURRENT_STATES
condition|;
name|t
operator|++
control|)
name|space_map_walk
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
operator|(
name|txg
operator|+
name|t
operator|)
operator|&
name|TXG_MASK
index|]
argument_list|,
name|space_map_remove
argument_list|,
name|allocmap
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|space_map_truncate
argument_list|(
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
name|space_map_sync
argument_list|(
name|allocmap
argument_list|,
name|SM_ALLOC
argument_list|,
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|space_map_sync
argument_list|(
name|freemap
argument_list|,
name|SM_FREE
argument_list|,
name|smo
argument_list|,
name|mos
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
literal|0
operator|==
name|dmu_bonus_hold
argument_list|(
name|mos
argument_list|,
name|smo
operator|->
name|smo_object
argument_list|,
name|FTAG
argument_list|,
operator|&
name|db
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_will_dirty
argument_list|(
name|db
argument_list|,
name|tx
argument_list|)
expr_stmt|;
name|ASSERT3U
argument_list|(
name|db
operator|->
name|db_size
argument_list|,
operator|>=
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|smo
argument_list|,
name|db
operator|->
name|db_data
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|smo
argument_list|)
argument_list|)
expr_stmt|;
name|dmu_buf_rele
argument_list|(
name|db
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|dmu_tx_commit
argument_list|(
name|tx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called after a transaction group has completely synced to mark  * all of the metaslab's free space as usable.  */
end_comment

begin_function
name|void
name|metaslab_sync_done
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|space_map_obj_t
modifier|*
name|smo
init|=
operator|&
name|msp
operator|->
name|ms_smo
decl_stmt|;
name|space_map_obj_t
modifier|*
name|smosync
init|=
operator|&
name|msp
operator|->
name|ms_smo_syncing
decl_stmt|;
name|space_map_t
modifier|*
name|sm
init|=
operator|&
name|msp
operator|->
name|ms_map
decl_stmt|;
name|space_map_t
modifier|*
name|freed_map
init|=
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|TXG_CLEAN
argument_list|(
name|txg
argument_list|)
operator|&
name|TXG_MASK
index|]
decl_stmt|;
name|space_map_t
modifier|*
name|defer_map
init|=
operator|&
name|msp
operator|->
name|ms_defermap
index|[
name|txg
operator|%
name|TXG_DEFER_SIZE
index|]
decl_stmt|;
name|metaslab_group_t
modifier|*
name|mg
init|=
name|msp
operator|->
name|ms_group
decl_stmt|;
name|vdev_t
modifier|*
name|vd
init|=
name|mg
operator|->
name|mg_vd
decl_stmt|;
name|int64_t
name|alloc_delta
decl_stmt|,
name|defer_delta
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|vd
operator|->
name|vdev_ishole
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
comment|/* 	 * If this metaslab is just becoming available, initialize its 	 * allocmaps and freemaps and add its capacity to the vdev. 	 */
if|if
condition|(
name|freed_map
operator|->
name|sm_size
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_SIZE
condition|;
name|t
operator|++
control|)
block|{
name|space_map_create
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|t
index|]
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|,
name|sm
operator|->
name|sm_shift
argument_list|,
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
name|space_map_create
argument_list|(
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|t
index|]
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|,
name|sm
operator|->
name|sm_shift
argument_list|,
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|int
name|t
init|=
literal|0
init|;
name|t
operator|<
name|TXG_DEFER_SIZE
condition|;
name|t
operator|++
control|)
name|space_map_create
argument_list|(
operator|&
name|msp
operator|->
name|ms_defermap
index|[
name|t
index|]
argument_list|,
name|sm
operator|->
name|sm_start
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|,
name|sm
operator|->
name|sm_shift
argument_list|,
name|sm
operator|->
name|sm_lock
argument_list|)
expr_stmt|;
name|vdev_space_update
argument_list|(
name|vd
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|)
expr_stmt|;
block|}
name|alloc_delta
operator|=
name|smosync
operator|->
name|smo_alloc
operator|-
name|smo
operator|->
name|smo_alloc
expr_stmt|;
name|defer_delta
operator|=
name|freed_map
operator|->
name|sm_space
operator|-
name|defer_map
operator|->
name|sm_space
expr_stmt|;
name|vdev_space_update
argument_list|(
name|vd
argument_list|,
name|alloc_delta
operator|+
name|defer_delta
argument_list|,
name|defer_delta
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If there's a space_map_load() in progress, wait for it to complete 	 * so that we have a consistent view of the in-core space map. 	 * Then, add defer_map (oldest deferred frees) to this map and 	 * transfer freed_map (this txg's frees) to defer_map. 	 */
name|space_map_load_wait
argument_list|(
name|sm
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
name|defer_map
argument_list|,
name|sm
operator|->
name|sm_loaded
condition|?
name|space_map_free
else|:
name|NULL
argument_list|,
name|sm
argument_list|)
expr_stmt|;
name|space_map_vacate
argument_list|(
name|freed_map
argument_list|,
name|space_map_add
argument_list|,
name|defer_map
argument_list|)
expr_stmt|;
operator|*
name|smo
operator|=
operator|*
name|smosync
expr_stmt|;
name|msp
operator|->
name|ms_deferspace
operator|+=
name|defer_delta
expr_stmt|;
name|ASSERT3S
argument_list|(
name|msp
operator|->
name|ms_deferspace
argument_list|,
operator|>=
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ASSERT3S
argument_list|(
name|msp
operator|->
name|ms_deferspace
argument_list|,
operator|<=
argument_list|,
name|sm
operator|->
name|sm_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|msp
operator|->
name|ms_deferspace
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * Keep syncing this metaslab until all deferred frees 		 * are back in circulation. 		 */
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the map is loaded but no longer active, evict it as soon as all 	 * future allocations have synced.  (If we unloaded it now and then 	 * loaded a moment later, the map wouldn't reflect those allocations.) 	 */
if|if
condition|(
name|sm
operator|->
name|sm_loaded
operator|&&
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
operator|==
literal|0
condition|)
block|{
name|int
name|evictable
init|=
literal|1
decl_stmt|;
for|for
control|(
name|int
name|t
init|=
literal|1
init|;
name|t
operator|<
name|TXG_CONCURRENT_STATES
condition|;
name|t
operator|++
control|)
if|if
condition|(
name|msp
operator|->
name|ms_allocmap
index|[
operator|(
name|txg
operator|+
name|t
operator|)
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
condition|)
name|evictable
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|evictable
operator|&&
operator|!
name|metaslab_debug
condition|)
name|space_map_unload
argument_list|(
name|sm
argument_list|)
expr_stmt|;
block|}
name|metaslab_group_sort
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|,
name|metaslab_weight
argument_list|(
name|msp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|metaslab_sync_reassess
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|)
block|{
name|vdev_t
modifier|*
name|vd
init|=
name|mg
operator|->
name|mg_vd
decl_stmt|;
name|int64_t
name|failures
init|=
name|mg
operator|->
name|mg_alloc_failures
decl_stmt|;
comment|/* 	 * Re-evaluate all metaslabs which have lower offsets than the 	 * bonus area. 	 */
for|for
control|(
name|int
name|m
init|=
literal|0
init|;
name|m
operator|<
name|vd
operator|->
name|vdev_ms_count
condition|;
name|m
operator|++
control|)
block|{
name|metaslab_t
modifier|*
name|msp
init|=
name|vd
operator|->
name|vdev_ms
index|[
name|m
index|]
decl_stmt|;
if|if
condition|(
name|msp
operator|->
name|ms_map
operator|.
name|sm_start
operator|>
name|mg
operator|->
name|mg_bonus_area
condition|)
break|break;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
name|metaslab_group_sort
argument_list|(
name|mg
argument_list|,
name|msp
argument_list|,
name|metaslab_weight
argument_list|(
name|msp
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
name|atomic_add_64
argument_list|(
operator|&
name|mg
operator|->
name|mg_alloc_failures
argument_list|,
operator|-
name|failures
argument_list|)
expr_stmt|;
comment|/* 	 * Prefetch the next potential metaslabs 	 */
name|metaslab_prefetch
argument_list|(
name|mg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|metaslab_distance
parameter_list|(
name|metaslab_t
modifier|*
name|msp
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|)
block|{
name|uint64_t
name|ms_shift
init|=
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
operator|->
name|vdev_ms_shift
decl_stmt|;
name|uint64_t
name|offset
init|=
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
operator|>>
name|ms_shift
decl_stmt|;
name|uint64_t
name|start
init|=
name|msp
operator|->
name|ms_map
operator|.
name|sm_start
operator|>>
name|ms_shift
decl_stmt|;
if|if
condition|(
name|msp
operator|->
name|ms_group
operator|->
name|mg_vd
operator|->
name|vdev_id
operator|!=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
condition|)
return|return
operator|(
literal|1ULL
operator|<<
literal|63
operator|)
return|;
if|if
condition|(
name|offset
operator|<
name|start
condition|)
return|return
operator|(
operator|(
name|start
operator|-
name|offset
operator|)
operator|<<
name|ms_shift
operator|)
return|;
if|if
condition|(
name|offset
operator|>
name|start
condition|)
return|return
operator|(
operator|(
name|offset
operator|-
name|start
operator|)
operator|<<
name|ms_shift
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|metaslab_group_alloc
parameter_list|(
name|metaslab_group_t
modifier|*
name|mg
parameter_list|,
name|uint64_t
name|psize
parameter_list|,
name|uint64_t
name|asize
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|uint64_t
name|min_distance
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|spa_t
modifier|*
name|spa
init|=
name|mg
operator|->
name|mg_vd
operator|->
name|vdev_spa
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
init|=
name|NULL
decl_stmt|;
name|uint64_t
name|offset
init|=
operator|-
literal|1ULL
decl_stmt|;
name|avl_tree_t
modifier|*
name|t
init|=
operator|&
name|mg
operator|->
name|mg_metaslab_tree
decl_stmt|;
name|uint64_t
name|activation_weight
decl_stmt|;
name|uint64_t
name|target_distance
decl_stmt|;
name|int
name|i
decl_stmt|;
name|activation_weight
operator|=
name|METASLAB_WEIGHT_PRIMARY
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|i
index|]
argument_list|)
operator|==
name|mg
operator|->
name|mg_vd
operator|->
name|vdev_id
condition|)
block|{
name|activation_weight
operator|=
name|METASLAB_WEIGHT_SECONDARY
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|boolean_t
name|was_active
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|msp
operator|=
name|avl_first
argument_list|(
name|t
argument_list|)
init|;
name|msp
condition|;
name|msp
operator|=
name|AVL_NEXT
argument_list|(
name|t
argument_list|,
name|msp
argument_list|)
control|)
block|{
if|if
condition|(
name|msp
operator|->
name|ms_weight
operator|<
name|asize
condition|)
block|{
name|spa_dbgmsg
argument_list|(
name|spa
argument_list|,
literal|"%s: failed to meet weight "
literal|"requirement: vdev %llu, txg %llu, mg %p, "
literal|"msp %p, psize %llu, asize %llu, "
literal|"failures %llu, weight %llu"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|mg
operator|->
name|mg_vd
operator|->
name|vdev_id
argument_list|,
name|txg
argument_list|,
name|mg
argument_list|,
name|msp
argument_list|,
name|psize
argument_list|,
name|asize
argument_list|,
name|mg
operator|->
name|mg_alloc_failures
argument_list|,
name|msp
operator|->
name|ms_weight
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
block|}
name|was_active
operator|=
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
expr_stmt|;
if|if
condition|(
name|activation_weight
operator|==
name|METASLAB_WEIGHT_PRIMARY
condition|)
break|break;
name|target_distance
operator|=
name|min_distance
operator|+
operator|(
name|msp
operator|->
name|ms_smo
operator|.
name|smo_alloc
condition|?
literal|0
else|:
name|min_distance
operator|>>
literal|1
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|d
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|metaslab_distance
argument_list|(
name|msp
argument_list|,
operator|&
name|dva
index|[
name|i
index|]
argument_list|)
operator|<
name|target_distance
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|d
condition|)
break|break;
block|}
name|mutex_exit
argument_list|(
operator|&
name|mg
operator|->
name|mg_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|msp
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
comment|/* 		 * If we've already reached the allowable number of failed 		 * allocation attempts on this metaslab group then we 		 * consider skipping it. We skip it only if we're allowed 		 * to "fast" gang, the physical size is larger than 		 * a gang block, and we're attempting to allocate from 		 * the primary metaslab. 		 */
if|if
condition|(
name|mg
operator|->
name|mg_alloc_failures
operator|>
name|zfs_mg_alloc_failures
operator|&&
name|CAN_FASTGANG
argument_list|(
name|flags
argument_list|)
operator|&&
name|psize
operator|>
name|SPA_GANGBLOCKSIZE
operator|&&
name|activation_weight
operator|==
name|METASLAB_WEIGHT_PRIMARY
condition|)
block|{
name|spa_dbgmsg
argument_list|(
name|spa
argument_list|,
literal|"%s: skipping metaslab group: "
literal|"vdev %llu, txg %llu, mg %p, psize %llu, "
literal|"asize %llu, failures %llu"
argument_list|,
name|spa_name
argument_list|(
name|spa
argument_list|)
argument_list|,
name|mg
operator|->
name|mg_vd
operator|->
name|vdev_id
argument_list|,
name|txg
argument_list|,
name|mg
argument_list|,
name|psize
argument_list|,
name|asize
argument_list|,
name|mg
operator|->
name|mg_alloc_failures
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1ULL
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Ensure that the metaslab we have selected is still 		 * capable of handling our request. It's possible that 		 * another thread may have changed the weight while we 		 * were blocked on the metaslab lock. 		 */
if|if
condition|(
name|msp
operator|->
name|ms_weight
operator|<
name|asize
operator|||
operator|(
name|was_active
operator|&&
operator|!
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_ACTIVE_MASK
operator|)
operator|&&
name|activation_weight
operator|==
name|METASLAB_WEIGHT_PRIMARY
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|msp
operator|->
name|ms_weight
operator|&
name|METASLAB_WEIGHT_SECONDARY
operator|)
operator|&&
name|activation_weight
operator|==
name|METASLAB_WEIGHT_PRIMARY
condition|)
block|{
name|metaslab_passivate
argument_list|(
name|msp
argument_list|,
name|msp
operator|->
name|ms_weight
operator|&
operator|~
name|METASLAB_ACTIVE_MASK
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|metaslab_activate
argument_list|(
name|msp
argument_list|,
name|activation_weight
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|offset
operator|=
name|space_map_alloc
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|asize
argument_list|)
operator|)
operator|!=
operator|-
literal|1ULL
condition|)
break|break;
name|atomic_inc_64
argument_list|(
operator|&
name|mg
operator|->
name|mg_alloc_failures
argument_list|)
expr_stmt|;
name|metaslab_passivate
argument_list|(
name|msp
argument_list|,
name|space_map_maxsize
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|mg
operator|->
name|mg_vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|asize
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|offset
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Allocate a block for the specified i/o.  */
end_comment

begin_function
specifier|static
name|int
name|metaslab_alloc_dva
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|metaslab_class_t
modifier|*
name|mc
parameter_list|,
name|uint64_t
name|psize
parameter_list|,
name|dva_t
modifier|*
name|dva
parameter_list|,
name|int
name|d
parameter_list|,
name|dva_t
modifier|*
name|hintdva
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|metaslab_group_t
modifier|*
name|mg
decl_stmt|,
modifier|*
name|rotor
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|int
name|dshift
init|=
literal|3
decl_stmt|;
name|int
name|all_zero
decl_stmt|;
name|int
name|zio_lock
init|=
name|B_FALSE
decl_stmt|;
name|boolean_t
name|allocatable
decl_stmt|;
name|uint64_t
name|offset
init|=
operator|-
literal|1ULL
decl_stmt|;
name|uint64_t
name|asize
decl_stmt|;
name|uint64_t
name|distance
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|DVA_IS_VALID
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * For testing, make some blocks above a certain size be gang blocks. 	 */
if|if
condition|(
name|psize
operator|>=
name|metaslab_gang_bang
operator|&&
operator|(
name|ddi_get_lbolt
argument_list|()
operator|&
literal|3
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOSPC
operator|)
return|;
comment|/* 	 * Start at the rotor and loop through all mgs until we find something. 	 * Note that there's no locking on mc_rotor or mc_aliquot because 	 * nothing actually breaks if we miss a few updates -- we just won't 	 * allocate quite as evenly.  It all balances out over time. 	 * 	 * If we are doing ditto or log blocks, try to spread them across 	 * consecutive vdevs.  If we're forced to reuse a vdev before we've 	 * allocated all of our ditto blocks, then try and spread them out on 	 * that vdev as much as possible.  If it turns out to not be possible, 	 * gradually lower our standards until anything becomes acceptable. 	 * Also, allocating on consecutive vdevs (as opposed to random vdevs) 	 * gives us hope of containing our fault domains to something we're 	 * able to reason about.  Otherwise, any two top-level vdev failures 	 * will guarantee the loss of data.  With consecutive allocation, 	 * only two adjacent top-level vdev failures will result in data loss. 	 * 	 * If we are doing gang blocks (hintdva is non-NULL), try to keep 	 * ourselves on the same vdev as our gang block header.  That 	 * way, we can hope for locality in vdev_cache, plus it makes our 	 * fault domains something tractable. 	 */
if|if
condition|(
name|hintdva
condition|)
block|{
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|hintdva
index|[
name|d
index|]
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 		 * It's possible the vdev we're using as the hint no 		 * longer exists (i.e. removed). Consult the rotor when 		 * all else fails. 		 */
if|if
condition|(
name|vd
operator|!=
name|NULL
condition|)
block|{
name|mg
operator|=
name|vd
operator|->
name|vdev_mg
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|METASLAB_HINTBP_AVOID
operator|&&
name|mg
operator|->
name|mg_next
operator|!=
name|NULL
condition|)
name|mg
operator|=
name|mg
operator|->
name|mg_next
expr_stmt|;
block|}
else|else
block|{
name|mg
operator|=
name|mc
operator|->
name|mc_rotor
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|d
operator|!=
literal|0
condition|)
block|{
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|DVA_GET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|d
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mg
operator|=
name|vd
operator|->
name|vdev_mg
operator|->
name|mg_next
expr_stmt|;
block|}
else|else
block|{
name|mg
operator|=
name|mc
operator|->
name|mc_rotor
expr_stmt|;
block|}
comment|/* 	 * If the hint put us into the wrong metaslab class, or into a 	 * metaslab group that has been passivated, just follow the rotor. 	 */
if|if
condition|(
name|mg
operator|->
name|mg_class
operator|!=
name|mc
operator|||
name|mg
operator|->
name|mg_activation_count
operator|<=
literal|0
condition|)
name|mg
operator|=
name|mc
operator|->
name|mc_rotor
expr_stmt|;
name|rotor
operator|=
name|mg
expr_stmt|;
name|top
label|:
name|all_zero
operator|=
name|B_TRUE
expr_stmt|;
do|do
block|{
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_activation_count
operator|==
literal|1
argument_list|)
expr_stmt|;
name|vd
operator|=
name|mg
operator|->
name|mg_vd
expr_stmt|;
comment|/* 		 * Don't allocate from faulted devices. 		 */
if|if
condition|(
name|zio_lock
condition|)
block|{
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ZIO
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|allocatable
operator|=
name|vdev_allocatable
argument_list|(
name|vd
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ZIO
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|allocatable
operator|=
name|vdev_allocatable
argument_list|(
name|vd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|allocatable
condition|)
goto|goto
name|next
goto|;
comment|/* 		 * Avoid writing single-copy data to a failing vdev 		 * unless the user instructs us that it is okay. 		 */
if|if
condition|(
operator|(
name|vd
operator|->
name|vdev_stat
operator|.
name|vs_write_errors
operator|>
literal|0
operator|||
name|vd
operator|->
name|vdev_state
operator|<
name|VDEV_STATE_HEALTHY
operator|)
operator|&&
name|d
operator|==
literal|0
operator|&&
name|dshift
operator|==
literal|3
operator|&&
operator|!
operator|(
name|zfs_write_to_degraded
operator|&&
name|vd
operator|->
name|vdev_state
operator|==
name|VDEV_STATE_DEGRADED
operator|)
condition|)
block|{
name|all_zero
operator|=
name|B_FALSE
expr_stmt|;
goto|goto
name|next
goto|;
block|}
name|ASSERT
argument_list|(
name|mg
operator|->
name|mg_class
operator|==
name|mc
argument_list|)
expr_stmt|;
name|distance
operator|=
name|vd
operator|->
name|vdev_asize
operator|>>
name|dshift
expr_stmt|;
if|if
condition|(
name|distance
operator|<=
operator|(
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_ms_shift
operator|)
condition|)
name|distance
operator|=
literal|0
expr_stmt|;
else|else
name|all_zero
operator|=
name|B_FALSE
expr_stmt|;
name|asize
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|psize
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|P2PHASE
argument_list|(
name|asize
argument_list|,
literal|1ULL
operator|<<
name|vd
operator|->
name|vdev_ashift
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|offset
operator|=
name|metaslab_group_alloc
argument_list|(
name|mg
argument_list|,
name|psize
argument_list|,
name|asize
argument_list|,
name|txg
argument_list|,
name|distance
argument_list|,
name|dva
argument_list|,
name|d
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
operator|-
literal|1ULL
condition|)
block|{
comment|/* 			 * If we've just selected this metaslab group, 			 * figure out whether the corresponding vdev is 			 * over- or under-used relative to the pool, 			 * and set an allocation bias to even it out. 			 */
if|if
condition|(
name|mc
operator|->
name|mc_aliquot
operator|==
literal|0
condition|)
block|{
name|vdev_stat_t
modifier|*
name|vs
init|=
operator|&
name|vd
operator|->
name|vdev_stat
decl_stmt|;
name|int64_t
name|vu
decl_stmt|,
name|cu
decl_stmt|;
name|vu
operator|=
operator|(
name|vs
operator|->
name|vs_alloc
operator|*
literal|100
operator|)
operator|/
operator|(
name|vs
operator|->
name|vs_space
operator|+
literal|1
operator|)
expr_stmt|;
name|cu
operator|=
operator|(
name|mc
operator|->
name|mc_alloc
operator|*
literal|100
operator|)
operator|/
operator|(
name|mc
operator|->
name|mc_space
operator|+
literal|1
operator|)
expr_stmt|;
comment|/* 				 * Calculate how much more or less we should 				 * try to allocate from this device during 				 * this iteration around the rotor. 				 * For example, if a device is 80% full 				 * and the pool is 20% full then we should 				 * reduce allocations by 60% on this device. 				 * 				 * mg_bias = (20 - 80) * 512K / 100 = -307K 				 * 				 * This reduces allocations by 307K for this 				 * iteration. 				 */
name|mg
operator|->
name|mg_bias
operator|=
operator|(
operator|(
name|cu
operator|-
name|vu
operator|)
operator|*
operator|(
name|int64_t
operator|)
name|mg
operator|->
name|mg_aliquot
operator|)
operator|/
literal|100
expr_stmt|;
block|}
if|if
condition|(
name|atomic_add_64_nv
argument_list|(
operator|&
name|mc
operator|->
name|mc_aliquot
argument_list|,
name|asize
argument_list|)
operator|>=
name|mg
operator|->
name|mg_aliquot
operator|+
name|mg
operator|->
name|mg_bias
condition|)
block|{
name|mc
operator|->
name|mc_rotor
operator|=
name|mg
operator|->
name|mg_next
expr_stmt|;
name|mc
operator|->
name|mc_aliquot
operator|=
literal|0
expr_stmt|;
block|}
name|DVA_SET_VDEV
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|vd
operator|->
name|vdev_id
argument_list|)
expr_stmt|;
name|DVA_SET_OFFSET
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|DVA_SET_GANG
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
operator|!
operator|!
operator|(
name|flags
operator|&
name|METASLAB_GANG_HEADER
operator|)
argument_list|)
expr_stmt|;
name|DVA_SET_ASIZE
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|asize
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|next
label|:
name|mc
operator|->
name|mc_rotor
operator|=
name|mg
operator|->
name|mg_next
expr_stmt|;
name|mc
operator|->
name|mc_aliquot
operator|=
literal|0
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|mg
operator|=
name|mg
operator|->
name|mg_next
operator|)
operator|!=
name|rotor
condition|)
do|;
if|if
condition|(
operator|!
name|all_zero
condition|)
block|{
name|dshift
operator|++
expr_stmt|;
name|ASSERT
argument_list|(
name|dshift
operator|<
literal|64
argument_list|)
expr_stmt|;
goto|goto
name|top
goto|;
block|}
if|if
condition|(
operator|!
name|allocatable
operator|&&
operator|!
name|zio_lock
condition|)
block|{
name|dshift
operator|=
literal|3
expr_stmt|;
name|zio_lock
operator|=
name|B_TRUE
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|bzero
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the block represented by DVA in the context of the specified  * transaction group.  */
end_comment

begin_function
specifier|static
name|void
name|metaslab_free_dva
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|boolean_t
name|now
parameter_list|)
block|{
name|uint64_t
name|vdev
init|=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|offset
init|=
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|size
init|=
name|DVA_GET_ASIZE
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|ASSERT
argument_list|(
name|DVA_IS_VALID
argument_list|(
name|dva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|>
name|spa_freeze_txg
argument_list|(
name|spa
argument_list|)
condition|)
return|return;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|vdev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
operator|>=
name|vd
operator|->
name|vdev_ms_count
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"metaslab_free_dva(): bad DVA %llu:%llu"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|vdev
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
name|msp
operator|=
name|vd
operator|->
name|vdev_ms
index|[
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
index|]
expr_stmt|;
if|if
condition|(
name|DVA_GET_GANG
argument_list|(
name|dva
argument_list|)
condition|)
name|size
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|now
condition|)
block|{
name|space_map_remove
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|space_map_free
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
operator|&
name|msp
operator|->
name|ms_freemap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Intent log support: upon opening the pool after a crash, notify the SPA  * of blocks that the intent log has allocated for immediate write, but  * which are still considered free by the SPA because the last transaction  * group didn't commit yet.  */
end_comment

begin_function
specifier|static
name|int
name|metaslab_claim_dva
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|dva_t
modifier|*
name|dva
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
name|uint64_t
name|vdev
init|=
name|DVA_GET_VDEV
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|offset
init|=
name|DVA_GET_OFFSET
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|uint64_t
name|size
init|=
name|DVA_GET_ASIZE
argument_list|(
name|dva
argument_list|)
decl_stmt|;
name|vdev_t
modifier|*
name|vd
decl_stmt|;
name|metaslab_t
modifier|*
name|msp
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|DVA_IS_VALID
argument_list|(
name|dva
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vd
operator|=
name|vdev_lookup_top
argument_list|(
name|spa
argument_list|,
name|vdev
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
operator|)
operator|>=
name|vd
operator|->
name|vdev_ms_count
condition|)
return|return
operator|(
name|ENXIO
operator|)
return|;
name|msp
operator|=
name|vd
operator|->
name|vdev_ms
index|[
name|offset
operator|>>
name|vd
operator|->
name|vdev_ms_shift
index|]
expr_stmt|;
if|if
condition|(
name|DVA_GET_GANG
argument_list|(
name|dva
argument_list|)
condition|)
name|size
operator|=
name|vdev_psize_to_asize
argument_list|(
name|vd
argument_list|,
name|SPA_GANGBLOCKSIZE
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|txg
operator|!=
literal|0
operator|&&
name|spa_writeable
argument_list|(
name|spa
argument_list|)
operator|)
operator|||
operator|!
name|msp
operator|->
name|ms_map
operator|.
name|sm_loaded
condition|)
name|error
operator|=
name|metaslab_activate
argument_list|(
name|msp
argument_list|,
name|METASLAB_WEIGHT_SECONDARY
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
operator|&&
operator|!
name|space_map_contains
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
condition|)
name|error
operator|=
name|ENOENT
expr_stmt|;
if|if
condition|(
name|error
operator|||
name|txg
operator|==
literal|0
condition|)
block|{
comment|/* txg == 0 indicates dry run */
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
name|space_map_claim
argument_list|(
operator|&
name|msp
operator|->
name|ms_map
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|spa_writeable
argument_list|(
name|spa
argument_list|)
condition|)
block|{
comment|/* don't dirty if we're zdb(1M) */
if|if
condition|(
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
operator|.
name|sm_space
operator|==
literal|0
condition|)
name|vdev_dirty
argument_list|(
name|vd
argument_list|,
name|VDD_METASLAB
argument_list|,
name|msp
argument_list|,
name|txg
argument_list|)
expr_stmt|;
name|space_map_add
argument_list|(
operator|&
name|msp
operator|->
name|ms_allocmap
index|[
name|txg
operator|&
name|TXG_MASK
index|]
argument_list|,
name|offset
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|msp
operator|->
name|ms_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|metaslab_alloc
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
name|metaslab_class_t
modifier|*
name|mc
parameter_list|,
name|uint64_t
name|psize
parameter_list|,
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|int
name|ndvas
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|blkptr_t
modifier|*
name|hintbp
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|dva_t
modifier|*
name|dva
init|=
name|bp
operator|->
name|blk_dva
decl_stmt|;
name|dva_t
modifier|*
name|hintdva
init|=
name|hintbp
operator|->
name|blk_dva
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|bp
operator|->
name|blk_birth
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_PHYSICAL_BIRTH
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|mc
operator|->
name|mc_rotor
operator|==
name|NULL
condition|)
block|{
comment|/* no vdevs in this class */
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOSPC
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|ndvas
operator|>
literal|0
operator|&&
name|ndvas
operator|<=
name|spa_max_replication
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|hintbp
operator|==
name|NULL
operator|||
name|ndvas
operator|<=
name|BP_GET_NDVAS
argument_list|(
name|hintbp
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|ndvas
condition|;
name|d
operator|++
control|)
block|{
name|error
operator|=
name|metaslab_alloc_dva
argument_list|(
name|spa
argument_list|,
name|mc
argument_list|,
name|psize
argument_list|,
name|dva
argument_list|,
name|d
argument_list|,
name|hintdva
argument_list|,
name|txg
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
for|for
control|(
name|d
operator|--
init|;
name|d
operator|>=
literal|0
condition|;
name|d
operator|--
control|)
block|{
name|metaslab_free_dva
argument_list|(
name|spa
argument_list|,
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|txg
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|dva_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
block|}
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
operator|==
name|ndvas
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|BP_SET_BIRTH
argument_list|(
name|bp
argument_list|,
name|txg
argument_list|,
name|txg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|void
name|metaslab_free
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|,
name|boolean_t
name|now
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva
init|=
name|bp
operator|->
name|blk_dva
decl_stmt|;
name|int
name|ndvas
init|=
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|now
operator|||
name|bp
operator|->
name|blk_birth
operator|>=
name|spa_syncing_txg
argument_list|(
name|spa
argument_list|)
argument_list|)
expr_stmt|;
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_FREE
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|ndvas
condition|;
name|d
operator|++
control|)
name|metaslab_free_dva
argument_list|(
name|spa
argument_list|,
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|txg
argument_list|,
name|now
argument_list|)
expr_stmt|;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_FREE
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|metaslab_claim
parameter_list|(
name|spa_t
modifier|*
name|spa
parameter_list|,
specifier|const
name|blkptr_t
modifier|*
name|bp
parameter_list|,
name|uint64_t
name|txg
parameter_list|)
block|{
specifier|const
name|dva_t
modifier|*
name|dva
init|=
name|bp
operator|->
name|blk_dva
decl_stmt|;
name|int
name|ndvas
init|=
name|BP_GET_NDVAS
argument_list|(
name|bp
argument_list|)
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
operator|!
name|BP_IS_HOLE
argument_list|(
name|bp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|txg
operator|!=
literal|0
condition|)
block|{
comment|/* 		 * First do a dry run to make sure all DVAs are claimable, 		 * so we don't have to unwind from partial failures below. 		 */
if|if
condition|(
operator|(
name|error
operator|=
name|metaslab_claim
argument_list|(
name|spa
argument_list|,
name|bp
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
name|spa_config_enter
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
for|for
control|(
name|int
name|d
init|=
literal|0
init|;
name|d
operator|<
name|ndvas
condition|;
name|d
operator|++
control|)
if|if
condition|(
operator|(
name|error
operator|=
name|metaslab_claim_dva
argument_list|(
name|spa
argument_list|,
operator|&
name|dva
index|[
name|d
index|]
argument_list|,
name|txg
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
name|spa_config_exit
argument_list|(
name|spa
argument_list|,
name|SCL_ALLOC
argument_list|,
name|FTAG
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|error
operator|==
literal|0
operator|||
name|txg
operator|==
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

end_unit

