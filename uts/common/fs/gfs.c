begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/* Portions Copyright 2007 Shivakumar GN */
end_comment

begin_comment
comment|/*  * Copyright 2008 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2017 by Delphix. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/dirent.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/mutex.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmsystm.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<vm/as.h>
end_include

begin_include
include|#
directive|include
file|<vm/seg_vn.h>
end_include

begin_include
include|#
directive|include
file|<sys/gfs.h>
end_include

begin_comment
comment|/*  * Generic pseudo-filesystem routines.  *  * There are significant similarities between the implementation of certain file  * system entry points across different filesystems.  While one could attempt to  * "choke up on the bat" and incorporate common functionality into a VOP  * preamble or postamble, such an approach is limited in the benefit it can  * provide.  In this file we instead define a toolkit of routines which can be  * called from a filesystem (with in-kernel pseudo-filesystems being the focus  * of the exercise) in a more component-like fashion.  *  * There are three basic classes of routines:  *  * 1) Lowlevel support routines  *  *    These routines are designed to play a support role for existing  *    pseudo-filesystems (such as procfs).  They simplify common tasks,  *    without forcing the filesystem to hand over management to GFS.  The  *    routines covered are:  *  *	gfs_readdir_init()  *	gfs_readdir_emit()  *	gfs_readdir_emitn()  *	gfs_readdir_pred()  *	gfs_readdir_fini()  *	gfs_lookup_dot()  *  * 2) Complete GFS management  *  *    These routines take a more active role in management of the  *    pseudo-filesystem.  They handle the relationship between vnode private  *    data and VFS data, as well as the relationship between vnodes in the  *    directory hierarchy.  *  *    In order to use these interfaces, the first member of every private  *    v_data must be a gfs_file_t or a gfs_dir_t.  This hands over all control  *    to GFS.  *  * 	gfs_file_create()  * 	gfs_dir_create()  * 	gfs_root_create()  *  *	gfs_file_inactive()  *	gfs_dir_inactive()  *	gfs_dir_lookup()  *	gfs_dir_readdir()  *  * 	gfs_vop_inactive()  * 	gfs_vop_lookup()  * 	gfs_vop_readdir()  * 	gfs_vop_map()  *  * 3) Single File pseudo-filesystems  *  *    This routine creates a rooted file to be overlayed ontop of another  *    file in the physical filespace.  *  *    Note that the parent is NULL (actually the vfs), but there is nothing  *    technically keeping such a file from utilizing the "Complete GFS  *    management" set of routines.  *  * 	gfs_root_create_file()  */
end_comment

begin_comment
comment|/*  * gfs_make_opsvec: take an array of vnode type definitions and create  * their vnodeops_t structures  *  * This routine takes an array of gfs_opsvec_t's.  It could  * alternatively take an array of gfs_opsvec_t*'s, which would allow  * vnode types to be completely defined in files external to the caller  * of gfs_make_opsvec().  As it stands, much more sharing takes place --  * both the caller and the vnode type provider need to access gfsv_ops  * and gfsv_template, and the caller also needs to know gfsv_name.  */
end_comment

begin_function
name|int
name|gfs_make_opsvec
parameter_list|(
name|gfs_opsvec_t
modifier|*
name|vec
parameter_list|)
block|{
name|int
name|error
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vec
index|[
name|i
index|]
operator|.
name|gfsv_name
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|error
operator|=
name|vn_make_ops
argument_list|(
name|vec
index|[
name|i
index|]
operator|.
name|gfsv_name
argument_list|,
name|vec
index|[
name|i
index|]
operator|.
name|gfsv_template
argument_list|,
name|vec
index|[
name|i
index|]
operator|.
name|gfsv_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
block|}
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"gfs_make_opsvec: bad vnode ops template for '%s'"
argument_list|,
name|vec
index|[
name|i
index|]
operator|.
name|gfsv_name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|--
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|vn_freevnodeops
argument_list|(
operator|*
name|vec
index|[
name|i
index|]
operator|.
name|gfsv_ops
argument_list|)
expr_stmt|;
operator|*
name|vec
index|[
name|i
index|]
operator|.
name|gfsv_ops
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Low level directory routines  *  * These routines provide some simple abstractions for reading directories.  * They are designed to be used by existing pseudo filesystems (namely procfs)  * that already have a complicated management infrastructure.  */
end_comment

begin_comment
comment|/*  * gfs_get_parent_ino: used to obtain a parent inode number and the  * inode number of the given vnode in preparation for calling gfs_readdir_init.  */
end_comment

begin_function
name|int
name|gfs_get_parent_ino
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|ino64_t
modifier|*
name|pino
parameter_list|,
name|ino64_t
modifier|*
name|ino
parameter_list|)
block|{
name|vnode_t
modifier|*
name|parent
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
init|=
name|dvp
operator|->
name|v_data
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|ino
operator|=
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_ino
expr_stmt|;
name|parent
operator|=
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_parent
expr_stmt|;
if|if
condition|(
name|parent
operator|==
name|NULL
condition|)
block|{
operator|*
name|pino
operator|=
operator|*
name|ino
expr_stmt|;
comment|/* root of filesystem */
block|}
elseif|else
if|if
condition|(
name|dvp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
condition|)
block|{
name|vattr_t
name|va
decl_stmt|;
name|va
operator|.
name|va_mask
operator|=
name|AT_NODEID
expr_stmt|;
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|parent
argument_list|,
operator|&
name|va
argument_list|,
literal|0
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
operator|*
name|pino
operator|=
name|va
operator|.
name|va_nodeid
expr_stmt|;
block|}
else|else
block|{
operator|*
name|pino
operator|=
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
operator|(
name|parent
operator|->
name|v_data
operator|)
operator|)
operator|->
name|gfs_ino
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_init: initiate a generic readdir  *   st		- a pointer to an uninitialized gfs_readdir_state_t structure  *   name_max	- the directory's maximum file name length  *   ureclen	- the exported file-space record length (1 for non-legacy FSs)  *   uiop	- the uiop passed to readdir  *   parent	- the parent directory's inode  *   self	- this directory's inode  *   flags	- flags from VOP_READDIR  *  * Returns 0 or a non-zero errno.  *  * Typical VOP_READDIR usage of gfs_readdir_*:  *  *	if ((error = gfs_readdir_init(...)) != 0)  *		return (error);  *	eof = 0;  *	while ((error = gfs_readdir_pred(...,&voffset)) != 0) {  *		if (!consumer_entry_at(voffset))  *			voffset = consumer_next_entry(voffset);  *		if (consumer_eof(voffset)) {  *			eof = 1  *			break;  *		}  *		if ((error = gfs_readdir_emit(..., voffset,  *		    consumer_ino(voffset), consumer_name(voffset))) != 0)  *			break;  *	}  *	return (gfs_readdir_fini(..., error, eofp, eof));  *  * As you can see, a zero result from gfs_readdir_pred() or  * gfs_readdir_emit() indicates that processing should continue,  * whereas a non-zero result indicates that the loop should terminate.  * Most consumers need do nothing more than let gfs_readdir_fini()  * determine what the cause of failure was and return the appropriate  * value.  */
end_comment

begin_function
name|int
name|gfs_readdir_init
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|int
name|name_max
parameter_list|,
name|int
name|ureclen
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|ino64_t
name|parent
parameter_list|,
name|ino64_t
name|self
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|size_t
name|dirent_size
decl_stmt|;
if|if
condition|(
name|uiop
operator|->
name|uio_loffset
operator|<
literal|0
operator|||
name|uiop
operator|->
name|uio_resid
operator|<=
literal|0
operator|||
operator|(
name|uiop
operator|->
name|uio_loffset
operator|%
name|ureclen
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|st
operator|->
name|grd_ureclen
operator|=
name|ureclen
expr_stmt|;
name|st
operator|->
name|grd_oresid
operator|=
name|uiop
operator|->
name|uio_resid
expr_stmt|;
name|st
operator|->
name|grd_namlen
operator|=
name|name_max
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
name|dirent_size
operator|=
name|EDIRENT_RECLEN
argument_list|(
name|st
operator|->
name|grd_namlen
argument_list|)
expr_stmt|;
else|else
name|dirent_size
operator|=
name|DIRENT64_RECLEN
argument_list|(
name|st
operator|->
name|grd_namlen
argument_list|)
expr_stmt|;
name|st
operator|->
name|grd_dirent
operator|=
name|kmem_zalloc
argument_list|(
name|dirent_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|st
operator|->
name|grd_parent
operator|=
name|parent
expr_stmt|;
name|st
operator|->
name|grd_self
operator|=
name|self
expr_stmt|;
name|st
operator|->
name|grd_flags
operator|=
name|flags
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_emit_int: internal routine to emit directory entry  *  *   st		- the current readdir state, which must have d_ino/ed_ino  *		  and d_name/ed_name set  *   uiop	- caller-supplied uio pointer  *   next	- the offset of the next entry  */
end_comment

begin_function
specifier|static
name|int
name|gfs_readdir_emit_int
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|offset_t
name|next
parameter_list|)
block|{
name|int
name|reclen
decl_stmt|;
name|dirent64_t
modifier|*
name|dp
decl_stmt|;
name|edirent_t
modifier|*
name|edp
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|grd_flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
block|{
name|edp
operator|=
name|st
operator|->
name|grd_dirent
expr_stmt|;
name|reclen
operator|=
name|EDIRENT_RECLEN
argument_list|(
name|strlen
argument_list|(
name|edp
operator|->
name|ed_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|=
name|st
operator|->
name|grd_dirent
expr_stmt|;
name|reclen
operator|=
name|DIRENT64_RECLEN
argument_list|(
name|strlen
argument_list|(
name|dp
operator|->
name|d_name
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reclen
operator|>
name|uiop
operator|->
name|uio_resid
condition|)
block|{
comment|/* 		 * Error if no entries were returned yet 		 */
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|==
name|st
operator|->
name|grd_oresid
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|st
operator|->
name|grd_flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
block|{
name|edp
operator|->
name|ed_off
operator|=
name|next
expr_stmt|;
name|edp
operator|->
name|ed_reclen
operator|=
operator|(
name|ushort_t
operator|)
name|reclen
expr_stmt|;
block|}
else|else
block|{
name|dp
operator|->
name|d_off
operator|=
name|next
expr_stmt|;
name|dp
operator|->
name|d_reclen
operator|=
operator|(
name|ushort_t
operator|)
name|reclen
expr_stmt|;
block|}
if|if
condition|(
name|uiomove
argument_list|(
operator|(
name|caddr_t
operator|)
name|st
operator|->
name|grd_dirent
argument_list|,
name|reclen
argument_list|,
name|UIO_READ
argument_list|,
name|uiop
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
name|uiop
operator|->
name|uio_loffset
operator|=
name|next
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_emit: emit a directory entry  *   voff       - the virtual offset (obtained from gfs_readdir_pred)  *   ino        - the entry's inode  *   name       - the entry's name  *   eflags	- value for ed_eflags (if processing edirent_t)  *  * Returns a 0 on success, a non-zero errno on failure, or -1 if the  * readdir loop should terminate.  A non-zero result (either errno or  * -1) from this function is typically passed directly to  * gfs_readdir_fini().  */
end_comment

begin_function
name|int
name|gfs_readdir_emit
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|offset_t
name|voff
parameter_list|,
name|ino64_t
name|ino
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|offset_t
name|off
init|=
operator|(
name|voff
operator|+
literal|2
operator|)
operator|*
name|st
operator|->
name|grd_ureclen
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|grd_flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
block|{
name|edirent_t
modifier|*
name|edp
init|=
name|st
operator|->
name|grd_dirent
decl_stmt|;
name|edp
operator|->
name|ed_ino
operator|=
name|ino
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|edp
operator|->
name|ed_name
argument_list|,
name|name
argument_list|,
name|st
operator|->
name|grd_namlen
argument_list|)
expr_stmt|;
name|edp
operator|->
name|ed_eflags
operator|=
name|eflags
expr_stmt|;
block|}
else|else
block|{
name|dirent64_t
modifier|*
name|dp
init|=
name|st
operator|->
name|grd_dirent
decl_stmt|;
name|dp
operator|->
name|d_ino
operator|=
name|ino
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|dp
operator|->
name|d_name
argument_list|,
name|name
argument_list|,
name|st
operator|->
name|grd_namlen
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Inter-entry offsets are invalid, so we assume a record size of 	 * grd_ureclen and explicitly set the offset appropriately. 	 */
return|return
operator|(
name|gfs_readdir_emit_int
argument_list|(
name|st
argument_list|,
name|uiop
argument_list|,
name|off
operator|+
name|st
operator|->
name|grd_ureclen
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_emitn: like gfs_readdir_emit(), but takes an integer  * instead of a string for the entry's name.  */
end_comment

begin_function
name|int
name|gfs_readdir_emitn
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|offset_t
name|voff
parameter_list|,
name|ino64_t
name|ino
parameter_list|,
name|unsigned
name|long
name|num
parameter_list|)
block|{
name|char
name|buf
index|[
literal|40
index|]
decl_stmt|;
name|numtos
argument_list|(
name|num
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|gfs_readdir_emit
argument_list|(
name|st
argument_list|,
name|uiop
argument_list|,
name|voff
argument_list|,
name|ino
argument_list|,
name|buf
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_pred: readdir loop predicate  *   voffp - a pointer in which the next virtual offset should be stored  *  * Returns a 0 on success, a non-zero errno on failure, or -1 if the  * readdir loop should terminate.  A non-zero result (either errno or  * -1) from this function is typically passed directly to  * gfs_readdir_fini().  */
end_comment

begin_function
name|int
name|gfs_readdir_pred
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|offset_t
modifier|*
name|voffp
parameter_list|)
block|{
name|offset_t
name|off
decl_stmt|,
name|voff
decl_stmt|;
name|int
name|error
decl_stmt|;
name|top
label|:
if|if
condition|(
name|uiop
operator|->
name|uio_resid
operator|<=
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|off
operator|=
name|uiop
operator|->
name|uio_loffset
operator|/
name|st
operator|->
name|grd_ureclen
expr_stmt|;
name|voff
operator|=
name|off
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|off
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit
argument_list|(
name|st
argument_list|,
name|uiop
argument_list|,
name|voff
argument_list|,
name|st
operator|->
name|grd_self
argument_list|,
literal|"."
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
block|}
elseif|else
if|if
condition|(
name|off
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit
argument_list|(
name|st
argument_list|,
name|uiop
argument_list|,
name|voff
argument_list|,
name|st
operator|->
name|grd_parent
argument_list|,
literal|".."
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
goto|goto
name|top
goto|;
block|}
else|else
block|{
operator|*
name|voffp
operator|=
name|voff
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_readdir_fini: generic readdir cleanup  *   error	- if positive, an error to return  *   eofp	- the eofp passed to readdir  *   eof	- the eof value  *  * Returns a 0 on success, a non-zero errno on failure.  This result  * should be returned from readdir.  */
end_comment

begin_function
name|int
name|gfs_readdir_fini
parameter_list|(
name|gfs_readdir_state_t
modifier|*
name|st
parameter_list|,
name|int
name|error
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|int
name|eof
parameter_list|)
block|{
name|size_t
name|dirent_size
decl_stmt|;
if|if
condition|(
name|st
operator|->
name|grd_flags
operator|&
name|V_RDDIR_ENTFLAGS
condition|)
name|dirent_size
operator|=
name|EDIRENT_RECLEN
argument_list|(
name|st
operator|->
name|grd_namlen
argument_list|)
expr_stmt|;
else|else
name|dirent_size
operator|=
name|DIRENT64_RECLEN
argument_list|(
name|st
operator|->
name|grd_namlen
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|st
operator|->
name|grd_dirent
argument_list|,
name|dirent_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
name|eof
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_lookup_dot  *  * Performs a basic check for "." and ".." directory entries.  */
end_comment

begin_function
name|int
name|gfs_lookup_dot
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
name|pvp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|)
block|{
if|if
condition|(
operator|*
name|nm
operator|==
literal|'\0'
operator|||
name|strcmp
argument_list|(
name|nm
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
block|{
name|VN_HOLD
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|nm
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|pvp
operator|==
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
name|dvp
operator|->
name|v_flag
operator|&
name|VROOT
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|dvp
expr_stmt|;
block|}
else|else
block|{
name|VN_HOLD
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|pvp
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_file_create(): create a new GFS file  *  *   size	- size of private data structure (v_data)  *   pvp	- parent vnode (GFS directory)  *   ops	- vnode operations vector  *  * In order to use this interface, the parent vnode must have been created by  * gfs_dir_create(), and the private data stored in v_data must have a  * 'gfs_file_t' as its first field.  *  * Given these constraints, this routine will automatically:  *  * 	- Allocate v_data for the vnode  * 	- Initialize necessary fields in the vnode  * 	- Hold the parent  */
end_comment

begin_function
name|vnode_t
modifier|*
name|gfs_file_create
parameter_list|(
name|size_t
name|size
parameter_list|,
name|vnode_t
modifier|*
name|pvp
parameter_list|,
name|vnodeops_t
modifier|*
name|ops
parameter_list|)
block|{
name|gfs_file_t
modifier|*
name|fp
decl_stmt|;
name|vnode_t
modifier|*
name|vp
decl_stmt|;
comment|/* 	 * Allocate vnode and internal data structure 	 */
name|fp
operator|=
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|vp
operator|=
name|vn_alloc
argument_list|(
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Set up various pointers 	 */
name|fp
operator|->
name|gfs_vnode
operator|=
name|vp
expr_stmt|;
name|fp
operator|->
name|gfs_parent
operator|=
name|pvp
expr_stmt|;
name|vp
operator|->
name|v_data
operator|=
name|fp
expr_stmt|;
name|fp
operator|->
name|gfs_size
operator|=
name|size
expr_stmt|;
name|fp
operator|->
name|gfs_type
operator|=
name|GFS_FILE
expr_stmt|;
comment|/* 	 * Initialize vnode and hold parent. 	 */
name|vn_setops
argument_list|(
name|vp
argument_list|,
name|ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|pvp
condition|)
block|{
name|VN_SET_VFS_TYPE_DEV
argument_list|(
name|vp
argument_list|,
name|pvp
operator|->
name|v_vfsp
argument_list|,
name|VREG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VN_HOLD
argument_list|(
name|pvp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_create: creates a new directory in the parent  *  *   size	- size of private data structure (v_data)  *   pvp	- parent vnode (GFS directory)  *   ops	- vnode operations vector  *   entries	- NULL-terminated list of static entries (if any)  *   maxlen	- maximum length of a directory entry  *   readdir_cb	- readdir callback (see gfs_dir_readdir)  *   inode_cb	- inode callback (see gfs_dir_readdir)  *   lookup_cb	- lookup callback (see gfs_dir_lookup)  *  * In order to use this function, the first member of the private vnode  * structure (v_data) must be a gfs_dir_t.  For each directory, there are  * static entries, defined when the structure is initialized, and dynamic  * entries, retrieved through callbacks.  *  * If a directory has static entries, then it must supply a inode callback,  * which will compute the inode number based on the parent and the index.  * For a directory with dynamic entries, the caller must supply a readdir  * callback and a lookup callback.  If a static lookup fails, we fall back to  * the supplied lookup callback, if any.  *  * This function also performs the same initialization as gfs_file_create().  */
end_comment

begin_function
name|vnode_t
modifier|*
name|gfs_dir_create
parameter_list|(
name|size_t
name|struct_size
parameter_list|,
name|vnode_t
modifier|*
name|pvp
parameter_list|,
name|vnodeops_t
modifier|*
name|ops
parameter_list|,
name|gfs_dirent_t
modifier|*
name|entries
parameter_list|,
name|gfs_inode_cb
name|inode_cb
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|gfs_readdir_cb
name|readdir_cb
parameter_list|,
name|gfs_lookup_cb
name|lookup_cb
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
decl_stmt|;
name|gfs_dirent_t
modifier|*
name|de
decl_stmt|;
name|vp
operator|=
name|gfs_file_create
argument_list|(
name|struct_size
argument_list|,
name|pvp
argument_list|,
name|ops
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|VDIR
expr_stmt|;
name|dp
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_type
operator|=
name|GFS_DIR
expr_stmt|;
name|dp
operator|->
name|gfsd_maxlen
operator|=
name|maxlen
expr_stmt|;
if|if
condition|(
name|entries
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|de
operator|=
name|entries
init|;
name|de
operator|->
name|gfse_name
operator|!=
name|NULL
condition|;
name|de
operator|++
control|)
name|dp
operator|->
name|gfsd_nstatic
operator|++
expr_stmt|;
name|dp
operator|->
name|gfsd_static
operator|=
name|kmem_alloc
argument_list|(
name|dp
operator|->
name|gfsd_nstatic
operator|*
sizeof|sizeof
argument_list|(
name|gfs_dirent_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|entries
argument_list|,
name|dp
operator|->
name|gfsd_static
argument_list|,
name|dp
operator|->
name|gfsd_nstatic
operator|*
sizeof|sizeof
argument_list|(
name|gfs_dirent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dp
operator|->
name|gfsd_readdir
operator|=
name|readdir_cb
expr_stmt|;
name|dp
operator|->
name|gfsd_lookup
operator|=
name|lookup_cb
expr_stmt|;
name|dp
operator|->
name|gfsd_inode
operator|=
name|inode_cb
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|dp
operator|->
name|gfsd_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_root_create(): create a root vnode for a GFS filesystem  *  * Similar to gfs_dir_create(), this creates a root vnode for a filesystem.  The  * only difference is that it takes a vfs_t instead of a vnode_t as its parent.  */
end_comment

begin_function
name|vnode_t
modifier|*
name|gfs_root_create
parameter_list|(
name|size_t
name|size
parameter_list|,
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnodeops_t
modifier|*
name|ops
parameter_list|,
name|ino64_t
name|ino
parameter_list|,
name|gfs_dirent_t
modifier|*
name|entries
parameter_list|,
name|gfs_inode_cb
name|inode_cb
parameter_list|,
name|int
name|maxlen
parameter_list|,
name|gfs_readdir_cb
name|readdir_cb
parameter_list|,
name|gfs_lookup_cb
name|lookup_cb
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|gfs_dir_create
argument_list|(
name|size
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|,
name|entries
argument_list|,
name|inode_cb
argument_list|,
name|maxlen
argument_list|,
name|readdir_cb
argument_list|,
name|lookup_cb
argument_list|)
decl_stmt|;
comment|/* Manually set the inode */
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|gfs_ino
operator|=
name|ino
expr_stmt|;
name|VFS_HOLD
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|VN_SET_VFS_TYPE_DEV
argument_list|(
name|vp
argument_list|,
name|vfsp
argument_list|,
name|VDIR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VROOT
operator||
name|VNOCACHE
operator||
name|VNOMAP
operator||
name|VNOSWAP
operator||
name|VNOMOUNT
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_root_create_file(): create a root vnode for a GFS file as a filesystem  *  * Similar to gfs_root_create(), this creates a root vnode for a file to  * be the pseudo-filesystem.  */
end_comment

begin_function
name|vnode_t
modifier|*
name|gfs_root_create_file
parameter_list|(
name|size_t
name|size
parameter_list|,
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|vnodeops_t
modifier|*
name|ops
parameter_list|,
name|ino64_t
name|ino
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
init|=
name|gfs_file_create
argument_list|(
name|size
argument_list|,
name|NULL
argument_list|,
name|ops
argument_list|)
decl_stmt|;
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|gfs_ino
operator|=
name|ino
expr_stmt|;
name|VFS_HOLD
argument_list|(
name|vfsp
argument_list|)
expr_stmt|;
name|VN_SET_VFS_TYPE_DEV
argument_list|(
name|vp
argument_list|,
name|vfsp
argument_list|,
name|VREG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_flag
operator||=
name|VROOT
operator||
name|VNOCACHE
operator||
name|VNOMAP
operator||
name|VNOSWAP
operator||
name|VNOMOUNT
expr_stmt|;
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_file_inactive()  *  * Called from the VOP_INACTIVE() routine.  If necessary, this routine will  * remove the given vnode from the parent directory and clean up any references  * in the VFS layer.  *  * If the vnode was not removed (due to a race with vget), then NULL is  * returned.  Otherwise, a pointer to the private data is returned.  */
end_comment

begin_function
name|void
modifier|*
name|gfs_file_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|gfs_dirent_t
modifier|*
name|ge
init|=
name|NULL
decl_stmt|;
name|gfs_file_t
modifier|*
name|fp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
init|=
name|NULL
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|gfs_parent
operator|==
name|NULL
operator|||
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
operator|)
condition|)
goto|goto
name|found
goto|;
name|dp
operator|=
name|fp
operator|->
name|gfs_parent
operator|->
name|v_data
expr_stmt|;
comment|/* 	 * First, see if this vnode is cached in the parent. 	 */
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * Find it in the set of static entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|gfsd_nstatic
condition|;
name|i
operator|++
control|)
block|{
name|ge
operator|=
operator|&
name|dp
operator|->
name|gfsd_static
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|ge
operator|->
name|gfse_vnode
operator|==
name|vp
condition|)
goto|goto
name|found
goto|;
block|}
comment|/* 	 * If 'ge' is NULL, then it is a dynamic entry. 	 */
name|ge
operator|=
name|NULL
expr_stmt|;
name|found
label|:
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|gfs_parent
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_count
operator|==
literal|1
condition|)
block|{
comment|/* 		 * Really remove this vnode 		 */
name|data
operator|=
name|vp
operator|->
name|v_data
expr_stmt|;
if|if
condition|(
name|ge
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * If this was a statically cached entry, simply set the 			 * cached vnode to NULL. 			 */
name|ge
operator|->
name|gfse_vnode
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
condition|)
block|{
name|fp
operator|->
name|gfs_parent
operator|->
name|v_xattrdir
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|gfs_parent
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
comment|/* 		 * Free vnode and release parent 		 */
if|if
condition|(
name|fp
operator|->
name|gfs_parent
condition|)
block|{
if|if
condition|(
name|dp
condition|)
block|{
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
name|VN_RELE
argument_list|(
name|fp
operator|->
name|gfs_parent
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_vfsp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|VFS_RELE
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|)
expr_stmt|;
block|}
name|vn_free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|VN_RELE_LOCKED
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|data
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|V_XATTRDIR
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|gfs_parent
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dp
condition|)
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|data
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_inactive()  *  * Same as above, but for directories.  */
end_comment

begin_function
name|void
modifier|*
name|gfs_dir_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|gfs_dir_t
modifier|*
name|dp
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dp
operator|=
name|gfs_file_inactive
argument_list|(
name|vp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|mutex_destroy
argument_list|(
operator|&
name|dp
operator|->
name|gfsd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|->
name|gfsd_nstatic
condition|)
name|kmem_free
argument_list|(
name|dp
operator|->
name|gfsd_static
argument_list|,
name|dp
operator|->
name|gfsd_nstatic
operator|*
sizeof|sizeof
argument_list|(
name|gfs_dirent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_lookup_dynamic()  *  * This routine looks up the provided name amongst the dynamic entries  * in the gfs directory and returns the corresponding vnode, if found.  *  * The gfs directory is expected to be locked by the caller prior to  * calling this function.  The directory will be unlocked during the  * execution of this function, but will be locked upon return from the  * function.  This function returns 0 on success, non-zero on error.  *  * The dynamic lookups are performed by invoking the lookup  * callback, which is passed to this function as the first argument.  * The arguments to the callback are:  *  * int gfs_lookup_cb(vnode_t *pvp, const char *nm, vnode_t **vpp, cred_t *cr,  *     int flags, int *deflgs, pathname_t *rpnp);  *  *	pvp	- parent vnode  *	nm	- name of entry  *	vpp	- pointer to resulting vnode  *	cr	- pointer to cred  *	flags	- flags value from lookup request  *		ignored here; currently only used to request  *		insensitive lookups  *	direntflgs - output parameter, directory entry flags  *		ignored here; currently only used to indicate a lookup  *		has more than one possible match when case is not considered  *	realpnp	- output parameter, real pathname  *		ignored here; when lookup was performed case-insensitively,  *		this field contains the "real" name of the file.  *  * 	Returns 0 on success, non-zero on error.  */
end_comment

begin_function
specifier|static
name|int
name|gfs_dir_lookup_dynamic
parameter_list|(
name|gfs_lookup_cb
name|callback
parameter_list|,
name|gfs_dir_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
name|gfs_file_t
modifier|*
name|fp
decl_stmt|;
name|ino64_t
name|ino
decl_stmt|;
name|int
name|ret
decl_stmt|;
name|ASSERT
argument_list|(
name|GFS_DIR_LOCKED
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Drop the directory lock, as the lookup routine 	 * will need to allocate memory, or otherwise deadlock on this 	 * directory. 	 */
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|ret
operator|=
name|callback
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|vpp
argument_list|,
operator|&
name|ino
argument_list|,
name|cr
argument_list|,
name|flags
argument_list|,
name|direntflags
argument_list|,
name|realpnp
argument_list|)
expr_stmt|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
comment|/* 	 * The callback for extended attributes returns a vnode 	 * with v_data from an underlying fs. 	 */
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|!
name|IS_XATTRDIR
argument_list|(
name|dvp
argument_list|)
condition|)
block|{
name|fp
operator|=
operator|(
name|gfs_file_t
operator|*
operator|)
operator|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_data
operator|)
expr_stmt|;
name|fp
operator|->
name|gfs_index
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|->
name|gfs_ino
operator|=
name|ino
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_lookup_static()  *  * This routine looks up the provided name amongst the static entries  * in the gfs directory and returns the corresponding vnode, if found.  * The first argument to the function is a pointer to the comparison  * function this function should use to decide if names are a match.  *  * If a match is found, and GFS_CACHE_VNODE is set and the vnode  * exists, we simply return the existing vnode.  Otherwise, we call  * the static entry's callback routine, caching the result if  * necessary.  If the idx pointer argument is non-NULL, we use it to  * return the index of the matching static entry.  *  * The gfs directory is expected to be locked by the caller prior to calling  * this function.  The directory may be unlocked during the execution of  * this function, but will be locked upon return from the function.  *  * This function returns 0 if a match is found, ENOENT if not.  */
end_comment

begin_function
specifier|static
name|int
name|gfs_dir_lookup_static
parameter_list|(
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
parameter_list|,
name|gfs_dir_t
modifier|*
name|dp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|int
modifier|*
name|idx
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|pathname_t
modifier|*
name|rpnp
parameter_list|)
block|{
name|gfs_dirent_t
modifier|*
name|ge
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|GFS_DIR_LOCKED
argument_list|(
name|dp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Search static entries. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dp
operator|->
name|gfsd_nstatic
condition|;
name|i
operator|++
control|)
block|{
name|ge
operator|=
operator|&
name|dp
operator|->
name|gfsd_static
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|compare
argument_list|(
name|ge
operator|->
name|gfse_name
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|rpnp
condition|)
operator|(
name|void
operator|)
name|strlcpy
argument_list|(
name|rpnp
operator|->
name|pn_buf
argument_list|,
name|ge
operator|->
name|gfse_name
argument_list|,
name|rpnp
operator|->
name|pn_bufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|ge
operator|->
name|gfse_vnode
condition|)
block|{
name|ASSERT
argument_list|(
name|ge
operator|->
name|gfse_flags
operator|&
name|GFS_CACHE_VNODE
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ge
operator|->
name|gfse_vnode
expr_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* 			 * We drop the directory lock, as the constructor will 			 * need to do KM_SLEEP allocations.  If we return from 			 * the constructor only to find that a parallel 			 * operation has completed, and GFS_CACHE_VNODE is set 			 * for this entry, we discard the result in favor of 			 * the cached vnode. 			 */
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|ge
operator|->
name|gfse_ctor
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|gfs_index
operator|=
name|i
expr_stmt|;
comment|/* Set the inode according to the callback. */
operator|(
operator|(
name|gfs_file_t
operator|*
operator|)
name|vp
operator|->
name|v_data
operator|)
operator|->
name|gfs_ino
operator|=
name|dp
operator|->
name|gfsd_inode
argument_list|(
name|dvp
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|ge
operator|->
name|gfse_flags
operator|&
name|GFS_CACHE_VNODE
condition|)
block|{
if|if
condition|(
name|ge
operator|->
name|gfse_vnode
operator|==
name|NULL
condition|)
block|{
name|ge
operator|->
name|gfse_vnode
operator|=
name|vp
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * A parallel constructor beat us to it; 					 * return existing vnode.  We have to be 					 * careful because we can't release the 					 * current vnode while holding the 					 * directory lock; its inactive routine 					 * will try to lock this directory. 					 */
name|vnode_t
modifier|*
name|oldvp
init|=
name|vp
decl_stmt|;
name|vp
operator|=
name|ge
operator|->
name|gfse_vnode
expr_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|oldvp
argument_list|)
expr_stmt|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return
operator|(
name|ENOENT
operator|)
return|;
elseif|else
if|if
condition|(
name|idx
condition|)
operator|*
name|idx
operator|=
name|i
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_lookup()  *  * Looks up the given name in the directory and returns the corresponding  * vnode, if found.  *  * First, we search statically defined entries, if any, with a call to  * gfs_dir_lookup_static().  If no static entry is found, and we have  * a callback function we try a dynamic lookup via gfs_dir_lookup_dynamic().  *  * This function returns 0 on success, non-zero on error.  */
end_comment

begin_function
name|int
name|gfs_dir_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
name|flags
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
name|gfs_dir_t
modifier|*
name|dp
init|=
name|dvp
operator|->
name|v_data
decl_stmt|;
name|boolean_t
name|casecheck
decl_stmt|;
name|vnode_t
modifier|*
name|dynvp
init|=
name|NULL
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
name|int
name|error
decl_stmt|,
name|idx
decl_stmt|;
name|ASSERT
argument_list|(
name|dvp
operator|->
name|v_type
operator|==
name|VDIR
argument_list|)
expr_stmt|;
if|if
condition|(
name|gfs_lookup_dot
argument_list|(
name|vpp
argument_list|,
name|dvp
argument_list|,
name|dp
operator|->
name|gfsd_file
operator|.
name|gfs_parent
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|casecheck
operator|=
operator|(
name|flags
operator|&
name|FIGNORECASE
operator|)
operator|!=
literal|0
operator|&&
name|direntflags
operator|!=
name|NULL
expr_stmt|;
if|if
condition|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|||
operator|(
name|flags
operator|&
name|FIGNORECASE
operator|)
condition|)
name|compare
operator|=
name|strcasecmp
expr_stmt|;
else|else
name|compare
operator|=
name|strcmp
expr_stmt|;
name|gfs_dir_lock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|error
operator|=
name|gfs_dir_lookup_static
argument_list|(
name|compare
argument_list|,
name|dp
argument_list|,
name|nm
argument_list|,
name|dvp
argument_list|,
operator|&
name|idx
argument_list|,
operator|&
name|vp
argument_list|,
name|realpnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|&&
name|casecheck
condition|)
block|{
name|gfs_dirent_t
modifier|*
name|ge
decl_stmt|;
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|idx
operator|+
literal|1
init|;
name|i
operator|<
name|dp
operator|->
name|gfsd_nstatic
condition|;
name|i
operator|++
control|)
block|{
name|ge
operator|=
operator|&
name|dp
operator|->
name|gfsd_static
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|ge
operator|->
name|gfse_name
argument_list|,
name|nm
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
name|direntflags
operator||=
name|ED_CASE_CONFLICT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
operator|(
name|error
operator|||
name|casecheck
operator|)
operator|&&
name|dp
operator|->
name|gfsd_lookup
condition|)
name|error
operator|=
name|gfs_dir_lookup_dynamic
argument_list|(
name|dp
operator|->
name|gfsd_lookup
argument_list|,
name|dp
argument_list|,
name|nm
argument_list|,
name|dvp
argument_list|,
operator|&
name|dynvp
argument_list|,
name|cr
argument_list|,
name|flags
argument_list|,
name|direntflags
argument_list|,
name|vp
condition|?
name|NULL
else|:
name|realpnp
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|&&
name|dynvp
condition|)
block|{
comment|/* static and dynamic entries are case-insensitive conflict */
name|ASSERT
argument_list|(
name|casecheck
argument_list|)
expr_stmt|;
operator|*
name|direntflags
operator||=
name|ED_CASE_CONFLICT
expr_stmt|;
name|VN_RELE
argument_list|(
name|dynvp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|vp
operator|=
name|dynvp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
operator|==
name|ENOENT
condition|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|error
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
name|out
label|:
name|gfs_dir_unlock
argument_list|(
name|dp
argument_list|)
expr_stmt|;
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_dir_readdir: does a readdir() on the given directory  *  *    dvp	- directory vnode  *    uiop	- uio structure  *    eofp	- eof pointer  *    data	- arbitrary data passed to readdir callback  *  * This routine does all the readdir() dirty work.  Even so, the caller must  * supply two callbacks in order to get full compatibility.  *  * If the directory contains static entries, an inode callback must be  * specified.  This avoids having to create every vnode and call VOP_GETATTR()  * when reading the directory.  This function has the following arguments:  *  *	ino_t gfs_inode_cb(vnode_t *vp, int index);  *  * 	vp	- vnode for the directory  * 	index	- index in original gfs_dirent_t array  *  * 	Returns the inode number for the given entry.  *  * For directories with dynamic entries, a readdir callback must be provided.  * This is significantly more complex, thanks to the particulars of  * VOP_READDIR().  *  *	int gfs_readdir_cb(vnode_t *vp, void *dp, int *eofp,  *	    offset_t *off, offset_t *nextoff, void *data, int flags)  *  *	vp	- directory vnode  *	dp	- directory entry, sized according to maxlen given to  *		  gfs_dir_create().  callback must fill in d_name and  *		  d_ino (if a dirent64_t), or ed_name, ed_ino, and ed_eflags  *		  (if an edirent_t). edirent_t is used if V_RDDIR_ENTFLAGS  *		  is set in 'flags'.  *	eofp	- callback must set to 1 when EOF has been reached  *	off	- on entry, the last offset read from the directory.  Callback  *		  must set to the offset of the current entry, typically left  *		  untouched.  *	nextoff	- callback must set to offset of next entry.  Typically  *		  (off + 1)  *	data	- caller-supplied data  *	flags	- VOP_READDIR flags  *  *	Return 0 on success, or error on failure.  */
end_comment

begin_function
name|int
name|gfs_dir_readdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|gfs_readdir_state_t
name|gstate
decl_stmt|;
name|int
name|error
decl_stmt|,
name|eof
init|=
literal|0
decl_stmt|;
name|ino64_t
name|ino
decl_stmt|,
name|pino
decl_stmt|;
name|offset_t
name|off
decl_stmt|,
name|next
decl_stmt|;
name|gfs_dir_t
modifier|*
name|dp
init|=
name|dvp
operator|->
name|v_data
decl_stmt|;
name|error
operator|=
name|gfs_get_parent_ino
argument_list|(
name|dvp
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|,
operator|&
name|pino
argument_list|,
operator|&
name|ino
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_init
argument_list|(
operator|&
name|gstate
argument_list|,
name|dp
operator|->
name|gfsd_maxlen
argument_list|,
literal|1
argument_list|,
name|uiop
argument_list|,
name|pino
argument_list|,
name|ino
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
while|while
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_pred
argument_list|(
operator|&
name|gstate
argument_list|,
name|uiop
argument_list|,
operator|&
name|off
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|!
name|eof
condition|)
block|{
if|if
condition|(
name|off
operator|>=
literal|0
operator|&&
name|off
operator|<
name|dp
operator|->
name|gfsd_nstatic
condition|)
block|{
name|ino
operator|=
name|dp
operator|->
name|gfsd_inode
argument_list|(
name|dvp
argument_list|,
name|off
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit
argument_list|(
operator|&
name|gstate
argument_list|,
name|uiop
argument_list|,
name|off
argument_list|,
name|ino
argument_list|,
name|dp
operator|->
name|gfsd_static
index|[
name|off
index|]
operator|.
name|gfse_name
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
elseif|else
if|if
condition|(
name|dp
operator|->
name|gfsd_readdir
condition|)
block|{
name|off
operator|-=
name|dp
operator|->
name|gfsd_nstatic
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|dp
operator|->
name|gfsd_readdir
argument_list|(
name|dvp
argument_list|,
name|gstate
operator|.
name|grd_dirent
argument_list|,
operator|&
name|eof
argument_list|,
operator|&
name|off
argument_list|,
operator|&
name|next
argument_list|,
name|data
argument_list|,
name|flags
argument_list|)
operator|)
operator|!=
literal|0
operator|||
name|eof
condition|)
break|break;
name|off
operator|+=
name|dp
operator|->
name|gfsd_nstatic
operator|+
literal|2
expr_stmt|;
name|next
operator|+=
name|dp
operator|->
name|gfsd_nstatic
operator|+
literal|2
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|gfs_readdir_emit_int
argument_list|(
operator|&
name|gstate
argument_list|,
name|uiop
argument_list|,
name|next
argument_list|)
operator|)
operator|!=
literal|0
condition|)
break|break;
block|}
else|else
block|{
comment|/* 			 * Offset is beyond the end of the static entries, and 			 * we have no dynamic entries.  Set EOF. 			 */
name|eof
operator|=
literal|1
expr_stmt|;
block|}
block|}
return|return
operator|(
name|gfs_readdir_fini
argument_list|(
operator|&
name|gstate
argument_list|,
name|error
argument_list|,
name|eofp
argument_list|,
name|eof
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_vop_lookup: VOP_LOOKUP() entry point  *  * For use directly in vnode ops table.  Given a GFS directory, calls  * gfs_dir_lookup() as necessary.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|gfs_vop_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|pathname_t
modifier|*
name|pnp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
name|rdir
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
modifier|*
name|direntflags
parameter_list|,
name|pathname_t
modifier|*
name|realpnp
parameter_list|)
block|{
return|return
operator|(
name|gfs_dir_lookup
argument_list|(
name|dvp
argument_list|,
name|nm
argument_list|,
name|vpp
argument_list|,
name|cr
argument_list|,
name|flags
argument_list|,
name|direntflags
argument_list|,
name|realpnp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_vop_readdir: VOP_READDIR() entry point  *  * For use directly in vnode ops table.  Given a GFS directory, calls  * gfs_dir_readdir() as necessary.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|gfs_vop_readdir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
return|return
operator|(
name|gfs_dir_readdir
argument_list|(
name|vp
argument_list|,
name|uiop
argument_list|,
name|eofp
argument_list|,
name|NULL
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|,
name|flags
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_vop_map: VOP_MAP() entry point  *  * Convenient routine for handling pseudo-files that wish to allow mmap() calls.  * This function only works for readonly files, and uses the read function for  * the vnode to fill in the data.  The mapped data is immediately faulted in and  * filled with the necessary data during this call; there are no getpage() or  * putpage() routines.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|gfs_vop_map
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|struct
name|as
modifier|*
name|as
parameter_list|,
name|caddr_t
modifier|*
name|addrp
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uchar_t
name|prot
parameter_list|,
name|uchar_t
name|maxprot
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cred
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|rv
decl_stmt|;
name|ssize_t
name|resid
init|=
name|len
decl_stmt|;
comment|/* 	 * Check for bad parameters 	 */
ifdef|#
directive|ifdef
name|_ILP32
if|if
condition|(
name|len
operator|>
name|MAXOFF_T
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
endif|#
directive|endif
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VNOMAP
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
if|if
condition|(
name|off
operator|>
name|MAXOFF_T
condition|)
return|return
operator|(
name|EFBIG
operator|)
return|;
if|if
condition|(
operator|(
name|long
operator|)
name|off
operator|<
literal|0
operator|||
call|(
name|long
call|)
argument_list|(
name|off
operator|+
name|len
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
if|if
condition|(
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
return|return
operator|(
name|ENODEV
operator|)
return|;
if|if
condition|(
operator|(
name|prot
operator|&
operator|(
name|PROT_EXEC
operator||
name|PROT_WRITE
operator|)
operator|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EACCES
operator|)
return|;
comment|/* 	 * Find appropriate address if needed, otherwise clear address range. 	 */
name|as_rangelock
argument_list|(
name|as
argument_list|)
expr_stmt|;
name|rv
operator|=
name|choose_addr
argument_list|(
name|as
argument_list|,
name|addrp
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
name|ADDR_VACALIGN
argument_list|,
name|flags
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|as_rangeunlock
argument_list|(
name|as
argument_list|)
expr_stmt|;
return|return
operator|(
name|rv
operator|)
return|;
block|}
comment|/* 	 * Create mapping 	 */
name|rv
operator|=
name|as_map
argument_list|(
name|as
argument_list|,
operator|*
name|addrp
argument_list|,
name|len
argument_list|,
name|segvn_create
argument_list|,
name|zfod_argsp
argument_list|)
expr_stmt|;
name|as_rangeunlock
argument_list|(
name|as
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
return|return
operator|(
name|rv
operator|)
return|;
comment|/* 	 * Fill with data from read() 	 */
name|rv
operator|=
name|vn_rdwr
argument_list|(
name|UIO_READ
argument_list|,
name|vp
argument_list|,
operator|*
name|addrp
argument_list|,
name|len
argument_list|,
name|off
argument_list|,
name|UIO_USERSPACE
argument_list|,
literal|0
argument_list|,
operator|(
name|rlim64_t
operator|)
literal|0
argument_list|,
name|cred
argument_list|,
operator|&
name|resid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rv
operator|==
literal|0
operator|&&
name|resid
operator|!=
literal|0
condition|)
name|rv
operator|=
name|ENXIO
expr_stmt|;
if|if
condition|(
name|rv
operator|!=
literal|0
condition|)
block|{
name|as_rangelock
argument_list|(
name|as
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|as_unmap
argument_list|(
name|as
argument_list|,
operator|*
name|addrp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|as_rangeunlock
argument_list|(
name|as
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|rv
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * gfs_vop_inactive: VOP_INACTIVE() entry point  *  * Given a vnode that is a GFS file or directory, call gfs_file_inactive() or  * gfs_dir_inactive() as necessary, and kmem_free()s associated private data.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|gfs_vop_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|gfs_file_t
modifier|*
name|fp
init|=
name|vp
operator|->
name|v_data
decl_stmt|;
name|void
modifier|*
name|data
decl_stmt|;
if|if
condition|(
name|fp
operator|->
name|gfs_type
operator|==
name|GFS_DIR
condition|)
name|data
operator|=
name|gfs_dir_inactive
argument_list|(
name|vp
argument_list|)
expr_stmt|;
else|else
name|data
operator|=
name|gfs_file_inactive
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|data
argument_list|,
name|fp
operator|->
name|gfs_size
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

