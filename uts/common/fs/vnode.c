begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  */
end_comment

begin_comment
comment|/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
end_comment

begin_comment
comment|/*	  All Rights Reserved  	*/
end_comment

begin_comment
comment|/*  * University Copyright- Copyright (c) 1982, 1986, 1988  * The Regents of the University of California  * All Rights Reserved  *  * University Acknowledgment- Portions of this document are derived from  * software developed by the University of California, Berkeley, and its  * contributors.  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/t_lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/pathname.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs.h>
end_include

begin_include
include|#
directive|include
file|<sys/vfs_opreg.h>
end_include

begin_include
include|#
directive|include
file|<sys/vnode.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwstlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/fem.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/mode.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<c2/audit.h>
end_include

begin_include
include|#
directive|include
file|<sys/acl.h>
end_include

begin_include
include|#
directive|include
file|<sys/nbmlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_include
include|#
directive|include
file|<fs/fs_subr.h>
end_include

begin_include
include|#
directive|include
file|<sys/taskq.h>
end_include

begin_include
include|#
directive|include
file|<fs/fs_reparse.h>
end_include

begin_comment
comment|/* Determine if this vnode is a file that is read-only */
end_comment

begin_define
define|#
directive|define
name|ISROFILE
parameter_list|(
name|vp
parameter_list|)
define|\
value|((vp)->v_type != VCHR&& (vp)->v_type != VBLK&& \ 	    (vp)->v_type != VFIFO&& vn_is_readonly(vp))
end_define

begin_comment
comment|/* Tunable via /etc/system; used only by admin/install */
end_comment

begin_decl_stmt
name|int
name|nfs_global_client_only
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Array of vopstats_t for per-FS-type vopstats.  This array has the same  * number of entries as and parallel to the vfssw table.  (Arguably, it could  * be part of the vfssw table.)  Once it's initialized, it's accessed using  * the same fstype index that is used to index into the vfssw table.  */
end_comment

begin_decl_stmt
name|vopstats_t
modifier|*
modifier|*
name|vopstats_fstype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* vopstats initialization template used for fast initialization via bcopy() */
end_comment

begin_decl_stmt
specifier|static
name|vopstats_t
modifier|*
name|vs_templatep
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Kmem cache handle for vsk_anchor_t allocations */
end_comment

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|vsk_anchor_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file events cleanup routine */
end_comment

begin_function_decl
specifier|extern
name|void
name|free_fopdata
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Root of AVL tree for the kstats associated with vopstats.  Lock protects  * updates to vsktat_tree.  */
end_comment

begin_decl_stmt
name|avl_tree_t
name|vskstat_tree
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|kmutex_t
name|vskstat_tree_lock
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global variable which enables/disables the vopstats collection */
end_comment

begin_decl_stmt
name|int
name|vopstats_enabled
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * forward declarations for internal vnode specific data (vsd)  */
end_comment

begin_function_decl
specifier|static
name|void
modifier|*
name|vsd_realloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * forward declarations for reparse point functions  */
end_comment

begin_function_decl
specifier|static
name|int
name|fs_reparse_mark
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|xvattr_t
modifier|*
name|xvattr
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * VSD -- VNODE SPECIFIC DATA  * The v_data pointer is typically used by a file system to store a  * pointer to the file system's private node (e.g. ufs inode, nfs rnode).  * However, there are times when additional project private data needs  * to be stored separately from the data (node) pointed to by v_data.  * This additional data could be stored by the file system itself or  * by a completely different kernel entity.  VSD provides a way for  * callers to obtain a key and store a pointer to private data associated  * with a vnode.  *  * Callers are responsible for protecting the vsd by holding v_vsd_lock  * for calls to vsd_set() and vsd_get().  */
end_comment

begin_comment
comment|/*  * vsd_lock protects:  *   vsd_nkeys - creation and deletion of vsd keys  *   vsd_list - insertion and deletion of vsd_node in the vsd_list  *   vsd_destructor - adding and removing destructors to the list  */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|vsd_lock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint_t
name|vsd_nkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of destructor array */
end_comment

begin_comment
comment|/* list of vsd_node's */
end_comment

begin_decl_stmt
specifier|static
name|list_t
modifier|*
name|vsd_list
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* per-key destructor funcs */
end_comment

begin_function_decl
specifier|static
name|void
function_decl|(
modifier|*
modifier|*
name|vsd_destructor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * The following is the common set of actions needed to update the  * vopstats structure from a vnode op.  Both VOPSTATS_UPDATE() and  * VOPSTATS_UPDATE_IO() do almost the same thing, except for the  * recording of the bytes transferred.  Since the code is similar  * but small, it is nearly a duplicate.  Consequently any changes  * to one may need to be reflected in the other.  * Rundown of the variables:  * vp - Pointer to the vnode  * counter - Partial name structure member to update in vopstats for counts  * bytecounter - Partial name structure member to update in vopstats for bytes  * bytesval - Value to update in vopstats for bytes  * fstype - Index into vsanchor_fstype[], same as index into vfssw[]  * vsp - Pointer to vopstats structure (either in vfs or vsanchor_fstype[i])  */
end_comment

begin_define
define|#
directive|define
name|VOPSTATS_UPDATE
parameter_list|(
name|vp
parameter_list|,
name|counter
parameter_list|)
value|{					\ 	vfs_t *vfsp = (vp)->v_vfsp;					\ 	if (vfsp&& vfsp->vfs_implp&&					\ 	    (vfsp->vfs_flag& VFS_STATS)&& (vp)->v_type != VBAD) {	\ 		vopstats_t *vsp =&vfsp->vfs_vopstats;			\ 		uint64_t *stataddr =&(vsp->n##counter.value.ui64);	\ 		extern void __dtrace_probe___fsinfo_##counter(vnode_t *, \ 		    size_t, uint64_t *);				\ 		__dtrace_probe___fsinfo_##counter(vp, 0, stataddr);	\ 		(*stataddr)++;						\ 		if ((vsp = vfsp->vfs_fstypevsp) != NULL) {		\ 			vsp->n##counter.value.ui64++;			\ 		}							\ 	}								\ }
end_define

begin_define
define|#
directive|define
name|VOPSTATS_UPDATE_IO
parameter_list|(
name|vp
parameter_list|,
name|counter
parameter_list|,
name|bytecounter
parameter_list|,
name|bytesval
parameter_list|)
value|{	\ 	vfs_t *vfsp = (vp)->v_vfsp;					\ 	if (vfsp&& vfsp->vfs_implp&&					\ 	    (vfsp->vfs_flag& VFS_STATS)&& (vp)->v_type != VBAD) {	\ 		vopstats_t *vsp =&vfsp->vfs_vopstats;			\ 		uint64_t *stataddr =&(vsp->n##counter.value.ui64);	\ 		extern void __dtrace_probe___fsinfo_##counter(vnode_t *, \ 		    size_t, uint64_t *);				\ 		__dtrace_probe___fsinfo_##counter(vp, bytesval, stataddr); \ 		(*stataddr)++;						\ 		vsp->bytecounter.value.ui64 += bytesval;		\ 		if ((vsp = vfsp->vfs_fstypevsp) != NULL) {		\ 			vsp->n##counter.value.ui64++;			\ 			vsp->bytecounter.value.ui64 += bytesval;	\ 		}							\ 	}								\ }
end_define

begin_comment
comment|/*  * If the filesystem does not support XIDs map credential  * If the vfsp is NULL, perhaps we should also map?  */
end_comment

begin_define
define|#
directive|define
name|VOPXID_MAP_CR
parameter_list|(
name|vp
parameter_list|,
name|cr
parameter_list|)
value|{					\ 	vfs_t *vfsp = (vp)->v_vfsp;					\ 	if (vfsp != NULL&& (vfsp->vfs_flag& VFS_XID) == 0)		\ 		cr = crgetmapped(cr);					\ 	}
end_define

begin_comment
comment|/*  * Convert stat(2) formats to vnode types and vice versa.  (Knows about  * numerical order of S_IFMT and vnode types.)  */
end_comment

begin_decl_stmt
name|enum
name|vtype
name|iftovt_tab
index|[]
init|=
block|{
name|VNON
block|,
name|VFIFO
block|,
name|VCHR
block|,
name|VNON
block|,
name|VDIR
block|,
name|VNON
block|,
name|VBLK
block|,
name|VNON
block|,
name|VREG
block|,
name|VNON
block|,
name|VLNK
block|,
name|VNON
block|,
name|VSOCK
block|,
name|VNON
block|,
name|VNON
block|,
name|VNON
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ushort_t
name|vttoif_tab
index|[]
init|=
block|{
literal|0
block|,
name|S_IFREG
block|,
name|S_IFDIR
block|,
name|S_IFBLK
block|,
name|S_IFCHR
block|,
name|S_IFLNK
block|,
name|S_IFIFO
block|,
name|S_IFDOOR
block|,
literal|0
block|,
name|S_IFSOCK
block|,
name|S_IFPORT
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The system vnode cache.  */
end_comment

begin_decl_stmt
name|kmem_cache_t
modifier|*
name|vn_cache
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Vnode operations vector.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|fs_operation_trans_def_t
name|vn_ops_table
index|[]
init|=
block|{
name|VOPNAME_OPEN
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_open
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_CLOSE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_close
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_READ
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_read
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_WRITE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_write
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_IOCTL
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_ioctl
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_SETFL
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_setfl
argument_list|)
block|,
name|fs_setfl
block|,
name|fs_nosys
block|,
name|VOPNAME_GETATTR
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_getattr
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_SETATTR
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_setattr
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_ACCESS
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_access
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_LOOKUP
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_lookup
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_CREATE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_create
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_REMOVE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_remove
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_LINK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_link
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_RENAME
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_rename
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_MKDIR
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_mkdir
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_RMDIR
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_rmdir
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_READDIR
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_readdir
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_SYMLINK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_symlink
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_READLINK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_readlink
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_FSYNC
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_fsync
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_INACTIVE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_inactive
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_FID
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_fid
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_RWLOCK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_rwlock
argument_list|)
block|,
name|fs_rwlock
block|,
name|fs_rwlock
block|,
name|VOPNAME_RWUNLOCK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_rwunlock
argument_list|)
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_rwunlock
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_rwunlock
block|,
comment|/* no errors allowed */
name|VOPNAME_SEEK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_seek
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_CMP
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_cmp
argument_list|)
block|,
name|fs_cmp
block|,
name|fs_cmp
block|,
comment|/* no errors allowed */
name|VOPNAME_FRLOCK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_frlock
argument_list|)
block|,
name|fs_frlock
block|,
name|fs_nosys
block|,
name|VOPNAME_SPACE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_space
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_REALVP
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_realvp
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_GETPAGE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_getpage
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_PUTPAGE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_putpage
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_MAP
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_map
argument_list|)
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_nosys_map
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_nosys_map
block|,
name|VOPNAME_ADDMAP
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_addmap
argument_list|)
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_nosys_addmap
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_nosys_addmap
block|,
name|VOPNAME_DELMAP
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_delmap
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_POLL
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_poll
argument_list|)
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_poll
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_nosys_poll
block|,
name|VOPNAME_DUMP
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_dump
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_PATHCONF
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_pathconf
argument_list|)
block|,
name|fs_pathconf
block|,
name|fs_nosys
block|,
name|VOPNAME_PAGEIO
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_pageio
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_DUMPCTL
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_dumpctl
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_DISPOSE
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_dispose
argument_list|)
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_dispose
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_nodispose
block|,
name|VOPNAME_SETSECATTR
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_setsecattr
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_GETSECATTR
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_getsecattr
argument_list|)
block|,
name|fs_fab_acl
block|,
name|fs_nosys
block|,
name|VOPNAME_SHRLOCK
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_shrlock
argument_list|)
block|,
name|fs_shrlock
block|,
name|fs_nosys
block|,
name|VOPNAME_VNEVENT
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_vnevent
argument_list|)
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_vnevent_nosupport
block|,
operator|(
name|fs_generic_func_p
operator|)
name|fs_vnevent_nosupport
block|,
name|VOPNAME_REQZCBUF
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_reqzcbuf
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|VOPNAME_RETZCBUF
block|,
name|offsetof
argument_list|(
expr|struct
name|vnodeops
argument_list|,
name|vop_retzcbuf
argument_list|)
block|,
name|fs_nosys
block|,
name|fs_nosys
block|,
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Extensible attribute (xva) routines. */
end_comment

begin_comment
comment|/*  * Zero out the structure, set the size of the requested/returned bitmaps,  * set AT_XVATTR in the embedded vattr_t's va_mask, and set up the pointer  * to the returned attributes array.  */
end_comment

begin_function
name|void
name|xva_init
parameter_list|(
name|xvattr_t
modifier|*
name|xvap
parameter_list|)
block|{
name|bzero
argument_list|(
name|xvap
argument_list|,
sizeof|sizeof
argument_list|(
name|xvattr_t
argument_list|)
argument_list|)
expr_stmt|;
name|xvap
operator|->
name|xva_mapsize
operator|=
name|XVA_MAPSIZE
expr_stmt|;
name|xvap
operator|->
name|xva_magic
operator|=
name|XVA_MAGIC
expr_stmt|;
name|xvap
operator|->
name|xva_vattr
operator|.
name|va_mask
operator|=
name|AT_XVATTR
expr_stmt|;
name|xvap
operator|->
name|xva_rtnattrmapp
operator|=
operator|&
operator|(
name|xvap
operator|->
name|xva_rtnattrmap
operator|)
index|[
literal|0
index|]
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If AT_XVATTR is set, returns a pointer to the embedded xoptattr_t  * structure.  Otherwise, returns NULL.  */
end_comment

begin_function
name|xoptattr_t
modifier|*
name|xva_getxoptattr
parameter_list|(
name|xvattr_t
modifier|*
name|xvap
parameter_list|)
block|{
name|xoptattr_t
modifier|*
name|xoap
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|xvap
operator|->
name|xva_vattr
operator|.
name|va_mask
operator|&
name|AT_XVATTR
condition|)
name|xoap
operator|=
operator|&
name|xvap
operator|->
name|xva_xoptattrs
expr_stmt|;
return|return
operator|(
name|xoap
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used by the AVL routines to compare two vsk_anchor_t structures in the tree.  * We use the f_fsid reported by VFS_STATVFS() since we use that for the  * kstat name.  */
end_comment

begin_function
specifier|static
name|int
name|vska_compar
parameter_list|(
specifier|const
name|void
modifier|*
name|n1
parameter_list|,
specifier|const
name|void
modifier|*
name|n2
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ulong_t
name|p1
init|=
operator|(
operator|(
name|vsk_anchor_t
operator|*
operator|)
name|n1
operator|)
operator|->
name|vsk_fsid
decl_stmt|;
name|ulong_t
name|p2
init|=
operator|(
operator|(
name|vsk_anchor_t
operator|*
operator|)
name|n2
operator|)
operator|->
name|vsk_fsid
decl_stmt|;
if|if
condition|(
name|p1
operator|<
name|p2
condition|)
block|{
name|ret
operator|=
operator|-
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p1
operator|>
name|p2
condition|)
block|{
name|ret
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Used to create a single template which will be bcopy()ed to a newly  * allocated vsanchor_combo_t structure in new_vsanchor(), below.  */
end_comment

begin_function
specifier|static
name|vopstats_t
modifier|*
name|create_vopstats_template
parameter_list|()
block|{
name|vopstats_t
modifier|*
name|vsp
decl_stmt|;
name|vsp
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vopstats_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vsp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vsp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Start fresh */
comment|/* VOP_OPEN */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nopen
argument_list|,
literal|"nopen"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_CLOSE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nclose
argument_list|,
literal|"nclose"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_READ I/O */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nread
argument_list|,
literal|"nread"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|read_bytes
argument_list|,
literal|"read_bytes"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_WRITE I/O */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nwrite
argument_list|,
literal|"nwrite"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|write_bytes
argument_list|,
literal|"write_bytes"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_IOCTL */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nioctl
argument_list|,
literal|"nioctl"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_SETFL */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nsetfl
argument_list|,
literal|"nsetfl"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_GETATTR */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ngetattr
argument_list|,
literal|"ngetattr"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_SETATTR */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nsetattr
argument_list|,
literal|"nsetattr"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_ACCESS */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|naccess
argument_list|,
literal|"naccess"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_LOOKUP */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nlookup
argument_list|,
literal|"nlookup"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_CREATE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ncreate
argument_list|,
literal|"ncreate"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_REMOVE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nremove
argument_list|,
literal|"nremove"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_LINK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nlink
argument_list|,
literal|"nlink"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_RENAME */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nrename
argument_list|,
literal|"nrename"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_MKDIR */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nmkdir
argument_list|,
literal|"nmkdir"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_RMDIR */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nrmdir
argument_list|,
literal|"nrmdir"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_READDIR I/O */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nreaddir
argument_list|,
literal|"nreaddir"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|readdir_bytes
argument_list|,
literal|"readdir_bytes"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_SYMLINK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nsymlink
argument_list|,
literal|"nsymlink"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_READLINK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nreadlink
argument_list|,
literal|"nreadlink"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_FSYNC */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nfsync
argument_list|,
literal|"nfsync"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_INACTIVE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ninactive
argument_list|,
literal|"ninactive"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_FID */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nfid
argument_list|,
literal|"nfid"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_RWLOCK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nrwlock
argument_list|,
literal|"nrwlock"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_RWUNLOCK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nrwunlock
argument_list|,
literal|"nrwunlock"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_SEEK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nseek
argument_list|,
literal|"nseek"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_CMP */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ncmp
argument_list|,
literal|"ncmp"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_FRLOCK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nfrlock
argument_list|,
literal|"nfrlock"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_SPACE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nspace
argument_list|,
literal|"nspace"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_REALVP */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nrealvp
argument_list|,
literal|"nrealvp"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_GETPAGE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ngetpage
argument_list|,
literal|"ngetpage"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_PUTPAGE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nputpage
argument_list|,
literal|"nputpage"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_MAP */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nmap
argument_list|,
literal|"nmap"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_ADDMAP */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|naddmap
argument_list|,
literal|"naddmap"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_DELMAP */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ndelmap
argument_list|,
literal|"ndelmap"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_POLL */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|npoll
argument_list|,
literal|"npoll"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_DUMP */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ndump
argument_list|,
literal|"ndump"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_PATHCONF */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|npathconf
argument_list|,
literal|"npathconf"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_PAGEIO */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|npageio
argument_list|,
literal|"npageio"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_DUMPCTL */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ndumpctl
argument_list|,
literal|"ndumpctl"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_DISPOSE */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ndispose
argument_list|,
literal|"ndispose"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_SETSECATTR */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nsetsecattr
argument_list|,
literal|"nsetsecattr"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_GETSECATTR */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|ngetsecattr
argument_list|,
literal|"ngetsecattr"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_SHRLOCK */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nshrlock
argument_list|,
literal|"nshrlock"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_VNEVENT */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nvnevent
argument_list|,
literal|"nvnevent"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_REQZCBUF */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nreqzcbuf
argument_list|,
literal|"nreqzcbuf"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
comment|/* VOP_RETZCBUF */
name|kstat_named_init
argument_list|(
operator|&
name|vsp
operator|->
name|nretzcbuf
argument_list|,
literal|"nretzcbuf"
argument_list|,
name|KSTAT_DATA_UINT64
argument_list|)
expr_stmt|;
return|return
operator|(
name|vsp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Creates a kstat structure associated with a vopstats structure.  */
end_comment

begin_function
name|kstat_t
modifier|*
name|new_vskstat
parameter_list|(
name|char
modifier|*
name|ksname
parameter_list|,
name|vopstats_t
modifier|*
name|vsp
parameter_list|)
block|{
name|kstat_t
modifier|*
name|ksp
decl_stmt|;
if|if
condition|(
operator|!
name|vopstats_enabled
condition|)
block|{
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|ksp
operator|=
name|kstat_create
argument_list|(
literal|"unix"
argument_list|,
literal|0
argument_list|,
name|ksname
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
name|vopstats_t
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
operator||
name|KSTAT_FLAG_WRITABLE
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksp
condition|)
block|{
name|ksp
operator|->
name|ks_data
operator|=
name|vsp
expr_stmt|;
name|kstat_install
argument_list|(
name|ksp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ksp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from vfsinit() to initialize the support mechanisms for vopstats  */
end_comment

begin_function
name|void
name|vopstats_startup
parameter_list|()
block|{
if|if
condition|(
operator|!
name|vopstats_enabled
condition|)
return|return;
comment|/* 	 * Creates the AVL tree which holds per-vfs vopstat anchors.  This 	 * is necessary since we need to check if a kstat exists before we 	 * attempt to create it.  Also, initialize its lock. 	 */
name|avl_create
argument_list|(
operator|&
name|vskstat_tree
argument_list|,
name|vska_compar
argument_list|,
sizeof|sizeof
argument_list|(
name|vsk_anchor_t
argument_list|)
argument_list|,
name|offsetof
argument_list|(
name|vsk_anchor_t
argument_list|,
name|vsk_node
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vskstat_tree_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vsk_anchor_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"vsk_anchor_cache"
argument_list|,
sizeof|sizeof
argument_list|(
name|vsk_anchor_t
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|uintptr_t
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Set up the array of pointers for the vopstats-by-FS-type. 	 * The entries will be allocated/initialized as each file system 	 * goes through modload/mod_installfs. 	 */
name|vopstats_fstype
operator|=
operator|(
name|vopstats_t
operator|*
operator|*
operator|)
name|kmem_zalloc
argument_list|(
operator|(
sizeof|sizeof
argument_list|(
name|vopstats_t
operator|*
argument_list|)
operator|*
name|nfstype
operator|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* Set up the global vopstats initialization template */
name|vs_templatep
operator|=
name|create_vopstats_template
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * We need to have the all of the counters zeroed.  * The initialization of the vopstats_t includes on the order of  * 50 calls to kstat_named_init().  Rather that do that on every call,  * we do it once in a template (vs_templatep) then bcopy it over.  */
end_comment

begin_function
name|void
name|initialize_vopstats
parameter_list|(
name|vopstats_t
modifier|*
name|vsp
parameter_list|)
block|{
if|if
condition|(
name|vsp
operator|==
name|NULL
condition|)
return|return;
name|bcopy
argument_list|(
name|vs_templatep
argument_list|,
name|vsp
argument_list|,
sizeof|sizeof
argument_list|(
name|vopstats_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * If possible, determine which vopstats by fstype to use and  * return a pointer to the caller.  */
end_comment

begin_function
name|vopstats_t
modifier|*
name|get_fstype_vopstats
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|,
name|struct
name|vfssw
modifier|*
name|vswp
parameter_list|)
block|{
name|int
name|fstype
init|=
literal|0
decl_stmt|;
comment|/* Index into vfssw[] */
name|vopstats_t
modifier|*
name|vsp
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
operator|||
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_STATS
operator|)
operator|==
literal|0
operator|||
operator|!
name|vopstats_enabled
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * Set up the fstype.  We go to so much trouble because all versions 	 * of NFS use the same fstype in their vfs even though they have 	 * distinct entries in the vfssw[] table. 	 * NOTE: A special vfs (e.g., EIO_vfs) may not have an entry. 	 */
if|if
condition|(
name|vswp
condition|)
block|{
name|fstype
operator|=
name|vswp
operator|-
name|vfssw
expr_stmt|;
comment|/* Gets us the index */
block|}
else|else
block|{
name|fstype
operator|=
name|vfsp
operator|->
name|vfs_fstype
expr_stmt|;
block|}
comment|/* 	 * Point to the per-fstype vopstats. The only valid values are 	 * non-zero positive values less than the number of vfssw[] table 	 * entries. 	 */
if|if
condition|(
name|fstype
operator|>
literal|0
operator|&&
name|fstype
operator|<
name|nfstype
condition|)
block|{
name|vsp
operator|=
name|vopstats_fstype
index|[
name|fstype
index|]
expr_stmt|;
block|}
return|return
operator|(
name|vsp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Generate a kstat name, create the kstat structure, and allocate a  * vsk_anchor_t to hold it together.  Return the pointer to the vsk_anchor_t  * to the caller.  This must only be called from a mount.  */
end_comment

begin_function
name|vsk_anchor_t
modifier|*
name|get_vskstat_anchor
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|char
name|kstatstr
index|[
name|KSTAT_STRLEN
index|]
decl_stmt|;
comment|/* kstat name for vopstats */
name|statvfs64_t
name|statvfsbuf
decl_stmt|;
comment|/* Needed to find f_fsid */
name|vsk_anchor_t
modifier|*
name|vskp
init|=
name|NULL
decl_stmt|;
comment|/* vfs<--> kstat anchor */
name|kstat_t
modifier|*
name|ksp
decl_stmt|;
comment|/* Ptr to new kstat */
name|avl_index_t
name|where
decl_stmt|;
comment|/* Location in the AVL tree */
if|if
condition|(
name|vfsp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_implp
operator|==
name|NULL
operator|||
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_STATS
operator|)
operator|==
literal|0
operator|||
operator|!
name|vopstats_enabled
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* Need to get the fsid to build a kstat name */
if|if
condition|(
name|VFS_STATVFS
argument_list|(
name|vfsp
argument_list|,
operator|&
name|statvfsbuf
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Create a name for our kstats based on fsid */
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|kstatstr
argument_list|,
name|KSTAT_STRLEN
argument_list|,
literal|"%s%lx"
argument_list|,
name|VOPSTATS_STR
argument_list|,
name|statvfsbuf
operator|.
name|f_fsid
argument_list|)
expr_stmt|;
comment|/* Allocate and initialize the vsk_anchor_t */
name|vskp
operator|=
name|kmem_cache_alloc
argument_list|(
name|vsk_anchor_cache
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|vskp
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vskp
argument_list|)
argument_list|)
expr_stmt|;
name|vskp
operator|->
name|vsk_fsid
operator|=
name|statvfsbuf
operator|.
name|f_fsid
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vskstat_tree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
operator|&
name|vskstat_tree
argument_list|,
name|vskp
argument_list|,
operator|&
name|where
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|avl_insert
argument_list|(
operator|&
name|vskstat_tree
argument_list|,
name|vskp
argument_list|,
name|where
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vskstat_tree_lock
argument_list|)
expr_stmt|;
comment|/* 			 * Now that we've got the anchor in the AVL 			 * tree, we can create the kstat. 			 */
name|ksp
operator|=
name|new_vskstat
argument_list|(
name|kstatstr
argument_list|,
operator|&
name|vfsp
operator|->
name|vfs_vopstats
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksp
condition|)
block|{
name|vskp
operator|->
name|vsk_ksp
operator|=
name|ksp
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Oops, found one! Release memory and lock. */
name|mutex_exit
argument_list|(
operator|&
name|vskstat_tree_lock
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|vsk_anchor_cache
argument_list|,
name|vskp
argument_list|)
expr_stmt|;
name|vskp
operator|=
name|NULL
expr_stmt|;
block|}
block|}
return|return
operator|(
name|vskp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * We're in the process of tearing down the vfs and need to cleanup  * the data structures associated with the vopstats. Must only be called  * from dounmount().  */
end_comment

begin_function
name|void
name|teardown_vopstats
parameter_list|(
name|vfs_t
modifier|*
name|vfsp
parameter_list|)
block|{
name|vsk_anchor_t
modifier|*
name|vskap
decl_stmt|;
name|avl_index_t
name|where
decl_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_implp
operator|==
name|NULL
operator|||
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_STATS
operator|)
operator|==
literal|0
operator|||
operator|!
name|vopstats_enabled
condition|)
return|return;
comment|/* This is a safe check since VFS_STATS must be set (see above) */
if|if
condition|(
operator|(
name|vskap
operator|=
name|vfsp
operator|->
name|vfs_vskap
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* Whack the pointer right away */
name|vfsp
operator|->
name|vfs_vskap
operator|=
name|NULL
expr_stmt|;
comment|/* Lock the tree, remove the node, and delete the kstat */
name|mutex_enter
argument_list|(
operator|&
name|vskstat_tree_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|avl_find
argument_list|(
operator|&
name|vskstat_tree
argument_list|,
name|vskap
argument_list|,
operator|&
name|where
argument_list|)
condition|)
block|{
name|avl_remove
argument_list|(
operator|&
name|vskstat_tree
argument_list|,
name|vskap
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vskap
operator|->
name|vsk_ksp
condition|)
block|{
name|kstat_delete
argument_list|(
name|vskap
operator|->
name|vsk_ksp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vskstat_tree_lock
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|vsk_anchor_cache
argument_list|,
name|vskap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read or write a vnode.  Called from kernel code.  */
end_comment

begin_function
name|int
name|vn_rdwr
parameter_list|(
name|enum
name|uio_rw
name|rw
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|caddr_t
name|base
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|rlim64_t
name|ulimit
parameter_list|,
comment|/* meaningful only if rw is UIO_WRITE */
name|cred_t
modifier|*
name|cr
parameter_list|,
name|ssize_t
modifier|*
name|residp
parameter_list|)
block|{
name|struct
name|uio
name|uio
decl_stmt|;
name|struct
name|iovec
name|iov
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|in_crit
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|rw
operator|==
name|UIO_WRITE
operator|&&
name|ISROFILE
argument_list|(
name|vp
argument_list|)
condition|)
return|return
operator|(
name|EROFS
operator|)
return|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|iov
operator|.
name|iov_base
operator|=
name|base
expr_stmt|;
name|iov
operator|.
name|iov_len
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_iov
operator|=
operator|&
name|iov
expr_stmt|;
name|uio
operator|.
name|uio_iovcnt
operator|=
literal|1
expr_stmt|;
name|uio
operator|.
name|uio_loffset
operator|=
name|offset
expr_stmt|;
name|uio
operator|.
name|uio_segflg
operator|=
operator|(
name|short
operator|)
name|seg
expr_stmt|;
name|uio
operator|.
name|uio_resid
operator|=
name|len
expr_stmt|;
name|uio
operator|.
name|uio_llimit
operator|=
name|ulimit
expr_stmt|;
comment|/* 	 * We have to enter the critical region before calling VOP_RWLOCK 	 * to avoid a deadlock with ufs. 	 */
if|if
condition|(
name|nbl_need_check
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|int
name|svmand
decl_stmt|;
name|nbl_start_crit
argument_list|(
name|vp
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|in_crit
operator|=
literal|1
expr_stmt|;
name|error
operator|=
name|nbl_svmand
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|,
operator|&
name|svmand
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
goto|goto
name|done
goto|;
if|if
condition|(
name|nbl_conflict
argument_list|(
name|vp
argument_list|,
name|rw
operator|==
name|UIO_WRITE
condition|?
name|NBL_WRITE
else|:
name|NBL_READ
argument_list|,
name|uio
operator|.
name|uio_offset
argument_list|,
name|uio
operator|.
name|uio_resid
argument_list|,
name|svmand
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
operator|(
name|void
operator|)
name|VOP_RWLOCK
argument_list|(
name|vp
argument_list|,
name|rw
operator|==
name|UIO_WRITE
condition|?
name|V_WRITELOCK_TRUE
else|:
name|V_WRITELOCK_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|rw
operator|==
name|UIO_WRITE
condition|)
block|{
name|uio
operator|.
name|uio_fmode
operator|=
name|FWRITE
expr_stmt|;
name|uio
operator|.
name|uio_extflg
operator|=
name|UIO_COPY_DEFAULT
expr_stmt|;
name|error
operator|=
name|VOP_WRITE
argument_list|(
name|vp
argument_list|,
operator|&
name|uio
argument_list|,
name|ioflag
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|uio
operator|.
name|uio_fmode
operator|=
name|FREAD
expr_stmt|;
name|uio
operator|.
name|uio_extflg
operator|=
name|UIO_COPY_CACHED
expr_stmt|;
name|error
operator|=
name|VOP_READ
argument_list|(
name|vp
argument_list|,
operator|&
name|uio
argument_list|,
name|ioflag
argument_list|,
name|cr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|VOP_RWUNLOCK
argument_list|(
name|vp
argument_list|,
name|rw
operator|==
name|UIO_WRITE
condition|?
name|V_WRITELOCK_TRUE
else|:
name|V_WRITELOCK_FALSE
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|residp
condition|)
operator|*
name|residp
operator|=
name|uio
operator|.
name|uio_resid
expr_stmt|;
elseif|else
if|if
condition|(
name|uio
operator|.
name|uio_resid
condition|)
name|error
operator|=
name|EIO
expr_stmt|;
name|done
label|:
if|if
condition|(
name|in_crit
condition|)
name|nbl_end_crit
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Release a vnode.  Call VOP_INACTIVE on last reference or  * decrement reference count.  *  * To avoid race conditions, the v_count is left at 1 for  * the call to VOP_INACTIVE. This prevents another thread  * from reclaiming and releasing the vnode *before* the  * VOP_INACTIVE routine has a chance to destroy the vnode.  * We can't have more than 1 thread calling VOP_INACTIVE  * on a vnode.  */
end_comment

begin_function
name|void
name|vn_rele
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|vp
operator|->
name|v_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_count
operator|==
literal|1
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|VOP_INACTIVE
argument_list|(
name|vp
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|->
name|v_count
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Release a vnode referenced by the DNLC. Multiple DNLC references are treated  * as a single reference, so v_count is not decremented until the last DNLC hold  * is released. This makes it possible to distinguish vnodes that are referenced  * only by the DNLC.  */
end_comment

begin_function
name|void
name|vn_rele_dnlc
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|VERIFY
argument_list|(
operator|(
name|vp
operator|->
name|v_count
operator|>
literal|0
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_count_dnlc
operator|>
literal|0
operator|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|vp
operator|->
name|v_count_dnlc
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|vp
operator|->
name|v_count
operator|==
literal|1
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|VOP_INACTIVE
argument_list|(
name|vp
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|->
name|v_count
operator|--
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Like vn_rele() except that it clears v_stream under v_lock.  * This is used by sockfs when it dismantels the association between  * the sockfs node and the vnode in the underlaying file system.  * v_lock has to be held to prevent a thread coming through the lookupname  * path from accessing a stream head that is going away.  */
end_comment

begin_function
name|void
name|vn_rele_stream
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|vp
operator|->
name|v_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_stream
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_count
operator|==
literal|1
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|VOP_INACTIVE
argument_list|(
name|vp
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|->
name|v_count
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|vn_rele_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|VOP_INACTIVE
argument_list|(
name|vp
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Like vn_rele() except if we are going to call VOP_INACTIVE() then do it  * asynchronously using a taskq. This can avoid deadlocks caused by re-entering  * the file system as a result of releasing the vnode. Note, file systems  * already have to handle the race where the vnode is incremented before the  * inactive routine is called and does its locking.  *  * Warning: Excessive use of this routine can lead to performance problems.  * This is because taskqs throttle back allocation if too many are created.  */
end_comment

begin_function
name|void
name|vn_rele_async
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|taskq_t
modifier|*
name|taskq
parameter_list|)
block|{
name|VERIFY
argument_list|(
name|vp
operator|->
name|v_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_count
operator|==
literal|1
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|VERIFY
argument_list|(
name|taskq_dispatch
argument_list|(
name|taskq
argument_list|,
operator|(
name|task_func_t
operator|*
operator|)
name|vn_rele_inactive
argument_list|,
name|vp
argument_list|,
name|TQ_SLEEP
argument_list|)
operator|!=
name|NULL
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|->
name|v_count
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vn_open
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|int
name|filemode
parameter_list|,
name|int
name|createmode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|crwhy
parameter_list|,
name|mode_t
name|umask
parameter_list|)
block|{
return|return
operator|(
name|vn_openat
argument_list|(
name|pnamep
argument_list|,
name|seg
argument_list|,
name|filemode
argument_list|,
name|createmode
argument_list|,
name|vpp
argument_list|,
name|crwhy
argument_list|,
name|umask
argument_list|,
name|NULL
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open/create a vnode.  * This may be callable by the kernel, the only known use  * of user context being that the current user credentials  * are used for permissions.  crwhy is defined iff filemode& FCREAT.  */
end_comment

begin_function
name|int
name|vn_openat
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|int
name|filemode
parameter_list|,
name|int
name|createmode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|crwhy
parameter_list|,
name|mode_t
name|umask
parameter_list|,
name|struct
name|vnode
modifier|*
name|startvp
parameter_list|,
name|int
name|fd
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|int
name|accessflags
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|in_crit
init|=
literal|0
decl_stmt|;
name|int
name|open_done
init|=
literal|0
decl_stmt|;
name|int
name|shrlock_done
init|=
literal|0
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|enum
name|symfollow
name|follow
decl_stmt|;
name|int
name|estale_retry
init|=
literal|0
decl_stmt|;
name|struct
name|shrlock
name|shr
decl_stmt|;
name|struct
name|shr_locowner
name|shr_own
decl_stmt|;
name|mode
operator|=
literal|0
expr_stmt|;
name|accessflags
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FREAD
condition|)
name|mode
operator||=
name|VREAD
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
operator|(
name|FWRITE
operator||
name|FTRUNC
operator|)
condition|)
name|mode
operator||=
name|VWRITE
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
operator|(
name|FSEARCH
operator||
name|FEXEC
operator||
name|FXATTRDIROPEN
operator|)
condition|)
name|mode
operator||=
name|VEXEC
expr_stmt|;
comment|/* symlink interpretation */
if|if
condition|(
name|filemode
operator|&
name|FNOFOLLOW
condition|)
name|follow
operator|=
name|NO_FOLLOW
expr_stmt|;
else|else
name|follow
operator|=
name|FOLLOW
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FAPPEND
condition|)
name|accessflags
operator||=
name|V_APPEND
expr_stmt|;
name|top
label|:
if|if
condition|(
name|filemode
operator|&
name|FCREAT
condition|)
block|{
name|enum
name|vcexcl
name|excl
decl_stmt|;
comment|/* 		 * Wish to create a file. 		 */
name|vattr
operator|.
name|va_type
operator|=
name|VREG
expr_stmt|;
name|vattr
operator|.
name|va_mode
operator|=
name|createmode
expr_stmt|;
name|vattr
operator|.
name|va_mask
operator|=
name|AT_TYPE
operator||
name|AT_MODE
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FTRUNC
condition|)
block|{
name|vattr
operator|.
name|va_size
operator|=
literal|0
expr_stmt|;
name|vattr
operator|.
name|va_mask
operator||=
name|AT_SIZE
expr_stmt|;
block|}
if|if
condition|(
name|filemode
operator|&
name|FEXCL
condition|)
name|excl
operator|=
name|EXCL
expr_stmt|;
else|else
name|excl
operator|=
name|NONEXCL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|vn_createat
argument_list|(
name|pnamep
argument_list|,
name|seg
argument_list|,
operator|&
name|vattr
argument_list|,
name|excl
argument_list|,
name|mode
argument_list|,
operator|&
name|vp
argument_list|,
name|crwhy
argument_list|,
operator|(
name|filemode
operator|&
operator|~
operator|(
name|FTRUNC
operator||
name|FEXCL
operator|)
operator|)
argument_list|,
name|umask
argument_list|,
name|startvp
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
block|}
else|else
block|{
comment|/* 		 * Wish to open a file.  Just look it up. 		 */
if|if
condition|(
name|error
operator|=
name|lookupnameat
argument_list|(
name|pnamep
argument_list|,
name|seg
argument_list|,
name|follow
argument_list|,
name|NULLVPP
argument_list|,
operator|&
name|vp
argument_list|,
name|startvp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 		 * Get the attributes to check whether file is large. 		 * We do this only if the FOFFMAX flag is not set and 		 * only for regular files. 		 */
if|if
condition|(
operator|!
operator|(
name|filemode
operator|&
name|FOFFMAX
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|vattr
operator|.
name|va_mask
operator|=
name|AT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vattr
operator|.
name|va_size
operator|>
operator|(
name|u_offset_t
operator|)
name|MAXOFF32_T
condition|)
block|{
comment|/* 				 * Large File API - regular open fails 				 * if FOFFMAX flag is set in file mode 				 */
name|error
operator|=
name|EOVERFLOW
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 		 * Can't write directories, active texts, or 		 * read-only filesystems.  Can't truncate files 		 * on which mandatory locking is in effect. 		 */
if|if
condition|(
name|filemode
operator|&
operator|(
name|FWRITE
operator||
name|FTRUNC
operator|)
condition|)
block|{
comment|/* 			 * Allow writable directory if VDIROPEN flag is set. 			 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
operator|&&
operator|!
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VDIROPEN
operator|)
condition|)
block|{
name|error
operator|=
name|EISDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|ISROFILE
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * Can't truncate files on which 			 * sysv mandatory locking is in effect. 			 */
if|if
condition|(
name|filemode
operator|&
name|FTRUNC
condition|)
block|{
name|vnode_t
modifier|*
name|rvp
decl_stmt|;
if|if
condition|(
name|VOP_REALVP
argument_list|(
name|vp
argument_list|,
operator|&
name|rvp
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|rvp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
name|rvp
operator|->
name|v_filocks
operator|!=
name|NULL
condition|)
block|{
name|vattr
operator|.
name|va_mask
operator|=
name|AT_MODE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
literal|0
operator|&&
name|MANDLOCK
argument_list|(
name|vp
argument_list|,
name|vattr
operator|.
name|va_mode
argument_list|)
condition|)
name|error
operator|=
name|EAGAIN
expr_stmt|;
block|}
block|}
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Check permissions. 		 */
if|if
condition|(
name|error
operator|=
name|VOP_ACCESS
argument_list|(
name|vp
argument_list|,
name|mode
argument_list|,
name|accessflags
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 		 * Require FSEARCH to return a directory. 		 * Require FEXEC to return a regular file. 		 */
if|if
condition|(
operator|(
name|filemode
operator|&
name|FSEARCH
operator|)
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|filemode
operator|&
name|FEXEC
operator|)
operator|&&
name|vp
operator|->
name|v_type
operator|!=
name|VREG
condition|)
block|{
name|error
operator|=
name|ENOEXEC
expr_stmt|;
comment|/* XXX: error code? */
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Do remaining checks for FNOFOLLOW and FNOLINKS. 	 */
if|if
condition|(
operator|(
name|filemode
operator|&
name|FNOFOLLOW
operator|)
operator|&&
name|vp
operator|->
name|v_type
operator|==
name|VLNK
condition|)
block|{
name|error
operator|=
name|ELOOP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|filemode
operator|&
name|FNOLINKS
condition|)
block|{
name|vattr
operator|.
name|va_mask
operator|=
name|AT_NLINK
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|vattr
operator|.
name|va_nlink
operator|!=
literal|1
condition|)
block|{
name|error
operator|=
name|EMLINK
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Opening a socket corresponding to the AF_UNIX pathname 	 * in the filesystem name space is not supported. 	 * However, VSOCK nodes in namefs are supported in order 	 * to make fattach work for sockets. 	 * 	 * XXX This uses VOP_REALVP to distinguish between 	 * an unopened namefs node (where VOP_REALVP returns a 	 * different VSOCK vnode) and a VSOCK created by vn_create 	 * in some file system (where VOP_REALVP would never return 	 * a different vnode). 	 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VSOCK
condition|)
block|{
name|struct
name|vnode
modifier|*
name|nvp
decl_stmt|;
name|error
operator|=
name|VOP_REALVP
argument_list|(
name|vp
argument_list|,
operator|&
name|nvp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
operator|||
name|nvp
operator|==
name|NULL
operator|||
name|nvp
operator|==
name|vp
operator|||
name|nvp
operator|->
name|v_type
operator|!=
name|VSOCK
condition|)
block|{
name|error
operator|=
name|EOPNOTSUPP
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
name|nbl_need_check
argument_list|(
name|vp
argument_list|)
condition|)
block|{
comment|/* get share reservation */
name|shr
operator|.
name|s_access
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FWRITE
condition|)
name|shr
operator|.
name|s_access
operator||=
name|F_WRACC
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FREAD
condition|)
name|shr
operator|.
name|s_access
operator||=
name|F_RDACC
expr_stmt|;
name|shr
operator|.
name|s_deny
operator|=
literal|0
expr_stmt|;
name|shr
operator|.
name|s_sysid
operator|=
literal|0
expr_stmt|;
name|shr
operator|.
name|s_pid
operator|=
name|ttoproc
argument_list|(
name|curthread
argument_list|)
operator|->
name|p_pid
expr_stmt|;
name|shr_own
operator|.
name|sl_pid
operator|=
name|shr
operator|.
name|s_pid
expr_stmt|;
name|shr_own
operator|.
name|sl_id
operator|=
name|fd
expr_stmt|;
name|shr
operator|.
name|s_own_len
operator|=
sizeof|sizeof
argument_list|(
name|shr_own
argument_list|)
expr_stmt|;
name|shr
operator|.
name|s_owner
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|shr_own
expr_stmt|;
name|error
operator|=
name|VOP_SHRLOCK
argument_list|(
name|vp
argument_list|,
name|F_SHARE_NBMAND
argument_list|,
operator|&
name|shr
argument_list|,
name|filemode
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|shrlock_done
operator|=
literal|1
expr_stmt|;
comment|/* nbmand conflict check if truncating file */
if|if
condition|(
operator|(
name|filemode
operator|&
name|FTRUNC
operator|)
operator|&&
operator|!
operator|(
name|filemode
operator|&
name|FCREAT
operator|)
condition|)
block|{
name|nbl_start_crit
argument_list|(
name|vp
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|in_crit
operator|=
literal|1
expr_stmt|;
name|vattr
operator|.
name|va_mask
operator|=
name|AT_SIZE
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|nbl_conflict
argument_list|(
name|vp
argument_list|,
name|NBL_WRITE
argument_list|,
literal|0
argument_list|,
name|vattr
operator|.
name|va_size
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* 	 * Do opening protocol. 	 */
name|error
operator|=
name|VOP_OPEN
argument_list|(
operator|&
name|vp
argument_list|,
name|filemode
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|open_done
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Truncate if required. 	 */
if|if
condition|(
operator|(
name|filemode
operator|&
name|FTRUNC
operator|)
operator|&&
operator|!
operator|(
name|filemode
operator|&
name|FCREAT
operator|)
condition|)
block|{
name|vattr
operator|.
name|va_size
operator|=
literal|0
expr_stmt|;
name|vattr
operator|.
name|va_mask
operator|=
name|AT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_SETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|out
goto|;
block|}
name|out
label|:
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_count
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_crit
condition|)
block|{
name|nbl_end_crit
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|in_crit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
name|open_done
condition|)
block|{
operator|(
name|void
operator|)
name|VOP_CLOSE
argument_list|(
name|vp
argument_list|,
name|filemode
argument_list|,
literal|1
argument_list|,
operator|(
name|offset_t
operator|)
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|open_done
operator|=
literal|0
expr_stmt|;
name|shrlock_done
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|shrlock_done
condition|)
block|{
operator|(
name|void
operator|)
name|VOP_SHRLOCK
argument_list|(
name|vp
argument_list|,
name|F_UNSHARE
argument_list|,
operator|&
name|shr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|shrlock_done
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 		 * The following clause was added to handle a problem 		 * with NFS consistency.  It is possible that a lookup 		 * of the file to be opened succeeded, but the file 		 * itself doesn't actually exist on the server.  This 		 * is chiefly due to the DNLC containing an entry for 		 * the file which has been removed on the server.  In 		 * this case, we just start over.  If there was some 		 * other cause for the ESTALE error, then the lookup 		 * of the file will fail and the error will be returned 		 * above instead of looping around from here. 		 */
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
block|}
else|else
operator|*
name|vpp
operator|=
name|vp
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The following two accessor functions are for the NFSv4 server.  Since there  * is no VOP_OPEN_UP/DOWNGRADE we need a way for the NFS server to keep the  * vnode open counts correct when a client "upgrades" an open or does an  * open_downgrade.  In NFS, an upgrade or downgrade can not only change the  * open mode (add or subtract read or write), but also change the share/deny  * modes.  However, share reservations are not integrated with OPEN, yet, so  * we need to handle each separately.  These functions are cleaner than having  * the NFS server manipulate the counts directly, however, nobody else should  * use these functions.  */
end_comment

begin_function
name|void
name|vn_open_upgrade
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|filemode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
argument_list|)
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FREAD
condition|)
name|atomic_inc_32
argument_list|(
operator|&
name|vp
operator|->
name|v_rdcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FWRITE
condition|)
name|atomic_inc_32
argument_list|(
operator|&
name|vp
operator|->
name|v_wrcnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vn_open_downgrade
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|filemode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
argument_list|)
expr_stmt|;
if|if
condition|(
name|filemode
operator|&
name|FREAD
condition|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_rdcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_rdcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|filemode
operator|&
name|FWRITE
condition|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_wrcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_wrcnt
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|vn_create
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|enum
name|vcexcl
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|why
parameter_list|,
name|int
name|flag
parameter_list|,
name|mode_t
name|umask
parameter_list|)
block|{
return|return
operator|(
name|vn_createat
argument_list|(
name|pnamep
argument_list|,
name|seg
argument_list|,
name|vap
argument_list|,
name|excl
argument_list|,
name|mode
argument_list|,
name|vpp
argument_list|,
name|why
argument_list|,
name|flag
argument_list|,
name|umask
argument_list|,
name|NULL
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Create a vnode (makenode).  */
end_comment

begin_function
name|int
name|vn_createat
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|enum
name|vcexcl
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|why
parameter_list|,
name|int
name|flag
parameter_list|,
name|mode_t
name|umask
parameter_list|,
name|struct
name|vnode
modifier|*
name|startvp
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
comment|/* ptr to parent dir vnode */
name|struct
name|vnode
modifier|*
name|vp
init|=
name|NULL
decl_stmt|;
name|struct
name|pathname
name|pn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|int
name|in_crit
init|=
literal|0
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|enum
name|symfollow
name|follow
decl_stmt|;
name|int
name|estale_retry
init|=
literal|0
decl_stmt|;
name|uint32_t
name|auditing
init|=
name|AU_AUDITING
argument_list|()
decl_stmt|;
name|ASSERT
argument_list|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
operator|(
name|AT_TYPE
operator||
name|AT_MODE
operator|)
operator|)
operator|==
operator|(
name|AT_TYPE
operator||
name|AT_MODE
operator|)
argument_list|)
expr_stmt|;
comment|/* symlink interpretation */
if|if
condition|(
operator|(
name|flag
operator|&
name|FNOFOLLOW
operator|)
operator|||
name|excl
operator|==
name|EXCL
condition|)
name|follow
operator|=
name|NO_FOLLOW
expr_stmt|;
else|else
name|follow
operator|=
name|FOLLOW
expr_stmt|;
name|flag
operator|&=
operator|~
operator|(
name|FNOFOLLOW
operator||
name|FNOLINKS
operator|)
expr_stmt|;
name|top
label|:
comment|/* 	 * Lookup directory. 	 * If new object is a file, call lower level to create it. 	 * Note that it is up to the lower level to enforce exclusive 	 * creation, if the file is already there. 	 * This allows the lower level to do whatever 	 * locking or protocol that is needed to prevent races. 	 * If the new object is directory call lower level to make 	 * the new directory, with "." and "..". 	 */
if|if
condition|(
name|error
operator|=
name|pn_get
argument_list|(
name|pnamep
argument_list|,
name|seg
argument_list|,
operator|&
name|pn
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|auditing
condition|)
name|audit_vncreate_start
argument_list|()
expr_stmt|;
name|dvp
operator|=
name|NULL
expr_stmt|;
operator|*
name|vpp
operator|=
name|NULL
expr_stmt|;
comment|/* 	 * lookup will find the parent directory for the vnode. 	 * When it is done the pn holds the name of the entry 	 * in the directory. 	 * If this is a non-exclusive create we also find the node itself. 	 */
name|error
operator|=
name|lookuppnat
argument_list|(
operator|&
name|pn
argument_list|,
name|NULL
argument_list|,
name|follow
argument_list|,
operator|&
name|dvp
argument_list|,
operator|(
name|excl
operator|==
name|EXCL
operator|)
condition|?
name|NULLVPP
else|:
name|vpp
argument_list|,
name|startvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|pn_free
argument_list|(
operator|&
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
if|if
condition|(
name|why
operator|==
name|CRMKDIR
operator|&&
name|error
operator|==
name|EINVAL
condition|)
name|error
operator|=
name|EEXIST
expr_stmt|;
comment|/* SVID */
return|return
operator|(
name|error
operator|)
return|;
block|}
if|if
condition|(
name|why
operator|!=
name|CRMKNOD
condition|)
name|vap
operator|->
name|va_mode
operator|&=
operator|~
name|VSVTX
expr_stmt|;
comment|/* 	 * If default ACLs are defined for the directory don't apply the 	 * umask if umask is passed. 	 */
if|if
condition|(
name|umask
condition|)
block|{
name|vsecattr_t
name|vsec
decl_stmt|;
name|vsec
operator|.
name|vsa_aclcnt
operator|=
literal|0
expr_stmt|;
name|vsec
operator|.
name|vsa_aclentp
operator|=
name|NULL
expr_stmt|;
name|vsec
operator|.
name|vsa_dfaclcnt
operator|=
literal|0
expr_stmt|;
name|vsec
operator|.
name|vsa_dfaclentp
operator|=
name|NULL
expr_stmt|;
name|vsec
operator|.
name|vsa_mask
operator|=
name|VSA_DFACLCNT
expr_stmt|;
name|error
operator|=
name|VOP_GETSECATTR
argument_list|(
name|dvp
argument_list|,
operator|&
name|vsec
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 		 * If error is ENOSYS then treat it as no error 		 * Don't want to force all file systems to support 		 * aclent_t style of ACL's. 		 */
if|if
condition|(
name|error
operator|==
name|ENOSYS
condition|)
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
if|if
condition|(
operator|*
name|vpp
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
else|else
block|{
comment|/* 			 * Apply the umask if no default ACLs. 			 */
if|if
condition|(
name|vsec
operator|.
name|vsa_dfaclcnt
operator|==
literal|0
condition|)
name|vap
operator|->
name|va_mode
operator|&=
operator|~
name|umask
expr_stmt|;
comment|/* 			 * VOP_GETSECATTR() may have allocated memory for 			 * ACLs we didn't request, so double-check and 			 * free it if necessary. 			 */
if|if
condition|(
name|vsec
operator|.
name|vsa_aclcnt
operator|&&
name|vsec
operator|.
name|vsa_aclentp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsec
operator|.
name|vsa_aclentp
argument_list|,
name|vsec
operator|.
name|vsa_aclcnt
operator|*
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsec
operator|.
name|vsa_dfaclcnt
operator|&&
name|vsec
operator|.
name|vsa_dfaclentp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
operator|(
name|caddr_t
operator|)
name|vsec
operator|.
name|vsa_dfaclentp
argument_list|,
name|vsec
operator|.
name|vsa_dfaclcnt
operator|*
sizeof|sizeof
argument_list|(
name|aclent_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* 	 * In general we want to generate EROFS if the file system is 	 * readonly.  However, POSIX (IEEE Std. 1003.1) section 5.3.1 	 * documents the open system call, and it says that O_CREAT has no 	 * effect if the file already exists.  Bug 1119649 states 	 * that open(path, O_CREAT, ...) fails when attempting to open an 	 * existing file on a read only file system.  Thus, the first part 	 * of the following if statement has 3 checks: 	 *	if the file exists&& 	 *		it is being open with write access&& 	 *		the file system is read only 	 *	then generate EROFS 	 */
if|if
condition|(
operator|(
operator|*
name|vpp
operator|!=
name|NULL
operator|&&
operator|(
name|mode
operator|&
name|VWRITE
operator|)
operator|&&
name|ISROFILE
argument_list|(
operator|*
name|vpp
argument_list|)
operator|)
operator|||
operator|(
operator|*
name|vpp
operator|==
name|NULL
operator|&&
name|dvp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|vpp
condition|)
name|VN_RELE
argument_list|(
operator|*
name|vpp
argument_list|)
expr_stmt|;
name|error
operator|=
name|EROFS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|excl
operator|==
name|NONEXCL
operator|&&
operator|*
name|vpp
operator|!=
name|NULL
condition|)
block|{
name|vnode_t
modifier|*
name|rvp
decl_stmt|;
comment|/* 		 * File already exists.  If a mandatory lock has been 		 * applied, return error. 		 */
name|vp
operator|=
operator|*
name|vpp
expr_stmt|;
if|if
condition|(
name|VOP_REALVP
argument_list|(
name|vp
argument_list|,
operator|&
name|rvp
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|rvp
operator|=
name|vp
expr_stmt|;
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_SIZE
operator|)
operator|&&
name|nbl_need_check
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|nbl_start_crit
argument_list|(
name|vp
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|in_crit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|rvp
operator|->
name|v_filocks
operator|!=
name|NULL
operator|||
name|rvp
operator|->
name|v_shrlocks
operator|!=
name|NULL
condition|)
block|{
name|vattr
operator|.
name|va_mask
operator|=
name|AT_MODE
operator||
name|AT_SIZE
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|MANDLOCK
argument_list|(
name|vp
argument_list|,
name|vattr
operator|.
name|va_mode
argument_list|)
condition|)
block|{
name|error
operator|=
name|EAGAIN
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 			 * File cannot be truncated if non-blocking mandatory 			 * locks are currently on the file. 			 */
if|if
condition|(
operator|(
name|vap
operator|->
name|va_mask
operator|&
name|AT_SIZE
operator|)
operator|&&
name|in_crit
condition|)
block|{
name|u_offset_t
name|offset
decl_stmt|;
name|ssize_t
name|length
decl_stmt|;
name|offset
operator|=
name|vap
operator|->
name|va_size
operator|>
name|vattr
operator|.
name|va_size
condition|?
name|vattr
operator|.
name|va_size
else|:
name|vap
operator|->
name|va_size
expr_stmt|;
name|length
operator|=
name|vap
operator|->
name|va_size
operator|>
name|vattr
operator|.
name|va_size
condition|?
name|vap
operator|->
name|va_size
operator|-
name|vattr
operator|.
name|va_size
else|:
name|vattr
operator|.
name|va_size
operator|-
name|vap
operator|->
name|va_size
expr_stmt|;
if|if
condition|(
name|nbl_conflict
argument_list|(
name|vp
argument_list|,
name|NBL_WRITE
argument_list|,
name|offset
argument_list|,
name|length
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
comment|/* 		 * If the file is the root of a VFS, we've crossed a 		 * mount point and the "containing" directory that we 		 * acquired above (dvp) is irrelevant because it's in 		 * a different file system.  We apply VOP_CREATE to the 		 * target itself instead of to the containing directory 		 * and supply a null path name to indicate (conventionally) 		 * the node itself as the "component" of interest. 		 * 		 * The intercession of the file system is necessary to 		 * ensure that the appropriate permission checks are 		 * done. 		 */
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
block|{
name|ASSERT
argument_list|(
name|why
operator|!=
name|CRMKDIR
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|vp
argument_list|,
literal|""
argument_list|,
name|vap
argument_list|,
name|excl
argument_list|,
name|mode
argument_list|,
name|vpp
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|flag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* 			 * If the create succeeded, it will have created 			 * a new reference to the vnode.  Give up the 			 * original reference.  The assertion should not 			 * get triggered because NBMAND locks only apply to 			 * VREG files.  And if in_crit is non-zero for some 			 * reason, detect that here, rather than when we 			 * deference a null vp. 			 */
name|ASSERT
argument_list|(
name|in_crit
operator|==
literal|0
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Large File API - non-large open (FOFFMAX flag not set) 		 * of regular file fails if the file size exceeds MAXOFF32_T. 		 */
if|if
condition|(
name|why
operator|!=
name|CRMKDIR
operator|&&
operator|!
operator|(
name|flag
operator|&
name|FOFFMAX
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|vattr
operator|.
name|va_mask
operator|=
name|AT_SIZE
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
operator|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|vattr
operator|.
name|va_size
operator|>
operator|(
name|u_offset_t
operator|)
name|MAXOFF32_T
operator|)
condition|)
block|{
name|error
operator|=
name|EOVERFLOW
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
block|}
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Call mkdir() if specified, otherwise create(). 		 */
name|int
name|must_be_dir
init|=
name|pn_fixslash
argument_list|(
operator|&
name|pn
argument_list|)
decl_stmt|;
comment|/* trailing '/'? */
if|if
condition|(
name|why
operator|==
name|CRMKDIR
condition|)
comment|/* 			 * N.B., if vn_createat() ever requests 			 * case-insensitive behavior then it will need 			 * to be passed to VOP_MKDIR().  VOP_CREATE() 			 * will already get it via "flag" 			 */
name|error
operator|=
name|VOP_MKDIR
argument_list|(
name|dvp
argument_list|,
name|pn
operator|.
name|pn_path
argument_list|,
name|vap
argument_list|,
name|vpp
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|must_be_dir
condition|)
name|error
operator|=
name|VOP_CREATE
argument_list|(
name|dvp
argument_list|,
name|pn
operator|.
name|pn_path
argument_list|,
name|vap
argument_list|,
name|excl
argument_list|,
name|mode
argument_list|,
name|vpp
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|flag
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|error
operator|=
name|ENOTDIR
expr_stmt|;
block|}
name|out
label|:
if|if
condition|(
name|auditing
condition|)
name|audit_vncreate_finish
argument_list|(
operator|*
name|vpp
argument_list|,
name|error
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_crit
condition|)
block|{
name|nbl_end_crit
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|in_crit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
name|pn_free
argument_list|(
operator|&
name|pn
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
comment|/* 	 * The following clause was added to handle a problem 	 * with NFS consistency.  It is possible that a lookup 	 * of the file to be created succeeded, but the file 	 * itself doesn't actually exist on the server.  This 	 * is chiefly due to the DNLC containing an entry for 	 * the file which has been removed on the server.  In 	 * this case, we just start over.  If there was some 	 * other cause for the ESTALE error, then the lookup 	 * of the file will fail and the error will be returned 	 * above instead of looping around from here. 	 */
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_link
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
block|{
return|return
operator|(
name|vn_linkat
argument_list|(
name|NULL
argument_list|,
name|from
argument_list|,
name|NO_FOLLOW
argument_list|,
name|NULL
argument_list|,
name|to
argument_list|,
name|seg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_linkat
parameter_list|(
name|vnode_t
modifier|*
name|fstartvp
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|enum
name|symfollow
name|follow
parameter_list|,
name|vnode_t
modifier|*
name|tstartvp
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|fvp
decl_stmt|;
comment|/* from vnode ptr */
name|struct
name|vnode
modifier|*
name|tdvp
decl_stmt|;
comment|/* to directory vnode ptr */
name|struct
name|pathname
name|pn
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|dev_t
name|fsid
decl_stmt|;
name|int
name|estale_retry
init|=
literal|0
decl_stmt|;
name|uint32_t
name|auditing
init|=
name|AU_AUDITING
argument_list|()
decl_stmt|;
name|top
label|:
name|fvp
operator|=
name|tdvp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|pn_get
argument_list|(
name|to
argument_list|,
name|seg
argument_list|,
operator|&
name|pn
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|auditing
operator|&&
name|fstartvp
operator|!=
name|NULL
condition|)
name|audit_setfsat_path
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lookupnameat
argument_list|(
name|from
argument_list|,
name|seg
argument_list|,
name|follow
argument_list|,
name|NULLVPP
argument_list|,
operator|&
name|fvp
argument_list|,
name|fstartvp
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|auditing
operator|&&
name|tstartvp
operator|!=
name|NULL
condition|)
name|audit_setfsat_path
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lookuppnat
argument_list|(
operator|&
name|pn
argument_list|,
name|NULL
argument_list|,
name|NO_FOLLOW
argument_list|,
operator|&
name|tdvp
argument_list|,
name|NULLVPP
argument_list|,
name|tstartvp
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * Make sure both source vnode and target directory vnode are 	 * in the same vfs and that it is writeable. 	 */
name|vattr
operator|.
name|va_mask
operator|=
name|AT_FSID
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|fvp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|fsid
operator|=
name|vattr
operator|.
name|va_fsid
expr_stmt|;
name|vattr
operator|.
name|va_mask
operator|=
name|AT_FSID
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|tdvp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|fsid
operator|!=
name|vattr
operator|.
name|va_fsid
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|tdvp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Do the link. 	 */
operator|(
name|void
operator|)
name|pn_fixslash
argument_list|(
operator|&
name|pn
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_LINK
argument_list|(
name|tdvp
argument_list|,
name|fvp
argument_list|,
name|pn
operator|.
name|pn_path
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
name|pn_free
argument_list|(
operator|&
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
condition|)
name|VN_RELE
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tdvp
condition|)
name|VN_RELE
argument_list|(
name|tdvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_rename
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
block|{
return|return
operator|(
name|vn_renameat
argument_list|(
name|NULL
argument_list|,
name|from
argument_list|,
name|NULL
argument_list|,
name|to
argument_list|,
name|seg
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_renameat
parameter_list|(
name|vnode_t
modifier|*
name|fdvp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|char
modifier|*
name|tname
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|struct
name|vattr
name|vattr
decl_stmt|;
name|struct
name|pathname
name|fpn
decl_stmt|;
comment|/* from pathname */
name|struct
name|pathname
name|tpn
decl_stmt|;
comment|/* to pathname */
name|dev_t
name|fsid
decl_stmt|;
name|int
name|in_crit_src
decl_stmt|,
name|in_crit_targ
decl_stmt|;
name|vnode_t
modifier|*
name|fromvp
decl_stmt|,
modifier|*
name|fvp
decl_stmt|;
name|vnode_t
modifier|*
name|tovp
decl_stmt|,
modifier|*
name|targvp
decl_stmt|;
name|int
name|estale_retry
init|=
literal|0
decl_stmt|;
name|uint32_t
name|auditing
init|=
name|AU_AUDITING
argument_list|()
decl_stmt|;
name|top
label|:
name|fvp
operator|=
name|fromvp
operator|=
name|tovp
operator|=
name|targvp
operator|=
name|NULL
expr_stmt|;
name|in_crit_src
operator|=
name|in_crit_targ
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Get to and from pathnames. 	 */
if|if
condition|(
name|error
operator|=
name|pn_get
argument_list|(
name|fname
argument_list|,
name|seg
argument_list|,
operator|&
name|fpn
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
if|if
condition|(
name|error
operator|=
name|pn_get
argument_list|(
name|tname
argument_list|,
name|seg
argument_list|,
operator|&
name|tpn
argument_list|)
condition|)
block|{
name|pn_free
argument_list|(
operator|&
name|fpn
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * First we need to resolve the correct directories 	 * The passed in directories may only be a starting point, 	 * but we need the real directories the file(s) live in. 	 * For example the fname may be something like usr/lib/sparc 	 * and we were passed in the / directory, but we need to 	 * use the lib directory for the rename. 	 */
if|if
condition|(
name|auditing
operator|&&
name|fdvp
operator|!=
name|NULL
condition|)
name|audit_setfsat_path
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Lookup to and from directories. 	 */
if|if
condition|(
name|error
operator|=
name|lookuppnat
argument_list|(
operator|&
name|fpn
argument_list|,
name|NULL
argument_list|,
name|NO_FOLLOW
argument_list|,
operator|&
name|fromvp
argument_list|,
operator|&
name|fvp
argument_list|,
name|fdvp
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Make sure there is an entry. 	 */
if|if
condition|(
name|fvp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|auditing
operator|&&
name|tdvp
operator|!=
name|NULL
condition|)
name|audit_setfsat_path
argument_list|(
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lookuppnat
argument_list|(
operator|&
name|tpn
argument_list|,
name|NULL
argument_list|,
name|NO_FOLLOW
argument_list|,
operator|&
name|tovp
argument_list|,
operator|&
name|targvp
argument_list|,
name|tdvp
argument_list|)
condition|)
block|{
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Make sure both the from vnode directory and the to directory 	 * are in the same vfs and the to directory is writable. 	 * We check fsid's, not vfs pointers, so loopback fs works. 	 */
if|if
condition|(
name|fromvp
operator|!=
name|tovp
condition|)
block|{
name|vattr
operator|.
name|va_mask
operator|=
name|AT_FSID
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|fromvp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|fsid
operator|=
name|vattr
operator|.
name|va_fsid
expr_stmt|;
name|vattr
operator|.
name|va_mask
operator|=
name|AT_FSID
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|VOP_GETATTR
argument_list|(
name|tovp
argument_list|,
operator|&
name|vattr
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|)
condition|)
goto|goto
name|out
goto|;
if|if
condition|(
name|fsid
operator|!=
name|vattr
operator|.
name|va_fsid
condition|)
block|{
name|error
operator|=
name|EXDEV
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|tovp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|targvp
operator|&&
operator|(
name|fvp
operator|!=
name|targvp
operator|)
condition|)
block|{
name|nbl_start_crit
argument_list|(
name|targvp
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|in_crit_targ
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nbl_conflict
argument_list|(
name|targvp
argument_list|,
name|NBL_REMOVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
if|if
condition|(
name|nbl_need_check
argument_list|(
name|fvp
argument_list|)
condition|)
block|{
name|nbl_start_crit
argument_list|(
name|fvp
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|in_crit_src
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nbl_conflict
argument_list|(
name|fvp
argument_list|,
name|NBL_RENAME
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
comment|/* 	 * Do the rename. 	 */
operator|(
name|void
operator|)
name|pn_fixslash
argument_list|(
operator|&
name|tpn
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_RENAME
argument_list|(
name|fromvp
argument_list|,
name|fpn
operator|.
name|pn_path
argument_list|,
name|tovp
argument_list|,
name|tpn
operator|.
name|pn_path
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|out
label|:
name|pn_free
argument_list|(
operator|&
name|fpn
argument_list|)
expr_stmt|;
name|pn_free
argument_list|(
operator|&
name|tpn
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_crit_src
condition|)
name|nbl_end_crit
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_crit_targ
condition|)
name|nbl_end_crit
argument_list|(
name|targvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fromvp
condition|)
name|VN_RELE
argument_list|(
name|fromvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tovp
condition|)
name|VN_RELE
argument_list|(
name|tovp
argument_list|)
expr_stmt|;
if|if
condition|(
name|targvp
condition|)
name|VN_RELE
argument_list|(
name|targvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fvp
condition|)
name|VN_RELE
argument_list|(
name|fvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Remove a file or directory.  */
end_comment

begin_function
name|int
name|vn_remove
parameter_list|(
name|char
modifier|*
name|fnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|enum
name|rm
name|dirflag
parameter_list|)
block|{
return|return
operator|(
name|vn_removeat
argument_list|(
name|NULL
argument_list|,
name|fnamep
argument_list|,
name|seg
argument_list|,
name|dirflag
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_removeat
parameter_list|(
name|vnode_t
modifier|*
name|startvp
parameter_list|,
name|char
modifier|*
name|fnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|enum
name|rm
name|dirflag
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
comment|/* entry vnode */
name|struct
name|vnode
modifier|*
name|dvp
decl_stmt|;
comment|/* ptr to parent dir vnode */
name|struct
name|vnode
modifier|*
name|coveredvp
decl_stmt|;
name|struct
name|pathname
name|pn
decl_stmt|;
comment|/* name of entry */
name|enum
name|vtype
name|vtype
decl_stmt|;
name|int
name|error
decl_stmt|;
name|struct
name|vfs
modifier|*
name|vfsp
decl_stmt|;
name|struct
name|vfs
modifier|*
name|dvfsp
decl_stmt|;
comment|/* ptr to parent dir vfs */
name|int
name|in_crit
init|=
literal|0
decl_stmt|;
name|int
name|estale_retry
init|=
literal|0
decl_stmt|;
name|top
label|:
if|if
condition|(
name|error
operator|=
name|pn_get
argument_list|(
name|fnamep
argument_list|,
name|seg
argument_list|,
operator|&
name|pn
argument_list|)
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|dvp
operator|=
name|vp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|error
operator|=
name|lookuppnat
argument_list|(
operator|&
name|pn
argument_list|,
name|NULL
argument_list|,
name|NO_FOLLOW
argument_list|,
operator|&
name|dvp
argument_list|,
operator|&
name|vp
argument_list|,
name|startvp
argument_list|)
condition|)
block|{
name|pn_free
argument_list|(
operator|&
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
comment|/* 	 * Make sure there is an entry. 	 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
block|{
name|error
operator|=
name|ENOENT
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vfsp
operator|=
name|vp
operator|->
name|v_vfsp
expr_stmt|;
name|dvfsp
operator|=
name|dvp
operator|->
name|v_vfsp
expr_stmt|;
comment|/* 	 * If the named file is the root of a mounted filesystem, fail, 	 * unless it's marked unlinkable.  In that case, unmount the 	 * filesystem and proceed to unlink the covered vnode.  (If the 	 * covered vnode is a directory, use rmdir instead of unlink, 	 * to avoid file system corruption.) 	 */
if|if
condition|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
condition|)
block|{
if|if
condition|(
operator|(
name|vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_UNLINKABLE
operator|)
operator|==
literal|0
condition|)
block|{
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * Namefs specific code starts here. 		 */
if|if
condition|(
name|dirflag
operator|==
name|RMDIRECTORY
condition|)
block|{
comment|/* 			 * User called rmdir(2) on a file that has 			 * been namefs mounted on top of.  Since 			 * namefs doesn't allow directories to 			 * be mounted on other files we know 			 * vp is not of type VDIR so fail to operation. 			 */
name|error
operator|=
name|ENOTDIR
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 		 * If VROOT is still set after grabbing vp->v_lock, 		 * noone has finished nm_unmount so far and coveredvp 		 * is valid. 		 * If we manage to grab vn_vfswlock(coveredvp) before releasing 		 * vp->v_lock, any race window is eliminated. 		 */
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_flag
operator|&
name|VROOT
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* Someone beat us to the unmount */
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|EBUSY
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vfsp
operator|=
name|vp
operator|->
name|v_vfsp
expr_stmt|;
name|coveredvp
operator|=
name|vfsp
operator|->
name|vfs_vnodecovered
expr_stmt|;
name|ASSERT
argument_list|(
name|coveredvp
argument_list|)
expr_stmt|;
comment|/* 		 * Note: Implementation of vn_vfswlock shows that ordering of 		 * v_lock / vn_vfswlock is not an issue here. 		 */
name|error
operator|=
name|vn_vfswlock
argument_list|(
name|coveredvp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
name|VN_HOLD
argument_list|(
name|coveredvp
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|error
operator|=
name|dounmount
argument_list|(
name|vfsp
argument_list|,
literal|0
argument_list|,
name|CRED
argument_list|()
argument_list|)
expr_stmt|;
comment|/* 		 * Unmounted the namefs file system; now get 		 * the object it was mounted over. 		 */
name|vp
operator|=
name|coveredvp
expr_stmt|;
comment|/* 		 * If namefs was mounted over a directory, then 		 * we want to use rmdir() instead of unlink(). 		 */
if|if
condition|(
name|vp
operator|->
name|v_type
operator|==
name|VDIR
condition|)
name|dirflag
operator|=
name|RMDIRECTORY
expr_stmt|;
if|if
condition|(
name|error
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 	 * Make sure filesystem is writeable. 	 * We check the parent directory's vfs in case this is an lofs vnode. 	 */
if|if
condition|(
name|dvfsp
operator|&&
name|dvfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
condition|)
block|{
name|error
operator|=
name|EROFS
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|vtype
operator|=
name|vp
operator|->
name|v_type
expr_stmt|;
comment|/* 	 * If there is the possibility of an nbmand share reservation, make 	 * sure it's okay to remove the file.  Keep a reference to the 	 * vnode, so that we can exit the nbl critical region after 	 * calling VOP_REMOVE. 	 * If there is no possibility of an nbmand share reservation, 	 * release the vnode reference now.  Filesystems like NFS may 	 * behave differently if there is an extra reference, so get rid of 	 * this one.  Fortunately, we can't have nbmand mounts on NFS 	 * filesystems. 	 */
if|if
condition|(
name|nbl_need_check
argument_list|(
name|vp
argument_list|)
condition|)
block|{
name|nbl_start_crit
argument_list|(
name|vp
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
name|in_crit
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|nbl_conflict
argument_list|(
name|vp
argument_list|,
name|NBL_REMOVE
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|error
operator|=
name|EACCES
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
else|else
block|{
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vp
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|dirflag
operator|==
name|RMDIRECTORY
condition|)
block|{
comment|/* 		 * Caller is using rmdir(2), which can only be applied to 		 * directories. 		 */
if|if
condition|(
name|vtype
operator|!=
name|VDIR
condition|)
block|{
name|error
operator|=
name|ENOTDIR
expr_stmt|;
block|}
else|else
block|{
name|vnode_t
modifier|*
name|cwd
decl_stmt|;
name|proc_t
modifier|*
name|pp
init|=
name|curproc
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pp
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|cwd
operator|=
name|PTOU
argument_list|(
name|pp
argument_list|)
operator|->
name|u_cdir
expr_stmt|;
name|VN_HOLD
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pp
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|error
operator|=
name|VOP_RMDIR
argument_list|(
name|dvp
argument_list|,
name|pn
operator|.
name|pn_path
argument_list|,
name|cwd
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|VN_RELE
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Unlink(2) can be applied to anything. 		 */
name|error
operator|=
name|VOP_REMOVE
argument_list|(
name|dvp
argument_list|,
name|pn
operator|.
name|pn_path
argument_list|,
name|CRED
argument_list|()
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|pn_free
argument_list|(
operator|&
name|pn
argument_list|)
expr_stmt|;
if|if
condition|(
name|in_crit
condition|)
block|{
name|nbl_end_crit
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|in_crit
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dvp
operator|!=
name|NULL
condition|)
name|VN_RELE
argument_list|(
name|dvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|error
operator|==
name|ESTALE
operator|)
operator|&&
name|fs_need_estale_retry
argument_list|(
name|estale_retry
operator|++
argument_list|)
condition|)
goto|goto
name|top
goto|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Utility function to compare equality of vnodes.  * Compare the underlying real vnodes, if there are underlying vnodes.  * This is a more thorough comparison than the VN_CMP() macro provides.  */
end_comment

begin_function
name|int
name|vn_compare
parameter_list|(
name|vnode_t
modifier|*
name|vp1
parameter_list|,
name|vnode_t
modifier|*
name|vp2
parameter_list|)
block|{
name|vnode_t
modifier|*
name|realvp
decl_stmt|;
if|if
condition|(
name|vp1
operator|!=
name|NULL
operator|&&
name|VOP_REALVP
argument_list|(
name|vp1
argument_list|,
operator|&
name|realvp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|vp1
operator|=
name|realvp
expr_stmt|;
if|if
condition|(
name|vp2
operator|!=
name|NULL
operator|&&
name|VOP_REALVP
argument_list|(
name|vp2
argument_list|,
operator|&
name|realvp
argument_list|,
name|NULL
argument_list|)
operator|==
literal|0
condition|)
name|vp2
operator|=
name|realvp
expr_stmt|;
return|return
operator|(
name|VN_CMP
argument_list|(
name|vp1
argument_list|,
name|vp2
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The number of locks to hash into.  This value must be a power  * of 2 minus 1 and should probably also be prime.  */
end_comment

begin_define
define|#
directive|define
name|NUM_BUCKETS
value|1023
end_define

begin_struct
struct|struct
name|vn_vfslocks_bucket
block|{
name|kmutex_t
name|vb_lock
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|vb_list
decl_stmt|;
name|char
name|pad
index|[
literal|64
operator|-
sizeof|sizeof
argument_list|(
name|kmutex_t
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * Total number of buckets will be NUM_BUCKETS + 1 .  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|align
name|64
name|(
name|vn_vfslocks_buckets
name|)
end_pragma

begin_decl_stmt
specifier|static
name|struct
name|vn_vfslocks_bucket
name|vn_vfslocks_buckets
index|[
name|NUM_BUCKETS
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|VN_VFSLOCKS_SHIFT
value|9
end_define

begin_define
define|#
directive|define
name|VN_VFSLOCKS_HASH
parameter_list|(
name|vfsvpptr
parameter_list|)
define|\
value|((((intptr_t)(vfsvpptr))>> VN_VFSLOCKS_SHIFT)& NUM_BUCKETS)
end_define

begin_comment
comment|/*  * vn_vfslocks_getlock() uses an HASH scheme to generate  * rwstlock using vfs/vnode pointer passed to it.  *  * vn_vfslocks_rele() releases a reference in the  * HASH table which allows the entry allocated by  * vn_vfslocks_getlock() to be freed at a later  * stage when the refcount drops to zero.  */
end_comment

begin_function
name|vn_vfslocks_entry_t
modifier|*
name|vn_vfslocks_getlock
parameter_list|(
name|void
modifier|*
name|vfsvpptr
parameter_list|)
block|{
name|struct
name|vn_vfslocks_bucket
modifier|*
name|bp
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|vep
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|tvep
decl_stmt|;
name|ASSERT
argument_list|(
name|vfsvpptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|vn_vfslocks_buckets
index|[
name|VN_VFSLOCKS_HASH
argument_list|(
name|vfsvpptr
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|vep
operator|=
name|bp
operator|->
name|vb_list
init|;
name|vep
operator|!=
name|NULL
condition|;
name|vep
operator|=
name|vep
operator|->
name|ve_next
control|)
block|{
if|if
condition|(
name|vep
operator|->
name|ve_vpvfs
operator|==
name|vfsvpptr
condition|)
block|{
name|vep
operator|->
name|ve_refcnt
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|vep
operator|)
return|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
name|vep
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vep
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|rwst_init
argument_list|(
operator|&
name|vep
operator|->
name|ve_lock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vep
operator|->
name|ve_vpvfs
operator|=
operator|(
name|char
operator|*
operator|)
name|vfsvpptr
expr_stmt|;
name|vep
operator|->
name|ve_refcnt
operator|=
literal|1
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|tvep
operator|=
name|bp
operator|->
name|vb_list
init|;
name|tvep
operator|!=
name|NULL
condition|;
name|tvep
operator|=
name|tvep
operator|->
name|ve_next
control|)
block|{
if|if
condition|(
name|tvep
operator|->
name|ve_vpvfs
operator|==
name|vfsvpptr
condition|)
block|{
name|tvep
operator|->
name|ve_refcnt
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
comment|/* 			 * There is already an entry in the hash 			 * destroy what we just allocated. 			 */
name|rwst_destroy
argument_list|(
operator|&
name|vep
operator|->
name|ve_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vep
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|tvep
operator|)
return|;
block|}
block|}
name|vep
operator|->
name|ve_next
operator|=
name|bp
operator|->
name|vb_list
expr_stmt|;
name|bp
operator|->
name|vb_list
operator|=
name|vep
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|vep
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vn_vfslocks_rele
parameter_list|(
name|vn_vfslocks_entry_t
modifier|*
name|vepent
parameter_list|)
block|{
name|struct
name|vn_vfslocks_bucket
modifier|*
name|bp
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|vep
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|pvep
decl_stmt|;
name|ASSERT
argument_list|(
name|vepent
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vepent
operator|->
name|ve_vpvfs
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bp
operator|=
operator|&
name|vn_vfslocks_buckets
index|[
name|VN_VFSLOCKS_HASH
argument_list|(
name|vepent
operator|->
name|ve_vpvfs
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
name|vepent
operator|->
name|ve_refcnt
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|int32_t
operator|)
name|vepent
operator|->
name|ve_refcnt
operator|<
literal|0
condition|)
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"vn_vfslocks_rele: refcount negative"
argument_list|)
expr_stmt|;
if|if
condition|(
name|vepent
operator|->
name|ve_refcnt
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|vep
operator|=
name|bp
operator|->
name|vb_list
init|;
name|vep
operator|!=
name|NULL
condition|;
name|vep
operator|=
name|vep
operator|->
name|ve_next
control|)
block|{
if|if
condition|(
name|vep
operator|->
name|ve_vpvfs
operator|==
name|vepent
operator|->
name|ve_vpvfs
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|vb_list
operator|==
name|vep
condition|)
name|bp
operator|->
name|vb_list
operator|=
name|vep
operator|->
name|ve_next
expr_stmt|;
else|else
block|{
comment|/* LINTED */
name|pvep
operator|->
name|ve_next
operator|=
name|vep
operator|->
name|ve_next
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
name|rwst_destroy
argument_list|(
operator|&
name|vep
operator|->
name|ve_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vep
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vep
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|pvep
operator|=
name|vep
expr_stmt|;
block|}
name|cmn_err
argument_list|(
name|CE_PANIC
argument_list|,
literal|"vn_vfslocks_rele: vp/vfs not found"
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bp
operator|->
name|vb_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vn_vfswlock_wait is used to implement a lock which is logically a writers  * lock protecting the v_vfsmountedhere field.  * vn_vfswlock_wait has been modified to be similar to vn_vfswlock,  * except that it blocks to acquire the lock VVFSLOCK.  *  * traverse() and routines re-implementing part of traverse (e.g. autofs)  * need to hold this lock. mount(), vn_rename(), vn_remove() and so on  * need the non-blocking version of the writers lock i.e. vn_vfswlock  */
end_comment

begin_function
name|int
name|vn_vfswlock_wait
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|vpvfsentry
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vpvfsentry
operator|=
name|vn_vfslocks_getlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|rwst_enter_sig
argument_list|(
operator|&
name|vpvfsentry
operator|->
name|ve_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
block|{
name|vn_vfslocks_rele
argument_list|(
name|vpvfsentry
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_vfsrlock_wait
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|retval
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|vpvfsentry
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vpvfsentry
operator|=
name|vn_vfslocks_getlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|rwst_enter_sig
argument_list|(
operator|&
name|vpvfsentry
operator|->
name|ve_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|EINTR
condition|)
block|{
name|vn_vfslocks_rele
argument_list|(
name|vpvfsentry
argument_list|)
expr_stmt|;
return|return
operator|(
name|EINTR
operator|)
return|;
block|}
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vn_vfswlock is used to implement a lock which is logically a writers lock  * protecting the v_vfsmountedhere field.  */
end_comment

begin_function
name|int
name|vn_vfswlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vn_vfslocks_entry_t
modifier|*
name|vpvfsentry
decl_stmt|;
comment|/* 	 * If vp is NULL then somebody is trying to lock the covered vnode 	 * of /.  (vfs_vnodecovered is NULL for /).  This situation will 	 * only happen when unmounting /.  Since that operation will fail 	 * anyway, return EBUSY here instead of in VFS_UNMOUNT. 	 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|vpvfsentry
operator|=
name|vn_vfslocks_getlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwst_tryenter
argument_list|(
operator|&
name|vpvfsentry
operator|->
name|ve_lock
argument_list|,
name|RW_WRITER
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vn_vfslocks_rele
argument_list|(
name|vpvfsentry
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_vfsrlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vn_vfslocks_entry_t
modifier|*
name|vpvfsentry
decl_stmt|;
comment|/* 	 * If vp is NULL then somebody is trying to lock the covered vnode 	 * of /.  (vfs_vnodecovered is NULL for /).  This situation will 	 * only happen when unmounting /.  Since that operation will fail 	 * anyway, return EBUSY here instead of in VFS_UNMOUNT. 	 */
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|vpvfsentry
operator|=
name|vn_vfslocks_getlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rwst_tryenter
argument_list|(
operator|&
name|vpvfsentry
operator|->
name|ve_lock
argument_list|,
name|RW_READER
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|vn_vfslocks_rele
argument_list|(
name|vpvfsentry
argument_list|)
expr_stmt|;
return|return
operator|(
name|EBUSY
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vn_vfsunlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vn_vfslocks_entry_t
modifier|*
name|vpvfsentry
decl_stmt|;
comment|/* 	 * ve_refcnt needs to be decremented twice. 	 * 1. To release refernce after a call to vn_vfslocks_getlock() 	 * 2. To release the reference from the locking routines like 	 *    vn_vfsrlock/vn_vfswlock etc,. 	 */
name|vpvfsentry
operator|=
name|vn_vfslocks_getlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|vn_vfslocks_rele
argument_list|(
name|vpvfsentry
argument_list|)
expr_stmt|;
name|rwst_exit
argument_list|(
operator|&
name|vpvfsentry
operator|->
name|ve_lock
argument_list|)
expr_stmt|;
name|vn_vfslocks_rele
argument_list|(
name|vpvfsentry
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|vn_vfswlock_held
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|held
decl_stmt|;
name|vn_vfslocks_entry_t
modifier|*
name|vpvfsentry
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|vpvfsentry
operator|=
name|vn_vfslocks_getlock
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|held
operator|=
name|rwst_lock_held
argument_list|(
operator|&
name|vpvfsentry
operator|->
name|ve_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
name|vn_vfslocks_rele
argument_list|(
name|vpvfsentry
argument_list|)
expr_stmt|;
return|return
operator|(
name|held
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_make_ops
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
comment|/* Name of file system */
specifier|const
name|fs_operation_def_t
modifier|*
name|templ
parameter_list|,
comment|/* Operation specification */
name|vnodeops_t
modifier|*
modifier|*
name|actual
parameter_list|)
comment|/* Return the vnodeops */
block|{
name|int
name|unused_ops
decl_stmt|;
name|int
name|error
decl_stmt|;
operator|*
name|actual
operator|=
operator|(
name|vnodeops_t
operator|*
operator|)
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|vnodeops_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
operator|*
name|actual
operator|)
operator|->
name|vnop_name
operator|=
name|name
expr_stmt|;
name|error
operator|=
name|fs_build_vector
argument_list|(
operator|*
name|actual
argument_list|,
operator|&
name|unused_ops
argument_list|,
name|vn_ops_table
argument_list|,
name|templ
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|kmem_free
argument_list|(
operator|*
name|actual
argument_list|,
sizeof|sizeof
argument_list|(
name|vnodeops_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|DEBUG
if|if
condition|(
name|unused_ops
operator|!=
literal|0
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"vn_make_ops: %s: %d operations supplied "
literal|"but not used"
argument_list|,
name|name
argument_list|,
name|unused_ops
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Free the vnodeops created as a result of vn_make_ops()  */
end_comment

begin_function
name|void
name|vn_freevnodeops
parameter_list|(
name|vnodeops_t
modifier|*
name|vnops
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|vnops
argument_list|,
sizeof|sizeof
argument_list|(
name|vnodeops_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Vnode cache.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|int
name|vn_cache_constructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|cdrarg
parameter_list|,
name|int
name|kmflags
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|buf
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|vp
operator|->
name|v_vsd_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|cv_init
argument_list|(
operator|&
name|vp
operator|->
name|v_cv
argument_list|,
name|NULL
argument_list|,
name|CV_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|rw_init
argument_list|(
operator|&
name|vp
operator|->
name|v_nbllock
argument_list|,
name|NULL
argument_list|,
name|RW_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_femhead
operator|=
name|NULL
expr_stmt|;
comment|/* Must be done before vn_reinit() */
name|vp
operator|->
name|v_path
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_mpssdata
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_vsd
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_fopdata
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|vn_cache_destructor
parameter_list|(
name|void
modifier|*
name|buf
parameter_list|,
name|void
modifier|*
name|cdrarg
parameter_list|)
block|{
name|struct
name|vnode
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|buf
expr_stmt|;
name|rw_destroy
argument_list|(
operator|&
name|vp
operator|->
name|v_nbllock
argument_list|)
expr_stmt|;
name|cv_destroy
argument_list|(
operator|&
name|vp
operator|->
name|v_cv
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vp
operator|->
name|v_vsd_lock
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vn_create_cache
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* LINTED */
name|ASSERT
argument_list|(
operator|(
literal|1
operator|<<
name|VNODE_ALIGN_LOG2
operator|)
operator|==
name|P2ROUNDUP
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|vnode
argument_list|)
argument_list|,
name|VNODE_ALIGN
argument_list|)
argument_list|)
expr_stmt|;
name|vn_cache
operator|=
name|kmem_cache_create
argument_list|(
literal|"vn_cache"
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vnode
argument_list|)
argument_list|,
name|VNODE_ALIGN
argument_list|,
name|vn_cache_constructor
argument_list|,
name|vn_cache_destructor
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vn_destroy_cache
parameter_list|(
name|void
parameter_list|)
block|{
name|kmem_cache_destroy
argument_list|(
name|vn_cache
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Used by file systems when fs-specific nodes (e.g., ufs inodes) are  * cached by the file system and vnodes remain associated.  */
end_comment

begin_function
name|void
name|vn_recycle
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_pages
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * XXX - This really belongs in vn_reinit(), but we have some issues 	 * with the counts.  Best to have it here for clean initialization. 	 */
name|vp
operator|->
name|v_rdcnt
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_wrcnt
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_mmap_read
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_mmap_write
operator|=
literal|0
expr_stmt|;
comment|/* 	 * If FEM was in use, make sure everything gets cleaned up 	 * NOTE: vp->v_femhead is initialized to NULL in the vnode 	 * constructor. 	 */
if|if
condition|(
name|vp
operator|->
name|v_femhead
condition|)
block|{
comment|/* XXX - There should be a free_femhead() that does all this */
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_femhead
operator|->
name|femh_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vp
operator|->
name|v_femhead
operator|->
name|femh_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vp
operator|->
name|v_femhead
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|vp
operator|->
name|v_femhead
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_femhead
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_path
condition|)
block|{
name|kmem_free
argument_list|(
name|vp
operator|->
name|v_path
argument_list|,
name|strlen
argument_list|(
name|vp
operator|->
name|v_path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_path
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_fopdata
operator|!=
name|NULL
condition|)
block|{
name|free_fopdata
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_mpssdata
operator|=
name|NULL
expr_stmt|;
name|vsd_free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Used to reset the vnode fields including those that are directly accessible  * as well as those which require an accessor function.  *  * Does not initialize:  *	synchronization objects: v_lock, v_vsd_lock, v_nbllock, v_cv  *	v_data (since FS-nodes and vnodes point to each other and should  *		be updated simultaneously)  *	v_op (in case someone needs to make a VOP call on this object)  */
end_comment

begin_function
name|void
name|vn_reinit
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vp
operator|->
name|v_count
operator|=
literal|1
expr_stmt|;
name|vp
operator|->
name|v_count_dnlc
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_vfsp
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_stream
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_vfsmountedhere
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_flag
operator|=
literal|0
expr_stmt|;
name|vp
operator|->
name|v_type
operator|=
name|VNON
expr_stmt|;
name|vp
operator|->
name|v_rdev
operator|=
name|NODEV
expr_stmt|;
name|vp
operator|->
name|v_filocks
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_shrlocks
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_pages
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_locality
operator|=
name|NULL
expr_stmt|;
name|vp
operator|->
name|v_xattrdir
operator|=
name|NULL
expr_stmt|;
comment|/* Handles v_femhead, v_path, and the r/w/map counts */
name|vn_recycle
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|vnode_t
modifier|*
name|vn_alloc
parameter_list|(
name|int
name|kmflag
parameter_list|)
block|{
name|vnode_t
modifier|*
name|vp
decl_stmt|;
name|vp
operator|=
name|kmem_cache_alloc
argument_list|(
name|vn_cache
argument_list|,
name|kmflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|!=
name|NULL
condition|)
block|{
name|vp
operator|->
name|v_femhead
operator|=
name|NULL
expr_stmt|;
comment|/* Must be done before vn_reinit() */
name|vp
operator|->
name|v_fopdata
operator|=
name|NULL
expr_stmt|;
name|vn_reinit
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|vp
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vn_free
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_shrlocks
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_filocks
operator|==
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Some file systems call vn_free() with v_count of zero, 	 * some with v_count of 1.  In any case, the value should 	 * never be anything else. 	 */
name|ASSERT
argument_list|(
operator|(
name|vp
operator|->
name|v_count
operator|==
literal|0
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_count
operator|==
literal|1
operator|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_count_dnlc
operator|==
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_path
operator|!=
name|NULL
condition|)
block|{
name|kmem_free
argument_list|(
name|vp
operator|->
name|v_path
argument_list|,
name|strlen
argument_list|(
name|vp
operator|->
name|v_path
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_path
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* If FEM was in use, make sure everything gets cleaned up */
if|if
condition|(
name|vp
operator|->
name|v_femhead
condition|)
block|{
comment|/* XXX - There should be a free_femhead() that does all this */
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_femhead
operator|->
name|femh_list
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|mutex_destroy
argument_list|(
operator|&
name|vp
operator|->
name|v_femhead
operator|->
name|femh_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vp
operator|->
name|v_femhead
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
operator|(
name|vp
operator|->
name|v_femhead
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_femhead
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|vp
operator|->
name|v_fopdata
operator|!=
name|NULL
condition|)
block|{
name|free_fopdata
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
name|vp
operator|->
name|v_mpssdata
operator|=
name|NULL
expr_stmt|;
name|vsd_free
argument_list|(
name|vp
argument_list|)
expr_stmt|;
name|kmem_cache_free
argument_list|(
name|vn_cache
argument_list|,
name|vp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * vnode status changes, should define better states than 1, 0.  */
end_comment

begin_function
name|void
name|vn_reclaim
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vfs_t
modifier|*
name|vfsp
init|=
name|vp
operator|->
name|v_vfsp
decl_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_implp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_VNSTATE
argument_list|(
name|vfsp
argument_list|,
name|vp
argument_list|,
name|VNTRANS_RECLAIMED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vn_idle
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vfs_t
modifier|*
name|vfsp
init|=
name|vp
operator|->
name|v_vfsp
decl_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_implp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_VNSTATE
argument_list|(
name|vfsp
argument_list|,
name|vp
argument_list|,
name|VNTRANS_IDLED
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vn_exists
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vfs_t
modifier|*
name|vfsp
init|=
name|vp
operator|->
name|v_vfsp
decl_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_implp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_VNSTATE
argument_list|(
name|vfsp
argument_list|,
name|vp
argument_list|,
name|VNTRANS_EXISTS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vn_invalid
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vfs_t
modifier|*
name|vfsp
init|=
name|vp
operator|->
name|v_vfsp
decl_stmt|;
if|if
condition|(
name|vfsp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_implp
operator|==
name|NULL
operator|||
name|vfsp
operator|->
name|vfs_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VFS_VNSTATE
argument_list|(
name|vfsp
argument_list|,
name|vp
argument_list|,
name|VNTRANS_DESTROYED
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Vnode event notification */
end_comment

begin_function
name|int
name|vnevent_support
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
return|return
operator|(
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_SUPPORT
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ct
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|vnevent_rename_src
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_RENAME_SRC
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_rename_dest
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_RENAME_DEST
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_rename_dest_dir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_RENAME_DEST_DIR
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_remove
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_REMOVE
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_rmdir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_RMDIR
argument_list|,
name|dvp
argument_list|,
name|name
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_create
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_CREATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_link
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_LINK
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_mountedover
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_MOUNTEDOVER
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|vnevent_truncate
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
if|if
condition|(
name|vp
operator|==
name|NULL
operator|||
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
operator|(
name|void
operator|)
name|VOP_VNEVENT
argument_list|(
name|vp
argument_list|,
name|VE_TRUNCATE
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|ct
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Vnode accessors.  */
end_comment

begin_function
name|int
name|vn_is_readonly
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|vp
operator|->
name|v_vfsp
operator|->
name|vfs_flag
operator|&
name|VFS_RDONLY
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_has_flocks
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|vp
operator|->
name|v_filocks
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_has_mandatory_locks
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
return|return
operator|(
operator|(
name|vp
operator|->
name|v_filocks
operator|!=
name|NULL
operator|)
operator|&&
operator|(
name|MANDLOCK
argument_list|(
name|vp
argument_list|,
name|mode
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|vn_has_cached_data
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|vp
operator|->
name|v_pages
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return 0 if the vnode in question shouldn't be permitted into a zone via  * zone_enter(2).  */
end_comment

begin_function
name|int
name|vn_can_change_zones
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|struct
name|vfssw
modifier|*
name|vswp
decl_stmt|;
name|int
name|allow
init|=
literal|1
decl_stmt|;
name|vnode_t
modifier|*
name|rvp
decl_stmt|;
if|if
condition|(
name|nfs_global_client_only
operator|!=
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 	 * We always want to look at the underlying vnode if there is one. 	 */
if|if
condition|(
name|VOP_REALVP
argument_list|(
name|vp
argument_list|,
operator|&
name|rvp
argument_list|,
name|NULL
argument_list|)
operator|!=
literal|0
condition|)
name|rvp
operator|=
name|vp
expr_stmt|;
comment|/* 	 * Some pseudo filesystems (including doorfs) don't actually register 	 * their vfsops_t, so the following may return NULL; we happily let 	 * such vnodes switch zones. 	 */
name|vswp
operator|=
name|vfs_getvfsswbyvfsops
argument_list|(
name|vfs_getops
argument_list|(
name|rvp
operator|->
name|v_vfsp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|vswp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|vswp
operator|->
name|vsw_flag
operator|&
name|VSW_NOTZONESAFE
condition|)
name|allow
operator|=
literal|0
expr_stmt|;
name|vfs_unrefvfssw
argument_list|(
name|vswp
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|allow
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return nonzero if the vnode is a mount point, zero if not.  */
end_comment

begin_function
name|int
name|vn_ismntpt
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|vp
operator|->
name|v_vfsmountedhere
operator|!=
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Retrieve the vfs (if any) mounted on this vnode */
end_comment

begin_function
name|vfs_t
modifier|*
name|vn_mountedvfs
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|vp
operator|->
name|v_vfsmountedhere
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return nonzero if the vnode is referenced by the dnlc, zero if not.  */
end_comment

begin_function
name|int
name|vn_in_dnlc
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
return|return
operator|(
name|vp
operator|->
name|v_count_dnlc
operator|>
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vn_has_other_opens() checks whether a particular file is opened by more than  * just the caller and whether the open is for read and/or write.  * This routine is for calling after the caller has already called VOP_OPEN()  * and the caller wishes to know if they are the only one with it open for  * the mode(s) specified.  *  * Vnode counts are only kept on regular files (v_type=VREG).  */
end_comment

begin_function
name|int
name|vn_has_other_opens
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|v_mode_t
name|mode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V_WRITE
case|:
if|if
condition|(
name|vp
operator|->
name|v_wrcnt
operator|>
literal|1
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDORWR
case|:
if|if
condition|(
operator|(
name|vp
operator|->
name|v_rdcnt
operator|>
literal|1
operator|)
operator|||
operator|(
name|vp
operator|->
name|v_wrcnt
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDANDWR
case|:
if|if
condition|(
operator|(
name|vp
operator|->
name|v_rdcnt
operator|>
literal|1
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_wrcnt
operator|>
literal|1
operator|)
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_READ
case|:
if|if
condition|(
name|vp
operator|->
name|v_rdcnt
operator|>
literal|1
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|V_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vn_is_opened() checks whether a particular file is opened and  * whether the open is for read and/or write.  *  * Vnode counts are only kept on regular files (v_type=VREG).  */
end_comment

begin_function
name|int
name|vn_is_opened
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|v_mode_t
name|mode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V_WRITE
case|:
if|if
condition|(
name|vp
operator|->
name|v_wrcnt
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDANDWR
case|:
if|if
condition|(
name|vp
operator|->
name|v_rdcnt
operator|&&
name|vp
operator|->
name|v_wrcnt
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDORWR
case|:
if|if
condition|(
name|vp
operator|->
name|v_rdcnt
operator|||
name|vp
operator|->
name|v_wrcnt
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_READ
case|:
if|if
condition|(
name|vp
operator|->
name|v_rdcnt
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
block|}
return|return
operator|(
name|V_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vn_is_mapped() checks whether a particular file is mapped and whether  * the file is mapped read and/or write.  */
end_comment

begin_function
name|int
name|vn_is_mapped
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|v_mode_t
name|mode
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|_LP64
argument_list|)
switch|switch
condition|(
name|mode
condition|)
block|{
comment|/* 	 * The atomic_add_64_nv functions force atomicity in the 	 * case of 32 bit architectures. Otherwise the 64 bit values 	 * require two fetches. The value of the fields may be 	 * (potentially) changed between the first fetch and the 	 * second 	 */
case|case
name|V_WRITE
case|:
if|if
condition|(
name|atomic_add_64_nv
argument_list|(
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_write
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDANDWR
case|:
if|if
condition|(
operator|(
name|atomic_add_64_nv
argument_list|(
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|&&
operator|(
name|atomic_add_64_nv
argument_list|(
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_write
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDORWR
case|:
if|if
condition|(
operator|(
name|atomic_add_64_nv
argument_list|(
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
operator|(
name|atomic_add_64_nv
argument_list|(
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_write
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_READ
case|:
if|if
condition|(
name|atomic_add_64_nv
argument_list|(
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
block|}
else|#
directive|else
switch|switch
condition|(
name|mode
condition|)
block|{
case|case
name|V_WRITE
case|:
if|if
condition|(
name|vp
operator|->
name|v_mmap_write
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDANDWR
case|:
if|if
condition|(
name|vp
operator|->
name|v_mmap_read
operator|&&
name|vp
operator|->
name|v_mmap_write
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_RDORWR
case|:
if|if
condition|(
name|vp
operator|->
name|v_mmap_read
operator|||
name|vp
operator|->
name|v_mmap_write
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
case|case
name|V_READ
case|:
if|if
condition|(
name|vp
operator|->
name|v_mmap_read
condition|)
return|return
operator|(
name|V_TRUE
operator|)
return|;
break|break;
block|}
endif|#
directive|endif
return|return
operator|(
name|V_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set the operations vector for a vnode.  *  * FEM ensures that the v_femhead pointer is filled in before the  * v_op pointer is changed.  This means that if the v_femhead pointer  * is NULL, and the v_op field hasn't changed since before which checked  * the v_femhead pointer; then our update is ok - we are not racing with  * FEM.  */
end_comment

begin_function
name|void
name|vn_setops
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnodeops_t
modifier|*
name|vnodeops
parameter_list|)
block|{
name|vnodeops_t
modifier|*
name|op
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|vnodeops
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|vp
operator|->
name|v_op
expr_stmt|;
name|membar_consumer
argument_list|()
expr_stmt|;
comment|/* 	 * If vp->v_femhead == NULL, then we'll call atomic_cas_ptr() to do 	 * the compare-and-swap on vp->v_op.  If either fails, then FEM is 	 * in effect on the vnode and we need to have FEM deal with it. 	 */
if|if
condition|(
name|vp
operator|->
name|v_femhead
operator|!=
name|NULL
operator|||
name|atomic_cas_ptr
argument_list|(
operator|&
name|vp
operator|->
name|v_op
argument_list|,
name|op
argument_list|,
name|vnodeops
argument_list|)
operator|!=
name|op
condition|)
block|{
name|fem_setvnops
argument_list|(
name|vp
argument_list|,
name|vnodeops
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Retrieve the operations vector for a vnode  * As with vn_setops(above); make sure we aren't racing with FEM.  * FEM sets the v_op to a special, internal, vnodeops that wouldn't  * make sense to the callers of this routine.  */
end_comment

begin_function
name|vnodeops_t
modifier|*
name|vn_getops
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vnodeops_t
modifier|*
name|op
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|op
operator|=
name|vp
operator|->
name|v_op
expr_stmt|;
name|membar_consumer
argument_list|()
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_femhead
operator|==
name|NULL
operator|&&
name|op
operator|==
name|vp
operator|->
name|v_op
condition|)
block|{
return|return
operator|(
name|op
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|fem_getvnops
argument_list|(
name|vp
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Returns non-zero (1) if the vnodeops matches that of the vnode.  * Returns zero (0) if not.  */
end_comment

begin_function
name|int
name|vn_matchops
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnodeops_t
modifier|*
name|vnodeops
parameter_list|)
block|{
return|return
operator|(
name|vn_getops
argument_list|(
name|vp
argument_list|)
operator|==
name|vnodeops
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns non-zero (1) if the specified operation matches the  * corresponding operation for that the vnode.  * Returns zero (0) if not.  */
end_comment

begin_define
define|#
directive|define
name|MATCHNAME
parameter_list|(
name|n1
parameter_list|,
name|n2
parameter_list|)
value|(((n1)[0] == (n2)[0])&& (strcmp((n1), (n2)) == 0))
end_define

begin_function
name|int
name|vn_matchopval
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
name|vopname
parameter_list|,
name|fs_generic_func_p
name|funcp
parameter_list|)
block|{
specifier|const
name|fs_operation_trans_def_t
modifier|*
name|otdp
decl_stmt|;
name|fs_generic_func_p
modifier|*
name|loc
init|=
name|NULL
decl_stmt|;
name|vnodeops_t
modifier|*
name|vop
init|=
name|vn_getops
argument_list|(
name|vp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|vopname
operator|!=
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|otdp
operator|=
name|vn_ops_table
init|;
name|otdp
operator|->
name|name
operator|!=
name|NULL
condition|;
name|otdp
operator|++
control|)
block|{
if|if
condition|(
name|MATCHNAME
argument_list|(
name|otdp
operator|->
name|name
argument_list|,
name|vopname
argument_list|)
condition|)
block|{
name|loc
operator|=
operator|(
name|fs_generic_func_p
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
operator|(
name|vop
operator|)
operator|+
name|otdp
operator|->
name|offset
operator|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
operator|(
name|loc
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|loc
operator|==
name|funcp
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * fs_new_caller_id() needs to return a unique ID on a given local system.  * The IDs do not need to survive across reboots.  These are primarily  * used so that (FEM) monitors can detect particular callers (such as  * the NFS server) to a given vnode/vfs operation.  */
end_comment

begin_function
name|u_longlong_t
name|fs_new_caller_id
parameter_list|()
block|{
specifier|static
name|uint64_t
name|next_caller_id
init|=
literal|0LL
decl_stmt|;
comment|/* First call returns 1 */
return|return
operator|(
operator|(
name|u_longlong_t
operator|)
name|atomic_inc_64_nv
argument_list|(
operator|&
name|next_caller_id
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Given a starting vnode and a path, updates the path in the target vnode in  * a safe manner.  If the vnode already has path information embedded, then the  * cached path is left untouched.  */
end_comment

begin_decl_stmt
name|size_t
name|max_vnode_path
init|=
literal|4
operator|*
name|MAXPATHLEN
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|vn_setpath
parameter_list|(
name|vnode_t
modifier|*
name|rootvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|startvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|size_t
name|plen
parameter_list|)
block|{
name|char
modifier|*
name|rpath
decl_stmt|;
name|vnode_t
modifier|*
name|base
decl_stmt|;
name|size_t
name|rpathlen
decl_stmt|,
name|rpathalloc
decl_stmt|;
name|int
name|doslash
init|=
literal|1
decl_stmt|;
if|if
condition|(
operator|*
name|path
operator|==
literal|'/'
condition|)
block|{
name|base
operator|=
name|rootvp
expr_stmt|;
name|path
operator|++
expr_stmt|;
name|plen
operator|--
expr_stmt|;
block|}
else|else
block|{
name|base
operator|=
name|startvp
expr_stmt|;
block|}
comment|/* 	 * We cannot grab base->v_lock while we hold vp->v_lock because of 	 * the potential for deadlock. 	 */
name|mutex_enter
argument_list|(
operator|&
name|base
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|v_path
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|base
operator|->
name|v_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|rpathlen
operator|=
name|strlen
argument_list|(
name|base
operator|->
name|v_path
argument_list|)
expr_stmt|;
name|rpathalloc
operator|=
name|rpathlen
operator|+
name|plen
operator|+
literal|1
expr_stmt|;
comment|/* Avoid adding a slash if there's already one there */
if|if
condition|(
name|base
operator|->
name|v_path
index|[
name|rpathlen
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
name|doslash
operator|=
literal|0
expr_stmt|;
else|else
name|rpathalloc
operator|++
expr_stmt|;
comment|/* 	 * We don't want to call kmem_alloc(KM_SLEEP) with kernel locks held, 	 * so we must do this dance.  If, by chance, something changes the path, 	 * just give up since there is no real harm. 	 */
name|mutex_exit
argument_list|(
operator|&
name|base
operator|->
name|v_lock
argument_list|)
expr_stmt|;
comment|/* Paths should stay within reason */
if|if
condition|(
name|rpathalloc
operator|>
name|max_vnode_path
condition|)
return|return;
name|rpath
operator|=
name|kmem_alloc
argument_list|(
name|rpathalloc
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|base
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|->
name|v_path
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|base
operator|->
name|v_path
argument_list|)
operator|!=
name|rpathlen
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|base
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rpath
argument_list|,
name|rpathalloc
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|base
operator|->
name|v_path
argument_list|,
name|rpath
argument_list|,
name|rpathlen
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|base
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|doslash
condition|)
name|rpath
index|[
name|rpathlen
operator|++
index|]
operator|=
literal|'/'
expr_stmt|;
name|bcopy
argument_list|(
name|path
argument_list|,
name|rpath
operator|+
name|rpathlen
argument_list|,
name|plen
argument_list|)
expr_stmt|;
name|rpath
index|[
name|rpathlen
operator|+
name|plen
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_path
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|rpath
argument_list|,
name|rpathalloc
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|vp
operator|->
name|v_path
operator|=
name|rpath
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Sets the path to the vnode to be the given string, regardless of current  * context.  The string must be a complete path from rootdir.  This is only used  * by fsop_root() for setting the path based on the mountpoint.  */
end_comment

begin_function
name|void
name|vn_setpath_str
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|buf
init|=
name|kmem_alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|v_path
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|vp
operator|->
name|v_path
operator|=
name|buf
expr_stmt|;
name|bcopy
argument_list|(
name|str
argument_list|,
name|vp
operator|->
name|v_path
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_path
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Called from within filesystem's vop_rename() to handle renames once the  * target vnode is available.  */
end_comment

begin_function
name|void
name|vn_renamepath
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|tmp
operator|=
name|vp
operator|->
name|v_path
expr_stmt|;
name|vp
operator|->
name|v_path
operator|=
name|NULL
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vp
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|vn_setpath
argument_list|(
name|rootdir
argument_list|,
name|dvp
argument_list|,
name|vp
argument_list|,
name|nm
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
name|NULL
condition|)
name|kmem_free
argument_list|(
name|tmp
argument_list|,
name|strlen
argument_list|(
name|tmp
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Similar to vn_setpath_str(), this function sets the path of the destination  * vnode to the be the same as the source vnode.  */
end_comment

begin_function
name|void
name|vn_copypath
parameter_list|(
name|struct
name|vnode
modifier|*
name|src
parameter_list|,
name|struct
name|vnode
modifier|*
name|dst
parameter_list|)
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|alloc
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|src
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|v_path
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|src
operator|->
name|v_lock
argument_list|)
expr_stmt|;
return|return;
block|}
name|alloc
operator|=
name|strlen
argument_list|(
name|src
operator|->
name|v_path
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* avoid kmem_alloc() with lock held */
name|mutex_exit
argument_list|(
operator|&
name|src
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|buf
operator|=
name|kmem_alloc
argument_list|(
name|alloc
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|src
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|src
operator|->
name|v_path
operator|==
name|NULL
operator|||
name|strlen
argument_list|(
name|src
operator|->
name|v_path
argument_list|)
operator|+
literal|1
operator|!=
name|alloc
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|src
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
return|return;
block|}
name|bcopy
argument_list|(
name|src
operator|->
name|v_path
argument_list|,
name|buf
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|src
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|dst
operator|->
name|v_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|dst
operator|->
name|v_path
operator|!=
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|dst
operator|->
name|v_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|alloc
argument_list|)
expr_stmt|;
return|return;
block|}
name|dst
operator|->
name|v_path
operator|=
name|buf
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|dst
operator|->
name|v_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * XXX Private interface for segvn routines that handle vnode  * large page segments.  *  * return 1 if vp's file system VOP_PAGEIO() implementation  * can be safely used instead of VOP_GETPAGE() for handling  * pagefaults against regular non swap files. VOP_PAGEIO()  * interface is considered safe here if its implementation  * is very close to VOP_GETPAGE() implementation.  * e.g. It zero's out the part of the page beyond EOF. Doesn't  * panic if there're file holes but instead returns an error.  * Doesn't assume file won't be changed by user writes, etc.  *  * return 0 otherwise.  *  * For now allow segvn to only use VOP_PAGEIO() with ufs and nfs.  */
end_comment

begin_function
name|int
name|vn_vmpss_usepageio
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|vfs_t
modifier|*
name|vfsp
init|=
name|vp
operator|->
name|v_vfsp
decl_stmt|;
name|char
modifier|*
name|fsname
init|=
name|vfssw
index|[
name|vfsp
operator|->
name|vfs_fstype
index|]
operator|.
name|vsw_name
decl_stmt|;
name|char
modifier|*
name|pageio_ok_fss
index|[]
init|=
block|{
literal|"ufs"
block|,
literal|"nfs"
block|,
name|NULL
block|}
decl_stmt|;
name|char
modifier|*
modifier|*
name|fsok
init|=
name|pageio_ok_fss
decl_stmt|;
if|if
condition|(
name|fsname
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
init|;
operator|*
name|fsok
condition|;
name|fsok
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|fsok
argument_list|,
name|fsname
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* VOP_XXX() macros call the corresponding fop_xxx() function */
end_comment

begin_function
name|int
name|fop_open
parameter_list|(
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|int
name|mode
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|vnode_t
modifier|*
name|vp
init|=
operator|*
name|vpp
decl_stmt|;
name|VN_HOLD
argument_list|(
name|vp
argument_list|)
expr_stmt|;
comment|/* 	 * Adding to the vnode counts before calling open 	 * avoids the need for a mutex. It circumvents a race 	 * condition where a query made on the vnode counts results in a 	 * false negative. The inquirer goes away believing the file is 	 * not open when there is an open on the file already under way. 	 * 	 * The counts are meant to prevent NFS from granting a delegation 	 * when it would be dangerous to do so. 	 * 	 * The vnode counts are only kept on regular files 	 */
if|if
condition|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|==
name|VREG
condition|)
block|{
if|if
condition|(
name|mode
operator|&
name|FREAD
condition|)
name|atomic_inc_32
argument_list|(
operator|&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_rdcnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|&
name|FWRITE
condition|)
name|atomic_inc_32
argument_list|(
operator|&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_wrcnt
argument_list|)
expr_stmt|;
block|}
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
operator|*
operator|(
operator|*
operator|(
name|vpp
operator|)
operator|)
operator|->
name|v_op
operator|->
name|vop_open
operator|)
operator|(
name|vpp
operator|,
name|mode
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
block|{
comment|/* 		 * Use the saved vp just in case the vnode ptr got trashed 		 * by the error. 		 */
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|open
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|mode
operator|&
name|FREAD
operator|)
condition|)
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_rdcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_wrcnt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * Some filesystems will return a different vnode, 		 * but the same path was still used to open it. 		 * So if we do change the vnode and need to 		 * copy over the path, do so here, rather than special 		 * casing each filesystem. Adjust the vnode counts to 		 * reflect the vnode switch. 		 */
name|VOPSTATS_UPDATE
argument_list|(
operator|*
name|vpp
argument_list|,
name|open
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|vpp
operator|!=
name|vp
operator|&&
operator|*
name|vpp
operator|!=
name|NULL
condition|)
block|{
name|vn_copypath
argument_list|(
name|vp
argument_list|,
operator|*
name|vpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|mode
operator|&
name|FREAD
operator|)
condition|)
name|atomic_inc_32
argument_list|(
operator|&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_rdcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|mode
operator|&
name|FREAD
operator|)
condition|)
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_rdcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
name|atomic_inc_32
argument_list|(
operator|&
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_wrcnt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|mode
operator|&
name|FWRITE
operator|)
condition|)
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_wrcnt
argument_list|)
expr_stmt|;
block|}
block|}
name|VN_RELE
argument_list|(
name|vp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_close
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|count
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_close
operator|)
operator|(
name|vp
operator|,
name|flag
operator|,
name|count
operator|,
name|offset
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|close
argument_list|)
expr_stmt|;
comment|/* 	 * Check passed in count to handle possible dups. Vnode counts are only 	 * kept on regular files 	 */
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
operator|&&
operator|(
name|count
operator|==
literal|1
operator|)
condition|)
block|{
if|if
condition|(
name|flag
operator|&
name|FREAD
condition|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_rdcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_rdcnt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag
operator|&
name|FWRITE
condition|)
block|{
name|ASSERT
argument_list|(
name|vp
operator|->
name|v_wrcnt
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_dec_32
argument_list|(
operator|&
name|vp
operator|->
name|v_wrcnt
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_read
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ssize_t
name|resid_start
init|=
name|uiop
operator|->
name|uio_resid
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_read
operator|)
operator|(
name|vp
operator|,
name|uiop
operator|,
name|ioflag
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE_IO
argument_list|(
name|vp
argument_list|,
name|read
argument_list|,
name|read_bytes
argument_list|,
operator|(
name|resid_start
operator|-
name|uiop
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_write
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ssize_t
name|resid_start
init|=
name|uiop
operator|->
name|uio_resid
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_write
operator|)
operator|(
name|vp
operator|,
name|uiop
operator|,
name|ioflag
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE_IO
argument_list|(
name|vp
argument_list|,
name|write
argument_list|,
name|write_bytes
argument_list|,
operator|(
name|resid_start
operator|-
name|uiop
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_ioctl
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|intptr_t
name|arg
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|rvalp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_ioctl
operator|)
operator|(
name|vp
operator|,
name|cmd
operator|,
name|arg
operator|,
name|flag
operator|,
name|cr
operator|,
name|rvalp
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|ioctl
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_setfl
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|oflags
parameter_list|,
name|int
name|nflags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_setfl
operator|)
operator|(
name|vp
operator|,
name|oflags
operator|,
name|nflags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|setfl
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_getattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* 	 * If this file system doesn't understand the xvattr extensions 	 * then turn off the xvattr bit. 	 */
if|if
condition|(
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_XVATTR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vap
operator|->
name|va_mask
operator|&=
operator|~
name|AT_XVATTR
expr_stmt|;
block|}
comment|/* 	 * We're only allowed to skip the ACL check iff we used a 32 bit 	 * ACE mask with VOP_ACCESS() to determine permissions. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
operator|&&
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_getattr
operator|)
operator|(
name|vp
operator|,
name|vap
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|getattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_setattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* 	 * If this file system doesn't understand the xvattr extensions 	 * then turn off the xvattr bit. 	 */
if|if
condition|(
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_XVATTR
argument_list|)
operator|==
literal|0
condition|)
block|{
name|vap
operator|->
name|va_mask
operator|&=
operator|~
name|AT_XVATTR
expr_stmt|;
block|}
comment|/* 	 * We're only allowed to skip the ACL check iff we used a 32 bit 	 * ACE mask with VOP_ACCESS() to determine permissions. 	 */
if|if
condition|(
operator|(
name|flags
operator|&
name|ATTR_NOACLCHECK
operator|)
operator|&&
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_setattr
operator|)
operator|(
name|vp
operator|,
name|vap
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|setattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_access
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|mode
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|V_ACE_MASK
operator|)
operator|&&
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_access
operator|)
operator|(
name|vp
operator|,
name|mode
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|access
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_lookup
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|pathname_t
modifier|*
name|pnp
parameter_list|,
name|int
name|flags
parameter_list|,
name|vnode_t
modifier|*
name|rdir
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
modifier|*
name|deflags
parameter_list|,
comment|/* Returned per-dirent flags */
name|pathname_t
modifier|*
name|ppnp
parameter_list|)
comment|/* Returned case-preserved name in directory */
block|{
name|int
name|ret
decl_stmt|;
comment|/* 	 * If this file system doesn't support case-insensitive access 	 * and said access is requested, fail quickly.  It is required 	 * that if the vfs supports case-insensitive lookup, it also 	 * supports extended dirent flags. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|dvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|flags
operator|&
name|LOOKUP_XATTR
operator|)
operator|&&
operator|(
name|flags
operator|&
name|LOOKUP_HAVE_SYSATTR_DIR
operator|)
operator|==
literal|0
condition|)
block|{
name|ret
operator|=
name|xattr_dir_lookup
argument_list|(
name|dvp
argument_list|,
name|vpp
argument_list|,
name|flags
argument_list|,
name|cr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ret
operator|=
operator|(
operator|*
operator|(
name|dvp
operator|)
operator|->
name|v_op
operator|->
name|vop_lookup
operator|)
operator|(
name|dvp
operator|,
name|nm
operator|,
name|vpp
operator|,
name|pnp
operator|,
name|flags
operator|,
name|rdir
operator|,
name|cr
operator|,
name|ct
operator|,
name|deflags
operator|,
name|ppnp
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|*
name|vpp
condition|)
block|{
name|VOPSTATS_UPDATE
argument_list|(
operator|*
name|vpp
argument_list|,
name|lookup
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_path
operator|==
name|NULL
condition|)
block|{
name|vn_setpath
argument_list|(
name|rootdir
argument_list|,
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|nm
argument_list|,
name|strlen
argument_list|(
name|nm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_create
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vcexcl_t
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
name|flags
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|)
comment|/* ACL to set during create */
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|vsecp
operator|!=
name|NULL
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACLONCREATE
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * If this file system doesn't support case-insensitive access 	 * and said access is requested, fail quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|dvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
operator|*
operator|(
name|dvp
operator|)
operator|->
name|v_op
operator|->
name|vop_create
operator|)
operator|(
name|dvp
operator|,
name|name
operator|,
name|vap
operator|,
name|excl
operator|,
name|mode
operator|,
name|vpp
operator|,
name|cr
operator|,
name|flags
operator|,
name|ct
operator|,
name|vsecp
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|*
name|vpp
condition|)
block|{
name|VOPSTATS_UPDATE
argument_list|(
operator|*
name|vpp
argument_list|,
name|create
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_path
operator|==
name|NULL
condition|)
block|{
name|vn_setpath
argument_list|(
name|rootdir
argument_list|,
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|name
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_remove
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * If this file system doesn't support case-insensitive access 	 * and said access is requested, fail quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|dvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|dvp
operator|)
operator|->
name|v_op
operator|->
name|vop_remove
operator|)
operator|(
name|dvp
operator|,
name|nm
operator|,
name|cr
operator|,
name|ct
operator|,
name|flags
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|dvp
argument_list|,
name|remove
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_link
parameter_list|(
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|vnode_t
modifier|*
name|svp
parameter_list|,
name|char
modifier|*
name|tnm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * If the target file system doesn't support case-insensitive access 	 * and said access is requested, fail quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
name|vfs_has_feature
argument_list|(
name|tdvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|tdvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|tdvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|tdvp
operator|)
operator|->
name|v_op
operator|->
name|vop_link
operator|)
operator|(
name|tdvp
operator|,
name|svp
operator|,
name|tnm
operator|,
name|cr
operator|,
name|ct
operator|,
name|flags
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|tdvp
argument_list|,
name|link
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_rename
parameter_list|(
name|vnode_t
modifier|*
name|sdvp
parameter_list|,
name|char
modifier|*
name|snm
parameter_list|,
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|char
modifier|*
name|tnm
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * If the file system involved does not support 	 * case-insensitive access and said access is requested, fail 	 * quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
operator|(
name|vfs_has_feature
argument_list|(
name|sdvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|sdvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|tdvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|sdvp
operator|)
operator|->
name|v_op
operator|->
name|vop_rename
operator|)
operator|(
name|sdvp
operator|,
name|snm
operator|,
name|tdvp
operator|,
name|tnm
operator|,
name|cr
operator|,
name|ct
operator|,
name|flags
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|sdvp
argument_list|,
name|rename
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_mkdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|dirname
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|,
name|vsecattr_t
modifier|*
name|vsecp
parameter_list|)
comment|/* ACL to set during create */
block|{
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|vsecp
operator|!=
name|NULL
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACLONCREATE
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
comment|/* 	 * If this file system doesn't support case-insensitive access 	 * and said access is requested, fail quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|dvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|(
operator|*
operator|(
name|dvp
operator|)
operator|->
name|v_op
operator|->
name|vop_mkdir
operator|)
operator|(
name|dvp
operator|,
name|dirname
operator|,
name|vap
operator|,
name|vpp
operator|,
name|cr
operator|,
name|ct
operator|,
name|flags
operator|,
name|vsecp
operator|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
literal|0
operator|&&
operator|*
name|vpp
condition|)
block|{
name|VOPSTATS_UPDATE
argument_list|(
operator|*
name|vpp
argument_list|,
name|mkdir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|vpp
operator|)
operator|->
name|v_path
operator|==
name|NULL
condition|)
block|{
name|vn_setpath
argument_list|(
name|rootdir
argument_list|,
name|dvp
argument_list|,
operator|*
name|vpp
argument_list|,
name|dirname
argument_list|,
name|strlen
argument_list|(
name|dirname
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_rmdir
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|nm
parameter_list|,
name|vnode_t
modifier|*
name|cdir
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * If this file system doesn't support case-insensitive access 	 * and said access is requested, fail quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|dvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|dvp
operator|)
operator|->
name|v_op
operator|->
name|vop_rmdir
operator|)
operator|(
name|dvp
operator|,
name|nm
operator|,
name|cdir
operator|,
name|cr
operator|,
name|ct
operator|,
name|flags
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|dvp
argument_list|,
name|rmdir
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_readdir
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|eofp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|ssize_t
name|resid_start
init|=
name|uiop
operator|->
name|uio_resid
decl_stmt|;
comment|/* 	 * If this file system doesn't support retrieving directory 	 * entry flags and said access is requested, fail quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|V_RDDIR_ENTFLAGS
operator|&&
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_DIRENTFLAGS
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_readdir
operator|)
operator|(
name|vp
operator|,
name|uiop
operator|,
name|cr
operator|,
name|eofp
operator|,
name|ct
operator|,
name|flags
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE_IO
argument_list|(
name|vp
argument_list|,
name|readdir
argument_list|,
name|readdir_bytes
argument_list|,
operator|(
name|resid_start
operator|-
name|uiop
operator|->
name|uio_resid
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_symlink
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|linkname
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|char
modifier|*
name|target
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|xvattr_t
name|xvattr
decl_stmt|;
comment|/* 	 * If this file system doesn't support case-insensitive access 	 * and said access is requested, fail quickly. 	 */
if|if
condition|(
name|flags
operator|&
name|FIGNORECASE
operator|&&
operator|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_CASEINSENSITIVE
argument_list|)
operator|==
literal|0
operator|&&
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_NOCASESENSITIVE
argument_list|)
operator|==
literal|0
operator|)
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|VOPXID_MAP_CR
argument_list|(
name|dvp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* check for reparse point */
if|if
condition|(
operator|(
name|vfs_has_feature
argument_list|(
name|dvp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_REPARSE
argument_list|)
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
name|target
argument_list|,
name|FS_REPARSE_TAG_STR
argument_list|,
name|strlen
argument_list|(
name|FS_REPARSE_TAG_STR
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|fs_reparse_mark
argument_list|(
name|target
argument_list|,
name|vap
argument_list|,
operator|&
name|xvattr
argument_list|)
condition|)
name|vap
operator|=
operator|(
name|vattr_t
operator|*
operator|)
operator|&
name|xvattr
expr_stmt|;
block|}
name|err
operator|=
operator|(
operator|*
operator|(
name|dvp
operator|)
operator|->
name|v_op
operator|->
name|vop_symlink
operator|)
operator|(
name|dvp
operator|,
name|linkname
operator|,
name|vap
operator|,
name|target
operator|,
name|cr
operator|,
name|ct
operator|,
name|flags
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|dvp
argument_list|,
name|symlink
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_readlink
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uio_t
modifier|*
name|uiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_readlink
operator|)
operator|(
name|vp
operator|,
name|uiop
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|readlink
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_fsync
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|syncflag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_fsync
operator|)
operator|(
name|vp
operator|,
name|syncflag
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|fsync
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fop_inactive
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
comment|/* Need to update stats before vop call since we may lose the vnode */
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|inactive
argument_list|)
expr_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_inactive
operator|)
operator|(
name|vp
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fop_fid
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|fid_t
modifier|*
name|fidp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_fid
operator|)
operator|(
name|vp
operator|,
name|fidp
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|fid
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_rwlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|write_lock
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
operator|(
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_rwlock
operator|)
operator|(
name|vp
operator|,
name|write_lock
operator|,
name|ct
operator|)
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|rwlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fop_rwunlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|write_lock
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_rwunlock
operator|)
operator|(
name|vp
operator|,
name|write_lock
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|rwunlock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fop_seek
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|ooff
parameter_list|,
name|offset_t
modifier|*
name|noffp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_seek
operator|)
operator|(
name|vp
operator|,
name|ooff
operator|,
name|noffp
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|seek
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_cmp
parameter_list|(
name|vnode_t
modifier|*
name|vp1
parameter_list|,
name|vnode_t
modifier|*
name|vp2
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp1
operator|)
operator|->
name|v_op
operator|->
name|vop_cmp
operator|)
operator|(
name|vp1
operator|,
name|vp2
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp1
argument_list|,
name|cmp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_frlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|flock64_t
modifier|*
name|bfp
parameter_list|,
name|int
name|flag
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|struct
name|flk_callback
modifier|*
name|flk_cbp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_frlock
operator|)
operator|(
name|vp
operator|,
name|cmd
operator|,
name|bfp
operator|,
name|flag
operator|,
name|offset
operator|,
name|flk_cbp
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|frlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_space
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|flock64_t
modifier|*
name|bfp
parameter_list|,
name|int
name|flag
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_space
operator|)
operator|(
name|vp
operator|,
name|cmd
operator|,
name|bfp
operator|,
name|flag
operator|,
name|offset
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|space
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_realvp
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnode_t
modifier|*
modifier|*
name|vpp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_realvp
operator|)
operator|(
name|vp
operator|,
name|vpp
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|realvp
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_getpage
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint_t
modifier|*
name|protp
parameter_list|,
name|page_t
modifier|*
modifier|*
name|plarr
parameter_list|,
name|size_t
name|plsz
parameter_list|,
name|struct
name|seg
modifier|*
name|seg
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|enum
name|seg_rw
name|rw
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_getpage
operator|)
operator|(
name|vp
operator|,
name|off
operator|,
name|len
operator|,
name|protp
operator|,
name|plarr
operator|,
name|plsz
operator|,
name|seg
operator|,
name|addr
operator|,
name|rw
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|getpage
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_putpage
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|size_t
name|len
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_putpage
operator|)
operator|(
name|vp
operator|,
name|off
operator|,
name|len
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|putpage
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_map
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|struct
name|as
modifier|*
name|as
parameter_list|,
name|caddr_t
modifier|*
name|addrp
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uchar_t
name|prot
parameter_list|,
name|uchar_t
name|maxprot
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_map
operator|)
operator|(
name|vp
operator|,
name|off
operator|,
name|as
operator|,
name|addrp
operator|,
name|len
operator|,
name|prot
operator|,
name|maxprot
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|map
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_addmap
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|struct
name|as
modifier|*
name|as
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uchar_t
name|prot
parameter_list|,
name|uchar_t
name|maxprot
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_longlong_t
name|delta
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_addmap
operator|)
operator|(
name|vp
operator|,
name|off
operator|,
name|as
operator|,
name|addr
operator|,
name|len
operator|,
name|prot
operator|,
name|maxprot
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|error
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|delta
operator|=
operator|(
name|u_longlong_t
operator|)
name|btopr
argument_list|(
name|len
argument_list|)
expr_stmt|;
comment|/* 		 * If file is declared MAP_PRIVATE, it can't be written back 		 * even if open for write. Handle as read. 		 */
if|if
condition|(
name|flags
operator|&
name|MAP_PRIVATE
condition|)
block|{
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
operator|(
name|int64_t
operator|)
name|delta
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * atomic_add_64 forces the fetch of a 64 bit value to 			 * be atomic on 32 bit machines 			 */
if|if
condition|(
name|maxprot
operator|&
name|PROT_WRITE
condition|)
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_write
operator|)
operator|)
argument_list|,
operator|(
name|int64_t
operator|)
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxprot
operator|&
name|PROT_READ
condition|)
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
operator|(
name|int64_t
operator|)
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxprot
operator|&
name|PROT_EXEC
condition|)
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
operator|(
name|int64_t
operator|)
name|delta
argument_list|)
expr_stmt|;
block|}
block|}
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|addmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_delmap
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|offset_t
name|off
parameter_list|,
name|struct
name|as
modifier|*
name|as
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|size_t
name|len
parameter_list|,
name|uint_t
name|prot
parameter_list|,
name|uint_t
name|maxprot
parameter_list|,
name|uint_t
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
name|u_longlong_t
name|delta
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|error
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_delmap
operator|)
operator|(
name|vp
operator|,
name|off
operator|,
name|as
operator|,
name|addr
operator|,
name|len
operator|,
name|prot
operator|,
name|maxprot
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
comment|/* 	 * NFS calls into delmap twice, the first time 	 * it simply establishes a callback mechanism and returns EAGAIN 	 * while the real work is being done upon the second invocation. 	 * We have to detect this here and only decrement the counts upon 	 * the second delmap request. 	 */
if|if
condition|(
operator|(
name|error
operator|!=
name|EAGAIN
operator|)
operator|&&
operator|(
name|vp
operator|->
name|v_type
operator|==
name|VREG
operator|)
condition|)
block|{
name|delta
operator|=
operator|(
name|u_longlong_t
operator|)
name|btopr
argument_list|(
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|MAP_PRIVATE
condition|)
block|{
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
operator|-
name|delta
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * atomic_add_64 forces the fetch of a 64 bit value 			 * to be atomic on 32 bit machines 			 */
if|if
condition|(
name|maxprot
operator|&
name|PROT_WRITE
condition|)
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_write
operator|)
operator|)
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
operator|-
name|delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxprot
operator|&
name|PROT_READ
condition|)
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
operator|-
name|delta
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|maxprot
operator|&
name|PROT_EXEC
condition|)
name|atomic_add_64
argument_list|(
operator|(
name|uint64_t
operator|*
operator|)
operator|(
operator|&
operator|(
name|vp
operator|->
name|v_mmap_read
operator|)
operator|)
argument_list|,
call|(
name|int64_t
call|)
argument_list|(
operator|-
name|delta
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|delmap
argument_list|)
expr_stmt|;
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_poll
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|short
name|events
parameter_list|,
name|int
name|anyyet
parameter_list|,
name|short
modifier|*
name|reventsp
parameter_list|,
name|struct
name|pollhead
modifier|*
modifier|*
name|phpp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_poll
operator|)
operator|(
name|vp
operator|,
name|events
operator|,
name|anyyet
operator|,
name|reventsp
operator|,
name|phpp
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|poll
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_dump
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|caddr_t
name|addr
parameter_list|,
name|offset_t
name|lbdn
parameter_list|,
name|offset_t
name|dblks
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* ensure lbdn and dblks can be passed safely to bdev_dump */
if|if
condition|(
operator|(
name|lbdn
operator|!=
operator|(
name|daddr_t
operator|)
name|lbdn
operator|)
operator|||
operator|(
name|dblks
operator|!=
operator|(
name|int
operator|)
name|dblks
operator|)
condition|)
return|return
operator|(
name|EIO
operator|)
return|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_dump
operator|)
operator|(
name|vp
operator|,
name|addr
operator|,
name|lbdn
operator|,
name|dblks
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|dump
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_pathconf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|ulong_t
modifier|*
name|valp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_pathconf
operator|)
operator|(
name|vp
operator|,
name|cmd
operator|,
name|valp
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|pathconf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_pageio
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|struct
name|page
modifier|*
name|pp
parameter_list|,
name|u_offset_t
name|io_off
parameter_list|,
name|size_t
name|io_len
parameter_list|,
name|int
name|flags
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_pageio
operator|)
operator|(
name|vp
operator|,
name|pp
operator|,
name|io_off
operator|,
name|io_len
operator|,
name|flags
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|pageio
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_dumpctl
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|action
parameter_list|,
name|offset_t
modifier|*
name|blkp
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_dumpctl
operator|)
operator|(
name|vp
operator|,
name|action
operator|,
name|blkp
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|dumpctl
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fop_dispose
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|page_t
modifier|*
name|pp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|dn
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
comment|/* Must do stats first since it's possible to lose the vnode */
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|dispose
argument_list|)
expr_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_dispose
operator|)
operator|(
name|vp
operator|,
name|pp
operator|,
name|flag
operator|,
name|dn
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|fop_setsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsap
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
comment|/* 	 * We're only allowed to skip the ACL check iff we used a 32 bit 	 * ACE mask with VOP_ACCESS() to determine permissions. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
operator|&&
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_setsecattr
operator|)
operator|(
name|vp
operator|,
name|vsap
operator|,
name|flag
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|setsecattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_getsecattr
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vsecattr_t
modifier|*
name|vsap
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
comment|/* 	 * We're only allowed to skip the ACL check iff we used a 32 bit 	 * ACE mask with VOP_ACCESS() to determine permissions. 	 */
if|if
condition|(
operator|(
name|flag
operator|&
name|ATTR_NOACLCHECK
operator|)
operator|&&
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ACEMASKONACCESS
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_getsecattr
operator|)
operator|(
name|vp
operator|,
name|vsap
operator|,
name|flag
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|getsecattr
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_shrlock
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|int
name|cmd
parameter_list|,
name|struct
name|shrlock
modifier|*
name|shr
parameter_list|,
name|int
name|flag
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|VOPXID_MAP_CR
argument_list|(
name|vp
argument_list|,
name|cr
argument_list|)
expr_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_shrlock
operator|)
operator|(
name|vp
operator|,
name|cmd
operator|,
name|shr
operator|,
name|flag
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|shrlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_vnevent
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|vnevent_t
name|vnevent
parameter_list|,
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|char
modifier|*
name|fnm
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_vnevent
operator|)
operator|(
name|vp
operator|,
name|vnevent
operator|,
name|dvp
operator|,
name|fnm
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|vnevent
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_reqzcbuf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|enum
name|uio_rw
name|ioflag
parameter_list|,
name|xuio_t
modifier|*
name|uiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ZEROCOPY_SUPPORTED
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_reqzcbuf
operator|)
operator|(
name|vp
operator|,
name|ioflag
operator|,
name|uiop
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|reqzcbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_function
name|int
name|fop_retzcbuf
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|xuio_t
modifier|*
name|uiop
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|int
name|err
decl_stmt|;
if|if
condition|(
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_ZEROCOPY_SUPPORTED
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ENOTSUP
operator|)
return|;
name|err
operator|=
operator|(
operator|*
operator|(
name|vp
operator|)
operator|->
name|v_op
operator|->
name|vop_retzcbuf
operator|)
operator|(
name|vp
operator|,
name|uiop
operator|,
name|cr
operator|,
name|ct
operator|)
expr_stmt|;
name|VOPSTATS_UPDATE
argument_list|(
name|vp
argument_list|,
name|retzcbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|err
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Default destructor  *	Needed because NULL destructor means that the key is unused  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|void
name|vsd_defaultdestructor
parameter_list|(
name|void
modifier|*
name|value
parameter_list|)
block|{}
end_function

begin_comment
comment|/*  * Create a key (index into per vnode array)  *	Locks out vsd_create, vsd_destroy, and vsd_free  *	May allocate memory with lock held  */
end_comment

begin_function
name|void
name|vsd_create
parameter_list|(
name|uint_t
modifier|*
name|keyp
parameter_list|,
name|void
function_decl|(
modifier|*
name|destructor
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|uint_t
name|nkeys
decl_stmt|;
comment|/* 	 * if key is allocated, do nothing 	 */
name|mutex_enter
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|keyp
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * find an unused key 	 */
if|if
condition|(
name|destructor
operator|==
name|NULL
condition|)
name|destructor
operator|=
name|vsd_defaultdestructor
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsd_nkeys
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|vsd_destructor
index|[
name|i
index|]
operator|==
name|NULL
condition|)
break|break;
comment|/* 	 * if no unused keys, increase the size of the destructor array 	 */
if|if
condition|(
name|i
operator|==
name|vsd_nkeys
condition|)
block|{
if|if
condition|(
operator|(
name|nkeys
operator|=
operator|(
name|vsd_nkeys
operator|<<
literal|1
operator|)
operator|)
operator|==
literal|0
condition|)
name|nkeys
operator|=
literal|1
expr_stmt|;
name|vsd_destructor
operator|=
operator|(
name|void
argument_list|(
operator|*
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
operator|)
name|vsd_realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|vsd_destructor
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|vsd_nkeys
operator|*
sizeof|sizeof
argument_list|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
argument_list|)
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|nkeys
operator|*
sizeof|sizeof
argument_list|(
name|void
argument_list|(
operator|*
argument_list|)
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|vsd_nkeys
operator|=
name|nkeys
expr_stmt|;
block|}
comment|/* 	 * allocate the next available unused key 	 */
name|vsd_destructor
index|[
name|i
index|]
operator|=
name|destructor
expr_stmt|;
operator|*
name|keyp
operator|=
name|i
operator|+
literal|1
expr_stmt|;
comment|/* create vsd_list, if it doesn't exist */
if|if
condition|(
name|vsd_list
operator|==
name|NULL
condition|)
block|{
name|vsd_list
operator|=
name|kmem_alloc
argument_list|(
sizeof|sizeof
argument_list|(
name|list_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|list_create
argument_list|(
name|vsd_list
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vsd_node
argument_list|)
argument_list|,
name|offsetof
argument_list|(
expr|struct
name|vsd_node
argument_list|,
name|vs_nodes
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Destroy a key  *  * Assumes that the caller is preventing vsd_set and vsd_get  * Locks out vsd_create, vsd_destroy, and vsd_free  * May free memory with lock held  */
end_comment

begin_function
name|void
name|vsd_destroy
parameter_list|(
name|uint_t
modifier|*
name|keyp
parameter_list|)
block|{
name|uint_t
name|key
decl_stmt|;
name|struct
name|vsd_node
modifier|*
name|vsd
decl_stmt|;
comment|/* 	 * protect the key namespace and our destructor lists 	 */
name|mutex_enter
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
name|key
operator|=
operator|*
name|keyp
expr_stmt|;
operator|*
name|keyp
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|key
operator|<=
name|vsd_nkeys
argument_list|)
expr_stmt|;
comment|/* 	 * if the key is valid 	 */
if|if
condition|(
name|key
operator|!=
literal|0
condition|)
block|{
name|uint_t
name|k
init|=
name|key
operator|-
literal|1
decl_stmt|;
comment|/* 		 * for every vnode with VSD, call key's destructor 		 */
for|for
control|(
name|vsd
operator|=
name|list_head
argument_list|(
name|vsd_list
argument_list|)
init|;
name|vsd
operator|!=
name|NULL
condition|;
name|vsd
operator|=
name|list_next
argument_list|(
name|vsd_list
argument_list|,
name|vsd
argument_list|)
control|)
block|{
comment|/* 			 * no VSD for key in this vnode 			 */
if|if
condition|(
name|key
operator|>
name|vsd
operator|->
name|vs_nkeys
condition|)
continue|continue;
comment|/* 			 * call destructor for key 			 */
if|if
condition|(
name|vsd
operator|->
name|vs_value
index|[
name|k
index|]
operator|&&
name|vsd_destructor
index|[
name|k
index|]
condition|)
call|(
modifier|*
name|vsd_destructor
index|[
name|k
index|]
call|)
argument_list|(
name|vsd
operator|->
name|vs_value
index|[
name|k
index|]
argument_list|)
expr_stmt|;
comment|/* 			 * reset value for key 			 */
name|vsd
operator|->
name|vs_value
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 		 * actually free the key (NULL destructor == unused) 		 */
name|vsd_destructor
index|[
name|k
index|]
operator|=
name|NULL
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Quickly return the per vnode value that was stored with the specified key  * Assumes the caller is protecting key from vsd_create and vsd_destroy  * Assumes the caller is holding v_vsd_lock to protect the vsd.  */
end_comment

begin_function
name|void
modifier|*
name|vsd_get
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uint_t
name|key
parameter_list|)
block|{
name|struct
name|vsd_node
modifier|*
name|vsd
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mutex_owned
argument_list|(
operator|&
name|vp
operator|->
name|v_vsd_lock
argument_list|)
argument_list|)
expr_stmt|;
name|vsd
operator|=
name|vp
operator|->
name|v_vsd
expr_stmt|;
if|if
condition|(
name|key
operator|&&
name|vsd
operator|!=
name|NULL
operator|&&
name|key
operator|<=
name|vsd
operator|->
name|vs_nkeys
condition|)
return|return
operator|(
name|vsd
operator|->
name|vs_value
index|[
name|key
operator|-
literal|1
index|]
operator|)
return|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Set a per vnode value indexed with the specified key  * Assumes the caller is holding v_vsd_lock to protect the vsd.  */
end_comment

begin_function
name|int
name|vsd_set
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|uint_t
name|key
parameter_list|,
name|void
modifier|*
name|value
parameter_list|)
block|{
name|struct
name|vsd_node
modifier|*
name|vsd
decl_stmt|;
name|ASSERT
argument_list|(
name|vp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|mutex_owned
argument_list|(
operator|&
name|vp
operator|->
name|v_vsd_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|vsd
operator|=
name|vp
operator|->
name|v_vsd
expr_stmt|;
if|if
condition|(
name|vsd
operator|==
name|NULL
condition|)
name|vsd
operator|=
name|vp
operator|->
name|v_vsd
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|vsd
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * If the vsd was just allocated, vs_nkeys will be 0, so the following 	 * code won't happen and we will continue down and allocate space for 	 * the vs_value array. 	 * If the caller is replacing one value with another, then it is up 	 * to the caller to free/rele/destroy the previous value (if needed). 	 */
if|if
condition|(
name|key
operator|<=
name|vsd
operator|->
name|vs_nkeys
condition|)
block|{
name|vsd
operator|->
name|vs_value
index|[
name|key
operator|-
literal|1
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|key
operator|<=
name|vsd_nkeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|vsd
operator|->
name|vs_nkeys
operator|==
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
comment|/* lock out vsd_destroy() */
comment|/* 		 * Link onto list of all VSD nodes. 		 */
name|list_insert_head
argument_list|(
name|vsd_list
argument_list|,
name|vsd
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Allocate vnode local storage and set the value for key 	 */
name|vsd
operator|->
name|vs_value
operator|=
name|vsd_realloc
argument_list|(
name|vsd
operator|->
name|vs_value
argument_list|,
name|vsd
operator|->
name|vs_nkeys
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|,
name|key
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|vsd
operator|->
name|vs_nkeys
operator|=
name|key
expr_stmt|;
name|vsd
operator|->
name|vs_value
index|[
name|key
operator|-
literal|1
index|]
operator|=
name|value
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Called from vn_free() to run the destructor function for each vsd  *	Locks out vsd_create and vsd_destroy  *	Assumes that the destructor *DOES NOT* use vsd  */
end_comment

begin_function
name|void
name|vsd_free
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|vsd_node
modifier|*
name|vsd
init|=
name|vp
operator|->
name|v_vsd
decl_stmt|;
if|if
condition|(
name|vsd
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|vsd
operator|->
name|vs_nkeys
operator|==
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|vsd
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|vsd
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vsd
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
comment|/* 	 * lock out vsd_create and vsd_destroy, call 	 * the destructor, and mark the value as destroyed. 	 */
name|mutex_enter
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|vsd
operator|->
name|vs_nkeys
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|vsd
operator|->
name|vs_value
index|[
name|i
index|]
operator|&&
name|vsd_destructor
index|[
name|i
index|]
condition|)
call|(
modifier|*
name|vsd_destructor
index|[
name|i
index|]
call|)
argument_list|(
name|vsd
operator|->
name|vs_value
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|vsd
operator|->
name|vs_value
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
block|}
comment|/* 	 * remove from linked list of VSD nodes 	 */
name|list_remove
argument_list|(
name|vsd_list
argument_list|,
name|vsd
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|vsd_lock
argument_list|)
expr_stmt|;
comment|/* 	 * free up the VSD 	 */
name|kmem_free
argument_list|(
name|vsd
operator|->
name|vs_value
argument_list|,
name|vsd
operator|->
name|vs_nkeys
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|vsd
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|vsd_node
argument_list|)
argument_list|)
expr_stmt|;
name|vp
operator|->
name|v_vsd
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * realloc  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|vsd_realloc
parameter_list|(
name|void
modifier|*
name|old
parameter_list|,
name|size_t
name|osize
parameter_list|,
name|size_t
name|nsize
parameter_list|)
block|{
name|void
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|kmem_zalloc
argument_list|(
name|nsize
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|old
condition|)
block|{
name|bcopy
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|osize
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|old
argument_list|,
name|osize
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Setup the extensible system attribute for creating a reparse point.  * The symlink data 'target' is validated for proper format of a reparse  * string and a check also made to make sure the symlink data does not  * point to an existing file.  *  * return 0 if ok else -1.  */
end_comment

begin_function
specifier|static
name|int
name|fs_reparse_mark
parameter_list|(
name|char
modifier|*
name|target
parameter_list|,
name|vattr_t
modifier|*
name|vap
parameter_list|,
name|xvattr_t
modifier|*
name|xvattr
parameter_list|)
block|{
name|xoptattr_t
modifier|*
name|xoap
decl_stmt|;
if|if
condition|(
operator|(
operator|!
name|target
operator|)
operator|||
operator|(
operator|!
name|vap
operator|)
operator|||
operator|(
operator|!
name|xvattr
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* validate reparse string */
if|if
condition|(
name|reparse_validate
argument_list|(
operator|(
specifier|const
name|char
operator|*
operator|)
name|target
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|xva_init
argument_list|(
name|xvattr
argument_list|)
expr_stmt|;
name|xvattr
operator|->
name|xva_vattr
operator|=
operator|*
name|vap
expr_stmt|;
name|xvattr
operator|->
name|xva_vattr
operator|.
name|va_mask
operator||=
name|AT_XVATTR
expr_stmt|;
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
name|xvattr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xoap
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
name|xvattr
argument_list|,
name|XAT_REPARSE
argument_list|)
expr_stmt|;
name|xoap
operator|->
name|xoa_reparse
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function to check whether a symlink is a reparse point.  * Return B_TRUE if it is a reparse point, else return B_FALSE  */
end_comment

begin_function
name|boolean_t
name|vn_is_reparse
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
block|{
name|xvattr_t
name|xvattr
decl_stmt|;
name|xoptattr_t
modifier|*
name|xoap
decl_stmt|;
if|if
condition|(
operator|(
name|vp
operator|->
name|v_type
operator|!=
name|VLNK
operator|)
operator|||
operator|!
operator|(
name|vfs_has_feature
argument_list|(
name|vp
operator|->
name|v_vfsp
argument_list|,
name|VFSFT_XVATTR
argument_list|)
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
name|xva_init
argument_list|(
operator|&
name|xvattr
argument_list|)
expr_stmt|;
name|xoap
operator|=
name|xva_getxoptattr
argument_list|(
operator|&
name|xvattr
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|xoap
argument_list|)
expr_stmt|;
name|XVA_SET_REQ
argument_list|(
operator|&
name|xvattr
argument_list|,
name|XAT_REPARSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|VOP_GETATTR
argument_list|(
name|vp
argument_list|,
operator|&
name|xvattr
operator|.
name|xva_vattr
argument_list|,
literal|0
argument_list|,
name|cr
argument_list|,
name|ct
argument_list|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
if|if
condition|(
operator|(
operator|!
operator|(
name|xvattr
operator|.
name|xva_vattr
operator|.
name|va_mask
operator|&
name|AT_XVATTR
operator|)
operator|)
operator|||
operator|(
operator|!
operator|(
name|XVA_ISSET_RTN
argument_list|(
operator|&
name|xvattr
argument_list|,
name|XAT_REPARSE
argument_list|)
operator|)
operator|)
condition|)
return|return
operator|(
name|B_FALSE
operator|)
return|;
return|return
operator|(
name|xoap
operator|->
name|xoa_reparse
condition|?
name|B_TRUE
else|:
name|B_FALSE
operator|)
return|;
block|}
end_function

end_unit

