begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright 2007 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/* crc32.c -- compute the CRC-32 of a data stream  * Copyright (C) 1995-2005 Mark Adler  * For conditions of distribution and use, see copyright notice in zlib.h  *  * Thanks to Rodney Brown<rbrown64@csc.com.au> for his contribution of faster  * CRC methods: exclusive-oring 32 bits of data at a time, and pre-computing  * tables for updating the shift register in one step with three exclusive-ors  * instead of four steps with four exclusive-ors.  This results in about a  * factor of two increase in speed on a Power PC G4 (PPC7455) using gcc -O3.  */
end_comment

begin_pragma
pragma|#
directive|pragma
name|ident
literal|"%Z%%M%	%I%	%E% SMI"
end_pragma

begin_comment
comment|/*   Note on the use of DYNAMIC_CRC_TABLE: there is no mutex or semaphore   protection on the static variables used to control the first-use generation   of the crc tables.  Therefore, if you #define DYNAMIC_CRC_TABLE, you should   first call get_crc_table() to initialize the tables before allowing more than   one thread to use crc32().  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAKECRCH
end_ifdef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|DYNAMIC_CRC_TABLE
end_ifndef

begin_define
define|#
directive|define
name|DYNAMIC_CRC_TABLE
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !DYNAMIC_CRC_TABLE */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKECRCH */
end_comment

begin_include
include|#
directive|include
file|"zutil.h"
end_include

begin_comment
comment|/* for STDC and FAR definitions */
end_comment

begin_define
define|#
directive|define
name|local
value|static
end_define

begin_comment
comment|/* Find a four-byte integer type for crc32_little() and crc32_big(). */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NOBYFOUR
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|STDC
end_ifdef

begin_comment
comment|/* need ANSI C limits.h to determine sizes */
end_comment

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_define
define|#
directive|define
name|BYFOUR
end_define

begin_if
if|#
directive|if
operator|(
name|UINT_MAX
operator|==
literal|0xffffffffUL
operator|)
end_if

begin_typedef
typedef|typedef
name|unsigned
name|int
name|u4
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|ULONG_MAX
operator|==
literal|0xffffffffUL
operator|)
end_if

begin_typedef
typedef|typedef
name|unsigned
name|long
name|u4
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
operator|(
name|USHRT_MAX
operator|==
literal|0xffffffffUL
operator|)
end_if

begin_typedef
typedef|typedef
name|unsigned
name|short
name|u4
typedef|;
end_typedef

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|BYFOUR
end_undef

begin_comment
comment|/* can't find a four-byte integer type! */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* STDC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NOBYFOUR */
end_comment

begin_comment
comment|/* Definitions for doing the crc four data bytes at a time. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|BYFOUR
end_ifdef

begin_define
define|#
directive|define
name|REV
parameter_list|(
name|w
parameter_list|)
value|(((w)>>24)+(((w)>>8)&0xff00)+ \                 (((w)&0xff00)<<8)+(((w)&0xff)<<24))
end_define

begin_decl_stmt
name|local
name|unsigned
name|long
name|crc32_little
name|OF
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|long
name|crc32_big
name|OF
argument_list|(
operator|(
name|unsigned
name|long
operator|,
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|,
name|unsigned
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TBLS
value|8
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|TBLS
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BYFOUR */
end_comment

begin_comment
comment|/* Local functions for crc concatenation */
end_comment

begin_decl_stmt
name|local
name|unsigned
name|long
name|gf2_matrix_times
name|OF
argument_list|(
operator|(
name|unsigned
name|long
operator|*
name|mat
operator|,
name|unsigned
name|long
name|vec
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|gf2_matrix_square
name|OF
argument_list|(
operator|(
name|unsigned
name|long
operator|*
name|square
operator|,
name|unsigned
name|long
operator|*
name|mat
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|DYNAMIC_CRC_TABLE
end_ifdef

begin_decl_stmt
name|local
specifier|volatile
name|int
name|crc_table_empty
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|unsigned
name|long
name|FAR
name|crc_table
index|[
name|TBLS
index|]
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|local
name|void
name|make_crc_table
name|OF
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAKECRCH
end_ifdef

begin_decl_stmt
name|local
name|void
name|write_table
name|OF
argument_list|(
operator|(
name|FILE
operator|*
operator|,
specifier|const
name|unsigned
name|long
name|FAR
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKECRCH */
end_comment

begin_comment
comment|/*   Generate tables for a byte-wise 32-bit CRC calculation on the polynomial:   x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.    Polynomials over GF(2) are represented in binary, one bit per coefficient,   with the lowest powers in the most significant bit.  Then adding polynomials   is just exclusive-or, and multiplying a polynomial by x is a right shift by   one.  If we call the above polynomial p, and represent a byte as the   polynomial q, also with the lowest power in the most significant bit (so the   byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,   where a mod b means the remainder after dividing a by b.    This calculation is done using the shift-register method of multiplying and   taking the remainder.  The register is initialized to zero, and for each   incoming bit, x^32 is added mod p to the register if the bit is a one (where   x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by   x (which is shifting right by one and adding x^32 mod p if the bit shifted   out is a one).  We start with the highest power (least significant bit) of   q and repeat for all eight bits of q.    The first table is simply the CRC of all possible eight bit values.  This is   all the information needed to generate CRCs on data a byte at a time for all   combinations of CRC register values and incoming bytes.  The remaining tables   allow for word-at-a-time CRC calculation for both big-endian and little-   endian machines, where a word is four bytes. */
end_comment

begin_function
name|local
name|void
name|make_crc_table
parameter_list|()
block|{
name|unsigned
name|long
name|c
decl_stmt|;
name|int
name|n
decl_stmt|,
name|k
decl_stmt|;
name|unsigned
name|long
name|poly
decl_stmt|;
comment|/* polynomial exclusive-or pattern */
comment|/* terms of polynomial defining this crc (except x^32): */
specifier|static
specifier|volatile
name|int
name|first
init|=
literal|1
decl_stmt|;
comment|/* flag to limit concurrent making */
specifier|static
specifier|const
name|unsigned
name|char
name|p
index|[]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|5
block|,
literal|7
block|,
literal|8
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|16
block|,
literal|22
block|,
literal|23
block|,
literal|26
block|}
decl_stmt|;
comment|/* See if another task is already doing this (not thread-safe, but better        than nothing -- significantly reduces duration of vulnerability in        case the advice about DYNAMIC_CRC_TABLE is ignored) */
if|if
condition|(
name|first
condition|)
block|{
name|first
operator|=
literal|0
expr_stmt|;
comment|/* make exclusive-or pattern from polynomial (0xedb88320UL) */
name|poly
operator|=
literal|0UL
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
sizeof|sizeof
argument_list|(
name|p
argument_list|)
operator|/
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
condition|;
name|n
operator|++
control|)
name|poly
operator||=
literal|1UL
operator|<<
operator|(
literal|31
operator|-
name|p
index|[
name|n
index|]
operator|)
expr_stmt|;
comment|/* generate a crc for every 8-bit value */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
operator|(
name|unsigned
name|long
operator|)
name|n
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
name|c
operator|=
name|c
operator|&
literal|1
condition|?
name|poly
operator|^
operator|(
name|c
operator|>>
literal|1
operator|)
else|:
name|c
operator|>>
literal|1
expr_stmt|;
name|crc_table
index|[
literal|0
index|]
index|[
name|n
index|]
operator|=
name|c
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BYFOUR
comment|/* generate crc for each value followed by one, two, and three zeros,            and then the byte reversal of those as well as the first table */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
name|n
index|]
expr_stmt|;
name|crc_table
index|[
literal|4
index|]
index|[
name|n
index|]
operator|=
name|REV
argument_list|(
name|c
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|4
condition|;
name|k
operator|++
control|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
name|c
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>
literal|8
operator|)
expr_stmt|;
name|crc_table
index|[
name|k
index|]
index|[
name|n
index|]
operator|=
name|c
expr_stmt|;
name|crc_table
index|[
name|k
operator|+
literal|4
index|]
index|[
name|n
index|]
operator|=
name|REV
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* BYFOUR */
name|crc_table_empty
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* not first */
comment|/* wait for the other guy to finish (not efficient, but rare) */
while|while
condition|(
name|crc_table_empty
condition|)
empty_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAKECRCH
comment|/* write out CRC tables to crc32.h */
block|{
name|FILE
modifier|*
name|out
decl_stmt|;
name|out
operator|=
name|fopen
argument_list|(
literal|"crc32.h"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|out
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"/* crc32.h -- tables for rapid CRC calculation\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" * Generated automatically by crc32.c\n */\n\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"local const unsigned long FAR "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"crc_table[TBLS][256] =\n{\n  {\n"
argument_list|)
expr_stmt|;
name|write_table
argument_list|(
name|out
argument_list|,
name|crc_table
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYFOUR
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#ifdef BYFOUR\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<
literal|8
condition|;
name|k
operator|++
control|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  },\n  {\n"
argument_list|)
expr_stmt|;
name|write_table
argument_list|(
name|out
argument_list|,
name|crc_table
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BYFOUR */
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  }\n};\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|out
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* MAKECRCH */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MAKECRCH
end_ifdef

begin_function
name|local
name|void
name|write_table
parameter_list|(
name|out
parameter_list|,
name|table
parameter_list|)
name|FILE
modifier|*
name|out
decl_stmt|;
specifier|const
name|unsigned
name|long
name|FAR
modifier|*
name|table
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|256
condition|;
name|n
operator|++
control|)
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%s0x%08lxUL%s"
argument_list|,
name|n
operator|%
literal|5
condition|?
literal|""
else|:
literal|"    "
argument_list|,
name|table
index|[
name|n
index|]
argument_list|,
name|n
operator|==
literal|255
condition|?
literal|"\n"
else|:
operator|(
name|n
operator|%
literal|5
operator|==
literal|4
condition|?
literal|",\n"
else|:
literal|", "
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAKECRCH */
end_comment

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* !DYNAMIC_CRC_TABLE */
end_comment

begin_comment
comment|/* ========================================================================  * Tables of CRC-32s of all single-byte values, made by make_crc_table().  */
end_comment

begin_include
include|#
directive|include
file|"crc32.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DYNAMIC_CRC_TABLE */
end_comment

begin_comment
comment|/* =========================================================================  * This function can be used by asm versions of crc32()  */
end_comment

begin_function
specifier|const
name|unsigned
name|long
name|FAR
modifier|*
name|ZEXPORT
name|get_crc_table
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|DYNAMIC_CRC_TABLE
if|if
condition|(
name|crc_table_empty
condition|)
name|make_crc_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC_CRC_TABLE */
return|return
operator|(
specifier|const
name|unsigned
name|long
name|FAR
operator|*
operator|)
name|crc_table
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_define
define|#
directive|define
name|DO1
value|crc = crc_table[0][((int)crc ^ (*buf++))& 0xff] ^ (crc>> 8)
end_define

begin_define
define|#
directive|define
name|DO8
value|DO1; DO1; DO1; DO1; DO1; DO1; DO1; DO1
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|unsigned
name|long
name|ZEXPORT
name|crc32
parameter_list|(
name|crc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|long
name|crc
decl_stmt|;
specifier|const
name|unsigned
name|char
name|FAR
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
if|if
condition|(
name|buf
operator|==
name|Z_NULL
condition|)
return|return
literal|0UL
return|;
ifdef|#
directive|ifdef
name|DYNAMIC_CRC_TABLE
if|if
condition|(
name|crc_table_empty
condition|)
name|make_crc_table
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* DYNAMIC_CRC_TABLE */
ifdef|#
directive|ifdef
name|BYFOUR
if|if
condition|(
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|==
sizeof|sizeof
argument_list|(
name|ptrdiff_t
argument_list|)
condition|)
block|{
name|u4
name|endian
decl_stmt|;
name|endian
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
operator|&
name|endian
operator|)
operator|)
condition|)
return|return
name|crc32_little
argument_list|(
name|crc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
else|else
return|return
name|crc32_big
argument_list|(
name|crc
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
return|;
block|}
endif|#
directive|endif
comment|/* BYFOUR */
name|crc
operator|=
name|crc
operator|^
literal|0xffffffffUL
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|8
condition|)
block|{
name|DO8
expr_stmt|;
name|len
operator|-=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|len
condition|)
do|do
block|{
name|DO1
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
return|return
name|crc
operator|^
literal|0xffffffffUL
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BYFOUR
end_ifdef

begin_comment
comment|/* ========================================================================= */
end_comment

begin_define
define|#
directive|define
name|DOLIT4
value|c ^= *buf4++; \         c = crc_table[3][c& 0xff] ^ crc_table[2][(c>> 8)& 0xff] ^ \             crc_table[1][(c>> 16)& 0xff] ^ crc_table[0][c>> 24]
end_define

begin_define
define|#
directive|define
name|DOLIT32
value|DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4; DOLIT4
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|local
name|unsigned
name|long
name|crc32_little
parameter_list|(
name|crc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|long
name|crc
decl_stmt|;
specifier|const
name|unsigned
name|char
name|FAR
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
specifier|register
name|u4
name|c
decl_stmt|;
specifier|register
specifier|const
name|u4
name|FAR
modifier|*
name|buf4
decl_stmt|;
name|c
operator|=
operator|(
name|u4
operator|)
name|crc
expr_stmt|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
while|while
condition|(
name|len
operator|&&
operator|(
operator|(
name|ptrdiff_t
operator|)
name|buf
operator|&
literal|3
operator|)
condition|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
operator|(
name|c
operator|^
operator|*
name|buf
operator|++
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>
literal|8
operator|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|buf4
operator|=
operator|(
specifier|const
name|u4
name|FAR
operator|*
operator|)
operator|(
specifier|const
name|void
name|FAR
operator|*
operator|)
name|buf
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|32
condition|)
block|{
name|DOLIT32
expr_stmt|;
name|len
operator|-=
literal|32
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|DOLIT4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
name|buf
operator|=
operator|(
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|)
name|buf4
expr_stmt|;
if|if
condition|(
name|len
condition|)
do|do
block|{
name|c
operator|=
name|crc_table
index|[
literal|0
index|]
index|[
operator|(
name|c
operator|^
operator|*
name|buf
operator|++
operator|)
operator|&
literal|0xff
index|]
operator|^
operator|(
name|c
operator|>>
literal|8
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
return|return
operator|(
name|unsigned
name|long
operator|)
name|c
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_define
define|#
directive|define
name|DOBIG4
value|c ^= *++buf4; \         c = crc_table[4][c& 0xff] ^ crc_table[5][(c>> 8)& 0xff] ^ \             crc_table[6][(c>> 16)& 0xff] ^ crc_table[7][c>> 24]
end_define

begin_define
define|#
directive|define
name|DOBIG32
value|DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4; DOBIG4
end_define

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|local
name|unsigned
name|long
name|crc32_big
parameter_list|(
name|crc
parameter_list|,
name|buf
parameter_list|,
name|len
parameter_list|)
name|unsigned
name|long
name|crc
decl_stmt|;
specifier|const
name|unsigned
name|char
name|FAR
modifier|*
name|buf
decl_stmt|;
name|unsigned
name|len
decl_stmt|;
block|{
specifier|register
name|u4
name|c
decl_stmt|;
specifier|register
specifier|const
name|u4
name|FAR
modifier|*
name|buf4
decl_stmt|;
name|c
operator|=
name|REV
argument_list|(
operator|(
name|u4
operator|)
name|crc
argument_list|)
expr_stmt|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
while|while
condition|(
name|len
operator|&&
operator|(
operator|(
name|ptrdiff_t
operator|)
name|buf
operator|&
literal|3
operator|)
condition|)
block|{
name|c
operator|=
name|crc_table
index|[
literal|4
index|]
index|[
operator|(
name|c
operator|>>
literal|24
operator|)
operator|^
operator|*
name|buf
operator|++
index|]
operator|^
operator|(
name|c
operator|<<
literal|8
operator|)
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
name|buf4
operator|=
operator|(
specifier|const
name|u4
name|FAR
operator|*
operator|)
operator|(
specifier|const
name|void
name|FAR
operator|*
operator|)
name|buf
expr_stmt|;
name|buf4
operator|--
expr_stmt|;
while|while
condition|(
name|len
operator|>=
literal|32
condition|)
block|{
name|DOBIG32
expr_stmt|;
name|len
operator|-=
literal|32
expr_stmt|;
block|}
while|while
condition|(
name|len
operator|>=
literal|4
condition|)
block|{
name|DOBIG4
expr_stmt|;
name|len
operator|-=
literal|4
expr_stmt|;
block|}
name|buf4
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
specifier|const
name|unsigned
name|char
name|FAR
operator|*
operator|)
name|buf4
expr_stmt|;
if|if
condition|(
name|len
condition|)
do|do
block|{
name|c
operator|=
name|crc_table
index|[
literal|4
index|]
index|[
operator|(
name|c
operator|>>
literal|24
operator|)
operator|^
operator|*
name|buf
operator|++
index|]
operator|^
operator|(
name|c
operator|<<
literal|8
operator|)
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
name|c
operator|=
operator|~
name|c
expr_stmt|;
return|return
call|(
name|unsigned
name|long
call|)
argument_list|(
name|REV
argument_list|(
name|c
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BYFOUR */
end_comment

begin_define
define|#
directive|define
name|GF2_DIM
value|32
end_define

begin_comment
comment|/* dimension of GF(2) vectors (length of CRC) */
end_comment

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|local
name|unsigned
name|long
name|gf2_matrix_times
parameter_list|(
name|mat
parameter_list|,
name|vec
parameter_list|)
name|unsigned
name|long
modifier|*
name|mat
decl_stmt|;
name|unsigned
name|long
name|vec
decl_stmt|;
block|{
name|unsigned
name|long
name|sum
decl_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|vec
condition|)
block|{
if|if
condition|(
name|vec
operator|&
literal|1
condition|)
name|sum
operator|^=
operator|*
name|mat
expr_stmt|;
name|vec
operator|>>=
literal|1
expr_stmt|;
name|mat
operator|++
expr_stmt|;
block|}
return|return
name|sum
return|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|local
name|void
name|gf2_matrix_square
parameter_list|(
name|square
parameter_list|,
name|mat
parameter_list|)
name|unsigned
name|long
modifier|*
name|square
decl_stmt|;
name|unsigned
name|long
modifier|*
name|mat
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|GF2_DIM
condition|;
name|n
operator|++
control|)
name|square
index|[
name|n
index|]
operator|=
name|gf2_matrix_times
argument_list|(
name|mat
argument_list|,
name|mat
index|[
name|n
index|]
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ========================================================================= */
end_comment

begin_function
name|uLong
name|ZEXPORT
name|crc32_combine
parameter_list|(
name|crc1
parameter_list|,
name|crc2
parameter_list|,
name|len2
parameter_list|)
name|uLong
name|crc1
decl_stmt|;
name|uLong
name|crc2
decl_stmt|;
name|z_off_t
name|len2
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|unsigned
name|long
name|row
decl_stmt|;
name|unsigned
name|long
name|even
index|[
name|GF2_DIM
index|]
decl_stmt|;
comment|/* even-power-of-two zeros operator */
name|unsigned
name|long
name|odd
index|[
name|GF2_DIM
index|]
decl_stmt|;
comment|/* odd-power-of-two zeros operator */
comment|/* degenerate case */
if|if
condition|(
name|len2
operator|==
literal|0
condition|)
return|return
name|crc1
return|;
comment|/* put operator for one zero bit in odd */
name|odd
index|[
literal|0
index|]
operator|=
literal|0xedb88320UL
expr_stmt|;
comment|/* CRC-32 polynomial */
name|row
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|n
operator|=
literal|1
init|;
name|n
operator|<
name|GF2_DIM
condition|;
name|n
operator|++
control|)
block|{
name|odd
index|[
name|n
index|]
operator|=
name|row
expr_stmt|;
name|row
operator|<<=
literal|1
expr_stmt|;
block|}
comment|/* put operator for two zero bits in even */
name|gf2_matrix_square
argument_list|(
name|even
argument_list|,
name|odd
argument_list|)
expr_stmt|;
comment|/* put operator for four zero bits in odd */
name|gf2_matrix_square
argument_list|(
name|odd
argument_list|,
name|even
argument_list|)
expr_stmt|;
comment|/* apply len2 zeros to crc1 (first square will put the operator for one        zero byte, eight zero bits, in even) */
do|do
block|{
comment|/* apply zeros operator for this bit of len2 */
name|gf2_matrix_square
argument_list|(
name|even
argument_list|,
name|odd
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
operator|&
literal|1
condition|)
name|crc1
operator|=
name|gf2_matrix_times
argument_list|(
name|even
argument_list|,
name|crc1
argument_list|)
expr_stmt|;
name|len2
operator|>>=
literal|1
expr_stmt|;
comment|/* if no more bits set, then done */
if|if
condition|(
name|len2
operator|==
literal|0
condition|)
break|break;
comment|/* another iteration of the loop with odd and even swapped */
name|gf2_matrix_square
argument_list|(
name|odd
argument_list|,
name|even
argument_list|)
expr_stmt|;
if|if
condition|(
name|len2
operator|&
literal|1
condition|)
name|crc1
operator|=
name|gf2_matrix_times
argument_list|(
name|odd
argument_list|,
name|crc1
argument_list|)
expr_stmt|;
name|len2
operator|>>=
literal|1
expr_stmt|;
comment|/* if no more bits set, then done */
block|}
do|while
condition|(
name|len2
operator|!=
literal|0
condition|)
do|;
comment|/* return combined crc */
name|crc1
operator|^=
name|crc2
expr_stmt|;
return|return
name|crc1
return|;
block|}
end_function

end_unit

