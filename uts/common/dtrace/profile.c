begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/strsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/cyclic.h>
end_include

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_decl_stmt
specifier|static
name|dev_info_t
modifier|*
name|profile_devi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_provider_id_t
name|profile_id
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Regardless of platform, the stack frames look like this in the case of the  * profile provider:  *  *	profile_fire  *	cyclic_expire  *	cyclic_fire  *	[ cbe ]  *	[ interrupt code ]  *  * On x86, there are five frames from the generic interrupt code; further, the  * interrupted instruction appears as its own stack frame, giving us a total of  * 10.  *  * On SPARC, the picture is further complicated because the compiler  * optimizes away tail-calls -- so the following frames are optimized away:  *  * 	profile_fire  *	cyclic_expire  *  * This gives three frames.  However, on DEBUG kernels, the cyclic_expire  * frame cannot be tail-call eliminated, yielding four frames in this case.  *  * All of the above constraints lead to the mess below.  Yes, the profile  * provider should ideally figure this out on-the-fly by hitting one of its own  * probes and then walking its own stack trace.  This is complicated, however,  * and the static definition doesn't seem to be overly brittle.  Still, we  * allow for a manual override in case we get it completely wrong.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__x86
end_ifdef

begin_define
define|#
directive|define
name|PROF_ARTIFICIAL_FRAMES
value|10
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__sparc
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_define
define|#
directive|define
name|PROF_ARTIFICIAL_FRAMES
value|4
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PROF_ARTIFICIAL_FRAMES
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|PROF_NAMELEN
value|15
end_define

begin_define
define|#
directive|define
name|PROF_PROFILE
value|0
end_define

begin_define
define|#
directive|define
name|PROF_TICK
value|1
end_define

begin_define
define|#
directive|define
name|PROF_PREFIX_PROFILE
value|"profile-"
end_define

begin_define
define|#
directive|define
name|PROF_PREFIX_TICK
value|"tick-"
end_define

begin_typedef
typedef|typedef
struct|struct
name|profile_probe
block|{
name|char
name|prof_name
index|[
name|PROF_NAMELEN
index|]
decl_stmt|;
name|dtrace_id_t
name|prof_id
decl_stmt|;
name|int
name|prof_kind
decl_stmt|;
name|hrtime_t
name|prof_interval
decl_stmt|;
name|cyclic_id_t
name|prof_cyclic
decl_stmt|;
block|}
name|profile_probe_t
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|profile_probe_percpu
block|{
name|hrtime_t
name|profc_expected
decl_stmt|;
name|hrtime_t
name|profc_interval
decl_stmt|;
name|profile_probe_t
modifier|*
name|profc_probe
decl_stmt|;
block|}
name|profile_probe_percpu_t
typedef|;
end_typedef

begin_decl_stmt
name|hrtime_t
name|profile_interval_min
init|=
name|NANOSEC
operator|/
literal|5000
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 5000 hz */
end_comment

begin_decl_stmt
name|int
name|profile_aframes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override */
end_comment

begin_decl_stmt
specifier|static
name|int
name|profile_rates
index|[]
init|=
block|{
literal|97
block|,
literal|199
block|,
literal|499
block|,
literal|997
block|,
literal|1999
block|,
literal|4001
block|,
literal|4999
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|profile_ticks
index|[]
init|=
block|{
literal|1
block|,
literal|10
block|,
literal|100
block|,
literal|500
block|,
literal|1000
block|,
literal|5000
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * profile_max defines the upper bound on the number of profile probes that  * can exist (this is to prevent malicious or clumsy users from exhausing  * system resources by creating a slew of profile probes). At mod load time,  * this gets its value from PROFILE_MAX_DEFAULT or profile-max-probes if it's  * present in the profile.conf file.  */
end_comment

begin_define
define|#
directive|define
name|PROFILE_MAX_DEFAULT
value|1000
end_define

begin_comment
comment|/* default max. number of probes */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|profile_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of profile probes */
end_comment

begin_decl_stmt
specifier|static
name|uint32_t
name|profile_total
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current number of profile probes */
end_comment

begin_function
specifier|static
name|void
name|profile_fire
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|profile_probe_percpu_t
modifier|*
name|pcpu
init|=
name|arg
decl_stmt|;
name|profile_probe_t
modifier|*
name|prof
init|=
name|pcpu
operator|->
name|profc_probe
decl_stmt|;
name|hrtime_t
name|late
decl_stmt|;
name|late
operator|=
name|dtrace_gethrtime
argument_list|()
operator|-
name|pcpu
operator|->
name|profc_expected
expr_stmt|;
name|pcpu
operator|->
name|profc_expected
operator|+=
name|pcpu
operator|->
name|profc_interval
expr_stmt|;
name|dtrace_probe
argument_list|(
name|prof
operator|->
name|prof_id
argument_list|,
name|CPU
operator|->
name|cpu_profile_pc
argument_list|,
name|CPU
operator|->
name|cpu_profile_upc
argument_list|,
name|late
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|profile_tick
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|profile_probe_t
modifier|*
name|prof
init|=
name|arg
decl_stmt|;
name|dtrace_probe
argument_list|(
name|prof
operator|->
name|prof_id
argument_list|,
name|CPU
operator|->
name|cpu_profile_pc
argument_list|,
name|CPU
operator|->
name|cpu_profile_upc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|profile_create
parameter_list|(
name|hrtime_t
name|interval
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|kind
parameter_list|)
block|{
name|profile_probe_t
modifier|*
name|prof
decl_stmt|;
name|int
name|nr_frames
init|=
name|PROF_ARTIFICIAL_FRAMES
operator|+
name|dtrace_mach_aframes
argument_list|()
decl_stmt|;
if|if
condition|(
name|profile_aframes
condition|)
name|nr_frames
operator|=
name|profile_aframes
expr_stmt|;
if|if
condition|(
name|interval
operator|<
name|profile_interval_min
condition|)
return|return;
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|profile_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|atomic_add_32
argument_list|(
operator|&
name|profile_total
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|profile_total
operator|>
name|profile_max
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|profile_total
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|prof
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|profile_probe_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prof
operator|->
name|prof_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|prof
operator|->
name|prof_interval
operator|=
name|interval
expr_stmt|;
name|prof
operator|->
name|prof_cyclic
operator|=
name|CYCLIC_NONE
expr_stmt|;
name|prof
operator|->
name|prof_kind
operator|=
name|kind
expr_stmt|;
name|prof
operator|->
name|prof_id
operator|=
name|dtrace_probe_create
argument_list|(
name|profile_id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|name
argument_list|,
name|nr_frames
argument_list|,
name|prof
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|profile_provide
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|rate
decl_stmt|,
name|kind
decl_stmt|;
name|hrtime_t
name|val
init|=
literal|0
decl_stmt|,
name|mult
init|=
literal|1
decl_stmt|,
name|len
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|suffix
init|=
name|NULL
decl_stmt|;
specifier|const
struct|struct
block|{
name|char
modifier|*
name|prefix
decl_stmt|;
name|int
name|kind
decl_stmt|;
block|}
name|types
index|[]
init|=
block|{
block|{
name|PROF_PREFIX_PROFILE
block|,
name|PROF_PROFILE
block|}
block|,
block|{
name|PROF_PREFIX_TICK
block|,
name|PROF_TICK
block|}
block|,
block|{
name|NULL
block|,
name|NULL
block|}
block|}
struct|;
specifier|const
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|hrtime_t
name|mult
decl_stmt|;
block|}
name|suffixes
index|[]
init|=
block|{
block|{
literal|"ns"
block|,
name|NANOSEC
operator|/
name|NANOSEC
block|}
block|,
block|{
literal|"nsec"
block|,
name|NANOSEC
operator|/
name|NANOSEC
block|}
block|,
block|{
literal|"us"
block|,
name|NANOSEC
operator|/
name|MICROSEC
block|}
block|,
block|{
literal|"usec"
block|,
name|NANOSEC
operator|/
name|MICROSEC
block|}
block|,
block|{
literal|"ms"
block|,
name|NANOSEC
operator|/
name|MILLISEC
block|}
block|,
block|{
literal|"msec"
block|,
name|NANOSEC
operator|/
name|MILLISEC
block|}
block|,
block|{
literal|"s"
block|,
name|NANOSEC
operator|/
name|SEC
block|}
block|,
block|{
literal|"sec"
block|,
name|NANOSEC
operator|/
name|SEC
block|}
block|,
block|{
literal|"m"
block|,
name|NANOSEC
operator|*
operator|(
name|hrtime_t
operator|)
literal|60
block|}
block|,
block|{
literal|"min"
block|,
name|NANOSEC
operator|*
operator|(
name|hrtime_t
operator|)
literal|60
block|}
block|,
block|{
literal|"h"
block|,
name|NANOSEC
operator|*
operator|(
name|hrtime_t
operator|)
operator|(
literal|60
operator|*
literal|60
operator|)
block|}
block|,
block|{
literal|"hour"
block|,
name|NANOSEC
operator|*
operator|(
name|hrtime_t
operator|)
operator|(
literal|60
operator|*
literal|60
operator|)
block|}
block|,
block|{
literal|"d"
block|,
name|NANOSEC
operator|*
operator|(
name|hrtime_t
operator|)
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
block|}
block|,
block|{
literal|"day"
block|,
name|NANOSEC
operator|*
operator|(
name|hrtime_t
operator|)
operator|(
literal|24
operator|*
literal|60
operator|*
literal|60
operator|)
block|}
block|,
block|{
literal|"hz"
block|,
literal|0
block|}
block|,
block|{
name|NULL
block|}
block|}
struct|;
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
block|{
name|char
name|n
index|[
name|PROF_NAMELEN
index|]
decl_stmt|;
comment|/* 		 * If no description was provided, provide all of our probes. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|profile_rates
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rate
operator|=
name|profile_rates
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|n
argument_list|,
name|PROF_NAMELEN
argument_list|,
literal|"%s%d"
argument_list|,
name|PROF_PREFIX_PROFILE
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|profile_create
argument_list|(
name|NANOSEC
operator|/
name|rate
argument_list|,
name|n
argument_list|,
name|PROF_PROFILE
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
argument_list|(
name|profile_ticks
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rate
operator|=
name|profile_ticks
index|[
name|i
index|]
operator|)
operator|==
literal|0
condition|)
continue|continue;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|n
argument_list|,
name|PROF_NAMELEN
argument_list|,
literal|"%s%d"
argument_list|,
name|PROF_PREFIX_TICK
argument_list|,
name|rate
argument_list|)
expr_stmt|;
name|profile_create
argument_list|(
name|NANOSEC
operator|/
name|rate
argument_list|,
name|n
argument_list|,
name|PROF_TICK
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
name|name
operator|=
name|desc
operator|->
name|dtpd_name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|types
index|[
name|i
index|]
operator|.
name|prefix
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|types
index|[
name|i
index|]
operator|.
name|prefix
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|types
index|[
name|i
index|]
operator|.
name|prefix
argument_list|,
name|len
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
break|break;
block|}
if|if
condition|(
name|types
index|[
name|i
index|]
operator|.
name|prefix
operator|==
name|NULL
condition|)
return|return;
name|kind
operator|=
name|types
index|[
name|i
index|]
operator|.
name|kind
expr_stmt|;
name|j
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
operator|-
name|len
expr_stmt|;
comment|/* 	 * We need to start before any time suffix. 	 */
for|for
control|(
name|j
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
init|;
name|j
operator|>=
name|len
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|name
index|[
name|j
index|]
operator|>=
literal|'0'
operator|&&
name|name
index|[
name|j
index|]
operator|<=
literal|'9'
condition|)
break|break;
name|suffix
operator|=
operator|&
name|name
index|[
name|j
index|]
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|suffix
operator|!=
name|NULL
argument_list|)
expr_stmt|;
comment|/* 	 * Now determine the numerical value present in the probe name. 	 */
for|for
control|(
init|;
name|j
operator|>=
name|len
condition|;
name|j
operator|--
control|)
block|{
if|if
condition|(
name|name
index|[
name|j
index|]
operator|<
literal|'0'
operator|||
name|name
index|[
name|j
index|]
operator|>
literal|'9'
condition|)
return|return;
name|val
operator|+=
operator|(
name|name
index|[
name|j
index|]
operator|-
literal|'0'
operator|)
operator|*
name|mult
expr_stmt|;
name|mult
operator|*=
operator|(
name|hrtime_t
operator|)
literal|10
expr_stmt|;
block|}
if|if
condition|(
name|val
operator|==
literal|0
condition|)
return|return;
comment|/* 	 * Look-up the suffix to determine the multiplier. 	 */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|mult
operator|=
literal|0
init|;
name|suffixes
index|[
name|i
index|]
operator|.
name|name
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcasecmp
argument_list|(
name|suffixes
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|suffix
argument_list|)
operator|==
literal|0
condition|)
block|{
name|mult
operator|=
name|suffixes
index|[
name|i
index|]
operator|.
name|mult
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|suffixes
index|[
name|i
index|]
operator|.
name|name
operator|==
name|NULL
operator|&&
operator|*
name|suffix
operator|!=
literal|'\0'
condition|)
return|return;
if|if
condition|(
name|mult
operator|==
literal|0
condition|)
block|{
comment|/* 		 * The default is frequency-per-second. 		 */
name|val
operator|=
name|NANOSEC
operator|/
name|val
expr_stmt|;
block|}
else|else
block|{
name|val
operator|*=
name|mult
expr_stmt|;
block|}
name|profile_create
argument_list|(
name|val
argument_list|,
name|name
argument_list|,
name|kind
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|profile_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|profile_probe_t
modifier|*
name|prof
init|=
name|parg
decl_stmt|;
name|ASSERT
argument_list|(
name|prof
operator|->
name|prof_cyclic
operator|==
name|CYCLIC_NONE
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|prof
argument_list|,
sizeof|sizeof
argument_list|(
name|profile_probe_t
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|profile_total
operator|>=
literal|1
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|profile_total
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|profile_online
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|cpu_t
modifier|*
name|cpu
parameter_list|,
name|cyc_handler_t
modifier|*
name|hdlr
parameter_list|,
name|cyc_time_t
modifier|*
name|when
parameter_list|)
block|{
name|profile_probe_t
modifier|*
name|prof
init|=
name|arg
decl_stmt|;
name|profile_probe_percpu_t
modifier|*
name|pcpu
decl_stmt|;
name|pcpu
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|profile_probe_percpu_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pcpu
operator|->
name|profc_probe
operator|=
name|prof
expr_stmt|;
name|hdlr
operator|->
name|cyh_func
operator|=
name|profile_fire
expr_stmt|;
name|hdlr
operator|->
name|cyh_arg
operator|=
name|pcpu
expr_stmt|;
name|hdlr
operator|->
name|cyh_level
operator|=
name|CY_HIGH_LEVEL
expr_stmt|;
name|when
operator|->
name|cyt_interval
operator|=
name|prof
operator|->
name|prof_interval
expr_stmt|;
name|when
operator|->
name|cyt_when
operator|=
name|dtrace_gethrtime
argument_list|()
operator|+
name|when
operator|->
name|cyt_interval
expr_stmt|;
name|pcpu
operator|->
name|profc_expected
operator|=
name|when
operator|->
name|cyt_when
expr_stmt|;
name|pcpu
operator|->
name|profc_interval
operator|=
name|when
operator|->
name|cyt_interval
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|profile_offline
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|cpu_t
modifier|*
name|cpu
parameter_list|,
name|void
modifier|*
name|oarg
parameter_list|)
block|{
name|profile_probe_percpu_t
modifier|*
name|pcpu
init|=
name|oarg
decl_stmt|;
name|ASSERT
argument_list|(
name|pcpu
operator|->
name|profc_probe
operator|==
name|arg
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|pcpu
argument_list|,
sizeof|sizeof
argument_list|(
name|profile_probe_percpu_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|profile_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|profile_probe_t
modifier|*
name|prof
init|=
name|parg
decl_stmt|;
name|cyc_omni_handler_t
name|omni
decl_stmt|;
name|cyc_handler_t
name|hdlr
decl_stmt|;
name|cyc_time_t
name|when
decl_stmt|;
name|ASSERT
argument_list|(
name|prof
operator|->
name|prof_interval
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|prof
operator|->
name|prof_kind
operator|==
name|PROF_TICK
condition|)
block|{
name|hdlr
operator|.
name|cyh_func
operator|=
name|profile_tick
expr_stmt|;
name|hdlr
operator|.
name|cyh_arg
operator|=
name|prof
expr_stmt|;
name|hdlr
operator|.
name|cyh_level
operator|=
name|CY_HIGH_LEVEL
expr_stmt|;
name|when
operator|.
name|cyt_interval
operator|=
name|prof
operator|->
name|prof_interval
expr_stmt|;
name|when
operator|.
name|cyt_when
operator|=
name|dtrace_gethrtime
argument_list|()
operator|+
name|when
operator|.
name|cyt_interval
expr_stmt|;
block|}
else|else
block|{
name|ASSERT
argument_list|(
name|prof
operator|->
name|prof_kind
operator|==
name|PROF_PROFILE
argument_list|)
expr_stmt|;
name|omni
operator|.
name|cyo_online
operator|=
name|profile_online
expr_stmt|;
name|omni
operator|.
name|cyo_offline
operator|=
name|profile_offline
expr_stmt|;
name|omni
operator|.
name|cyo_arg
operator|=
name|prof
expr_stmt|;
block|}
if|if
condition|(
name|prof
operator|->
name|prof_kind
operator|==
name|PROF_TICK
condition|)
block|{
name|prof
operator|->
name|prof_cyclic
operator|=
name|cyclic_add
argument_list|(
operator|&
name|hdlr
argument_list|,
operator|&
name|when
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prof
operator|->
name|prof_cyclic
operator|=
name|cyclic_add_omni
argument_list|(
operator|&
name|omni
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|profile_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|profile_probe_t
modifier|*
name|prof
init|=
name|parg
decl_stmt|;
name|ASSERT
argument_list|(
name|prof
operator|->
name|prof_cyclic
operator|!=
name|CYCLIC_NONE
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|cyclic_remove
argument_list|(
name|prof
operator|->
name|prof_cyclic
argument_list|)
expr_stmt|;
name|prof
operator|->
name|prof_cyclic
operator|=
name|CYCLIC_NONE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|profile_usermode
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
return|return
operator|(
name|CPU
operator|->
name|cpu_profile_pc
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dtrace_pattr_t
name|profile_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_STABILITY_UNSTABLE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|profile_pops
init|=
block|{
name|profile_provide
block|,
name|NULL
block|,
name|profile_enable
block|,
name|profile_disable
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|profile_usermode
block|,
name|profile_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|profile_attach
parameter_list|(
name|dev_info_t
modifier|*
name|devi
parameter_list|,
name|ddi_attach_cmd_t
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_ATTACH
case|:
break|break;
case|case
name|DDI_RESUME
case|:
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|devi
argument_list|,
literal|"profile"
argument_list|,
name|S_IFCHR
argument_list|,
literal|0
argument_list|,
name|DDI_PSEUDO
argument_list|,
name|NULL
argument_list|)
operator|==
name|DDI_FAILURE
operator|||
name|dtrace_register
argument_list|(
literal|"profile"
argument_list|,
operator|&
name|profile_attr
argument_list|,
name|DTRACE_PRIV_KERNEL
operator||
name|DTRACE_PRIV_USER
argument_list|,
name|NULL
argument_list|,
operator|&
name|profile_pops
argument_list|,
name|NULL
argument_list|,
operator|&
name|profile_id
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
name|profile_max
operator|=
name|ddi_getprop
argument_list|(
name|DDI_DEV_T_ANY
argument_list|,
name|devi
argument_list|,
name|DDI_PROP_DONTPASS
argument_list|,
literal|"profile-max-probes"
argument_list|,
name|PROFILE_MAX_DEFAULT
argument_list|)
expr_stmt|;
name|ddi_report_dev
argument_list|(
name|devi
argument_list|)
expr_stmt|;
name|profile_devi
operator|=
name|devi
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|profile_detach
parameter_list|(
name|dev_info_t
modifier|*
name|devi
parameter_list|,
name|ddi_detach_cmd_t
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_DETACH
case|:
break|break;
case|case
name|DDI_SUSPEND
case|:
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_unregister
argument_list|(
name|profile_id
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
name|ddi_remove_minor_node
argument_list|(
name|devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|profile_info
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|,
name|ddi_info_cmd_t
name|infocmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|infocmd
condition|)
block|{
case|case
name|DDI_INFO_DEVT2DEVINFO
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|profile_devi
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
case|case
name|DDI_INFO_DEVT2INSTANCE
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|DDI_FAILURE
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|profile_open
parameter_list|(
name|dev_t
modifier|*
name|devp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|cred_t
modifier|*
name|cred_p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cb_ops
name|profile_cb_ops
init|=
block|{
name|profile_open
block|,
comment|/* open */
name|nodev
block|,
comment|/* close */
name|nulldev
block|,
comment|/* strategy */
name|nulldev
block|,
comment|/* print */
name|nodev
block|,
comment|/* dump */
name|nodev
block|,
comment|/* read */
name|nodev
block|,
comment|/* write */
name|nodev
block|,
comment|/* ioctl */
name|nodev
block|,
comment|/* devmap */
name|nodev
block|,
comment|/* mmap */
name|nodev
block|,
comment|/* segmap */
name|nochpoll
block|,
comment|/* poll */
name|ddi_prop_op
block|,
comment|/* cb_prop_op */
literal|0
block|,
comment|/* streamtab  */
name|D_NEW
operator||
name|D_MP
comment|/* Driver compatibility flag */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dev_ops
name|profile_ops
init|=
block|{
name|DEVO_REV
block|,
comment|/* devo_rev, */
literal|0
block|,
comment|/* refcnt  */
name|profile_info
block|,
comment|/* get_dev_info */
name|nulldev
block|,
comment|/* identify */
name|nulldev
block|,
comment|/* probe */
name|profile_attach
block|,
comment|/* attach */
name|profile_detach
block|,
comment|/* detach */
name|nodev
block|,
comment|/* reset */
operator|&
name|profile_cb_ops
block|,
comment|/* driver operations */
name|NULL
block|,
comment|/* bus operations */
name|nodev
block|,
comment|/* dev power */
name|ddi_quiesce_not_needed
block|,
comment|/* quiesce */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Module linkage information for the kernel.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|modldrv
name|modldrv
init|=
block|{
operator|&
name|mod_driverops
block|,
comment|/* module type (this is a pseudo driver) */
literal|"Profile Interrupt Tracing"
block|,
comment|/* name of module */
operator|&
name|profile_ops
block|,
comment|/* driver ops */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlinkage
name|modlinkage
init|=
block|{
name|MODREV_1
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|modldrv
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_install
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_info
parameter_list|(
name|struct
name|modinfo
modifier|*
name|modinfop
parameter_list|)
block|{
return|return
operator|(
name|mod_info
argument_list|(
operator|&
name|modlinkage
argument_list|,
name|modinfop
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_remove
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

