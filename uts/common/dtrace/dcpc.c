begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2010 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/ksynch.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/kcpc.h>
end_include

begin_include
include|#
directive|include
file|<sys/cap_util.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpc_pcbe.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpc_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_impl.h>
end_include

begin_comment
comment|/*  * DTrace CPU Performance Counter Provider  * ---------------------------------------  *  * The DTrace cpc provider allows DTrace consumers to access the CPU  * performance counter overflow mechanism of a CPU. The configuration  * presented in a probe specification is programmed into the performance  * counter hardware of all available CPUs on a system. Programming the  * hardware causes a counter on each CPU to begin counting events of the  * given type. When the specified number of events have occurred, an overflow  * interrupt will be generated and the probe is fired.  *  * The required configuration for the performance counter is encoded into  * the probe specification and this includes the performance counter event  * name, processor mode, overflow rate and an optional unit mask.  *  * Most processors provide several counters (PICs) which can count all or a  * subset of the events available for a given CPU. However, when overflow  * profiling is being used, not all CPUs can detect which counter generated the  * overflow interrupt. In this case we cannot reliably determine which counter  * overflowed and we therefore only allow such CPUs to configure one event at  * a time. Processors that can determine the counter which overflowed are  * allowed to program as many events at one time as possible (in theory up to  * the number of instrumentation counters supported by that platform).  * Therefore, multiple consumers can enable multiple probes at the same time  * on such platforms. Platforms which cannot determine the source of an  * overflow interrupt are only allowed to program a single event at one time.  *  * The performance counter hardware is made available to consumers on a  * first-come, first-served basis. Only a finite amount of hardware resource  * is available and, while we make every attempt to accomodate requests from  * consumers, we must deny requests when hardware resources have been exhausted.  * A consumer will fail to enable probes when resources are currently in use.  *  * The cpc provider contends for shared hardware resources along with other  * consumers of the kernel CPU performance counter subsystem (e.g. cpustat(1M)).  * Only one such consumer can use the performance counters at any one time and  * counters are made available on a first-come, first-served basis. As with  * cpustat, the cpc provider has priority over per-LWP libcpc usage (e.g.  * cputrack(1)). Invoking the cpc provider will cause all existing per-LWP  * counter contexts to be invalidated.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|dcpc_probe
block|{
name|char
name|dcpc_event_name
index|[
name|CPC_MAX_EVENT_LEN
index|]
decl_stmt|;
name|int
name|dcpc_flag
decl_stmt|;
comment|/* flags (USER/SYS) */
name|uint32_t
name|dcpc_ovfval
decl_stmt|;
comment|/* overflow value */
name|int64_t
name|dcpc_umask
decl_stmt|;
comment|/* umask/emask for this event */
name|int
name|dcpc_picno
decl_stmt|;
comment|/* pic this event is programmed in */
name|int
name|dcpc_enabled
decl_stmt|;
comment|/* probe is actually enabled? */
name|int
name|dcpc_disabling
decl_stmt|;
comment|/* probe is currently being disabled */
name|dtrace_id_t
name|dcpc_id
decl_stmt|;
comment|/* probeid this request is enabling */
name|int
name|dcpc_actv_req_idx
decl_stmt|;
comment|/* idx into dcpc_actv_reqs[] */
block|}
name|dcpc_probe_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|dev_info_t
modifier|*
name|dcpc_devi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_provider_id_t
name|dcpc_pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dcpc_probe_t
modifier|*
modifier|*
name|dcpc_actv_reqs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|dcpc_enablings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dcpc_ovf_mask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dcpc_mult_ovf_cap
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dcpc_mask_type
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When the dcpc provider is loaded, dcpc_min_overflow is set to either  * DCPC_MIN_OVF_DEFAULT or the value that dcpc-min-overflow is set to in  * the dcpc.conf file. Decrease this value to set probes with smaller  * overflow values. Remember that very small values could render a system  * unusable with frequently occurring events.  */
end_comment

begin_define
define|#
directive|define
name|DCPC_MIN_OVF_DEFAULT
value|5000
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|dcpc_min_overflow
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|dcpc_aframes
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* override for artificial frame setting */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__x86
argument_list|)
end_if

begin_define
define|#
directive|define
name|DCPC_ARTIFICIAL_FRAMES
value|8
end_define

begin_elif
elif|#
directive|elif
name|defined
argument_list|(
name|__sparc
argument_list|)
end_elif

begin_define
define|#
directive|define
name|DCPC_ARTIFICIAL_FRAMES
value|2
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Called from the platform overflow interrupt handler. 'bitmap' is a mask  * which contains the pic(s) that have overflowed.  */
end_comment

begin_function
specifier|static
name|void
name|dcpc_fire
parameter_list|(
name|uint64_t
name|bitmap
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
comment|/* 	 * No counter was marked as overflowing. Shout about it and get out. 	 */
if|if
condition|(
operator|(
name|bitmap
operator|&
name|dcpc_ovf_mask
operator|)
operator|==
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"dcpc_fire: no counter overflow found\n"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * This is the common case of a processor that doesn't support 	 * multiple overflow events. Such systems are only allowed a single 	 * enabling and therefore we just look for the first entry in 	 * the active request array. 	 */
if|if
condition|(
operator|!
name|dcpc_mult_ovf_cap
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpc_ncounters
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|dtrace_probe
argument_list|(
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|->
name|dcpc_id
argument_list|,
name|CPU
operator|->
name|cpu_cpcprofile_pc
argument_list|,
name|CPU
operator|->
name|cpu_cpcprofile_upc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
return|return;
block|}
comment|/* 	 * This is a processor capable of handling multiple overflow events. 	 * Iterate over the array of active requests and locate the counters 	 * that overflowed (note: it is possible for more than one counter to 	 * have overflowed at the same time). 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpc_ncounters
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|!=
name|NULL
operator|&&
operator|(
name|bitmap
operator|&
operator|(
literal|1ULL
operator|<<
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|->
name|dcpc_picno
operator|)
operator|)
condition|)
block|{
name|dtrace_probe
argument_list|(
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|->
name|dcpc_id
argument_list|,
name|CPU
operator|->
name|cpu_cpcprofile_pc
argument_list|,
name|CPU
operator|->
name|cpu_cpcprofile_upc
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dcpc_create_probe
parameter_list|(
name|dtrace_provider_id_t
name|id
parameter_list|,
specifier|const
name|char
modifier|*
name|probename
parameter_list|,
name|char
modifier|*
name|eventname
parameter_list|,
name|int64_t
name|umask
parameter_list|,
name|uint32_t
name|ovfval
parameter_list|,
name|char
name|flag
parameter_list|)
block|{
name|dcpc_probe_t
modifier|*
name|pp
decl_stmt|;
name|int
name|nr_frames
init|=
name|DCPC_ARTIFICIAL_FRAMES
operator|+
name|dtrace_mach_aframes
argument_list|()
decl_stmt|;
if|if
condition|(
name|dcpc_aframes
condition|)
name|nr_frames
operator|=
name|dcpc_aframes
expr_stmt|;
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|probename
argument_list|)
operator|!=
literal|0
condition|)
return|return;
name|pp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|dcpc_probe_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|pp
operator|->
name|dcpc_event_name
argument_list|,
name|eventname
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|dcpc_event_name
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|dcpc_event_name
index|[
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|dcpc_event_name
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|->
name|dcpc_flag
operator|=
name|flag
operator||
name|CPC_OVF_NOTIFY_EMT
expr_stmt|;
name|pp
operator|->
name|dcpc_ovfval
operator|=
name|ovfval
expr_stmt|;
name|pp
operator|->
name|dcpc_umask
operator|=
name|umask
expr_stmt|;
name|pp
operator|->
name|dcpc_actv_req_idx
operator|=
name|pp
operator|->
name|dcpc_picno
operator|=
name|pp
operator|->
name|dcpc_disabling
operator|=
operator|-
literal|1
expr_stmt|;
name|pp
operator|->
name|dcpc_id
operator|=
name|dtrace_probe_create
argument_list|(
name|id
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|probename
argument_list|,
name|nr_frames
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dcpc_provide
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|)
block|{
comment|/* 	 * The format of a probe is: 	 * 	 *	event_name-mode-{optional_umask}-overflow_rate 	 * e.g. 	 *	DC_refill_from_system-user-0x1e-50000, or, 	 *	DC_refill_from_system-all-10000 	 * 	 */
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|flag
init|=
literal|0
decl_stmt|;
name|char
name|event
index|[
name|CPC_MAX_EVENT_LEN
index|]
decl_stmt|;
name|long
name|umask
init|=
operator|-
literal|1
decl_stmt|,
name|val
init|=
literal|0
decl_stmt|;
name|size_t
name|evlen
decl_stmt|,
name|len
decl_stmt|;
comment|/* 	 * The 'cpc' provider offers no probes by default. 	 */
if|if
condition|(
name|desc
operator|==
name|NULL
condition|)
return|return;
name|len
operator|=
name|strlen
argument_list|(
name|desc
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
name|p
operator|=
name|str
operator|=
name|kmem_alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
name|desc
operator|->
name|dtpd_name
argument_list|)
expr_stmt|;
comment|/* 	 * We have a poor man's strtok() going on here. Replace any hyphens 	 * in the the probe name with NULL characters in order to make it 	 * easy to parse the string with regular string functions. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'-'
condition|)
name|str
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * The first part of the string must be either a platform event 	 * name or a generic event name. 	 */
name|evlen
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|event
argument_list|,
name|p
argument_list|,
name|CPC_MAX_EVENT_LEN
operator|-
literal|1
argument_list|)
expr_stmt|;
name|event
index|[
name|CPC_MAX_EVENT_LEN
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * The next part of the name is the mode specification. Valid 	 * settings are "user", "kernel" or "all". 	 */
name|p
operator|+=
name|evlen
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"user"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|CPC_COUNT_USER
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"kernel"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|CPC_COUNT_SYSTEM
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
literal|"all"
argument_list|)
operator|==
literal|0
condition|)
name|flag
operator||=
name|CPC_COUNT_USER
operator||
name|CPC_COUNT_SYSTEM
expr_stmt|;
else|else
goto|goto
name|err
goto|;
comment|/* 	 * Next we either have a mask specification followed by an overflow 	 * rate or just an overflow rate on its own. 	 */
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'0'
operator|&&
operator|(
name|p
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|p
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
comment|/* 		 * A unit mask can only be specified if: 		 * 1) this performance counter back end supports masks. 		 * 2) the specified event is platform specific. 		 * 3) a valid hex number is converted. 		 * 4) no extraneous characters follow the mask specification. 		 */
if|if
condition|(
name|dcpc_mask_type
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|event
argument_list|,
literal|"PAPI"
argument_list|,
literal|4
argument_list|)
operator|!=
literal|0
operator|&&
name|ddi_strtol
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|16
argument_list|,
operator|&
name|umask
argument_list|)
operator|==
literal|0
operator|&&
name|end
operator|==
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
goto|goto
name|err
goto|;
block|}
block|}
comment|/* 	 * This final part must be an overflow value which has to be greater 	 * than the minimum permissible overflow rate. 	 */
if|if
condition|(
operator|(
name|ddi_strtol
argument_list|(
name|p
argument_list|,
operator|&
name|end
argument_list|,
literal|10
argument_list|,
operator|&
name|val
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|end
operator|!=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|||
name|val
operator|<
name|dcpc_min_overflow
condition|)
goto|goto
name|err
goto|;
comment|/* 	 * Validate the event and create the probe. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpc_ncounters
condition|;
name|i
operator|++
control|)
block|{
name|char
modifier|*
name|events
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|int
name|found
init|=
literal|0
decl_stmt|,
name|j
decl_stmt|;
name|size_t
name|llen
decl_stmt|;
if|if
condition|(
operator|(
name|events
operator|=
name|kcpc_list_events
argument_list|(
name|i
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|err
goto|;
name|llen
operator|=
name|strlen
argument_list|(
name|events
argument_list|)
expr_stmt|;
name|p
operator|=
name|cp
operator|=
name|ddi_strdup
argument_list|(
name|events
argument_list|,
name|KM_NOSLEEP
argument_list|)
expr_stmt|;
name|end
operator|=
name|cp
operator|+
name|llen
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|llen
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|cp
index|[
name|j
index|]
operator|==
literal|','
condition|)
name|cp
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
while|while
condition|(
name|p
operator|<
name|end
operator|&&
name|found
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|p
argument_list|,
name|event
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dcpc_create_probe
argument_list|(
name|dcpc_pid
argument_list|,
name|desc
operator|->
name|dtpd_name
argument_list|,
name|event
argument_list|,
name|umask
argument_list|,
operator|(
name|uint32_t
operator|)
name|val
argument_list|,
name|flag
argument_list|)
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
block|}
name|p
operator|+=
name|strlen
argument_list|(
name|p
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|cp
argument_list|,
name|llen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
break|break;
block|}
name|err
label|:
name|kmem_free
argument_list|(
name|str
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dcpc_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|dcpc_probe_t
modifier|*
name|pp
init|=
name|parg
decl_stmt|;
name|ASSERT
argument_list|(
name|pp
operator|->
name|dcpc_enabled
operator|==
literal|0
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|pp
argument_list|,
sizeof|sizeof
argument_list|(
name|dcpc_probe_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dcpc_mode
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
if|if
condition|(
name|CPU
operator|->
name|cpu_cpcprofile_pc
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|DTRACE_MODE_NOPRIV_DROP
operator||
name|DTRACE_MODE_USER
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|DTRACE_MODE_NOPRIV_DROP
operator||
name|DTRACE_MODE_KERNEL
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|dcpc_populate_set
parameter_list|(
name|cpu_t
modifier|*
name|c
parameter_list|,
name|dcpc_probe_t
modifier|*
name|pp
parameter_list|,
name|kcpc_set_t
modifier|*
name|set
parameter_list|,
name|int
name|reqno
parameter_list|)
block|{
name|kcpc_set_t
modifier|*
name|oset
decl_stmt|;
name|int
name|i
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_event
argument_list|,
name|pp
operator|->
name|dcpc_event_name
argument_list|,
name|CPC_MAX_EVENT_LEN
argument_list|)
expr_stmt|;
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_config
operator|=
name|NULL
expr_stmt|;
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_index
operator|=
name|reqno
expr_stmt|;
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_picnum
operator|=
operator|-
literal|1
expr_stmt|;
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_flags
operator|=
name|pp
operator|->
name|dcpc_flag
expr_stmt|;
comment|/* 	 * If a unit mask has been specified then detect which attribute 	 * the platform needs. For now, it's either "umask" or "emask". 	 */
if|if
condition|(
name|pp
operator|->
name|dcpc_umask
operator|>=
literal|0
condition|)
block|{
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_attr
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|kcpc_attr_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_nattrs
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|dcpc_mask_type
operator|&
name|DCPC_UMASK
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_attr
operator|->
name|ka_name
argument_list|,
literal|"umask"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_attr
operator|->
name|ka_name
argument_list|,
literal|"emask"
argument_list|,
literal|5
argument_list|)
expr_stmt|;
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_attr
operator|->
name|ka_val
operator|=
name|pp
operator|->
name|dcpc_umask
expr_stmt|;
block|}
else|else
block|{
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_attr
operator|=
name|NULL
expr_stmt|;
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_nattrs
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * If this probe is enabled, obtain its current countdown value 	 * and use that. The CPUs cpc context might not exist yet if we 	 * are dealing with a CPU that is just coming online. 	 */
if|if
condition|(
name|pp
operator|->
name|dcpc_enabled
operator|&&
operator|(
name|c
operator|->
name|cpu_cpc_ctx
operator|!=
name|NULL
operator|)
condition|)
block|{
name|oset
operator|=
name|c
operator|->
name|cpu_cpc_ctx
operator|->
name|kc_set
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|oset
operator|->
name|ks_nreqs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|oset
operator|->
name|ks_req
index|[
name|i
index|]
operator|.
name|kr_event
argument_list|,
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_event
argument_list|)
operator|==
literal|0
condition|)
block|{
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_preset
operator|=
operator|*
operator|(
name|oset
operator|->
name|ks_req
index|[
name|i
index|]
operator|.
name|kr_data
operator|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|set
operator|->
name|ks_req
index|[
name|reqno
index|]
operator|.
name|kr_preset
operator|=
name|UINT64_MAX
operator|-
name|pp
operator|->
name|dcpc_ovfval
expr_stmt|;
block|}
name|set
operator|->
name|ks_nreqs
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a fresh request set for the enablings represented in the  * 'dcpc_actv_reqs' array which contains the probes we want to be  * in the set. This can be called for several reasons:  *  * 1)	We are on a single or multi overflow platform and we have no  *	current events so we can just create the set and initialize it.  * 2)	We are on a multi-overflow platform and we already have one or  *	more existing events and we are adding a new enabling. Create a  *	new set and copy old requests in and then add the new request.  * 3)	We are on a multi-overflow platform and we have just removed an  *	enabling but we still have enablings whch are valid. Create a new  *	set and copy in still valid requests.  */
end_comment

begin_function
specifier|static
name|kcpc_set_t
modifier|*
name|dcpc_create_set
parameter_list|(
name|cpu_t
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|reqno
init|=
literal|0
decl_stmt|;
name|int
name|active_requests
init|=
literal|0
decl_stmt|;
name|kcpc_set_t
modifier|*
name|set
decl_stmt|;
comment|/* 	 * First get a count of the number of currently active requests. 	 * Note that dcpc_actv_reqs[] should always reflect which requests 	 * we want to be in the set that is to be created. It is the 	 * responsibility of the caller of dcpc_create_set() to adjust that 	 * array accordingly beforehand. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpc_ncounters
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
name|active_requests
operator|++
expr_stmt|;
block|}
name|set
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|kcpc_set_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|set
operator|->
name|ks_req
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|kcpc_request_t
argument_list|)
operator|*
name|active_requests
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|set
operator|->
name|ks_data
operator|=
name|kmem_zalloc
argument_list|(
name|active_requests
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * Look for valid entries in the active requests array and populate 	 * the request set for any entries found. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpc_ncounters
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|dcpc_populate_set
argument_list|(
name|c
argument_list|,
name|dcpc_actv_reqs
index|[
name|i
index|]
argument_list|,
name|set
argument_list|,
name|reqno
argument_list|)
expr_stmt|;
name|reqno
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|set
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dcpc_program_cpu_event
parameter_list|(
name|cpu_t
modifier|*
name|c
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|subcode
decl_stmt|;
name|kcpc_ctx_t
modifier|*
name|ctx
decl_stmt|,
modifier|*
name|octx
decl_stmt|;
name|kcpc_set_t
modifier|*
name|set
decl_stmt|;
name|set
operator|=
name|dcpc_create_set
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|set
operator|->
name|ks_ctx
operator|=
name|ctx
operator|=
name|kcpc_ctx_alloc
argument_list|(
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ctx
operator|->
name|kc_set
operator|=
name|set
expr_stmt|;
name|ctx
operator|->
name|kc_cpuid
operator|=
name|c
operator|->
name|cpu_id
expr_stmt|;
if|if
condition|(
name|kcpc_assign_reqs
argument_list|(
name|set
argument_list|,
name|ctx
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
if|if
condition|(
name|kcpc_configure_reqs
argument_list|(
name|ctx
argument_list|,
name|set
argument_list|,
operator|&
name|subcode
argument_list|)
operator|!=
literal|0
condition|)
goto|goto
name|err
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|set
operator|->
name|ks_nreqs
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|cpc_ncounters
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|dcpc_actv_reqs
index|[
name|j
index|]
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|set
operator|->
name|ks_req
index|[
name|i
index|]
operator|.
name|kr_event
argument_list|,
name|dcpc_actv_reqs
index|[
name|j
index|]
operator|->
name|dcpc_event_name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dcpc_actv_reqs
index|[
name|j
index|]
operator|->
name|dcpc_picno
operator|=
name|set
operator|->
name|ks_req
index|[
name|i
index|]
operator|.
name|kr_picnum
expr_stmt|;
block|}
block|}
block|}
comment|/* 	 * If we already have an active enabling then save the current cpc 	 * context away. 	 */
name|octx
operator|=
name|c
operator|->
name|cpu_cpc_ctx
expr_stmt|;
name|kcpc_cpu_program
argument_list|(
name|c
argument_list|,
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|octx
operator|!=
name|NULL
condition|)
block|{
name|kcpc_set_t
modifier|*
name|oset
init|=
name|octx
operator|->
name|kc_set
decl_stmt|;
name|kmem_free
argument_list|(
name|oset
operator|->
name|ks_data
argument_list|,
name|oset
operator|->
name|ks_nreqs
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|kcpc_free_configs
argument_list|(
name|oset
argument_list|)
expr_stmt|;
name|kcpc_free_set
argument_list|(
name|oset
argument_list|)
expr_stmt|;
name|kcpc_ctx_free
argument_list|(
name|octx
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
comment|/* 	 * We failed to configure this request up so free things up and 	 * get out. 	 */
name|kcpc_free_configs
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|set
operator|->
name|ks_data
argument_list|,
name|set
operator|->
name|ks_nreqs
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|kcpc_free_set
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|kcpc_ctx_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|dcpc_disable_cpu
parameter_list|(
name|cpu_t
modifier|*
name|c
parameter_list|)
block|{
name|kcpc_ctx_t
modifier|*
name|ctx
decl_stmt|;
name|kcpc_set_t
modifier|*
name|set
decl_stmt|;
comment|/* 	 * Leave this CPU alone if it's already offline. 	 */
if|if
condition|(
name|c
operator|->
name|cpu_flags
operator|&
name|CPU_OFFLINE
condition|)
return|return;
comment|/* 	 * Grab CPUs CPC context before kcpc_cpu_stop() stops counters and 	 * changes it. 	 */
name|ctx
operator|=
name|c
operator|->
name|cpu_cpc_ctx
expr_stmt|;
name|kcpc_cpu_stop
argument_list|(
name|c
argument_list|,
name|B_FALSE
argument_list|)
expr_stmt|;
name|set
operator|=
name|ctx
operator|->
name|kc_set
expr_stmt|;
name|kcpc_free_configs
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|set
operator|->
name|ks_data
argument_list|,
name|set
operator|->
name|ks_nreqs
operator|*
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
name|kcpc_free_set
argument_list|(
name|set
argument_list|)
expr_stmt|;
name|kcpc_ctx_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The dcpc_*_interrupts() routines are responsible for manipulating the  * per-CPU dcpc interrupt state byte. The purpose of the state byte is to  * synchronize processing of hardware overflow interrupts wth configuration  * changes made to the CPU performance counter subsystem by the dcpc provider.  *  * The dcpc provider claims ownership of the overflow interrupt mechanism  * by transitioning the state byte from DCPC_INTR_INACTIVE (indicating the  * dcpc provider is not in use) to DCPC_INTR_FREE (the dcpc provider owns the  * overflow mechanism and interrupts may be processed). Before modifying  * a CPUs configuration state the state byte is transitioned from  * DCPC_INTR_FREE to DCPC_INTR_CONFIG ("configuration in process" state).  * The hardware overflow handler, kcpc_hw_overflow_intr(), will only process  * an interrupt when a configuration is not in process (i.e. the state is  * marked as free). During interrupt processing the state is set to  * DCPC_INTR_PROCESSING by the overflow handler. When the last dcpc based  * enabling is removed, the state byte is set to DCPC_INTR_INACTIVE to indicate  * the dcpc provider is no longer interested in overflow interrupts.  */
end_comment

begin_function
specifier|static
name|void
name|dcpc_block_interrupts
parameter_list|(
name|void
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
init|=
name|cpu_list
decl_stmt|;
name|uint8_t
modifier|*
name|state
decl_stmt|;
name|ASSERT
argument_list|(
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|!=
name|DCPC_INTR_INACTIVE
argument_list|)
expr_stmt|;
do|do
block|{
name|state
operator|=
operator|&
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
expr_stmt|;
while|while
condition|(
name|atomic_cas_8
argument_list|(
name|state
argument_list|,
name|DCPC_INTR_FREE
argument_list|,
name|DCPC_INTR_CONFIG
argument_list|)
operator|!=
name|DCPC_INTR_FREE
condition|)
continue|continue;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Set all CPUs dcpc interrupt state to DCPC_INTR_FREE to indicate that  * overflow interrupts can be processed safely.  */
end_comment

begin_function
specifier|static
name|void
name|dcpc_release_interrupts
parameter_list|(
name|void
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
init|=
name|cpu_list
decl_stmt|;
name|ASSERT
argument_list|(
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|!=
name|DCPC_INTR_INACTIVE
argument_list|)
expr_stmt|;
do|do
block|{
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|=
name|DCPC_INTR_FREE
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Transition all CPUs dcpc interrupt state from DCPC_INTR_INACTIVE to  * to DCPC_INTR_FREE. This indicates that the dcpc provider is now  * responsible for handling all overflow interrupt activity. Should only be  * called before enabling the first dcpc based probe.  */
end_comment

begin_function
specifier|static
name|void
name|dcpc_claim_interrupts
parameter_list|(
name|void
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
init|=
name|cpu_list
decl_stmt|;
name|ASSERT
argument_list|(
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|==
name|DCPC_INTR_INACTIVE
argument_list|)
expr_stmt|;
do|do
block|{
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|=
name|DCPC_INTR_FREE
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Set all CPUs dcpc interrupt state to DCPC_INTR_INACTIVE to indicate that  * the dcpc provider is no longer processing overflow interrupts. Only called  * during removal of the last dcpc based enabling.  */
end_comment

begin_function
specifier|static
name|void
name|dcpc_surrender_interrupts
parameter_list|(
name|void
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
init|=
name|cpu_list
decl_stmt|;
name|ASSERT
argument_list|(
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|!=
name|DCPC_INTR_INACTIVE
argument_list|)
expr_stmt|;
do|do
block|{
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|=
name|DCPC_INTR_INACTIVE
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * dcpc_program_event() can be called owing to a new enabling or if a multi  * overflow platform has disabled a request but needs to  program the requests  * that are still valid.  *  * Every invocation of dcpc_program_event() will create a new kcpc_ctx_t  * and a new request set which contains the new enabling and any old enablings  * which are still valid (possible with multi-overflow platforms).  */
end_comment

begin_function
specifier|static
name|int
name|dcpc_program_event
parameter_list|(
name|dcpc_probe_t
modifier|*
name|pp
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
decl_stmt|;
name|int
name|ret
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|kpreempt_disable
argument_list|()
expr_stmt|;
name|dcpc_block_interrupts
argument_list|()
expr_stmt|;
name|c
operator|=
name|cpu_list
expr_stmt|;
do|do
block|{
comment|/* 		 * Skip CPUs that are currently offline. 		 */
if|if
condition|(
name|c
operator|->
name|cpu_flags
operator|&
name|CPU_OFFLINE
condition|)
continue|continue;
comment|/* 		 * Stop counters but preserve existing DTrace CPC context 		 * if there is one. 		 * 		 * If we come here when the first event is programmed for a CPU, 		 * there should be no DTrace CPC context installed. In this 		 * case, kcpc_cpu_stop() will ensure that there is no other 		 * context on the CPU. 		 * 		 * If we add new enabling to the original one, the CPU should 		 * have the old DTrace CPC context which we need to keep around 		 * since dcpc_program_event() will add to it. 		 */
if|if
condition|(
name|c
operator|->
name|cpu_cpc_ctx
operator|!=
name|NULL
condition|)
name|kcpc_cpu_stop
argument_list|(
name|c
argument_list|,
name|B_TRUE
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
name|dcpc_release_interrupts
argument_list|()
expr_stmt|;
comment|/* 	 * If this enabling is being removed (in the case of a multi event 	 * capable system with more than one active enabling), we can now 	 * update the active request array to reflect the enablings that need 	 * to be reprogrammed. 	 */
if|if
condition|(
name|pp
operator|->
name|dcpc_disabling
operator|==
literal|1
condition|)
name|dcpc_actv_reqs
index|[
name|pp
operator|->
name|dcpc_actv_req_idx
index|]
operator|=
name|NULL
expr_stmt|;
do|do
block|{
comment|/* 		 * Skip CPUs that are currently offline. 		 */
if|if
condition|(
name|c
operator|->
name|cpu_flags
operator|&
name|CPU_OFFLINE
condition|)
continue|continue;
name|ret
operator|=
name|dcpc_program_cpu_event
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
operator|&&
name|ret
operator|==
literal|0
condition|)
do|;
comment|/* 	 * If dcpc_program_cpu_event() fails then it is because we couldn't 	 * configure the requests in the set for the CPU and not because of 	 * an error programming the hardware. If we have a failure here then 	 * we assume no CPUs have been programmed in the above step as they 	 * are all configured identically. 	 */
if|if
condition|(
name|ret
operator|!=
literal|0
condition|)
block|{
name|pp
operator|->
name|dcpc_enabled
operator|=
literal|0
expr_stmt|;
name|kpreempt_enable
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pp
operator|->
name|dcpc_disabling
operator|!=
literal|1
condition|)
name|pp
operator|->
name|dcpc_enabled
operator|=
literal|1
expr_stmt|;
name|kpreempt_enable
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dcpc_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|dcpc_probe_t
modifier|*
name|pp
init|=
name|parg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|found
init|=
literal|0
decl_stmt|;
name|cpu_t
modifier|*
name|c
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Bail out if the counters are being used by a libcpc consumer. 	 */
name|rw_enter
argument_list|(
operator|&
name|kcpc_cpuctx_lock
argument_list|,
name|RW_READER
argument_list|)
expr_stmt|;
if|if
condition|(
name|kcpc_cpuctx
operator|>
literal|0
condition|)
block|{
name|rw_exit
argument_list|(
operator|&
name|kcpc_cpuctx_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|dtrace_cpc_in_use
operator|++
expr_stmt|;
name|rw_exit
argument_list|(
operator|&
name|kcpc_cpuctx_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Locate this enabling in the first free entry of the active 	 * request array. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cpc_ncounters
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|==
name|NULL
condition|)
block|{
name|dcpc_actv_reqs
index|[
name|i
index|]
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|dcpc_actv_req_idx
operator|=
name|i
expr_stmt|;
name|found
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * If we couldn't find a slot for this probe then there is no 	 * room at the inn. 	 */
if|if
condition|(
operator|!
name|found
condition|)
block|{
name|dtrace_cpc_in_use
operator|--
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|ASSERT
argument_list|(
name|pp
operator|->
name|dcpc_actv_req_idx
operator|>=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * DTrace is taking over CPC contexts, so stop collecting 	 * capacity/utilization data for all CPUs. 	 */
if|if
condition|(
name|dtrace_cpc_in_use
operator|==
literal|1
condition|)
name|cu_disable
argument_list|()
expr_stmt|;
comment|/* 	 * The following must hold true if we are to (attempt to) enable 	 * this request: 	 * 	 * 1) No enablings currently exist. We allow all platforms to 	 * proceed if this is true. 	 * 	 * OR 	 * 	 * 2) If the platform is multi overflow capable and there are 	 * less valid enablings than there are counters. There is no 	 * guarantee that a platform can accommodate as many events as 	 * it has counters for but we will at least try to program 	 * up to that many requests. 	 * 	 * The 'dcpc_enablings' variable is implictly protected by locking 	 * provided by the DTrace framework and the cpu management framework. 	 */
if|if
condition|(
name|dcpc_enablings
operator|==
literal|0
operator|||
operator|(
name|dcpc_mult_ovf_cap
operator|&&
name|dcpc_enablings
operator|<
name|cpc_ncounters
operator|)
condition|)
block|{
comment|/* 		 * Before attempting to program the first enabling we need to 		 * invalidate any lwp-based contexts and lay claim to the 		 * overflow interrupt mechanism. 		 */
if|if
condition|(
name|dcpc_enablings
operator|==
literal|0
condition|)
block|{
name|kcpc_invalidate_all
argument_list|()
expr_stmt|;
name|dcpc_claim_interrupts
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|dcpc_program_event
argument_list|(
name|pp
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dcpc_enablings
operator|++
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
comment|/* 	 * If active enablings existed before we failed to enable this probe 	 * on a multi event capable platform then we need to restart counters 	 * as they will have been stopped in the attempted configuration. The 	 * context should now just contain the request prior to this failed 	 * enabling. 	 */
if|if
condition|(
name|dcpc_enablings
operator|>
literal|0
operator|&&
name|dcpc_mult_ovf_cap
condition|)
block|{
name|c
operator|=
name|cpu_list
expr_stmt|;
name|ASSERT
argument_list|(
name|dcpc_mult_ovf_cap
operator|==
literal|1
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* 			 * Skip CPUs that are currently offline. 			 */
if|if
condition|(
name|c
operator|->
name|cpu_flags
operator|&
name|CPU_OFFLINE
condition|)
continue|continue;
name|kcpc_cpu_program
argument_list|(
name|c
argument_list|,
name|c
operator|->
name|cpu_cpc_ctx
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
block|}
comment|/* 	 * Give up any claim to the overflow interrupt mechanism if no 	 * dcpc based enablings exist. 	 */
if|if
condition|(
name|dcpc_enablings
operator|==
literal|0
condition|)
name|dcpc_surrender_interrupts
argument_list|()
expr_stmt|;
name|dtrace_cpc_in_use
operator|--
expr_stmt|;
name|dcpc_actv_reqs
index|[
name|pp
operator|->
name|dcpc_actv_req_idx
index|]
operator|=
name|NULL
expr_stmt|;
name|pp
operator|->
name|dcpc_actv_req_idx
operator|=
name|pp
operator|->
name|dcpc_picno
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If all probes are removed, enable capacity/utilization data 	 * collection for every CPU. 	 */
if|if
condition|(
name|dtrace_cpc_in_use
operator|==
literal|0
condition|)
name|cu_enable
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * If only one enabling is active then remove the context and free  * everything up. If there are multiple enablings active then remove this  * one, its associated meta-data and re-program the hardware.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|dcpc_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
decl_stmt|;
name|dcpc_probe_t
modifier|*
name|pp
init|=
name|parg
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|kpreempt_disable
argument_list|()
expr_stmt|;
comment|/* 	 * This probe didn't actually make it as far as being fully enabled 	 * so we needn't do anything with it. 	 */
if|if
condition|(
name|pp
operator|->
name|dcpc_enabled
operator|==
literal|0
condition|)
block|{
comment|/* 		 * If we actually allocated this request a slot in the 		 * request array but failed to enabled it then remove the 		 * entry in the array. 		 */
if|if
condition|(
name|pp
operator|->
name|dcpc_actv_req_idx
operator|>=
literal|0
condition|)
block|{
name|dcpc_actv_reqs
index|[
name|pp
operator|->
name|dcpc_actv_req_idx
index|]
operator|=
name|NULL
expr_stmt|;
name|pp
operator|->
name|dcpc_actv_req_idx
operator|=
name|pp
operator|->
name|dcpc_picno
operator|=
name|pp
operator|->
name|dcpc_disabling
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|kpreempt_enable
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* 	 * If this is the only enabling then stop all the counters and 	 * free up the meta-data. 	 */
if|if
condition|(
name|dcpc_enablings
operator|==
literal|1
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_cpc_in_use
operator|==
literal|1
argument_list|)
expr_stmt|;
name|dcpc_block_interrupts
argument_list|()
expr_stmt|;
name|c
operator|=
name|cpu_list
expr_stmt|;
do|do
block|{
name|dcpc_disable_cpu
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|c
operator|=
name|c
operator|->
name|cpu_next
operator|)
operator|!=
name|cpu_list
condition|)
do|;
name|dcpc_actv_reqs
index|[
name|pp
operator|->
name|dcpc_actv_req_idx
index|]
operator|=
name|NULL
expr_stmt|;
name|dcpc_surrender_interrupts
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * This platform can support multiple overflow events and 		 * the enabling being disabled is not the last one. Remove this 		 * enabling and re-program the hardware with the new config. 		 */
name|ASSERT
argument_list|(
name|dcpc_mult_ovf_cap
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dcpc_enablings
operator|>
literal|1
argument_list|)
expr_stmt|;
name|pp
operator|->
name|dcpc_disabling
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|dcpc_program_event
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|kpreempt_enable
argument_list|()
expr_stmt|;
name|dcpc_enablings
operator|--
expr_stmt|;
name|dtrace_cpc_in_use
operator|--
expr_stmt|;
name|pp
operator|->
name|dcpc_enabled
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|dcpc_actv_req_idx
operator|=
name|pp
operator|->
name|dcpc_picno
operator|=
name|pp
operator|->
name|dcpc_disabling
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* 	 * If all probes are removed, enable capacity/utilization data 	 * collection for every CPU 	 */
if|if
condition|(
name|dtrace_cpc_in_use
operator|==
literal|0
condition|)
name|cu_enable
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dcpc_cpu_setup
parameter_list|(
name|cpu_setup_t
name|what
parameter_list|,
name|processorid_t
name|cpu
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|)
block|{
name|cpu_t
modifier|*
name|c
decl_stmt|;
name|uint8_t
modifier|*
name|state
decl_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|what
condition|)
block|{
case|case
name|CPU_OFF
case|:
comment|/* 		 * Offline CPUs are not allowed to take part so remove this 		 * CPU if we are actively tracing. 		 */
if|if
condition|(
name|dtrace_cpc_in_use
condition|)
block|{
name|c
operator|=
name|cpu_get
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
name|state
operator|=
operator|&
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
expr_stmt|;
comment|/* 			 * Indicate that a configuration is in process in 			 * order to stop overflow interrupts being processed 			 * on this CPU while we disable it. 			 */
while|while
condition|(
name|atomic_cas_8
argument_list|(
name|state
argument_list|,
name|DCPC_INTR_FREE
argument_list|,
name|DCPC_INTR_CONFIG
argument_list|)
operator|!=
name|DCPC_INTR_FREE
condition|)
continue|continue;
name|dcpc_disable_cpu
argument_list|(
name|c
argument_list|)
expr_stmt|;
comment|/* 			 * Reset this CPUs interrupt state as the configuration 			 * has ended. 			 */
name|cpu_core
index|[
name|c
operator|->
name|cpu_id
index|]
operator|.
name|cpuc_dcpc_intr_state
operator|=
name|DCPC_INTR_FREE
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
name|CPU_ON
case|:
case|case
name|CPU_SETUP
case|:
comment|/* 		 * This CPU is being initialized or brought online so program 		 * it with the current request set if we are actively tracing. 		 */
if|if
condition|(
name|dtrace_cpc_in_use
condition|)
block|{
name|c
operator|=
name|cpu_get
argument_list|(
name|cpu
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dcpc_program_cpu_event
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
break|break;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dtrace_pattr_t
name|dcpc_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_CPU
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_COMMON
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|dcpc_pops
init|=
block|{
name|dcpc_provide
block|,
name|NULL
block|,
name|dcpc_enable
block|,
name|dcpc_disable
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|NULL
block|,
name|dcpc_mode
block|,
name|dcpc_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dcpc_open
parameter_list|(
name|dev_t
modifier|*
name|devp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|cred_t
modifier|*
name|cred_p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|dcpc_info
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|,
name|ddi_info_cmd_t
name|infocmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|infocmd
condition|)
block|{
case|case
name|DDI_INFO_DEVT2DEVINFO
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|dcpc_devi
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
case|case
name|DDI_INFO_DEVT2INSTANCE
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|DDI_FAILURE
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dcpc_detach
parameter_list|(
name|dev_info_t
modifier|*
name|devi
parameter_list|,
name|ddi_detach_cmd_t
name|cmd
parameter_list|)
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_DETACH
case|:
break|break;
case|case
name|DDI_SUSPEND
case|:
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|dtrace_unregister
argument_list|(
name|dcpc_pid
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
name|ddi_remove_minor_node
argument_list|(
name|devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|unregister_cpu_setup_func
argument_list|(
name|dcpc_cpu_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|dcpc_actv_reqs
argument_list|,
name|cpc_ncounters
operator|*
sizeof|sizeof
argument_list|(
name|dcpc_probe_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|kcpc_unregister_dcpc
argument_list|()
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|dcpc_attach
parameter_list|(
name|dev_info_t
modifier|*
name|devi
parameter_list|,
name|ddi_attach_cmd_t
name|cmd
parameter_list|)
block|{
name|uint_t
name|caps
decl_stmt|;
name|char
modifier|*
name|attrs
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_ATTACH
case|:
break|break;
case|case
name|DDI_RESUME
case|:
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|kcpc_pcbe_loaded
argument_list|()
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
name|caps
operator|=
name|kcpc_pcbe_capabilities
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|caps
operator|&
name|CPC_CAP_OVERFLOW_INTERRUPT
operator|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"!dcpc: Counter Overflow not supported"
expr|\
literal|" on this processor"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|devi
argument_list|,
literal|"dcpc"
argument_list|,
name|S_IFCHR
argument_list|,
literal|0
argument_list|,
name|DDI_PSEUDO
argument_list|,
name|NULL
argument_list|)
operator|==
name|DDI_FAILURE
operator|||
name|dtrace_register
argument_list|(
literal|"cpc"
argument_list|,
operator|&
name|dcpc_attr
argument_list|,
name|DTRACE_PRIV_KERNEL
argument_list|,
name|NULL
argument_list|,
operator|&
name|dcpc_pops
argument_list|,
name|NULL
argument_list|,
operator|&
name|dcpc_pid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|register_cpu_setup_func
argument_list|(
name|dcpc_cpu_setup
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_lock
argument_list|)
expr_stmt|;
name|dcpc_ovf_mask
operator|=
operator|(
literal|1
operator|<<
name|cpc_ncounters
operator|)
operator|-
literal|1
expr_stmt|;
name|ASSERT
argument_list|(
name|dcpc_ovf_mask
operator|!=
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|caps
operator|&
name|CPC_CAP_OVERFLOW_PRECISE
condition|)
name|dcpc_mult_ovf_cap
operator|=
literal|1
expr_stmt|;
comment|/* 	 * Determine which, if any, mask attribute the back-end can use. 	 */
name|attrs
operator|=
name|kcpc_list_attrs
argument_list|()
expr_stmt|;
if|if
condition|(
name|strstr
argument_list|(
name|attrs
argument_list|,
literal|"umask"
argument_list|)
operator|!=
name|NULL
condition|)
name|dcpc_mask_type
operator||=
name|DCPC_UMASK
expr_stmt|;
elseif|else
if|if
condition|(
name|strstr
argument_list|(
name|attrs
argument_list|,
literal|"emask"
argument_list|)
operator|!=
name|NULL
condition|)
name|dcpc_mask_type
operator||=
name|DCPC_EMASK
expr_stmt|;
comment|/* 	 * The dcpc_actv_reqs array is used to store the requests that 	 * we currently have programmed. The order of requests in this 	 * array is not necessarily the order that the event appears in 	 * the kcpc_request_t array. Once entered into a slot in the array 	 * the entry is not moved until it's removed. 	 */
name|dcpc_actv_reqs
operator|=
name|kmem_zalloc
argument_list|(
name|cpc_ncounters
operator|*
sizeof|sizeof
argument_list|(
name|dcpc_probe_t
operator|*
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|dcpc_min_overflow
operator|=
name|ddi_prop_get_int
argument_list|(
name|DDI_DEV_T_ANY
argument_list|,
name|devi
argument_list|,
name|DDI_PROP_DONTPASS
argument_list|,
literal|"dcpc-min-overflow"
argument_list|,
name|DCPC_MIN_OVF_DEFAULT
argument_list|)
expr_stmt|;
name|kcpc_register_dcpc
argument_list|(
name|dcpc_fire
argument_list|)
expr_stmt|;
name|ddi_report_dev
argument_list|(
name|devi
argument_list|)
expr_stmt|;
name|dcpc_devi
operator|=
name|devi
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cb_ops
name|dcpc_cb_ops
init|=
block|{
name|dcpc_open
block|,
comment|/* open */
name|nodev
block|,
comment|/* close */
name|nulldev
block|,
comment|/* strategy */
name|nulldev
block|,
comment|/* print */
name|nodev
block|,
comment|/* dump */
name|nodev
block|,
comment|/* read */
name|nodev
block|,
comment|/* write */
name|nodev
block|,
comment|/* ioctl */
name|nodev
block|,
comment|/* devmap */
name|nodev
block|,
comment|/* mmap */
name|nodev
block|,
comment|/* segmap */
name|nochpoll
block|,
comment|/* poll */
name|ddi_prop_op
block|,
comment|/* cb_prop_op */
literal|0
block|,
comment|/* streamtab  */
name|D_NEW
operator||
name|D_MP
comment|/* Driver compatibility flag */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|dev_ops
name|dcpc_ops
init|=
block|{
name|DEVO_REV
block|,
comment|/* devo_rev, */
literal|0
block|,
comment|/* refcnt  */
name|dcpc_info
block|,
comment|/* get_dev_info */
name|nulldev
block|,
comment|/* identify */
name|nulldev
block|,
comment|/* probe */
name|dcpc_attach
block|,
comment|/* attach */
name|dcpc_detach
block|,
comment|/* detach */
name|nodev
block|,
comment|/* reset */
operator|&
name|dcpc_cb_ops
block|,
comment|/* driver operations */
name|NULL
block|,
comment|/* bus operations */
name|nodev
block|,
comment|/* dev power */
name|ddi_quiesce_not_needed
comment|/* quiesce */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Module linkage information for the kernel.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|modldrv
name|modldrv
init|=
block|{
operator|&
name|mod_driverops
block|,
comment|/* module type */
literal|"DTrace CPC Module"
block|,
comment|/* name of module */
operator|&
name|dcpc_ops
block|,
comment|/* driver ops */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlinkage
name|modlinkage
init|=
block|{
name|MODREV_1
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|modldrv
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_install
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_info
parameter_list|(
name|struct
name|modinfo
modifier|*
name|modinfop
parameter_list|)
block|{
return|return
operator|(
name|mod_info
argument_list|(
operator|&
name|modlinkage
argument_list|,
name|modinfop
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_remove
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

