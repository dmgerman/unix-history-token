begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  */
end_comment

begin_include
include|#
directive|include
file|<sys/atomic.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/modctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/strsubr.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/fasttrap_isa.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/dtrace_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/priv.h>
end_include

begin_include
include|#
directive|include
file|<sys/policy.h>
end_include

begin_include
include|#
directive|include
file|<util/qsort.h>
end_include

begin_comment
comment|/*  * User-Land Trap-Based Tracing  * ----------------------------  *  * The fasttrap provider allows DTrace consumers to instrument any user-level  * instruction to gather data; this includes probes with semantic  * signifigance like entry and return as well as simple offsets into the  * function. While the specific techniques used are very ISA specific, the  * methodology is generalizable to any architecture.  *  *  * The General Methodology  * -----------------------  *  * With the primary goal of tracing every user-land instruction and the  * limitation that we can't trust user space so don't want to rely on much  * information there, we begin by replacing the instructions we want to trace  * with trap instructions. Each instruction we overwrite is saved into a hash  * table keyed by process ID and pc address. When we enter the kernel due to  * this trap instruction, we need the effects of the replaced instruction to  * appear to have occurred before we proceed with the user thread's  * execution.  *  * Each user level thread is represented by a ulwp_t structure which is  * always easily accessible through a register. The most basic way to produce  * the effects of the instruction we replaced is to copy that instruction out  * to a bit of scratch space reserved in the user thread's ulwp_t structure  * (a sort of kernel-private thread local storage), set the PC to that  * scratch space and single step. When we reenter the kernel after single  * stepping the instruction we must then adjust the PC to point to what would  * normally be the next instruction. Of course, special care must be taken  * for branches and jumps, but these represent such a small fraction of any  * instruction set that writing the code to emulate these in the kernel is  * not too difficult.  *  * Return probes may require several tracepoints to trace every return site,  * and, conversely, each tracepoint may activate several probes (the entry  * and offset 0 probes, for example). To solve this muliplexing problem,  * tracepoints contain lists of probes to activate and probes contain lists  * of tracepoints to enable. If a probe is activated, it adds its ID to  * existing tracepoints or creates new ones as necessary.  *  * Most probes are activated _before_ the instruction is executed, but return  * probes are activated _after_ the effects of the last instruction of the  * function are visible. Return probes must be fired _after_ we have  * single-stepped the instruction whereas all other probes are fired  * beforehand.  *  *  * Lock Ordering  * -------------  *  * The lock ordering below -- both internally and with respect to the DTrace  * framework -- is a little tricky and bears some explanation. Each provider  * has a lock (ftp_mtx) that protects its members including reference counts  * for enabled probes (ftp_rcount), consumers actively creating probes  * (ftp_ccount) and USDT consumers (ftp_mcount); all three prevent a provider  * from being freed. A provider is looked up by taking the bucket lock for the  * provider hash table, and is returned with its lock held. The provider lock  * may be taken in functions invoked by the DTrace framework, but may not be  * held while calling functions in the DTrace framework.  *  * To ensure consistency over multiple calls to the DTrace framework, the  * creation lock (ftp_cmtx) should be held. Naturally, the creation lock may  * not be taken when holding the provider lock as that would create a cyclic  * lock ordering. In situations where one would naturally take the provider  * lock and then the creation lock, we instead up a reference count to prevent  * the provider from disappearing, drop the provider lock, and acquire the  * creation lock.  *  * Briefly:  * 	bucket lock before provider lock  *	DTrace before provider lock  *	creation lock before DTrace  *	never hold the provider lock and creation lock simultaneously  */
end_comment

begin_decl_stmt
specifier|static
name|dev_info_t
modifier|*
name|fasttrap_devi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_meta_provider_id_t
name|fasttrap_meta_id
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|timeout_id_t
name|fasttrap_timeout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|fasttrap_cleanup_mtx
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint_t
name|fasttrap_cleanup_work
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Generation count on modifications to the global tracepoint lookup table.  */
end_comment

begin_decl_stmt
specifier|static
specifier|volatile
name|uint64_t
name|fasttrap_mod_gen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * When the fasttrap provider is loaded, fasttrap_max is set to either  * FASTTRAP_MAX_DEFAULT or the value for fasttrap-max-probes in the  * fasttrap.conf file. Each time a probe is created, fasttrap_total is  * incremented by the number of tracepoints that may be associated with that  * probe; fasttrap_total is capped at fasttrap_max.  */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_MAX_DEFAULT
value|250000
end_define

begin_decl_stmt
specifier|static
name|uint32_t
name|fasttrap_max
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint32_t
name|fasttrap_total
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|FASTTRAP_TPOINTS_DEFAULT_SIZE
value|0x4000
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PROVIDERS_DEFAULT_SIZE
value|0x100
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PROCS_DEFAULT_SIZE
value|0x100
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PID_NAME
value|"pid"
end_define

begin_decl_stmt
name|fasttrap_hash_t
name|fasttrap_tpoints
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fasttrap_hash_t
name|fasttrap_provs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|fasttrap_hash_t
name|fasttrap_procs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint64_t
name|fasttrap_pid_count
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pid ref count */
end_comment

begin_decl_stmt
specifier|static
name|kmutex_t
name|fasttrap_count_mtx
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* lock on ref count */
end_comment

begin_define
define|#
directive|define
name|FASTTRAP_ENABLE_FAIL
value|1
end_define

begin_define
define|#
directive|define
name|FASTTRAP_ENABLE_PARTIAL
value|2
end_define

begin_function_decl
specifier|static
name|int
name|fasttrap_tracepoint_enable
parameter_list|(
name|proc_t
modifier|*
parameter_list|,
name|fasttrap_probe_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_tracepoint_disable
parameter_list|(
name|proc_t
modifier|*
parameter_list|,
name|fasttrap_probe_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fasttrap_provider_t
modifier|*
name|fasttrap_provider_lookup
parameter_list|(
name|pid_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|dtrace_pattr_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_provider_retire
parameter_list|(
name|pid_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_provider_free
parameter_list|(
name|fasttrap_provider_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|fasttrap_proc_t
modifier|*
name|fasttrap_proc_lookup
parameter_list|(
name|pid_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|fasttrap_proc_release
parameter_list|(
name|fasttrap_proc_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FASTTRAP_PROVS_INDEX
parameter_list|(
name|pid
parameter_list|,
name|name
parameter_list|)
define|\
value|((fasttrap_hash_str(name) + (pid))& fasttrap_provs.fth_mask)
end_define

begin_define
define|#
directive|define
name|FASTTRAP_PROCS_INDEX
parameter_list|(
name|pid
parameter_list|)
value|((pid)& fasttrap_procs.fth_mask)
end_define

begin_function
specifier|static
name|int
name|fasttrap_highbit
parameter_list|(
name|ulong_t
name|i
parameter_list|)
block|{
name|int
name|h
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
ifdef|#
directive|ifdef
name|_LP64
if|if
condition|(
name|i
operator|&
literal|0xffffffff00000000ul
condition|)
block|{
name|h
operator|+=
literal|32
expr_stmt|;
name|i
operator|>>=
literal|32
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|i
operator|&
literal|0xffff0000
condition|)
block|{
name|h
operator|+=
literal|16
expr_stmt|;
name|i
operator|>>=
literal|16
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0xff00
condition|)
block|{
name|h
operator|+=
literal|8
expr_stmt|;
name|i
operator|>>=
literal|8
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0xf0
condition|)
block|{
name|h
operator|+=
literal|4
expr_stmt|;
name|i
operator|>>=
literal|4
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0xc
condition|)
block|{
name|h
operator|+=
literal|2
expr_stmt|;
name|i
operator|>>=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|&
literal|0x2
condition|)
block|{
name|h
operator|+=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|h
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|uint_t
name|fasttrap_hash_str
parameter_list|(
specifier|const
name|char
modifier|*
name|p
parameter_list|)
block|{
name|unsigned
name|int
name|g
decl_stmt|;
name|uint_t
name|hval
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|hval
operator|=
operator|(
name|hval
operator|<<
literal|4
operator|)
operator|+
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|g
operator|=
operator|(
name|hval
operator|&
literal|0xf0000000
operator|)
operator|)
operator|!=
literal|0
condition|)
name|hval
operator|^=
name|g
operator|>>
literal|24
expr_stmt|;
name|hval
operator|&=
operator|~
name|g
expr_stmt|;
block|}
return|return
operator|(
name|hval
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fasttrap_sigtrap
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|kthread_t
modifier|*
name|t
parameter_list|,
name|uintptr_t
name|pc
parameter_list|)
block|{
name|sigqueue_t
modifier|*
name|sqp
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|sigqueue_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_signo
operator|=
name|SIGTRAP
expr_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_code
operator|=
name|TRAP_DTRACE
expr_stmt|;
name|sqp
operator|->
name|sq_info
operator|.
name|si_addr
operator|=
operator|(
name|caddr_t
operator|)
name|pc
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sigaddqa
argument_list|(
name|p
argument_list|,
name|t
argument_list|,
name|sqp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NULL
condition|)
name|aston
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This function ensures that no threads are actively using the memory  * associated with probes that were formerly live.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_mod_barrier
parameter_list|(
name|uint64_t
name|gen
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|gen
operator|<
name|fasttrap_mod_gen
condition|)
return|return;
name|fasttrap_mod_gen
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCPU
condition|;
name|i
operator|++
control|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|cpu_core
index|[
name|i
index|]
operator|.
name|cpuc_pid_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cpu_core
index|[
name|i
index|]
operator|.
name|cpuc_pid_lock
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * This is the timeout's callback for cleaning up the providers and their  * probes.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_cleanup_cb
parameter_list|(
name|void
modifier|*
name|data
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
modifier|*
name|fpp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|dtrace_provider_id_t
name|provid
decl_stmt|;
name|int
name|i
decl_stmt|,
name|later
decl_stmt|,
name|rval
decl_stmt|;
specifier|static
specifier|volatile
name|int
name|in
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|in
operator|==
literal|0
argument_list|)
expr_stmt|;
name|in
operator|=
literal|1
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
while|while
condition|(
name|fasttrap_cleanup_work
condition|)
block|{
name|fasttrap_cleanup_work
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|later
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Iterate over all the providers trying to remove the marked 		 * ones. If a provider is marked but not retired, we just 		 * have to take a crack at removing it -- it's no big deal if 		 * we can't. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_provs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
block|{
name|bucket
operator|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|i
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fpp
operator|=
operator|(
name|fasttrap_provider_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
while|while
condition|(
operator|(
name|fp
operator|=
operator|*
name|fpp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|!
name|fp
operator|->
name|ftp_marked
condition|)
block|{
name|fpp
operator|=
operator|&
name|fp
operator|->
name|ftp_next
expr_stmt|;
continue|continue;
block|}
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 				 * If this provider has consumers actively 				 * creating probes (ftp_ccount) or is a USDT 				 * provider (ftp_mcount), we can't unregister 				 * or even condense. 				 */
if|if
condition|(
name|fp
operator|->
name|ftp_ccount
operator|!=
literal|0
operator|||
name|fp
operator|->
name|ftp_mcount
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ftp_marked
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|fp
operator|->
name|ftp_retired
operator|||
name|fp
operator|->
name|ftp_rcount
operator|!=
literal|0
condition|)
name|fp
operator|->
name|ftp_marked
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 				 * If we successfully unregister this 				 * provider we can remove it from the hash 				 * chain and free the memory. If our attempt 				 * to unregister fails and this is a retired 				 * provider, increment our flag to try again 				 * pretty soon. If we've consumed more than 				 * half of our total permitted number of 				 * probes call dtrace_condense() to try to 				 * clean out the unenabled probes. 				 */
name|provid
operator|=
name|fp
operator|->
name|ftp_provid
expr_stmt|;
if|if
condition|(
operator|(
name|rval
operator|=
name|dtrace_unregister
argument_list|(
name|provid
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
operator|/
literal|2
condition|)
operator|(
name|void
operator|)
name|dtrace_condense
argument_list|(
name|provid
argument_list|)
expr_stmt|;
if|if
condition|(
name|rval
operator|==
name|EAGAIN
condition|)
name|fp
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|later
operator|+=
name|fp
operator|->
name|ftp_marked
expr_stmt|;
name|fpp
operator|=
operator|&
name|fp
operator|->
name|ftp_next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fpp
operator|=
name|fp
operator|->
name|ftp_next
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|fasttrap_timeout
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If we were unable to remove a retired provider, try again after 	 * a second. This situation can occur in certain circumstances where 	 * providers cannot be unregistered even though they have no probes 	 * enabled because of an execution of dtrace -l or something similar. 	 * If the timeout has been disabled (set to 1 because we're trying 	 * to detach), we set fasttrap_cleanup_work to ensure that we'll 	 * get a chance to do that work if and when the timeout is reenabled 	 * (if detach fails). 	 */
if|if
condition|(
name|later
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|fasttrap_timeout
operator|!=
operator|(
name|timeout_id_t
operator|)
literal|1
condition|)
block|{
name|fasttrap_timeout
operator|=
name|timeout
argument_list|(
operator|&
name|fasttrap_pid_cleanup_cb
argument_list|,
name|NULL
argument_list|,
name|hz
argument_list|)
expr_stmt|;
block|}
name|fasttrap_cleanup_work
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|fasttrap_timeout
operator|=
literal|0
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|in
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Activates the asynchronous cleanup mechanism.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_cleanup
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|fasttrap_cleanup_work
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|fasttrap_timeout
operator|==
literal|0
condition|)
name|fasttrap_timeout
operator|=
name|timeout
argument_list|(
operator|&
name|fasttrap_pid_cleanup_cb
argument_list|,
name|NULL
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called from cfork() via dtrace_fasttrap_fork(). The child  * process's address space is (roughly) a copy of the parent process's so  * we have to remove all the instrumentation we had previously enabled in the  * parent.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_fork
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|proc_t
modifier|*
name|cp
parameter_list|)
block|{
name|pid_t
name|ppid
init|=
name|p
operator|->
name|p_pid
decl_stmt|;
name|int
name|i
decl_stmt|;
name|ASSERT
argument_list|(
name|curproc
operator|==
name|p
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_proc_flag
operator|&
name|P_PR_LOCK
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_dtrace_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|cp
operator|->
name|p_dtrace_count
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * This would be simpler and faster if we maintained per-process 	 * hash tables of enabled tracepoints. It could, however, potentially 	 * slow down execution of a tracepoint since we'd need to go 	 * through two levels of indirection. In the future, we should 	 * consider either maintaining per-process ancillary lists of 	 * enabled tracepoints or hanging a pointer to a per-process hash 	 * table of enabled tracepoints off the proc structure. 	 */
comment|/* 	 * We don't have to worry about the child process disappearing 	 * because we're in fork(). 	 */
name|mutex_enter
argument_list|(
operator|&
name|cp
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprlock_proc
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|cp
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over every tracepoint looking for ones that belong to the 	 * parent process, and remove each from the child process. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_tpoints
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
block|{
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
init|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|i
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|ftt_pid
operator|==
name|ppid
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
block|{
name|int
name|ret
init|=
name|fasttrap_tracepoint_remove
argument_list|(
name|cp
argument_list|,
name|tp
argument_list|)
decl_stmt|;
name|ASSERT
argument_list|(
name|ret
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 				 * The count of active providers can only be 				 * decremented (i.e. to zero) during exec, 				 * exit, and removal of a meta provider so it 				 * should be impossible to drop the count 				 * mid-fork. 				 */
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|cp
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprunlock
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * This is called from proc_exit() or from exec_common() if p_dtrace_probes  * is set on the proc structure to indicate that there is a pid provider  * associated with this process.  */
end_comment

begin_function
specifier|static
name|void
name|fasttrap_exec_exit
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|p
operator|==
name|curproc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We clean up the pid provider for this process here; user-land 	 * static probes are handled by the meta-provider remove entry point. 	 */
name|fasttrap_provider_retire
argument_list|(
name|p
operator|->
name|p_pid
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_provide
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
specifier|const
name|dtrace_probedesc_t
modifier|*
name|desc
parameter_list|)
block|{
comment|/* 	 * There are no "default" pid probes. 	 */
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_tracepoint_enable
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|uint_t
name|index
parameter_list|)
block|{
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|,
modifier|*
name|new_tp
init|=
name|NULL
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|uintptr_t
name|pc
decl_stmt|;
name|ASSERT
argument_list|(
name|index
operator|<
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|pid
operator|=
name|probe
operator|->
name|ftp_pid
expr_stmt|;
name|pc
operator|=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pc
expr_stmt|;
name|id
operator|=
operator|&
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_id
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pid
operator|==
name|pid
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
operator|)
argument_list|)
expr_stmt|;
comment|/* 	 * Before we make any modifications, make sure we've imposed a barrier 	 * on the generation in which this probe was last modified. 	 */
name|fasttrap_mod_barrier
argument_list|(
name|probe
operator|->
name|ftp_gen
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
comment|/* 	 * If the tracepoint has already been enabled, just add our id to the 	 * list of interested probes. This may be our second time through 	 * this path in which case we'll have constructed the tracepoint we'd 	 * like to install. If we can't find a match, and have an allocated 	 * tracepoint ready to go, enable that one now. 	 * 	 * A tracepoint whose process is defunct is also considered defunct. 	 */
name|again
label|:
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
comment|/* 		 * Note that it's safe to access the active count on the 		 * associated proc structure because we know that at least one 		 * provider (this one) will still be around throughout this 		 * operation. 		 */
if|if
condition|(
name|tp
operator|->
name|ftt_pid
operator|!=
name|pid
operator|||
name|tp
operator|->
name|ftt_pc
operator|!=
name|pc
operator|||
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|==
literal|0
condition|)
continue|continue;
comment|/* 		 * Now that we've found a matching tracepoint, it would be 		 * a decent idea to confirm that the tracepoint is still 		 * enabled and the trap instruction hasn't been overwritten. 		 * Since this is a little hairy, we'll punt for now. 		 */
comment|/* 		 * This can't be the first interested probe. We don't have 		 * to worry about another thread being in the midst of 		 * deleting this tracepoint (which would be the only valid 		 * reason for a tracepoint to have no interested probes) 		 * since we're holding P_PR_LOCK for this process. 		 */
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
operator|||
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|fti_ptype
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
case|case
name|DTFTP_OFFSETS
case|:
case|case
name|DTFTP_IS_ENABLED
case|:
name|id
operator|->
name|fti_next
operator|=
name|tp
operator|->
name|ftt_ids
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|tp
operator|->
name|ftt_ids
operator|=
name|id
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
case|case
name|DTFTP_POST_OFFSETS
case|:
name|id
operator|->
name|fti_next
operator|=
name|tp
operator|->
name|ftt_retids
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|tp
operator|->
name|ftt_retids
operator|=
name|id
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_tp
operator|!=
name|NULL
condition|)
block|{
name|new_tp
operator|->
name|ftt_ids
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_retids
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * If we have a good tracepoint ready to go, install it now while 	 * we have the lock held and no one can screw with us. 	 */
if|if
condition|(
name|new_tp
operator|!=
name|NULL
condition|)
block|{
name|int
name|rc
init|=
literal|0
decl_stmt|;
name|new_tp
operator|->
name|ftt_next
operator|=
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|bucket
operator|->
name|ftb_data
operator|=
name|new_tp
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Activate the tracepoint in the ISA-specific manner. 		 * If this fails, we need to report the failure, but 		 * indicate that this tracepoint must still be disabled 		 * by calling fasttrap_tracepoint_disable(). 		 */
if|if
condition|(
name|fasttrap_tracepoint_install
argument_list|(
name|p
argument_list|,
name|new_tp
argument_list|)
operator|!=
literal|0
condition|)
name|rc
operator|=
name|FASTTRAP_ENABLE_PARTIAL
expr_stmt|;
comment|/* 		 * Increment the count of the number of tracepoints active in 		 * the victim process. 		 */
name|ASSERT
argument_list|(
name|p
operator|->
name|p_proc_flag
operator|&
name|P_PR_LOCK
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_dtrace_count
operator|++
expr_stmt|;
return|return
operator|(
name|rc
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Initialize the tracepoint that's been preallocated with the probe. 	 */
name|new_tp
operator|=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_pid
operator|==
name|pid
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_pc
operator|==
name|pc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_proc
operator|==
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_proc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_ids
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_tp
operator|->
name|ftt_retids
operator|==
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|fti_ptype
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
case|case
name|DTFTP_OFFSETS
case|:
case|case
name|DTFTP_IS_ENABLED
case|:
name|id
operator|->
name|fti_next
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_ids
operator|=
name|id
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
case|case
name|DTFTP_POST_OFFSETS
case|:
name|id
operator|->
name|fti_next
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_retids
operator|=
name|id
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * If the ISA-dependent initialization goes to plan, go back to the 	 * beginning and try to install this freshly made tracepoint. 	 */
if|if
condition|(
name|fasttrap_tracepoint_init
argument_list|(
name|p
argument_list|,
name|new_tp
argument_list|,
name|pc
argument_list|,
name|id
operator|->
name|fti_ptype
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|again
goto|;
name|new_tp
operator|->
name|ftt_ids
operator|=
name|NULL
expr_stmt|;
name|new_tp
operator|->
name|ftt_retids
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|FASTTRAP_ENABLE_FAIL
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_tracepoint_disable
parameter_list|(
name|proc_t
modifier|*
name|p
parameter_list|,
name|fasttrap_probe_t
modifier|*
name|probe
parameter_list|,
name|uint_t
name|index
parameter_list|)
block|{
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_provider_t
modifier|*
name|provider
init|=
name|probe
operator|->
name|ftp_prov
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
modifier|*
name|pp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
name|fasttrap_id_t
modifier|*
name|id
decl_stmt|,
modifier|*
modifier|*
name|idp
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|uintptr_t
name|pc
decl_stmt|;
name|ASSERT
argument_list|(
name|index
operator|<
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|pid
operator|=
name|probe
operator|->
name|ftp_pid
expr_stmt|;
name|pc
operator|=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pc
expr_stmt|;
name|id
operator|=
operator|&
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_id
expr_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|->
name|ftt_pid
operator|==
name|pid
argument_list|)
expr_stmt|;
comment|/* 	 * Find the tracepoint and make sure that our id is one of the 	 * ones registered with it. 	 */
name|bucket
operator|=
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|pid
argument_list|,
name|pc
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|tp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|tp
operator|!=
name|NULL
condition|;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
control|)
block|{
if|if
condition|(
name|tp
operator|->
name|ftt_pid
operator|==
name|pid
operator|&&
name|tp
operator|->
name|ftt_pc
operator|==
name|pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|==
name|provider
operator|->
name|ftp_proc
condition|)
break|break;
block|}
comment|/* 	 * If we somehow lost this tracepoint, we're in a world of hurt. 	 */
name|ASSERT
argument_list|(
name|tp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|id
operator|->
name|fti_ptype
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
case|case
name|DTFTP_OFFSETS
case|:
case|case
name|DTFTP_IS_ENABLED
case|:
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|idp
operator|=
operator|&
name|tp
operator|->
name|ftt_ids
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
case|case
name|DTFTP_POST_OFFSETS
case|:
name|ASSERT
argument_list|(
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|idp
operator|=
operator|&
name|tp
operator|->
name|ftt_retids
expr_stmt|;
break|break;
default|default:
name|ASSERT
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|*
name|idp
operator|)
operator|->
name|fti_probe
operator|!=
name|probe
condition|)
block|{
name|idp
operator|=
operator|&
operator|(
operator|*
name|idp
operator|)
operator|->
name|fti_next
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|idp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
name|id
operator|=
operator|*
name|idp
expr_stmt|;
operator|*
name|idp
operator|=
name|id
operator|->
name|fti_next
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|->
name|fti_probe
operator|==
name|probe
argument_list|)
expr_stmt|;
comment|/* 	 * If there are other registered enablings of this tracepoint, we're 	 * all done, but if this was the last probe assocated with this 	 * this tracepoint, we need to remove and free it. 	 */
if|if
condition|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
operator|||
name|tp
operator|->
name|ftt_retids
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If the current probe's tracepoint is in use, swap it 		 * for an unused tracepoint. 		 */
if|if
condition|(
name|tp
operator|==
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
condition|)
block|{
name|fasttrap_probe_t
modifier|*
name|tmp_probe
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
modifier|*
name|tmp_tp
decl_stmt|;
name|uint_t
name|tmp_index
decl_stmt|;
if|if
condition|(
name|tp
operator|->
name|ftt_ids
operator|!=
name|NULL
condition|)
block|{
name|tmp_probe
operator|=
name|tp
operator|->
name|ftt_ids
operator|->
name|fti_probe
expr_stmt|;
comment|/* LINTED - alignment */
name|tmp_index
operator|=
name|FASTTRAP_ID_INDEX
argument_list|(
name|tp
operator|->
name|ftt_ids
argument_list|)
expr_stmt|;
name|tmp_tp
operator|=
operator|&
name|tmp_probe
operator|->
name|ftp_tps
index|[
name|tmp_index
index|]
operator|.
name|fit_tp
expr_stmt|;
block|}
else|else
block|{
name|tmp_probe
operator|=
name|tp
operator|->
name|ftt_retids
operator|->
name|fti_probe
expr_stmt|;
comment|/* LINTED - alignment */
name|tmp_index
operator|=
name|FASTTRAP_ID_INDEX
argument_list|(
name|tp
operator|->
name|ftt_retids
argument_list|)
expr_stmt|;
name|tmp_tp
operator|=
operator|&
name|tmp_probe
operator|->
name|ftp_tps
index|[
name|tmp_index
index|]
operator|.
name|fit_tp
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|*
name|tmp_tp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|tmp_tp
operator|!=
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|*
name|tmp_tp
operator|)
operator|->
name|ftt_ids
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|(
operator|*
name|tmp_tp
operator|)
operator|->
name|ftt_retids
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|probe
operator|->
name|ftp_tps
index|[
name|index
index|]
operator|.
name|fit_tp
operator|=
operator|*
name|tmp_tp
expr_stmt|;
operator|*
name|tmp_tp
operator|=
name|tp
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 		 * Tag the modified probe with the generation in which it was 		 * changed. 		 */
name|probe
operator|->
name|ftp_gen
operator|=
name|fasttrap_mod_gen
expr_stmt|;
return|return;
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * We can't safely remove the tracepoint from the set of active 	 * tracepoints until we've actually removed the fasttrap instruction 	 * from the process's text. We can, however, operate on this 	 * tracepoint secure in the knowledge that no other thread is going to 	 * be looking at it since we hold P_PR_LOCK on the process if it's 	 * live or we hold the provider lock on the process if it's dead and 	 * gone. 	 */
comment|/* 	 * We only need to remove the actual instruction if we're looking 	 * at an existing process 	 */
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * If we fail to restore the instruction we need to kill 		 * this process since it's in a completely unrecoverable 		 * state. 		 */
if|if
condition|(
name|fasttrap_tracepoint_remove
argument_list|(
name|p
argument_list|,
name|tp
argument_list|)
operator|!=
literal|0
condition|)
name|fasttrap_sigtrap
argument_list|(
name|p
argument_list|,
name|NULL
argument_list|,
name|pc
argument_list|)
expr_stmt|;
comment|/* 		 * Decrement the count of the number of tracepoints active 		 * in the victim process. 		 */
name|ASSERT
argument_list|(
name|p
operator|->
name|p_proc_flag
operator|&
name|P_PR_LOCK
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_dtrace_count
operator|--
expr_stmt|;
block|}
comment|/* 	 * Remove the probe from the hash table of active tracepoints. 	 */
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|pp
operator|=
operator|(
name|fasttrap_tracepoint_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|pp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|tp
condition|)
block|{
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|ftt_next
expr_stmt|;
name|ASSERT
argument_list|(
operator|*
name|pp
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
operator|*
name|pp
operator|=
name|tp
operator|->
name|ftt_next
expr_stmt|;
name|membar_producer
argument_list|()
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Tag the modified probe with the generation in which it was changed. 	 */
name|probe
operator|->
name|ftp_gen
operator|=
name|fasttrap_mod_gen
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_enable_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* 	 * We don't have to play the rw lock game here because we're 	 * providing something rather than taking something away -- 	 * we can be sure that no threads have tried to follow this 	 * function pointer yet. 	 */
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_pid_count
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|dtrace_pid_probe_ptr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_return_probe_ptr
operator|==
name|NULL
argument_list|)
expr_stmt|;
name|dtrace_pid_probe_ptr
operator|=
operator|&
name|fasttrap_pid_probe
expr_stmt|;
name|dtrace_return_probe_ptr
operator|=
operator|&
name|fasttrap_return_probe
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|dtrace_pid_probe_ptr
operator|==
operator|&
name|fasttrap_pid_probe
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_return_probe_ptr
operator|==
operator|&
name|fasttrap_return_probe
argument_list|)
expr_stmt|;
name|fasttrap_pid_count
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_disable_callbacks
parameter_list|(
name|void
parameter_list|)
block|{
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_pid_count
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_pid_count
operator|--
expr_stmt|;
if|if
condition|(
name|fasttrap_pid_count
operator|==
literal|0
condition|)
block|{
name|cpu_t
modifier|*
name|cur
decl_stmt|,
modifier|*
name|cpu
init|=
name|CPU
decl_stmt|;
for|for
control|(
name|cur
operator|=
name|cpu
operator|->
name|cpu_next_onln
init|;
name|cur
operator|!=
name|cpu
condition|;
name|cur
operator|=
name|cur
operator|->
name|cpu_next_onln
control|)
block|{
name|rw_enter
argument_list|(
operator|&
name|cur
operator|->
name|cpu_ft_lock
argument_list|,
name|RW_WRITER
argument_list|)
expr_stmt|;
block|}
name|dtrace_pid_probe_ptr
operator|=
name|NULL
expr_stmt|;
name|dtrace_return_probe_ptr
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cur
operator|=
name|cpu
operator|->
name|cpu_next_onln
init|;
name|cur
operator|!=
name|cpu
condition|;
name|cur
operator|=
name|cur
operator|->
name|cpu_next_onln
control|)
block|{
name|rw_exit
argument_list|(
operator|&
name|cur
operator|->
name|cpu_ft_lock
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fasttrap_pid_enable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|rc
decl_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|probe
operator|->
name|ftp_enabled
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|id
operator|==
name|probe
operator|->
name|ftp_id
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Increment the count of enabled probes on this probe's provider; 	 * the provider can't go away while the probe still exists. We 	 * must increment this even if we aren't able to properly enable 	 * this probe. 	 */
name|mutex_enter
argument_list|(
operator|&
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_rcount
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * If this probe's provider is retired (meaning it was valid in a 	 * previously exec'ed incarnation of this address space), bail out. The 	 * provider can't go away while we're in this code path. 	 */
if|if
condition|(
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_retired
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* 	 * If we can't find the process, it may be that we're in the context of 	 * a fork in which the traced process is being born and we're copying 	 * USDT probes. Otherwise, the process is gone so bail. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|sprlock
argument_list|(
name|probe
operator|->
name|ftp_pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|curproc
operator|->
name|p_flag
operator|&
name|SFORKING
operator|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
name|p
operator|=
name|prfind
argument_list|(
name|probe
operator|->
name|ftp_pid
argument_list|)
expr_stmt|;
comment|/* 		 * Confirm that curproc is indeed forking the process in which 		 * we're trying to enable probes. 		 */
name|ASSERT
argument_list|(
name|p
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_parent
operator|==
name|curproc
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|p
operator|->
name|p_stat
operator|==
name|SIDL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
name|sprlock_proc
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|ASSERT
argument_list|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
operator|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
comment|/* 	 * We have to enable the trap entry point before any user threads have 	 * the chance to execute the trap instruction we're about to place 	 * in their process's text. 	 */
name|fasttrap_enable_callbacks
argument_list|()
expr_stmt|;
comment|/* 	 * Enable all the tracepoints and add this probe's id to each 	 * tracepoint's list of active probes. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|probe
operator|->
name|ftp_ntps
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|rc
operator|=
name|fasttrap_tracepoint_enable
argument_list|(
name|p
argument_list|,
name|probe
argument_list|,
name|i
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
comment|/* 			 * If enabling the tracepoint failed completely, 			 * we don't have to disable it; if the failure 			 * was only partial we must disable it. 			 */
if|if
condition|(
name|rc
operator|==
name|FASTTRAP_ENABLE_FAIL
condition|)
name|i
operator|--
expr_stmt|;
else|else
name|ASSERT
argument_list|(
name|rc
operator|==
name|FASTTRAP_ENABLE_PARTIAL
argument_list|)
expr_stmt|;
comment|/* 			 * Back up and pull out all the tracepoints we've 			 * created so far for this probe. 			 */
while|while
condition|(
name|i
operator|>=
literal|0
condition|)
block|{
name|fasttrap_tracepoint_disable
argument_list|(
name|p
argument_list|,
name|probe
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprunlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* 			 * Since we're not actually enabling this probe, 			 * drop our reference on the trap table entry. 			 */
name|fasttrap_disable_callbacks
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprunlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|probe
operator|->
name|ftp_enabled
operator|=
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_disable
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|fasttrap_provider_t
modifier|*
name|provider
init|=
name|probe
operator|->
name|ftp_prov
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|,
name|whack
init|=
literal|0
decl_stmt|;
name|ASSERT
argument_list|(
name|id
operator|==
name|probe
operator|->
name|ftp_id
argument_list|)
expr_stmt|;
comment|/* 	 * We won't be able to acquire a /proc-esque lock on the process 	 * iff the process is dead and gone. In this case, we rely on the 	 * provider lock as a point of mutual exclusion to prevent other 	 * DTrace consumers from disabling this probe. 	 */
if|if
condition|(
operator|(
name|p
operator|=
name|sprlock
argument_list|(
name|probe
operator|->
name|ftp_pid
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|ASSERT
argument_list|(
operator|!
operator|(
name|p
operator|->
name|p_flag
operator|&
name|SVFORK
operator|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Disable all the associated tracepoints (for fully enabled probes). 	 */
if|if
condition|(
name|probe
operator|->
name|ftp_enabled
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|probe
operator|->
name|ftp_ntps
condition|;
name|i
operator|++
control|)
block|{
name|fasttrap_tracepoint_disable
argument_list|(
name|p
argument_list|,
name|probe
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
block|}
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_rcount
operator|>
literal|0
argument_list|)
expr_stmt|;
name|provider
operator|->
name|ftp_rcount
operator|--
expr_stmt|;
if|if
condition|(
name|p
operator|!=
name|NULL
condition|)
block|{
comment|/* 		 * Even though we may not be able to remove it entirely, we 		 * mark this retired provider to get a chance to remove some 		 * of the associated probes. 		 */
if|if
condition|(
name|provider
operator|->
name|ftp_retired
operator|&&
operator|!
name|provider
operator|->
name|ftp_marked
condition|)
name|whack
operator|=
name|provider
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|sprunlock
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * If the process is dead, we're just waiting for the 		 * last probe to be disabled to be able to free it. 		 */
if|if
condition|(
name|provider
operator|->
name|ftp_rcount
operator|==
literal|0
operator|&&
operator|!
name|provider
operator|->
name|ftp_marked
condition|)
name|whack
operator|=
name|provider
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|whack
condition|)
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|probe
operator|->
name|ftp_enabled
condition|)
return|return;
name|probe
operator|->
name|ftp_enabled
operator|=
literal|0
expr_stmt|;
name|ASSERT
argument_list|(
name|MUTEX_HELD
argument_list|(
operator|&
name|cpu_lock
argument_list|)
argument_list|)
expr_stmt|;
name|fasttrap_disable_callbacks
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_getargdesc
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|dtrace_argdesc_t
modifier|*
name|desc
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|i
decl_stmt|,
name|ndx
decl_stmt|;
name|desc
operator|->
name|dtargd_native
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|desc
operator|->
name|dtargd_xlate
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|ftp_prov
operator|->
name|ftp_retired
operator|!=
literal|0
operator|||
name|desc
operator|->
name|dtargd_ndx
operator|>=
name|probe
operator|->
name|ftp_nargs
condition|)
block|{
name|desc
operator|->
name|dtargd_ndx
operator|=
name|DTRACE_ARGNONE
expr_stmt|;
return|return;
block|}
name|ndx
operator|=
operator|(
name|probe
operator|->
name|ftp_argmap
operator|!=
name|NULL
operator|)
condition|?
name|probe
operator|->
name|ftp_argmap
index|[
name|desc
operator|->
name|dtargd_ndx
index|]
else|:
name|desc
operator|->
name|dtargd_ndx
expr_stmt|;
name|str
operator|=
name|probe
operator|->
name|ftp_ntypes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ndx
condition|;
name|i
operator|++
control|)
block|{
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|str
operator|+
literal|1
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
operator|->
name|dtargd_native
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|ftp_xtypes
operator|==
name|NULL
condition|)
return|return;
name|str
operator|=
name|probe
operator|->
name|ftp_xtypes
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|desc
operator|->
name|dtargd_ndx
condition|;
name|i
operator|++
control|)
block|{
name|str
operator|+=
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|str
operator|+
literal|1
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|desc
operator|->
name|dtargd_xlate
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|desc
operator|->
name|dtargd_xlate
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_pid_destroy
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_id_t
name|id
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|)
block|{
name|fasttrap_probe_t
modifier|*
name|probe
init|=
name|parg
decl_stmt|;
name|int
name|i
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|ASSERT
argument_list|(
name|probe
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|probe
operator|->
name|ftp_enabled
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_total
operator|>=
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|probe
operator|->
name|ftp_ntps
argument_list|)
expr_stmt|;
name|size
operator|=
name|offsetof
argument_list|(
name|fasttrap_probe_t
argument_list|,
name|ftp_tps
index|[
name|probe
operator|->
name|ftp_ntps
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|probe
operator|->
name|ftp_gen
operator|+
literal|1
operator|>=
name|fasttrap_mod_gen
condition|)
name|fasttrap_mod_barrier
argument_list|(
name|probe
operator|->
name|ftp_gen
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|probe
operator|->
name|ftp_ntps
condition|;
name|i
operator|++
control|)
block|{
name|kmem_free
argument_list|(
name|probe
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|kmem_free
argument_list|(
name|probe
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|dtrace_pattr_t
name|pid_attr
init|=
block|{
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_ISA
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|,
block|{
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_STABILITY_EVOLVING
block|,
name|DTRACE_CLASS_ISA
block|}
block|,
block|{
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_STABILITY_PRIVATE
block|,
name|DTRACE_CLASS_UNKNOWN
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|pid_pops
init|=
block|{
name|fasttrap_pid_provide
block|,
name|NULL
block|,
name|fasttrap_pid_enable
block|,
name|fasttrap_pid_disable
block|,
name|NULL
block|,
name|NULL
block|,
name|fasttrap_pid_getargdesc
block|,
name|fasttrap_pid_getarg
block|,
name|NULL
block|,
name|fasttrap_pid_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|dtrace_pops_t
name|usdt_pops
init|=
block|{
name|fasttrap_pid_provide
block|,
name|NULL
block|,
name|fasttrap_pid_enable
block|,
name|fasttrap_pid_disable
block|,
name|NULL
block|,
name|NULL
block|,
name|fasttrap_pid_getargdesc
block|,
name|fasttrap_usdt_getarg
block|,
name|NULL
block|,
name|fasttrap_pid_destroy
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|fasttrap_proc_t
modifier|*
name|fasttrap_proc_lookup
parameter_list|(
name|pid_t
name|pid
parameter_list|)
block|{
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_proc_t
modifier|*
name|fprc
decl_stmt|,
modifier|*
name|new_fprc
decl_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_procs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROCS_INDEX
argument_list|(
name|pid
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|fprc
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fprc
operator|!=
name|NULL
condition|;
name|fprc
operator|=
name|fprc
operator|->
name|ftpc_next
control|)
block|{
if|if
condition|(
name|fprc
operator|->
name|ftpc_pid
operator|==
name|pid
operator|&&
name|fprc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fprc
operator|->
name|ftpc_rcount
operator|++
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_acount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fprc
operator|->
name|ftpc_acount
operator|<=
name|fprc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|fprc
operator|)
return|;
block|}
block|}
comment|/* 	 * Drop the bucket lock so we don't try to perform a sleeping 	 * allocation under it. 	 */
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|new_fprc
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_proc_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new_fprc
operator|->
name|ftpc_pid
operator|=
name|pid
expr_stmt|;
name|new_fprc
operator|->
name|ftpc_rcount
operator|=
literal|1
expr_stmt|;
name|new_fprc
operator|->
name|ftpc_acount
operator|=
literal|1
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take another lap through the list to make sure a proc hasn't 	 * been created for this pid while we weren't under the bucket lock. 	 */
for|for
control|(
name|fprc
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fprc
operator|!=
name|NULL
condition|;
name|fprc
operator|=
name|fprc
operator|->
name|ftpc_next
control|)
block|{
if|if
condition|(
name|fprc
operator|->
name|ftpc_pid
operator|==
name|pid
operator|&&
name|fprc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fprc
operator|->
name|ftpc_rcount
operator|++
expr_stmt|;
name|atomic_inc_64
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_acount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fprc
operator|->
name|ftpc_acount
operator|<=
name|fprc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fprc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|new_fprc
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_proc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|fprc
operator|)
return|;
block|}
block|}
name|new_fprc
operator|->
name|ftpc_next
operator|=
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|bucket
operator|->
name|ftb_data
operator|=
name|new_fprc
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_fprc
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_proc_release
parameter_list|(
name|fasttrap_proc_t
modifier|*
name|proc
parameter_list|)
block|{
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|fasttrap_proc_t
modifier|*
name|fprc
decl_stmt|,
modifier|*
modifier|*
name|fprcp
decl_stmt|;
name|pid_t
name|pid
init|=
name|proc
operator|->
name|ftpc_pid
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|proc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|proc
operator|->
name|ftpc_rcount
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|proc
operator|->
name|ftpc_acount
operator|<=
name|proc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
if|if
condition|(
operator|--
name|proc
operator|->
name|ftpc_rcount
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|proc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_exit
argument_list|(
operator|&
name|proc
operator|->
name|ftpc_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * There should definitely be no live providers associated with this 	 * process at this point. 	 */
name|ASSERT
argument_list|(
name|proc
operator|->
name|ftpc_acount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_procs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROCS_INDEX
argument_list|(
name|pid
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fprcp
operator|=
operator|(
name|fasttrap_proc_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
while|while
condition|(
operator|(
name|fprc
operator|=
operator|*
name|fprcp
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|fprc
operator|==
name|proc
condition|)
break|break;
name|fprcp
operator|=
operator|&
name|fprc
operator|->
name|ftpc_next
expr_stmt|;
block|}
comment|/* 	 * Something strange has happened if we can't find the proc. 	 */
name|ASSERT
argument_list|(
name|fprc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
operator|*
name|fprcp
operator|=
name|fprc
operator|->
name|ftpc_next
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|fprc
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_proc_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Lookup a fasttrap-managed provider based on its name and associated pid.  * If the pattr argument is non-NULL, this function instantiates the provider  * if it doesn't exist otherwise it returns NULL. The provider is returned  * with its lock held.  */
end_comment

begin_function
specifier|static
name|fasttrap_provider_t
modifier|*
name|fasttrap_provider_lookup
parameter_list|(
name|pid_t
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|dtrace_pattr_t
modifier|*
name|pattr
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|fp
decl_stmt|,
modifier|*
name|new_fp
init|=
name|NULL
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|char
name|provname
index|[
name|DTRACE_PROVNAMELEN
index|]
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
name|cred_t
modifier|*
name|cred
decl_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|)
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|pattr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROVS_INDEX
argument_list|(
name|pid
argument_list|,
name|name
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take a lap through the list and return the match if we find it. 	 */
for|for
control|(
name|fp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|ftp_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftp_pid
operator|==
name|pid
operator|&&
name|strcmp
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|fp
operator|->
name|ftp_retired
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
block|}
comment|/* 	 * Drop the bucket lock so we don't try to perform a sleeping 	 * allocation under it. 	 */
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the process exists, isn't a child created as the result 	 * of a vfork(2), and isn't a zombie (but may be in fork). 	 */
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|prfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|p_flag
operator|&
operator|(
name|SVFORK
operator||
name|SEXITING
operator|)
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Increment p_dtrace_probes so that the process knows to inform us 	 * when it exits or execs. fasttrap_provider_free() decrements this 	 * when we're done with this provider. 	 */
name|p
operator|->
name|p_dtrace_probes
operator|++
expr_stmt|;
comment|/* 	 * Grab the credentials for this process so we have 	 * something to pass to dtrace_register(). 	 */
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_crlock
argument_list|)
expr_stmt|;
name|crhold
argument_list|(
name|p
operator|->
name|p_cred
argument_list|)
expr_stmt|;
name|cred
operator|=
name|p
operator|->
name|p_cred
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_crlock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|new_fp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_provider_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|new_fp
operator|->
name|ftp_pid
operator|=
name|pid
expr_stmt|;
name|new_fp
operator|->
name|ftp_proc
operator|=
name|fasttrap_proc_lookup
argument_list|(
name|pid
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|new_fp
operator|->
name|ftp_proc
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Take another lap through the list to make sure a provider hasn't 	 * been created for this pid while we weren't under the bucket lock. 	 */
for|for
control|(
name|fp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|ftp_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftp_pid
operator|==
name|pid
operator|&&
name|strcmp
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|fp
operator|->
name|ftp_retired
condition|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|new_fp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|fp
operator|)
return|;
block|}
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|new_fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
expr_stmt|;
comment|/* 	 * Fail and return NULL if either the provider name is too long 	 * or we fail to register this new provider with the DTrace 	 * framework. Note that this is the only place we ever construct 	 * the full provider name -- we keep it in pieces in the provider 	 * structure. 	 */
if|if
condition|(
name|snprintf
argument_list|(
name|provname
argument_list|,
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
argument_list|,
literal|"%s%u"
argument_list|,
name|name
argument_list|,
operator|(
name|uint_t
operator|)
name|pid
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|provname
argument_list|)
operator|||
name|dtrace_register
argument_list|(
name|provname
argument_list|,
name|pattr
argument_list|,
name|DTRACE_PRIV_PROC
operator||
name|DTRACE_PRIV_OWNER
operator||
name|DTRACE_PRIV_ZONEOWNER
argument_list|,
name|cred
argument_list|,
name|pattr
operator|==
operator|&
name|pid_attr
condition|?
operator|&
name|pid_pops
else|:
operator|&
name|usdt_pops
argument_list|,
name|new_fp
argument_list|,
operator|&
name|new_fp
operator|->
name|ftp_provid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|new_fp
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|new_fp
operator|->
name|ftp_next
operator|=
name|bucket
operator|->
name|ftb_data
expr_stmt|;
name|bucket
operator|->
name|ftb_data
operator|=
name|new_fp
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|new_fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|crfree
argument_list|(
name|cred
argument_list|)
expr_stmt|;
return|return
operator|(
name|new_fp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_provider_free
parameter_list|(
name|fasttrap_provider_t
modifier|*
name|provider
parameter_list|)
block|{
name|pid_t
name|pid
init|=
name|provider
operator|->
name|ftp_pid
decl_stmt|;
name|proc_t
modifier|*
name|p
decl_stmt|;
comment|/* 	 * There need to be no associated enabled probes, no consumers 	 * creating probes, and no meta providers referencing this provider. 	 */
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_rcount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_ccount
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_mcount
operator|==
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * If this provider hasn't been retired, we need to explicitly drop the 	 * count of active providers on the associated process structure. 	 */
if|if
condition|(
operator|!
name|provider
operator|->
name|ftp_retired
condition|)
block|{
name|atomic_dec_64
argument_list|(
operator|&
name|provider
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
operator|<
name|provider
operator|->
name|ftp_proc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
block|}
name|fasttrap_proc_release
argument_list|(
name|provider
operator|->
name|ftp_proc
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|provider
argument_list|,
sizeof|sizeof
argument_list|(
name|fasttrap_provider_t
argument_list|)
argument_list|)
expr_stmt|;
comment|/* 	 * Decrement p_dtrace_probes on the process whose provider we're 	 * freeing. We don't have to worry about clobbering somone else's 	 * modifications to it because we have locked the bucket that 	 * corresponds to this process's hash chain in the provider hash 	 * table. Don't sweat it if we can't find the process. 	 */
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|prfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
name|p
operator|->
name|p_dtrace_probes
operator|--
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|fasttrap_provider_retire
parameter_list|(
name|pid_t
name|pid
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|mprov
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|fp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
decl_stmt|;
name|dtrace_provider_id_t
name|provid
decl_stmt|;
name|ASSERT
argument_list|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|)
argument_list|)
expr_stmt|;
name|bucket
operator|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|FASTTRAP_PROVS_INDEX
argument_list|(
name|pid
argument_list|,
name|name
argument_list|)
index|]
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
for|for
control|(
name|fp
operator|=
name|bucket
operator|->
name|ftb_data
init|;
name|fp
operator|!=
name|NULL
condition|;
name|fp
operator|=
name|fp
operator|->
name|ftp_next
control|)
block|{
if|if
condition|(
name|fp
operator|->
name|ftp_pid
operator|==
name|pid
operator|&&
name|strcmp
argument_list|(
name|fp
operator|->
name|ftp_name
argument_list|,
name|name
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|fp
operator|->
name|ftp_retired
condition|)
break|break;
block|}
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
operator|!
name|mprov
operator|||
name|fp
operator|->
name|ftp_mcount
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|mprov
operator|&&
operator|--
name|fp
operator|->
name|ftp_mcount
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Mark the provider to be removed in our post-processing step, mark it 	 * retired, and drop the active count on its proc. Marking it indicates 	 * that we should try to remove it; setting the retired flag indicates 	 * that we're done with this provider; dropping the active the proc 	 * releases our hold, and when this reaches zero (as it will during 	 * exit or exec) the proc and associated providers become defunct. 	 * 	 * We obviously need to take the bucket lock before the provider lock 	 * to perform the lookup, but we need to drop the provider lock 	 * before calling into the DTrace framework since we acquire the 	 * provider lock in callbacks invoked from the DTrace framework. The 	 * bucket lock therefore protects the integrity of the provider hash 	 * table. 	 */
name|atomic_dec_64
argument_list|(
operator|&
name|fp
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fp
operator|->
name|ftp_proc
operator|->
name|ftpc_acount
operator|<
name|fp
operator|->
name|ftp_proc
operator|->
name|ftpc_rcount
argument_list|)
expr_stmt|;
name|fp
operator|->
name|ftp_retired
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|provid
operator|=
name|fp
operator|->
name|ftp_provid
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * We don't have to worry about invalidating the same provider twice 	 * since fasttrap_provider_lookup() will ignore provider that have 	 * been marked as retired. 	 */
name|dtrace_invalidate
argument_list|(
name|provid
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_uint32_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|ap
operator|-
operator|*
operator|(
specifier|const
name|uint32_t
operator|*
operator|)
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_uint64_cmp
parameter_list|(
specifier|const
name|void
modifier|*
name|ap
parameter_list|,
specifier|const
name|void
modifier|*
name|bp
parameter_list|)
block|{
return|return
operator|(
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|ap
operator|-
operator|*
operator|(
specifier|const
name|uint64_t
operator|*
operator|)
name|bp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_add_probe
parameter_list|(
name|fasttrap_probe_spec_t
modifier|*
name|pdata
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|provider
decl_stmt|;
name|fasttrap_probe_t
modifier|*
name|pp
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|aframes
decl_stmt|,
name|whack
decl_stmt|;
comment|/* 	 * There needs to be at least one desired trace point. 	 */
if|if
condition|(
name|pdata
operator|->
name|ftps_noffs
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
switch|switch
condition|(
name|pdata
operator|->
name|ftps_type
condition|)
block|{
case|case
name|DTFTP_ENTRY
case|:
name|name
operator|=
literal|"entry"
expr_stmt|;
name|aframes
operator|=
name|FASTTRAP_ENTRY_AFRAMES
expr_stmt|;
break|break;
case|case
name|DTFTP_RETURN
case|:
name|name
operator|=
literal|"return"
expr_stmt|;
name|aframes
operator|=
name|FASTTRAP_RETURN_AFRAMES
expr_stmt|;
break|break;
case|case
name|DTFTP_OFFSETS
case|:
name|name
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|provider
operator|=
name|fasttrap_provider_lookup
argument_list|(
name|pdata
operator|->
name|ftps_pid
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|,
operator|&
name|pid_attr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|ESRCH
operator|)
return|;
comment|/* 	 * Increment this reference count to indicate that a consumer is 	 * actively adding a new probe associated with this provider. This 	 * prevents the provider from being deleted -- we'll need to check 	 * for pending deletions when we drop this reference count. 	 */
name|provider
operator|->
name|ftp_ccount
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Grab the creation lock to ensure consistency between calls to 	 * dtrace_probe_lookup() and dtrace_probe_create() in the face of 	 * other threads creating probes. We must drop the provider lock 	 * before taking this lock to avoid a three-way deadlock with the 	 * DTrace framework. 	 */
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
operator|==
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdata
operator|->
name|ftps_noffs
condition|;
name|i
operator|++
control|)
block|{
name|char
name|name_str
index|[
literal|17
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|name_str
argument_list|,
literal|"%llx"
argument_list|,
operator|(
name|unsigned
name|long
name|long
operator|)
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name_str
argument_list|)
operator|!=
literal|0
condition|)
continue|continue;
name|atomic_inc_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
condition|)
block|{
name|atomic_dec_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|)
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
name|pp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_probe_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ftp_prov
operator|=
name|provider
expr_stmt|;
name|pp
operator|->
name|ftp_faddr
operator|=
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|pp
operator|->
name|ftp_fsize
operator|=
name|pdata
operator|->
name|ftps_size
expr_stmt|;
name|pp
operator|->
name|ftp_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_ntps
operator|=
literal|1
expr_stmt|;
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
operator|+
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
literal|0
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
literal|0
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
literal|0
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|pdata
operator|->
name|ftps_type
expr_stmt|;
name|pp
operator|->
name|ftp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name_str
argument_list|,
name|FASTTRAP_OFFSET_AFRAMES
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name
argument_list|)
operator|==
literal|0
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
name|pdata
operator|->
name|ftps_noffs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|pdata
operator|->
name|ftps_noffs
argument_list|)
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
comment|/* 		 * Make sure all tracepoint program counter values are unique. 		 * We later assume that each probe has exactly one tracepoint 		 * for a given pc. 		 */
name|qsort
argument_list|(
name|pdata
operator|->
name|ftps_offs
argument_list|,
name|pdata
operator|->
name|ftps_noffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint64_t
argument_list|)
argument_list|,
name|fasttrap_uint64_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|pdata
operator|->
name|ftps_noffs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
operator|>
name|pdata
operator|->
name|ftps_offs
index|[
name|i
operator|-
literal|1
index|]
condition|)
continue|continue;
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|pdata
operator|->
name|ftps_noffs
argument_list|)
expr_stmt|;
goto|goto
name|no_mem
goto|;
block|}
name|ASSERT
argument_list|(
name|pdata
operator|->
name|ftps_noffs
operator|>
literal|0
argument_list|)
expr_stmt|;
name|pp
operator|=
name|kmem_zalloc
argument_list|(
name|offsetof
argument_list|(
name|fasttrap_probe_t
argument_list|,
name|ftp_tps
index|[
name|pdata
operator|->
name|ftps_noffs
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ftp_prov
operator|=
name|provider
expr_stmt|;
name|pp
operator|->
name|ftp_faddr
operator|=
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|pp
operator|->
name|ftp_fsize
operator|=
name|pdata
operator|->
name|ftps_size
expr_stmt|;
name|pp
operator|->
name|ftp_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_ntps
operator|=
name|pdata
operator|->
name|ftps_noffs
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pdata
operator|->
name|ftps_noffs
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|pdata
operator|->
name|ftps_offs
index|[
name|i
index|]
operator|+
name|pdata
operator|->
name|ftps_pc
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|pdata
operator|->
name|ftps_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|pdata
operator|->
name|ftps_type
expr_stmt|;
block|}
name|pp
operator|->
name|ftp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|pdata
operator|->
name|ftps_mod
argument_list|,
name|pdata
operator|->
name|ftps_func
argument_list|,
name|name
argument_list|,
name|aframes
argument_list|,
name|pp
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
comment|/* 	 * We know that the provider is still valid since we incremented the 	 * creation reference count. If someone tried to clean up this provider 	 * while we were using it (e.g. because the process called exec(2) or 	 * exit(2)), take note of that and try to clean it up now. 	 */
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|provider
operator|->
name|ftp_ccount
operator|--
expr_stmt|;
name|whack
operator|=
name|provider
operator|->
name|ftp_retired
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|whack
condition|)
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|no_mem
label|:
comment|/* 	 * If we've exhausted the allowable resources, we'll try to remove 	 * this provider to free some up. This is to cover the case where 	 * the user has accidentally created many more probes than was 	 * intended (e.g. pid123:::). 	 */
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|provider
operator|->
name|ftp_ccount
operator|--
expr_stmt|;
name|provider
operator|->
name|ftp_marked
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
return|return
operator|(
name|ENOMEM
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
modifier|*
name|fasttrap_meta_provide
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_helper_provdesc_t
modifier|*
name|dhpv
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|provider
decl_stmt|;
comment|/* 	 * A 32-bit unsigned integer (like a pid for example) can be 	 * expressed in 10 or fewer decimal digits. Make sure that we'll 	 * have enough space for the provider name. 	 */
if|if
condition|(
name|strlen
argument_list|(
name|dhpv
operator|->
name|dthpv_provname
argument_list|)
operator|+
literal|10
operator|>=
sizeof|sizeof
argument_list|(
name|provider
operator|->
name|ftp_name
argument_list|)
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to instantiate provider %s: "
literal|"name too long to accomodate pid"
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Don't let folks spoof the true pid provider. 	 */
if|if
condition|(
name|strcmp
argument_list|(
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to instantiate provider %s: "
literal|"%s is an invalid name"
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
name|FASTTRAP_PID_NAME
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * The highest stability class that fasttrap supports is ISA; cap 	 * the stability of the new provider accordingly. 	 */
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_provider
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_provider
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_mod
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_mod
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_func
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_func
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_name
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_name
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_args
operator|.
name|dtat_class
operator|>
name|DTRACE_CLASS_ISA
condition|)
name|dhpv
operator|->
name|dthpv_pattr
operator|.
name|dtpa_args
operator|.
name|dtat_class
operator|=
name|DTRACE_CLASS_ISA
expr_stmt|;
if|if
condition|(
operator|(
name|provider
operator|=
name|fasttrap_provider_lookup
argument_list|(
name|pid
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
operator|&
name|dhpv
operator|->
name|dthpv_pattr
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"failed to instantiate provider %s for "
literal|"process %u"
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
operator|(
name|uint_t
operator|)
name|pid
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	 * Up the meta provider count so this provider isn't removed until 	 * the meta provider has been told to remove it. 	 */
name|provider
operator|->
name|ftp_mcount
operator|++
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|provider
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_meta_create_probe
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
name|parg
parameter_list|,
name|dtrace_helper_probedesc_t
modifier|*
name|dhpb
parameter_list|)
block|{
name|fasttrap_provider_t
modifier|*
name|provider
init|=
name|parg
decl_stmt|;
name|fasttrap_probe_t
modifier|*
name|pp
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|uint32_t
name|ntps
decl_stmt|;
comment|/* 	 * Since the meta provider count is non-zero we don't have to worry 	 * about this provider disappearing. 	 */
name|ASSERT
argument_list|(
name|provider
operator|->
name|ftp_mcount
operator|>
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * The offsets must be unique. 	 */
name|qsort
argument_list|(
name|dhpb
operator|->
name|dthpb_offs
argument_list|,
name|dhpb
operator|->
name|dthpb_noffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|fasttrap_uint32_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_noffs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_offs
index|[
name|i
index|]
operator|<=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_offs
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return;
block|}
name|qsort
argument_list|(
name|dhpb
operator|->
name|dthpb_enoffs
argument_list|,
name|dhpb
operator|->
name|dthpb_nenoffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
argument_list|,
name|fasttrap_uint32_cmp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_nenoffs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_enoffs
index|[
name|i
index|]
operator|<=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_enoffs
index|[
name|i
operator|-
literal|1
index|]
condition|)
return|return;
block|}
comment|/* 	 * Grab the creation lock to ensure consistency between calls to 	 * dtrace_probe_lookup() and dtrace_probe_create() in the face of 	 * other threads creating probes. 	 */
name|mutex_enter
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_probe_lookup
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|dhpb
operator|->
name|dthpb_mod
argument_list|,
name|dhpb
operator|->
name|dthpb_func
argument_list|,
name|dhpb
operator|->
name|dthpb_name
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|ntps
operator|=
name|dhpb
operator|->
name|dthpb_noffs
operator|+
name|dhpb
operator|->
name|dthpb_nenoffs
expr_stmt|;
name|ASSERT
argument_list|(
name|ntps
operator|>
literal|0
argument_list|)
expr_stmt|;
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
name|ntps
argument_list|)
expr_stmt|;
if|if
condition|(
name|fasttrap_total
operator|>
name|fasttrap_max
condition|)
block|{
name|atomic_add_32
argument_list|(
operator|&
name|fasttrap_total
argument_list|,
operator|-
name|ntps
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
return|return;
block|}
name|pp
operator|=
name|kmem_zalloc
argument_list|(
name|offsetof
argument_list|(
name|fasttrap_probe_t
argument_list|,
name|ftp_tps
index|[
name|ntps
index|]
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ftp_prov
operator|=
name|provider
expr_stmt|;
name|pp
operator|->
name|ftp_pid
operator|=
name|provider
operator|->
name|ftp_pid
expr_stmt|;
name|pp
operator|->
name|ftp_ntps
operator|=
name|ntps
expr_stmt|;
name|pp
operator|->
name|ftp_nargs
operator|=
name|dhpb
operator|->
name|dthpb_xargc
expr_stmt|;
name|pp
operator|->
name|ftp_xtypes
operator|=
name|dhpb
operator|->
name|dthpb_xtypes
expr_stmt|;
name|pp
operator|->
name|ftp_ntypes
operator|=
name|dhpb
operator|->
name|dthpb_ntypes
expr_stmt|;
comment|/* 	 * First create a tracepoint for each actual point of interest. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_noffs
condition|;
name|i
operator|++
control|)
block|{
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_offs
index|[
name|i
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|provider
operator|->
name|ftp_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
ifdef|#
directive|ifdef
name|__sparc
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|DTFTP_POST_OFFSETS
expr_stmt|;
else|#
directive|else
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|DTFTP_OFFSETS
expr_stmt|;
endif|#
directive|endif
block|}
comment|/* 	 * Then create a tracepoint for each is-enabled point. 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|ntps
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
block|{
name|tp
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|fasttrap_tracepoint_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|tp
operator|->
name|ftt_proc
operator|=
name|provider
operator|->
name|ftp_proc
expr_stmt|;
name|tp
operator|->
name|ftt_pc
operator|=
name|dhpb
operator|->
name|dthpb_base
operator|+
name|dhpb
operator|->
name|dthpb_enoffs
index|[
name|j
index|]
expr_stmt|;
name|tp
operator|->
name|ftt_pid
operator|=
name|provider
operator|->
name|ftp_pid
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_tp
operator|=
name|tp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_probe
operator|=
name|pp
expr_stmt|;
name|pp
operator|->
name|ftp_tps
index|[
name|i
index|]
operator|.
name|fit_id
operator|.
name|fti_ptype
operator|=
name|DTFTP_IS_ENABLED
expr_stmt|;
block|}
comment|/* 	 * If the arguments are shuffled around we set the argument remapping 	 * table. Later, when the probe fires, we only remap the arguments 	 * if the table is non-NULL. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|dhpb
operator|->
name|dthpb_xargc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|dhpb
operator|->
name|dthpb_args
index|[
name|i
index|]
operator|!=
name|i
condition|)
block|{
name|pp
operator|->
name|ftp_argmap
operator|=
name|dhpb
operator|->
name|dthpb_args
expr_stmt|;
break|break;
block|}
block|}
comment|/* 	 * The probe is fully constructed -- register it with DTrace. 	 */
name|pp
operator|->
name|ftp_id
operator|=
name|dtrace_probe_create
argument_list|(
name|provider
operator|->
name|ftp_provid
argument_list|,
name|dhpb
operator|->
name|dthpb_mod
argument_list|,
name|dhpb
operator|->
name|dthpb_func
argument_list|,
name|dhpb
operator|->
name|dthpb_name
argument_list|,
name|FASTTRAP_OFFSET_AFRAMES
argument_list|,
name|pp
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|provider
operator|->
name|ftp_cmtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fasttrap_meta_remove
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|dtrace_helper_provdesc_t
modifier|*
name|dhpv
parameter_list|,
name|pid_t
name|pid
parameter_list|)
block|{
comment|/* 	 * Clean up the USDT provider. There may be active consumers of the 	 * provider busy adding probes, no damage will actually befall the 	 * provider until that count has dropped to zero. This just puts 	 * the provider on death row. 	 */
name|fasttrap_provider_retire
argument_list|(
name|pid
argument_list|,
name|dhpv
operator|->
name|dthpv_provname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|dtrace_mops_t
name|fasttrap_mops
init|=
block|{
name|fasttrap_meta_create_probe
block|,
name|fasttrap_meta_provide
block|,
name|fasttrap_meta_remove
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fasttrap_open
parameter_list|(
name|dev_t
modifier|*
name|devp
parameter_list|,
name|int
name|flag
parameter_list|,
name|int
name|otyp
parameter_list|,
name|cred_t
modifier|*
name|cred_p
parameter_list|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fasttrap_ioctl
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|int
name|cmd
parameter_list|,
name|intptr_t
name|arg
parameter_list|,
name|int
name|md
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|int
modifier|*
name|rv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|dtrace_attached
argument_list|()
condition|)
return|return
operator|(
name|EAGAIN
operator|)
return|;
if|if
condition|(
name|cmd
operator|==
name|FASTTRAPIOC_MAKEPROBE
condition|)
block|{
name|fasttrap_probe_spec_t
modifier|*
name|uprobe
init|=
operator|(
name|void
operator|*
operator|)
name|arg
decl_stmt|;
name|fasttrap_probe_spec_t
modifier|*
name|probe
decl_stmt|;
name|uint64_t
name|noffs
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|err
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|&
name|uprobe
operator|->
name|ftps_noffs
argument_list|,
operator|&
name|noffs
argument_list|,
sizeof|sizeof
argument_list|(
name|uprobe
operator|->
name|ftps_noffs
argument_list|)
argument_list|)
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
comment|/* 		 * Probes must have at least one tracepoint. 		 */
if|if
condition|(
name|noffs
operator|==
literal|0
condition|)
return|return
operator|(
name|EINVAL
operator|)
return|;
name|size
operator|=
sizeof|sizeof
argument_list|(
name|fasttrap_probe_spec_t
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|probe
operator|->
name|ftps_offs
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|noffs
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|size
operator|>
literal|1024
operator|*
literal|1024
condition|)
return|return
operator|(
name|ENOMEM
operator|)
return|;
name|probe
operator|=
name|kmem_alloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyin
argument_list|(
name|uprobe
argument_list|,
name|probe
argument_list|,
name|size
argument_list|)
operator|!=
literal|0
operator|||
name|probe
operator|->
name|ftps_noffs
operator|!=
name|noffs
condition|)
block|{
name|kmem_free
argument_list|(
name|probe
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
comment|/* 		 * Verify that the function and module strings contain no 		 * funny characters. 		 */
if|if
condition|(
name|u8_validate
argument_list|(
name|probe
operator|->
name|ftps_func
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|ftps_func
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|err
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
name|u8_validate
argument_list|(
name|probe
operator|->
name|ftps_mod
argument_list|,
name|strlen
argument_list|(
name|probe
operator|->
name|ftps_mod
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|U8_VALIDATE_ENTIRE
argument_list|,
operator|&
name|err
argument_list|)
operator|<
literal|0
condition|)
block|{
name|ret
operator|=
name|EINVAL
expr_stmt|;
goto|goto
name|err
goto|;
block|}
if|if
condition|(
operator|!
name|PRIV_POLICY_CHOICE
argument_list|(
name|cr
argument_list|,
name|PRIV_ALL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|proc_t
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
init|=
name|probe
operator|->
name|ftps_pid
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
comment|/* 			 * Report an error if the process doesn't exist 			 * or is actively being birthed. 			 */
if|if
condition|(
operator|(
name|p
operator|=
name|prfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|p_stat
operator|==
name|SIDL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|priv_proc_cred_perm
argument_list|(
name|cr
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|VREAD
operator||
name|VWRITE
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
name|ret
operator|=
name|fasttrap_add_probe
argument_list|(
name|probe
argument_list|)
expr_stmt|;
name|err
label|:
name|kmem_free
argument_list|(
name|probe
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|==
name|FASTTRAPIOC_GETINSTR
condition|)
block|{
name|fasttrap_instr_query_t
name|instr
decl_stmt|;
name|fasttrap_tracepoint_t
modifier|*
name|tp
decl_stmt|;
name|uint_t
name|index
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|copyin
argument_list|(
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
operator|&
name|instr
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
if|if
condition|(
operator|!
name|PRIV_POLICY_CHOICE
argument_list|(
name|cr
argument_list|,
name|PRIV_ALL
argument_list|,
name|B_FALSE
argument_list|)
condition|)
block|{
name|proc_t
modifier|*
name|p
decl_stmt|;
name|pid_t
name|pid
init|=
name|instr
operator|.
name|ftiq_pid
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
comment|/* 			 * Report an error if the process doesn't exist 			 * or is actively being birthed. 			 */
if|if
condition|(
operator|(
name|p
operator|=
name|prfind
argument_list|(
name|pid
argument_list|)
operator|)
operator|==
name|NULL
operator|||
name|p
operator|->
name|p_stat
operator|==
name|SIDL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ESRCH
operator|)
return|;
block|}
name|mutex_enter
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|pidlock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ret
operator|=
name|priv_proc_cred_perm
argument_list|(
name|cr
argument_list|,
name|p
argument_list|,
name|NULL
argument_list|,
name|VREAD
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|p
operator|->
name|p_lock
argument_list|)
expr_stmt|;
block|}
name|index
operator|=
name|FASTTRAP_TPOINTS_INDEX
argument_list|(
name|instr
operator|.
name|ftiq_pid
argument_list|,
name|instr
operator|.
name|ftiq_pc
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
name|tp
operator|=
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_data
expr_stmt|;
while|while
condition|(
name|tp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|instr
operator|.
name|ftiq_pid
operator|==
name|tp
operator|->
name|ftt_pid
operator|&&
name|instr
operator|.
name|ftiq_pc
operator|==
name|tp
operator|->
name|ftt_pc
operator|&&
name|tp
operator|->
name|ftt_proc
operator|->
name|ftpc_acount
operator|!=
literal|0
condition|)
break|break;
name|tp
operator|=
name|tp
operator|->
name|ftt_next
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|==
name|NULL
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
return|return
operator|(
name|ENOENT
operator|)
return|;
block|}
name|bcopy
argument_list|(
operator|&
name|tp
operator|->
name|ftt_instr
argument_list|,
operator|&
name|instr
operator|.
name|ftiq_instr
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
operator|.
name|ftiq_instr
argument_list|)
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_tpoints
operator|.
name|fth_table
index|[
name|index
index|]
operator|.
name|ftb_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|copyout
argument_list|(
operator|&
name|instr
argument_list|,
operator|(
name|void
operator|*
operator|)
name|arg
argument_list|,
sizeof|sizeof
argument_list|(
name|instr
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|EFAULT
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|EINVAL
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|cb_ops
name|fasttrap_cb_ops
init|=
block|{
name|fasttrap_open
block|,
comment|/* open */
name|nodev
block|,
comment|/* close */
name|nulldev
block|,
comment|/* strategy */
name|nulldev
block|,
comment|/* print */
name|nodev
block|,
comment|/* dump */
name|nodev
block|,
comment|/* read */
name|nodev
block|,
comment|/* write */
name|fasttrap_ioctl
block|,
comment|/* ioctl */
name|nodev
block|,
comment|/* devmap */
name|nodev
block|,
comment|/* mmap */
name|nodev
block|,
comment|/* segmap */
name|nochpoll
block|,
comment|/* poll */
name|ddi_prop_op
block|,
comment|/* cb_prop_op */
literal|0
block|,
comment|/* streamtab  */
name|D_NEW
operator||
name|D_MP
comment|/* Driver compatibility flag */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|int
name|fasttrap_info
parameter_list|(
name|dev_info_t
modifier|*
name|dip
parameter_list|,
name|ddi_info_cmd_t
name|infocmd
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|void
modifier|*
modifier|*
name|result
parameter_list|)
block|{
name|int
name|error
decl_stmt|;
switch|switch
condition|(
name|infocmd
condition|)
block|{
case|case
name|DDI_INFO_DEVT2DEVINFO
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
name|fasttrap_devi
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
case|case
name|DDI_INFO_DEVT2INSTANCE
case|:
operator|*
name|result
operator|=
operator|(
name|void
operator|*
operator|)
literal|0
expr_stmt|;
name|error
operator|=
name|DDI_SUCCESS
expr_stmt|;
break|break;
default|default:
name|error
operator|=
name|DDI_FAILURE
expr_stmt|;
block|}
return|return
operator|(
name|error
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_attach
parameter_list|(
name|dev_info_t
modifier|*
name|devi
parameter_list|,
name|ddi_attach_cmd_t
name|cmd
parameter_list|)
block|{
name|ulong_t
name|nent
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_ATTACH
case|:
break|break;
case|case
name|DDI_RESUME
case|:
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
if|if
condition|(
name|ddi_create_minor_node
argument_list|(
name|devi
argument_list|,
literal|"fasttrap"
argument_list|,
name|S_IFCHR
argument_list|,
literal|0
argument_list|,
name|DDI_PSEUDO
argument_list|,
name|NULL
argument_list|)
operator|==
name|DDI_FAILURE
condition|)
block|{
name|ddi_remove_minor_node
argument_list|(
name|devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
name|ddi_report_dev
argument_list|(
name|devi
argument_list|)
expr_stmt|;
name|fasttrap_devi
operator|=
name|devi
expr_stmt|;
comment|/* 	 * Install our hooks into fork(2), exec(2), and exit(2). 	 */
name|dtrace_fasttrap_fork_ptr
operator|=
operator|&
name|fasttrap_fork
expr_stmt|;
name|dtrace_fasttrap_exit_ptr
operator|=
operator|&
name|fasttrap_exec_exit
expr_stmt|;
name|dtrace_fasttrap_exec_ptr
operator|=
operator|&
name|fasttrap_exec_exit
expr_stmt|;
name|fasttrap_max
operator|=
name|ddi_getprop
argument_list|(
name|DDI_DEV_T_ANY
argument_list|,
name|devi
argument_list|,
name|DDI_PROP_DONTPASS
argument_list|,
literal|"fasttrap-max-probes"
argument_list|,
name|FASTTRAP_MAX_DEFAULT
argument_list|)
expr_stmt|;
name|fasttrap_total
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Conjure up the tracepoints hashtable... 	 */
name|nent
operator|=
name|ddi_getprop
argument_list|(
name|DDI_DEV_T_ANY
argument_list|,
name|devi
argument_list|,
name|DDI_PROP_DONTPASS
argument_list|,
literal|"fasttrap-hash-size"
argument_list|,
name|FASTTRAP_TPOINTS_DEFAULT_SIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nent
operator|==
literal|0
operator|||
name|nent
operator|>
literal|0x1000000
condition|)
name|nent
operator|=
name|FASTTRAP_TPOINTS_DEFAULT_SIZE
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
name|nent
argument_list|)
condition|)
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|=
name|nent
expr_stmt|;
else|else
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|=
literal|1
operator|<<
name|fasttrap_highbit
argument_list|(
name|nent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_tpoints
operator|.
name|fth_mask
operator|=
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|-
literal|1
expr_stmt|;
name|fasttrap_tpoints
operator|.
name|fth_table
operator|=
name|kmem_zalloc
argument_list|(
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * ... and the providers hash table... 	 */
name|nent
operator|=
name|FASTTRAP_PROVIDERS_DEFAULT_SIZE
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
name|nent
argument_list|)
condition|)
name|fasttrap_provs
operator|.
name|fth_nent
operator|=
name|nent
expr_stmt|;
else|else
name|fasttrap_provs
operator|.
name|fth_nent
operator|=
literal|1
operator|<<
name|fasttrap_highbit
argument_list|(
name|nent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_provs
operator|.
name|fth_nent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_provs
operator|.
name|fth_mask
operator|=
name|fasttrap_provs
operator|.
name|fth_nent
operator|-
literal|1
expr_stmt|;
name|fasttrap_provs
operator|.
name|fth_table
operator|=
name|kmem_zalloc
argument_list|(
name|fasttrap_provs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
comment|/* 	 * ... and the procs hash table. 	 */
name|nent
operator|=
name|FASTTRAP_PROCS_DEFAULT_SIZE
expr_stmt|;
if|if
condition|(
name|ISP2
argument_list|(
name|nent
argument_list|)
condition|)
name|fasttrap_procs
operator|.
name|fth_nent
operator|=
name|nent
expr_stmt|;
else|else
name|fasttrap_procs
operator|.
name|fth_nent
operator|=
literal|1
operator|<<
name|fasttrap_highbit
argument_list|(
name|nent
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_procs
operator|.
name|fth_nent
operator|>
literal|0
argument_list|)
expr_stmt|;
name|fasttrap_procs
operator|.
name|fth_mask
operator|=
name|fasttrap_procs
operator|.
name|fth_nent
operator|-
literal|1
expr_stmt|;
name|fasttrap_procs
operator|.
name|fth_table
operator|=
name|kmem_zalloc
argument_list|(
name|fasttrap_procs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_meta_register
argument_list|(
literal|"fasttrap"
argument_list|,
operator|&
name|fasttrap_mops
argument_list|,
name|NULL
argument_list|,
operator|&
name|fasttrap_meta_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|fasttrap_detach
parameter_list|(
name|dev_info_t
modifier|*
name|devi
parameter_list|,
name|ddi_detach_cmd_t
name|cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|fail
init|=
literal|0
decl_stmt|;
name|timeout_id_t
name|tmp
decl_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|DDI_DETACH
case|:
break|break;
case|case
name|DDI_SUSPEND
case|:
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
default|default:
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
comment|/* 	 * Unregister the meta-provider to make sure no new fasttrap- 	 * managed providers come along while we're trying to close up 	 * shop. If we fail to detach, we'll need to re-register as a 	 * meta-provider. We can fail to unregister as a meta-provider 	 * if providers we manage still exist. 	 */
if|if
condition|(
name|fasttrap_meta_id
operator|!=
name|DTRACE_METAPROVNONE
operator|&&
name|dtrace_meta_unregister
argument_list|(
name|fasttrap_meta_id
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
comment|/* 	 * Prevent any new timeouts from running by setting fasttrap_timeout 	 * to a non-zero value, and wait for the current timeout to complete. 	 */
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|fasttrap_cleanup_work
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|fasttrap_timeout
operator|!=
operator|(
name|timeout_id_t
operator|)
literal|1
condition|)
block|{
name|tmp
operator|=
name|fasttrap_timeout
expr_stmt|;
name|fasttrap_timeout
operator|=
operator|(
name|timeout_id_t
operator|)
literal|1
expr_stmt|;
if|if
condition|(
name|tmp
operator|!=
literal|0
condition|)
block|{
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|untimeout
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
block|}
block|}
name|fasttrap_cleanup_work
operator|=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
comment|/* 	 * Iterate over all of our providers. If there's still a process 	 * that corresponds to that pid, fail to detach. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fasttrap_provs
operator|.
name|fth_nent
condition|;
name|i
operator|++
control|)
block|{
name|fasttrap_provider_t
modifier|*
modifier|*
name|fpp
decl_stmt|,
modifier|*
name|fp
decl_stmt|;
name|fasttrap_bucket_t
modifier|*
name|bucket
init|=
operator|&
name|fasttrap_provs
operator|.
name|fth_table
index|[
name|i
index|]
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
name|fpp
operator|=
operator|(
name|fasttrap_provider_t
operator|*
operator|*
operator|)
operator|&
name|bucket
operator|->
name|ftb_data
expr_stmt|;
while|while
condition|(
operator|(
name|fp
operator|=
operator|*
name|fpp
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* 			 * Acquire and release the lock as a simple way of 			 * waiting for any other consumer to finish with 			 * this provider. A thread must first acquire the 			 * bucket lock so there's no chance of another thread 			 * blocking on the provider's lock. 			 */
name|mutex_enter
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fp
operator|->
name|ftp_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|dtrace_unregister
argument_list|(
name|fp
operator|->
name|ftp_provid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|fail
operator|=
literal|1
expr_stmt|;
name|fpp
operator|=
operator|&
name|fp
operator|->
name|ftp_next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fpp
operator|=
name|fp
operator|->
name|ftp_next
expr_stmt|;
name|fasttrap_provider_free
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
name|mutex_exit
argument_list|(
operator|&
name|bucket
operator|->
name|ftb_mtx
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fail
condition|)
block|{
name|uint_t
name|work
decl_stmt|;
comment|/* 		 * If we're failing to detach, we need to unblock timeouts 		 * and start a new timeout if any work has accumulated while 		 * we've been unsuccessfully trying to detach. 		 */
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
name|fasttrap_timeout
operator|=
literal|0
expr_stmt|;
name|work
operator|=
name|fasttrap_cleanup_work
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_cleanup_mtx
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
condition|)
name|fasttrap_pid_cleanup
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|dtrace_meta_register
argument_list|(
literal|"fasttrap"
argument_list|,
operator|&
name|fasttrap_mops
argument_list|,
name|NULL
argument_list|,
operator|&
name|fasttrap_meta_id
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_FAILURE
operator|)
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|mutex_enter
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|fasttrap_pid_count
operator|==
literal|0
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|fasttrap_count_mtx
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|kmem_free
argument_list|(
name|fasttrap_tpoints
operator|.
name|fth_table
argument_list|,
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|fasttrap_tpoints
operator|.
name|fth_nent
operator|=
literal|0
expr_stmt|;
name|kmem_free
argument_list|(
name|fasttrap_provs
operator|.
name|fth_table
argument_list|,
name|fasttrap_provs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|fasttrap_provs
operator|.
name|fth_nent
operator|=
literal|0
expr_stmt|;
name|kmem_free
argument_list|(
name|fasttrap_procs
operator|.
name|fth_table
argument_list|,
name|fasttrap_procs
operator|.
name|fth_nent
operator|*
sizeof|sizeof
argument_list|(
name|fasttrap_bucket_t
argument_list|)
argument_list|)
expr_stmt|;
name|fasttrap_procs
operator|.
name|fth_nent
operator|=
literal|0
expr_stmt|;
comment|/* 	 * We know there are no tracepoints in any process anywhere in 	 * the system so there is no process which has its p_dtrace_count 	 * greater than zero, therefore we know that no thread can actively 	 * be executing code in fasttrap_fork(). Similarly for p_dtrace_probes 	 * and fasttrap_exec() and fasttrap_exit(). 	 */
name|ASSERT
argument_list|(
name|dtrace_fasttrap_fork_ptr
operator|==
operator|&
name|fasttrap_fork
argument_list|)
expr_stmt|;
name|dtrace_fasttrap_fork_ptr
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_fasttrap_exec_ptr
operator|==
operator|&
name|fasttrap_exec_exit
argument_list|)
expr_stmt|;
name|dtrace_fasttrap_exec_ptr
operator|=
name|NULL
expr_stmt|;
name|ASSERT
argument_list|(
name|dtrace_fasttrap_exit_ptr
operator|==
operator|&
name|fasttrap_exec_exit
argument_list|)
expr_stmt|;
name|dtrace_fasttrap_exit_ptr
operator|=
name|NULL
expr_stmt|;
name|ddi_remove_minor_node
argument_list|(
name|devi
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|DDI_SUCCESS
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|dev_ops
name|fasttrap_ops
init|=
block|{
name|DEVO_REV
block|,
comment|/* devo_rev */
literal|0
block|,
comment|/* refcnt */
name|fasttrap_info
block|,
comment|/* get_dev_info */
name|nulldev
block|,
comment|/* identify */
name|nulldev
block|,
comment|/* probe */
name|fasttrap_attach
block|,
comment|/* attach */
name|fasttrap_detach
block|,
comment|/* detach */
name|nodev
block|,
comment|/* reset */
operator|&
name|fasttrap_cb_ops
block|,
comment|/* driver operations */
name|NULL
block|,
comment|/* bus operations */
name|nodev
block|,
comment|/* dev power */
name|ddi_quiesce_not_needed
block|,
comment|/* quiesce */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Module linkage information for the kernel.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|modldrv
name|modldrv
init|=
block|{
operator|&
name|mod_driverops
block|,
comment|/* module type (this is a pseudo driver) */
literal|"Fasttrap Tracing"
block|,
comment|/* name of module */
operator|&
name|fasttrap_ops
block|,
comment|/* driver ops */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|modlinkage
name|modlinkage
init|=
block|{
name|MODREV_1
block|,
operator|(
name|void
operator|*
operator|)
operator|&
name|modldrv
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|_init
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_install
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_info
parameter_list|(
name|struct
name|modinfo
modifier|*
name|modinfop
parameter_list|)
block|{
return|return
operator|(
name|mod_info
argument_list|(
operator|&
name|modlinkage
argument_list|,
name|modinfop
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|_fini
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|mod_remove
argument_list|(
operator|&
name|modlinkage
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

