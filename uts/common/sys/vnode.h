begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 1988, 2010, Oracle and/or its affiliates. All rights reserved.  * Copyright (c) 2013, Joyent, Inc. All rights reserved.  */
end_comment

begin_comment
comment|/*	Copyright (c) 1983, 1984, 1985, 1986, 1987, 1988, 1989 AT&T	*/
end_comment

begin_comment
comment|/*	  All Rights Reserved  	*/
end_comment

begin_comment
comment|/*  * University Copyright- Copyright (c) 1982, 1986, 1988  * The Regents of the University of California  * All Rights Reserved  *  * University Acknowledgment- Portions of this document are derived from  * software developed by the University of California, Berkeley, and its  * contributors.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_SYS_VNODE_H
end_ifndef

begin_define
define|#
directive|define
name|_SYS_VNODE_H
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/t_lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/rwstlock.h>
end_include

begin_include
include|#
directive|include
file|<sys/time_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/cred.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<vm/seg_enum.h>
end_include

begin_include
include|#
directive|include
file|<sys/kstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/list.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<sys/buf.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _KERNEL */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__cplusplus
end_ifdef

begin_extern
extern|extern
literal|"C"
block|{
endif|#
directive|endif
comment|/*  * Statistics for all vnode operations.  * All operations record number of ops (since boot/mount/zero'ed).  * Certain I/O operations (read, write, readdir) also record number  * of bytes transferred.  * This appears in two places in the system: one is embedded in each  * vfs_t.  There is also an array of vopstats_t structures allocated  * on a per-fstype basis.  */
define|#
directive|define
name|VOPSTATS_STR
value|"vopstats_"
comment|/* Initial string for vopstat kstats */
typedef|typedef
struct|struct
name|vopstats
block|{
name|kstat_named_t
name|nopen
decl_stmt|;
comment|/* VOP_OPEN */
name|kstat_named_t
name|nclose
decl_stmt|;
comment|/* VOP_CLOSE */
name|kstat_named_t
name|nread
decl_stmt|;
comment|/* VOP_READ */
name|kstat_named_t
name|read_bytes
decl_stmt|;
name|kstat_named_t
name|nwrite
decl_stmt|;
comment|/* VOP_WRITE */
name|kstat_named_t
name|write_bytes
decl_stmt|;
name|kstat_named_t
name|nioctl
decl_stmt|;
comment|/* VOP_IOCTL */
name|kstat_named_t
name|nsetfl
decl_stmt|;
comment|/* VOP_SETFL */
name|kstat_named_t
name|ngetattr
decl_stmt|;
comment|/* VOP_GETATTR */
name|kstat_named_t
name|nsetattr
decl_stmt|;
comment|/* VOP_SETATTR */
name|kstat_named_t
name|naccess
decl_stmt|;
comment|/* VOP_ACCESS */
name|kstat_named_t
name|nlookup
decl_stmt|;
comment|/* VOP_LOOKUP */
name|kstat_named_t
name|ncreate
decl_stmt|;
comment|/* VOP_CREATE */
name|kstat_named_t
name|nremove
decl_stmt|;
comment|/* VOP_REMOVE */
name|kstat_named_t
name|nlink
decl_stmt|;
comment|/* VOP_LINK */
name|kstat_named_t
name|nrename
decl_stmt|;
comment|/* VOP_RENAME */
name|kstat_named_t
name|nmkdir
decl_stmt|;
comment|/* VOP_MKDIR */
name|kstat_named_t
name|nrmdir
decl_stmt|;
comment|/* VOP_RMDIR */
name|kstat_named_t
name|nreaddir
decl_stmt|;
comment|/* VOP_READDIR */
name|kstat_named_t
name|readdir_bytes
decl_stmt|;
name|kstat_named_t
name|nsymlink
decl_stmt|;
comment|/* VOP_SYMLINK */
name|kstat_named_t
name|nreadlink
decl_stmt|;
comment|/* VOP_READLINK */
name|kstat_named_t
name|nfsync
decl_stmt|;
comment|/* VOP_FSYNC */
name|kstat_named_t
name|ninactive
decl_stmt|;
comment|/* VOP_INACTIVE */
name|kstat_named_t
name|nfid
decl_stmt|;
comment|/* VOP_FID */
name|kstat_named_t
name|nrwlock
decl_stmt|;
comment|/* VOP_RWLOCK */
name|kstat_named_t
name|nrwunlock
decl_stmt|;
comment|/* VOP_RWUNLOCK */
name|kstat_named_t
name|nseek
decl_stmt|;
comment|/* VOP_SEEK */
name|kstat_named_t
name|ncmp
decl_stmt|;
comment|/* VOP_CMP */
name|kstat_named_t
name|nfrlock
decl_stmt|;
comment|/* VOP_FRLOCK */
name|kstat_named_t
name|nspace
decl_stmt|;
comment|/* VOP_SPACE */
name|kstat_named_t
name|nrealvp
decl_stmt|;
comment|/* VOP_REALVP */
name|kstat_named_t
name|ngetpage
decl_stmt|;
comment|/* VOP_GETPAGE */
name|kstat_named_t
name|nputpage
decl_stmt|;
comment|/* VOP_PUTPAGE */
name|kstat_named_t
name|nmap
decl_stmt|;
comment|/* VOP_MAP */
name|kstat_named_t
name|naddmap
decl_stmt|;
comment|/* VOP_ADDMAP */
name|kstat_named_t
name|ndelmap
decl_stmt|;
comment|/* VOP_DELMAP */
name|kstat_named_t
name|npoll
decl_stmt|;
comment|/* VOP_POLL */
name|kstat_named_t
name|ndump
decl_stmt|;
comment|/* VOP_DUMP */
name|kstat_named_t
name|npathconf
decl_stmt|;
comment|/* VOP_PATHCONF */
name|kstat_named_t
name|npageio
decl_stmt|;
comment|/* VOP_PAGEIO */
name|kstat_named_t
name|ndumpctl
decl_stmt|;
comment|/* VOP_DUMPCTL */
name|kstat_named_t
name|ndispose
decl_stmt|;
comment|/* VOP_DISPOSE */
name|kstat_named_t
name|nsetsecattr
decl_stmt|;
comment|/* VOP_SETSECATTR */
name|kstat_named_t
name|ngetsecattr
decl_stmt|;
comment|/* VOP_GETSECATTR */
name|kstat_named_t
name|nshrlock
decl_stmt|;
comment|/* VOP_SHRLOCK */
name|kstat_named_t
name|nvnevent
decl_stmt|;
comment|/* VOP_VNEVENT */
name|kstat_named_t
name|nreqzcbuf
decl_stmt|;
comment|/* VOP_REQZCBUF */
name|kstat_named_t
name|nretzcbuf
decl_stmt|;
comment|/* VOP_RETZCBUF */
block|}
name|vopstats_t
typedef|;
comment|/*  * The vnode is the focus of all file activity in UNIX.  * A vnode is allocated for each active file, each current  * directory, each mounted-on file, and the root.  *  * Each vnode is usually associated with a file-system-specific node (for  * UFS, this is the in-memory inode).  Generally, a vnode and an fs-node  * should be created and destroyed together as a pair.  *  * If a vnode is reused for a new file, it should be reinitialized by calling  * either vn_reinit() or vn_recycle().  *  * vn_reinit() resets the entire vnode as if it was returned by vn_alloc().  * The caller is responsible for setting up the entire vnode after calling  * vn_reinit().  This is important when using kmem caching where the vnode is  * allocated by a constructor, for instance.  *  * vn_recycle() is used when the file system keeps some state around in both  * the vnode and the associated FS-node.  In UFS, for example, the inode of  * a deleted file can be reused immediately.  The v_data, v_vfsp, v_op, etc.  * remains the same but certain fields related to the previous instance need  * to be reset.  In particular:  *	v_femhead  *	v_path  *	v_rdcnt, v_wrcnt  *	v_mmap_read, v_mmap_write  */
comment|/*  * vnode types.  VNON means no type.  These values are unrelated to  * values in on-disk inodes.  */
typedef|typedef
enum|enum
name|vtype
block|{
name|VNON
init|=
literal|0
block|,
name|VREG
init|=
literal|1
block|,
name|VDIR
init|=
literal|2
block|,
name|VBLK
init|=
literal|3
block|,
name|VCHR
init|=
literal|4
block|,
name|VLNK
init|=
literal|5
block|,
name|VFIFO
init|=
literal|6
block|,
name|VDOOR
init|=
literal|7
block|,
name|VPROC
init|=
literal|8
block|,
name|VSOCK
init|=
literal|9
block|,
name|VPORT
init|=
literal|10
block|,
name|VBAD
init|=
literal|11
block|}
name|vtype_t
typedef|;
comment|/*  * VSD - Vnode Specific Data  * Used to associate additional private data with a vnode.  */
struct|struct
name|vsd_node
block|{
name|list_node_t
name|vs_nodes
decl_stmt|;
comment|/* list of all VSD nodes */
name|uint_t
name|vs_nkeys
decl_stmt|;
comment|/* entries in value array */
name|void
modifier|*
modifier|*
name|vs_value
decl_stmt|;
comment|/* array of value/key */
block|}
struct|;
comment|/*  * Many of the fields in the vnode are read-only once they are initialized  * at vnode creation time.  Other fields are protected by locks.  *  * IMPORTANT: vnodes should be created ONLY by calls to vn_alloc().  They  * may not be embedded into the file-system specific node (inode).  The  * size of vnodes may change.  *  * The v_lock protects:  *   v_flag  *   v_stream  *   v_count  *   v_shrlocks  *   v_path  *   v_vsd  *   v_xattrdir  *  * A special lock (implemented by vn_vfswlock in vnode.c) protects:  *   v_vfsmountedhere  *  * The global flock_lock mutex (in flock.c) protects:  *   v_filocks  *  * IMPORTANT NOTE:  *  *   The following vnode fields are considered public and may safely be  *   accessed by file systems or other consumers:  *  *     v_lock  *     v_flag  *     v_count  *     v_data  *     v_vfsp  *     v_stream  *     v_type  *     v_rdev  *  * ALL OTHER FIELDS SHOULD BE ACCESSED ONLY BY THE OWNER OF THAT FIELD.  * In particular, file systems should not access other fields; they may  * change or even be removed.  The functionality which was once provided  * by these fields is available through vn_* functions.  */
struct_decl|struct
name|fem_head
struct_decl|;
comment|/* from fem.h */
typedef|typedef
struct|struct
name|vnode
block|{
name|kmutex_t
name|v_lock
decl_stmt|;
comment|/* protects vnode fields */
name|uint_t
name|v_flag
decl_stmt|;
comment|/* vnode flags (see below) */
name|uint_t
name|v_count
decl_stmt|;
comment|/* reference count */
name|void
modifier|*
name|v_data
decl_stmt|;
comment|/* private data for fs */
name|struct
name|vfs
modifier|*
name|v_vfsp
decl_stmt|;
comment|/* ptr to containing VFS */
name|struct
name|stdata
modifier|*
name|v_stream
decl_stmt|;
comment|/* associated stream */
name|enum
name|vtype
name|v_type
decl_stmt|;
comment|/* vnode type */
name|dev_t
name|v_rdev
decl_stmt|;
comment|/* device (VCHR, VBLK) */
comment|/* PRIVATE FIELDS BELOW - DO NOT USE */
name|struct
name|vfs
modifier|*
name|v_vfsmountedhere
decl_stmt|;
comment|/* ptr to vfs mounted here */
name|struct
name|vnodeops
modifier|*
name|v_op
decl_stmt|;
comment|/* vnode operations */
name|struct
name|page
modifier|*
name|v_pages
decl_stmt|;
comment|/* vnode pages list */
name|struct
name|filock
modifier|*
name|v_filocks
decl_stmt|;
comment|/* ptr to filock list */
name|struct
name|shrlocklist
modifier|*
name|v_shrlocks
decl_stmt|;
comment|/* ptr to shrlock list */
name|krwlock_t
name|v_nbllock
decl_stmt|;
comment|/* sync for NBMAND locks */
name|kcondvar_t
name|v_cv
decl_stmt|;
comment|/* synchronize locking */
name|void
modifier|*
name|v_locality
decl_stmt|;
comment|/* hook for locality info */
name|struct
name|fem_head
modifier|*
name|v_femhead
decl_stmt|;
comment|/* fs monitoring */
name|char
modifier|*
name|v_path
decl_stmt|;
comment|/* cached path */
name|uint_t
name|v_rdcnt
decl_stmt|;
comment|/* open for read count  (VREG only) */
name|uint_t
name|v_wrcnt
decl_stmt|;
comment|/* open for write count (VREG only) */
name|u_longlong_t
name|v_mmap_read
decl_stmt|;
comment|/* mmap read count */
name|u_longlong_t
name|v_mmap_write
decl_stmt|;
comment|/* mmap write count */
name|void
modifier|*
name|v_mpssdata
decl_stmt|;
comment|/* info for large page mappings */
name|void
modifier|*
name|v_fopdata
decl_stmt|;
comment|/* list of file ops event watches */
name|kmutex_t
name|v_vsd_lock
decl_stmt|;
comment|/* protects v_vsd field */
name|struct
name|vsd_node
modifier|*
name|v_vsd
decl_stmt|;
comment|/* vnode specific data */
name|struct
name|vnode
modifier|*
name|v_xattrdir
decl_stmt|;
comment|/* unnamed extended attr dir (GFS) */
name|uint_t
name|v_count_dnlc
decl_stmt|;
comment|/* dnlc reference count */
block|}
name|vnode_t
typedef|;
define|#
directive|define
name|IS_DEVVP
parameter_list|(
name|vp
parameter_list|)
define|\
value|((vp)->v_type == VCHR || (vp)->v_type == VBLK || (vp)->v_type == VFIFO)
define|#
directive|define
name|VNODE_ALIGN
value|64
comment|/* Count of low-order 0 bits in a vnode *, based on size and alignment. */
if|#
directive|if
name|defined
argument_list|(
name|_LP64
argument_list|)
define|#
directive|define
name|VNODE_ALIGN_LOG2
value|8
else|#
directive|else
define|#
directive|define
name|VNODE_ALIGN_LOG2
value|7
endif|#
directive|endif
comment|/*  * vnode flags.  */
define|#
directive|define
name|VROOT
value|0x01
comment|/* root of its file system */
define|#
directive|define
name|VNOCACHE
value|0x02
comment|/* don't keep cache pages on vnode */
define|#
directive|define
name|VNOMAP
value|0x04
comment|/* file cannot be mapped/faulted */
define|#
directive|define
name|VDUP
value|0x08
comment|/* file should be dup'ed rather then opened */
define|#
directive|define
name|VNOSWAP
value|0x10
comment|/* file cannot be used as virtual swap device */
define|#
directive|define
name|VNOMOUNT
value|0x20
comment|/* file cannot be covered by mount */
define|#
directive|define
name|VISSWAP
value|0x40
comment|/* vnode is being used for swap */
define|#
directive|define
name|VSWAPLIKE
value|0x80
comment|/* vnode acts like swap (but may not be) */
define|#
directive|define
name|IS_SWAPVP
parameter_list|(
name|vp
parameter_list|)
value|(((vp)->v_flag& (VISSWAP | VSWAPLIKE)) != 0)
typedef|typedef
struct|struct
name|vn_vfslocks_entry
block|{
name|rwstlock_t
name|ve_lock
decl_stmt|;
name|void
modifier|*
name|ve_vpvfs
decl_stmt|;
name|struct
name|vn_vfslocks_entry
modifier|*
name|ve_next
decl_stmt|;
name|uint32_t
name|ve_refcnt
decl_stmt|;
name|char
name|pad
index|[
literal|64
operator|-
sizeof|sizeof
argument_list|(
name|rwstlock_t
argument_list|)
operator|-
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|void
operator|*
argument_list|)
operator|-
expr|\
sizeof|sizeof
argument_list|(
name|uint32_t
argument_list|)
index|]
decl_stmt|;
block|}
name|vn_vfslocks_entry_t
typedef|;
comment|/*  * The following two flags are used to lock the v_vfsmountedhere field  */
define|#
directive|define
name|VVFSLOCK
value|0x100
define|#
directive|define
name|VVFSWAIT
value|0x200
comment|/*  * Used to serialize VM operations on a vnode  */
define|#
directive|define
name|VVMLOCK
value|0x400
comment|/*  * Tell vn_open() not to fail a directory open for writing but  * to go ahead and call VOP_OPEN() to let the filesystem check.  */
define|#
directive|define
name|VDIROPEN
value|0x800
comment|/*  * Flag to let the VM system know that this file is most likely a binary  * or shared library since it has been mmap()ed EXEC at some time.  */
define|#
directive|define
name|VVMEXEC
value|0x1000
define|#
directive|define
name|VPXFS
value|0x2000
comment|/* clustering: global fs proxy vnode */
define|#
directive|define
name|IS_PXFSVP
parameter_list|(
name|vp
parameter_list|)
value|((vp)->v_flag& VPXFS)
define|#
directive|define
name|V_XATTRDIR
value|0x4000
comment|/* attribute unnamed directory */
define|#
directive|define
name|IS_XATTRDIR
parameter_list|(
name|vp
parameter_list|)
value|((vp)->v_flag& V_XATTRDIR)
define|#
directive|define
name|V_LOCALITY
value|0x8000
comment|/* whether locality aware */
comment|/*  * Flag that indicates the VM should maintain the v_pages list with all modified  * pages on one end and unmodified pages at the other. This makes finding dirty  * pages to write back to disk much faster at the expense of taking a minor  * fault on the first store instruction which touches a writable page.  */
define|#
directive|define
name|VMODSORT
value|(0x10000)
define|#
directive|define
name|IS_VMODSORT
parameter_list|(
name|vp
parameter_list|)
define|\
value|(pvn_vmodsort_supported != 0&& ((vp)->v_flag& VMODSORT) != 0)
define|#
directive|define
name|VISSWAPFS
value|0x20000
comment|/* vnode is being used for swapfs */
comment|/*  * The mdb memstat command assumes that IS_SWAPFSVP only uses the  * vnode's v_flag field.  If this changes, cache the additional  * fields in mdb; see vn_get in mdb/common/modules/genunix/memory.c  */
define|#
directive|define
name|IS_SWAPFSVP
parameter_list|(
name|vp
parameter_list|)
value|(((vp)->v_flag& VISSWAPFS) != 0)
define|#
directive|define
name|V_SYSATTR
value|0x40000
comment|/* vnode is a GFS system attribute */
comment|/*  * Vnode attributes.  A bit-mask is supplied as part of the  * structure to indicate the attributes the caller wants to  * set (setattr) or extract (getattr).  */
comment|/*  * Note that va_nodeid and va_nblocks are 64bit data type.  * We support large files over NFSV3. With Solaris client and  * Server that generates 64bit ino's and sizes these fields  * will overflow if they are 32 bit sizes.  */
typedef|typedef
struct|struct
name|vattr
block|{
name|uint_t
name|va_mask
decl_stmt|;
comment|/* bit-mask of attributes */
name|vtype_t
name|va_type
decl_stmt|;
comment|/* vnode type (for create) */
name|mode_t
name|va_mode
decl_stmt|;
comment|/* file access mode */
name|uid_t
name|va_uid
decl_stmt|;
comment|/* owner user id */
name|gid_t
name|va_gid
decl_stmt|;
comment|/* owner group id */
name|dev_t
name|va_fsid
decl_stmt|;
comment|/* file system id (dev for now) */
name|u_longlong_t
name|va_nodeid
decl_stmt|;
comment|/* node id */
name|nlink_t
name|va_nlink
decl_stmt|;
comment|/* number of references to file */
name|u_offset_t
name|va_size
decl_stmt|;
comment|/* file size in bytes */
name|timestruc_t
name|va_atime
decl_stmt|;
comment|/* time of last access */
name|timestruc_t
name|va_mtime
decl_stmt|;
comment|/* time of last modification */
name|timestruc_t
name|va_ctime
decl_stmt|;
comment|/* time of last status change */
name|dev_t
name|va_rdev
decl_stmt|;
comment|/* device the file represents */
name|uint_t
name|va_blksize
decl_stmt|;
comment|/* fundamental block size */
name|u_longlong_t
name|va_nblocks
decl_stmt|;
comment|/* # of blocks allocated */
name|uint_t
name|va_seq
decl_stmt|;
comment|/* sequence number */
block|}
name|vattr_t
typedef|;
define|#
directive|define
name|AV_SCANSTAMP_SZ
value|32
comment|/* length of anti-virus scanstamp */
comment|/*  * Structure of all optional attributes.  */
typedef|typedef
struct|struct
name|xoptattr
block|{
name|timestruc_t
name|xoa_createtime
decl_stmt|;
comment|/* Create time of file */
name|uint8_t
name|xoa_archive
decl_stmt|;
name|uint8_t
name|xoa_system
decl_stmt|;
name|uint8_t
name|xoa_readonly
decl_stmt|;
name|uint8_t
name|xoa_hidden
decl_stmt|;
name|uint8_t
name|xoa_nounlink
decl_stmt|;
name|uint8_t
name|xoa_immutable
decl_stmt|;
name|uint8_t
name|xoa_appendonly
decl_stmt|;
name|uint8_t
name|xoa_nodump
decl_stmt|;
name|uint8_t
name|xoa_opaque
decl_stmt|;
name|uint8_t
name|xoa_av_quarantined
decl_stmt|;
name|uint8_t
name|xoa_av_modified
decl_stmt|;
name|uint8_t
name|xoa_av_scanstamp
index|[
name|AV_SCANSTAMP_SZ
index|]
decl_stmt|;
name|uint8_t
name|xoa_reparse
decl_stmt|;
name|uint64_t
name|xoa_generation
decl_stmt|;
name|uint8_t
name|xoa_offline
decl_stmt|;
name|uint8_t
name|xoa_sparse
decl_stmt|;
block|}
name|xoptattr_t
typedef|;
comment|/*  * The xvattr structure is really a variable length structure that  * is made up of:  * - The classic vattr_t (xva_vattr)  * - a 32 bit quantity (xva_mapsize) that specifies the size of the  *   attribute bitmaps in 32 bit words.  * - A pointer to the returned attribute bitmap (needed because the  *   previous element, the requested attribute bitmap) is variable lenth.  * - The requested attribute bitmap, which is an array of 32 bit words.  *   Callers use the XVA_SET_REQ() macro to set the bits corresponding to  *   the attributes that are being requested.  * - The returned attribute bitmap, which is an array of 32 bit words.  *   File systems that support optional attributes use the XVA_SET_RTN()  *   macro to set the bits corresponding to the attributes that are being  *   returned.  * - The xoptattr_t structure which contains the attribute values  *  * xva_mapsize determines how many words in the attribute bitmaps.  * Immediately following the attribute bitmaps is the xoptattr_t.  * xva_getxoptattr() is used to get the pointer to the xoptattr_t  * section.  */
define|#
directive|define
name|XVA_MAPSIZE
value|3
comment|/* Size of attr bitmaps */
define|#
directive|define
name|XVA_MAGIC
value|0x78766174
comment|/* Magic # for verification */
comment|/*  * The xvattr structure is an extensible structure which permits optional  * attributes to be requested/returned.  File systems may or may not support  * optional attributes.  They do so at their own discretion but if they do  * support optional attributes, they must register the VFSFT_XVATTR feature  * so that the optional attributes can be set/retrived.  *  * The fields of the xvattr structure are:  *  * xva_vattr - The first element of an xvattr is a legacy vattr structure  * which includes the common attributes.  If AT_XVATTR is set in the va_mask  * then the entire structure is treated as an xvattr.  If AT_XVATTR is not  * set, then only the xva_vattr structure can be used.  *  * xva_magic - 0x78766174 (hex for "xvat"). Magic number for verification.  *  * xva_mapsize - Size of requested and returned attribute bitmaps.  *  * xva_rtnattrmapp - Pointer to xva_rtnattrmap[].  We need this since the  * size of the array before it, xva_reqattrmap[], could change which means  * the location of xva_rtnattrmap[] could change.  This will allow unbundled  * file systems to find the location of xva_rtnattrmap[] when the sizes change.  *  * xva_reqattrmap[] - Array of requested attributes.  Attributes are  * represented by a specific bit in a specific element of the attribute  * map array.  Callers set the bits corresponding to the attributes  * that the caller wants to get/set.  *  * xva_rtnattrmap[] - Array of attributes that the file system was able to  * process.  Not all file systems support all optional attributes.  This map  * informs the caller which attributes the underlying file system was able  * to set/get.  (Same structure as the requested attributes array in terms  * of each attribute  corresponding to specific bits and array elements.)  *  * xva_xoptattrs - Structure containing values of optional attributes.  * These values are only valid if the corresponding bits in xva_reqattrmap  * are set and the underlying file system supports those attributes.  */
typedef|typedef
struct|struct
name|xvattr
block|{
name|vattr_t
name|xva_vattr
decl_stmt|;
comment|/* Embedded vattr structure */
name|uint32_t
name|xva_magic
decl_stmt|;
comment|/* Magic Number */
name|uint32_t
name|xva_mapsize
decl_stmt|;
comment|/* Size of attr bitmap (32-bit words) */
name|uint32_t
modifier|*
name|xva_rtnattrmapp
decl_stmt|;
comment|/* Ptr to xva_rtnattrmap[] */
name|uint32_t
name|xva_reqattrmap
index|[
name|XVA_MAPSIZE
index|]
decl_stmt|;
comment|/* Requested attrs */
name|uint32_t
name|xva_rtnattrmap
index|[
name|XVA_MAPSIZE
index|]
decl_stmt|;
comment|/* Returned attrs */
name|xoptattr_t
name|xva_xoptattrs
decl_stmt|;
comment|/* Optional attributes */
block|}
name|xvattr_t
typedef|;
ifdef|#
directive|ifdef
name|_SYSCALL32
comment|/*  * For bigtypes time_t changed to 64 bit on the 64-bit kernel.  * Define an old version for user/kernel interface  */
if|#
directive|if
name|_LONG_LONG_ALIGNMENT
operator|==
literal|8
operator|&&
name|_LONG_LONG_ALIGNMENT_32
operator|==
literal|4
pragma|#
directive|pragma
name|pack
name|(
name|4
name|)
endif|#
directive|endif
typedef|typedef
struct|struct
name|vattr32
block|{
name|uint32_t
name|va_mask
decl_stmt|;
comment|/* bit-mask of attributes */
name|vtype_t
name|va_type
decl_stmt|;
comment|/* vnode type (for create) */
name|mode32_t
name|va_mode
decl_stmt|;
comment|/* file access mode */
name|uid32_t
name|va_uid
decl_stmt|;
comment|/* owner user id */
name|gid32_t
name|va_gid
decl_stmt|;
comment|/* owner group id */
name|dev32_t
name|va_fsid
decl_stmt|;
comment|/* file system id (dev for now) */
name|u_longlong_t
name|va_nodeid
decl_stmt|;
comment|/* node id */
name|nlink_t
name|va_nlink
decl_stmt|;
comment|/* number of references to file */
name|u_offset_t
name|va_size
decl_stmt|;
comment|/* file size in bytes */
name|timestruc32_t
name|va_atime
decl_stmt|;
comment|/* time of last access */
name|timestruc32_t
name|va_mtime
decl_stmt|;
comment|/* time of last modification */
name|timestruc32_t
name|va_ctime
decl_stmt|;
comment|/* time of last status change */
name|dev32_t
name|va_rdev
decl_stmt|;
comment|/* device the file represents */
name|uint32_t
name|va_blksize
decl_stmt|;
comment|/* fundamental block size */
name|u_longlong_t
name|va_nblocks
decl_stmt|;
comment|/* # of blocks allocated */
name|uint32_t
name|va_seq
decl_stmt|;
comment|/* sequence number */
block|}
name|vattr32_t
typedef|;
if|#
directive|if
name|_LONG_LONG_ALIGNMENT
operator|==
literal|8
operator|&&
name|_LONG_LONG_ALIGNMENT_32
operator|==
literal|4
pragma|#
directive|pragma
name|pack
name|(
name|)
endif|#
directive|endif
else|#
directive|else
comment|/* not _SYSCALL32 */
define|#
directive|define
name|vattr32
value|vattr
typedef|typedef
name|vattr_t
name|vattr32_t
typedef|;
endif|#
directive|endif
comment|/* _SYSCALL32 */
comment|/*  * Attributes of interest to the caller of setattr or getattr.  */
define|#
directive|define
name|AT_TYPE
value|0x00001
define|#
directive|define
name|AT_MODE
value|0x00002
define|#
directive|define
name|AT_UID
value|0x00004
define|#
directive|define
name|AT_GID
value|0x00008
define|#
directive|define
name|AT_FSID
value|0x00010
define|#
directive|define
name|AT_NODEID
value|0x00020
define|#
directive|define
name|AT_NLINK
value|0x00040
define|#
directive|define
name|AT_SIZE
value|0x00080
define|#
directive|define
name|AT_ATIME
value|0x00100
define|#
directive|define
name|AT_MTIME
value|0x00200
define|#
directive|define
name|AT_CTIME
value|0x00400
define|#
directive|define
name|AT_RDEV
value|0x00800
define|#
directive|define
name|AT_BLKSIZE
value|0x01000
define|#
directive|define
name|AT_NBLOCKS
value|0x02000
comment|/*			0x04000 */
comment|/* unused */
define|#
directive|define
name|AT_SEQ
value|0x08000
comment|/*  * If AT_XVATTR is set then there are additional bits to process in  * the xvattr_t's attribute bitmap.  If this is not set then the bitmap  * MUST be ignored.  Note that this bit must be set/cleared explicitly.  * That is, setting AT_ALL will NOT set AT_XVATTR.  */
define|#
directive|define
name|AT_XVATTR
value|0x10000
define|#
directive|define
name|AT_ALL
value|(AT_TYPE|AT_MODE|AT_UID|AT_GID|AT_FSID|AT_NODEID|\ 			AT_NLINK|AT_SIZE|AT_ATIME|AT_MTIME|AT_CTIME|\ 			AT_RDEV|AT_BLKSIZE|AT_NBLOCKS|AT_SEQ)
define|#
directive|define
name|AT_STAT
value|(AT_MODE|AT_UID|AT_GID|AT_FSID|AT_NODEID|AT_NLINK|\ 			AT_SIZE|AT_ATIME|AT_MTIME|AT_CTIME|AT_RDEV|AT_TYPE)
define|#
directive|define
name|AT_TIMES
value|(AT_ATIME|AT_MTIME|AT_CTIME)
define|#
directive|define
name|AT_NOSET
value|(AT_NLINK|AT_RDEV|AT_FSID|AT_NODEID|AT_TYPE|\ 			AT_BLKSIZE|AT_NBLOCKS|AT_SEQ)
comment|/*  * Attribute bits used in the extensible attribute's (xva's) attribute  * bitmaps.  Note that the bitmaps are made up of a variable length number  * of 32-bit words.  The convention is to use XAT{n}_{attrname} where "n"  * is the element in the bitmap (starting at 1).  This convention is for  * the convenience of the maintainer to keep track of which element each  * attribute belongs to.  *  * NOTE THAT CONSUMERS MUST *NOT* USE THE XATn_* DEFINES DIRECTLY.  CONSUMERS  * MUST USE THE XAT_* DEFINES.  */
define|#
directive|define
name|XAT0_INDEX
value|0LL
comment|/* Index into bitmap for XAT0 attrs */
define|#
directive|define
name|XAT0_CREATETIME
value|0x00000001
comment|/* Create time of file */
define|#
directive|define
name|XAT0_ARCHIVE
value|0x00000002
comment|/* Archive */
define|#
directive|define
name|XAT0_SYSTEM
value|0x00000004
comment|/* System */
define|#
directive|define
name|XAT0_READONLY
value|0x00000008
comment|/* Readonly */
define|#
directive|define
name|XAT0_HIDDEN
value|0x00000010
comment|/* Hidden */
define|#
directive|define
name|XAT0_NOUNLINK
value|0x00000020
comment|/* Nounlink */
define|#
directive|define
name|XAT0_IMMUTABLE
value|0x00000040
comment|/* immutable */
define|#
directive|define
name|XAT0_APPENDONLY
value|0x00000080
comment|/* appendonly */
define|#
directive|define
name|XAT0_NODUMP
value|0x00000100
comment|/* nodump */
define|#
directive|define
name|XAT0_OPAQUE
value|0x00000200
comment|/* opaque */
define|#
directive|define
name|XAT0_AV_QUARANTINED
value|0x00000400
comment|/* anti-virus quarantine */
define|#
directive|define
name|XAT0_AV_MODIFIED
value|0x00000800
comment|/* anti-virus modified */
define|#
directive|define
name|XAT0_AV_SCANSTAMP
value|0x00001000
comment|/* anti-virus scanstamp */
define|#
directive|define
name|XAT0_REPARSE
value|0x00002000
comment|/* FS reparse point */
define|#
directive|define
name|XAT0_GEN
value|0x00004000
comment|/* object generation number */
define|#
directive|define
name|XAT0_OFFLINE
value|0x00008000
comment|/* offline */
define|#
directive|define
name|XAT0_SPARSE
value|0x00010000
comment|/* sparse */
define|#
directive|define
name|XAT0_ALL_ATTRS
value|(XAT0_CREATETIME|XAT0_ARCHIVE|XAT0_SYSTEM| \     XAT0_READONLY|XAT0_HIDDEN|XAT0_NOUNLINK|XAT0_IMMUTABLE|XAT0_APPENDONLY| \     XAT0_NODUMP|XAT0_OPAQUE|XAT0_AV_QUARANTINED|  XAT0_AV_MODIFIED| \     XAT0_AV_SCANSTAMP|XAT0_REPARSE|XATO_GEN|XAT0_OFFLINE|XAT0_SPARSE)
comment|/* Support for XAT_* optional attributes */
define|#
directive|define
name|XVA_MASK
value|0xffffffff
comment|/* Used to mask off 32 bits */
define|#
directive|define
name|XVA_SHFT
value|32
comment|/* Used to shift index */
comment|/*  * Used to pry out the index and attribute bits from the XAT_* attributes  * defined below.  Note that we're masking things down to 32 bits then  * casting to uint32_t.  */
define|#
directive|define
name|XVA_INDEX
parameter_list|(
name|attr
parameter_list|)
value|((uint32_t)(((attr)>> XVA_SHFT)& XVA_MASK))
define|#
directive|define
name|XVA_ATTRBIT
parameter_list|(
name|attr
parameter_list|)
value|((uint32_t)((attr)& XVA_MASK))
comment|/*  * The following defines present a "flat namespace" so that consumers don't  * need to keep track of which element belongs to which bitmap entry.  *  * NOTE THAT THESE MUST NEVER BE OR-ed TOGETHER  */
define|#
directive|define
name|XAT_CREATETIME
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_CREATETIME)
define|#
directive|define
name|XAT_ARCHIVE
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_ARCHIVE)
define|#
directive|define
name|XAT_SYSTEM
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_SYSTEM)
define|#
directive|define
name|XAT_READONLY
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_READONLY)
define|#
directive|define
name|XAT_HIDDEN
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_HIDDEN)
define|#
directive|define
name|XAT_NOUNLINK
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_NOUNLINK)
define|#
directive|define
name|XAT_IMMUTABLE
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_IMMUTABLE)
define|#
directive|define
name|XAT_APPENDONLY
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_APPENDONLY)
define|#
directive|define
name|XAT_NODUMP
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_NODUMP)
define|#
directive|define
name|XAT_OPAQUE
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_OPAQUE)
define|#
directive|define
name|XAT_AV_QUARANTINED
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_AV_QUARANTINED)
define|#
directive|define
name|XAT_AV_MODIFIED
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_AV_MODIFIED)
define|#
directive|define
name|XAT_AV_SCANSTAMP
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_AV_SCANSTAMP)
define|#
directive|define
name|XAT_REPARSE
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_REPARSE)
define|#
directive|define
name|XAT_GEN
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_GEN)
define|#
directive|define
name|XAT_OFFLINE
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_OFFLINE)
define|#
directive|define
name|XAT_SPARSE
value|((XAT0_INDEX<< XVA_SHFT) | XAT0_SPARSE)
comment|/*  * The returned attribute map array (xva_rtnattrmap[]) is located past the  * requested attribute map array (xva_reqattrmap[]).  Its location changes  * when the array sizes change.  We use a separate pointer in a known location  * (xva_rtnattrmapp) to hold the location of xva_rtnattrmap[].  This is  * set in xva_init()  */
define|#
directive|define
name|XVA_RTNATTRMAP
parameter_list|(
name|xvap
parameter_list|)
value|((xvap)->xva_rtnattrmapp)
comment|/*  * XVA_SET_REQ() sets an attribute bit in the proper element in the bitmap  * of requested attributes (xva_reqattrmap[]).  */
define|#
directive|define
name|XVA_SET_REQ
parameter_list|(
name|xvap
parameter_list|,
name|attr
parameter_list|)
define|\
value|ASSERT((xvap)->xva_vattr.va_mask | AT_XVATTR);		\ 	ASSERT((xvap)->xva_magic == XVA_MAGIC);			\ 	(xvap)->xva_reqattrmap[XVA_INDEX(attr)] |= XVA_ATTRBIT(attr)
comment|/*  * XVA_CLR_REQ() clears an attribute bit in the proper element in the bitmap  * of requested attributes (xva_reqattrmap[]).  */
define|#
directive|define
name|XVA_CLR_REQ
parameter_list|(
name|xvap
parameter_list|,
name|attr
parameter_list|)
define|\
value|ASSERT((xvap)->xva_vattr.va_mask | AT_XVATTR);		\ 	ASSERT((xvap)->xva_magic == XVA_MAGIC);			\ 	(xvap)->xva_reqattrmap[XVA_INDEX(attr)]&= ~XVA_ATTRBIT(attr)
comment|/*  * XVA_SET_RTN() sets an attribute bit in the proper element in the bitmap  * of returned attributes (xva_rtnattrmap[]).  */
define|#
directive|define
name|XVA_SET_RTN
parameter_list|(
name|xvap
parameter_list|,
name|attr
parameter_list|)
define|\
value|ASSERT((xvap)->xva_vattr.va_mask | AT_XVATTR);		\ 	ASSERT((xvap)->xva_magic == XVA_MAGIC);			\ 	(XVA_RTNATTRMAP(xvap))[XVA_INDEX(attr)] |= XVA_ATTRBIT(attr)
comment|/*  * XVA_ISSET_REQ() checks the requested attribute bitmap (xva_reqattrmap[])  * to see of the corresponding attribute bit is set.  If so, returns non-zero.  */
define|#
directive|define
name|XVA_ISSET_REQ
parameter_list|(
name|xvap
parameter_list|,
name|attr
parameter_list|)
define|\
value|((((xvap)->xva_vattr.va_mask | AT_XVATTR)&&			\ 		((xvap)->xva_magic == XVA_MAGIC)&&			\ 		((xvap)->xva_mapsize> XVA_INDEX(attr))) ?		\ 	((xvap)->xva_reqattrmap[XVA_INDEX(attr)]& XVA_ATTRBIT(attr)) :	0)
comment|/*  * XVA_ISSET_RTN() checks the returned attribute bitmap (xva_rtnattrmap[])  * to see of the corresponding attribute bit is set.  If so, returns non-zero.  */
define|#
directive|define
name|XVA_ISSET_RTN
parameter_list|(
name|xvap
parameter_list|,
name|attr
parameter_list|)
define|\
value|((((xvap)->xva_vattr.va_mask | AT_XVATTR)&&			\ 		((xvap)->xva_magic == XVA_MAGIC)&&			\ 		((xvap)->xva_mapsize> XVA_INDEX(attr))) ?		\ 	((XVA_RTNATTRMAP(xvap))[XVA_INDEX(attr)]& XVA_ATTRBIT(attr)) : 0)
comment|/*  *  Modes.  Some values same as S_xxx entries from stat.h for convenience.  */
define|#
directive|define
name|VSUID
value|04000
comment|/* set user id on execution */
define|#
directive|define
name|VSGID
value|02000
comment|/* set group id on execution */
define|#
directive|define
name|VSVTX
value|01000
comment|/* save swapped text even after use */
comment|/*  * Permissions.  */
define|#
directive|define
name|VREAD
value|00400
define|#
directive|define
name|VWRITE
value|00200
define|#
directive|define
name|VEXEC
value|00100
define|#
directive|define
name|MODEMASK
value|07777
comment|/* mode bits plus permission bits */
define|#
directive|define
name|PERMMASK
value|00777
comment|/* permission bits */
comment|/*  * VOP_ACCESS flags  */
define|#
directive|define
name|V_ACE_MASK
value|0x1
comment|/* mask represents  NFSv4 ACE permissions */
define|#
directive|define
name|V_APPEND
value|0x2
comment|/* want to do append only check */
comment|/*  * Check whether mandatory file locking is enabled.  */
define|#
directive|define
name|MANDMODE
parameter_list|(
name|mode
parameter_list|)
value|(((mode)& (VSGID|(VEXEC>>3))) == VSGID)
define|#
directive|define
name|MANDLOCK
parameter_list|(
name|vp
parameter_list|,
name|mode
parameter_list|)
value|((vp)->v_type == VREG&& MANDMODE(mode))
comment|/*  * Flags for vnode operations.  */
enum|enum
name|rm
block|{
name|RMFILE
block|,
name|RMDIRECTORY
block|}
enum|;
comment|/* rm or rmdir (remove) */
enum|enum
name|symfollow
block|{
name|NO_FOLLOW
block|,
name|FOLLOW
block|}
enum|;
comment|/* follow symlinks (or not) */
enum|enum
name|vcexcl
block|{
name|NONEXCL
block|,
name|EXCL
block|}
enum|;
comment|/* (non)excl create */
enum|enum
name|create
block|{
name|CRCREAT
block|,
name|CRMKNOD
block|,
name|CRMKDIR
block|}
enum|;
comment|/* reason for create */
typedef|typedef
name|enum
name|rm
name|rm_t
typedef|;
typedef|typedef
name|enum
name|symfollow
name|symfollow_t
typedef|;
typedef|typedef
name|enum
name|vcexcl
name|vcexcl_t
typedef|;
typedef|typedef
name|enum
name|create
name|create_t
typedef|;
comment|/*  * Vnode Events - Used by VOP_VNEVENT  * The VE_PRE_RENAME_* events fire before the rename operation and are  * primarily used for specialized applications, such as NFSv4 delegation, which  * need to know about rename before it occurs.  */
typedef|typedef
enum|enum
name|vnevent
block|{
name|VE_SUPPORT
init|=
literal|0
block|,
comment|/* Query */
name|VE_RENAME_SRC
init|=
literal|1
block|,
comment|/* Rename, with vnode as source */
name|VE_RENAME_DEST
init|=
literal|2
block|,
comment|/* Rename, with vnode as target/destination */
name|VE_REMOVE
init|=
literal|3
block|,
comment|/* Remove of vnode's name */
name|VE_RMDIR
init|=
literal|4
block|,
comment|/* Remove of directory vnode's name */
name|VE_CREATE
init|=
literal|5
block|,
comment|/* Create with vnode's name which exists */
name|VE_LINK
init|=
literal|6
block|,
comment|/* Link with vnode's name as source */
name|VE_RENAME_DEST_DIR
init|=
literal|7
block|,
comment|/* Rename with vnode as target dir */
name|VE_MOUNTEDOVER
init|=
literal|8
block|,
comment|/* File or Filesystem got mounted over vnode */
name|VE_TRUNCATE
init|=
literal|9
block|,
comment|/* Truncate */
name|VE_PRE_RENAME_SRC
init|=
literal|10
block|,
comment|/* Pre-rename, with vnode as source */
name|VE_PRE_RENAME_DEST
init|=
literal|11
block|,
comment|/* Pre-rename, with vnode as target/dest. */
name|VE_PRE_RENAME_DEST_DIR
init|=
literal|12
comment|/* Pre-rename with vnode as target dir */
block|}
name|vnevent_t
typedef|;
comment|/*  * Values for checking vnode open and map counts  */
enum|enum
name|v_mode
block|{
name|V_READ
block|,
name|V_WRITE
block|,
name|V_RDORWR
block|,
name|V_RDANDWR
block|}
enum|;
typedef|typedef
name|enum
name|v_mode
name|v_mode_t
typedef|;
define|#
directive|define
name|V_TRUE
value|1
define|#
directive|define
name|V_FALSE
value|0
comment|/*  * Structure used on VOP_GETSECATTR and VOP_SETSECATTR operations  */
typedef|typedef
struct|struct
name|vsecattr
block|{
name|uint_t
name|vsa_mask
decl_stmt|;
comment|/* See below */
name|int
name|vsa_aclcnt
decl_stmt|;
comment|/* ACL entry count */
name|void
modifier|*
name|vsa_aclentp
decl_stmt|;
comment|/* pointer to ACL entries */
name|int
name|vsa_dfaclcnt
decl_stmt|;
comment|/* default ACL entry count */
name|void
modifier|*
name|vsa_dfaclentp
decl_stmt|;
comment|/* pointer to default ACL entries */
name|size_t
name|vsa_aclentsz
decl_stmt|;
comment|/* ACE size in bytes of vsa_aclentp */
name|uint_t
name|vsa_aclflags
decl_stmt|;
comment|/* ACE ACL flags */
block|}
name|vsecattr_t
typedef|;
comment|/* vsa_mask values */
define|#
directive|define
name|VSA_ACL
value|0x0001
define|#
directive|define
name|VSA_ACLCNT
value|0x0002
define|#
directive|define
name|VSA_DFACL
value|0x0004
define|#
directive|define
name|VSA_DFACLCNT
value|0x0008
define|#
directive|define
name|VSA_ACE
value|0x0010
define|#
directive|define
name|VSA_ACECNT
value|0x0020
define|#
directive|define
name|VSA_ACE_ALLTYPES
value|0x0040
define|#
directive|define
name|VSA_ACE_ACLFLAGS
value|0x0080
comment|/* get/set ACE ACL flags */
comment|/*  * Structure used by various vnode operations to determine  * the context (pid, host, identity) of a caller.  *  * The cc_caller_id is used to identify one or more callers who invoke  * operations, possibly on behalf of others.  For example, the NFS  * server could have it's own cc_caller_id which can be detected by  * vnode/vfs operations or (FEM) monitors on those operations.  New  * caller IDs are generated by fs_new_caller_id().  */
typedef|typedef
struct|struct
name|caller_context
block|{
name|pid_t
name|cc_pid
decl_stmt|;
comment|/* Process ID of the caller */
name|int
name|cc_sysid
decl_stmt|;
comment|/* System ID, used for remote calls */
name|u_longlong_t
name|cc_caller_id
decl_stmt|;
comment|/* Identifier for (set of) caller(s) */
name|ulong_t
name|cc_flags
decl_stmt|;
block|}
name|caller_context_t
typedef|;
comment|/*  * Flags for caller context.  The caller sets CC_DONTBLOCK if it does not  * want to block inside of a FEM monitor.  The monitor will set CC_WOULDBLOCK  * and return EAGAIN if the operation would have blocked.  */
define|#
directive|define
name|CC_WOULDBLOCK
value|0x01
define|#
directive|define
name|CC_DONTBLOCK
value|0x02
comment|/*  * Structure tags for function prototypes, defined elsewhere.  */
struct_decl|struct
name|pathname
struct_decl|;
struct_decl|struct
name|fid
struct_decl|;
struct_decl|struct
name|flock64
struct_decl|;
struct_decl|struct
name|flk_callback
struct_decl|;
struct_decl|struct
name|shrlock
struct_decl|;
struct_decl|struct
name|page
struct_decl|;
struct_decl|struct
name|seg
struct_decl|;
struct_decl|struct
name|as
struct_decl|;
struct_decl|struct
name|pollhead
struct_decl|;
struct_decl|struct
name|taskq
struct_decl|;
ifdef|#
directive|ifdef
name|_KERNEL
comment|/*  * VNODE_OPS defines all the vnode operations.  It is used to define  * the vnodeops structure (below) and the fs_func_p union (vfs_opreg.h).  */
define|#
directive|define
name|VNODE_OPS
define|\
value|int	(*vop_open)(vnode_t **, int, cred_t *,			\ 				caller_context_t *);			\ 	int	(*vop_close)(vnode_t *, int, int, offset_t, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_read)(vnode_t *, uio_t *, int, cred_t *,		\ 				caller_context_t *);			\ 	int	(*vop_write)(vnode_t *, uio_t *, int, cred_t *,		\ 				caller_context_t *);			\ 	int	(*vop_ioctl)(vnode_t *, int, intptr_t, int, cred_t *,	\ 				int *, caller_context_t *);		\ 	int	(*vop_setfl)(vnode_t *, int, int, cred_t *,		\ 				caller_context_t *);			\ 	int	(*vop_getattr)(vnode_t *, vattr_t *, int, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_setattr)(vnode_t *, vattr_t *, int, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_access)(vnode_t *, int, int, cred_t *,		\ 				caller_context_t *);			\ 	int	(*vop_lookup)(vnode_t *, char *, vnode_t **,		\ 				struct pathname *,			\ 				int, vnode_t *, cred_t *,		\ 				caller_context_t *, int *,		\ 				struct pathname *);			\ 	int	(*vop_create)(vnode_t *, char *, vattr_t *, vcexcl_t,	\ 				int, vnode_t **, cred_t *, int,		\ 				caller_context_t *, vsecattr_t *);	\ 	int	(*vop_remove)(vnode_t *, char *, cred_t *,		\ 				caller_context_t *, int);		\ 	int	(*vop_link)(vnode_t *, vnode_t *, char *, cred_t *,	\ 				caller_context_t *, int);		\ 	int	(*vop_rename)(vnode_t *, char *, vnode_t *, char *,	\ 				cred_t *, caller_context_t *, int);	\ 	int	(*vop_mkdir)(vnode_t *, char *, vattr_t *, vnode_t **,	\ 				cred_t *, caller_context_t *, int,	\ 				vsecattr_t *);				\ 	int	(*vop_rmdir)(vnode_t *, char *, vnode_t *, cred_t *,	\ 				caller_context_t *, int);		\ 	int	(*vop_readdir)(vnode_t *, uio_t *, cred_t *, int *,	\ 				caller_context_t *, int);		\ 	int	(*vop_symlink)(vnode_t *, char *, vattr_t *, char *,	\ 				cred_t *, caller_context_t *, int);	\ 	int	(*vop_readlink)(vnode_t *, uio_t *, cred_t *,		\ 				caller_context_t *);			\ 	int	(*vop_fsync)(vnode_t *, int, cred_t *,			\ 				caller_context_t *);			\ 	void	(*vop_inactive)(vnode_t *, cred_t *,			\ 				caller_context_t *);			\ 	int	(*vop_fid)(vnode_t *, struct fid *,			\ 				caller_context_t *);			\ 	int	(*vop_rwlock)(vnode_t *, int, caller_context_t *);	\ 	void	(*vop_rwunlock)(vnode_t *, int, caller_context_t *);	\ 	int	(*vop_seek)(vnode_t *, offset_t, offset_t *,		\ 				caller_context_t *);			\ 	int	(*vop_cmp)(vnode_t *, vnode_t *, caller_context_t *);	\ 	int	(*vop_frlock)(vnode_t *, int, struct flock64 *,		\ 				int, offset_t,				\ 				struct flk_callback *, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_space)(vnode_t *, int, struct flock64 *,		\ 				int, offset_t,				\ 				cred_t *, caller_context_t *);		\ 	int	(*vop_realvp)(vnode_t *, vnode_t **,			\ 				caller_context_t *);			\ 	int	(*vop_getpage)(vnode_t *, offset_t, size_t, uint_t *,	\ 				struct page **, size_t, struct seg *,	\ 				caddr_t, enum seg_rw, cred_t *,		\ 				caller_context_t *);			\ 	int	(*vop_putpage)(vnode_t *, offset_t, size_t,		\ 				int, cred_t *, caller_context_t *);	\ 	int	(*vop_map)(vnode_t *, offset_t, struct as *,		\ 				caddr_t *, size_t,			\ 				uchar_t, uchar_t, uint_t, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_addmap)(vnode_t *, offset_t, struct as *,		\ 				caddr_t, size_t,			\ 				uchar_t, uchar_t, uint_t, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_delmap)(vnode_t *, offset_t, struct as *,		\ 				caddr_t, size_t,			\ 				uint_t, uint_t, uint_t, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_poll)(vnode_t *, short, int, short *,		\ 				struct pollhead **,			\ 				caller_context_t *);			\ 	int	(*vop_dump)(vnode_t *, caddr_t, offset_t, offset_t,	\ 				caller_context_t *);			\ 	int	(*vop_pathconf)(vnode_t *, int, ulong_t *, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_pageio)(vnode_t *, struct page *,			\ 				u_offset_t, size_t, int, cred_t *,	\ 				caller_context_t *);			\ 	int	(*vop_dumpctl)(vnode_t *, int, offset_t *,		\ 				caller_context_t *);			\ 	void	(*vop_dispose)(vnode_t *, struct page *,		\ 				int, int, cred_t *,			\ 				caller_context_t *);			\ 	int	(*vop_setsecattr)(vnode_t *, vsecattr_t *,		\ 				int, cred_t *, caller_context_t *);	\ 	int	(*vop_getsecattr)(vnode_t *, vsecattr_t *,		\ 				int, cred_t *, caller_context_t *);	\ 	int	(*vop_shrlock)(vnode_t *, int, struct shrlock *,	\ 				int, cred_t *, caller_context_t *);	\ 	int	(*vop_vnevent)(vnode_t *, vnevent_t, vnode_t *,		\ 				char *, caller_context_t *);		\ 	int	(*vop_reqzcbuf)(vnode_t *, enum uio_rw, xuio_t *,	\ 				cred_t *, caller_context_t *);		\ 	int	(*vop_retzcbuf)(vnode_t *, xuio_t *, cred_t *,		\ 				caller_context_t *)
comment|/* NB: No ";" */
comment|/*  * Operations on vnodes.  Note: File systems must never operate directly  * on a 'vnodeops' structure -- it WILL change in future releases!  They  * must use vn_make_ops() to create the structure.  */
typedef|typedef
struct|struct
name|vnodeops
block|{
specifier|const
name|char
modifier|*
name|vnop_name
decl_stmt|;
name|VNODE_OPS
expr_stmt|;
comment|/* Signatures of all vnode operations (vops) */
block|}
name|vnodeops_t
typedef|;
typedef|typedef
name|int
function_decl|(
modifier|*
name|fs_generic_func_p
function_decl|)
parameter_list|()
function_decl|;
comment|/* Generic vop/vfsop/femop/fsemop ptr */
specifier|extern
name|int
name|fop_open
parameter_list|(
name|vnode_t
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_close
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|offset_t
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_read
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|uio_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_write
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|uio_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_ioctl
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|intptr_t
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_setfl
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_getattr
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vattr_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_setattr
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vattr_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_access
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_lookup
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|vnode_t
modifier|*
modifier|*
parameter_list|,
name|struct
name|pathname
modifier|*
parameter_list|,
name|int
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|struct
name|pathname
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_create
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|vattr_t
modifier|*
parameter_list|,
name|vcexcl_t
parameter_list|,
name|int
parameter_list|,
name|vnode_t
modifier|*
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|vsecattr_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_remove
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|,
name|char
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_link
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_rename
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_mkdir
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|vattr_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|vsecattr_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_rmdir
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_readdir
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|uio_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_symlink
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|vattr_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_readlink
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|uio_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_fsync
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|fop_inactive
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_fid
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|struct
name|fid
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_rwlock
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|fop_rwunlock
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_seek
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|offset_t
parameter_list|,
name|offset_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_cmp
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_frlock
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|flock64
modifier|*
parameter_list|,
name|int
parameter_list|,
name|offset_t
parameter_list|,
name|struct
name|flk_callback
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_space
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|flock64
modifier|*
parameter_list|,
name|int
parameter_list|,
name|offset_t
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_realvp
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_getpage
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|offset_t
parameter_list|,
name|size_t
parameter_list|,
name|uint_t
modifier|*
parameter_list|,
name|struct
name|page
modifier|*
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|struct
name|seg
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|enum
name|seg_rw
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_putpage
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|offset_t
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_map
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|offset_t
parameter_list|,
name|struct
name|as
modifier|*
parameter_list|,
name|caddr_t
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|uchar_t
parameter_list|,
name|uchar_t
parameter_list|,
name|uint_t
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_addmap
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|offset_t
parameter_list|,
name|struct
name|as
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|,
name|uchar_t
parameter_list|,
name|uchar_t
parameter_list|,
name|uint_t
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_delmap
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|offset_t
parameter_list|,
name|struct
name|as
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|size_t
parameter_list|,
name|uint_t
parameter_list|,
name|uint_t
parameter_list|,
name|uint_t
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_poll
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|short
parameter_list|,
name|int
parameter_list|,
name|short
modifier|*
parameter_list|,
name|struct
name|pollhead
modifier|*
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_dump
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|caddr_t
parameter_list|,
name|offset_t
parameter_list|,
name|offset_t
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_pathconf
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|ulong_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_pageio
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|struct
name|page
modifier|*
parameter_list|,
name|u_offset_t
parameter_list|,
name|size_t
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_dumpctl
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|offset_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|void
name|fop_dispose
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|struct
name|page
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_setsecattr
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vsecattr_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_getsecattr
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vsecattr_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_shrlock
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|,
name|struct
name|shrlock
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_vnevent
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnevent_t
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_reqzcbuf
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|enum
name|uio_rw
parameter_list|,
name|xuio_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
specifier|extern
name|int
name|fop_retzcbuf
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|xuio_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
endif|#
directive|endif
comment|/* _KERNEL */
define|#
directive|define
name|VOP_OPEN
parameter_list|(
name|vpp
parameter_list|,
name|mode
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_open(vpp, mode, cr, ct)
define|#
directive|define
name|VOP_CLOSE
parameter_list|(
name|vp
parameter_list|,
name|f
parameter_list|,
name|c
parameter_list|,
name|o
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_close(vp, f, c, o, cr, ct)
define|#
directive|define
name|VOP_READ
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|iof
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_read(vp, uiop, iof, cr, ct)
define|#
directive|define
name|VOP_WRITE
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|iof
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_write(vp, uiop, iof, cr, ct)
define|#
directive|define
name|VOP_IOCTL
parameter_list|(
name|vp
parameter_list|,
name|cmd
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|cr
parameter_list|,
name|rvp
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_ioctl(vp, cmd, a, f, cr, rvp, ct)
define|#
directive|define
name|VOP_SETFL
parameter_list|(
name|vp
parameter_list|,
name|f
parameter_list|,
name|a
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_setfl(vp, f, a, cr, ct)
define|#
directive|define
name|VOP_GETATTR
parameter_list|(
name|vp
parameter_list|,
name|vap
parameter_list|,
name|f
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_getattr(vp, vap, f, cr, ct)
define|#
directive|define
name|VOP_SETATTR
parameter_list|(
name|vp
parameter_list|,
name|vap
parameter_list|,
name|f
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_setattr(vp, vap, f, cr, ct)
define|#
directive|define
name|VOP_ACCESS
parameter_list|(
name|vp
parameter_list|,
name|mode
parameter_list|,
name|f
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_access(vp, mode, f, cr, ct)
define|#
directive|define
name|VOP_LOOKUP
parameter_list|(
name|vp
parameter_list|,
name|cp
parameter_list|,
name|vpp
parameter_list|,
name|pnp
parameter_list|,
name|f
parameter_list|,
name|rdir
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|,
name|defp
parameter_list|,
name|rpnp
parameter_list|)
define|\
value|fop_lookup(vp, cp, vpp, pnp, f, rdir, cr, ct, defp, rpnp)
define|#
directive|define
name|VOP_CREATE
parameter_list|(
name|dvp
parameter_list|,
name|p
parameter_list|,
name|vap
parameter_list|,
name|ex
parameter_list|,
name|mode
parameter_list|,
name|vpp
parameter_list|,
name|cr
parameter_list|,
name|flag
parameter_list|,
name|ct
parameter_list|,
name|vsap
parameter_list|)
define|\
value|fop_create(dvp, p, vap, ex, mode, vpp, cr, flag, ct, vsap)
define|#
directive|define
name|VOP_REMOVE
parameter_list|(
name|dvp
parameter_list|,
name|p
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|,
name|f
parameter_list|)
define|\
value|fop_remove(dvp, p, cr, ct, f)
define|#
directive|define
name|VOP_LINK
parameter_list|(
name|tdvp
parameter_list|,
name|fvp
parameter_list|,
name|p
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|,
name|f
parameter_list|)
define|\
value|fop_link(tdvp, fvp, p, cr, ct, f)
define|#
directive|define
name|VOP_RENAME
parameter_list|(
name|fvp
parameter_list|,
name|fnm
parameter_list|,
name|tdvp
parameter_list|,
name|tnm
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|,
name|f
parameter_list|)
define|\
value|fop_rename(fvp, fnm, tdvp, tnm, cr, ct, f)
define|#
directive|define
name|VOP_MKDIR
parameter_list|(
name|dp
parameter_list|,
name|p
parameter_list|,
name|vap
parameter_list|,
name|vpp
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|,
name|f
parameter_list|,
name|vsap
parameter_list|)
define|\
value|fop_mkdir(dp, p, vap, vpp, cr, ct, f, vsap)
define|#
directive|define
name|VOP_RMDIR
parameter_list|(
name|dp
parameter_list|,
name|p
parameter_list|,
name|cdir
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|,
name|f
parameter_list|)
define|\
value|fop_rmdir(dp, p, cdir, cr, ct, f)
define|#
directive|define
name|VOP_READDIR
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|cr
parameter_list|,
name|eofp
parameter_list|,
name|ct
parameter_list|,
name|f
parameter_list|)
define|\
value|fop_readdir(vp, uiop, cr, eofp, ct, f)
define|#
directive|define
name|VOP_SYMLINK
parameter_list|(
name|dvp
parameter_list|,
name|lnm
parameter_list|,
name|vap
parameter_list|,
name|tnm
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|,
name|f
parameter_list|)
define|\
value|fop_symlink(dvp, lnm, vap, tnm, cr, ct, f)
define|#
directive|define
name|VOP_READLINK
parameter_list|(
name|vp
parameter_list|,
name|uiop
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_readlink(vp, uiop, cr, ct)
define|#
directive|define
name|VOP_FSYNC
parameter_list|(
name|vp
parameter_list|,
name|syncflag
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_fsync(vp, syncflag, cr, ct)
define|#
directive|define
name|VOP_INACTIVE
parameter_list|(
name|vp
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_inactive(vp, cr, ct)
define|#
directive|define
name|VOP_FID
parameter_list|(
name|vp
parameter_list|,
name|fidp
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_fid(vp, fidp, ct)
define|#
directive|define
name|VOP_RWLOCK
parameter_list|(
name|vp
parameter_list|,
name|w
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_rwlock(vp, w, ct)
define|#
directive|define
name|VOP_RWUNLOCK
parameter_list|(
name|vp
parameter_list|,
name|w
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_rwunlock(vp, w, ct)
define|#
directive|define
name|VOP_SEEK
parameter_list|(
name|vp
parameter_list|,
name|ooff
parameter_list|,
name|noffp
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_seek(vp, ooff, noffp, ct)
define|#
directive|define
name|VOP_CMP
parameter_list|(
name|vp1
parameter_list|,
name|vp2
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_cmp(vp1, vp2, ct)
define|#
directive|define
name|VOP_FRLOCK
parameter_list|(
name|vp
parameter_list|,
name|cmd
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|,
name|cb
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_frlock(vp, cmd, a, f, o, cb, cr, ct)
define|#
directive|define
name|VOP_SPACE
parameter_list|(
name|vp
parameter_list|,
name|cmd
parameter_list|,
name|a
parameter_list|,
name|f
parameter_list|,
name|o
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_space(vp, cmd, a, f, o, cr, ct)
define|#
directive|define
name|VOP_REALVP
parameter_list|(
name|vp1
parameter_list|,
name|vp2
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_realvp(vp1, vp2, ct)
define|#
directive|define
name|VOP_GETPAGE
parameter_list|(
name|vp
parameter_list|,
name|of
parameter_list|,
name|sz
parameter_list|,
name|pr
parameter_list|,
name|pl
parameter_list|,
name|ps
parameter_list|,
name|sg
parameter_list|,
name|a
parameter_list|,
name|rw
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_getpage(vp, of, sz, pr, pl, ps, sg, a, rw, cr, ct)
define|#
directive|define
name|VOP_PUTPAGE
parameter_list|(
name|vp
parameter_list|,
name|of
parameter_list|,
name|sz
parameter_list|,
name|fl
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_putpage(vp, of, sz, fl, cr, ct)
define|#
directive|define
name|VOP_MAP
parameter_list|(
name|vp
parameter_list|,
name|of
parameter_list|,
name|as
parameter_list|,
name|a
parameter_list|,
name|sz
parameter_list|,
name|p
parameter_list|,
name|mp
parameter_list|,
name|fl
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_map(vp, of, as, a, sz, p, mp, fl, cr, ct)
define|#
directive|define
name|VOP_ADDMAP
parameter_list|(
name|vp
parameter_list|,
name|of
parameter_list|,
name|as
parameter_list|,
name|a
parameter_list|,
name|sz
parameter_list|,
name|p
parameter_list|,
name|mp
parameter_list|,
name|fl
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_addmap(vp, of, as, a, sz, p, mp, fl, cr, ct)
define|#
directive|define
name|VOP_DELMAP
parameter_list|(
name|vp
parameter_list|,
name|of
parameter_list|,
name|as
parameter_list|,
name|a
parameter_list|,
name|sz
parameter_list|,
name|p
parameter_list|,
name|mp
parameter_list|,
name|fl
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_delmap(vp, of, as, a, sz, p, mp, fl, cr, ct)
define|#
directive|define
name|VOP_POLL
parameter_list|(
name|vp
parameter_list|,
name|events
parameter_list|,
name|anyyet
parameter_list|,
name|reventsp
parameter_list|,
name|phpp
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_poll(vp, events, anyyet, reventsp, phpp, ct)
define|#
directive|define
name|VOP_DUMP
parameter_list|(
name|vp
parameter_list|,
name|addr
parameter_list|,
name|bn
parameter_list|,
name|count
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_dump(vp, addr, bn, count, ct)
define|#
directive|define
name|VOP_PATHCONF
parameter_list|(
name|vp
parameter_list|,
name|cmd
parameter_list|,
name|valp
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_pathconf(vp, cmd, valp, cr, ct)
define|#
directive|define
name|VOP_PAGEIO
parameter_list|(
name|vp
parameter_list|,
name|pp
parameter_list|,
name|io_off
parameter_list|,
name|io_len
parameter_list|,
name|flags
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_pageio(vp, pp, io_off, io_len, flags, cr, ct)
define|#
directive|define
name|VOP_DUMPCTL
parameter_list|(
name|vp
parameter_list|,
name|action
parameter_list|,
name|blkp
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_dumpctl(vp, action, blkp, ct)
define|#
directive|define
name|VOP_DISPOSE
parameter_list|(
name|vp
parameter_list|,
name|pp
parameter_list|,
name|flag
parameter_list|,
name|dn
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_dispose(vp, pp, flag, dn, cr, ct)
define|#
directive|define
name|VOP_GETSECATTR
parameter_list|(
name|vp
parameter_list|,
name|vsap
parameter_list|,
name|f
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_getsecattr(vp, vsap, f, cr, ct)
define|#
directive|define
name|VOP_SETSECATTR
parameter_list|(
name|vp
parameter_list|,
name|vsap
parameter_list|,
name|f
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_setsecattr(vp, vsap, f, cr, ct)
define|#
directive|define
name|VOP_SHRLOCK
parameter_list|(
name|vp
parameter_list|,
name|cmd
parameter_list|,
name|shr
parameter_list|,
name|f
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_shrlock(vp, cmd, shr, f, cr, ct)
define|#
directive|define
name|VOP_VNEVENT
parameter_list|(
name|vp
parameter_list|,
name|vnevent
parameter_list|,
name|dvp
parameter_list|,
name|fnm
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_vnevent(vp, vnevent, dvp, fnm, ct)
define|#
directive|define
name|VOP_REQZCBUF
parameter_list|(
name|vp
parameter_list|,
name|rwflag
parameter_list|,
name|xuiop
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_reqzcbuf(vp, rwflag, xuiop, cr, ct)
define|#
directive|define
name|VOP_RETZCBUF
parameter_list|(
name|vp
parameter_list|,
name|xuiop
parameter_list|,
name|cr
parameter_list|,
name|ct
parameter_list|)
define|\
value|fop_retzcbuf(vp, xuiop, cr, ct)
define|#
directive|define
name|VOPNAME_OPEN
value|"open"
define|#
directive|define
name|VOPNAME_CLOSE
value|"close"
define|#
directive|define
name|VOPNAME_READ
value|"read"
define|#
directive|define
name|VOPNAME_WRITE
value|"write"
define|#
directive|define
name|VOPNAME_IOCTL
value|"ioctl"
define|#
directive|define
name|VOPNAME_SETFL
value|"setfl"
define|#
directive|define
name|VOPNAME_GETATTR
value|"getattr"
define|#
directive|define
name|VOPNAME_SETATTR
value|"setattr"
define|#
directive|define
name|VOPNAME_ACCESS
value|"access"
define|#
directive|define
name|VOPNAME_LOOKUP
value|"lookup"
define|#
directive|define
name|VOPNAME_CREATE
value|"create"
define|#
directive|define
name|VOPNAME_REMOVE
value|"remove"
define|#
directive|define
name|VOPNAME_LINK
value|"link"
define|#
directive|define
name|VOPNAME_RENAME
value|"rename"
define|#
directive|define
name|VOPNAME_MKDIR
value|"mkdir"
define|#
directive|define
name|VOPNAME_RMDIR
value|"rmdir"
define|#
directive|define
name|VOPNAME_READDIR
value|"readdir"
define|#
directive|define
name|VOPNAME_SYMLINK
value|"symlink"
define|#
directive|define
name|VOPNAME_READLINK
value|"readlink"
define|#
directive|define
name|VOPNAME_FSYNC
value|"fsync"
define|#
directive|define
name|VOPNAME_INACTIVE
value|"inactive"
define|#
directive|define
name|VOPNAME_FID
value|"fid"
define|#
directive|define
name|VOPNAME_RWLOCK
value|"rwlock"
define|#
directive|define
name|VOPNAME_RWUNLOCK
value|"rwunlock"
define|#
directive|define
name|VOPNAME_SEEK
value|"seek"
define|#
directive|define
name|VOPNAME_CMP
value|"cmp"
define|#
directive|define
name|VOPNAME_FRLOCK
value|"frlock"
define|#
directive|define
name|VOPNAME_SPACE
value|"space"
define|#
directive|define
name|VOPNAME_REALVP
value|"realvp"
define|#
directive|define
name|VOPNAME_GETPAGE
value|"getpage"
define|#
directive|define
name|VOPNAME_PUTPAGE
value|"putpage"
define|#
directive|define
name|VOPNAME_MAP
value|"map"
define|#
directive|define
name|VOPNAME_ADDMAP
value|"addmap"
define|#
directive|define
name|VOPNAME_DELMAP
value|"delmap"
define|#
directive|define
name|VOPNAME_POLL
value|"poll"
define|#
directive|define
name|VOPNAME_DUMP
value|"dump"
define|#
directive|define
name|VOPNAME_PATHCONF
value|"pathconf"
define|#
directive|define
name|VOPNAME_PAGEIO
value|"pageio"
define|#
directive|define
name|VOPNAME_DUMPCTL
value|"dumpctl"
define|#
directive|define
name|VOPNAME_DISPOSE
value|"dispose"
define|#
directive|define
name|VOPNAME_GETSECATTR
value|"getsecattr"
define|#
directive|define
name|VOPNAME_SETSECATTR
value|"setsecattr"
define|#
directive|define
name|VOPNAME_SHRLOCK
value|"shrlock"
define|#
directive|define
name|VOPNAME_VNEVENT
value|"vnevent"
define|#
directive|define
name|VOPNAME_REQZCBUF
value|"reqzcbuf"
define|#
directive|define
name|VOPNAME_RETZCBUF
value|"retzcbuf"
comment|/*  * Flags for VOP_LOOKUP  *  * Defined in file.h, but also possible, FIGNORECASE and FSEARCH  *  */
define|#
directive|define
name|LOOKUP_DIR
value|0x01
comment|/* want parent dir vp */
define|#
directive|define
name|LOOKUP_XATTR
value|0x02
comment|/* lookup up extended attr dir */
define|#
directive|define
name|CREATE_XATTR_DIR
value|0x04
comment|/* Create extended attr dir */
define|#
directive|define
name|LOOKUP_HAVE_SYSATTR_DIR
value|0x08
comment|/* Already created virtual GFS dir */
comment|/*  * Flags for VOP_READDIR  */
define|#
directive|define
name|V_RDDIR_ENTFLAGS
value|0x01
comment|/* request dirent flags */
define|#
directive|define
name|V_RDDIR_ACCFILTER
value|0x02
comment|/* filter out inaccessible dirents */
comment|/*  * Flags for VOP_RWLOCK/VOP_RWUNLOCK  * VOP_RWLOCK will return the flag that was actually set, or -1 if none.  */
define|#
directive|define
name|V_WRITELOCK_TRUE
value|(1)
comment|/* Request write-lock on the vnode */
define|#
directive|define
name|V_WRITELOCK_FALSE
value|(0)
comment|/* Request read-lock on the vnode */
comment|/*  * Flags for VOP_DUMPCTL  */
define|#
directive|define
name|DUMP_ALLOC
value|0
define|#
directive|define
name|DUMP_FREE
value|1
define|#
directive|define
name|DUMP_SCAN
value|2
comment|/*  * Public vnode manipulation functions.  */
ifdef|#
directive|ifdef
name|_KERNEL
name|vnode_t
modifier|*
name|vn_alloc
parameter_list|(
name|int
parameter_list|)
function_decl|;
name|void
name|vn_reinit
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vn_recycle
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vn_free
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vn_is_readonly
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vn_is_opened
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|v_mode_t
parameter_list|)
function_decl|;
name|int
name|vn_is_mapped
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|v_mode_t
parameter_list|)
function_decl|;
name|int
name|vn_has_other_opens
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|v_mode_t
parameter_list|)
function_decl|;
name|void
name|vn_open_upgrade
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|void
name|vn_open_downgrade
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
name|vn_can_change_zones
parameter_list|(
name|vnode_t
modifier|*
name|vp
parameter_list|)
function_decl|;
name|int
name|vn_has_flocks
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vn_has_mandatory_locks
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
name|int
name|vn_has_cached_data
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vn_setops
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnodeops_t
modifier|*
parameter_list|)
function_decl|;
name|vnodeops_t
modifier|*
name|vn_getops
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vn_matchops
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnodeops_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vn_matchopval
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|fs_generic_func_p
parameter_list|)
function_decl|;
name|int
name|vn_ismntpt
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|struct
name|vfs
modifier|*
name|vn_mountedvfs
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vn_in_dnlc
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vn_create_cache
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|vn_destroy_cache
parameter_list|(
name|void
parameter_list|)
function_decl|;
name|void
name|vn_freevnodeops
parameter_list|(
name|vnodeops_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vn_open
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|int
name|filemode
parameter_list|,
name|int
name|createmode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|crwhy
parameter_list|,
name|mode_t
name|umask
parameter_list|)
function_decl|;
name|int
name|vn_openat
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|int
name|filemode
parameter_list|,
name|int
name|createmode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|crwhy
parameter_list|,
name|mode_t
name|umask
parameter_list|,
name|struct
name|vnode
modifier|*
name|startvp
parameter_list|,
name|int
name|fd
parameter_list|)
function_decl|;
name|int
name|vn_create
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|enum
name|vcexcl
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|why
parameter_list|,
name|int
name|flag
parameter_list|,
name|mode_t
name|umask
parameter_list|)
function_decl|;
name|int
name|vn_createat
parameter_list|(
name|char
modifier|*
name|pnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|struct
name|vattr
modifier|*
name|vap
parameter_list|,
name|enum
name|vcexcl
name|excl
parameter_list|,
name|int
name|mode
parameter_list|,
name|struct
name|vnode
modifier|*
modifier|*
name|vpp
parameter_list|,
name|enum
name|create
name|why
parameter_list|,
name|int
name|flag
parameter_list|,
name|mode_t
name|umask
parameter_list|,
name|struct
name|vnode
modifier|*
name|startvp
parameter_list|)
function_decl|;
name|int
name|vn_rdwr
parameter_list|(
name|enum
name|uio_rw
name|rw
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|caddr_t
name|base
parameter_list|,
name|ssize_t
name|len
parameter_list|,
name|offset_t
name|offset
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|int
name|ioflag
parameter_list|,
name|rlim64_t
name|ulimit
parameter_list|,
name|cred_t
modifier|*
name|cr
parameter_list|,
name|ssize_t
modifier|*
name|residp
parameter_list|)
function_decl|;
name|void
name|vn_rele
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|void
name|vn_rele_async
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|struct
name|taskq
modifier|*
name|taskq
parameter_list|)
function_decl|;
name|void
name|vn_rele_dnlc
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|void
name|vn_rele_stream
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|int
name|vn_link
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
function_decl|;
name|int
name|vn_linkat
parameter_list|(
name|vnode_t
modifier|*
name|fstartvp
parameter_list|,
name|char
modifier|*
name|from
parameter_list|,
name|enum
name|symfollow
name|follow
parameter_list|,
name|vnode_t
modifier|*
name|tstartvp
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
function_decl|;
name|int
name|vn_rename
parameter_list|(
name|char
modifier|*
name|from
parameter_list|,
name|char
modifier|*
name|to
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
function_decl|;
name|int
name|vn_renameat
parameter_list|(
name|vnode_t
modifier|*
name|fdvp
parameter_list|,
name|char
modifier|*
name|fname
parameter_list|,
name|vnode_t
modifier|*
name|tdvp
parameter_list|,
name|char
modifier|*
name|tname
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|)
function_decl|;
name|int
name|vn_remove
parameter_list|(
name|char
modifier|*
name|fnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|enum
name|rm
name|dirflag
parameter_list|)
function_decl|;
name|int
name|vn_removeat
parameter_list|(
name|vnode_t
modifier|*
name|startvp
parameter_list|,
name|char
modifier|*
name|fnamep
parameter_list|,
name|enum
name|uio_seg
name|seg
parameter_list|,
name|enum
name|rm
name|dirflag
parameter_list|)
function_decl|;
name|int
name|vn_compare
parameter_list|(
name|vnode_t
modifier|*
name|vp1
parameter_list|,
name|vnode_t
modifier|*
name|vp2
parameter_list|)
function_decl|;
name|int
name|vn_vfswlock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|int
name|vn_vfswlock_wait
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|int
name|vn_vfsrlock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|int
name|vn_vfsrlock_wait
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|void
name|vn_vfsunlock
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|int
name|vn_vfswlock_held
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|)
function_decl|;
name|vnode_t
modifier|*
name|specvp
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
name|dev_t
name|dev
parameter_list|,
name|vtype_t
name|type
parameter_list|,
name|struct
name|cred
modifier|*
name|cr
parameter_list|)
function_decl|;
name|vnode_t
modifier|*
name|makespecvp
parameter_list|(
name|dev_t
name|dev
parameter_list|,
name|vtype_t
name|type
parameter_list|)
function_decl|;
name|vn_vfslocks_entry_t
modifier|*
name|vn_vfslocks_getlock
parameter_list|(
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
name|vn_vfslocks_rele
parameter_list|(
name|vn_vfslocks_entry_t
modifier|*
parameter_list|)
function_decl|;
name|boolean_t
name|vn_is_reparse
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|cred_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vn_copypath
parameter_list|(
name|struct
name|vnode
modifier|*
name|src
parameter_list|,
name|struct
name|vnode
modifier|*
name|dst
parameter_list|)
function_decl|;
name|void
name|vn_setpath_str
parameter_list|(
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
name|void
name|vn_setpath
parameter_list|(
name|vnode_t
modifier|*
name|rootvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|startvp
parameter_list|,
name|struct
name|vnode
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|path
parameter_list|,
name|size_t
name|plen
parameter_list|)
function_decl|;
name|void
name|vn_renamepath
parameter_list|(
name|vnode_t
modifier|*
name|dvp
parameter_list|,
name|vnode_t
modifier|*
name|vp
parameter_list|,
specifier|const
name|char
modifier|*
name|nm
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
comment|/* Vnode event notification */
name|void
name|vnevent_rename_src
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_rename_dest
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_remove
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_rmdir
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_create
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_link
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_rename_dest_dir
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
name|ct
parameter_list|)
function_decl|;
name|void
name|vnevent_mountedover
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_truncate
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|int
name|vnevent_support
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_pre_rename_src
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_pre_rename_dest
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
name|void
name|vnevent_pre_rename_dest_dir
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|caller_context_t
modifier|*
parameter_list|)
function_decl|;
comment|/* Vnode specific data */
name|void
name|vsd_create
parameter_list|(
name|uint_t
modifier|*
parameter_list|,
name|void
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|)
parameter_list|)
function_decl|;
name|void
name|vsd_destroy
parameter_list|(
name|uint_t
modifier|*
parameter_list|)
function_decl|;
name|void
modifier|*
name|vsd_get
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|)
function_decl|;
name|int
name|vsd_set
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|uint_t
parameter_list|,
name|void
modifier|*
parameter_list|)
function_decl|;
name|void
name|vsd_free
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Extensible vnode attribute (xva) routines:  * xva_init() initializes an xvattr_t (zero struct, init mapsize, set AT_XATTR)  * xva_getxoptattr() returns a ponter to the xoptattr_t section of xvattr_t  */
name|void
name|xva_init
parameter_list|(
name|xvattr_t
modifier|*
parameter_list|)
function_decl|;
name|xoptattr_t
modifier|*
name|xva_getxoptattr
parameter_list|(
name|xvattr_t
modifier|*
parameter_list|)
function_decl|;
comment|/* Get ptr to xoptattr_t */
name|void
name|xattr_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Initialize vnodeops for xattrs */
comment|/* GFS tunnel for xattrs */
name|int
name|xattr_dir_lookup
parameter_list|(
name|vnode_t
modifier|*
parameter_list|,
name|vnode_t
modifier|*
modifier|*
parameter_list|,
name|int
parameter_list|,
name|cred_t
modifier|*
parameter_list|)
function_decl|;
comment|/* Reparse Point */
name|void
name|reparse_point_init
parameter_list|(
name|void
parameter_list|)
function_decl|;
comment|/* Context identification */
name|u_longlong_t
name|fs_new_caller_id
parameter_list|()
function_decl|;
name|int
name|vn_vmpss_usepageio
parameter_list|(
name|vnode_t
modifier|*
parameter_list|)
function_decl|;
comment|/*  * Needed for use of IS_VMODSORT() in kernel.  */
specifier|extern
name|uint_t
name|pvn_vmodsort_supported
decl_stmt|;
define|#
directive|define
name|VN_HOLD
parameter_list|(
name|vp
parameter_list|)
value|{ \ 	mutex_enter(&(vp)->v_lock); \ 	(vp)->v_count++; \ 	mutex_exit(&(vp)->v_lock); \ }
define|#
directive|define
name|VN_RELE
parameter_list|(
name|vp
parameter_list|)
value|{ \ 	vn_rele(vp); \ }
define|#
directive|define
name|VN_RELE_ASYNC
parameter_list|(
name|vp
parameter_list|,
name|taskq
parameter_list|)
value|{ \ 	vn_rele_async(vp, taskq); \ }
define|#
directive|define
name|VN_SET_VFS_TYPE_DEV
parameter_list|(
name|vp
parameter_list|,
name|vfsp
parameter_list|,
name|type
parameter_list|,
name|dev
parameter_list|)
value|{ \ 	(vp)->v_vfsp = (vfsp); \ 	(vp)->v_type = (type); \ 	(vp)->v_rdev = (dev); \ }
comment|/*  * Compare two vnodes for equality.  In general this macro should be used  * in preference to calling VOP_CMP directly.  */
define|#
directive|define
name|VN_CMP
parameter_list|(
name|VP1
parameter_list|,
name|VP2
parameter_list|)
value|((VP1) == (VP2) ? 1 : 	\ 	((VP1)&& (VP2)&& (vn_getops(VP1) == vn_getops(VP2)) ? \ 	VOP_CMP(VP1, VP2, NULL) : 0))
comment|/*  * Some well-known global vnodes used by the VM system to name pages.  */
specifier|extern
name|struct
name|vnode
name|kvps
index|[]
decl_stmt|;
typedef|typedef
enum|enum
block|{
name|KV_KVP
block|,
comment|/* vnode for all segkmem pages */
name|KV_ZVP
block|,
comment|/* vnode for all ZFS pages */
if|#
directive|if
name|defined
argument_list|(
name|__sparc
argument_list|)
name|KV_MPVP
block|,
comment|/* vnode for all page_t meta-pages */
name|KV_PROMVP
block|,
comment|/* vnode for all PROM pages */
endif|#
directive|endif
comment|/* __sparc */
name|KV_MAX
comment|/* total number of vnodes in kvps[] */
block|}
name|kvps_index_t
typedef|;
define|#
directive|define
name|VN_ISKAS
parameter_list|(
name|vp
parameter_list|)
value|((vp)>=&kvps[0]&& (vp)<&kvps[KV_MAX])
endif|#
directive|endif
comment|/* _KERNEL */
comment|/*  * Flags to VOP_SETATTR/VOP_GETATTR.  */
define|#
directive|define
name|ATTR_UTIME
value|0x01
comment|/* non-default utime(2) request */
define|#
directive|define
name|ATTR_EXEC
value|0x02
comment|/* invocation from exec(2) */
define|#
directive|define
name|ATTR_COMM
value|0x04
comment|/* yield common vp attributes */
define|#
directive|define
name|ATTR_HINT
value|0x08
comment|/* information returned will be `hint' */
define|#
directive|define
name|ATTR_REAL
value|0x10
comment|/* yield attributes of the real vp */
define|#
directive|define
name|ATTR_NOACLCHECK
value|0x20
comment|/* Don't check ACL when checking permissions */
define|#
directive|define
name|ATTR_TRIGGER
value|0x40
comment|/* Mount first if vnode is a trigger mount */
comment|/*  * Generally useful macros.  */
define|#
directive|define
name|VBSIZE
parameter_list|(
name|vp
parameter_list|)
value|((vp)->v_vfsp->vfs_bsize)
define|#
directive|define
name|VTOZONE
parameter_list|(
name|vp
parameter_list|)
value|((vp)->v_vfsp->vfs_zone)
define|#
directive|define
name|NULLVP
value|((struct vnode *)0)
define|#
directive|define
name|NULLVPP
value|((struct vnode **)0)
ifdef|#
directive|ifdef
name|_KERNEL
comment|/*  * Structure used while handling asynchronous VOP_PUTPAGE operations.  */
struct|struct
name|async_reqs
block|{
name|struct
name|async_reqs
modifier|*
name|a_next
decl_stmt|;
comment|/* pointer to next arg struct */
name|struct
name|vnode
modifier|*
name|a_vp
decl_stmt|;
comment|/* vnode pointer */
name|u_offset_t
name|a_off
decl_stmt|;
comment|/* offset in file */
name|uint_t
name|a_len
decl_stmt|;
comment|/* size of i/o request */
name|int
name|a_flags
decl_stmt|;
comment|/* flags to indicate operation type */
name|struct
name|cred
modifier|*
name|a_cred
decl_stmt|;
comment|/* cred pointer	*/
name|ushort_t
name|a_prealloced
decl_stmt|;
comment|/* set if struct is pre-allocated */
block|}
struct|;
comment|/*  * VN_DISPOSE() -- given a page pointer, safely invoke VOP_DISPOSE().  * Note that there is no guarantee that the page passed in will be  * freed.  If that is required, then a check after calling VN_DISPOSE would  * be necessary to ensure the page was freed.  */
define|#
directive|define
name|VN_DISPOSE
parameter_list|(
name|pp
parameter_list|,
name|flag
parameter_list|,
name|dn
parameter_list|,
name|cr
parameter_list|)
value|{ \ 	if ((pp)->p_vnode != NULL&& !VN_ISKAS((pp)->p_vnode)) \ 		VOP_DISPOSE((pp)->p_vnode, (pp), (flag), (dn), (cr), NULL); \ 	else if ((flag) == B_FREE) \ 		page_free((pp), (dn)); \ 	else \ 		page_destroy((pp), (dn)); \ 	}
endif|#
directive|endif
comment|/* _KERNEL */
ifdef|#
directive|ifdef
name|__cplusplus
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* _SYS_VNODE_H */
end_comment

end_unit

