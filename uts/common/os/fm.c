begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright (c) 2004, 2010, Oracle and/or its affiliates. All rights reserved.  */
end_comment

begin_comment
comment|/*  * Fault Management Architecture (FMA) Resource and Protocol Support  *  * The routines contained herein provide services to support kernel subsystems  * in publishing fault management telemetry (see PSARC 2002/412 and 2003/089).  *  * Name-Value Pair Lists  *  * The embodiment of an FMA protocol element (event, fmri or authority) is a  * name-value pair list (nvlist_t).  FMA-specific nvlist construtor and  * destructor functions, fm_nvlist_create() and fm_nvlist_destroy(), are used  * to create an nvpair list using custom allocators.  Callers may choose to  * allocate either from the kernel memory allocator, or from a preallocated  * buffer, useful in constrained contexts like high-level interrupt routines.  *  * Protocol Event and FMRI Construction  *  * Convenience routines are provided to construct nvlist events according to  * the FMA Event Protocol and Naming Schema specification for ereports and  * FMRIs for the dev, cpu, hc, mem, legacy hc and de schemes.  *  * ENA Manipulation  *  * Routines to generate ENA formats 0, 1 and 2 are available as well as  * routines to increment formats 1 and 2.  Individual fields within the  * ENA are extractable via fm_ena_time_get(), fm_ena_id_get(),  * fm_ena_format_get() and fm_ena_gen_get().  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysevent.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysevent_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/nvpair.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddifm.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddifm_impl.h>
end_include

begin_include
include|#
directive|include
file|<sys/spl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dumphdr.h>
end_include

begin_include
include|#
directive|include
file|<sys/compress.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/console.h>
end_include

begin_include
include|#
directive|include
file|<sys/panic.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/sunddi.h>
end_include

begin_include
include|#
directive|include
file|<sys/systeminfo.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysevent/eventdefs.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/util.h>
end_include

begin_include
include|#
directive|include
file|<sys/fm/protocol.h>
end_include

begin_comment
comment|/*  * URL and SUNW-MSG-ID value to display for fm_panic(), defined below.  These  * values must be kept in sync with the FMA source code in usr/src/cmd/fm.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fm_url
init|=
literal|"http://illumos.org/msg"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|fm_msgid
init|=
literal|"SUNOS-8000-0G"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
specifier|volatile
name|fm_panicstr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|errorq_t
modifier|*
name|ereport_errorq
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
modifier|*
name|ereport_dumpbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|size_t
name|ereport_dumplen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|uint_t
name|ereport_chanlen
init|=
name|ERPT_EVCH_MAX
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|evchan_t
modifier|*
name|ereport_chan
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|ulong_t
name|ereport_qlen
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|size_t
name|ereport_size
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|ereport_cols
init|=
literal|80
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|void
name|fastreboot_disable_highpil
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Common fault management kstats to record ereport generation  * failures  */
end_comment

begin_struct
struct|struct
name|erpt_kstat
block|{
name|kstat_named_t
name|erpt_dropped
decl_stmt|;
comment|/* num erpts dropped on post */
name|kstat_named_t
name|erpt_set_failed
decl_stmt|;
comment|/* num erpt set failures */
name|kstat_named_t
name|fmri_set_failed
decl_stmt|;
comment|/* num fmri set failures */
name|kstat_named_t
name|payload_set_failed
decl_stmt|;
comment|/* num payload set failures */
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|erpt_kstat
name|erpt_kstat_data
init|=
block|{
block|{
literal|"erpt-dropped"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"erpt-set-failed"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"fmri-set-failed"
block|,
name|KSTAT_DATA_UINT64
block|}
block|,
block|{
literal|"payload-set-failed"
block|,
name|KSTAT_DATA_UINT64
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
specifier|static
name|void
name|fm_drain
parameter_list|(
name|void
modifier|*
name|private
parameter_list|,
name|void
modifier|*
name|data
parameter_list|,
name|errorq_elem_t
modifier|*
name|eep
parameter_list|)
block|{
name|nvlist_t
modifier|*
name|nvl
init|=
name|errorq_elem_nvl
argument_list|(
name|ereport_errorq
argument_list|,
name|eep
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|panicstr
condition|)
operator|(
name|void
operator|)
name|fm_ereport_post
argument_list|(
name|nvl
argument_list|,
name|EVCH_TRYHARD
argument_list|)
expr_stmt|;
else|else
name|fm_nvprint
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fm_init
parameter_list|(
name|void
parameter_list|)
block|{
name|kstat_t
modifier|*
name|ksp
decl_stmt|;
operator|(
name|void
operator|)
name|sysevent_evc_bind
argument_list|(
name|FM_ERROR_CHAN
argument_list|,
operator|&
name|ereport_chan
argument_list|,
name|EVCH_CREAT
operator||
name|EVCH_HOLD_PEND
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysevent_evc_control
argument_list|(
name|ereport_chan
argument_list|,
name|EVCH_SET_CHAN_LEN
argument_list|,
operator|&
name|ereport_chanlen
argument_list|)
expr_stmt|;
if|if
condition|(
name|ereport_qlen
operator|==
literal|0
condition|)
name|ereport_qlen
operator|=
name|ERPT_MAX_ERRS
operator|*
name|MAX
argument_list|(
name|max_ncpus
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|ereport_size
operator|==
literal|0
condition|)
name|ereport_size
operator|=
name|ERPT_DATA_SZ
expr_stmt|;
name|ereport_errorq
operator|=
name|errorq_nvcreate
argument_list|(
literal|"fm_ereport_queue"
argument_list|,
operator|(
name|errorq_func_t
operator|)
name|fm_drain
argument_list|,
name|NULL
argument_list|,
name|ereport_qlen
argument_list|,
name|ereport_size
argument_list|,
name|FM_ERR_PIL
argument_list|,
name|ERRORQ_VITAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ereport_errorq
operator|==
name|NULL
condition|)
name|panic
argument_list|(
literal|"failed to create required ereport error queue"
argument_list|)
expr_stmt|;
name|ereport_dumpbuf
operator|=
name|kmem_alloc
argument_list|(
name|ereport_size
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
name|ereport_dumplen
operator|=
name|ereport_size
expr_stmt|;
comment|/* Initialize ereport allocation and generation kstats */
name|ksp
operator|=
name|kstat_create
argument_list|(
literal|"unix"
argument_list|,
literal|0
argument_list|,
literal|"fm"
argument_list|,
literal|"misc"
argument_list|,
name|KSTAT_TYPE_NAMED
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|erpt_kstat
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|kstat_named_t
argument_list|)
argument_list|,
name|KSTAT_FLAG_VIRTUAL
argument_list|)
expr_stmt|;
if|if
condition|(
name|ksp
operator|!=
name|NULL
condition|)
block|{
name|ksp
operator|->
name|ks_data
operator|=
operator|&
name|erpt_kstat_data
expr_stmt|;
name|kstat_install
argument_list|(
name|ksp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"failed to create fm/misc kstat\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Formatting utility function for fm_nvprintr.  We attempt to wrap chunks of  * output so they aren't split across console lines, and return the end column.  */
end_comment

begin_comment
comment|/*PRINTFLIKE4*/
end_comment

begin_function
specifier|static
name|int
name|fm_printf
parameter_list|(
name|int
name|depth
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|cols
parameter_list|,
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
name|int
name|width
decl_stmt|;
name|char
name|c1
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|width
operator|=
name|vsnprintf
argument_list|(
operator|&
name|c1
argument_list|,
sizeof|sizeof
argument_list|(
name|c1
argument_list|)
argument_list|,
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|+
name|width
operator|>=
name|cols
condition|)
block|{
name|console_printf
argument_list|(
literal|"\n\r"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|format
index|[
literal|0
index|]
operator|!=
literal|' '
operator|&&
name|depth
operator|>
literal|0
condition|)
block|{
name|console_printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|c
operator|++
expr_stmt|;
block|}
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|console_vprintf
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|c
operator|+
name|width
operator|)
operator|%
name|cols
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Recursively print a nvlist in the specified column width and return the  * column we end up in.  This function is called recursively by fm_nvprint(),  * below.  We generically format the entire nvpair using hexadecimal  * integers and strings, and elide any integer arrays.  Arrays are basically  * used for cache dumps right now, so we suppress them so as not to overwhelm  * the amount of console output we produce at panic time.  This can be further  * enhanced as FMA technology grows based upon the needs of consumers.  All  * FMA telemetry is logged using the dump device transport, so the console  * output serves only as a fallback in case this procedure is unsuccessful.  */
end_comment

begin_function
specifier|static
name|int
name|fm_nvprintr
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|d
parameter_list|,
name|int
name|c
parameter_list|,
name|int
name|cols
parameter_list|)
block|{
name|nvpair_t
modifier|*
name|nvp
decl_stmt|;
for|for
control|(
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|NULL
argument_list|)
init|;
name|nvp
operator|!=
name|NULL
condition|;
name|nvp
operator|=
name|nvlist_next_nvpair
argument_list|(
name|nvl
argument_list|,
name|nvp
argument_list|)
control|)
block|{
name|data_type_t
name|type
init|=
name|nvpair_type
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
init|=
name|nvpair_name
argument_list|(
name|nvp
argument_list|)
decl_stmt|;
name|boolean_t
name|b
decl_stmt|;
name|uint8_t
name|i8
decl_stmt|;
name|uint16_t
name|i16
decl_stmt|;
name|uint32_t
name|i32
decl_stmt|;
name|uint64_t
name|i64
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|nvlist_t
modifier|*
name|cnv
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|FM_CLASS
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
comment|/* already printed by caller */
name|c
operator|=
name|fm_printf
argument_list|(
name|d
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|" %s="
argument_list|,
name|name
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BOOLEAN
case|:
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|" 1"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
operator|(
name|void
operator|)
name|nvpair_value_boolean_value
argument_list|(
name|nvp
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
name|b
condition|?
literal|"1"
else|:
literal|"0"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE
case|:
operator|(
name|void
operator|)
name|nvpair_value_byte
argument_list|(
name|nvp
argument_list|,
operator|&
name|i8
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%x"
argument_list|,
name|i8
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8
case|:
operator|(
name|void
operator|)
name|nvpair_value_int8
argument_list|(
name|nvp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i8
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%x"
argument_list|,
name|i8
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT8
case|:
operator|(
name|void
operator|)
name|nvpair_value_uint8
argument_list|(
name|nvp
argument_list|,
operator|&
name|i8
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%x"
argument_list|,
name|i8
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16
case|:
operator|(
name|void
operator|)
name|nvpair_value_int16
argument_list|(
name|nvp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i16
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%x"
argument_list|,
name|i16
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16
case|:
operator|(
name|void
operator|)
name|nvpair_value_uint16
argument_list|(
name|nvp
argument_list|,
operator|&
name|i16
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%x"
argument_list|,
name|i16
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT32
case|:
operator|(
name|void
operator|)
name|nvpair_value_int32
argument_list|(
name|nvp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i32
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%x"
argument_list|,
name|i32
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32
case|:
operator|(
name|void
operator|)
name|nvpair_value_uint32
argument_list|(
name|nvp
argument_list|,
operator|&
name|i32
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%x"
argument_list|,
name|i32
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64
case|:
operator|(
name|void
operator|)
name|nvpair_value_int64
argument_list|(
name|nvp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i64
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|i64
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64
case|:
operator|(
name|void
operator|)
name|nvpair_value_uint64
argument_list|(
name|nvp
argument_list|,
operator|&
name|i64
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|i64
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_HRTIME
case|:
operator|(
name|void
operator|)
name|nvpair_value_hrtime
argument_list|(
name|nvp
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|i64
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"%llx"
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|i64
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING
case|:
operator|(
name|void
operator|)
name|nvpair_value_string
argument_list|(
name|nvp
argument_list|,
operator|&
name|str
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"\"%s\""
argument_list|,
name|str
condition|?
name|str
else|:
literal|"<NULL>"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST
case|:
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_nvlist
argument_list|(
name|nvp
argument_list|,
operator|&
name|cnv
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_nvprintr
argument_list|(
name|cnv
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|)
expr_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|" ]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
block|{
name|nvlist_t
modifier|*
modifier|*
name|val
decl_stmt|;
name|uint_t
name|i
decl_stmt|,
name|nelem
decl_stmt|;
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|nvpair_value_nvlist_array
argument_list|(
name|nvp
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|nelem
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nelem
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|fm_nvprintr
argument_list|(
name|val
index|[
name|i
index|]
argument_list|,
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|" ]"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"[...]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UNKNOWN
case|:
name|c
operator|=
name|fm_printf
argument_list|(
name|d
operator|+
literal|1
argument_list|,
name|c
argument_list|,
name|cols
argument_list|,
literal|"<unknown>"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
return|return
operator|(
name|c
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fm_nvprint
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|)
block|{
name|char
modifier|*
name|class
decl_stmt|;
name|int
name|c
init|=
literal|0
decl_stmt|;
name|console_printf
argument_list|(
literal|"\r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|nvl
argument_list|,
name|FM_CLASS
argument_list|,
operator|&
name|class
argument_list|)
operator|==
literal|0
condition|)
name|c
operator|=
name|fm_printf
argument_list|(
literal|0
argument_list|,
name|c
argument_list|,
name|ereport_cols
argument_list|,
literal|"%s"
argument_list|,
name|class
argument_list|)
expr_stmt|;
if|if
condition|(
name|fm_nvprintr
argument_list|(
name|nvl
argument_list|,
literal|0
argument_list|,
name|c
argument_list|,
name|ereport_cols
argument_list|)
operator|!=
literal|0
condition|)
name|console_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|console_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wrapper for panic() that first produces an FMA-style message for admins.  * Normally such messages are generated by fmd(1M)'s syslog-msgs agent: this  * is the one exception to that rule and the only error that gets messaged.  * This function is intended for use by subsystems that have detected a fatal  * error and enqueued appropriate ereports and wish to then force a panic.  */
end_comment

begin_comment
comment|/*PRINTFLIKE1*/
end_comment

begin_function
name|void
name|fm_panic
parameter_list|(
specifier|const
name|char
modifier|*
name|format
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
operator|(
name|void
operator|)
name|atomic_cas_ptr
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|fm_panicstr
argument_list|,
name|NULL
argument_list|,
operator|(
name|void
operator|*
operator|)
name|format
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|__i386
argument_list|)
operator|||
name|defined
argument_list|(
name|__amd64
argument_list|)
name|fastreboot_disable_highpil
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* __i386 || __amd64 */
name|va_start
argument_list|(
name|ap
argument_list|,
name|format
argument_list|)
expr_stmt|;
name|vpanic
argument_list|(
name|format
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Simply tell the caller if fm_panicstr is set, ie. an fma event has  * caused the panic. If so, something other than the default panic  * diagnosis method will diagnose the cause of the panic.  */
end_comment

begin_function
name|int
name|is_fm_panic
parameter_list|()
block|{
if|if
condition|(
name|fm_panicstr
condition|)
return|return
operator|(
literal|1
operator|)
return|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Print any appropriate FMA banner message before the panic message.  This  * function is called by panicsys() and prints the message for fm_panic().  * We print the message here so that it comes after the system is quiesced.  * A one-line summary is recorded in the log only (cmn_err(9F) with "!" prefix).  * The rest of the message is for the console only and not needed in the log,  * so it is printed using console_printf().  We break it up into multiple  * chunks so as to avoid overflowing any small legacy prom_printf() buffers.  */
end_comment

begin_function
name|void
name|fm_banner
parameter_list|(
name|void
parameter_list|)
block|{
name|timespec_t
name|tod
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|;
if|if
condition|(
operator|!
name|fm_panicstr
condition|)
return|return;
comment|/* panic was not initiated by fm_panic(); do nothing */
if|if
condition|(
name|panicstr
condition|)
block|{
name|tod
operator|=
name|panic_hrestime
expr_stmt|;
name|now
operator|=
name|panic_hrtime
expr_stmt|;
block|}
else|else
block|{
name|gethrestime
argument_list|(
operator|&
name|tod
argument_list|)
expr_stmt|;
name|now
operator|=
name|gethrtime_waitfree
argument_list|()
expr_stmt|;
block|}
name|cmn_err
argument_list|(
name|CE_NOTE
argument_list|,
literal|"!SUNW-MSG-ID: %s, "
literal|"TYPE: Error, VER: 1, SEVERITY: Major\n"
argument_list|,
name|fm_msgid
argument_list|)
expr_stmt|;
name|console_printf
argument_list|(
literal|"\n\rSUNW-MSG-ID: %s, TYPE: Error, VER: 1, SEVERITY: Major\n"
literal|"EVENT-TIME: 0x%lx.0x%lx (0x%llx)\n"
argument_list|,
name|fm_msgid
argument_list|,
name|tod
operator|.
name|tv_sec
argument_list|,
name|tod
operator|.
name|tv_nsec
argument_list|,
operator|(
name|u_longlong_t
operator|)
name|now
argument_list|)
expr_stmt|;
name|console_printf
argument_list|(
literal|"PLATFORM: %s, CSN: -, HOSTNAME: %s\n"
literal|"SOURCE: %s, REV: %s %s\n"
argument_list|,
name|platform
argument_list|,
name|utsname
operator|.
name|nodename
argument_list|,
name|utsname
operator|.
name|sysname
argument_list|,
name|utsname
operator|.
name|release
argument_list|,
name|utsname
operator|.
name|version
argument_list|)
expr_stmt|;
name|console_printf
argument_list|(
literal|"DESC: Errors have been detected that require a reboot to ensure system\n"
literal|"integrity.  See %s/%s for more information.\n"
argument_list|,
name|fm_url
argument_list|,
name|fm_msgid
argument_list|)
expr_stmt|;
name|console_printf
argument_list|(
literal|"AUTO-RESPONSE: Solaris will attempt to save and diagnose the error telemetry\n"
literal|"IMPACT: The system will sync files, save a crash dump if needed, and reboot\n"
literal|"REC-ACTION: Save the error summary below in case telemetry cannot be saved\n"
argument_list|)
expr_stmt|;
name|console_printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Utility function to write all of the pending ereports to the dump device.  * This function is called at either normal reboot or panic time, and simply  * iterates over the in-transit messages in the ereport sysevent channel.  */
end_comment

begin_function
name|void
name|fm_ereport_dump
parameter_list|(
name|void
parameter_list|)
block|{
name|evchanq_t
modifier|*
name|chq
decl_stmt|;
name|sysevent_t
modifier|*
name|sep
decl_stmt|;
name|erpt_dump_t
name|ed
decl_stmt|;
name|timespec_t
name|tod
decl_stmt|;
name|hrtime_t
name|now
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|panicstr
condition|)
block|{
name|tod
operator|=
name|panic_hrestime
expr_stmt|;
name|now
operator|=
name|panic_hrtime
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|ereport_errorq
operator|!=
name|NULL
condition|)
name|errorq_drain
argument_list|(
name|ereport_errorq
argument_list|)
expr_stmt|;
name|gethrestime
argument_list|(
operator|&
name|tod
argument_list|)
expr_stmt|;
name|now
operator|=
name|gethrtime_waitfree
argument_list|()
expr_stmt|;
block|}
comment|/* 	 * In the panic case, sysevent_evc_walk_init() will return NULL. 	 */
if|if
condition|(
operator|(
name|chq
operator|=
name|sysevent_evc_walk_init
argument_list|(
name|ereport_chan
argument_list|,
name|NULL
argument_list|)
operator|)
operator|==
name|NULL
operator|&&
operator|!
name|panicstr
condition|)
return|return;
comment|/* event channel isn't initialized yet */
while|while
condition|(
operator|(
name|sep
operator|=
name|sysevent_evc_walk_step
argument_list|(
name|chq
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
name|sysevent_evc_event_attr
argument_list|(
name|sep
argument_list|,
operator|&
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|ed
operator|.
name|ed_magic
operator|=
name|ERPT_MAGIC
expr_stmt|;
name|ed
operator|.
name|ed_chksum
operator|=
name|checksum32
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|ed
operator|.
name|ed_size
operator|=
operator|(
name|uint32_t
operator|)
name|len
expr_stmt|;
name|ed
operator|.
name|ed_pad
operator|=
literal|0
expr_stmt|;
name|ed
operator|.
name|ed_hrt_nsec
operator|=
name|SE_TIME
argument_list|(
name|sep
argument_list|)
expr_stmt|;
name|ed
operator|.
name|ed_hrt_base
operator|=
name|now
expr_stmt|;
name|ed
operator|.
name|ed_tod_base
operator|.
name|sec
operator|=
name|tod
operator|.
name|tv_sec
expr_stmt|;
name|ed
operator|.
name|ed_tod_base
operator|.
name|nsec
operator|=
name|tod
operator|.
name|tv_nsec
expr_stmt|;
name|dumpvp_write
argument_list|(
operator|&
name|ed
argument_list|,
sizeof|sizeof
argument_list|(
name|ed
argument_list|)
argument_list|)
expr_stmt|;
name|dumpvp_write
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
name|sysevent_evc_walk_fini
argument_list|(
name|chq
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Post an error report (ereport) to the sysevent error channel.  The error  * channel must be established with a prior call to sysevent_evc_create()  * before publication may occur.  */
end_comment

begin_function
name|void
name|fm_ereport_post
parameter_list|(
name|nvlist_t
modifier|*
name|ereport
parameter_list|,
name|int
name|evc_flag
parameter_list|)
block|{
name|size_t
name|nvl_size
init|=
literal|0
decl_stmt|;
name|evchan_t
modifier|*
name|error_chan
decl_stmt|;
operator|(
name|void
operator|)
name|nvlist_size
argument_list|(
name|ereport
argument_list|,
operator|&
name|nvl_size
argument_list|,
name|NV_ENCODE_NATIVE
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvl_size
operator|>
name|ERPT_DATA_SZ
operator|||
name|nvl_size
operator|==
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_dropped
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sysevent_evc_bind
argument_list|(
name|FM_ERROR_CHAN
argument_list|,
operator|&
name|error_chan
argument_list|,
name|EVCH_CREAT
operator||
name|EVCH_HOLD_PEND
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_dropped
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|sysevent_evc_publish
argument_list|(
name|error_chan
argument_list|,
name|EC_FM
argument_list|,
name|ESC_FM_ERROR
argument_list|,
name|SUNW_VENDOR
argument_list|,
name|FM_PUB
argument_list|,
name|ereport
argument_list|,
name|evc_flag
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_dropped
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sysevent_evc_unbind
argument_list|(
name|error_chan
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sysevent_evc_unbind
argument_list|(
name|error_chan
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Wrapppers for FM nvlist allocators  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|i_fm_alloc
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
return|return
operator|(
name|kmem_zalloc
argument_list|(
name|size
argument_list|,
name|KM_SLEEP
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
specifier|static
name|void
name|i_fm_free
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|,
name|void
modifier|*
name|buf
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|kmem_free
argument_list|(
name|buf
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|nv_alloc_ops_t
name|fm_mem_alloc_ops
init|=
block|{
name|NULL
block|,
name|NULL
block|,
name|i_fm_alloc
block|,
name|i_fm_free
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Create and initialize a new nv_alloc_t for a fixed buffer, buf.  A pointer  * to the newly allocated nv_alloc_t structure is returned upon success or NULL  * is returned to indicate that the nv_alloc structure could not be created.  */
end_comment

begin_function
name|nv_alloc_t
modifier|*
name|fm_nva_xcreate
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|size_t
name|bufsz
parameter_list|)
block|{
name|nv_alloc_t
modifier|*
name|nvhdl
init|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|nv_alloc_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
decl_stmt|;
if|if
condition|(
name|bufsz
operator|==
literal|0
operator|||
name|nv_alloc_init
argument_list|(
name|nvhdl
argument_list|,
name|nv_fixed_ops
argument_list|,
name|buf
argument_list|,
name|bufsz
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|nvhdl
argument_list|,
sizeof|sizeof
argument_list|(
name|nv_alloc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nvhdl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a previously allocated nv_alloc structure.  The fixed buffer  * associated with nva must be freed by the caller.  */
end_comment

begin_function
name|void
name|fm_nva_xdestroy
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
name|nv_alloc_fini
argument_list|(
name|nva
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|nva
argument_list|,
sizeof|sizeof
argument_list|(
name|nv_alloc_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Create a new nv list.  A pointer to a new nv list structure is returned  * upon success or NULL is returned to indicate that the structure could  * not be created.  The newly created nv list is created and managed by the  * operations installed in nva.   If nva is NULL, the default FMA nva  * operations are installed and used.  *  * When called from the kernel and nva == NULL, this function must be called  * from passive kernel context with no locks held that can prevent a  * sleeping memory allocation from occurring.  Otherwise, this function may  * be called from other kernel contexts as long a valid nva created via  * fm_nva_create() is supplied.  */
end_comment

begin_function
name|nvlist_t
modifier|*
name|fm_nvlist_create
parameter_list|(
name|nv_alloc_t
modifier|*
name|nva
parameter_list|)
block|{
name|int
name|hdl_alloced
init|=
literal|0
decl_stmt|;
name|nvlist_t
modifier|*
name|nvl
decl_stmt|;
name|nv_alloc_t
modifier|*
name|nvhdl
decl_stmt|;
if|if
condition|(
name|nva
operator|==
name|NULL
condition|)
block|{
name|nvhdl
operator|=
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|nv_alloc_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
if|if
condition|(
name|nv_alloc_init
argument_list|(
name|nvhdl
argument_list|,
operator|&
name|fm_mem_alloc_ops
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|kmem_free
argument_list|(
name|nvhdl
argument_list|,
sizeof|sizeof
argument_list|(
name|nv_alloc_t
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|hdl_alloced
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|nvhdl
operator|=
name|nva
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_xalloc
argument_list|(
operator|&
name|nvl
argument_list|,
name|NV_UNIQUE_NAME
argument_list|,
name|nvhdl
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hdl_alloced
condition|)
block|{
name|nv_alloc_fini
argument_list|(
name|nvhdl
argument_list|)
expr_stmt|;
name|kmem_free
argument_list|(
name|nvhdl
argument_list|,
sizeof|sizeof
argument_list|(
name|nv_alloc_t
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|nvl
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Destroy a previously allocated nvlist structure.  flag indicates whether  * or not the associated nva structure should be freed (FM_NVA_FREE) or  * retained (FM_NVA_RETAIN).  Retaining the nv alloc structure allows  * it to be re-used for future nvlist creation operations.  */
end_comment

begin_function
name|void
name|fm_nvlist_destroy
parameter_list|(
name|nvlist_t
modifier|*
name|nvl
parameter_list|,
name|int
name|flag
parameter_list|)
block|{
name|nv_alloc_t
modifier|*
name|nva
init|=
name|nvlist_lookup_nv_alloc
argument_list|(
name|nvl
argument_list|)
decl_stmt|;
name|nvlist_free
argument_list|(
name|nvl
argument_list|)
expr_stmt|;
if|if
condition|(
name|nva
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|flag
operator|==
name|FM_NVA_FREE
condition|)
name|fm_nva_xdestroy
argument_list|(
name|nva
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|int
name|i_fm_payload_set
parameter_list|(
name|nvlist_t
modifier|*
name|payload
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|va_list
name|ap
parameter_list|)
block|{
name|int
name|nelem
decl_stmt|,
name|ret
init|=
literal|0
decl_stmt|;
name|data_type_t
name|type
decl_stmt|;
while|while
condition|(
name|ret
operator|==
literal|0
operator|&&
name|name
operator|!=
name|NULL
condition|)
block|{
name|type
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|data_type_t
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|DATA_TYPE_BYTE
case|:
name|ret
operator|=
name|nvlist_add_byte
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BYTE_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_byte_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uchar_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_VALUE
case|:
name|ret
operator|=
name|nvlist_add_boolean_value
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|boolean_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_BOOLEAN_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_boolean_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|boolean_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8
case|:
name|ret
operator|=
name|nvlist_add_int8
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT8_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_int8_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int8_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT8
case|:
name|ret
operator|=
name|nvlist_add_uint8
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT8_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_uint8_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint8_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16
case|:
name|ret
operator|=
name|nvlist_add_int16
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT16_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_int16_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int16_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16
case|:
name|ret
operator|=
name|nvlist_add_uint16
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT16_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_uint16_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint16_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT32
case|:
name|ret
operator|=
name|nvlist_add_int32
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int32_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT32_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_int32_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int32_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32
case|:
name|ret
operator|=
name|nvlist_add_uint32
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT32_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_uint32_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64
case|:
name|ret
operator|=
name|nvlist_add_int64
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int64_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_INT64_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_int64_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int64_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64
case|:
name|ret
operator|=
name|nvlist_add_uint64
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint64_t
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_UINT64_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_uint64_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint64_t
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING
case|:
name|ret
operator|=
name|nvlist_add_string
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_STRING_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_string_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST
case|:
name|ret
operator|=
name|nvlist_add_nvlist
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|nvlist_t
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|DATA_TYPE_NVLIST_ARRAY
case|:
name|nelem
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|int
argument_list|)
expr_stmt|;
name|ret
operator|=
name|nvlist_add_nvlist_array
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|va_arg
argument_list|(
name|ap
argument_list|,
name|nvlist_t
operator|*
operator|*
argument_list|)
argument_list|,
name|nelem
argument_list|)
expr_stmt|;
break|break;
default|default:
name|ret
operator|=
name|EINVAL
expr_stmt|;
block|}
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fm_payload_set
parameter_list|(
name|nvlist_t
modifier|*
name|payload
parameter_list|,
modifier|...
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|payload
argument_list|)
expr_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|char
operator|*
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i_fm_payload_set
argument_list|(
name|payload
argument_list|,
name|name
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|payload_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set-up and validate the members of an ereport event according to:  *  *	Member name		Type		Value  *	====================================================  *	class			string		ereport  *	version			uint8_t		0  *	ena			uint64_t<ena>  *	detector		nvlist_t<detector>  *	ereport-payload		nvlist_t<var args>  *  * We don't actually add a 'version' member to the payload.  Really,  * the version quoted to us by our caller is that of the category 1  * "ereport" event class (and we require FM_EREPORT_VERS0) but  * the payload version of the actual leaf class event under construction  * may be something else.  Callers should supply a version in the varargs,  * or (better) we could take two version arguments - one for the  * ereport category 1 classification (expect FM_EREPORT_VERS0) and one  * for the leaf class.  */
end_comment

begin_function
name|void
name|fm_ereport_set
parameter_list|(
name|nvlist_t
modifier|*
name|ereport
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|char
modifier|*
name|erpt_class
parameter_list|,
name|uint64_t
name|ena
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|detector
parameter_list|,
modifier|...
parameter_list|)
block|{
name|char
name|ereport_class
index|[
name|FM_MAX_CLASS
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|name
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|if
condition|(
name|version
operator|!=
name|FM_EREPORT_VERS0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|ereport_class
argument_list|,
name|FM_MAX_CLASS
argument_list|,
literal|"%s.%s"
argument_list|,
name|FM_EREPORT_CLASS
argument_list|,
name|erpt_class
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|ereport
argument_list|,
name|FM_CLASS
argument_list|,
name|ereport_class
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_ENA
argument_list|,
name|ena
argument_list|)
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|ereport
argument_list|,
name|FM_EREPORT_DETECTOR
argument_list|,
operator|(
name|nvlist_t
operator|*
operator|)
name|detector
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
name|va_start
argument_list|(
name|ap
argument_list|,
name|detector
argument_list|)
expr_stmt|;
name|name
operator|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
expr_stmt|;
name|ret
operator|=
name|i_fm_payload_set
argument_list|(
name|ereport
argument_list|,
name|name
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
condition|)
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|erpt_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set-up and validate the members of an hc fmri according to;  *  *	Member name		Type		Value  *	===================================================  *	version			uint8_t		0  *	auth			nvlist_t<auth>  *	hc-name			string<name>  *	hc-id			string<id>  *  * Note that auth and hc-id are optional members.  */
end_comment

begin_define
define|#
directive|define
name|HC_MAXPAIRS
value|20
end_define

begin_define
define|#
directive|define
name|HC_MAXNAMELEN
value|50
end_define

begin_function
specifier|static
name|int
name|fm_fmri_hc_set_common
parameter_list|(
name|nvlist_t
modifier|*
name|fmri
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|auth
parameter_list|)
block|{
if|if
condition|(
name|version
operator|!=
name|FM_HC_SCHEME_VERSION
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nvlist_add_uint8
argument_list|(
name|fmri
argument_list|,
name|FM_VERSION
argument_list|,
name|version
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_SCHEME
argument_list|,
name|FM_FMRI_SCHEME_HC
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|auth
operator|!=
name|NULL
operator|&&
name|nvlist_add_nvlist
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_AUTHORITY
argument_list|,
operator|(
name|nvlist_t
operator|*
operator|)
name|auth
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|fm_fmri_hc_set
parameter_list|(
name|nvlist_t
modifier|*
name|fmri
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|auth
parameter_list|,
name|nvlist_t
modifier|*
name|snvl
parameter_list|,
name|int
name|npairs
parameter_list|,
modifier|...
parameter_list|)
block|{
name|nv_alloc_t
modifier|*
name|nva
init|=
name|nvlist_lookup_nv_alloc
argument_list|(
name|fmri
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|pairs
index|[
name|HC_MAXPAIRS
index|]
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
name|fm_fmri_hc_set_common
argument_list|(
name|fmri
argument_list|,
name|version
argument_list|,
name|auth
argument_list|)
condition|)
return|return;
name|npairs
operator|=
name|MIN
argument_list|(
name|npairs
argument_list|,
name|HC_MAXPAIRS
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|npairs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npairs
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|uint32_t
name|id
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32_t
argument_list|)
decl_stmt|;
name|char
name|idstr
index|[
literal|11
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|idstr
argument_list|,
sizeof|sizeof
argument_list|(
name|idstr
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pairs
index|[
name|i
index|]
operator|=
name|fm_nvlist_create
argument_list|(
name|nva
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_NAME
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_ID
argument_list|,
name|idstr
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_nvlist_array
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_HC_LIST
argument_list|,
name|pairs
argument_list|,
name|npairs
argument_list|)
operator|!=
literal|0
condition|)
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npairs
condition|;
name|i
operator|++
control|)
name|fm_nvlist_destroy
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_NVA_RETAIN
argument_list|)
expr_stmt|;
if|if
condition|(
name|snvl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_HC_SPECIFIC
argument_list|,
name|snvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Set-up and validate the members of an dev fmri according to:  *  *	Member name		Type		Value  *	====================================================  *	version			uint8_t		0  *	auth			nvlist_t<auth>  *	devpath			string<devpath>  *	[devid]			string<devid>  *	[target-port-l0id]	string<target-port-lun0-id>  *  * Note that auth and devid are optional members.  */
end_comment

begin_function
name|void
name|fm_fmri_dev_set
parameter_list|(
name|nvlist_t
modifier|*
name|fmri_dev
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|auth
parameter_list|,
specifier|const
name|char
modifier|*
name|devpath
parameter_list|,
specifier|const
name|char
modifier|*
name|devid
parameter_list|,
specifier|const
name|char
modifier|*
name|tpl0
parameter_list|)
block|{
name|int
name|err
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|version
operator|!=
name|DEV_SCHEME_VERSION0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
name|err
operator||=
name|nvlist_add_uint8
argument_list|(
name|fmri_dev
argument_list|,
name|FM_VERSION
argument_list|,
name|version
argument_list|)
expr_stmt|;
name|err
operator||=
name|nvlist_add_string
argument_list|(
name|fmri_dev
argument_list|,
name|FM_FMRI_SCHEME
argument_list|,
name|FM_FMRI_SCHEME_DEV
argument_list|)
expr_stmt|;
if|if
condition|(
name|auth
operator|!=
name|NULL
condition|)
block|{
name|err
operator||=
name|nvlist_add_nvlist
argument_list|(
name|fmri_dev
argument_list|,
name|FM_FMRI_AUTHORITY
argument_list|,
operator|(
name|nvlist_t
operator|*
operator|)
name|auth
argument_list|)
expr_stmt|;
block|}
name|err
operator||=
name|nvlist_add_string
argument_list|(
name|fmri_dev
argument_list|,
name|FM_FMRI_DEV_PATH
argument_list|,
name|devpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|devid
operator|!=
name|NULL
condition|)
name|err
operator||=
name|nvlist_add_string
argument_list|(
name|fmri_dev
argument_list|,
name|FM_FMRI_DEV_ID
argument_list|,
name|devid
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpl0
operator|!=
name|NULL
condition|)
name|err
operator||=
name|nvlist_add_string
argument_list|(
name|fmri_dev
argument_list|,
name|FM_FMRI_DEV_TGTPTLUN0
argument_list|,
name|tpl0
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set-up and validate the members of an cpu fmri according to:  *  *	Member name		Type		Value  *	====================================================  *	version			uint8_t		0  *	auth			nvlist_t<auth>  *	cpuid			uint32_t<cpu_id>  *	cpumask			uint8_t<cpu_mask>  *	serial			uint64_t<serial_id>  *  * Note that auth, cpumask, serial are optional members.  *  */
end_comment

begin_function
name|void
name|fm_fmri_cpu_set
parameter_list|(
name|nvlist_t
modifier|*
name|fmri_cpu
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|auth
parameter_list|,
name|uint32_t
name|cpu_id
parameter_list|,
name|uint8_t
modifier|*
name|cpu_maskp
parameter_list|,
specifier|const
name|char
modifier|*
name|serial_idp
parameter_list|)
block|{
name|uint64_t
modifier|*
name|failedp
init|=
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
decl_stmt|;
if|if
condition|(
name|version
operator|<
name|CPU_SCHEME_VERSION1
condition|)
block|{
name|atomic_inc_64
argument_list|(
name|failedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_uint8
argument_list|(
name|fmri_cpu
argument_list|,
name|FM_VERSION
argument_list|,
name|version
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
name|failedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|fmri_cpu
argument_list|,
name|FM_FMRI_SCHEME
argument_list|,
name|FM_FMRI_SCHEME_CPU
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
name|failedp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|auth
operator|!=
name|NULL
operator|&&
name|nvlist_add_nvlist
argument_list|(
name|fmri_cpu
argument_list|,
name|FM_FMRI_AUTHORITY
argument_list|,
operator|(
name|nvlist_t
operator|*
operator|)
name|auth
argument_list|)
operator|!=
literal|0
condition|)
name|atomic_inc_64
argument_list|(
name|failedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_uint32
argument_list|(
name|fmri_cpu
argument_list|,
name|FM_FMRI_CPU_ID
argument_list|,
name|cpu_id
argument_list|)
operator|!=
literal|0
condition|)
name|atomic_inc_64
argument_list|(
name|failedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cpu_maskp
operator|!=
name|NULL
operator|&&
name|nvlist_add_uint8
argument_list|(
name|fmri_cpu
argument_list|,
name|FM_FMRI_CPU_MASK
argument_list|,
operator|*
name|cpu_maskp
argument_list|)
operator|!=
literal|0
condition|)
name|atomic_inc_64
argument_list|(
name|failedp
argument_list|)
expr_stmt|;
if|if
condition|(
name|serial_idp
operator|==
name|NULL
operator|||
name|nvlist_add_string
argument_list|(
name|fmri_cpu
argument_list|,
name|FM_FMRI_CPU_SERIAL_ID
argument_list|,
operator|(
name|char
operator|*
operator|)
name|serial_idp
argument_list|)
operator|!=
literal|0
condition|)
name|atomic_inc_64
argument_list|(
name|failedp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Set-up and validate the members of a mem according to:  *  *	Member name		Type		Value  *	====================================================  *	version			uint8_t		0  *	auth			nvlist_t<auth>		[optional]  *	unum			string<unum>  *	serial			string<serial>	[optional*]  *	offset			uint64_t<offset>	[optional]  *  *	* serial is required if offset is present  */
end_comment

begin_function
name|void
name|fm_fmri_mem_set
parameter_list|(
name|nvlist_t
modifier|*
name|fmri
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|auth
parameter_list|,
specifier|const
name|char
modifier|*
name|unum
parameter_list|,
specifier|const
name|char
modifier|*
name|serial
parameter_list|,
name|uint64_t
name|offset
parameter_list|)
block|{
if|if
condition|(
name|version
operator|!=
name|MEM_SCHEME_VERSION0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|serial
operator|&&
operator|(
name|offset
operator|!=
operator|(
name|uint64_t
operator|)
operator|-
literal|1
operator|)
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_uint8
argument_list|(
name|fmri
argument_list|,
name|FM_VERSION
argument_list|,
name|version
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_SCHEME
argument_list|,
name|FM_FMRI_SCHEME_MEM
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|auth
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_AUTHORITY
argument_list|,
operator|(
name|nvlist_t
operator|*
operator|)
name|auth
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_MEM_UNUM
argument_list|,
name|unum
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|serial
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_add_string_array
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_MEM_SERIAL_ID
argument_list|,
operator|(
name|char
operator|*
operator|*
operator|)
operator|&
name|serial
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offset
operator|!=
operator|(
name|uint64_t
operator|)
operator|-
literal|1
operator|&&
name|nvlist_add_uint64
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_MEM_OFFSET
argument_list|,
name|offset
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|fm_fmri_zfs_set
parameter_list|(
name|nvlist_t
modifier|*
name|fmri
parameter_list|,
name|int
name|version
parameter_list|,
name|uint64_t
name|pool_guid
parameter_list|,
name|uint64_t
name|vdev_guid
parameter_list|)
block|{
if|if
condition|(
name|version
operator|!=
name|ZFS_SCHEME_VERSION0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_uint8
argument_list|(
name|fmri
argument_list|,
name|FM_VERSION
argument_list|,
name|version
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_SCHEME
argument_list|,
name|FM_FMRI_SCHEME_ZFS
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_ZFS_POOL
argument_list|,
name|pool_guid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|vdev_guid
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|nvlist_add_uint64
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_ZFS_VDEV
argument_list|,
name|vdev_guid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|uint64_t
name|fm_ena_increment
parameter_list|(
name|uint64_t
name|ena
parameter_list|)
block|{
name|uint64_t
name|new_ena
decl_stmt|;
switch|switch
condition|(
name|ENA_FORMAT
argument_list|(
name|ena
argument_list|)
condition|)
block|{
case|case
name|FM_ENA_FMT1
case|:
name|new_ena
operator|=
name|ena
operator|+
operator|(
literal|1
operator|<<
name|ENA_FMT1_GEN_SHFT
operator|)
expr_stmt|;
break|break;
case|case
name|FM_ENA_FMT2
case|:
name|new_ena
operator|=
name|ena
operator|+
operator|(
literal|1
operator|<<
name|ENA_FMT2_GEN_SHFT
operator|)
expr_stmt|;
break|break;
default|default:
name|new_ena
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|new_ena
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|fm_ena_generate_cpu
parameter_list|(
name|uint64_t
name|timestamp
parameter_list|,
name|processorid_t
name|cpuid
parameter_list|,
name|uchar_t
name|format
parameter_list|)
block|{
name|uint64_t
name|ena
init|=
literal|0
decl_stmt|;
switch|switch
condition|(
name|format
condition|)
block|{
case|case
name|FM_ENA_FMT1
case|:
if|if
condition|(
name|timestamp
condition|)
block|{
name|ena
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|format
operator|&
name|ENA_FORMAT_MASK
operator|)
operator||
operator|(
operator|(
name|cpuid
operator|<<
name|ENA_FMT1_CPUID_SHFT
operator|)
operator|&
name|ENA_FMT1_CPUID_MASK
operator|)
operator||
operator|(
operator|(
name|timestamp
operator|<<
name|ENA_FMT1_TIME_SHFT
operator|)
operator|&
name|ENA_FMT1_TIME_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ena
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|format
operator|&
name|ENA_FORMAT_MASK
operator|)
operator||
operator|(
operator|(
name|cpuid
operator|<<
name|ENA_FMT1_CPUID_SHFT
operator|)
operator|&
name|ENA_FMT1_CPUID_MASK
operator|)
operator||
operator|(
operator|(
name|gethrtime_waitfree
argument_list|()
operator|<<
name|ENA_FMT1_TIME_SHFT
operator|)
operator|&
name|ENA_FMT1_TIME_MASK
operator|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|FM_ENA_FMT2
case|:
name|ena
operator|=
call|(
name|uint64_t
call|)
argument_list|(
operator|(
name|format
operator|&
name|ENA_FORMAT_MASK
operator|)
operator||
operator|(
operator|(
name|timestamp
operator|<<
name|ENA_FMT2_TIME_SHFT
operator|)
operator|&
name|ENA_FMT2_TIME_MASK
operator|)
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
name|ena
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|fm_ena_generate
parameter_list|(
name|uint64_t
name|timestamp
parameter_list|,
name|uchar_t
name|format
parameter_list|)
block|{
return|return
operator|(
name|fm_ena_generate_cpu
argument_list|(
name|timestamp
argument_list|,
name|CPU
operator|->
name|cpu_id
argument_list|,
name|format
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|fm_ena_generation_get
parameter_list|(
name|uint64_t
name|ena
parameter_list|)
block|{
name|uint64_t
name|gen
decl_stmt|;
switch|switch
condition|(
name|ENA_FORMAT
argument_list|(
name|ena
argument_list|)
condition|)
block|{
case|case
name|FM_ENA_FMT1
case|:
name|gen
operator|=
operator|(
name|ena
operator|&
name|ENA_FMT1_GEN_MASK
operator|)
operator|>>
name|ENA_FMT1_GEN_SHFT
expr_stmt|;
break|break;
case|case
name|FM_ENA_FMT2
case|:
name|gen
operator|=
operator|(
name|ena
operator|&
name|ENA_FMT2_GEN_MASK
operator|)
operator|>>
name|ENA_FMT2_GEN_SHFT
expr_stmt|;
break|break;
default|default:
name|gen
operator|=
literal|0
expr_stmt|;
break|break;
block|}
return|return
operator|(
name|gen
operator|)
return|;
block|}
end_function

begin_function
name|uchar_t
name|fm_ena_format_get
parameter_list|(
name|uint64_t
name|ena
parameter_list|)
block|{
return|return
operator|(
name|ENA_FORMAT
argument_list|(
name|ena
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|fm_ena_id_get
parameter_list|(
name|uint64_t
name|ena
parameter_list|)
block|{
name|uint64_t
name|id
decl_stmt|;
switch|switch
condition|(
name|ENA_FORMAT
argument_list|(
name|ena
argument_list|)
condition|)
block|{
case|case
name|FM_ENA_FMT1
case|:
name|id
operator|=
operator|(
name|ena
operator|&
name|ENA_FMT1_ID_MASK
operator|)
operator|>>
name|ENA_FMT1_ID_SHFT
expr_stmt|;
break|break;
case|case
name|FM_ENA_FMT2
case|:
name|id
operator|=
operator|(
name|ena
operator|&
name|ENA_FMT2_ID_MASK
operator|)
operator|>>
name|ENA_FMT2_ID_SHFT
expr_stmt|;
break|break;
default|default:
name|id
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|id
operator|)
return|;
block|}
end_function

begin_function
name|uint64_t
name|fm_ena_time_get
parameter_list|(
name|uint64_t
name|ena
parameter_list|)
block|{
name|uint64_t
name|time
decl_stmt|;
switch|switch
condition|(
name|ENA_FORMAT
argument_list|(
name|ena
argument_list|)
condition|)
block|{
case|case
name|FM_ENA_FMT1
case|:
name|time
operator|=
operator|(
name|ena
operator|&
name|ENA_FMT1_TIME_MASK
operator|)
operator|>>
name|ENA_FMT1_TIME_SHFT
expr_stmt|;
break|break;
case|case
name|FM_ENA_FMT2
case|:
name|time
operator|=
operator|(
name|ena
operator|&
name|ENA_FMT2_TIME_MASK
operator|)
operator|>>
name|ENA_FMT2_TIME_SHFT
expr_stmt|;
break|break;
default|default:
name|time
operator|=
literal|0
expr_stmt|;
block|}
return|return
operator|(
name|time
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Convert a getpcstack() trace to symbolic name+offset, and add the resulting  * string array to a Fault Management ereport as FM_EREPORT_PAYLOAD_NAME_STACK.  */
end_comment

begin_function
name|void
name|fm_payload_stack_add
parameter_list|(
name|nvlist_t
modifier|*
name|payload
parameter_list|,
specifier|const
name|pc_t
modifier|*
name|stack
parameter_list|,
name|int
name|depth
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|sym
decl_stmt|;
name|ulong_t
name|off
decl_stmt|;
name|char
modifier|*
name|stkpp
index|[
name|FM_STK_DEPTH
index|]
decl_stmt|;
name|char
name|buf
index|[
name|FM_STK_DEPTH
operator|*
name|FM_SYM_SZ
index|]
decl_stmt|;
name|char
modifier|*
name|stkp
init|=
name|buf
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|depth
operator|&&
name|i
operator|!=
name|FM_STK_DEPTH
condition|;
name|i
operator|++
operator|,
name|stkp
operator|+=
name|FM_SYM_SZ
control|)
block|{
if|if
condition|(
operator|(
name|sym
operator|=
name|kobj_getsymname
argument_list|(
name|stack
index|[
name|i
index|]
argument_list|,
operator|&
name|off
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|stkp
argument_list|,
name|FM_SYM_SZ
argument_list|,
literal|"%s+%lx"
argument_list|,
name|sym
argument_list|,
name|off
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|stkp
argument_list|,
name|FM_SYM_SZ
argument_list|,
literal|"%lx"
argument_list|,
operator|(
name|long
operator|)
name|stack
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|stkpp
index|[
name|i
index|]
operator|=
name|stkp
expr_stmt|;
block|}
name|fm_payload_set
argument_list|(
name|payload
argument_list|,
name|FM_EREPORT_PAYLOAD_NAME_STACK
argument_list|,
name|DATA_TYPE_STRING_ARRAY
argument_list|,
name|depth
argument_list|,
name|stkpp
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|print_msg_hwerr
parameter_list|(
name|ctid_t
name|ct_id
parameter_list|,
name|proc_t
modifier|*
name|p
parameter_list|)
block|{
name|uprintf
argument_list|(
literal|"Killed process %d (%s) in contract id %d "
literal|"due to hardware error\n"
argument_list|,
name|p
operator|->
name|p_pid
argument_list|,
name|p
operator|->
name|p_user
operator|.
name|u_comm
argument_list|,
name|ct_id
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|fm_fmri_hc_create
parameter_list|(
name|nvlist_t
modifier|*
name|fmri
parameter_list|,
name|int
name|version
parameter_list|,
specifier|const
name|nvlist_t
modifier|*
name|auth
parameter_list|,
name|nvlist_t
modifier|*
name|snvl
parameter_list|,
name|nvlist_t
modifier|*
name|bboard
parameter_list|,
name|int
name|npairs
parameter_list|,
modifier|...
parameter_list|)
block|{
name|nv_alloc_t
modifier|*
name|nva
init|=
name|nvlist_lookup_nv_alloc
argument_list|(
name|fmri
argument_list|)
decl_stmt|;
name|nvlist_t
modifier|*
name|pairs
index|[
name|HC_MAXPAIRS
index|]
decl_stmt|;
name|nvlist_t
modifier|*
modifier|*
name|hcl
decl_stmt|;
name|uint_t
name|n
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|hcname
decl_stmt|,
modifier|*
name|hcid
decl_stmt|;
if|if
condition|(
operator|!
name|fm_fmri_hc_set_common
argument_list|(
name|fmri
argument_list|,
name|version
argument_list|,
name|auth
argument_list|)
condition|)
return|return;
comment|/* 	 * copy the bboard nvpairs to the pairs array 	 */
if|if
condition|(
name|nvlist_lookup_nvlist_array
argument_list|(
name|bboard
argument_list|,
name|FM_FMRI_HC_LIST
argument_list|,
operator|&
name|hcl
argument_list|,
operator|&
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|hcl
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_NAME
argument_list|,
operator|&
name|hcname
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|nvlist_lookup_string
argument_list|(
name|hcl
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_ID
argument_list|,
operator|&
name|hcid
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
name|pairs
index|[
name|i
index|]
operator|=
name|fm_nvlist_create
argument_list|(
name|nva
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_NAME
argument_list|,
name|hcname
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_ID
argument_list|,
name|hcid
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pairs
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|fm_nvlist_destroy
argument_list|(
name|pairs
index|[
name|j
index|]
argument_list|,
name|FM_NVA_RETAIN
argument_list|)
expr_stmt|;
block|}
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
comment|/* 	 * create the pairs from passed in pairs 	 */
name|npairs
operator|=
name|MIN
argument_list|(
name|npairs
argument_list|,
name|HC_MAXPAIRS
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|npairs
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|n
init|;
name|i
operator|<
name|npairs
operator|+
name|n
condition|;
name|i
operator|++
control|)
block|{
specifier|const
name|char
modifier|*
name|name
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
specifier|const
name|char
operator|*
argument_list|)
decl_stmt|;
name|uint32_t
name|id
init|=
name|va_arg
argument_list|(
name|ap
argument_list|,
name|uint32_t
argument_list|)
decl_stmt|;
name|char
name|idstr
index|[
literal|11
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|idstr
argument_list|,
sizeof|sizeof
argument_list|(
name|idstr
argument_list|)
argument_list|,
literal|"%u"
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|pairs
index|[
name|i
index|]
operator|=
name|fm_nvlist_create
argument_list|(
name|nva
argument_list|)
expr_stmt|;
if|if
condition|(
name|nvlist_add_string
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_NAME
argument_list|,
name|name
argument_list|)
operator|!=
literal|0
operator|||
name|nvlist_add_string
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_FMRI_HC_ID
argument_list|,
name|idstr
argument_list|)
operator|!=
literal|0
condition|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<=
name|i
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|pairs
index|[
name|j
index|]
operator|!=
name|NULL
condition|)
name|fm_nvlist_destroy
argument_list|(
name|pairs
index|[
name|j
index|]
argument_list|,
name|FM_NVA_RETAIN
argument_list|)
expr_stmt|;
block|}
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
comment|/* 	 * Create the fmri hc list 	 */
if|if
condition|(
name|nvlist_add_nvlist_array
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_HC_LIST
argument_list|,
name|pairs
argument_list|,
name|npairs
operator|+
name|n
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|npairs
operator|+
name|n
condition|;
name|i
operator|++
control|)
block|{
name|fm_nvlist_destroy
argument_list|(
name|pairs
index|[
name|i
index|]
argument_list|,
name|FM_NVA_RETAIN
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|snvl
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nvlist_add_nvlist
argument_list|(
name|fmri
argument_list|,
name|FM_FMRI_HC_SPECIFIC
argument_list|,
name|snvl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|atomic_inc_64
argument_list|(
operator|&
name|erpt_kstat_data
operator|.
name|fmri_set_failed
operator|.
name|value
operator|.
name|ui64
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_function

end_unit

