begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * CDDL HEADER START  *  * The contents of this file are subject to the terms of the  * Common Development and Distribution License (the "License").  * You may not use this file except in compliance with the License.  *  * You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE  * or http://www.opensolaris.org/os/licensing.  * See the License for the specific language governing permissions  * and limitations under the License.  *  * When distributing Covered Code, include this CDDL HEADER in each  * file and include the License file at usr/src/OPENSOLARIS.LICENSE.  * If applicable, add the following below this CDDL HEADER, with the  * fields enclosed by brackets "[]" replaced with your own identifying  * information: Portions Copyright [yyyy] [name of copyright owner]  *  * CDDL HEADER END  */
end_comment

begin_comment
comment|/*  * Copyright 2009 Sun Microsystems, Inc.  All rights reserved.  * Use is subject to license terms.  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/t_lock.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysmacros.h>
end_include

begin_include
include|#
directive|include
file|<sys/systm.h>
end_include

begin_include
include|#
directive|include
file|<sys/cpuvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/callb.h>
end_include

begin_include
include|#
directive|include
file|<sys/kmem.h>
end_include

begin_include
include|#
directive|include
file|<sys/cmn_err.h>
end_include

begin_include
include|#
directive|include
file|<sys/swap.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmsystm.h>
end_include

begin_include
include|#
directive|include
file|<sys/class.h>
end_include

begin_include
include|#
directive|include
file|<sys/debug.h>
end_include

begin_include
include|#
directive|include
file|<sys/thread.h>
end_include

begin_include
include|#
directive|include
file|<sys/kobj.h>
end_include

begin_include
include|#
directive|include
file|<sys/ddi.h>
end_include

begin_comment
comment|/* for delay() */
end_comment

begin_include
include|#
directive|include
file|<sys/taskq.h>
end_include

begin_comment
comment|/* For TASKQ_NAMELEN */
end_comment

begin_define
define|#
directive|define
name|CB_MAXNAME
value|TASKQ_NAMELEN
end_define

begin_comment
comment|/*  * The callb mechanism provides generic event scheduling/echoing.  * A callb function is registered and called on behalf of the event.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|callb
block|{
name|struct
name|callb
modifier|*
name|c_next
decl_stmt|;
comment|/* next in class or on freelist */
name|kthread_id_t
name|c_thread
decl_stmt|;
comment|/* ptr to caller's thread struct */
name|char
name|c_flag
decl_stmt|;
comment|/* info about the callb state */
name|uchar_t
name|c_class
decl_stmt|;
comment|/* this callb's class */
name|kcondvar_t
name|c_done_cv
decl_stmt|;
comment|/* signal callb completion */
name|boolean_t
function_decl|(
modifier|*
name|c_func
function_decl|)
parameter_list|()
function_decl|;
comment|/* cb function: returns true if ok */
name|void
modifier|*
name|c_arg
decl_stmt|;
comment|/* arg to c_func */
name|char
name|c_name
index|[
name|CB_MAXNAME
operator|+
literal|1
index|]
decl_stmt|;
comment|/* debug:max func name length */
block|}
name|callb_t
typedef|;
end_typedef

begin_comment
comment|/*  * callb c_flag bitmap definitions  */
end_comment

begin_define
define|#
directive|define
name|CALLB_FREE
value|0x0
end_define

begin_define
define|#
directive|define
name|CALLB_TAKEN
value|0x1
end_define

begin_define
define|#
directive|define
name|CALLB_EXECUTING
value|0x2
end_define

begin_comment
comment|/*  * Basic structure for a callb table.  * All callbs are organized into different class groups described  * by ct_class array.  * The callbs within a class are single-linked and normally run by a  * serial execution.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|callb_table
block|{
name|kmutex_t
name|ct_lock
decl_stmt|;
comment|/* protect all callb states */
name|callb_t
modifier|*
name|ct_freelist
decl_stmt|;
comment|/* free callb structures */
name|int
name|ct_busy
decl_stmt|;
comment|/* != 0 prevents additions */
name|kcondvar_t
name|ct_busy_cv
decl_stmt|;
comment|/* to wait for not busy    */
name|int
name|ct_ncallb
decl_stmt|;
comment|/* num of callbs allocated */
name|callb_t
modifier|*
name|ct_first_cb
index|[
name|NCBCLASS
index|]
decl_stmt|;
comment|/* ptr to 1st callb in a class */
block|}
name|callb_table_t
typedef|;
end_typedef

begin_decl_stmt
name|int
name|callb_timeout_sec
init|=
name|CPR_KTHREAD_TIMEOUT_SEC
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|callb_id_t
name|callb_add_common
parameter_list|(
name|boolean_t
function_decl|(
modifier|*
function_decl|)
parameter_list|(
name|void
modifier|*
parameter_list|,
name|int
parameter_list|)
parameter_list|,
name|void
modifier|*
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|kthread_id_t
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|callb_table_t
name|callb_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* system level callback table */
end_comment

begin_decl_stmt
specifier|static
name|callb_table_t
modifier|*
name|ct
init|=
operator|&
name|callb_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kmutex_t
name|callb_safe_mutex
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|callb_cpr_t
name|callb_cprinfo_safe
init|=
block|{
operator|&
name|callb_safe_mutex
block|,
name|CALLB_CPR_ALWAYS_SAFE
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Init all callb tables in the system.  */
end_comment

begin_function
name|void
name|callb_init
parameter_list|()
block|{
name|callb_table
operator|.
name|ct_busy
operator|=
literal|0
expr_stmt|;
comment|/* mark table open for additions */
name|mutex_init
argument_list|(
operator|&
name|callb_safe_mutex
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|mutex_init
argument_list|(
operator|&
name|callb_table
operator|.
name|ct_lock
argument_list|,
name|NULL
argument_list|,
name|MUTEX_DEFAULT
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * callout_add() is called to register func() be called later.  */
end_comment

begin_function
specifier|static
name|callb_id_t
name|callb_add_common
parameter_list|(
name|boolean_t
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|code
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|class
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|kthread_id_t
name|t
parameter_list|)
block|{
name|callb_t
modifier|*
name|cp
decl_stmt|;
name|ASSERT
argument_list|(
name|class
operator|<
name|NCBCLASS
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
while|while
condition|(
name|ct
operator|->
name|ct_busy
condition|)
name|cv_wait
argument_list|(
operator|&
name|ct
operator|->
name|ct_busy_cv
argument_list|,
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|ct
operator|->
name|ct_freelist
operator|)
operator|==
name|NULL
condition|)
block|{
name|ct
operator|->
name|ct_ncallb
operator|++
expr_stmt|;
name|cp
operator|=
operator|(
name|callb_t
operator|*
operator|)
name|kmem_zalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|callb_t
argument_list|)
argument_list|,
name|KM_SLEEP
argument_list|)
expr_stmt|;
block|}
name|ct
operator|->
name|ct_freelist
operator|=
name|cp
operator|->
name|c_next
expr_stmt|;
name|cp
operator|->
name|c_thread
operator|=
name|t
expr_stmt|;
name|cp
operator|->
name|c_func
operator|=
name|func
expr_stmt|;
name|cp
operator|->
name|c_arg
operator|=
name|arg
expr_stmt|;
name|cp
operator|->
name|c_class
operator|=
operator|(
name|uchar_t
operator|)
name|class
expr_stmt|;
name|cp
operator|->
name|c_flag
operator||=
name|CALLB_TAKEN
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|strlen
argument_list|(
name|name
argument_list|)
operator|>
name|CB_MAXNAME
condition|)
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"callb_add: name of callback function '%s' "
literal|"too long -- truncated to %d chars"
argument_list|,
name|name
argument_list|,
name|CB_MAXNAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|cp
operator|->
name|c_name
argument_list|,
name|name
argument_list|,
name|CB_MAXNAME
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_name
index|[
name|CB_MAXNAME
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* 	 * Insert the new callb at the head of its class list. 	 */
name|cp
operator|->
name|c_next
operator|=
name|ct
operator|->
name|ct_first_cb
index|[
name|class
index|]
expr_stmt|;
name|ct
operator|->
name|ct_first_cb
index|[
name|class
index|]
operator|=
name|cp
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|callb_id_t
operator|)
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The default function to add an entry to the callback table.  Since  * it uses curthread as the thread identifier to store in the table,  * it should be used for the normal case of a thread which is calling  * to add ITSELF to the table.  */
end_comment

begin_function
name|callb_id_t
name|callb_add
parameter_list|(
name|boolean_t
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|code
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|class
parameter_list|,
name|char
modifier|*
name|name
parameter_list|)
block|{
return|return
operator|(
name|callb_add_common
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|class
argument_list|,
name|name
argument_list|,
name|curthread
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * A special version of callb_add() above for use by threads which  * might be adding an entry to the table on behalf of some other  * thread (for example, one which is constructed but not yet running).  * In this version the thread id is an argument.  */
end_comment

begin_function
name|callb_id_t
name|callb_add_thread
parameter_list|(
name|boolean_t
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|code
parameter_list|)
parameter_list|,
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|class
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|kthread_id_t
name|t
parameter_list|)
block|{
return|return
operator|(
name|callb_add_common
argument_list|(
name|func
argument_list|,
name|arg
argument_list|,
name|class
argument_list|,
name|name
argument_list|,
name|t
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * callout_delete() is called to remove an entry identified by id  * that was originally placed there by a call to callout_add().  * return -1 if fail to delete a callb entry otherwise return 0.  */
end_comment

begin_function
name|int
name|callb_delete
parameter_list|(
name|callb_id_t
name|id
parameter_list|)
block|{
name|callb_t
modifier|*
modifier|*
name|pp
decl_stmt|;
name|callb_t
modifier|*
name|me
init|=
operator|(
name|callb_t
operator|*
operator|)
name|id
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|pp
operator|=
operator|&
name|ct
operator|->
name|ct_first_cb
index|[
name|me
operator|->
name|c_class
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|pp
operator|!=
name|NULL
operator|&&
operator|*
name|pp
operator|!=
name|me
condition|)
name|pp
operator|=
operator|&
operator|(
operator|*
name|pp
operator|)
operator|->
name|c_next
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|*
name|pp
operator|!=
name|me
condition|)
block|{
name|cmn_err
argument_list|(
name|CE_WARN
argument_list|,
literal|"callb delete bogus entry 0x%p"
argument_list|,
operator|(
name|void
operator|*
operator|)
name|me
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* DEBUG */
comment|/* 		 * It is not allowed to delete a callb in the middle of 		 * executing otherwise, the callb_execute() will be confused. 		 */
if|if
condition|(
operator|!
operator|(
name|me
operator|->
name|c_flag
operator|&
name|CALLB_EXECUTING
operator|)
condition|)
break|break;
name|cv_wait
argument_list|(
operator|&
name|me
operator|->
name|c_done_cv
argument_list|,
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
block|}
comment|/* relink the class list */
operator|*
name|pp
operator|=
name|me
operator|->
name|c_next
expr_stmt|;
comment|/* clean up myself and return the free callb to the head of freelist */
name|me
operator|->
name|c_flag
operator|=
name|CALLB_FREE
expr_stmt|;
name|me
operator|->
name|c_next
operator|=
name|ct
operator|->
name|ct_freelist
expr_stmt|;
name|ct
operator|->
name|ct_freelist
operator|=
name|me
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * class:	indicates to execute all callbs in the same class;  * code:	optional argument for the callb functions.  * return:	 = 0: success  *		!= 0: ptr to string supplied when callback was registered  */
end_comment

begin_function
name|void
modifier|*
name|callb_execute_class
parameter_list|(
name|int
name|class
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|callb_t
modifier|*
name|cp
decl_stmt|;
name|void
modifier|*
name|ret
init|=
name|NULL
decl_stmt|;
name|ASSERT
argument_list|(
name|class
operator|<
name|NCBCLASS
argument_list|)
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|ct
operator|->
name|ct_first_cb
index|[
name|class
index|]
init|;
name|cp
operator|!=
name|NULL
operator|&&
name|ret
operator|==
literal|0
condition|;
name|cp
operator|=
name|cp
operator|->
name|c_next
control|)
block|{
while|while
condition|(
name|cp
operator|->
name|c_flag
operator|&
name|CALLB_EXECUTING
condition|)
name|cv_wait
argument_list|(
operator|&
name|cp
operator|->
name|c_done_cv
argument_list|,
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
comment|/* 		 * cont if the callb is deleted while we're sleeping 		 */
if|if
condition|(
name|cp
operator|->
name|c_flag
operator|==
name|CALLB_FREE
condition|)
continue|continue;
name|cp
operator|->
name|c_flag
operator||=
name|CALLB_EXECUTING
expr_stmt|;
ifdef|#
directive|ifdef
name|CALLB_DEBUG
name|printf
argument_list|(
literal|"callb_execute: name=%s func=%p arg=%p\n"
argument_list|,
name|cp
operator|->
name|c_name
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cp
operator|->
name|c_func
argument_list|,
operator|(
name|void
operator|*
operator|)
name|cp
operator|->
name|c_arg
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* CALLB_DEBUG */
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
comment|/* If callback function fails, pass back client's name */
if|if
condition|(
operator|!
call|(
modifier|*
name|cp
operator|->
name|c_func
call|)
argument_list|(
name|cp
operator|->
name|c_arg
argument_list|,
name|code
argument_list|)
condition|)
name|ret
operator|=
name|cp
operator|->
name|c_name
expr_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
name|cp
operator|->
name|c_flag
operator|&=
operator|~
name|CALLB_EXECUTING
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|cp
operator|->
name|c_done_cv
argument_list|)
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * callers make sure no recursive entries to this func.  * dp->cc_lockp is registered by callb_add to protect callb_cpr_t structure.  *  * When calling to stop a kernel thread (code == CB_CODE_CPR_CHKPT) we  * use a cv_timedwait() in case the kernel thread is blocked.  *  * Note that this is a generic callback handler for daemon CPR and  * should NOT be changed to accommodate any specific requirement in a daemon.  * Individual daemons that require changes to the handler shall write  * callback routines in their own daemon modules.  */
end_comment

begin_function
name|boolean_t
name|callb_generic_cpr
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|code
parameter_list|)
block|{
name|callb_cpr_t
modifier|*
name|cp
init|=
operator|(
name|callb_cpr_t
operator|*
operator|)
name|arg
decl_stmt|;
name|clock_t
name|ret
init|=
literal|0
decl_stmt|;
comment|/* assume success */
name|mutex_enter
argument_list|(
name|cp
operator|->
name|cc_lockp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CB_CODE_CPR_CHKPT
case|:
name|cp
operator|->
name|cc_events
operator||=
name|CALLB_CPR_START
expr_stmt|;
ifdef|#
directive|ifdef
name|CPR_NOT_THREAD_SAFE
while|while
condition|(
operator|!
operator|(
name|cp
operator|->
name|cc_events
operator|&
name|CALLB_CPR_SAFE
operator|)
condition|)
comment|/* cv_timedwait() returns -1 if it times out. */
if|if
condition|(
operator|(
name|ret
operator|=
name|cv_reltimedwait
argument_list|(
operator|&
name|cp
operator|->
name|cc_callb_cv
argument_list|,
name|cp
operator|->
name|cc_lockp
argument_list|,
operator|(
name|callb_timeout_sec
operator|*
name|hz
operator|)
argument_list|,
name|TR_CLOCK_TICK
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
break|break;
endif|#
directive|endif
break|break;
case|case
name|CB_CODE_CPR_RESUME
case|:
name|cp
operator|->
name|cc_events
operator|&=
operator|~
name|CALLB_CPR_START
expr_stmt|;
name|cv_signal
argument_list|(
operator|&
name|cp
operator|->
name|cc_stop_cv
argument_list|)
expr_stmt|;
break|break;
block|}
name|mutex_exit
argument_list|(
name|cp
operator|->
name|cc_lockp
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|!=
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The generic callback function associated with kernel threads which  * are always considered safe.  */
end_comment

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|boolean_t
name|callb_generic_cpr_safe
parameter_list|(
name|void
modifier|*
name|arg
parameter_list|,
name|int
name|code
parameter_list|)
block|{
return|return
operator|(
name|B_TRUE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Prevent additions to callback table.  */
end_comment

begin_function
name|void
name|callb_lock_table
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ct
operator|->
name|ct_busy
operator|==
literal|0
argument_list|)
expr_stmt|;
name|ct
operator|->
name|ct_busy
operator|=
literal|1
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Allow additions to callback table.  */
end_comment

begin_function
name|void
name|callb_unlock_table
parameter_list|(
name|void
parameter_list|)
block|{
name|mutex_enter
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
name|ASSERT
argument_list|(
name|ct
operator|->
name|ct_busy
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|ct
operator|->
name|ct_busy
operator|=
literal|0
expr_stmt|;
name|cv_broadcast
argument_list|(
operator|&
name|ct
operator|->
name|ct_busy_cv
argument_list|)
expr_stmt|;
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Return a boolean value indicating whether a particular kernel thread is  * stopped in accordance with the cpr callback protocol.  If returning  * false, also return a pointer to the thread name via the 2nd argument.  */
end_comment

begin_function
name|boolean_t
name|callb_is_stopped
parameter_list|(
name|kthread_id_t
name|tp
parameter_list|,
name|caddr_t
modifier|*
name|thread_name
parameter_list|)
block|{
name|callb_t
modifier|*
name|cp
decl_stmt|;
name|boolean_t
name|ret_val
decl_stmt|;
name|mutex_enter
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|ct
operator|->
name|ct_first_cb
index|[
name|CB_CL_CPR_DAEMON
index|]
init|;
name|cp
operator|!=
name|NULL
operator|&&
name|tp
operator|!=
name|cp
operator|->
name|c_thread
condition|;
name|cp
operator|=
name|cp
operator|->
name|c_next
control|)
empty_stmt|;
name|ret_val
operator|=
operator|(
name|cp
operator|!=
name|NULL
operator|)
expr_stmt|;
if|if
condition|(
name|ret_val
condition|)
block|{
comment|/* 		 * We found the thread in the callback table and have 		 * provisionally set the return value to true.  Now 		 * see if it is marked "safe" and is sleeping or stopped. 		 */
name|callb_cpr_t
modifier|*
name|ccp
init|=
operator|(
name|callb_cpr_t
operator|*
operator|)
name|cp
operator|->
name|c_arg
decl_stmt|;
operator|*
name|thread_name
operator|=
name|cp
operator|->
name|c_name
expr_stmt|;
comment|/* in case not stopped */
name|mutex_enter
argument_list|(
name|ccp
operator|->
name|cc_lockp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ccp
operator|->
name|cc_events
operator|&
name|CALLB_CPR_SAFE
condition|)
block|{
name|int
name|retry
decl_stmt|;
name|mutex_exit
argument_list|(
name|ccp
operator|->
name|cc_lockp
argument_list|)
expr_stmt|;
for|for
control|(
name|retry
operator|=
literal|0
init|;
name|retry
operator|<
name|CALLB_MAX_RETRY
condition|;
name|retry
operator|++
control|)
block|{
name|thread_lock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_SLEEP
operator||
name|TS_STOPPED
operator|)
condition|)
block|{
name|thread_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
break|break;
block|}
name|thread_unlock
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|delay
argument_list|(
name|CALLB_THREAD_DELAY
argument_list|)
expr_stmt|;
block|}
name|ret_val
operator|=
name|retry
operator|<
name|CALLB_MAX_RETRY
expr_stmt|;
block|}
else|else
block|{
name|ret_val
operator|=
operator|(
name|ccp
operator|->
name|cc_events
operator|&
name|CALLB_CPR_ALWAYS_SAFE
operator|)
operator|!=
literal|0
expr_stmt|;
name|mutex_exit
argument_list|(
name|ccp
operator|->
name|cc_lockp
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * Thread not found in callback table.  Make the best 		 * attempt to identify the thread in the error message. 		 */
name|ulong_t
name|offset
decl_stmt|;
name|char
modifier|*
name|sym
init|=
name|kobj_getsymname
argument_list|(
operator|(
name|uintptr_t
operator|)
name|tp
operator|->
name|t_startpc
argument_list|,
operator|&
name|offset
argument_list|)
decl_stmt|;
operator|*
name|thread_name
operator|=
name|sym
condition|?
name|sym
else|:
literal|"*unknown*"
expr_stmt|;
block|}
name|mutex_exit
argument_list|(
operator|&
name|ct
operator|->
name|ct_lock
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret_val
operator|)
return|;
block|}
end_function

end_unit

