begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_empty
empty|#
end_empty

begin_comment
comment|/*  * pi - Pascal interpreter code translator  *  * Charles Haley, Bill Joy UCB  * Version 1.0 August 1977  */
end_comment

begin_include
include|#
directive|include
file|"whoami"
end_include

begin_include
include|#
directive|include
file|"0.h"
end_include

begin_include
include|#
directive|include
file|"opcode.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|PI
end_ifdef

begin_comment
comment|/*  * Array of information about pre-defined, block 0 symbols.  */
end_comment

begin_decl_stmt
name|int
modifier|*
name|biltins
index|[]
block|{
comment|/* 	 * Types 	 */
literal|"boolean"
operator|,
literal|"char"
operator|,
literal|"integer"
operator|,
literal|"real"
operator|,
literal|"_nil"
operator|,
comment|/* dummy name */
literal|0
operator|,
comment|/* 	 * Ranges 	 */
name|TINT
operator|,
literal|0177777
operator|,
literal|0177600
operator|,
literal|0
operator|,
literal|0177
operator|,
name|TINT
operator|,
literal|0177777
operator|,
literal|0100000
operator|,
literal|0
operator|,
literal|077777
operator|,
name|TINT
operator|,
literal|0100000
operator|,
literal|0
operator|,
literal|077777
operator|,
literal|0177777
operator|,
name|TCHAR
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|127
operator|,
name|TBOOL
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|1
operator|,
name|TDOUBLE
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
literal|0
operator|,
comment|/* fake for reals */
literal|0
operator|,
comment|/* 	 * Built-in composite types 	 */
literal|"Boolean"
operator|,
literal|"intset"
operator|,
literal|"alfa"
operator|,
literal|"text"
operator|,
literal|"input"
operator|,
literal|"output"
operator|,
comment|/* 	 * Built-in constants 	 */
literal|"true"
operator|,
name|TBOOL
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"false"
operator|,
name|TBOOL
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"minint"
operator|,
name|T4INT
operator|,
literal|0100000
operator|,
literal|0
operator|,
literal|"maxint"
operator|,
name|T4INT
operator|,
literal|077777
operator|,
literal|0177777
operator|,
literal|"minchar"
operator|,
name|T1CHAR
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"maxchar"
operator|,
name|T1CHAR
operator|,
literal|0177
operator|,
literal|0
operator|,
literal|"bell"
operator|,
name|T1CHAR
operator|,
literal|07
operator|,
literal|0
operator|,
literal|"tab"
operator|,
name|T1CHAR
operator|,
literal|011
operator|,
literal|0
operator|,
literal|0
operator|,
comment|/* 	 * Built-in functions 	 */
literal|"abs"
operator|,
name|O_ABS2
operator|,
literal|"arctan"
operator|,
name|O_ATAN
operator|,
literal|"card"
operator|,
name|O_CARD
operator||
name|NSTAND
operator|,
literal|"chr"
operator|,
name|O_CHR2
operator|,
literal|"clock"
operator|,
name|O_CLCK
operator||
name|NSTAND
operator|,
literal|"cos"
operator|,
name|O_COS
operator|,
literal|"eof"
operator|,
name|O_EOF
operator|,
literal|"eoln"
operator|,
name|O_EOLN
operator|,
literal|"eos"
operator|,
literal|0
operator|,
literal|"exp"
operator|,
name|O_EXP
operator|,
literal|"expo"
operator|,
name|O_EXPO
operator||
name|NSTAND
operator|,
literal|"ln"
operator|,
name|O_LN
operator|,
literal|"odd"
operator|,
name|O_ODD2
operator|,
literal|"ord"
operator|,
name|O_ORD2
operator|,
literal|"pred"
operator|,
name|O_PRED2
operator|,
literal|"round"
operator|,
name|O_ROUND
operator|,
literal|"sin"
operator|,
name|O_SIN
operator|,
literal|"sqr"
operator|,
name|O_SQR2
operator|,
literal|"sqrt"
operator|,
name|O_SQRT
operator|,
literal|"succ"
operator|,
name|O_SUCC2
operator|,
literal|"trunc"
operator|,
name|O_TRUNC
operator|,
literal|"undefined"
operator|,
name|O_UNDEF
operator||
name|NSTAND
operator|,
comment|/* 	 * UNIX extensions 	 */
literal|"argc"
operator|,
name|O_ARGC
operator||
name|NSTAND
operator|,
literal|"random"
operator|,
name|O_RANDOM
operator||
name|NSTAND
operator|,
literal|"seed"
operator|,
name|O_SEED
operator||
name|NSTAND
operator|,
literal|"wallclock"
operator|,
name|O_WCLCK
operator||
name|NSTAND
operator|,
literal|"sysclock"
operator|,
name|O_SCLCK
operator||
name|NSTAND
operator|,
literal|0
operator|,
comment|/* 	 * Built-in procedures 	 */
literal|"date"
operator|,
name|O_DATE
operator||
name|NSTAND
operator|,
literal|"flush"
operator|,
name|O_FLUSH
operator||
name|NSTAND
operator|,
literal|"get"
operator|,
name|O_GET
operator|,
literal|"getseg"
operator|,
literal|0
operator|,
literal|"halt"
operator|,
name|O_HALT
operator||
name|NSTAND
operator|,
literal|"linelimit"
operator|,
name|O_LLIMIT
operator||
name|NSTAND
operator|,
literal|"message"
operator|,
name|O_MESSAGE
operator||
name|NSTAND
operator|,
literal|"new"
operator|,
name|O_NEW
operator|,
literal|"pack"
operator|,
name|O_PACK
operator|,
literal|"page"
operator|,
name|O_PAGE
operator|,
literal|"put"
operator|,
name|O_PUT
operator|,
literal|"putseg"
operator|,
literal|0
operator|,
literal|"read"
operator|,
name|O_READ4
operator|,
literal|"readln"
operator|,
name|O_READLN
operator|,
literal|"remove"
operator|,
name|O_REMOVE
operator||
name|NSTAND
operator|,
literal|"reset"
operator|,
name|O_RESET
operator|,
literal|"rewrite"
operator|,
name|O_REWRITE
operator|,
literal|"time"
operator|,
name|O_TIME
operator||
name|NSTAND
operator|,
literal|"unpack"
operator|,
name|O_UNPACK
operator|,
literal|"write"
operator|,
name|O_WRIT2
operator|,
literal|"writeln"
operator|,
name|O_WRITLN
operator|,
comment|/* 	 * UNIX extensions 	 */
literal|"argv"
operator|,
name|O_ARGV
operator||
name|NSTAND
operator|,
literal|"null"
operator|,
name|O_NULL
operator||
name|NSTAND
operator|,
literal|"stlimit"
operator|,
name|O_STLIM
operator||
name|NSTAND
operator|,
literal|0
operator|,
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_escape
end_escape

begin_comment
comment|/*  * NAMELIST SEGMENT DEFINITIONS  */
end_comment

begin_struct
struct|struct
name|nls
block|{
name|struct
name|nl
modifier|*
name|nls_low
decl_stmt|;
name|struct
name|nl
modifier|*
name|nls_high
decl_stmt|;
block|}
name|ntab
index|[
name|MAXNL
index|]
struct|,
modifier|*
name|nlact
struct|;
end_struct

begin_decl_stmt
name|struct
name|nl
name|nl
index|[
name|INL
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|nlp
name|nl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nls
modifier|*
name|nlact
name|ntab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Initnl initializes the first namelist segment and then  * uses the array biltins to initialize the name list for  * block 0.  */
end_comment

begin_macro
name|initnl
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|ntab
index|[
literal|0
index|]
operator|.
name|nls_low
operator|=
name|nl
expr_stmt|;
name|ntab
index|[
literal|0
index|]
operator|.
name|nls_high
operator|=
operator|&
name|nl
index|[
name|INL
index|]
expr_stmt|;
name|defnl
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* 	 * Fundamental types 	 */
for|for
control|(
name|q
operator|=
name|biltins
init|;
operator|*
name|q
operator|!=
literal|0
condition|;
name|q
operator|++
control|)
name|hdefnl
argument_list|(
operator|*
name|q
argument_list|,
name|TYPE
argument_list|,
name|nlp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|q
operator|++
expr_stmt|;
comment|/* 	 * Ranges 	 */
while|while
condition|(
operator|*
name|q
condition|)
block|{
name|p
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|RANGE
argument_list|,
name|nl
operator|+
operator|*
name|q
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|nl
index|[
operator|*
name|q
operator|++
index|]
operator|.
name|type
operator|=
name|p
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|4
condition|;
name|i
operator|++
control|)
name|p
operator|->
name|value
index|[
name|i
index|]
operator|=
operator|*
name|q
operator|++
expr_stmt|;
block|}
name|q
operator|++
expr_stmt|;
comment|/* 	 * Pre-defined composite types 	 */
name|hdefnl
argument_list|(
operator|*
name|q
operator|++
argument_list|,
name|TYPE
argument_list|,
name|nl
operator|+
name|T1BOOL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|enter
argument_list|(
name|defnl
argument_list|(
operator|(
name|intset
operator|=
operator|*
name|q
operator|++
operator|)
argument_list|,
name|TYPE
argument_list|,
name|nlp
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|defnl
argument_list|(
literal|0
argument_list|,
name|SET
argument_list|,
name|nlp
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defnl
argument_list|(
literal|0
argument_list|,
name|RANGE
argument_list|,
name|nl
operator|+
name|TINT
argument_list|,
literal|0
argument_list|)
operator|->
name|value
index|[
literal|3
index|]
operator|=
literal|127
expr_stmt|;
name|p
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|RANGE
argument_list|,
name|nl
operator|+
name|TINT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|value
index|[
literal|1
index|]
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|value
index|[
literal|3
index|]
operator|=
literal|10
expr_stmt|;
name|defnl
argument_list|(
literal|0
argument_list|,
name|ARRAY
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|1
argument_list|)
operator|->
name|chain
operator|=
name|p
expr_stmt|;
name|hdefnl
argument_list|(
operator|*
name|q
operator|++
argument_list|,
name|TYPE
argument_list|,
name|nlp
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* "alfa" */
name|hdefnl
argument_list|(
operator|*
name|q
operator|++
argument_list|,
name|TYPE
argument_list|,
name|nlp
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* "text" */
name|p
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
name|FILE
argument_list|,
name|nl
operator|+
name|T1CHAR
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|->
name|nl_flags
operator|=
operator||
name|NFILES
expr_stmt|;
name|input
operator|=
name|hdefnl
argument_list|(
operator|*
name|q
operator|++
argument_list|,
name|VAR
argument_list|,
name|p
argument_list|,
operator|-
literal|2
argument_list|)
expr_stmt|;
comment|/* "input" */
name|output
operator|=
name|hdefnl
argument_list|(
operator|*
name|q
operator|++
argument_list|,
name|VAR
argument_list|,
name|p
argument_list|,
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/* "output" */
comment|/* 	 * Pre-defined constants 	 */
for|for
control|(
init|;
operator|*
name|q
condition|;
name|q
operator|=
operator|+
literal|4
control|)
name|hdefnl
argument_list|(
name|q
index|[
literal|0
index|]
argument_list|,
name|CONST
argument_list|,
name|nl
operator|+
name|q
index|[
literal|1
index|]
argument_list|,
name|q
index|[
literal|2
index|]
argument_list|)
operator|->
name|value
index|[
literal|1
index|]
operator|=
name|q
index|[
literal|3
index|]
expr_stmt|;
comment|/* 	 * Built-in procedures and functions 	 */
for|for
control|(
name|q
operator|++
init|;
operator|*
name|q
condition|;
name|q
operator|=
operator|+
literal|2
control|)
name|hdefnl
argument_list|(
name|q
index|[
literal|0
index|]
argument_list|,
name|FUNC
argument_list|,
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|q
operator|++
init|;
operator|*
name|q
condition|;
name|q
operator|=
operator|+
literal|2
control|)
name|hdefnl
argument_list|(
name|q
index|[
literal|0
index|]
argument_list|,
name|PROC
argument_list|,
literal|0
argument_list|,
name|q
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|hdefnl
argument_list|(
argument|sym
argument_list|,
argument|cls
argument_list|,
argument|typ
argument_list|,
argument|val
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|sym
condition|)
name|hash
argument_list|(
name|sym
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|defnl
argument_list|(
name|sym
argument_list|,
name|cls
argument_list|,
name|typ
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
condition|)
name|enter
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Free up the name list segments  * at the end of a statement/proc/func  * All segments are freed down to the one in which  * p points.  */
end_comment

begin_macro
name|nlfree
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nlp
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|nlact
operator|->
name|nls_low
operator|>
name|nlp
operator|||
name|nlact
operator|->
name|nls_high
operator|<
name|nlp
condition|)
block|{
name|free
argument_list|(
name|nlact
operator|->
name|nls_low
argument_list|)
expr_stmt|;
name|nlact
operator|->
name|nls_low
operator|=
name|NIL
expr_stmt|;
name|nlact
operator|->
name|nls_high
operator|=
name|NIL
expr_stmt|;
operator|--
name|nlact
expr_stmt|;
if|if
condition|(
name|nlact
operator|<
operator|&
name|ntab
index|[
literal|0
index|]
condition|)
name|panic
argument_list|(
literal|"nlfree"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_expr_stmt
name|char
name|VARIABLE
index|[]
literal|"variable"
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|classes
index|[]
block|{
literal|"undefined"
operator|,
literal|"constant"
operator|,
literal|"type"
operator|,
name|VARIABLE
operator|,
literal|"array"
operator|,
literal|"pointer or file"
operator|,
literal|"record"
operator|,
literal|"field"
operator|,
literal|"procedure"
operator|,
literal|"function"
operator|,
name|VARIABLE
operator|,
name|VARIABLE
operator|,
literal|"pointer"
operator|,
literal|"file"
operator|,
literal|"set"
operator|,
literal|"subrange"
operator|,
literal|"label"
operator|,
literal|"withptr"
operator|,
literal|"scalar"
operator|,
literal|"string"
operator|,
literal|"program"
operator|,
literal|"improper"
operator|,
ifdef|#
directive|ifdef
name|DEBUG
literal|"variant"
operator|,
endif|#
directive|endif
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|char
name|snark
index|[]
literal|"SNARK"
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|PI
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|ctext
index|[]
block|{
literal|"BADUSE"
operator|,
literal|"CONST"
operator|,
literal|"TYPE"
operator|,
literal|"VAR"
operator|,
literal|"ARRAY"
operator|,
literal|"PTRFILE"
operator|,
literal|"RECORD"
operator|,
literal|"FIELD"
operator|,
literal|"PROC"
operator|,
literal|"FUNC"
operator|,
literal|"FVAR"
operator|,
literal|"REF"
operator|,
literal|"PTR"
operator|,
literal|"FILE"
operator|,
literal|"SET"
operator|,
literal|"RANGE"
operator|,
literal|"LABEL"
operator|,
literal|"WITHPTR"
operator|,
literal|"SCAL"
operator|,
literal|"STR"
operator|,
literal|"PROG"
operator|,
literal|"IMPROPER"
operator|,
literal|"VARNT"
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_expr_stmt
name|char
operator|*
name|stars
literal|"\t***"
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Dump the namelist from the  * current nlp down to 'to'.  * All the namelist is dumped if  * to is NIL.  */
end_comment

begin_macro
name|dumpnl
argument_list|(
argument|to
argument_list|,
argument|rout
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
name|struct
name|nls
modifier|*
name|nlsp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|v
decl_stmt|,
name|head
decl_stmt|;
if|if
condition|(
name|opt
argument_list|(
literal|'y'
argument_list|)
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|to
operator|!=
name|NIL
condition|)
name|printf
argument_list|(
literal|"\n\"%s\" Block=%d\n"
argument_list|,
name|rout
argument_list|,
name|cbn
argument_list|)
expr_stmt|;
name|nlsp
operator|=
name|nlact
expr_stmt|;
name|head
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|nlp
init|;
name|p
operator|!=
name|to
condition|;
control|)
block|{
if|if
condition|(
name|p
operator|==
name|nlsp
operator|->
name|nls_low
condition|)
block|{
if|if
condition|(
name|nlsp
operator|==
operator|&
name|ntab
index|[
literal|0
index|]
condition|)
break|break;
name|nlsp
operator|--
expr_stmt|;
name|p
operator|=
name|nlsp
operator|->
name|nls_high
expr_stmt|;
block|}
name|p
operator|--
expr_stmt|;
if|if
condition|(
name|head
operator|==
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|"\tName\tClass  Bn+Flags\tType\tVal\tChn\n"
argument_list|)
expr_stmt|;
name|head
operator|++
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%3d:"
argument_list|,
name|nloff
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|symbol
condition|)
name|printf
argument_list|(
literal|"\t%.7s"
argument_list|,
name|p
operator|->
name|symbol
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|class
condition|)
name|printf
argument_list|(
literal|"\t%s"
argument_list|,
name|ctext
index|[
name|p
operator|->
name|class
index|]
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
literal|037
condition|)
name|printf
argument_list|(
literal|"%d "
argument_list|,
name|p
operator|->
name|nl_flags
operator|&
literal|037
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
name|NMOD
condition|)
name|putchar
argument_list|(
literal|'M'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
name|NUSED
condition|)
name|putchar
argument_list|(
literal|'U'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|nl_flags
operator|&
name|NFILES
condition|)
name|putchar
argument_list|(
literal|'F'
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|type
condition|)
name|printf
argument_list|(
literal|"\t[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|type
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
name|v
operator|=
name|p
operator|->
name|value
index|[
literal|0
index|]
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|class
condition|)
block|{
case|case
name|TYPE
case|:
break|break;
case|case
name|VARNT
case|:
goto|goto
name|con
goto|;
case|case
name|CONST
case|:
switch|switch
condition|(
name|nloff
argument_list|(
name|p
operator|->
name|type
argument_list|)
condition|)
block|{
default|default:
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|TDOUBLE
case|:
name|printf
argument_list|(
literal|"\t%f"
argument_list|,
name|p
operator|->
name|real
argument_list|)
expr_stmt|;
break|break;
case|case
name|TINT
case|:
name|con
label|:
name|printf
argument_list|(
literal|"\t%ld"
argument_list|,
name|p
operator|->
name|range
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|TSTR
case|:
name|printf
argument_list|(
literal|"\t'%s'"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
case|case
name|VAR
case|:
case|case
name|REF
case|:
case|case
name|WITHPTR
case|:
name|printf
argument_list|(
literal|"\t%d,%d"
argument_list|,
name|cbn
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SCAL
case|:
case|case
name|RANGE
case|:
name|printf
argument_list|(
literal|"\t%ld..%ld"
argument_list|,
name|p
operator|->
name|range
index|[
literal|0
index|]
argument_list|,
name|p
operator|->
name|range
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|RECORD
case|:
name|printf
argument_list|(
literal|"\t%d(%d)"
argument_list|,
name|v
argument_list|,
name|p
operator|->
name|value
index|[
name|NL_FLDSZ
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|FIELD
case|:
name|printf
argument_list|(
literal|"\t%d"
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|printf
argument_list|(
literal|"\t\"%s\""
argument_list|,
name|p
operator|->
name|value
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
goto|goto
name|casedef
goto|;
case|case
name|FVAR
case|:
case|case
name|FUNC
case|:
case|case
name|PROC
case|:
case|case
name|PROG
case|:
if|if
condition|(
name|cbn
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"\t<%o>"
argument_list|,
name|p
operator|->
name|value
index|[
literal|0
index|]
operator|&
literal|0377
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|value
index|[
literal|0
index|]
operator|&
name|NSTAND
condition|)
name|printf
argument_list|(
literal|"\tNSTAND"
argument_list|)
expr_stmt|;
break|break;
block|}
name|v
operator|=
name|p
operator|->
name|value
index|[
literal|1
index|]
expr_stmt|;
default|default:
name|casedef
label|:
if|if
condition|(
name|v
condition|)
name|printf
argument_list|(
literal|"\t<%d>"
argument_list|,
name|v
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
name|stars
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|chain
condition|)
name|printf
argument_list|(
literal|"\t[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|chain
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|class
condition|)
block|{
case|case
name|RECORD
case|:
if|if
condition|(
name|p
operator|->
name|value
index|[
name|NL_VARNT
index|]
condition|)
name|printf
argument_list|(
literal|"\tVARNT=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|value
index|[
name|NL_VARNT
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|value
index|[
name|NL_TAG
index|]
condition|)
name|printf
argument_list|(
literal|" TAG=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|value
index|[
name|NL_TAG
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|VARNT
case|:
name|printf
argument_list|(
literal|"\tVTOREC=[%d]"
argument_list|,
name|nloff
argument_list|(
name|p
operator|->
name|value
index|[
name|NL_VTOREC
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\tNo entries\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/*  * Define a new name list entry  * with initial symbol, class, type  * and value[0] as given.  A new name  * list segment is allocated to hold  * the next name list slot if necessary.  */
end_comment

begin_macro
name|defnl
argument_list|(
argument|sym
argument_list|,
argument|cls
argument_list|,
argument|typ
argument_list|,
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|sym
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|nl
modifier|*
name|typ
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
modifier|*
name|q
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|p
operator|=
name|nlp
expr_stmt|;
comment|/* 	 * Zero out this entry 	 */
name|q
operator|=
name|p
expr_stmt|;
name|i
operator|=
operator|(
sizeof|sizeof
expr|*
name|p
operator|)
operator|/
literal|2
expr_stmt|;
do|do
operator|*
name|q
operator|++
operator|=
literal|0
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* 	 * Insert the values 	 */
name|p
operator|->
name|symbol
operator|=
name|sym
expr_stmt|;
name|p
operator|->
name|class
operator|=
name|cls
expr_stmt|;
name|p
operator|->
name|type
operator|=
name|typ
expr_stmt|;
name|p
operator|->
name|nl_block
operator|=
name|cbn
expr_stmt|;
name|p
operator|->
name|value
index|[
literal|0
index|]
operator|=
name|val
expr_stmt|;
comment|/* 	 * Insure that the next namelist 	 * entry actually exists. This is 	 * really not needed here, it would 	 * suffice to do it at entry if we 	 * need the slot.  It is done this 	 * way because, historically, nlp 	 * always pointed at the next namelist 	 * slot. 	 */
name|nlp
operator|++
expr_stmt|;
if|if
condition|(
name|nlp
operator|>=
name|nlact
operator|->
name|nls_high
condition|)
block|{
name|i
operator|=
name|NLINC
expr_stmt|;
name|cp
operator|=
name|alloc
argument_list|(
name|NLINC
operator|*
sizeof|sizeof
expr|*
name|nlp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
operator|-
literal|1
condition|)
block|{
name|i
operator|=
name|NLINC
operator|/
literal|2
expr_stmt|;
name|cp
operator|=
name|alloc
argument_list|(
operator|(
name|NLINC
operator|/
literal|2
operator|)
operator|*
sizeof|sizeof
expr|*
name|nlp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"Ran out of memory (defnl)"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|nlact
operator|++
expr_stmt|;
if|if
condition|(
name|nlact
operator|>=
operator|&
name|ntab
index|[
name|MAXNL
index|]
condition|)
block|{
name|error
argument_list|(
literal|"Ran out of name list tables"
argument_list|)
expr_stmt|;
name|pexit
argument_list|(
name|DIED
argument_list|)
expr_stmt|;
block|}
name|nlp
operator|=
name|cp
expr_stmt|;
name|nlact
operator|->
name|nls_low
operator|=
name|nlp
expr_stmt|;
name|nlact
operator|->
name|nls_high
operator|=
name|nlact
operator|->
name|nls_low
operator|+
name|i
expr_stmt|;
block|}
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Make a duplicate of the argument  * namelist entry for, e.g., type  * declarations of the form 'type a = b'  * and array indicies.  */
end_comment

begin_macro
name|nlcopy
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|p1
decl_stmt|,
modifier|*
name|p2
decl_stmt|,
name|i
decl_stmt|;
name|p1
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|p2
operator|=
name|defnl
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|i
operator|=
operator|(
sizeof|sizeof
expr|*
name|p
operator|)
operator|/
literal|2
expr_stmt|;
do|do
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
do|while
condition|(
operator|--
name|i
condition|)
do|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Compute a namelist offset  */
end_comment

begin_macro
name|nloff
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|p
operator|-
name|nl
operator|)
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Enter a symbol into the block  * symbol table.  Symbols are hashed  * 64 ways based on low 6 bits of the  * character pointer into the string  * table.  */
end_comment

begin_macro
name|enter
argument_list|(
argument|np
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|nl
modifier|*
name|np
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|nl
modifier|*
name|rp
decl_stmt|,
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|nl
modifier|*
name|p
decl_stmt|;
name|int
name|i
decl_stmt|;
name|rp
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|rp
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
name|cbn
operator|>
literal|0
condition|)
if|if
condition|(
name|rp
operator|->
name|symbol
operator|==
name|input
operator|->
name|symbol
operator|||
name|rp
operator|->
name|symbol
operator|==
name|output
operator|->
name|symbol
condition|)
name|error
argument_list|(
literal|"Pre-defined files input and output must not be redefined"
argument_list|)
expr_stmt|;
name|i
operator|=
name|rp
operator|->
name|symbol
expr_stmt|;
name|i
operator|=
operator|&
literal|077
expr_stmt|;
name|hp
operator|=
name|disptab
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|class
operator|!=
name|BADUSE
operator|&&
name|rp
operator|->
name|class
operator|!=
name|FIELD
condition|)
for|for
control|(
name|p
operator|=
name|hp
init|;
name|p
operator|!=
name|NIL
operator|&&
operator|(
name|p
operator|->
name|nl_block
operator|&
literal|037
operator|)
operator|==
name|cbn
condition|;
name|p
operator|=
name|p
operator|->
name|nl_next
control|)
if|if
condition|(
name|p
operator|->
name|symbol
operator|==
name|rp
operator|->
name|symbol
operator|&&
name|p
operator|->
name|class
operator|!=
name|BADUSE
operator|&&
name|p
operator|->
name|class
operator|!=
name|FIELD
condition|)
block|{
name|error
argument_list|(
literal|"%s is already defined in this block"
argument_list|,
name|rp
operator|->
name|symbol
argument_list|)
expr_stmt|;
break|break;
block|}
name|rp
operator|->
name|nl_next
operator|=
name|hp
expr_stmt|;
name|disptab
index|[
name|i
index|]
operator|=
name|rp
expr_stmt|;
return|return
operator|(
name|rp
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

