begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * William Jolitz and Don Ahn.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)pccons.c	5.11 (Berkeley) 5/21/91  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Header: /usr/bill/working/sys/i386/isa/RCS/pccons.c,v 1.2 92/01/21 14:35:28 william Exp $"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * code to work keyboard& display for PC-style console  */
end_comment

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"conf.h"
end_include

begin_include
include|#
directive|include
file|"ioctl.h"
end_include

begin_include
include|#
directive|include
file|"proc.h"
end_include

begin_include
include|#
directive|include
file|"user.h"
end_include

begin_include
include|#
directive|include
file|"tty.h"
end_include

begin_include
include|#
directive|include
file|"uio.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/isa_device.h"
end_include

begin_include
include|#
directive|include
file|"callout.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"syslog.h"
end_include

begin_include
include|#
directive|include
file|"i386/isa/icu.h"
end_include

begin_include
include|#
directive|include
file|"i386/i386/cons.h"
end_include

begin_decl_stmt
name|struct
name|tty
name|pccons
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|pcconsoftc
block|{
name|char
name|cs_flags
decl_stmt|;
define|#
directive|define
name|CSF_ACTIVE
value|0x1
comment|/* timeout active */
define|#
directive|define
name|CSF_POLLING
value|0x2
comment|/* polling for input */
name|char
name|cs_lastc
decl_stmt|;
comment|/* last char sent */
name|int
name|cs_timo
decl_stmt|;
comment|/* timeouts since interrupt */
name|u_long
name|cs_wedgecnt
decl_stmt|;
comment|/* times restarted */
block|}
name|pcconsoftc
struct|;
end_struct

begin_decl_stmt
name|int
name|pcprobe
argument_list|()
decl_stmt|,
name|pcattach
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|isa_driver
name|pcdriver
init|=
block|{
name|pcprobe
block|,
name|pcattach
block|,
literal|"pc"
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|COL
value|80
end_define

begin_define
define|#
directive|define
name|ROW
value|25
end_define

begin_define
define|#
directive|define
name|CHR
value|2
end_define

begin_define
define|#
directive|define
name|MONO_BASE
value|0x3B4
end_define

begin_define
define|#
directive|define
name|MONO_BUF
value|0xfe0B0000
end_define

begin_define
define|#
directive|define
name|CGA_BASE
value|0x3D4
end_define

begin_define
define|#
directive|define
name|CGA_BUF
value|0xfe0B8000
end_define

begin_define
define|#
directive|define
name|IOPHYSMEM
value|0xA0000
end_define

begin_decl_stmt
name|u_char
name|color
init|=
literal|0xe
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|addr_6845
init|=
name|MONO_BASE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
modifier|*
name|Crtat
init|=
operator|(
name|u_short
operator|*
operator|)
name|MONO_BUF
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|openf
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * We check the console periodically to make sure  * that it hasn't wedged.  Unfortunately, if an XOFF  * is typed on the console, that can't be distinguished  * from more catastrophic failure.  */
end_comment

begin_define
define|#
directive|define
name|CN_TIMERVAL
value|(hz)
end_define

begin_comment
comment|/* frequency at which to check cons */
end_comment

begin_define
define|#
directive|define
name|CN_TIMO
value|(2*60)
end_define

begin_comment
comment|/* intervals to allow for output char */
end_comment

begin_function_decl
name|int
name|pcstart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|pcparam
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|ttrstrt
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|partab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|pcopen
name|__P
argument_list|(
operator|(
name|dev_t
operator|,
name|int
operator|,
name|int
operator|,
expr|struct
name|proc
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Wait for CP to accept last CP command sent  * before setting up next command.  */
end_comment

begin_define
define|#
directive|define
name|waitforlast
parameter_list|(
name|timo
parameter_list|)
value|{ \ 	if (pclast) { \ 		(timo) = 10000; \ 		do \ 			uncache((char *)&pclast->cp_unit); \ 		while ((pclast->cp_unit&CPTAKE) == 0&& --(timo)); \ 	} \ }
end_define

begin_function_decl
name|u_char
name|inb
parameter_list|()
function_decl|;
end_function_decl

begin_macro
name|pcprobe
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_char
name|c
decl_stmt|;
name|int
name|again
init|=
literal|0
decl_stmt|;
comment|/* Enable interrupts and keyboard controller */
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
name|outb
argument_list|(
literal|0x64
argument_list|,
literal|0x60
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
name|outb
argument_list|(
literal|0x60
argument_list|,
literal|0x4D
argument_list|)
expr_stmt|;
comment|/* Start keyboard stuff RESET */
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
comment|/* wait input ready */
name|outb
argument_list|(
literal|0x60
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* RESET */
while|while
condition|(
operator|(
name|c
operator|=
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|)
operator|!=
literal|0xFA
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|0xFE
operator|)
operator|||
operator|(
name|c
operator|==
literal|0xFF
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|again
condition|)
name|printf
argument_list|(
literal|"KEYBOARD disconnected: RECONNECT \n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
comment|/* wait input ready */
name|outb
argument_list|(
literal|0x60
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* RESET */
name|again
operator|=
literal|1
expr_stmt|;
block|}
block|}
comment|/* pick up keyboard reset return code */
while|while
condition|(
operator|(
name|c
operator|=
name|inb
argument_list|(
literal|0x60
argument_list|)
operator|)
operator|!=
literal|0xAA
condition|)
empty_stmt|;
return|return
literal|1
return|;
block|}
end_block

begin_macro
name|pcattach
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|isa_device
modifier|*
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|u_short
modifier|*
name|cp
init|=
name|Crtat
operator|+
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
decl_stmt|;
name|u_short
name|was
decl_stmt|;
comment|/* Crtat initialized to point to MONO buffer   */
comment|/* if not present change to CGA_BUF offset     */
comment|/* ONLY ADD the difference since locore.s adds */
comment|/* in the remapped offset at the right time    */
name|was
operator|=
operator|*
name|Crtat
expr_stmt|;
operator|*
name|Crtat
operator|=
operator|(
name|u_short
operator|)
literal|0xA55A
expr_stmt|;
if|if
condition|(
operator|*
name|Crtat
operator|!=
literal|0xA55A
condition|)
name|printf
argument_list|(
literal|"<mono>"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"<color>"
argument_list|)
expr_stmt|;
operator|*
name|Crtat
operator|=
name|was
expr_stmt|;
name|cursor
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_macro
name|pcopen
argument_list|(
argument|dev_t dev
argument_list|,
argument|int flag
argument_list|,
argument|int mode
argument_list|,
argument|struct proc *p
argument_list|)
end_macro

begin_else
else|#
directive|else
end_else

begin_macro
name|pcopen
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
name|tp
operator|=
operator|&
name|pccons
expr_stmt|;
name|tp
operator|->
name|t_oproc
operator|=
name|pcstart
expr_stmt|;
name|tp
operator|->
name|t_param
operator|=
name|pcparam
expr_stmt|;
name|tp
operator|->
name|t_dev
operator|=
name|dev
expr_stmt|;
name|openf
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ISOPEN
operator|)
operator|==
literal|0
condition|)
block|{
name|tp
operator|->
name|t_state
operator||=
name|TS_WOPEN
expr_stmt|;
name|ttychars
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_iflag
operator|=
name|TTYDEF_IFLAG
expr_stmt|;
name|tp
operator|->
name|t_oflag
operator|=
name|TTYDEF_OFLAG
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|TTYDEF_CFLAG
expr_stmt|;
name|tp
operator|->
name|t_lflag
operator|=
name|TTYDEF_LFLAG
expr_stmt|;
name|tp
operator|->
name|t_ispeed
operator|=
name|tp
operator|->
name|t_ospeed
operator|=
name|TTYDEF_SPEED
expr_stmt|;
name|pcparam
argument_list|(
name|tp
argument_list|,
operator|&
name|tp
operator|->
name|t_termios
argument_list|)
expr_stmt|;
name|ttsetwater
argument_list|(
name|tp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_XCLUDE
operator|&&
name|p
operator|->
name|p_ucred
operator|->
name|cr_uid
operator|!=
literal|0
condition|)
return|return
operator|(
name|EBUSY
operator|)
return|;
name|tp
operator|->
name|t_state
operator||=
name|TS_CARR_ON
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_open
operator|)
operator|(
name|dev
operator|,
name|tp
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|pcclose
argument_list|(
argument|dev
argument_list|,
argument|flag
argument_list|,
argument|mode
argument_list|,
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag
decl_stmt|,
name|mode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|proc
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_close
operator|)
operator|(
operator|&
name|pccons
operator|,
name|flag
operator|)
expr_stmt|;
name|ttyclose
argument_list|(
operator|&
name|pccons
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|pcread
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_read
operator|)
operator|(
operator|&
name|pccons
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|pcwrite
argument_list|(
argument|dev
argument_list|,
argument|uio
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|uio
modifier|*
name|uio
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_write
operator|)
operator|(
operator|&
name|pccons
operator|,
name|uio
operator|,
name|flag
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Got a console receive interrupt -  * the console processor wants to give us a character.  * Catch the character, and see who it goes to.  */
end_comment

begin_macro
name|pcrint
argument_list|(
argument|dev
argument_list|,
argument|irq
argument_list|,
argument|cpl
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|sgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0x100
condition|)
return|return;
if|if
condition|(
name|pcconsoftc
operator|.
name|cs_flags
operator|&
name|CSF_POLLING
condition|)
return|return;
ifdef|#
directive|ifdef
name|KDB
if|if
condition|(
name|kdbrintr
argument_list|(
name|c
argument_list|,
operator|&
name|pccons
argument_list|)
condition|)
return|return;
endif|#
directive|endif
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_rint
operator|)
operator|(
name|c
operator|&
literal|0xff
operator|,
operator|&
name|pccons
operator|)
expr_stmt|;
block|}
end_block

begin_macro
name|pcioctl
argument_list|(
argument|dev
argument_list|,
argument|cmd
argument_list|,
argument|data
argument_list|,
argument|flag
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|data
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
init|=
operator|&
name|pccons
decl_stmt|;
specifier|register
name|error
expr_stmt|;
name|error
operator|=
operator|(
operator|*
name|linesw
index|[
name|tp
operator|->
name|t_line
index|]
operator|.
name|l_ioctl
operator|)
operator|(
name|tp
operator|,
name|cmd
operator|,
name|data
operator|,
name|flag
operator|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
name|error
operator|=
name|ttioctl
argument_list|(
name|tp
argument_list|,
name|cmd
argument_list|,
name|data
argument_list|,
name|flag
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|>=
literal|0
condition|)
return|return
operator|(
name|error
operator|)
return|;
return|return
operator|(
name|ENOTTY
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|int
name|pcconsintr
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Got a console transmission interrupt -  * the console processor wants another character.  */
end_comment

begin_macro
name|pcxint
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|unit
decl_stmt|;
if|if
condition|(
operator|!
name|pcconsintr
condition|)
return|return;
name|pccons
operator|.
name|t_state
operator|&=
operator|~
name|TS_BUSY
expr_stmt|;
name|pcconsoftc
operator|.
name|cs_timo
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|pccons
operator|.
name|t_line
condition|)
operator|(
operator|*
name|linesw
index|[
name|pccons
operator|.
name|t_line
index|]
operator|.
name|l_start
operator|)
operator|(
operator|&
name|pccons
operator|)
expr_stmt|;
else|else
name|pcstart
argument_list|(
operator|&
name|pccons
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pcstart
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|c
operator|,
name|s
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
operator|(
name|TS_TIMEOUT
operator||
name|TS_BUSY
operator||
name|TS_TTSTOP
operator|)
condition|)
goto|goto
name|out
goto|;
do|do
block|{
if|if
condition|(
name|RB_LEN
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
operator|<=
name|tp
operator|->
name|t_lowat
condition|)
block|{
if|if
condition|(
name|tp
operator|->
name|t_state
operator|&
name|TS_ASLEEP
condition|)
block|{
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_ASLEEP
expr_stmt|;
name|wakeup
argument_list|(
operator|(
name|caddr_t
operator|)
operator|&
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tp
operator|->
name|t_wsel
condition|)
block|{
name|selwakeup
argument_list|(
name|tp
operator|->
name|t_wsel
argument_list|,
name|tp
operator|->
name|t_state
operator|&
name|TS_WCOLL
argument_list|)
expr_stmt|;
name|tp
operator|->
name|t_wsel
operator|=
literal|0
expr_stmt|;
name|tp
operator|->
name|t_state
operator|&=
operator|~
name|TS_WCOLL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|RB_LEN
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
operator|==
literal|0
condition|)
goto|goto
name|out
goto|;
name|c
operator|=
name|getc
argument_list|(
operator|&
name|tp
operator|->
name|t_out
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|sput
argument_list|(
name|c
argument_list|,
literal|0x7
argument_list|)
expr_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
literal|1
condition|)
do|;
name|out
label|:
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pccnprobe
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|consdev
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|maj
decl_stmt|;
comment|/* locate the major number */
for|for
control|(
name|maj
operator|=
literal|0
init|;
name|maj
operator|<
name|nchrdev
condition|;
name|maj
operator|++
control|)
if|if
condition|(
name|cdevsw
index|[
name|maj
index|]
operator|.
name|d_open
operator|==
name|pcopen
condition|)
break|break;
comment|/* initialize required fields */
name|cp
operator|->
name|cn_dev
operator|=
name|makedev
argument_list|(
name|maj
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|->
name|cn_tp
operator|=
operator|&
name|pccons
expr_stmt|;
name|cp
operator|->
name|cn_pri
operator|=
name|CN_INTERNAL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|pccninit
argument_list|(
argument|cp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|consdev
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* 	 * For now, don't screw with it. 	 */
comment|/* crtat = 0; */
block|}
end_block

begin_expr_stmt
specifier|static
name|__color
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|pccnputc
argument_list|(
argument|dev
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|clr
init|=
name|__color
decl_stmt|;
if|if
condition|(
name|clr
operator|==
literal|0
condition|)
name|clr
operator|=
literal|0x30
expr_stmt|;
else|else
name|clr
operator||=
literal|0x60
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|sput
argument_list|(
literal|'\r'
argument_list|,
name|clr
argument_list|)
expr_stmt|;
name|sput
argument_list|(
name|c
argument_list|,
name|clr
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print a character on console.  */
end_comment

begin_macro
name|pcputchar
argument_list|(
argument|c
argument_list|,
argument|tp
argument_list|)
end_macro

begin_decl_stmt
name|char
name|c
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|struct
name|tty
modifier|*
name|tp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|sput
argument_list|(
name|c
argument_list|,
literal|0x2
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|getchar
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/* ARGSUSED */
end_comment

begin_macro
name|pccngetc
argument_list|(
argument|dev
argument_list|)
end_macro

begin_decl_stmt
name|dev_t
name|dev
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|s
decl_stmt|;
name|s
operator|=
name|spltty
argument_list|()
expr_stmt|;
comment|/* block pcrint while we poll */
name|c
operator|=
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
name|c
operator|=
literal|'\n'
expr_stmt|;
name|splx
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|pcgetchar
argument_list|(
name|tp
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|&
literal|0xff
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * Set line parameters  */
end_comment

begin_expr_stmt
name|pcparam
argument_list|(
name|tp
argument_list|,
name|t
argument_list|)
specifier|register
expr|struct
name|tty
operator|*
name|tp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|struct
name|termios
modifier|*
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|cflag
init|=
name|t
operator|->
name|c_cflag
decl_stmt|;
comment|/* and copy to tty */
name|tp
operator|->
name|t_ispeed
operator|=
name|t
operator|->
name|c_ispeed
expr_stmt|;
name|tp
operator|->
name|t_ospeed
operator|=
name|t
operator|->
name|c_ospeed
expr_stmt|;
name|tp
operator|->
name|t_cflag
operator|=
name|cflag
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|KDB
end_ifdef

begin_comment
comment|/*  * Turn input polling on/off (used by debugger).  */
end_comment

begin_macro
name|pcpoll
argument_list|(
argument|onoff
argument_list|)
end_macro

begin_decl_stmt
name|int
name|onoff
decl_stmt|;
end_decl_stmt

begin_block
block|{ }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|extern
name|int
name|hz
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|beeping
expr_stmt|;
end_expr_stmt

begin_macro
name|sysbeepstop
argument_list|()
end_macro

begin_block
block|{
comment|/* disable counter 2 */
name|outb
argument_list|(
literal|0x61
argument_list|,
name|inb
argument_list|(
literal|0x61
argument_list|)
operator|&
literal|0xFC
argument_list|)
expr_stmt|;
name|beeping
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|sysbeep
argument_list|()
end_macro

begin_block
block|{
comment|/* enable counter 2 */
name|outb
argument_list|(
literal|0x61
argument_list|,
name|inb
argument_list|(
literal|0x61
argument_list|)
operator||
literal|3
argument_list|)
expr_stmt|;
comment|/* set command for counter 2, 2 byte write */
name|outb
argument_list|(
literal|0x43
argument_list|,
literal|0xB6
argument_list|)
expr_stmt|;
comment|/* send 0x637 for 750 HZ */
name|outb
argument_list|(
literal|0x42
argument_list|,
literal|0x37
argument_list|)
expr_stmt|;
name|outb
argument_list|(
literal|0x42
argument_list|,
literal|0x06
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|beeping
condition|)
name|timeout
argument_list|(
name|sysbeepstop
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|4
argument_list|)
expr_stmt|;
name|beeping
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* cursor() sets an offset (0-1999) into the 80x25 text area    */
end_comment

begin_decl_stmt
specifier|static
name|u_short
modifier|*
name|crtat
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|bg_at
init|=
literal|0x0f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|so_at
init|=
literal|0x70
decl_stmt|;
end_decl_stmt

begin_macro
name|cursor
argument_list|()
end_macro

begin_block
block|{
name|int
name|pos
init|=
name|crtat
operator|-
name|Crtat
decl_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|pos
operator|>>
literal|8
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|,
name|pos
operator|&
literal|0xff
argument_list|)
expr_stmt|;
name|timeout
argument_list|(
name|cursor
argument_list|,
literal|0
argument_list|,
name|hz
operator|/
literal|10
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|u_char
name|shfts
decl_stmt|,
name|ctls
decl_stmt|,
name|alts
decl_stmt|,
name|caps
decl_stmt|,
name|num
decl_stmt|,
name|stp
decl_stmt|,
name|scroll
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Compensate for abysmally stupid frame buffer aribitration with macro  */
end_comment

begin_define
define|#
directive|define
name|wrtchar
parameter_list|(
name|c
parameter_list|)
value|{ do *crtat = (c); while ((c) != *crtat); crtat++; row++; }
end_define

begin_comment
comment|/* sput has support for emulation of the 'ibmpc' termcap entry. */
end_comment

begin_comment
comment|/* This is a bare-bones implementation of a bare-bones entry    */
end_comment

begin_comment
comment|/* One modification: Change li#24 to li#25 to reflect 25 lines  */
end_comment

begin_macro
name|sput
argument_list|(
argument|c
argument_list|,
argument|ca
argument_list|)
end_macro

begin_decl_stmt
name|u_char
name|c
decl_stmt|,
name|ca
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|esc
decl_stmt|,
name|ebrac
decl_stmt|,
name|eparm
decl_stmt|,
name|cx
decl_stmt|,
name|cy
decl_stmt|,
name|row
decl_stmt|,
name|so
decl_stmt|;
if|if
condition|(
name|crtat
operator|==
literal|0
condition|)
block|{
name|u_short
modifier|*
name|cp
init|=
name|Crtat
operator|+
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
decl_stmt|,
name|was
decl_stmt|;
name|unsigned
name|cursorat
decl_stmt|;
comment|/* Crtat initialized to point to MONO buffer   */
comment|/* if not present change to CGA_BUF offset     */
comment|/* ONLY ADD the difference since locore.s adds */
comment|/* in the remapped offset at the right time    */
name|was
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
operator|(
name|u_short
operator|)
literal|0xA55A
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|0xA55A
condition|)
block|{
name|addr_6845
operator|=
name|MONO_BASE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cp
operator|=
name|was
expr_stmt|;
name|addr_6845
operator|=
name|CGA_BASE
expr_stmt|;
name|Crtat
operator|=
name|Crtat
operator|+
operator|(
name|CGA_BUF
operator|-
name|MONO_BUF
operator|)
operator|/
name|CHR
expr_stmt|;
block|}
comment|/* Extract cursor location */
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|14
argument_list|)
expr_stmt|;
name|cursorat
operator|=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
operator|<<
literal|8
expr_stmt|;
name|outb
argument_list|(
name|addr_6845
argument_list|,
literal|15
argument_list|)
expr_stmt|;
name|cursorat
operator||=
name|inb
argument_list|(
name|addr_6845
operator|+
literal|1
argument_list|)
expr_stmt|;
name|crtat
operator|=
name|Crtat
operator|+
name|cursorat
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|bg_at
operator|<<
literal|8
operator|)
operator||
literal|' '
argument_list|,
name|crtat
argument_list|,
name|COL
operator|*
name|ROW
operator|-
name|cursorat
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0x1B
case|:
name|esc
operator|=
literal|1
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\t'
case|:
do|do
block|{
name|wrtchar
argument_list|(
operator|(
name|ca
operator|<<
literal|8
operator|)
operator||
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|row
operator|%
literal|8
condition|)
do|;
break|break;
case|case
literal|'\010'
case|:
name|crtat
operator|--
expr_stmt|;
name|row
operator|--
expr_stmt|;
if|if
condition|(
name|row
operator|<
literal|0
condition|)
name|row
operator|+=
name|COL
expr_stmt|;
comment|/* non-destructive backspace */
break|break;
case|case
literal|'\r'
case|:
name|crtat
operator|-=
name|row
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
name|crtat
operator|+=
name|COL
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|esc
condition|)
block|{
if|if
condition|(
name|ebrac
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'m'
case|:
comment|/* no support for standout */
if|if
condition|(
operator|!
name|cx
condition|)
name|so
operator|=
literal|0
expr_stmt|;
else|else
name|so
operator|=
literal|1
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
comment|/* back one row */
name|crtat
operator|-=
name|COL
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* down one row */
name|crtat
operator|+=
name|COL
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* right cursor */
name|crtat
operator|++
expr_stmt|;
name|row
operator|++
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
comment|/* Clear to end of display */
name|fillw
argument_list|(
operator|(
name|bg_at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|crtat
argument_list|,
name|Crtat
operator|+
name|COL
operator|*
name|ROW
operator|-
name|crtat
argument_list|)
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* Clear to EOL */
name|fillw
argument_list|(
operator|(
name|bg_at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|crtat
argument_list|,
name|COL
operator|-
operator|(
name|crtat
operator|-
name|Crtat
operator|)
operator|%
name|COL
argument_list|)
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
comment|/* Cursor move */
if|if
condition|(
operator|(
operator|!
name|cx
operator|)
operator|||
operator|(
operator|!
name|cy
operator|)
condition|)
block|{
name|crtat
operator|=
name|Crtat
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|crtat
operator|=
name|Crtat
operator|+
operator|(
name|cx
operator|-
literal|1
operator|)
operator|*
name|COL
operator|+
name|cy
operator|-
literal|1
expr_stmt|;
name|row
operator|=
name|cy
operator|-
literal|1
expr_stmt|;
block|}
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|';'
case|:
comment|/* Switch params in cursor def */
name|eparm
operator|=
literal|1
expr_stmt|;
return|return;
default|default:
comment|/* Only numbers valid here */
if|if
condition|(
operator|(
name|c
operator|>=
literal|'0'
operator|)
operator|&&
operator|(
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
if|if
condition|(
name|eparm
condition|)
block|{
name|cy
operator|*=
literal|10
expr_stmt|;
name|cy
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
name|cx
operator|*=
literal|10
expr_stmt|;
name|cx
operator|+=
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
else|else
block|{
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
block|}
return|return;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'c'
condition|)
block|{
comment|/* Clear screen& home */
name|fillw
argument_list|(
operator|(
name|bg_at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|Crtat
argument_list|,
name|COL
operator|*
name|ROW
argument_list|)
expr_stmt|;
name|crtat
operator|=
name|Crtat
expr_stmt|;
name|row
operator|=
literal|0
expr_stmt|;
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'['
condition|)
block|{
comment|/* Start ESC [ sequence */
name|ebrac
operator|=
literal|1
expr_stmt|;
name|cx
operator|=
literal|0
expr_stmt|;
name|cy
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* Invalid, clear state */
name|esc
operator|=
literal|0
expr_stmt|;
name|ebrac
operator|=
literal|0
expr_stmt|;
name|eparm
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|7
condition|)
name|sysbeep
argument_list|()
expr_stmt|;
comment|/* Print only printables */
else|else
comment|/*if (c>= ' ') */
block|{
if|if
condition|(
name|so
condition|)
block|{
name|wrtchar
argument_list|(
operator|(
name|so_at
operator|<<
literal|8
operator|)
operator||
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|wrtchar
argument_list|(
operator|(
name|ca
operator|<<
literal|8
operator|)
operator||
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|row
operator|>=
name|COL
condition|)
name|row
operator|=
literal|0
expr_stmt|;
break|break ;
block|}
block|}
block|}
if|if
condition|(
name|crtat
operator|>=
name|Crtat
operator|+
name|COL
operator|*
operator|(
name|ROW
operator|)
condition|)
block|{
comment|/* scroll check */
if|if
condition|(
name|openf
condition|)
do|do
name|sgetc
argument_list|(
literal|1
argument_list|)
expr_stmt|;
do|while
condition|(
name|scroll
condition|)
do|;
name|bcopy
argument_list|(
name|Crtat
operator|+
name|COL
argument_list|,
name|Crtat
argument_list|,
name|COL
operator|*
operator|(
name|ROW
operator|-
literal|1
operator|)
operator|*
name|CHR
argument_list|)
expr_stmt|;
name|fillw
argument_list|(
operator|(
name|bg_at
operator|<<
literal|8
operator|)
operator|+
literal|' '
argument_list|,
name|Crtat
operator|+
name|COL
operator|*
operator|(
name|ROW
operator|-
literal|1
operator|)
argument_list|,
name|COL
argument_list|)
expr_stmt|;
name|crtat
operator|-=
name|COL
expr_stmt|;
block|}
block|}
end_block

begin_define
define|#
directive|define
name|L
value|0x0001
end_define

begin_comment
comment|/* locking function */
end_comment

begin_define
define|#
directive|define
name|SHF
value|0x0002
end_define

begin_comment
comment|/* keyboard shift */
end_comment

begin_define
define|#
directive|define
name|ALT
value|0x0004
end_define

begin_comment
comment|/* alternate shift -- alternate chars */
end_comment

begin_define
define|#
directive|define
name|NUM
value|0x0008
end_define

begin_comment
comment|/* numeric shift  cursors vs. numeric */
end_comment

begin_define
define|#
directive|define
name|CTL
value|0x0010
end_define

begin_comment
comment|/* control shift  -- allows ctl function */
end_comment

begin_define
define|#
directive|define
name|CPS
value|0x0020
end_define

begin_comment
comment|/* caps shift -- swaps case of letter */
end_comment

begin_define
define|#
directive|define
name|ASCII
value|0x0040
end_define

begin_comment
comment|/* ascii code for this key */
end_comment

begin_define
define|#
directive|define
name|STP
value|0x0080
end_define

begin_comment
comment|/* stop output */
end_comment

begin_define
define|#
directive|define
name|FUNC
value|0x0100
end_define

begin_comment
comment|/* function key */
end_comment

begin_define
define|#
directive|define
name|SCROLL
value|0x0200
end_define

begin_comment
comment|/* scroll lock key */
end_comment

begin_decl_stmt
name|unsigned
name|__debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*0xffe */
end_comment

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_decl_stmt
name|u_short
name|action
index|[]
init|=
block|{
literal|0
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
comment|/* scan  0- 7 */
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
comment|/* scan  8-15 */
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
comment|/* scan 16-23 */
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|CTL
block|,
name|ASCII
block|,
name|ASCII
block|,
comment|/* scan 24-31 */
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
comment|/* scan 32-39 */
name|ASCII
block|,
name|ASCII
block|,
name|SHF
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
comment|/* scan 40-47 */
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|SHF
block|,
name|ASCII
block|,
comment|/* scan 48-55 */
name|ALT
block|,
name|ASCII
block|,
name|CPS
block|,
name|FUNC
block|,
name|FUNC
block|,
name|FUNC
block|,
name|FUNC
block|,
name|FUNC
block|,
comment|/* scan 56-63 */
name|FUNC
block|,
name|FUNC
block|,
name|FUNC
block|,
name|FUNC
block|,
name|FUNC
block|,
name|NUM
block|,
name|SCROLL
block|,
name|ASCII
block|,
comment|/* scan 64-71 */
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
comment|/* scan 72-79 */
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
name|ASCII
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 80-87 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|unshift
index|[]
init|=
block|{
comment|/* no shift */
literal|0
block|,
literal|033
block|,
literal|'1'
block|,
literal|'2'
block|,
literal|'3'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
comment|/* scan  0- 7 */
literal|'7'
block|,
literal|'8'
block|,
literal|'9'
block|,
literal|'0'
block|,
literal|'-'
block|,
literal|'='
block|,
literal|0177
block|,
literal|'\t'
block|,
comment|/* scan  8-15 */
literal|'q'
block|,
literal|'w'
block|,
literal|'e'
block|,
literal|'r'
block|,
literal|'t'
block|,
literal|'y'
block|,
literal|'u'
block|,
literal|'i'
block|,
comment|/* scan 16-23 */
literal|'o'
block|,
literal|'p'
block|,
literal|'['
block|,
literal|']'
block|,
literal|'\r'
block|,
name|CTL
block|,
literal|'a'
block|,
literal|'s'
block|,
comment|/* scan 24-31 */
literal|'d'
block|,
literal|'f'
block|,
literal|'g'
block|,
literal|'h'
block|,
literal|'j'
block|,
literal|'k'
block|,
literal|'l'
block|,
literal|';'
block|,
comment|/* scan 32-39 */
literal|'\''
block|,
literal|'`'
block|,
name|SHF
block|,
literal|'\\'
block|,
literal|'z'
block|,
literal|'x'
block|,
literal|'c'
block|,
literal|'v'
block|,
comment|/* scan 40-47 */
literal|'b'
block|,
literal|'n'
block|,
literal|'m'
block|,
literal|','
block|,
literal|'.'
block|,
literal|'/'
block|,
name|SHF
block|,
literal|'*'
block|,
comment|/* scan 48-55 */
name|ALT
block|,
literal|' '
block|,
name|CPS
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
comment|/* scan 56-63 */
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
name|NUM
block|,
name|STP
block|,
literal|'7'
block|,
comment|/* scan 64-71 */
literal|'8'
block|,
literal|'9'
block|,
literal|'-'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'+'
block|,
literal|'1'
block|,
comment|/* scan 72-79 */
literal|'2'
block|,
literal|'3'
block|,
literal|'0'
block|,
literal|'.'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 80-87 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|shift
index|[]
init|=
block|{
comment|/* shift shift */
literal|0
block|,
literal|033
block|,
literal|'!'
block|,
literal|'@'
block|,
literal|'#'
block|,
literal|'$'
block|,
literal|'%'
block|,
literal|'^'
block|,
comment|/* scan  0- 7 */
literal|'&'
block|,
literal|'*'
block|,
literal|'('
block|,
literal|')'
block|,
literal|'_'
block|,
literal|'+'
block|,
literal|0177
block|,
literal|'\t'
block|,
comment|/* scan  8-15 */
literal|'Q'
block|,
literal|'W'
block|,
literal|'E'
block|,
literal|'R'
block|,
literal|'T'
block|,
literal|'Y'
block|,
literal|'U'
block|,
literal|'I'
block|,
comment|/* scan 16-23 */
literal|'O'
block|,
literal|'P'
block|,
literal|'{'
block|,
literal|'}'
block|,
literal|'\r'
block|,
name|CTL
block|,
literal|'A'
block|,
literal|'S'
block|,
comment|/* scan 24-31 */
literal|'D'
block|,
literal|'F'
block|,
literal|'G'
block|,
literal|'H'
block|,
literal|'J'
block|,
literal|'K'
block|,
literal|'L'
block|,
literal|':'
block|,
comment|/* scan 32-39 */
literal|'"'
block|,
literal|'~'
block|,
name|SHF
block|,
literal|'|'
block|,
literal|'Z'
block|,
literal|'X'
block|,
literal|'C'
block|,
literal|'V'
block|,
comment|/* scan 40-47 */
literal|'B'
block|,
literal|'N'
block|,
literal|'M'
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'?'
block|,
name|SHF
block|,
literal|'*'
block|,
comment|/* scan 48-55 */
name|ALT
block|,
literal|' '
block|,
name|CPS
block|,
literal|0
block|,
literal|0
block|,
literal|' '
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 56-63 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
name|NUM
block|,
name|STP
block|,
literal|'7'
block|,
comment|/* scan 64-71 */
literal|'8'
block|,
literal|'9'
block|,
literal|'-'
block|,
literal|'4'
block|,
literal|'5'
block|,
literal|'6'
block|,
literal|'+'
block|,
literal|'1'
block|,
comment|/* scan 72-79 */
literal|'2'
block|,
literal|'3'
block|,
literal|'0'
block|,
literal|'.'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 80-87 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
name|ctl
index|[]
init|=
block|{
comment|/* CTL shift */
literal|0
block|,
literal|033
block|,
literal|'!'
block|,
literal|000
block|,
literal|'#'
block|,
literal|'$'
block|,
literal|'%'
block|,
literal|036
block|,
comment|/* scan  0- 7 */
literal|'&'
block|,
literal|'*'
block|,
literal|'('
block|,
literal|')'
block|,
literal|037
block|,
literal|'+'
block|,
literal|034
block|,
literal|'\177'
block|,
comment|/* scan  8-15 */
literal|021
block|,
literal|027
block|,
literal|005
block|,
literal|022
block|,
literal|024
block|,
literal|031
block|,
literal|025
block|,
literal|011
block|,
comment|/* scan 16-23 */
literal|017
block|,
literal|020
block|,
literal|033
block|,
literal|035
block|,
literal|'\r'
block|,
name|CTL
block|,
literal|001
block|,
literal|023
block|,
comment|/* scan 24-31 */
literal|004
block|,
literal|006
block|,
literal|007
block|,
literal|010
block|,
literal|012
block|,
literal|013
block|,
literal|014
block|,
literal|';'
block|,
comment|/* scan 32-39 */
literal|'\''
block|,
literal|'`'
block|,
name|SHF
block|,
literal|034
block|,
literal|032
block|,
literal|030
block|,
literal|003
block|,
literal|026
block|,
comment|/* scan 40-47 */
literal|002
block|,
literal|016
block|,
literal|015
block|,
literal|'<'
block|,
literal|'>'
block|,
literal|'?'
block|,
name|SHF
block|,
literal|'*'
block|,
comment|/* scan 48-55 */
name|ALT
block|,
literal|' '
block|,
name|CPS
block|,
literal|0
block|,
literal|0
block|,
literal|' '
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 56-63 */
name|CPS
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 64-71 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 72-79 */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/* scan 80-87 */
literal|0
block|,
literal|0
block|,
literal|033
block|,
literal|'7'
block|,
literal|'4'
block|,
literal|'1'
block|,
literal|0
block|,
name|NUM
block|,
comment|/* scan 88-95 */
literal|'8'
block|,
literal|'5'
block|,
literal|'2'
block|,
literal|0
block|,
name|STP
block|,
literal|'9'
block|,
literal|'6'
block|,
literal|'3'
block|,
comment|/*scan  96-103*/
literal|'.'
block|,
literal|0
block|,
literal|'*'
block|,
literal|'-'
block|,
literal|'+'
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
comment|/*scan 104-111*/
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,	}
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_struct
struct|struct
name|key
block|{
name|u_short
name|action
decl_stmt|;
comment|/* how this key functions */
name|char
name|ascii
index|[
literal|8
index|]
decl_stmt|;
comment|/* ascii result character indexed by shifts */
block|}
struct|;
end_struct

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|KBSTAT
value|0x64
end_define

begin_comment
comment|/* kbd status port */
end_comment

begin_define
define|#
directive|define
name|KBS_INP_BUF_FUL
value|0x02
end_define

begin_comment
comment|/* kbd char ready */
end_comment

begin_define
define|#
directive|define
name|KBDATA
value|0x60
end_define

begin_comment
comment|/* kbd data port */
end_comment

begin_define
define|#
directive|define
name|KBSTATUSPORT
value|0x61
end_define

begin_comment
comment|/* kbd status */
end_comment

begin_macro
name|update_led
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
comment|/* wait input ready */
name|outb
argument_list|(
literal|0x60
argument_list|,
literal|0xED
argument_list|)
expr_stmt|;
comment|/* LED Command */
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
comment|/* wait input ready */
name|outb
argument_list|(
literal|0x60
argument_list|,
name|scroll
operator||
literal|2
operator|*
name|num
operator||
literal|4
operator|*
name|caps
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|reset_cpu
argument_list|()
end_macro

begin_block
block|{
while|while
condition|(
literal|1
condition|)
block|{
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
comment|/* wait input ready */
name|outb
argument_list|(
literal|0x64
argument_list|,
literal|0xFE
argument_list|)
expr_stmt|;
comment|/* Reset Command */
name|DELAY
argument_list|(
literal|4000000
argument_list|)
expr_stmt|;
while|while
condition|(
name|inb
argument_list|(
literal|0x64
argument_list|)
operator|&
literal|2
condition|)
empty_stmt|;
comment|/* wait input ready */
name|outb
argument_list|(
literal|0x64
argument_list|,
literal|0xFF
argument_list|)
expr_stmt|;
comment|/* Keyboard Reset Command */
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/* sgetc(noblock) : get a character from the keyboard. If noblock = 0 wait until a key is gotten.  Otherwise return a 0x100 (256). */
end_comment

begin_function
name|int
name|sgetc
parameter_list|(
name|noblock
parameter_list|)
block|{
name|u_char
name|dt
decl_stmt|;
name|unsigned
name|key
decl_stmt|;
name|loop
label|:
comment|/* First see if there is something in the keyboard port */
if|if
condition|(
name|inb
argument_list|(
name|KBSTAT
argument_list|)
operator|&
literal|1
condition|)
name|dt
operator|=
name|inb
argument_list|(
name|KBDATA
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|noblock
condition|)
return|return
operator|(
literal|0x100
operator|)
return|;
else|else
goto|goto
name|loop
goto|;
block|}
comment|/* Check for cntl-alt-del */
if|if
condition|(
operator|(
name|dt
operator|==
literal|83
operator|)
operator|&&
name|ctls
operator|&&
name|alts
condition|)
name|_exit
argument_list|()
expr_stmt|;
comment|/* Check for make/break */
if|if
condition|(
name|dt
operator|&
literal|0x80
condition|)
block|{
comment|/* break */
name|dt
operator|=
name|dt
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|action
index|[
name|dt
index|]
condition|)
block|{
case|case
name|SHF
case|:
name|shfts
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|ALT
case|:
name|alts
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CTL
case|:
name|ctls
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|FUNC
case|:
comment|/* Toggle debug flags */
name|key
operator|=
name|unshift
index|[
name|dt
index|]
expr_stmt|;
if|if
condition|(
name|__debug
operator|&
operator|(
literal|1
operator|<<
name|key
operator|)
condition|)
name|__debug
operator|&=
operator|~
operator|(
literal|1
operator|<<
name|key
operator|)
expr_stmt|;
else|else
name|__debug
operator||=
operator|(
literal|1
operator|<<
name|key
operator|)
expr_stmt|;
break|break;
block|}
block|}
else|else
block|{
comment|/* make */
name|dt
operator|=
name|dt
operator|&
literal|0x7f
expr_stmt|;
switch|switch
condition|(
name|action
index|[
name|dt
index|]
condition|)
block|{
comment|/* LOCKING KEYS */
case|case
name|NUM
case|:
name|num
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
name|CPS
case|:
name|caps
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
name|SCROLL
case|:
name|scroll
operator|^=
literal|1
expr_stmt|;
name|update_led
argument_list|()
expr_stmt|;
break|break;
case|case
name|STP
case|:
name|stp
operator|^=
literal|1
expr_stmt|;
if|if
condition|(
name|stp
condition|)
goto|goto
name|loop
goto|;
break|break;
comment|/* NON-LOCKING KEYS */
case|case
name|SHF
case|:
name|shfts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ALT
case|:
name|alts
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|CTL
case|:
name|ctls
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|ASCII
case|:
if|if
condition|(
name|shfts
condition|)
name|dt
operator|=
name|shift
index|[
name|dt
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|ctls
condition|)
name|dt
operator|=
name|ctl
index|[
name|dt
index|]
expr_stmt|;
else|else
name|dt
operator|=
name|unshift
index|[
name|dt
index|]
expr_stmt|;
if|if
condition|(
name|caps
operator|&&
operator|(
name|dt
operator|>=
literal|'a'
operator|&&
name|dt
operator|<=
literal|'z'
operator|)
condition|)
name|dt
operator|-=
literal|'a'
operator|-
literal|'A'
expr_stmt|;
return|return
operator|(
name|dt
operator|)
return|;
block|}
block|}
if|if
condition|(
name|noblock
condition|)
return|return
operator|(
literal|0x100
operator|)
return|;
else|else
goto|goto
name|loop
goto|;
block|}
end_function

begin_macro
name|pg
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|,
argument|r
argument_list|,
argument|s
argument_list|,
argument|t
argument_list|,
argument|u
argument_list|,
argument|v
argument_list|,
argument|w
argument_list|,
argument|x
argument_list|,
argument|y
argument_list|,
argument|z
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|r
argument_list|,
name|s
argument_list|,
name|t
argument_list|,
name|u
argument_list|,
name|v
argument_list|,
name|w
argument_list|,
name|x
argument_list|,
name|y
argument_list|,
name|z
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|getchar
argument_list|()
operator|)
return|;
block|}
end_block

begin_comment
comment|/* special characters */
end_comment

begin_define
define|#
directive|define
name|bs
value|8
end_define

begin_define
define|#
directive|define
name|lf
value|10
end_define

begin_define
define|#
directive|define
name|cr
value|13
end_define

begin_define
define|#
directive|define
name|cntlc
value|3
end_define

begin_define
define|#
directive|define
name|del
value|0177
end_define

begin_define
define|#
directive|define
name|cntld
value|4
end_define

begin_macro
name|getchar
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
name|thechar
decl_stmt|;
specifier|register
name|delay
expr_stmt|;
name|int
name|x
decl_stmt|;
name|pcconsoftc
operator|.
name|cs_flags
operator||=
name|CSF_POLLING
expr_stmt|;
name|x
operator|=
name|splhigh
argument_list|()
expr_stmt|;
name|sput
argument_list|(
literal|'>'
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
comment|/*while (1) {*/
name|thechar
operator|=
operator|(
name|char
operator|)
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|pcconsoftc
operator|.
name|cs_flags
operator|&=
operator|~
name|CSF_POLLING
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|thechar
condition|)
block|{
default|default:
if|if
condition|(
name|thechar
operator|>=
literal|' '
condition|)
name|sput
argument_list|(
name|thechar
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
return|return
operator|(
name|thechar
operator|)
return|;
case|case
name|cr
case|:
case|case
name|lf
case|:
name|sput
argument_list|(
name|cr
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sput
argument_list|(
name|lf
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
return|return
operator|(
name|lf
operator|)
return|;
case|case
name|bs
case|:
case|case
name|del
case|:
name|sput
argument_list|(
name|bs
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|' '
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sput
argument_list|(
name|bs
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
return|return
operator|(
name|thechar
operator|)
return|;
comment|/*case cntlc: 			     sput('^',0xe) ; sput('C',0xe) ; sput('\r',0xe) ; sput('\n',0xe) ; 			     _exit(-2) ; */
case|case
name|cntld
case|:
name|sput
argument_list|(
literal|'^'
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'D'
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\r'
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
name|sput
argument_list|(
literal|'\n'
argument_list|,
literal|0x6
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/*}*/
block|}
end_block

begin_include
include|#
directive|include
file|"machine/stdarg.h"
end_include

begin_expr_stmt
specifier|static
name|nrow
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|DPAUSE
value|1
end_define

begin_function
name|void
ifdef|#
directive|ifdef
name|__STDC__
name|dprintf
parameter_list|(
name|unsigned
name|flgs
parameter_list|,
specifier|const
name|char
modifier|*
name|fmt
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
function|dprintf
parameter_list|(
name|flgs
parameter_list|,
name|fmt
comment|/*, va_alist */
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|unsigned
name|flgs
decl_stmt|;
endif|#
directive|endif
block|{
specifier|extern
name|unsigned
name|__debug
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
operator|(
name|flgs
operator|&
name|__debug
operator|)
operator|>
name|DPAUSE
condition|)
block|{
name|__color
operator|=
name|ffs
argument_list|(
name|flgs
operator|&
name|__debug
argument_list|)
operator|+
literal|1
expr_stmt|;
name|va_start
argument_list|(
name|ap
argument_list|,
name|fmt
argument_list|)
expr_stmt|;
name|kprintf
argument_list|(
name|fmt
argument_list|,
literal|1
argument_list|,
operator|(
expr|struct
name|tty
operator|*
operator|)
literal|0
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|flgs
operator|&
name|DPAUSE
operator|||
name|nrow
operator|%
literal|24
operator|==
literal|23
condition|)
block|{
name|int
name|x
decl_stmt|;
name|x
operator|=
name|splhigh
argument_list|()
expr_stmt|;
if|if
condition|(
name|nrow
operator|%
literal|24
operator|==
literal|23
condition|)
name|nrow
operator|=
literal|0
expr_stmt|;
name|sgetc
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|splx
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
block|}
name|__color
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_macro
name|consinit
argument_list|()
end_macro

begin_block
block|{}
end_block

end_unit

