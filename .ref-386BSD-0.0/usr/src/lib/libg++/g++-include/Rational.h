begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// This may look like C code, but it is really -*- C++ -*-
end_comment

begin_comment
comment|/*  Copyright (C) 1988 Free Software Foundation     written by Doug Lea (dl@rocky.oswego.edu)  This file is part of GNU CC.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the GNU CC General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU CC, but only under the conditions described in the GNU CC General Public License.   A copy of this license is supposed to have been given to you along with GNU CC so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.   */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|_Rational_h
end_ifndef

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_pragma
pragma|#
directive|pragma
name|once
end_pragma

begin_pragma
pragma|#
directive|pragma
name|interface
end_pragma

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|_Rational_h
value|1
end_define

begin_include
include|#
directive|include
file|<Integer.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_decl_stmt
name|class
name|Rational
block|{
name|protected
label|:
name|Integer
name|num
decl_stmt|;
name|Integer
name|den
decl_stmt|;
name|void
name|normalize
parameter_list|()
function_decl|;
name|public
label|:
name|Rational
argument_list|()
expr_stmt|;
name|Rational
argument_list|(
name|double
argument_list|)
expr_stmt|;
name|Rational
argument_list|(
argument|long n
argument_list|,
argument|long d =
literal|1
argument_list|)
empty_stmt|;
name|Rational
argument_list|(
specifier|const
name|Integer
operator|&
name|n
argument_list|)
expr_stmt|;
name|Rational
argument_list|(
specifier|const
name|Integer
operator|&
name|n
argument_list|,
specifier|const
name|Integer
operator|&
name|d
argument_list|)
expr_stmt|;
name|Rational
argument_list|(
specifier|const
name|Rational
operator|&
argument_list|)
expr_stmt|;
operator|~
name|Rational
argument_list|()
expr_stmt|;
name|void
name|operator
init|=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
decl_stmt|;
name|friend
name|int
name|operator
operator|==
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|int
name|operator
operator|!=
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|int
name|operator
operator|<
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|int
name|operator
operator|<=
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|int
name|operator
operator|>
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|int
name|operator
operator|>=
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|Rational
name|operator
operator|+
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|Rational
name|operator
operator|-
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|Rational
name|operator
modifier|*
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
specifier|const
name|Rational
modifier|&
name|y
parameter_list|)
function_decl|;
name|friend
name|Rational
name|operator
operator|/
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|void
name|operator
operator|+=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|void
name|operator
operator|-=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|void
name|operator
operator|*=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|void
name|operator
operator|/=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|__GNUG__
name|friend
name|Rational
name|operator
operator|<
condition|?
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
comment|// min
name|friend
name|Rational
name|operator
operator|>
condition|?
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
comment|// max
endif|#
directive|endif
name|friend
name|Rational
name|operator
operator|-
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|)
expr_stmt|;
comment|// builtin Rational functions
name|void
name|negate
parameter_list|()
function_decl|;
comment|// x = -x
name|void
name|invert
parameter_list|()
function_decl|;
comment|// x = 1/x
name|friend
name|int
name|sign
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
function_decl|;
comment|// -1, 0, or +1
name|friend
name|Rational
name|abs
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
function_decl|;
comment|// absolute value
name|friend
name|Rational
name|sqr
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
function_decl|;
comment|// square
name|friend
name|Rational
name|pow
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
name|long
name|y
parameter_list|)
function_decl|;
name|friend
name|Rational
name|pow
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
name|Integer
modifier|&
name|y
parameter_list|)
function_decl|;
specifier|const
name|Integer
operator|&
name|numerator
argument_list|()
specifier|const
expr_stmt|;
specifier|const
name|Integer
operator|&
name|denominator
argument_list|()
specifier|const
expr_stmt|;
comment|// coercion& conversion
name|operator
name|double
argument_list|()
specifier|const
expr_stmt|;
name|friend
name|Integer
name|floor
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
function_decl|;
name|friend
name|Integer
name|ceil
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
function_decl|;
name|friend
name|Integer
name|trunc
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
function_decl|;
name|friend
name|Integer
name|round
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
function_decl|;
name|friend
name|istream
operator|&
name|operator
operator|>>
operator|(
name|istream
operator|&
name|s
operator|,
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
name|friend
name|ostream
operator|&
name|operator
operator|<<
operator|(
name|ostream
operator|&
name|s
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
expr_stmt|;
comment|// procedural versions of operators
name|friend
name|int
name|compare
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
specifier|const
name|Rational
modifier|&
name|y
parameter_list|)
function_decl|;
name|friend
name|void
name|add
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
specifier|const
name|Rational
modifier|&
name|y
parameter_list|,
name|Rational
modifier|&
name|dest
parameter_list|)
function_decl|;
name|friend
name|void
name|sub
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
specifier|const
name|Rational
modifier|&
name|y
parameter_list|,
name|Rational
modifier|&
name|dest
parameter_list|)
function_decl|;
name|friend
name|void
name|mul
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
specifier|const
name|Rational
modifier|&
name|y
parameter_list|,
name|Rational
modifier|&
name|dest
parameter_list|)
function_decl|;
name|friend
name|void
name|div
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
specifier|const
name|Rational
modifier|&
name|y
parameter_list|,
name|Rational
modifier|&
name|dest
parameter_list|)
function_decl|;
comment|// error detection
specifier|volatile
name|void
name|error
argument_list|(
specifier|const
name|char
operator|*
name|msg
argument_list|)
decl|const
decl_stmt|;
name|int
name|OK
argument_list|()
specifier|const
expr_stmt|;
block|}
end_decl_stmt

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_typedef
typedef|typedef
name|Rational
name|RatTmp
typedef|;
end_typedef

begin_comment
comment|// backwards compatibility
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__OPTIMIZE__
argument_list|)
operator|||
name|defined
argument_list|(
name|USE_LIBGXX_INLINES
argument_list|)
end_if

begin_expr_stmt
specifier|inline
name|Rational
operator|::
name|Rational
argument_list|()
block|{}
specifier|inline
name|Rational
operator|::
operator|~
name|Rational
argument_list|()
block|{}
specifier|inline
name|Rational
operator|::
name|Rational
argument_list|(
specifier|const
name|Rational
operator|&
name|y
argument_list|)
operator|:
name|num
argument_list|(
name|y
operator|.
name|num
argument_list|)
operator|,
name|den
argument_list|(
argument|y.den
argument_list|)
block|{}
specifier|inline
name|Rational
operator|::
name|Rational
argument_list|(
specifier|const
name|Integer
operator|&
name|n
argument_list|)
operator|:
name|num
argument_list|(
name|n
argument_list|)
operator|,
name|den
argument_list|(
literal|1
argument_list|)
block|{}
specifier|inline
name|Rational
operator|::
name|Rational
argument_list|(
specifier|const
name|Integer
operator|&
name|n
argument_list|,
specifier|const
name|Integer
operator|&
name|d
argument_list|)
operator|:
name|num
argument_list|(
name|n
argument_list|)
operator|,
name|den
argument_list|(
argument|d
argument_list|)
block|{
name|normalize
argument_list|()
block|; }
specifier|inline
name|Rational
operator|::
name|Rational
argument_list|(
argument|long n
argument_list|,
argument|long d
argument_list|)
operator|:
name|num
argument_list|(
name|n
argument_list|)
operator|,
name|den
argument_list|(
argument|d
argument_list|)
block|{
name|normalize
argument_list|()
block|; }
specifier|inline
name|void
name|Rational
operator|::
name|operator
operator|=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|num
operator|=
name|y
operator|.
name|num
block|;
name|den
operator|=
name|y
operator|.
name|den
block|; }
specifier|inline
name|int
name|operator
operator|==
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
return|return
name|compare
argument_list|(
name|x
operator|.
name|num
argument_list|,
name|y
operator|.
name|num
argument_list|)
operator|==
literal|0
operator|&&
name|compare
argument_list|(
name|x
operator|.
name|den
argument_list|,
name|y
operator|.
name|den
argument_list|)
operator|==
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|operator
operator|!=
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
return|return
name|compare
argument_list|(
name|x
operator|.
name|num
argument_list|,
name|y
operator|.
name|num
argument_list|)
operator|!=
literal|0
operator|||
name|compare
argument_list|(
name|x
operator|.
name|den
argument_list|,
name|y
operator|.
name|den
argument_list|)
operator|!=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|operator
operator|<
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
return|return
name|compare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|<
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|operator
operator|<=
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
return|return
name|compare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|<=
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|operator
operator|>
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
return|return
name|compare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|>
literal|0
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|int
name|operator
operator|>=
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
return|return
name|compare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|>=
literal|0
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|int
name|sign
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|)
block|{
return|return
name|sign
argument_list|(
name|x
operator|.
name|num
argument_list|)
return|;
block|}
end_function

begin_expr_stmt
specifier|inline
name|void
name|Rational
operator|::
name|negate
argument_list|()
block|{
name|num
operator|.
name|negate
argument_list|()
block|; }
specifier|inline
name|void
name|Rational
operator|::
name|operator
operator|+=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|add
argument_list|(
operator|*
name|this
argument_list|,
name|y
argument_list|,
operator|*
name|this
argument_list|)
block|; }
specifier|inline
name|void
name|Rational
operator|::
name|operator
operator|-=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|sub
argument_list|(
operator|*
name|this
argument_list|,
name|y
argument_list|,
operator|*
name|this
argument_list|)
block|; }
specifier|inline
name|void
name|Rational
operator|::
name|operator
operator|*=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|mul
argument_list|(
operator|*
name|this
argument_list|,
name|y
argument_list|,
operator|*
name|this
argument_list|)
block|; }
specifier|inline
name|void
name|Rational
operator|::
name|operator
operator|/=
operator|(
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|div
argument_list|(
operator|*
name|this
argument_list|,
name|y
argument_list|,
operator|*
name|this
argument_list|)
block|; }
specifier|inline
specifier|const
name|Integer
operator|&
name|Rational
operator|::
name|numerator
argument_list|()
specifier|const
block|{
return|return
name|num
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
specifier|const
name|Integer
operator|&
name|Rational
operator|::
name|denominator
argument_list|()
specifier|const
block|{
return|return
name|den
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|Rational
operator|::
name|operator
name|double
argument_list|()
specifier|const
block|{
return|return
name|ratio
argument_list|(
name|num
argument_list|,
name|den
argument_list|)
return|;
block|}
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUG__
end_ifdef

begin_expr_stmt
specifier|inline
name|Rational
name|operator
operator|<
condition|?
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
if|if
condition|(
name|compare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|<=
literal|0
condition|)
return|return
name|x
return|;
else|else
return|return
name|y
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|inline
name|Rational
name|operator
operator|>
condition|?
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
if|if
condition|(
name|compare
argument_list|(
name|x
argument_list|,
name|y
argument_list|)
operator|>=
literal|0
condition|)
return|return
name|x
return|;
else|else
return|return
name|y
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__GNUG__
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_NRV
argument_list|)
end_if

begin_expr_stmt
specifier|inline
name|Rational
name|operator
operator|+
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
end_expr_stmt

begin_return
return|return
name|r
block|{
name|add
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
block|; }
specifier|inline
name|Rational
name|operator
operator|-
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
end_return

begin_return
return|return
name|r
block|{
name|sub
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
block|; }
specifier|inline
name|Rational
name|operator
operator|*
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
end_return

begin_return
return|return
name|r
block|{
name|mul
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
block|; }
specifier|inline
name|Rational
name|operator
operator|/
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
end_return

begin_return
return|return
name|r
block|{
name|div
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
block|; }
else|#
directive|else
comment|/* NO_NRV */
specifier|inline
name|Rational
name|operator
operator|+
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|Rational
name|r
block|;
name|add
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
block|;
return|return
name|r
return|;
block|}
end_return

begin_expr_stmt
specifier|inline
name|Rational
name|operator
operator|-
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|Rational
name|r
block|;
name|sub
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
block|;
return|return
name|r
return|;
block|}
end_expr_stmt

begin_function
specifier|inline
name|Rational
name|operator
modifier|*
parameter_list|(
specifier|const
name|Rational
modifier|&
name|x
parameter_list|,
specifier|const
name|Rational
modifier|&
name|y
parameter_list|)
block|{
name|Rational
name|r
decl_stmt|;
name|mul
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_expr_stmt
specifier|inline
name|Rational
name|operator
operator|/
operator|(
specifier|const
name|Rational
operator|&
name|x
operator|,
specifier|const
name|Rational
operator|&
name|y
operator|)
block|{
name|Rational
name|r
block|;
name|div
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
name|r
argument_list|)
block|;
return|return
name|r
return|;
block|}
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

