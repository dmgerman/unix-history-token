begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  * Modified 1990 by Van Jacobson at Lawrence Berkeley Laboratory.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)valprint.c	6.5 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Print values for GNU debugger gdb.    Copyright (C) 1986, 1988, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_comment
comment|/* GNU software is only expected to run on systems with 32-bit integers.  */
end_comment

begin_define
define|#
directive|define
name|UINT_MAX
value|0xffffffff
end_define

begin_comment
comment|/* Maximum number of chars to print for a string pointer value    or vector contents, or UINT_MAX for no limit.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|print_max
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|type_print_varspec_suffix
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|type_print_varspec_prefix
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|type_print_base
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|type_print_method_args
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
modifier|*
name|unsigned_type_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|signed_type_table
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|float_type_table
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Print repeat counts if there are more than this    many repetitions of an element in an array.  */
end_comment

begin_define
define|#
directive|define
name|REPEAT_COUNT_THRESHOLD
value|10
end_define

begin_escape
end_escape

begin_comment
comment|/* Print the character string STRING, printing at most LENGTH characters.    Printing stops early if the number hits print_max; repeat counts    are printed as appropriate.  Print ellipses at the end if we    had to stop before printing LENGTH characters, or if FORCE_ELLIPSES.  */
end_comment

begin_function
name|void
name|print_string
parameter_list|(
name|stream
parameter_list|,
name|string
parameter_list|,
name|length
parameter_list|,
name|force_ellipses
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
modifier|*
name|string
decl_stmt|;
name|unsigned
name|int
name|length
decl_stmt|;
name|int
name|force_ellipses
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
name|int
name|in_quotes
init|=
literal|0
decl_stmt|;
name|int
name|need_comma
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|length
operator|==
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\"\""
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|length
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
operator|++
name|i
control|)
block|{
comment|/* Position of the character we are examining 	 to see whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repititions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|need_comma
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|need_comma
operator|=
literal|0
expr_stmt|;
block|}
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|length
operator|&&
name|string
index|[
name|rep1
index|]
operator|==
name|string
index|[
name|i
index|]
condition|)
block|{
operator|++
name|rep1
expr_stmt|;
operator|++
name|reps
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|REPEAT_COUNT_THRESHOLD
condition|)
block|{
if|if
condition|(
name|in_quotes
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\", "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|0
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
literal|"'"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|REPEAT_COUNT_THRESHOLD
expr_stmt|;
name|need_comma
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|in_quotes
condition|)
block|{
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|in_quotes
operator|=
literal|1
expr_stmt|;
block|}
name|printchar
argument_list|(
name|string
index|[
name|i
index|]
argument_list|,
name|stream
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
operator|++
name|things_printed
expr_stmt|;
block|}
block|}
comment|/* Terminate the quotes if necessary.  */
if|if
condition|(
name|in_quotes
condition|)
name|fputs_filtered
argument_list|(
literal|"\""
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|force_ellipses
operator|||
name|i
operator|<
name|length
condition|)
name|fputs_filtered
argument_list|(
literal|"..."
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print the value VAL in C-ish syntax on stream STREAM.    FORMAT is a format-letter, or 0 for print in natural format of data type.    If the object printed is a string pointer, returns    the number of string bytes printed.  */
end_comment

begin_function
name|int
name|value_print
parameter_list|(
name|val
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|pretty
parameter_list|)
name|value
name|val
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
name|format
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|,
name|n
decl_stmt|,
name|typelen
decl_stmt|;
comment|/* A "repeated" value really contains several values in a row.      They are made by the @ operator.      Print such values as if they were arrays.  */
if|if
condition|(
name|VALUE_REPEATED
argument_list|(
name|val
argument_list|)
condition|)
block|{
name|n
operator|=
name|VALUE_REPETITIONS
argument_list|(
name|val
argument_list|)
expr_stmt|;
name|typelen
operator|=
name|TYPE_LENGTH
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* Print arrays of characters using string syntax.  */
if|if
condition|(
name|typelen
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|format
operator|==
literal|0
condition|)
name|print_string
argument_list|(
name|stream
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Position of the array element we are examining to see 		 whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repititions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|n
operator|&&
operator|!
name|bcmp
argument_list|(
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|rep1
argument_list|,
name|typelen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|REPEAT_COUNT_THRESHOLD
condition|)
block|{
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|REPEAT_COUNT_THRESHOLD
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|+
name|typelen
operator|*
name|i
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|n
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
return|return
name|n
operator|*
name|typelen
return|;
block|}
else|else
block|{
comment|/* If it is a pointer, indicate what it points to.  	 Print type also if it is a reference.           C++: if it is a member pointer, we will take care 	 of that when we print it.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_PTR
operator|||
name|TYPE_CODE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_REF
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") "
argument_list|)
expr_stmt|;
comment|/* If this is a function pointer, try to print what 	     function it is pointing to by name.  */
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_FUNC
condition|)
block|{
name|print_address
argument_list|(
operator|(
operator|(
name|int
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
operator|)
index|[
literal|0
index|]
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* Return value is irrelevant except for string pointers.  */
return|return
literal|0
return|;
block|}
block|}
return|return
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|,
name|pretty
argument_list|)
return|;
block|}
block|}
end_function

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|int
name|prettyprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls prettyprinting of structures.  */
end_comment

begin_decl_stmt
name|int
name|unionprint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Controls printing of nested unions.  */
end_comment

begin_function_decl
specifier|static
name|void
name|scalar_print_hack
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
function_decl|(
modifier|*
name|default_scalar_print
function_decl|)
parameter_list|()
init|=
name|scalar_print_hack
function_decl|;
end_function_decl

begin_comment
comment|/* Print data of type TYPE located at VALADDR (within GDB),    which came from the inferior at address ADDRESS,    onto stdio stream STREAM according to FORMAT    (a letter or 0 for natural format).     If the data are a string pointer, returns the number of    sting characters printed.     if DEREF_REF is nonzero, then dereference references,    otherwise just print them like pointers.     The PRETTY parameter controls prettyprinting.  */
end_comment

begin_function
name|int
name|val_print
parameter_list|(
name|type
parameter_list|,
name|valaddr
parameter_list|,
name|address
parameter_list|,
name|stream
parameter_list|,
name|format
parameter_list|,
name|deref_ref
parameter_list|,
name|recurse
parameter_list|,
name|pretty
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|valaddr
decl_stmt|;
name|CORE_ADDR
name|address
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|char
name|format
decl_stmt|;
name|int
name|deref_ref
decl_stmt|;
name|int
name|recurse
decl_stmt|;
name|enum
name|val_prettyprint
name|pretty
decl_stmt|;
block|{
specifier|register
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|len
decl_stmt|,
name|n_baseclasses
decl_stmt|;
name|struct
name|type
modifier|*
name|elttype
decl_stmt|;
name|int
name|eltlen
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|;
if|if
condition|(
name|pretty
operator|==
name|Val_pretty_default
condition|)
block|{
name|pretty
operator|=
name|prettyprint
condition|?
name|Val_prettyprint
else|:
name|Val_no_prettyprint
expr_stmt|;
block|}
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Type not defined in this context>"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|eltlen
operator|=
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|eltlen
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
comment|/* For an array of chars, print with string syntax.  */
if|if
condition|(
name|eltlen
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|format
operator|==
literal|0
condition|)
name|print_string
argument_list|(
name|stream
argument_list|,
name|valaddr
argument_list|,
name|len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|unsigned
name|int
name|things_printed
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|&&
name|things_printed
operator|<
name|print_max
condition|;
name|i
operator|++
control|)
block|{
comment|/* Position of the array element we are examining to see 		     whether it is repeated.  */
name|unsigned
name|int
name|rep1
decl_stmt|;
comment|/* Number of repititions we have detected so far.  */
name|unsigned
name|int
name|reps
decl_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|rep1
operator|=
name|i
operator|+
literal|1
expr_stmt|;
name|reps
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|rep1
operator|<
name|len
operator|&&
operator|!
name|bcmp
argument_list|(
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
name|valaddr
operator|+
name|rep1
operator|*
name|eltlen
argument_list|,
name|eltlen
argument_list|)
condition|)
block|{
operator|++
name|reps
expr_stmt|;
operator|++
name|rep1
expr_stmt|;
block|}
if|if
condition|(
name|reps
operator|>
name|REPEAT_COUNT_THRESHOLD
condition|)
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<repeats %u times>"
argument_list|,
name|reps
argument_list|)
expr_stmt|;
name|i
operator|=
name|rep1
operator|-
literal|1
expr_stmt|;
name|things_printed
operator|+=
name|REPEAT_COUNT_THRESHOLD
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|elttype
argument_list|,
name|valaddr
operator|+
name|i
operator|*
name|eltlen
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
name|things_printed
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Array of unspecified length: treat like pointer to first elt.  */
name|valaddr
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|address
expr_stmt|;
case|case
name|TYPE_CODE_PTR
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_METHOD
condition|)
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|fn_field
modifier|*
name|f
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
decl_stmt|;
name|char
modifier|*
name|kind
init|=
literal|""
decl_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|128
condition|)
block|{
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VOFFSET
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|==
name|val
condition|)
block|{
name|kind
operator|=
literal|"virtual"
expr_stmt|;
goto|goto
name|common
goto|;
block|}
block|}
block|}
block|}
else|else
block|{
name|struct
name|symbol
modifier|*
name|sym
init|=
name|find_pc_function
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|val
argument_list|)
decl_stmt|;
if|if
condition|(
name|sym
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"invalid pointer to member function"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|f
operator|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len2
operator|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|SYMBOL_NAME
argument_list|(
name|sym
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
condition|)
goto|goto
name|common
goto|;
block|}
block|}
block|}
name|common
label|:
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stream
argument_list|,
name|kind
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
literal|1
argument_list|,
literal|"~"
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|""
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|") %d"
argument_list|,
operator|(
name|int
operator|)
name|val
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|==
name|TYPE_CODE_MEMBER
condition|)
block|{
name|struct
name|type
modifier|*
name|domain
init|=
name|TYPE_DOMAIN_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|target
init|=
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|kind
init|=
literal|""
decl_stmt|;
comment|/* VAL is a byte offset into the structure type DOMAIN. 	     Find the name of the field for that offset and 	     print it.  */
name|int
name|extra
init|=
literal|0
decl_stmt|;
name|int
name|bits
init|=
literal|0
decl_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|domain
argument_list|)
expr_stmt|;
comment|/* @@ Make VAL into bit offset */
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
operator|<<
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|int
name|bitpos
init|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|bitpos
condition|)
break|break;
if|if
condition|(
name|val
operator|<
name|bitpos
operator|&&
name|i
operator|>
literal|0
condition|)
block|{
name|int
name|ptrsize
init|=
operator|(
name|TYPE_LENGTH
argument_list|(
name|builtin_type_char
argument_list|)
operator|*
name|TYPE_LENGTH
argument_list|(
name|target
argument_list|)
operator|)
decl_stmt|;
comment|/* Somehow pointing into a field.  */
name|i
operator|-=
literal|1
expr_stmt|;
name|extra
operator|=
operator|(
name|val
operator|-
name|TYPE_FIELD_BITPOS
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|extra
operator|&
literal|0x3
condition|)
name|bits
operator|=
literal|1
expr_stmt|;
else|else
name|extra
operator|>>=
literal|3
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
name|type_print_base
argument_list|(
name|domain
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|domain
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|extra
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" + %d bytes"
argument_list|,
name|extra
argument_list|)
expr_stmt|;
if|if
condition|(
name|bits
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" (offset in bits)"
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
name|val
operator|>>
literal|3
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|valaddr
argument_list|)
expr_stmt|;
comment|/* For a pointer to char or unsigned char, 	     also print the string pointed to, unless pointer is null.  */
comment|/* For an array of chars, print with string syntax.  */
name|elttype
operator|=
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
comment|/* Number of characters printed.  */
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|elttype
argument_list|)
operator|==
literal|1
operator|&&
name|TYPE_CODE
argument_list|(
name|elttype
argument_list|)
operator|==
name|TYPE_CODE_INT
operator|&&
name|format
operator|==
literal|0
operator|&&
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
operator|!=
literal|0
comment|/* If print_max is UINT_MAX, the alloca below will fail. 	         In that case don't try to print the string.  */
operator|&&
name|print_max
operator|<
name|UINT_MAX
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* Get first character.  */
if|if
condition|(
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
comment|/* First address out of bounds.  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Address 0x%x out of bounds>"
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|valaddr
operator|)
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
comment|/* A real string.  */
name|int
name|out_of_bounds
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|print_max
argument_list|)
decl_stmt|;
comment|/* If the loop ends by us hitting print_max characters, 		     we need to have elipses at the end.  */
name|int
name|force_ellipses
init|=
literal|1
decl_stmt|;
comment|/* This loop only fetches print_max characters, even 		     though print_string might want to print more 		     (with repeated characters).  This is so that 		     we don't spend forever fetching if we print 		     a long string consisting of the same character 		     repeated.  */
while|while
condition|(
name|i
operator|<
name|print_max
condition|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|read_memory
argument_list|(
operator|(
name|CORE_ADDR
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
operator|+
name|i
argument_list|,
operator|&
name|c
argument_list|,
literal|1
argument_list|)
condition|)
block|{
name|out_of_bounds
operator|=
literal|1
expr_stmt|;
name|force_ellipses
operator|=
literal|0
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|force_ellipses
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
name|string
index|[
name|i
operator|++
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|print_string
argument_list|(
name|stream
argument_list|,
name|string
argument_list|,
name|i
argument_list|,
name|force_ellipses
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_bounds
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<Address 0x%x out of bounds>"
argument_list|,
operator|(
operator|*
operator|(
name|int
operator|*
operator|)
name|valaddr
operator|)
operator|+
name|i
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
block|}
comment|/* Return number of characters printed, plus one for the 	     terminating null if we have "reached the end".  */
return|return
name|i
operator|+
operator|(
name|print_max
operator|&&
name|i
operator|!=
name|print_max
operator|)
return|;
block|}
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
name|error
argument_list|(
literal|"not implemented: member type in val_print"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"(0x%x&) = "
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|valaddr
argument_list|)
expr_stmt|;
comment|/* De-reference the reference.  */
if|if
condition|(
name|deref_ref
condition|)
block|{
if|if
condition|(
name|TYPE_CODE
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|!=
name|TYPE_CODE_UNDEF
condition|)
block|{
name|value
name|val
init|=
name|value_at
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
operator|*
operator|(
name|int
operator|*
operator|)
name|valaddr
argument_list|)
decl_stmt|;
name|val_print
argument_list|(
name|VALUE_TYPE
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"???"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_UNION
case|:
if|if
condition|(
name|recurse
operator|&&
operator|!
name|unionprint
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Fall through.  */
case|case
name|TYPE_CODE_STRUCT
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|n_baseclasses
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"<"
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"> = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
literal|0
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
operator|-
literal|1
argument_list|)
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|1
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|"members of "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|": "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|len
operator|&&
name|i
operator|==
literal|1
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<No data fields>"
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|-=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|>
name|n_baseclasses
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|+
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" = "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
comment|/* check if static field */
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|value
name|v
decl_stmt|;
name|v
operator|=
name|value_static_field
argument_list|(
name|type
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|char
modifier|*
name|valp
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|val
decl_stmt|;
union|union
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
block|}
name|test
union|;
name|test
operator|.
name|i
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|test
operator|.
name|c
operator|!=
literal|1
condition|)
name|valp
operator|+=
sizeof|sizeof
name|val
operator|-
name|TYPE_LENGTH
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_field_as_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valp
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|val_print
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|valaddr
operator|+
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|/
literal|8
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|,
name|format
argument_list|,
name|deref_ref
argument_list|,
name|recurse
operator|+
literal|1
argument_list|,
name|pretty
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|pretty
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|print_spaces_filtered
argument_list|(
literal|2
operator|*
name|recurse
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|val
operator|=
name|unpack_long
argument_list|(
name|builtin_type_int
argument_list|,
name|valaddr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
break|break;
block|}
if|if
condition|(
name|i
operator|<
name|len
condition|)
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|int
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
if|if
condition|(
name|format
condition|)
block|{
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|type
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"} "
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%x"
argument_list|,
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_INT
case|:
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
block|{
call|(
modifier|*
name|default_scalar_print
call|)
argument_list|(
name|stream
argument_list|,
name|type
argument_list|,
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|==
literal|1
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" '"
argument_list|)
expr_stmt|;
name|printchar
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|unpack_long
argument_list|(
name|type
argument_list|,
name|valaddr
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|'\''
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"'"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
break|break;
case|case
name|TYPE_CODE_FLT
case|:
if|if
condition|(
name|format
condition|)
name|print_scalar_formatted
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|format
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|print_floating
argument_list|(
name|valaddr
argument_list|,
name|type
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid type code in symbol table."
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stream
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print a description of a type TYPE    in the form of a declaration of a variable named VARSTRING.    Output goes to STREAM (via stdio).    If SHOW is positive, we show the contents of the outermost level    of structure even if there is a type name that could be used instead.    If SHOW is negative, we never show the details of elements' types.  */
end_comment

begin_function
name|void
name|type_print
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
block|{
name|type_print_1
argument_list|(
name|type
argument_list|,
name|varstring
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* LEVEL is the depth to indent lines by.  */
end_comment

begin_function
name|void
name|type_print_1
parameter_list|(
name|type
parameter_list|,
name|varstring
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|varstring
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
specifier|register
name|enum
name|type_code
name|code
decl_stmt|;
name|type_print_base
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
name|code
operator|=
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|varstring
operator|&&
operator|*
name|varstring
operator|)
operator|||
comment|/* Need a space if going to print stars or brackets; 	 but not if we will print just a type name.  */
operator|(
operator|(
name|show
operator|>
literal|0
operator|||
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|code
operator|==
name|TYPE_CODE_PTR
operator|||
name|code
operator|==
name|TYPE_CODE_FUNC
operator|||
name|code
operator|==
name|TYPE_CODE_METHOD
operator|||
name|code
operator|==
name|TYPE_CODE_ARRAY
operator|||
name|code
operator|==
name|TYPE_CODE_MEMBER
operator|||
name|code
operator|==
name|TYPE_CODE_REF
operator|)
operator|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|type
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print the method arguments ARGS to the file STREAM.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_method_args
parameter_list|(
name|args
parameter_list|,
name|prefix
parameter_list|,
name|varstring
parameter_list|,
name|staticp
parameter_list|,
name|stream
parameter_list|)
name|struct
name|type
modifier|*
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|prefix
decl_stmt|,
decl|*
name|varstring
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|staticp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|stream
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|prefix
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|varstring
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" ("
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|&&
name|args
index|[
operator|!
name|staticp
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|i
operator|=
operator|!
name|staticp
expr_stmt|;
comment|/* skip the class variable */
while|while
condition|(
literal|1
condition|)
block|{
name|type_print
argument_list|(
name|args
index|[
name|i
operator|++
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|args
index|[
name|i
index|]
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" ..."
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* If TYPE is a derived type, then print out derivation    information.  Print out all layers of the type heirarchy    until we encounter one with multiple inheritance.    At that point, print out that ply, and return.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_derivation_info
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|int
name|i
decl_stmt|,
name|n_baseclasses
init|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|basetype
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|type
operator|&&
name|n_baseclasses
operator|==
literal|1
condition|)
block|{
name|basetype
operator|=
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|name
operator|!=
literal|' '
condition|)
name|name
operator|++
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|": %s%s "
argument_list|,
name|TYPE_VIA_PUBLIC
argument_list|(
name|basetype
argument_list|)
condition|?
literal|"public"
else|:
literal|"private"
argument_list|,
name|TYPE_VIA_VIRTUAL
argument_list|(
name|basetype
argument_list|)
condition|?
literal|" virtual"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
name|n_baseclasses
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|basetype
argument_list|)
expr_stmt|;
name|type
operator|=
name|basetype
expr_stmt|;
block|}
if|if
condition|(
name|type
condition|)
block|{
if|if
condition|(
name|n_baseclasses
operator|!=
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|": "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|n_baseclasses
condition|;
name|i
operator|++
control|)
block|{
name|basetype
operator|=
name|TYPE_BASECLASS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|&&
operator|(
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|basetype
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|name
operator|!=
literal|' '
condition|)
name|name
operator|++
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%s%s "
argument_list|,
name|TYPE_VIA_PUBLIC
argument_list|(
name|basetype
argument_list|)
condition|?
literal|"public"
else|:
literal|"private"
argument_list|,
name|TYPE_VIA_VIRTUAL
argument_list|(
name|basetype
argument_list|)
condition|?
literal|" virtual"
else|:
literal|""
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|<
name|n_baseclasses
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print any asterisks or open-parentheses needed before the    variable name (to describe its type).     On outermost call, pass 0 for PASSED_A_PTR.    On outermost call, SHOW> 0 means should ignore    any typename for TYPE and show its details.    SHOW is always zero on recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_varspec_prefix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_PTR
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"*"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
name|type_print_base
argument_list|(
name|TYPE_DOMAIN_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"::"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_REF
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"&"
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_ARRAY
case|:
name|type_print_varspec_prefix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print any array sizes, function arguments or close parentheses    needed after the variable name (to describe its type).    Args work like type_print_varspec_prefix.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_varspec_suffix
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|passed_a_ptr
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|passed_a_ptr
decl_stmt|;
block|{
if|if
condition|(
name|type
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
return|return;
name|QUIT
expr_stmt|;
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"["
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|>=
literal|0
operator|&&
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"%d"
argument_list|,
operator|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
operator|/
name|TYPE_LENGTH
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"]"
argument_list|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_MEMBER
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_METHOD
case|:
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
block|{
name|int
name|i
decl_stmt|;
name|struct
name|type
modifier|*
modifier|*
name|args
init|=
name|TYPE_ARG_TYPES
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"("
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|i
operator|=
literal|1
init|;
name|args
index|[
name|i
index|]
operator|!=
literal|0
operator|&&
name|args
index|[
name|i
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|;
name|i
operator|++
control|)
block|{
name|type_print_1
argument_list|(
name|args
index|[
name|i
index|]
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|args
index|[
name|i
operator|+
literal|1
index|]
operator|->
name|code
operator|!=
name|TYPE_CODE_VOID
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|","
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_REF
case|:
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FUNC
case|:
name|type_print_varspec_suffix
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|,
name|passed_a_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
name|passed_a_ptr
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|")"
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"()"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* Print the name of the type (or the ultimate pointer target,    function value or array element), or the description of a    structure or union.     SHOW nonzero means don't print this type as just its name;    show its real definition even if it has a name.    SHOW zero means print just typename or struct tag if there is one    SHOW negative means abbreviate structure elements.    SHOW is decremented for printing of structure elements.     LEVEL is the depth to indent by.    We increase it for some recursive calls.  */
end_comment

begin_function
specifier|static
name|void
name|type_print_base
parameter_list|(
name|type
parameter_list|,
name|stream
parameter_list|,
name|show
parameter_list|,
name|level
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|FILE
modifier|*
name|stream
decl_stmt|;
name|int
name|show
decl_stmt|;
name|int
name|level
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|int
name|lastval
decl_stmt|;
name|QUIT
expr_stmt|;
if|if
condition|(
name|type
operator|==
literal|0
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"type unknown"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
name|show
operator|<=
literal|0
condition|)
block|{
name|fputs_filtered
argument_list|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
name|TYPE_CODE_ARRAY
case|:
case|case
name|TYPE_CODE_PTR
case|:
case|case
name|TYPE_CODE_MEMBER
case|:
case|case
name|TYPE_CODE_REF
case|:
case|case
name|TYPE_CODE_FUNC
case|:
case|case
name|TYPE_CODE_METHOD
case|:
name|type_print_base
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
argument_list|,
name|level
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_STRUCT
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
goto|goto
name|struct_union
goto|;
case|case
name|TYPE_CODE_UNION
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"union "
argument_list|)
expr_stmt|;
name|struct_union
label|:
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|&&
operator|(
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
operator|)
condition|)
block|{
while|while
condition|(
operator|*
name|name
operator|!=
literal|' '
condition|)
name|name
operator|++
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|i
decl_stmt|;
name|type_print_derivation_info
argument_list|(
name|stream
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|TYPE_FLAGS
argument_list|(
name|type
argument_list|)
operator|&
name|TYPE_FLAG_STUB
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<incomplete type>\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"<no data fields>\n"
argument_list|)
expr_stmt|;
block|}
comment|/* If there is a base class for this type, 	     do not print the field that it occupies.  */
for|for
control|(
name|i
operator|=
name|TYPE_N_BASECLASSES
argument_list|(
name|type
argument_list|)
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
comment|/* Don't print out virtual function table.  */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|"_vptr$"
argument_list|,
literal|6
argument_list|)
condition|)
continue|continue;
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
block|}
name|type_print_1
argument_list|(
name|TYPE_FIELD_TYPE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|,
name|show
operator|-
literal|1
argument_list|,
name|level
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|TYPE_FIELD_STATIC
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
operator|&&
name|TYPE_FIELD_PACKED
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
comment|/* It is a bitfield.  This code does not attempt 		     to look at the bitpos and reconstruct filler, 		     unnamed fields.  This would lead to misleading 		     results if the compiler does not put out fields 		     for such things (I don't know what it does).  */
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : %d"
argument_list|,
name|TYPE_FIELD_BITSIZE
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
comment|/* C++: print out the methods */
name|len
operator|=
name|TYPE_NFN_FIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|struct
name|fn_field
modifier|*
name|f
init|=
name|TYPE_FN_FIELDLIST1
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
name|int
name|j
decl_stmt|,
name|len2
init|=
name|TYPE_FN_FIELDLIST_LENGTH
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|len2
condition|;
name|j
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
name|print_spaces_filtered
argument_list|(
name|level
operator|+
literal|4
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_VIRTUAL_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"virtual "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"static "
argument_list|)
expr_stmt|;
name|type_print
argument_list|(
name|TYPE_TARGET_TYPE
argument_list|(
name|TYPE_FN_FIELD_TYPE
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|)
argument_list|,
literal|""
argument_list|,
name|stream
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|0
index|]
operator|==
literal|'_'
operator|&&
name|TYPE_FN_FIELD_PHYSNAME
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
index|[
literal|1
index|]
operator|==
literal|'$'
condition|)
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
operator|+
literal|1
argument_list|,
literal|"~"
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
literal|0
argument_list|,
name|stream
argument_list|)
expr_stmt|;
else|else
name|type_print_method_args
argument_list|(
name|TYPE_FN_FIELD_ARGS
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
literal|""
argument_list|,
name|TYPE_FN_FIELDLIST_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|TYPE_FN_FIELD_STATIC_P
argument_list|(
name|f
argument_list|,
name|j
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len2
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|print_spaces_filtered
argument_list|(
name|level
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_ENUM
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|name
operator|=
name|TYPE_NAME
argument_list|(
name|type
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|name
operator|!=
literal|' '
condition|)
name|name
operator|++
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
operator|+
literal|1
argument_list|,
name|stream
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
literal|" "
argument_list|,
name|stream
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|show
operator|<
literal|0
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{...}"
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"{"
argument_list|)
expr_stmt|;
name|len
operator|=
name|TYPE_NFIELDS
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|lastval
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|QUIT
expr_stmt|;
if|if
condition|(
name|i
condition|)
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|", "
argument_list|)
expr_stmt|;
name|fputs_filtered
argument_list|(
name|TYPE_FIELD_NAME
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|,
name|stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastval
operator|!=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
condition|)
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|" : %d"
argument_list|,
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|lastval
operator|=
name|TYPE_FIELD_BITPOS
argument_list|(
name|type
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|lastval
operator|++
expr_stmt|;
block|}
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"}"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_CODE_INT
case|:
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|name
operator|=
name|unsigned_type_table
index|[
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
else|else
name|name
operator|=
name|signed_type_table
index|[
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_FLT
case|:
name|name
operator|=
name|float_type_table
index|[
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
index|]
expr_stmt|;
name|fputs_filtered
argument_list|(
name|name
argument_list|,
name|stream
argument_list|)
expr_stmt|;
break|break;
case|case
name|TYPE_CODE_VOID
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"void"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"struct unknown"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"Invalid type code in symbol table."
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scalar_print_decimal
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|,
name|val
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
block|{
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|?
literal|"%lu"
else|:
literal|"%ld"
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|scalar_print_hex
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|,
name|val
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
block|{
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%02lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%04lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%08lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0x%lx"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scalar_print_octal
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|,
name|val
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
block|{
switch|switch
condition|(
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0%03lo"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0%06lo"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0%012lo"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
default|default:
name|fprintf_filtered
argument_list|(
name|stream
argument_list|,
literal|"0%lo"
argument_list|,
name|val
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|scalar_print_hack
parameter_list|(
name|stream
parameter_list|,
name|type
parameter_list|,
name|val
parameter_list|)
name|FILE
modifier|*
name|stream
decl_stmt|;
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|LONGEST
name|val
decl_stmt|;
block|{
if|if
condition|(
name|TYPE_UNSIGNED
argument_list|(
name|type
argument_list|)
condition|)
name|scalar_print_hex
argument_list|(
name|stream
argument_list|,
name|type
argument_list|,
name|val
argument_list|)
expr_stmt|;
else|else
name|scalar_print_decimal
argument_list|(
name|stream
argument_list|,
name|type
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_function
specifier|static
name|void
name|set_maximum_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|arg
condition|)
name|error_no_arg
argument_list|(
literal|"value for maximum elements to print"
argument_list|)
expr_stmt|;
name|print_max
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_max
operator|==
literal|0
condition|)
name|print_max
operator|=
name|UINT_MAX
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_base_command
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|int
name|base
decl_stmt|;
if|if
condition|(
operator|!
name|arg
condition|)
name|base
operator|=
literal|0
expr_stmt|;
else|else
name|base
operator|=
name|parse_and_eval_address
argument_list|(
name|arg
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|base
condition|)
block|{
default|default:
name|default_scalar_print
operator|=
name|scalar_print_hack
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|default_scalar_print
operator|=
name|scalar_print_octal
expr_stmt|;
break|break;
case|case
literal|10
case|:
name|default_scalar_print
operator|=
name|scalar_print_decimal
expr_stmt|;
break|break;
case|case
literal|16
case|:
name|default_scalar_print
operator|=
name|scalar_print_hex
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|set_prettyprint_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|prettyprint
operator|=
name|parse_binary_operation
argument_list|(
literal|"set prettyprint"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_unionprint_command
parameter_list|(
name|arg
parameter_list|,
name|from_tty
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|from_tty
decl_stmt|;
block|{
name|unionprint
operator|=
name|parse_binary_operation
argument_list|(
literal|"set unionprint"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|format_info
argument_list|(
argument|arg
argument_list|,
argument|from_tty
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|from_tty
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|arg
condition|)
name|error
argument_list|(
literal|"\"info format\" does not take any arguments."
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Prettyprinting of structures is %s.\n"
argument_list|,
name|prettyprint
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Printing of unions interior to structures is %s.\n"
argument_list|,
name|unionprint
condition|?
literal|"on"
else|:
literal|"off"
argument_list|)
expr_stmt|;
if|if
condition|(
name|print_max
operator|==
name|UINT_MAX
condition|)
name|printf_filtered
argument_list|(
literal|"There is no maximum number of array elements printed.\n"
argument_list|)
expr_stmt|;
else|else
name|printf_filtered
argument_list|(
literal|"The maximum number of array elements printed is %d.\n"
argument_list|,
name|print_max
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|extern
name|struct
name|cmd_list_element
modifier|*
name|setlist
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|_initialize_valprint
parameter_list|()
block|{
name|add_cmd
argument_list|(
literal|"base"
argument_list|,
name|class_support
argument_list|,
name|set_base_command
argument_list|,
literal|"Change default integer print radix to 8, 10 or 16\n\ No args returns to the ad-hoc default of `16' for unsigned values\n\ and `10' otherwise."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"array-max"
argument_list|,
name|class_vars
argument_list|,
name|set_maximum_command
argument_list|,
literal|"Set NUMBER as limit on string chars or array elements to print.\n\ \"set array-max 0\" causes there to be no limit."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"prettyprint"
argument_list|,
name|class_support
argument_list|,
name|set_prettyprint_command
argument_list|,
literal|"Turn prettyprinting of structures on and off."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_alias_cmd
argument_list|(
literal|"pp"
argument_list|,
literal|"prettyprint"
argument_list|,
name|class_support
argument_list|,
literal|1
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_cmd
argument_list|(
literal|"unionprint"
argument_list|,
name|class_support
argument_list|,
name|set_unionprint_command
argument_list|,
literal|"Turn printing of unions interior to structures on and off."
argument_list|,
operator|&
name|setlist
argument_list|)
expr_stmt|;
name|add_info
argument_list|(
literal|"format"
argument_list|,
name|format_info
argument_list|,
literal|"Show current settings of data formatting options."
argument_list|)
expr_stmt|;
comment|/* Give people the defaults which they are used to.  */
name|prettyprint
operator|=
literal|0
expr_stmt|;
name|unionprint
operator|=
literal|1
expr_stmt|;
name|print_max
operator|=
literal|200
expr_stmt|;
name|unsigned_type_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|unsigned_type_table
argument_list|,
operator|(
literal|1
operator|+
expr|sizeof
operator|(
name|unsigned
name|LONGEST
operator|)
operator|)
argument_list|)
expr_stmt|;
name|unsigned_type_table
index|[
expr|sizeof
operator|(
name|unsigned
name|char
operator|)
expr|]
operator|=
literal|"unsigned char"
expr_stmt|;
name|unsigned_type_table
index|[
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
expr|]
operator|=
literal|"unsigned short"
expr_stmt|;
name|unsigned_type_table
index|[
expr|sizeof
operator|(
name|unsigned
name|long
operator|)
expr|]
operator|=
literal|"unsigned long"
expr_stmt|;
name|unsigned_type_table
index|[
expr|sizeof
operator|(
name|unsigned
name|int
operator|)
expr|]
operator|=
literal|"unsigned int"
expr_stmt|;
ifdef|#
directive|ifdef
name|LONG_LONG
name|unsigned_type_table
index|[
expr|sizeof
operator|(
name|unsigned
name|long
name|long
operator|)
expr|]
operator|=
literal|"unsigned long long"
expr_stmt|;
endif|#
directive|endif
name|signed_type_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|signed_type_table
argument_list|,
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|LONGEST
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|signed_type_table
index|[
sizeof|sizeof
argument_list|(
name|char
argument_list|)
index|]
operator|=
literal|"char"
expr_stmt|;
name|signed_type_table
index|[
sizeof|sizeof
argument_list|(
name|short
argument_list|)
index|]
operator|=
literal|"short"
expr_stmt|;
name|signed_type_table
index|[
sizeof|sizeof
argument_list|(
name|long
argument_list|)
index|]
operator|=
literal|"long"
expr_stmt|;
name|signed_type_table
index|[
sizeof|sizeof
argument_list|(
name|int
argument_list|)
index|]
operator|=
literal|"int"
expr_stmt|;
ifdef|#
directive|ifdef
name|LONG_LONG
name|signed_type_table
index|[
expr|sizeof
operator|(
name|long
name|long
operator|)
expr|]
operator|=
literal|"long long"
expr_stmt|;
endif|#
directive|endif
name|float_type_table
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|float_type_table
argument_list|,
operator|(
literal|1
operator|+
sizeof|sizeof
argument_list|(
name|double
argument_list|)
operator|)
argument_list|)
expr_stmt|;
name|float_type_table
index|[
sizeof|sizeof
argument_list|(
name|float
argument_list|)
index|]
operator|=
literal|"float"
expr_stmt|;
name|float_type_table
index|[
sizeof|sizeof
argument_list|(
name|double
argument_list|)
index|]
operator|=
literal|"double"
expr_stmt|;
block|}
end_function

end_unit

