begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Find a variable's value in memory, for GDB, the GNU debugger.    Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.  This file is part of GDB.  GDB is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GDB is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GDB; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"symtab.h"
end_include

begin_include
include|#
directive|include
file|"frame.h"
end_include

begin_include
include|#
directive|include
file|"value.h"
end_include

begin_function_decl
name|CORE_ADDR
name|read_register
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Return the address in which frame FRAME's value of register REGNUM    has been saved in memory.  Or return zero if it has not been saved.    If REGNUM specifies the SP, the value we return is actually    the SP value, not an address where it was saved.  */
end_comment

begin_function
name|CORE_ADDR
name|find_saved_register
parameter_list|(
name|frame
parameter_list|,
name|regnum
parameter_list|)
name|FRAME
name|frame
decl_stmt|;
name|int
name|regnum
decl_stmt|;
block|{
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|frame_saved_regs
name|saved_regs
decl_stmt|;
specifier|register
name|FRAME
name|frame1
init|=
literal|0
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|HAVE_REGISTER_WINDOWS
comment|/* We assume that a register in a register window will only be saved      in one place (since the name changes and disappears as you go      towards inner frames), so we only call get_frame_saved_regs on      the current frame.  This is directly in contradiction to the      usage below, which assumes that registers used in a frame must be      saved in a lower (more interior) frame.  This change is a result      of working on a register window machine; get_frame_saved_regs      always returns the registers saved within a frame, within the      context (register namespace) of that frame. */
comment|/* However, note that we don't want this to return anything if      nothing is saved (if there's a frame inside of this one).  Also,      callers to this routine asking for the stack pointer want the      stack pointer saved for *this* frame; this is returned from the      next frame.  */
if|if
condition|(
name|REGISTER_IN_WINDOW_P
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
name|frame1
operator|=
name|get_next_frame
argument_list|(
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|frame1
condition|)
return|return
literal|0
return|;
comment|/* Registers of this frame are 				   active.  */
comment|/* Get the SP from the next frame in; it will be this 	 current frame.  */
if|if
condition|(
name|regnum
operator|!=
name|SP_REGNUM
condition|)
name|frame1
operator|=
name|frame
expr_stmt|;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|saved_regs
argument_list|)
expr_stmt|;
return|return
operator|(
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
condition|?
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
else|:
literal|0
operator|)
return|;
block|}
endif|#
directive|endif
comment|/* HAVE_REGISTER_WINDOWS */
comment|/* Note that this next routine assumes that registers used in      frame x will be saved only in the frame that x calls and      frames interior to it.  This is not true on the sparc, but the      above macro takes care of it, so we should be all right. */
while|while
condition|(
literal|1
condition|)
block|{
name|QUIT
expr_stmt|;
name|frame1
operator|=
name|get_prev_frame
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame1
operator|==
literal|0
operator|||
name|frame1
operator|==
name|frame
condition|)
break|break;
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame1
argument_list|)
expr_stmt|;
name|get_frame_saved_regs
argument_list|(
name|fi
argument_list|,
operator|&
name|saved_regs
argument_list|)
expr_stmt|;
if|if
condition|(
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
condition|)
name|addr
operator|=
name|saved_regs
operator|.
name|regs
index|[
name|regnum
index|]
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/* Copy the bytes of register REGNUM, relative to the current stack frame,    into our memory at MYADDR.    The number of bytes copied is REGISTER_RAW_SIZE (REGNUM).  */
end_comment

begin_function
name|void
name|read_relative_register_raw_bytes
parameter_list|(
name|regnum
parameter_list|,
name|myaddr
parameter_list|)
name|int
name|regnum
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
if|if
condition|(
name|regnum
operator|==
name|FP_REGNUM
condition|)
block|{
name|bcopy
argument_list|(
operator|&
name|FRAME_FP
argument_list|(
name|selected_frame
argument_list|)
argument_list|,
name|myaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|addr
operator|=
name|find_saved_register
argument_list|(
name|selected_frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
block|{
name|CORE_ADDR
name|buffer
init|=
name|addr
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|buffer
argument_list|,
name|myaddr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|read_memory
argument_list|(
name|addr
argument_list|,
name|myaddr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|myaddr
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return a `value' with the contents of register REGNUM    in its virtual format, with the type specified by    REGISTER_VIRTUAL_TYPE.  */
end_comment

begin_function
name|value
name|value_of_register
parameter_list|(
name|regnum
parameter_list|)
name|int
name|regnum
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|addr
decl_stmt|;
specifier|register
name|value
name|val
decl_stmt|;
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|have_inferior_p
argument_list|()
operator|||
name|have_core_file_p
argument_list|()
operator|)
condition|)
name|error
argument_list|(
literal|"Can't get value of register without inferior or core file"
argument_list|)
expr_stmt|;
name|addr
operator|=
name|find_saved_register
argument_list|(
name|selected_frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
condition|)
block|{
if|if
condition|(
name|regnum
operator|==
name|SP_REGNUM
condition|)
return|return
name|value_from_long
argument_list|(
name|builtin_type_int
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
return|;
name|read_memory
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
name|val
operator|=
name|allocate_value
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|virtual_buffer
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|val
argument_list|)
argument_list|,
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|val
argument_list|)
operator|=
name|addr
condition|?
name|lval_memory
else|:
name|lval_register
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|val
argument_list|)
operator|=
name|addr
condition|?
name|addr
else|:
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|VALUE_REGNO
argument_list|(
name|val
argument_list|)
operator|=
name|regnum
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Low level examining and depositing of registers.     Note that you must call `fetch_registers' once    before examining or depositing any registers.  */
end_comment

begin_decl_stmt
name|char
name|registers
index|[
name|REGISTER_BYTES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Copy LEN bytes of consecutive data from registers    starting with the REGBYTE'th byte of register data    into memory at MYADDR.  */
end_comment

begin_function
name|void
name|read_register_bytes
parameter_list|(
name|regbyte
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|regbyte
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|bcopy
argument_list|(
operator|&
name|registers
index|[
name|regbyte
index|]
argument_list|,
name|myaddr
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Copy LEN bytes of consecutive data from memory at MYADDR    into registers starting with the REGBYTE'th byte of register data.  */
end_comment

begin_function
name|void
name|write_register_bytes
parameter_list|(
name|regbyte
parameter_list|,
name|myaddr
parameter_list|,
name|len
parameter_list|)
name|int
name|regbyte
decl_stmt|;
name|char
modifier|*
name|myaddr
decl_stmt|;
name|int
name|len
decl_stmt|;
block|{
name|bcopy
argument_list|(
name|myaddr
argument_list|,
operator|&
name|registers
index|[
name|regbyte
index|]
argument_list|,
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|store_inferior_registers
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return the contents of register REGNO,    regarding it as an integer.  */
end_comment

begin_function
name|CORE_ADDR
name|read_register
parameter_list|(
name|regno
parameter_list|)
name|int
name|regno
decl_stmt|;
block|{
comment|/* This loses when REGISTER_RAW_SIZE (regno) != sizeof (int) */
return|return
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
return|;
block|}
end_function

begin_comment
comment|/* Store VALUE in the register number REGNO, regarded as an integer.  */
end_comment

begin_function
name|void
name|write_register
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
name|int
name|regno
decl_stmt|,
name|val
decl_stmt|;
block|{
comment|/* This loses when REGISTER_RAW_SIZE (regno) != sizeof (int) */
if|#
directive|if
name|defined
argument_list|(
name|sun4
argument_list|)
comment|/* This is a no-op on a Sun 4.  */
if|if
condition|(
name|regno
operator|==
literal|0
condition|)
return|return;
endif|#
directive|endif
operator|*
operator|(
name|int
operator|*
operator|)
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
operator|=
name|val
expr_stmt|;
if|if
condition|(
name|have_inferior_p
argument_list|()
condition|)
name|store_inferior_registers
argument_list|(
name|regno
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Record that register REGNO contains VAL.    This is used when the value is obtained from the inferior or core dump,    so there is no need to store the value there.  */
end_comment

begin_function
name|void
name|supply_register
parameter_list|(
name|regno
parameter_list|,
name|val
parameter_list|)
name|int
name|regno
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|bcopy
argument_list|(
name|val
argument_list|,
operator|&
name|registers
index|[
name|REGISTER_BYTE
argument_list|(
name|regno
argument_list|)
index|]
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a struct symbol for a variable,    and a stack frame id, read the value of the variable    and return a (pointer to a) struct value containing the value.  */
end_comment

begin_function
name|value
name|read_var_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|value
name|v
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
specifier|register
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|int
name|val
init|=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|v
operator|=
name|allocate_value
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
comment|/* The most likely possibility.  */
name|len
operator|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|frame
operator|=
name|selected_frame
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_LABEL
case|:
name|bcopy
argument_list|(
operator|&
name|val
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_CONST_BYTES
case|:
name|bcopy
argument_list|(
name|val
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|not_lval
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_STATIC
case|:
name|addr
operator|=
name|val
expr_stmt|;
break|break;
comment|/* Nonzero if a struct which is located in a register or a LOC_ARG    really contains    the address of the struct, not the struct itself.  GCC_P is nonzero    if the function was compiled with GCC.  */
if|#
directive|if
operator|!
name|defined
argument_list|(
name|REG_STRUCT_HAS_ADDR
argument_list|)
define|#
directive|define
name|REG_STRUCT_HAS_ADDR
parameter_list|(
name|gcc_p
parameter_list|)
value|0
endif|#
directive|endif
case|case
name|LOC_ARG
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|=
name|val
operator|+
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|=
name|val
operator|+
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|addr
operator|=
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|=
name|val
operator|+
name|FRAME_LOCALS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|error
argument_list|(
literal|"Cannot look up value of a typedef"
argument_list|)
expr_stmt|;
case|case
name|LOC_BLOCK
case|:
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|v
return|;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
block|{
name|struct
name|block
modifier|*
name|b
init|=
name|get_frame_block
argument_list|(
name|frame
argument_list|)
decl_stmt|;
name|v
operator|=
name|value_from_register
argument_list|(
name|type
argument_list|,
name|val
argument_list|,
name|frame
argument_list|)
expr_stmt|;
if|if
condition|(
name|REG_STRUCT_HAS_ADDR
argument_list|(
name|b
operator|->
name|gcc_compile_flag
argument_list|)
operator|&&
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_STRUCT
condition|)
name|addr
operator|=
operator|*
operator|(
name|CORE_ADDR
operator|*
operator|)
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
expr_stmt|;
else|else
return|return
name|v
return|;
block|}
block|}
name|read_memory
argument_list|(
name|addr
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|addr
expr_stmt|;
return|return
name|v
return|;
block|}
end_function

begin_comment
comment|/* Return a value of type TYPE, stored in register REGNUM, in frame    FRAME. */
end_comment

begin_function
name|value
name|value_from_register
parameter_list|(
name|type
parameter_list|,
name|regnum
parameter_list|,
name|frame
parameter_list|)
name|struct
name|type
modifier|*
name|type
decl_stmt|;
name|int
name|regnum
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
name|char
name|raw_buffer
index|[
name|MAX_REGISTER_RAW_SIZE
index|]
decl_stmt|;
name|char
name|virtual_buffer
index|[
name|MAX_REGISTER_VIRTUAL_SIZE
index|]
decl_stmt|;
name|CORE_ADDR
name|addr
decl_stmt|;
name|value
name|v
init|=
name|allocate_value
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
name|char
modifier|*
name|value_bytes
init|=
literal|0
decl_stmt|;
name|int
name|value_bytes_copied
init|=
literal|0
decl_stmt|;
name|int
name|num_storage_locs
decl_stmt|;
name|VALUE_REGNO
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
name|num_storage_locs
operator|=
operator|(
name|len
operator|>
name|REGISTER_VIRTUAL_SIZE
argument_list|(
name|regnum
argument_list|)
condition|?
operator|(
operator|(
name|len
operator|-
literal|1
operator|)
operator|/
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|)
operator|+
literal|1
else|:
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|num_storage_locs
operator|>
literal|1
condition|)
block|{
comment|/* Value spread across multiple storage locations.  */
name|int
name|local_regnum
decl_stmt|;
name|int
name|mem_stor
init|=
literal|0
decl_stmt|,
name|reg_stor
init|=
literal|0
decl_stmt|;
name|int
name|mem_tracking
init|=
literal|1
decl_stmt|;
name|CORE_ADDR
name|last_addr
init|=
literal|0
decl_stmt|;
name|value_bytes
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|len
operator|+
name|MAX_REGISTER_RAW_SIZE
argument_list|)
expr_stmt|;
comment|/* Copy all of the data out, whereever it may be.  */
for|for
control|(
name|local_regnum
operator|=
name|regnum
init|;
name|value_bytes_copied
operator|<
name|len
condition|;
operator|(
name|value_bytes_copied
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|local_regnum
argument_list|)
operator|,
operator|++
name|local_regnum
operator|)
control|)
block|{
name|int
name|register_index
init|=
name|local_regnum
operator|-
name|regnum
decl_stmt|;
name|addr
operator|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|local_regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|local_regnum
argument_list|)
argument_list|,
name|value_bytes
operator|+
name|value_bytes_copied
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|local_regnum
argument_list|)
argument_list|)
expr_stmt|;
name|reg_stor
operator|++
expr_stmt|;
block|}
else|else
block|{
name|read_memory
argument_list|(
name|addr
argument_list|,
name|value_bytes
operator|+
name|value_bytes_copied
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|local_regnum
argument_list|)
argument_list|)
expr_stmt|;
name|mem_stor
operator|++
expr_stmt|;
name|mem_tracking
operator|=
operator|(
name|mem_tracking
operator|&&
operator|(
name|regnum
operator|==
name|local_regnum
operator|||
name|addr
operator|==
name|last_addr
operator|)
operator|)
expr_stmt|;
block|}
name|last_addr
operator|=
name|addr
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|reg_stor
operator|&&
name|mem_stor
operator|)
operator|||
operator|(
name|mem_stor
operator|&&
operator|!
name|mem_tracking
operator|)
condition|)
comment|/* Mixed storage; all of the hassle we just went through was 	   for some good purpose.  */
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_reg_frame_relative
expr_stmt|;
name|VALUE_FRAME
argument_list|(
name|v
argument_list|)
operator|=
name|FRAME_FP
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|VALUE_FRAME_REGNUM
argument_list|(
name|v
argument_list|)
operator|=
name|regnum
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|mem_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|reg_stor
condition|)
block|{
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_register
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
block|}
else|else
name|fatal
argument_list|(
literal|"value_from_register: Value not stored anywhere!"
argument_list|)
expr_stmt|;
comment|/* Any structure stored in more than one register will always be 	 an inegral number of registers.  Otherwise, you'd need to do 	 some fiddling with the last register copied here for little 	 endian machines.  */
comment|/* Copy into the contents section of the value.  */
name|bcopy
argument_list|(
name|value_bytes
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return
name|v
return|;
block|}
comment|/* Data is completely contained within a single register.  Locate the      register's contents in a real register or in core;      read the data in raw format.  */
name|addr
operator|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|regnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|==
literal|0
condition|)
block|{
comment|/* Value is really in a register.  */
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_register
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
expr_stmt|;
name|read_register_bytes
argument_list|(
name|REGISTER_BYTE
argument_list|(
name|regnum
argument_list|)
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Value was in a register that has been saved in memory.  */
name|read_memory
argument_list|(
name|addr
argument_list|,
name|raw_buffer
argument_list|,
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|VALUE_LVAL
argument_list|(
name|v
argument_list|)
operator|=
name|lval_memory
expr_stmt|;
name|VALUE_ADDRESS
argument_list|(
name|v
argument_list|)
operator|=
name|addr
expr_stmt|;
block|}
comment|/* Convert the raw contents to virtual contents.      (Just copy them if the formats are the same.)  */
name|REGISTER_CONVERT_TO_VIRTUAL
argument_list|(
name|regnum
argument_list|,
name|raw_buffer
argument_list|,
name|virtual_buffer
argument_list|)
expr_stmt|;
if|if
condition|(
name|REGISTER_CONVERTIBLE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* When the raw and virtual formats differ, the virtual format 	 corresponds to a specific data type.  If we want that type, 	 copy the data into the value. 	 Otherwise, do a type-conversion.  */
if|if
condition|(
name|type
operator|!=
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* eg a variable of type `float' in a 68881 register 	     with raw type `extended' and virtual type `double'. 	     Fetch it as a `double' and then convert to `float'.  */
name|v
operator|=
name|allocate_value
argument_list|(
name|REGISTER_VIRTUAL_TYPE
argument_list|(
name|regnum
argument_list|)
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|virtual_buffer
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|v
operator|=
name|value_cast
argument_list|(
name|type
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
else|else
name|bcopy
argument_list|(
name|virtual_buffer
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Raw and virtual formats are the same for this register.  */
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|len
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
condition|)
block|{
comment|/* Big-endian, and we want less than full size.  */
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
operator|=
name|REGISTER_RAW_SIZE
argument_list|(
name|regnum
argument_list|)
operator|-
name|len
expr_stmt|;
block|}
endif|#
directive|endif
name|bcopy
argument_list|(
name|virtual_buffer
operator|+
name|VALUE_OFFSET
argument_list|(
name|v
argument_list|)
argument_list|,
name|VALUE_CONTENTS
argument_list|(
name|v
argument_list|)
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
return|return
name|v
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a struct symbol for a variable,    and a stack frame id,     return a (pointer to a) struct value containing the variable's address.  */
end_comment

begin_function
name|value
name|locate_var_value
parameter_list|(
name|var
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|struct
name|symbol
modifier|*
name|var
decl_stmt|;
name|FRAME
name|frame
decl_stmt|;
block|{
specifier|register
name|CORE_ADDR
name|addr
init|=
literal|0
decl_stmt|;
name|int
name|val
init|=
name|SYMBOL_VALUE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|struct
name|frame_info
modifier|*
name|fi
decl_stmt|;
name|struct
name|type
modifier|*
name|type
init|=
name|SYMBOL_TYPE
argument_list|(
name|var
argument_list|)
decl_stmt|;
name|struct
name|type
modifier|*
name|result_type
decl_stmt|;
if|if
condition|(
name|frame
operator|==
literal|0
condition|)
name|frame
operator|=
name|selected_frame
expr_stmt|;
switch|switch
condition|(
name|SYMBOL_CLASS
argument_list|(
name|var
argument_list|)
condition|)
block|{
case|case
name|LOC_CONST
case|:
case|case
name|LOC_CONST_BYTES
case|:
name|error
argument_list|(
literal|"Address requested for identifier \"%s\" which is a constant."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|LOC_REGISTER
case|:
case|case
name|LOC_REGPARM
case|:
name|addr
operator|=
name|find_saved_register
argument_list|(
name|frame
argument_list|,
name|val
argument_list|)
expr_stmt|;
if|if
condition|(
name|addr
operator|!=
literal|0
condition|)
block|{
name|int
name|len
init|=
name|TYPE_LENGTH
argument_list|(
name|type
argument_list|)
decl_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
if|if
condition|(
name|len
operator|<
name|REGISTER_RAW_SIZE
argument_list|(
name|val
argument_list|)
condition|)
comment|/* Big-endian, and we want less than full size.  */
name|addr
operator|+=
name|REGISTER_RAW_SIZE
argument_list|(
name|val
argument_list|)
operator|-
name|len
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
name|error
argument_list|(
literal|"Address requested for identifier \"%s\" which is in a register."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|LOC_STATIC
case|:
case|case
name|LOC_LABEL
case|:
name|addr
operator|=
name|val
expr_stmt|;
break|break;
case|case
name|LOC_ARG
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|=
name|val
operator|+
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_REF_ARG
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|=
name|val
operator|+
name|FRAME_ARGS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
name|addr
operator|=
name|read_memory_integer
argument_list|(
name|addr
argument_list|,
sizeof|sizeof
argument_list|(
name|CORE_ADDR
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_LOCAL
case|:
name|fi
operator|=
name|get_frame_info
argument_list|(
name|frame
argument_list|)
expr_stmt|;
name|addr
operator|=
name|val
operator|+
name|FRAME_LOCALS_ADDRESS
argument_list|(
name|fi
argument_list|)
expr_stmt|;
break|break;
case|case
name|LOC_TYPEDEF
case|:
name|error
argument_list|(
literal|"Address requested for identifier \"%s\" which is a typedef."
argument_list|,
name|SYMBOL_NAME
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
case|case
name|LOC_BLOCK
case|:
name|addr
operator|=
name|BLOCK_START
argument_list|(
name|SYMBOL_BLOCK_VALUE
argument_list|(
name|var
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Address of an array is of the type of address of it's elements.  */
name|result_type
operator|=
name|lookup_pointer_type
argument_list|(
name|TYPE_CODE
argument_list|(
name|type
argument_list|)
operator|==
name|TYPE_CODE_ARRAY
condition|?
name|TYPE_TARGET_TYPE
argument_list|(
name|type
argument_list|)
else|:
name|type
argument_list|)
expr_stmt|;
return|return
name|value_cast
argument_list|(
name|result_type
argument_list|,
name|value_from_long
argument_list|(
name|builtin_type_long
argument_list|,
operator|(
name|LONGEST
operator|)
name|addr
argument_list|)
argument_list|)
return|;
block|}
end_function

end_unit

