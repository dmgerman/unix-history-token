begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Convert language-specific tree expression to rtl instructions,    for GNU compiler.  Copyright (C) 1988 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"cplus-tree.h"
end_include

begin_include
include|#
directive|include
file|"assert.h"
end_include

begin_function
name|rtx
name|cplus_expand_expr
parameter_list|(
name|exp
parameter_list|,
name|target
parameter_list|,
name|tmode
parameter_list|,
name|modifier
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|rtx
name|target
decl_stmt|;
name|enum
name|machine_mode
name|tmode
decl_stmt|;
name|enum
name|expand_modifier
name|modifier
decl_stmt|;
block|{
specifier|register
name|rtx
name|op0
decl_stmt|,
name|op1
decl_stmt|,
name|temp
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|TYPE_MODE
argument_list|(
name|type
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|rtx
name|original_target
init|=
name|target
decl_stmt|;
name|int
name|ignore
init|=
name|target
operator|==
name|const0_rtx
decl_stmt|;
if|if
condition|(
name|ignore
condition|)
name|target
operator|=
literal|0
operator|,
name|original_target
operator|=
literal|0
expr_stmt|;
comment|/* No sense saving up arithmetic to be done      if it's all in the wrong mode to form part of an address.      And force_operand won't know whether to sign-extend or zero-extend.  */
if|if
condition|(
name|mode
operator|!=
name|Pmode
operator|&&
name|modifier
operator|==
name|EXPAND_SUM
condition|)
name|modifier
operator|=
name|EXPAND_NORMAL
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|CPLUS_NEW_EXPR
case|:
block|{
comment|/* Something needs to be initialized, but we didn't know 	   where that thing was when building the tree.  For example, 	   it could be the return value of a function, or a parameter 	   to a function which lays down in the stack, or a temporary 	   variable which must be passed by reference .  	   Cleanups are handled in a language-specific way: they 	   might be run by the called function (true in GNU C++ 	   for parameters with cleanups), or they might be 	   run by the caller, after the call (true in GNU C++ 	   for other cleanup needs).  */
name|tree
name|func
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|tree
name|args
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|tree
name|type
init|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
decl_stmt|,
name|slot
decl_stmt|;
name|tree
name|fn_type
init|=
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|func
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|return_type
init|=
name|TREE_TYPE
argument_list|(
name|fn_type
argument_list|)
decl_stmt|;
name|rtx
name|call_target
decl_stmt|,
name|return_target
decl_stmt|;
comment|/* The expression `init' wants to initialize what 	   `target' represents.  SLOT holds the slot for TARGET.  */
name|slot
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|==
literal|0
condition|)
block|{
comment|/* Should always be called with a target in BLKmode case.  */
name|assert
argument_list|(
name|mode
operator|!=
name|BLKmode
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
name|target
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
block|}
comment|/* The target the initializer will initialize (CALL_TARGET) 	   must now be directed to initialize the target we are 	   supposed to initialize (TARGET).  The semantics for 	   choosing what CALL_TARGET is is language-specific, 	   as is building the call which will perform the 	   initialization.  It is left here to show the choices that 	   exist for C++.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|func
argument_list|)
operator|==
name|ADDR_EXPR
operator|&&
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|FUNCTION_DECL
operator|&&
name|DECL_CONSTRUCTOR_P
argument_list|(
name|TREE_OPERAND
argument_list|(
name|func
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
name|type
operator|=
name|TYPE_POINTER_TO
argument_list|(
name|type
argument_list|)
expr_stmt|;
name|TREE_VALUE
argument_list|(
name|args
argument_list|)
operator|=
name|build1
argument_list|(
name|ADDR_EXPR
argument_list|,
name|type
argument_list|,
name|slot
argument_list|)
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|type
operator|=
name|return_type
expr_stmt|;
name|call_target
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|call_target
operator|=
name|target
expr_stmt|;
block|}
name|return_target
operator|=
name|expand_expr
argument_list|(
name|build
argument_list|(
name|CALL_EXPR
argument_list|,
name|type
argument_list|,
name|func
argument_list|,
name|args
argument_list|,
literal|0
argument_list|)
argument_list|,
name|call_target
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|call_target
operator|==
literal|0
condition|)
name|call_target
operator|=
name|return_target
expr_stmt|;
elseif|else
if|if
condition|(
name|call_target
operator|!=
name|return_target
condition|)
name|emit_move_insn
argument_list|(
name|call_target
argument_list|,
name|return_target
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|return_type
argument_list|)
operator|==
name|REFERENCE_TYPE
condition|)
block|{
name|tree
name|init
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|call_target
argument_list|)
operator|==
name|REG
operator|&&
name|REGNO
argument_list|(
name|call_target
argument_list|)
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
name|abort
argument_list|()
expr_stmt|;
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|init
operator|=
name|build
argument_list|(
name|RTL_EXPR
argument_list|,
name|return_type
argument_list|,
literal|0
argument_list|,
name|call_target
argument_list|)
expr_stmt|;
comment|/* We got back a reference to the type we want.  Now intialize 	       target with that.  */
name|expand_aggr_init
argument_list|(
name|slot
argument_list|,
name|init
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
operator|!=
name|target
condition|)
name|emit_move_insn
argument_list|(
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
argument_list|,
name|target
argument_list|)
expr_stmt|;
return|return
name|DECL_RTL
argument_list|(
name|slot
argument_list|)
return|;
block|}
default|default:
break|break;
block|}
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* If DECL had its rtl moved from where callers expect it    to be, fix it up.  RESULT is the nominal rtl for the RESULT_DECL,    which may be a pseudo instead of a hard register.  */
end_comment

begin_function
name|void
name|fixup_result_decl
parameter_list|(
name|decl
parameter_list|,
name|result
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|rtx
name|result
decl_stmt|;
block|{
if|if
condition|(
name|REG_P
argument_list|(
name|result
argument_list|)
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|result
argument_list|)
operator|>=
name|FIRST_PSEUDO_REGISTER
condition|)
block|{
name|rtx
name|real_decl_result
decl_stmt|;
ifdef|#
directive|ifdef
name|FUNCTION_OUTGOING_VALUE
name|real_decl_result
operator|=
name|FUNCTION_OUTGOING_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
name|real_decl_result
operator|=
name|FUNCTION_VALUE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|REG_FUNCTION_VALUE_P
argument_list|(
name|real_decl_result
argument_list|)
operator|=
literal|1
expr_stmt|;
name|result
operator|=
name|real_decl_result
expr_stmt|;
block|}
name|emit_move_insn
argument_list|(
name|result
argument_list|,
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
name|emit_insn
argument_list|(
name|gen_rtx
argument_list|(
name|USE
argument_list|,
name|VOIDmode
argument_list|,
name|result
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

