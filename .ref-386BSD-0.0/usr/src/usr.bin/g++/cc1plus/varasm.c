begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Output variables, constants and external declarations, for GNU compiler.    Copyright (C) 1987, 1988, 1989 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* This file handles generation of all the assembler code    *except* the instructions of a function.    This includes declarations of variables and their initial values.     We also output the assembler code for constants stored in memory    and are responsible for combining constants with the same value.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_comment
comment|/* #include<stab.h> */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_include
include|#
directive|include
file|"hard-reg-set.h"
end_include

begin_include
include|#
directive|include
file|"obstack.h"
end_include

begin_define
define|#
directive|define
name|MIN
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)< (b) ? (a) : (b))
end_define

begin_comment
comment|/* File in which assembler code is being written.  */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The (assembler) name of the first globally-visible object output.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|first_global_object_name
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|current_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
modifier|*
name|saveable_obstack
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|obstack
name|permanent_obstack
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|obstack_chunk_alloc
value|xmalloc
end_define

begin_function_decl
specifier|extern
name|int
name|xmalloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Number for making the label on the next    constant that is stored in memory.  */
end_comment

begin_decl_stmt
name|int
name|const_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number for making the label on the next    static variable internal to a function.  */
end_comment

begin_decl_stmt
name|int
name|var_labelno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero if at least one function definition has been seen.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|function_defined
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|asm_out_file
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|compare_constant_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|record_constant_1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_constant_pool
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|assemble_name
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_addressed_constants
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_constant
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_constructor
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SECTIONS
end_ifdef

begin_enum
specifier|static
enum|enum
name|in_section
block|{
name|no_section
block|,
name|in_text
block|,
name|in_data
block|,
name|EXTRA_SECTIONS
block|}
name|in_section
init|=
name|no_section
enum|;
end_enum

begin_else
else|#
directive|else
end_else

begin_enum
specifier|static
enum|enum
name|in_section
block|{
name|no_section
block|,
name|in_text
block|,
name|in_data
block|}
name|in_section
init|=
name|no_section
enum|;
end_enum

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Define functions like text_section for any extra sections.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|EXTRA_SECTION_FUNCTIONS
end_ifdef

begin_function
name|EXTRA_SECTION_FUNCTIONS
endif|#
directive|endif
comment|/* Tell assembler to switch to text section.  */
name|void
name|text_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_text
condition|)
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|TEXT_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_text
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Tell assembler to switch to data section.  */
end_comment

begin_function
name|void
name|data_section
parameter_list|()
block|{
if|if
condition|(
name|in_section
operator|!=
name|in_data
condition|)
block|{
if|if
condition|(
name|flag_shared_data
condition|)
block|{
ifdef|#
directive|ifdef
name|SHARED_SECTION_ASM_OP
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|SHARED_SECTION_ASM_OP
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"%s\n"
argument_list|,
name|DATA_SECTION_ASM_OP
argument_list|)
expr_stmt|;
name|in_section
operator|=
name|in_data
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Determine if we're in the text section. */
end_comment

begin_function
name|int
name|in_text_section
parameter_list|()
block|{
return|return
name|in_section
operator|==
name|in_text
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the rtl to represent a function, for a function definition.    DECL is a FUNCTION_DECL node which describes which function.    The rtl is stored into DECL.  */
end_comment

begin_function
name|void
name|make_function_rtl
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
comment|/* Rename a nested function to avoid conflicts.  */
if|if
condition|(
name|DECL_CONTEXT
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
operator|&&
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|name
init|=
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Record at least one function has been defined.  */
name|function_defined
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Decode an `asm' spec for a declaration as a register name.    Return the register number, or -1 if nothing specified,    or -2 if the name is not a register.  */
end_comment

begin_function
name|int
name|decode_reg_name
parameter_list|(
name|asmspec
parameter_list|)
name|char
modifier|*
name|asmspec
decl_stmt|;
block|{
if|if
condition|(
name|asmspec
operator|!=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
specifier|extern
name|char
modifier|*
name|reg_names
index|[]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|asmspec
argument_list|,
name|reg_names
index|[
name|i
index|]
argument_list|)
condition|)
break|break;
if|if
condition|(
name|i
operator|<
name|FIRST_PSEUDO_REGISTER
condition|)
return|return
name|i
return|;
else|else
return|return
operator|-
literal|2
return|;
block|}
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Create the DECL_RTL for a declaration for a static or external variable    or static or external function.    ASMSPEC, if not 0, is the string which the user specified    as the assembler symbol name.    TOP_LEVEL is nonzero if this is a file-scope variable.     This is never called for PARM_DECL nodes.  */
end_comment

begin_function
name|void
name|make_decl_rtl
parameter_list|(
name|decl
parameter_list|,
name|asmspec
parameter_list|,
name|top_level
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|char
modifier|*
name|asmspec
decl_stmt|;
name|int
name|top_level
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|DECL_ASSEMBLER_NAME
argument_list|(
name|decl
argument_list|)
decl_stmt|;
name|int
name|reg_number
init|=
name|decode_reg_name
argument_list|(
name|asmspec
argument_list|)
decl_stmt|;
if|if
condition|(
name|reg_number
operator|==
operator|-
literal|2
condition|)
block|{
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|strlen
argument_list|(
name|asmspec
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|name
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|strcpy
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|asmspec
argument_list|)
expr_stmt|;
block|}
comment|/* For a duplicate declaration, we can be called twice on the      same DECL node.  Don't alter the RTL already made      unless the old mode is wrong (which can happen when      the previous rtl was made when the type was incomplete).  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|GET_MODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
comment|/* First detect errors in declaring global registers.  */
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|&&
name|reg_number
operator|==
operator|-
literal|1
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name not specified for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|&&
name|reg_number
operator|==
operator|-
literal|2
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"invalid register name for `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reg_number
operator|>=
literal|0
operator|&&
operator|!
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"register name given for non-register variable `%s'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|error
argument_list|(
literal|"function declared `register'"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
operator|&&
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|BLKmode
condition|)
name|error_with_decl
argument_list|(
name|decl
argument_list|,
literal|"data type of `%s' isn't suitable for a register"
argument_list|)
expr_stmt|;
comment|/* Now handle properly declared static register variables.  */
elseif|else
if|if
condition|(
name|TREE_REGDECL
argument_list|(
name|decl
argument_list|)
condition|)
block|{
name|int
name|nregs
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
name|warning
argument_list|(
literal|"ANSI C forbids global register variables"
argument_list|)
expr_stmt|;
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"global register variable has initial value"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fixed_regs
index|[
name|reg_number
index|]
operator|==
literal|0
operator|&&
name|function_defined
operator|&&
name|top_level
condition|)
name|error
argument_list|(
literal|"global register variable follows a function definition"
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_THIS_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|warning
argument_list|(
literal|"volatile register variables don't work as you might wish"
argument_list|)
expr_stmt|;
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|REG
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|reg_number
argument_list|)
expr_stmt|;
if|if
condition|(
name|top_level
condition|)
block|{
comment|/* Make this register fixed, so not usable for anything else.  */
name|nregs
operator|=
name|HARD_REGNO_NREGS
argument_list|(
name|reg_number
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
name|nregs
operator|>
literal|0
condition|)
name|global_regs
index|[
name|reg_number
operator|+
operator|--
name|nregs
index|]
operator|=
literal|1
expr_stmt|;
name|init_reg_sets_1
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now handle ordinary static variables and functions (in memory). 	 Also handle vars declared register invalidly.  */
if|if
condition|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Can't use just the variable's own name for a variable 	     whose scope is less than the whole file. 	     Concatenate a distinguishing number.  */
if|if
condition|(
operator|!
name|top_level
operator|&&
operator|!
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
operator|&&
name|asmspec
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|ASM_FORMAT_PRIVATE_NAME
argument_list|(
name|label
argument_list|,
name|name
argument_list|,
name|var_labelno
argument_list|)
expr_stmt|;
name|name
operator|=
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
name|var_labelno
operator|++
expr_stmt|;
block|}
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|DECL_MODE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|name
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|MEM_VOLATILE_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
condition|)
name|RTX_UNCHANGING_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
name|MEM_IN_STRUCT_P
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|=
operator|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|ARRAY_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
operator|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output a string of literal assembler code    for an `asm' keyword used between functions.  */
end_comment

begin_function
name|void
name|assemble_asm
parameter_list|(
name|string
parameter_list|)
name|tree
name|string
decl_stmt|;
block|{
name|app_enable
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t%s\n"
argument_list|,
name|TREE_STRING_POINTER
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output assembler code for the constant pool of a function and associated    with defining the name of the function.  DECL describes the function.    For the constant pool, we use the current constant pool data.  */
end_comment

begin_function
name|void
name|assemble_function
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|x
decl_stmt|,
name|n
decl_stmt|;
name|char
modifier|*
name|fnname
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* Get the function's name, as described by its RTL.      This may be different from the DECL_NAME name used in the source file.  */
name|x
operator|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|n
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|n
argument_list|)
operator|!=
name|SYMBOL_REF
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fnname
operator|=
name|XSTR
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* The following code does not need preprocessing in the assembler.  */
name|app_disable
argument_list|()
expr_stmt|;
name|output_constant_pool
argument_list|(
name|fnname
argument_list|,
name|decl
argument_list|)
expr_stmt|;
name|text_section
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
comment|/* Make sure types are defined for debugger before fcn name is defined.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_tags
argument_list|(
name|gettags
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Tell assembler to move to target machine's alignment for functions.  */
name|align
operator|=
name|floor_log2
argument_list|(
name|FUNCTION_BOUNDARY
operator|/
name|BITS_PER_UNIT
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|align
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
comment|/* Output SDB definition of the function.  */
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
condition|)
name|sdbout_mark_begin_function
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Make function name accessible from other files, if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_global_object_name
condition|)
name|first_global_object_name
operator|=
name|fnname
expr_stmt|;
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
block|}
comment|/* Do any machine/system dependent processing of the function name */
ifdef|#
directive|ifdef
name|ASM_DECLARE_FUNCTION_NAME
name|ASM_DECLARE_FUNCTION_NAME
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|current_function_decl
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Standard thing is just output label for the function.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* ASM_DECLARE_FUNCTION_NAME */
block|}
end_function

begin_comment
comment|/* Assemble " .int 0\n" or whatever this assembler wants.  */
end_comment

begin_function
name|void
name|assemble_integer_zero
parameter_list|()
block|{
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|const0_rtx
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Assemble a string constant with the specified C string as contents.  */
end_comment

begin_function
name|void
name|assemble_string
parameter_list|(
name|p
parameter_list|,
name|size
parameter_list|)
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|pos
init|=
literal|0
decl_stmt|;
name|int
name|maximum
init|=
literal|2000
decl_stmt|;
comment|/* If the string is very long, split it up.  */
while|while
condition|(
name|pos
operator|<
name|size
condition|)
block|{
name|int
name|thissize
init|=
name|size
operator|-
name|pos
decl_stmt|;
if|if
condition|(
name|thissize
operator|>
name|maximum
condition|)
name|thissize
operator|=
name|maximum
expr_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_ASCII
name|ASM_OUTPUT_ASCII
argument_list|(
name|asm_out_file
argument_list|,
name|p
argument_list|,
name|thissize
argument_list|)
expr_stmt|;
else|#
directive|else
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\t.ascii \""
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|thissize
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|int
name|c
init|=
name|p
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|>=
literal|' '
operator|&&
name|c
operator|<
literal|0177
condition|)
name|putc
argument_list|(
name|c
argument_list|,
name|asm_out_file
argument_list|)
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\\%o"
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* After an octal-escape, if a digit follows, 		 terminate one string constant and start another. 		 The Vax assembler fails to stop reading the escape 		 after three digits, so this is the only way we 		 can get it to parse the data properly.  */
if|if
condition|(
name|i
operator|<
name|thissize
operator|-
literal|1
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|>=
literal|'0'
operator|&&
name|p
index|[
name|i
operator|+
literal|1
index|]
operator|<=
literal|'9'
condition|)
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\"\n\t.ascii \""
argument_list|)
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|asm_out_file
argument_list|,
literal|"\"\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* no ASM_OUTPUT_ASCII */
name|pos
operator|+=
name|thissize
expr_stmt|;
name|p
operator|+=
name|thissize
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Assemble everything that is needed for a variable or function declaration.    Not used for automatic variables, and not used for function definitions.    Should not be called for variables of incomplete structure type.     TOP_LEVEL is nonzero if this variable has file scope.    WRITE_SYMBOLS is DBX_DEBUG if writing dbx symbol output.    The dbx data for a file-scope variable is written here.    AT_END is nonzero if this is the special handling, at end of compilation,    to define things that have had only tentative definitions.  */
end_comment

begin_function
name|void
name|assemble_variable
parameter_list|(
name|decl
parameter_list|,
name|top_level
parameter_list|,
name|write_symbols
parameter_list|,
name|at_end
parameter_list|)
name|tree
name|decl
decl_stmt|;
name|int
name|top_level
decl_stmt|;
name|enum
name|debugger
name|write_symbols
decl_stmt|;
name|int
name|at_end
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* Do nothing for global register variables.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return;
comment|/* Normally no need to say anything for external references,      since assembler considers all undefined symbols external.  */
if|if
condition|(
name|TREE_EXTERNAL
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
comment|/* Output no assembler code for a function declaration.      Only definitions of functions output anything.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|decl
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
return|return;
comment|/* If type was incomplete when the variable was declared,      see if it is complete now.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
name|layout_decl
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Still incomplete => don't allocate it; treat the tentative defn      (which is what it must have been) as an `extern' reference.  */
if|if
condition|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error_with_file_and_line
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|,
name|DECL_SOURCE_LINE
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|"storage size of static var `%s' isn't known"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The first declaration of a variable that comes through this function      decides whether it is global (in C, has external linkage)      or local (in C, has internal linkage).  So do nothing more      if this function has already run.  */
if|if
condition|(
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
condition|)
return|return;
name|TREE_ASM_WRITTEN
argument_list|(
name|decl
argument_list|)
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|DBX_DEBUGGING_INFO
comment|/* File-scope global variables are output here.  */
if|if
condition|(
name|write_symbols
operator|==
name|DBX_DEBUG
operator|&&
name|top_level
condition|)
name|dbxout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SDB_DEBUGGING_INFO
if|if
condition|(
name|write_symbols
operator|==
name|SDB_DEBUG
operator|&&
name|top_level
condition|)
name|sdbout_symbol
argument_list|(
name|decl
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|write_symbols
operator|==
name|GDB_DEBUG
condition|)
comment|/* Make sure the file is known to GDB even if it has no functions.  */
name|set_current_gdbfile
argument_list|(
name|DECL_SOURCE_FILE
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* If storage size is erroneously variable, just continue.      Error message was already made.  */
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
condition|)
return|return;
name|app_disable
argument_list|()
expr_stmt|;
name|name
operator|=
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Handle uninitialized definitions.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
name|error_mark_node
condition|)
block|{
name|int
name|size
init|=
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|decl
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|)
decl_stmt|;
name|int
name|rounded
init|=
name|size
decl_stmt|;
comment|/* Don't allocate zero bytes of common, 	 since that means "undefined external" in the linker.  */
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|rounded
operator|=
literal|1
expr_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits 	 so that each uninitialized object starts on such a boundary.  */
name|rounded
operator|=
operator|(
operator|(
name|rounded
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|flag_shared_data
condition|)
name|data_section
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
condition|)
name|ASM_OUTPUT_COMMON
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Handle initialized definitions.  */
comment|/* First make the assembler name(s) global if appropriate.  */
if|if
condition|(
name|TREE_PUBLIC
argument_list|(
name|decl
argument_list|)
operator|&&
name|DECL_NAME
argument_list|(
name|decl
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|first_global_object_name
operator|&&
operator|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
operator|==
literal|0
operator|||
name|TREE_CODE
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
name|CONSTRUCTOR
operator|||
name|CONSTRUCTOR_ELTS
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
operator|!=
literal|0
operator|)
condition|)
name|first_global_object_name
operator|=
name|name
operator|+
operator|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|)
expr_stmt|;
name|ASM_GLOBALIZE_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|for (d = equivalents; d; d = TREE_CHAIN (d))     {       tree e = TREE_VALUE (d);       if (TREE_PUBLIC (e)&& DECL_NAME (e)) 	ASM_GLOBALIZE_LABEL (asm_out_file, 			     XSTR (XEXP (DECL_RTL (e), 0), 0));     }
endif|#
directive|endif
comment|/* Output any data that we will need to use the address of.  */
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
name|output_addressed_constants
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Switch to the proper section for this data.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|decl
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|TREE_READONLY
argument_list|(
name|decl
argument_list|)
operator|&&
operator|!
name|TREE_VOLATILE
argument_list|(
name|decl
argument_list|)
condition|)
name|text_section
argument_list|()
expr_stmt|;
else|else
name|data_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Output the alignment of this data.  */
ifdef|#
directive|ifdef
name|DATA_ALIGNMENT
comment|/* On some machines, it is good to increase alignment sometimes.  */
name|align
operator|=
name|DATA_ALIGNMENT
argument_list|(
name|decl
argument_list|,
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no DATA_ALIGNMENT */
name|align
operator|=
name|DECL_ALIGN
argument_list|(
name|decl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* DATA_ALIGNMENT */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|align
operator|>=
name|BITS_PER_UNIT
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output the name(s) of this data.  */
name|ASM_OUTPUT_LABEL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|for (d = equivalents; d; d = TREE_CHAIN (d))     {       tree e = TREE_VALUE (d);       ASM_OUTPUT_LABEL (asm_out_file, XSTR (XEXP (DECL_RTL (e), 0), 0));     }
endif|#
directive|endif
if|if
condition|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
condition|)
comment|/* Output the actual data.  */
name|output_constant
argument_list|(
name|DECL_INITIAL
argument_list|(
name|decl
argument_list|)
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
comment|/* Leave space for it.  */
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|decl
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output something to declare an external symbol to the assembler.    (Most assemblers don't need this, so we normally output nothing.)  */
end_comment

begin_function
name|void
name|assemble_external
parameter_list|(
name|decl
parameter_list|)
name|tree
name|decl
decl_stmt|;
block|{
name|rtx
name|rtl
init|=
name|DECL_RTL
argument_list|(
name|decl
argument_list|)
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|rtl
argument_list|)
operator|==
name|MEM
operator|&&
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
ifdef|#
directive|ifdef
name|ASM_OUTPUT_EXTERNAL
comment|/* Some systems do require some output.  */
name|ASM_OUTPUT_EXTERNAL
argument_list|(
name|asm_out_file
argument_list|,
name|decl
argument_list|,
name|XSTR
argument_list|(
name|XEXP
argument_list|(
name|rtl
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_comment
comment|/* Output to FILE a reference to the assembler name of a C-level name NAME.    If NAME starts with a *, the rest of NAME is output verbatim.    Otherwise NAME is transformed in an implementation-defined way    (usually by the addition of an underscore).    Many macros in the tm file are defined to call this function.  */
end_comment

begin_function
name|void
name|assemble_name
parameter_list|(
name|file
parameter_list|,
name|name
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
block|{
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
condition|)
name|fputs
argument_list|(
operator|&
name|name
index|[
literal|1
index|]
argument_list|,
name|file
argument_list|)
expr_stmt|;
else|else
name|ASM_OUTPUT_LABELREF
argument_list|(
name|file
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Allocate SIZE bytes writable static space with a gensym name    and return an RTX to refer to its address.  */
end_comment

begin_function
name|rtx
name|assemble_static_space
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|char
name|name
index|[
literal|12
index|]
decl_stmt|;
name|char
modifier|*
name|namestring
decl_stmt|;
name|rtx
name|x
decl_stmt|;
comment|/* Round size up to multiple of BIGGEST_ALIGNMENT bits      so that each uninitialized object starts on such a boundary.  */
name|int
name|rounded
init|=
operator|(
operator|(
name|size
operator|+
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|-
literal|1
operator|)
operator|/
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|*
operator|(
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
operator|)
operator|)
decl_stmt|;
if|if
condition|(
name|flag_shared_data
condition|)
name|data_section
argument_list|()
expr_stmt|;
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|name
argument_list|,
literal|"LF"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|namestring
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_alloc
argument_list|(
name|saveable_obstack
argument_list|,
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|namestring
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|x
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|namestring
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_LOCAL
argument_list|(
name|asm_out_file
argument_list|,
name|name
argument_list|,
name|size
argument_list|,
name|rounded
argument_list|)
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* Assemble the static constant template for function entry trampolines.    This is done at most once per compilation.    Returns an RTX for the address of the template.  */
end_comment

begin_comment
unit|rtx assemble_trampoline_template () {   char label[256];   char *name;   int align;
comment|/* Write the assembler code to define one.  */
end_comment

begin_comment
unit|align = floor_log2 (FUNCTION_BOUNDARY / BITS_PER_UNIT);   if (align> 0)     ASM_OUTPUT_ALIGN (asm_out_file, align);    ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, "LTRAMP", 0);   TRAMPOLINE_TEMPLATE (asm_out_file);
comment|/* Record the rtl to refer to it.  */
end_comment

begin_endif
unit|ASM_GENERATE_INTERNAL_LABEL (label, "LTRAMP", 0);   name     = (char *) obstack_copy0 (&permanent_obstack, label, strlen (label));   return gen_rtx (SYMBOL_REF, Pmode, name); }
endif|#
directive|endif
end_endif

begin_escape
end_escape

begin_comment
comment|/* Here we combine duplicate floating constants to make    CONST_DOUBLE rtx's, and force those out to memory when necessary.  */
end_comment

begin_comment
comment|/* Chain of all CONST_DOUBLE rtx's constructed for the current function.    They are chained through the CONST_DOUBLE_CHAIN.    A CONST_DOUBLE rtx has CONST_DOUBLE_MEM != cc0_rtx iff it is on this chain.    In that case, CONST_DOUBLE_MEM is either a MEM,    or const0_rtx if no MEM has been made for this CONST_DOUBLE yet.  */
end_comment

begin_decl_stmt
specifier|static
name|rtx
name|real_constant_chain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Return a CONST_DOUBLE for a value specified as a pair of ints.    For an integer, I0 is the low-order word and I1 is the high-order word.    For a real number, I0 is the word with the low address    and I1 is the word with the high address.  */
end_comment

begin_function
name|rtx
name|immed_double_const
parameter_list|(
name|i0
parameter_list|,
name|i1
parameter_list|,
name|mode
parameter_list|)
name|int
name|i0
decl_stmt|,
name|i1
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
specifier|register
name|rtx
name|r
decl_stmt|;
if|if
condition|(
name|mode
operator|==
name|DImode
operator|&&
name|i0
operator|==
literal|0
operator|&&
name|i1
operator|==
literal|0
condition|)
return|return
name|const0_rtx
return|;
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
for|for
control|(
name|r
operator|=
name|real_constant_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
operator|==
name|i0
operator|&&
name|CONST_DOUBLE_HIGH
argument_list|(
name|r
argument_list|)
operator|==
name|i1
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.  */
name|r
operator|=
name|gen_rtx
argument_list|(
name|CONST_DOUBLE
argument_list|,
name|mode
argument_list|,
literal|0
argument_list|,
name|i0
argument_list|,
name|i1
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|real_constant_chain
expr_stmt|;
name|real_constant_chain
operator|=
name|r
expr_stmt|;
comment|/* Store const0_rtx in mem-slot since this CONST_DOUBLE is on the chain.      Actual use of mem-slot is only through force_const_double_mem.  */
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE for a specified `double' value    and machine mode.  */
end_comment

begin_function
name|rtx
name|immed_real_const_1
parameter_list|(
name|d
parameter_list|,
name|mode
parameter_list|)
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
name|union
name|real_extract
name|u
decl_stmt|;
specifier|register
name|rtx
name|r
decl_stmt|;
name|REAL_VALUE_TYPE
name|negated
decl_stmt|;
comment|/* Get the desired `double' value as a sequence of ints      since that is how they are stored in a CONST_DOUBLE.  */
name|u
operator|.
name|d
operator|=
name|d
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Detect special cases.  */
block|if (REAL_VALUES_EQUAL (dconst0, d))     return (mode == DFmode ? dconst0_rtx : fconst0_rtx);   else if (REAL_VALUES_EQUAL (dconst1, d))     return (mode == DFmode ? dconst1_rtx : fconst1_rtx);    if (sizeof u == 2 * sizeof (int))     return immed_double_const (u.i[0], u.i[1], mode);
else|#
directive|else
comment|/* Detect zero.  */
name|negated
operator|=
name|REAL_VALUE_NEGATE
argument_list|(
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|REAL_VALUES_EQUAL
argument_list|(
name|negated
argument_list|,
name|d
argument_list|)
condition|)
return|return
operator|(
name|mode
operator|==
name|DFmode
condition|?
name|dconst0_rtx
else|:
name|fconst0_rtx
operator|)
return|;
if|if
condition|(
sizeof|sizeof
name|u
operator|==
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|)
return|return
name|immed_double_const
argument_list|(
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|,
name|mode
argument_list|)
return|;
endif|#
directive|endif
comment|/* The rest of this function handles the case where      a float value requires more than 2 ints of space.      It will be deleted as dead code on machines that don't need it.  */
comment|/* Search the chain for an existing CONST_DOUBLE with the right value.      If one is found, return it.  */
for|for
control|(
name|r
operator|=
name|real_constant_chain
init|;
name|r
condition|;
name|r
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
control|)
if|if
condition|(
operator|!
name|bcmp
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
operator|&&
name|GET_MODE
argument_list|(
name|r
argument_list|)
operator|==
name|mode
condition|)
return|return
name|r
return|;
comment|/* No; make a new one and add it to the chain.  */
name|r
operator|=
name|rtx_alloc
argument_list|(
name|CONST_DOUBLE
argument_list|)
expr_stmt|;
name|PUT_MODE
argument_list|(
name|r
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|u
argument_list|,
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|r
argument_list|)
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
name|real_constant_chain
expr_stmt|;
name|real_constant_chain
operator|=
name|r
expr_stmt|;
comment|/* Store const0_rtx in slot 2 since this CONST_DOUBLE is on the chain.      Actual use of slot 2 is only through force_const_double_mem.  */
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|const0_rtx
expr_stmt|;
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/* Return a CONST_DOUBLE rtx for a value specified by EXP,    which must be a REAL_CST tree node.  */
end_comment

begin_function
name|rtx
name|immed_real_const
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
name|immed_real_const_1
argument_list|(
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Given a CONST_DOUBLE, cause a constant in memory to be created    (unless we already have one for the same value)    and return a MEM rtx to refer to it.    Put the CONST_DOUBLE on real_constant_chain if it isn't already there.  */
end_comment

begin_function
name|rtx
name|force_const_double_mem
parameter_list|(
name|r
parameter_list|)
name|rtx
name|r
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
argument_list|)
operator|!=
name|MEM
condition|)
name|force_const_mem
argument_list|(
name|GET_MODE
argument_list|(
name|r
argument_list|)
argument_list|,
name|r
argument_list|)
expr_stmt|;
comment|/* CONST_DOUBLE_MEM (r) is now a MEM with a constant address.      If that is legitimate, return it.      Othewise it will need reloading, so return a copy of it.  */
if|if
condition|(
name|memory_address_p
argument_list|(
name|GET_MODE
argument_list|(
name|r
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
return|return
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
return|;
return|return
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|r
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
argument_list|,
literal|0
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* At the end of a function, forget the memory-constants    previously made for CONST_DOUBLEs.  Mark them as not on real_constant_chain.    Also clear out real_constant_chain and clear out all the chain-pointers.  */
end_comment

begin_function
name|void
name|clear_const_double_mem
parameter_list|()
block|{
specifier|register
name|rtx
name|r
decl_stmt|,
name|next
decl_stmt|;
for|for
control|(
name|r
operator|=
name|real_constant_chain
init|;
name|r
condition|;
name|r
operator|=
name|next
control|)
block|{
name|next
operator|=
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|CONST_DOUBLE_CHAIN
argument_list|(
name|r
argument_list|)
operator|=
literal|0
expr_stmt|;
name|CONST_DOUBLE_MEM
argument_list|(
name|r
argument_list|)
operator|=
name|cc0_rtx
expr_stmt|;
block|}
name|real_constant_chain
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given an expression EXP with a constant value,    reduce it to the sum of an assembler symbol and an integer.    Store them both in the structure *VALUE.    Abort if EXP does not reduce.  */
end_comment

begin_struct
struct|struct
name|addr_const
block|{
name|rtx
name|base
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_function
specifier|static
name|void
name|decode_addr_const
parameter_list|(
name|exp
parameter_list|,
name|value
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|addr_const
modifier|*
name|value
decl_stmt|;
block|{
specifier|register
name|tree
name|target
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
specifier|register
name|int
name|offset
init|=
literal|0
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|offset
operator|+=
name|DECL_OFFSET
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|ARRAY_REF
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
operator|||
name|TREE_CODE
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
name|offset
operator|+=
operator|(
operator|(
name|TYPE_SIZE_UNIT
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TYPE_SIZE
argument_list|(
name|TREE_TYPE
argument_list|(
name|target
argument_list|)
argument_list|)
argument_list|)
operator|*
name|TREE_INT_CST_LOW
argument_list|(
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|)
operator|/
name|BITS_PER_UNIT
operator|)
expr_stmt|;
name|target
operator|=
name|TREE_OPERAND
argument_list|(
name|target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|VAR_DECL
operator|||
name|TREE_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|FUNCTION_DECL
condition|)
name|x
operator|=
name|DECL_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|target
argument_list|)
condition|)
name|x
operator|=
name|TREE_CST_RTL
argument_list|(
name|target
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
name|abort
argument_list|()
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|value
operator|->
name|base
operator|=
name|x
expr_stmt|;
name|value
operator|->
name|offset
operator|=
name|offset
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Uniquize all constants that appear in memory.    Each constant in memory thus far output is recorded    in `const_hash_table' with a `struct constant_descriptor'    that contains a polish representation of the value of    the constant.     We cannot store the trees in the hash table    because the trees may be temporary.  */
end_comment

begin_struct
struct|struct
name|constant_descriptor
block|{
name|struct
name|constant_descriptor
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|char
name|contents
index|[
literal|1
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|HASHBITS
value|30
end_define

begin_define
define|#
directive|define
name|MAX_HASH_TABLE
value|1009
end_define

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|const_hash_table
index|[
name|MAX_HASH_TABLE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Compute a hash code for a constant expression.  */
end_comment

begin_function
name|int
name|const_hash
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|,
name|hi
decl_stmt|,
name|i
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|STRING_CST
condition|)
name|p
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
operator|,
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPLEX_CST
condition|)
return|return
name|const_hash
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|*
literal|5
operator|+
name|const_hash
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|tree
name|link
decl_stmt|;
comment|/* For record type, include the type in the hashing. 	 We do not do so for array types 	 because (1) the sizes of the elements are sufficient 	 and (2) distinct array types can have the same constructor.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|hi
operator|=
operator|(
operator|(
name|int
operator|)
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
operator|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
else|else
name|hi
operator|=
literal|5
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|hi
operator|=
operator|(
name|hi
operator|*
literal|603
operator|+
name|const_hash
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
operator|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|value
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
condition|)
return|return
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|9
operator|+
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
elseif|else
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
return|return
name|const_hash
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|*
literal|7
operator|+
literal|2
return|;
comment|/* Compute hashing function */
name|hi
operator|=
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|hi
operator|=
operator|(
operator|(
name|hi
operator|*
literal|613
operator|)
operator|+
call|(
name|unsigned
call|)
argument_list|(
name|p
index|[
name|i
index|]
argument_list|)
operator|)
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Compare a constant expression EXP with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as EXP.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant
parameter_list|(
name|exp
parameter_list|,
name|desc
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
return|return
literal|0
operator|!=
name|compare_constant_1
argument_list|(
name|exp
argument_list|,
name|desc
operator|->
name|contents
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Compare constant expression EXP with a substring P of a constant descriptor.    If they match, return a pointer to the end of the substring matched.    If they do not match, return 0.     Since descriptors are written in polish prefix notation,    this function can be used recursively to test one operand of EXP    against a subdescriptor, and if it succeeds it returns the    address of the subdescriptor for the next operand.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|compare_constant_1
parameter_list|(
name|exp
parameter_list|,
name|p
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
if|if
condition|(
name|code
operator|!=
operator|(
expr|enum
name|tree_code
operator|)
operator|*
name|p
operator|++
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
comment|/* Integer constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
comment|/* Real constants are the same only if the same width of type.  */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|flag_writable_strings
condition|)
return|return
literal|0
return|;
name|strp
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPLEX_CST
condition|)
block|{
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|length
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|length
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|length
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	 For arrays, just verify both constructors are for arrays.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|type
argument_list|,
name|p
argument_list|,
sizeof|sizeof
name|type
argument_list|)
condition|)
return|return
literal|0
return|;
name|p
operator|+=
sizeof|sizeof
name|type
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
if|if
condition|(
operator|(
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|,
name|p
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return
literal|0
return|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|value
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
expr_stmt|;
comment|/* Compare SYMBOL_REF address and offset.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
comment|/* Compare symbol name.  */
name|strp
operator|=
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|strp
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
condition|)
block|{
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|p
operator|=
name|compare_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
name|p
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Construct a constant descriptor for the expression EXP.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|ptr
init|=
literal|0
decl_stmt|;
name|int
name|buf
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|&
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|exp
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|obstack_finish
argument_list|(
operator|&
name|permanent_obstack
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Add a description of constant expression EXP    to the object growing in `permanent_obstack'.    No need to return its address; the caller will get that    from the obstack when the object is complete.  */
end_comment

begin_function
specifier|static
name|void
name|record_constant_1
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
decl_stmt|;
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|code
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
name|INTEGER_CST
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
literal|2
operator|*
sizeof|sizeof
name|TREE_INT_CST_LOW
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|REAL_CST
condition|)
block|{
name|obstack_1grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|TYPE_PRECISION
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|TREE_REAL_CST
operator|(
name|exp
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|STRING_CST
condition|)
block|{
if|if
condition|(
name|flag_writable_strings
condition|)
return|return;
name|strp
operator|=
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|len
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
argument_list|,
sizeof|sizeof
name|TREE_STRING_LENGTH
operator|(
name|exp
operator|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|COMPLEX_CST
condition|)
block|{
name|record_constant_1
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|CONSTRUCTOR
condition|)
block|{
specifier|register
name|tree
name|link
decl_stmt|;
name|int
name|length
init|=
name|list_length
argument_list|(
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|tree
name|type
decl_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|length
argument_list|,
sizeof|sizeof
name|length
argument_list|)
expr_stmt|;
comment|/* For record constructors, insist that the types match. 	 For arrays, just verify both constructors are for arrays.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
condition|)
name|type
operator|=
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|else
name|type
operator|=
literal|0
expr_stmt|;
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|type
argument_list|,
sizeof|sizeof
name|type
argument_list|)
expr_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|record_constant_1
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|ADDR_EXPR
condition|)
block|{
name|struct
name|addr_const
name|value
decl_stmt|;
name|decode_addr_const
argument_list|(
name|exp
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Record the SYMBOL_REF address and the offset.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|value
argument_list|,
sizeof|sizeof
name|value
argument_list|)
expr_stmt|;
comment|/* Record the symbol name.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|,
name|strlen
argument_list|(
name|XSTR
argument_list|(
name|value
operator|.
name|base
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|PLUS_EXPR
operator|||
name|code
operator|==
name|MINUS_EXPR
condition|)
block|{
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|NOP_EXPR
operator|||
name|code
operator|==
name|CONVERT_EXPR
condition|)
block|{
name|record_constant_1
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Record constant contents.  */
name|obstack_grow
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|strp
argument_list|,
name|len
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return the constant-label-string for constant value EXP.    If no constant equal to EXP has yet been output,    define a new label and output assembler code for it.    The const_hash_table records which constants already have label strings.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_or_assign_label
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|,
name|i
decl_stmt|,
name|align
decl_stmt|;
specifier|register
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
comment|/* Make sure any other constants whose addresses appear in EXP      are assigned label numbers.  */
name|output_addressed_constants
argument_list|(
name|exp
argument_list|)
expr_stmt|;
comment|/* Compute hash code of EXP.  Search the descriptors for that hash code      to see if any of them describes EXP.  If yes, the descriptor records      the label number already assigned.  */
name|hash
operator|=
name|const_hash
argument_list|(
name|exp
argument_list|)
operator|%
name|MAX_HASH_TABLE
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant
argument_list|(
name|exp
argument_list|,
name|desc
argument_list|)
condition|)
return|return
name|desc
operator|->
name|label
return|;
comment|/* No constant equal to EXP is known to have been output.      Make a constant descriptor to enter EXP in the hash table.      Assign the label number and record it in the descriptor for      future calls to this function to find.  */
name|desc
operator|=
name|record_constant
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
comment|/* Now output assembler code to define that label      and follow it with the data of EXP.  */
comment|/* First switch to text section, except for writable strings.  */
ifdef|#
directive|ifdef
name|SELECT_SECTION
name|SELECT_SECTION
argument_list|(
name|exp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
operator|)
operator|&&
name|flag_writable_strings
condition|)
name|data_section
argument_list|()
expr_stmt|;
else|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* Align the location counter as required by EXP's data type.  */
ifdef|#
directive|ifdef
name|DATA_ALIGNMENT
name|align
operator|=
name|DATA_ALIGNMENT
argument_list|(
name|exp
argument_list|,
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|align
operator|=
name|TYPE_ALIGN
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|align
operator|>=
name|BITS_PER_UNIT
operator|<<
operator|(
name|i
operator|+
literal|1
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Output the label itself.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of EXP.  */
name|output_constant
argument_list|(
name|exp
argument_list|,
operator|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|?
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
else|:
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|)
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|desc
operator|->
name|label
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
operator|&
name|permanent_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|desc
operator|->
name|label
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing a reference to constant data in memory    for the constant expression EXP.    If assembler code for such a constant has already been output,    return an rtx to refer to it.    Otherwise, output such a constant in memory and generate    an rtx for it.  The TREE_CST_RTL of EXP is set up to point to that rtx.  */
end_comment

begin_function
name|rtx
name|output_constant_def
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
specifier|register
name|rtx
name|def
decl_stmt|;
name|int
name|temp_p
init|=
name|allocation_temporary_p
argument_list|()
decl_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* No TREE_CST_RTL slot in these.  */
if|if
condition|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
condition|)
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
if|if
condition|(
name|TREE_PERMANENT
argument_list|(
name|exp
argument_list|)
condition|)
name|end_temporary_allocation
argument_list|()
expr_stmt|;
name|def
operator|=
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|get_or_assign_label
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
name|def
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|temp_p
operator|&&
name|TREE_PERMANENT
argument_list|(
name|exp
argument_list|)
condition|)
name|resume_temporary_allocation
argument_list|()
expr_stmt|;
return|return
name|TREE_CST_RTL
argument_list|(
name|exp
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Similar hash facility for making memory-constants    from constant rtl-expressions.  It is used on RISC machines    where immediate integer arguments and constant addresses are restricted    so that such constants must be stored in memory.     This pool of constants is reinitialized for each function    so each function gets its own constants-pool that comes right before it.     All structures allocated here are discarded when functions are saved for    inlining, so they do not need to be allocated permanently.  */
end_comment

begin_define
define|#
directive|define
name|MAX_RTX_HASH_TABLE
value|61
end_define

begin_decl_stmt
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|const_rtx_hash_table
index|[
name|MAX_RTX_HASH_TABLE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure to represent sufficient information about a constant so that    it can be output when the constant pool is output, so that function    integration can be done, and to simplify handling on machines that reference    constant pool as base+displacement.  */
end_comment

begin_struct
struct|struct
name|pool_constant
block|{
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|next
decl_stmt|;
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|constant
decl_stmt|;
name|int
name|labelno
decl_stmt|;
name|int
name|align
decl_stmt|;
name|int
name|offset
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Pointers to first and last constant in pool.  */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|pool_constant
modifier|*
name|first_pool
decl_stmt|,
modifier|*
name|last_pool
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current offset in constant pool (does not include any machine-specific    header.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pool_offset
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Structure used to maintain hash table mapping symbols used to their    corresponding constants.  */
end_comment

begin_struct
struct|struct
name|pool_sym
block|{
name|char
modifier|*
name|label
decl_stmt|;
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|struct
name|pool_sym
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|pool_sym
modifier|*
name|const_rtx_sym_hash_table
index|[
name|MAX_RTX_HASH_TABLE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Hash code for a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true.    The argument is XSTR (... , 0)  */
end_comment

begin_define
define|#
directive|define
name|SYMHASH
parameter_list|(
name|LABEL
parameter_list|)
define|\
value|((((int) (LABEL))& ((1<< HASHBITS) - 1))  % MAX_RTX_HASH_TABLE)
end_define

begin_escape
end_escape

begin_comment
comment|/* Initialize constant pool hashing for next function.  */
end_comment

begin_function
name|void
name|init_const_rtx_hash_table
parameter_list|()
block|{
name|bzero
argument_list|(
name|const_rtx_hash_table
argument_list|,
sizeof|sizeof
name|const_rtx_hash_table
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|const_rtx_sym_hash_table
argument_list|,
sizeof|sizeof
name|const_rtx_sym_hash_table
argument_list|)
expr_stmt|;
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
name|pool_offset
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_struct
struct|struct
name|rtx_const
block|{
enum|enum
name|kind
block|{
name|RTX_DOUBLE
block|,
name|RTX_INT
block|}
name|kind
range|:
literal|16
enum|;
name|enum
name|machine_mode
name|mode
range|:
literal|16
decl_stmt|;
union|union
block|{
name|union
name|real_extract
name|du
decl_stmt|;
name|struct
name|addr_const
name|addr
decl_stmt|;
block|}
name|un
union|;
block|}
struct|;
end_struct

begin_comment
comment|/* Express an rtx for a constant integer (perhaps symbolic)    as the sum of a symbol or label plus an explicit integer.    They are stored into VALUE.  */
end_comment

begin_function
specifier|static
name|void
name|decode_rtx_const
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|value
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|rtx_const
modifier|*
name|value
decl_stmt|;
block|{
comment|/* Clear the whole structure, including any gaps.  */
block|{
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|value
decl_stmt|;
name|int
modifier|*
name|end
init|=
operator|(
name|int
operator|*
operator|)
operator|(
name|value
operator|+
literal|1
operator|)
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|end
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
block|}
name|value
operator|->
name|kind
operator|=
name|RTX_INT
expr_stmt|;
comment|/* Most usual kind. */
name|value
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
condition|)
block|{
case|case
name|CONST_DOUBLE
case|:
name|value
operator|->
name|kind
operator|=
name|RTX_DOUBLE
expr_stmt|;
name|value
operator|->
name|mode
operator|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|value
operator|->
name|un
operator|.
name|du
argument_list|,
sizeof|sizeof
name|value
operator|->
name|un
operator|.
name|du
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONST_INT
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|SYMBOL_REF
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|LABEL_REF
case|:
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|x
expr_stmt|;
break|break;
case|case
name|CONST
case|:
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
block|{
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|!=
name|CONST_INT
condition|)
name|abort
argument_list|()
expr_stmt|;
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|offset
operator|=
operator|-
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|->
name|kind
operator|==
name|RTX_INT
operator|&&
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|!=
literal|0
condition|)
switch|switch
condition|(
name|GET_CODE
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|)
condition|)
block|{
case|case
name|SYMBOL_REF
case|:
case|case
name|LABEL_REF
case|:
comment|/* Use the string's address, not the SYMBOL_REF's address, 	   for the sake of addresses of library routines. 	   For a LABEL_REF, compare labels.  */
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
operator|=
name|XEXP
argument_list|(
name|value
operator|->
name|un
operator|.
name|addr
operator|.
name|base
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Compute a hash code for a constant RTL expression.  */
end_comment

begin_function
name|int
name|const_hash_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|hi
decl_stmt|,
name|i
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
comment|/* Compute hashing function */
name|hi
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
condition|;
name|i
operator|++
control|)
name|hi
operator|+=
operator|(
operator|(
name|int
operator|*
operator|)
operator|&
name|value
operator|)
index|[
name|i
index|]
expr_stmt|;
name|hi
operator|&=
operator|(
literal|1
operator|<<
name|HASHBITS
operator|)
operator|-
literal|1
expr_stmt|;
name|hi
operator|%=
name|MAX_RTX_HASH_TABLE
expr_stmt|;
return|return
name|hi
return|;
block|}
end_function

begin_comment
comment|/* Compare a constant rtl object X with a constant-descriptor DESC.    Return 1 if DESC describes a constant with the same value as X.  */
end_comment

begin_function
specifier|static
name|int
name|compare_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|,
name|desc
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
block|{
specifier|register
name|int
modifier|*
name|p
init|=
operator|(
name|int
operator|*
operator|)
name|desc
operator|->
name|contents
decl_stmt|;
specifier|register
name|int
modifier|*
name|strp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|strp
operator|=
operator|(
name|int
operator|*
operator|)
operator|&
name|value
expr_stmt|;
name|len
operator|=
sizeof|sizeof
name|value
operator|/
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
comment|/* Compare constant contents.  */
while|while
condition|(
operator|--
name|len
operator|>=
literal|0
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|strp
operator|++
condition|)
return|return
literal|0
return|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Construct a constant descriptor for the rtl-expression X.    It is up to the caller to enter the descriptor in the hash table.  */
end_comment

begin_function
specifier|static
name|struct
name|constant_descriptor
modifier|*
name|record_constant_rtx
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|struct
name|constant_descriptor
modifier|*
name|ptr
decl_stmt|;
name|char
modifier|*
name|label
decl_stmt|;
name|struct
name|rtx_const
name|value
decl_stmt|;
name|decode_rtx_const
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
operator|&
name|value
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|current_obstack
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|)
expr_stmt|;
name|obstack_grow
argument_list|(
name|current_obstack
argument_list|,
operator|&
name|label
argument_list|,
sizeof|sizeof
name|label
argument_list|)
expr_stmt|;
comment|/* Record constant contents.  */
name|obstack_grow
argument_list|(
name|current_obstack
argument_list|,
operator|&
name|value
argument_list|,
sizeof|sizeof
name|value
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|constant_descriptor
operator|*
operator|)
name|obstack_finish
argument_list|(
name|current_obstack
argument_list|)
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a constant rtx X, make (or find) a memory constant for its value    and return a MEM rtx to refer to it in memory.  */
end_comment

begin_function
name|rtx
name|force_const_mem
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|int
name|hash
decl_stmt|;
specifier|register
name|struct
name|constant_descriptor
modifier|*
name|desc
decl_stmt|;
name|char
name|label
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|found
init|=
literal|0
decl_stmt|;
name|rtx
name|def
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
operator|&&
name|GET_CODE
argument_list|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|MEM
condition|)
return|return
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
return|;
comment|/* Compute hash code of X.  Search the descriptors for that hash code      to see if any of them describes X.  If yes, the descriptor records      the label number already assigned.  */
name|hash
operator|=
name|const_hash_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
for|for
control|(
name|desc
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
init|;
name|desc
condition|;
name|desc
operator|=
name|desc
operator|->
name|next
control|)
if|if
condition|(
name|compare_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|desc
argument_list|)
condition|)
block|{
name|found
operator|=
name|desc
operator|->
name|label
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|found
operator|==
literal|0
condition|)
block|{
specifier|register
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
specifier|register
name|struct
name|pool_sym
modifier|*
name|sym
decl_stmt|;
name|int
name|align
decl_stmt|;
comment|/* No constant equal to X is known to have been output. 	 Make a constant descriptor to enter X in the hash table. 	 Assign the label number and record it in the descriptor for 	 future calls to this function to find.  */
name|desc
operator|=
name|record_constant_rtx
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|desc
operator|->
name|next
operator|=
name|const_rtx_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_hash_table
index|[
name|hash
index|]
operator|=
name|desc
expr_stmt|;
comment|/* Align the location counter as required by EXP's data type.  */
name|align
operator|=
operator|(
name|mode
operator|==
name|VOIDmode
operator|)
condition|?
name|UNITS_PER_WORD
else|:
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|align
operator|>
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
condition|)
name|align
operator|=
name|BIGGEST_ALIGNMENT
operator|/
name|BITS_PER_UNIT
expr_stmt|;
name|pool_offset
operator|+=
name|align
operator|-
literal|1
expr_stmt|;
name|pool_offset
operator|&=
operator|~
operator|(
name|align
operator|-
literal|1
operator|)
expr_stmt|;
comment|/* Allocate a pool constant descriptor, fill it in, and chain it in.  */
name|pool
operator|=
operator|(
expr|struct
name|pool_constant
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_constant
argument_list|)
argument_list|)
expr_stmt|;
name|pool
operator|->
name|desc
operator|=
name|desc
expr_stmt|;
name|pool
operator|->
name|constant
operator|=
name|x
expr_stmt|;
name|pool
operator|->
name|mode
operator|=
name|mode
expr_stmt|;
name|pool
operator|->
name|labelno
operator|=
name|const_labelno
expr_stmt|;
name|pool
operator|->
name|align
operator|=
name|align
expr_stmt|;
name|pool
operator|->
name|offset
operator|=
name|pool_offset
expr_stmt|;
name|pool
operator|->
name|next
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|last_pool
operator|==
literal|0
condition|)
name|first_pool
operator|=
name|pool
expr_stmt|;
else|else
name|last_pool
operator|->
name|next
operator|=
name|pool
expr_stmt|;
name|last_pool
operator|=
name|pool
expr_stmt|;
name|pool_offset
operator|+=
name|GET_MODE_SIZE
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* Create a string containing the label name, in LABEL.  */
name|ASM_GENERATE_INTERNAL_LABEL
argument_list|(
name|label
argument_list|,
literal|"LC"
argument_list|,
name|const_labelno
argument_list|)
expr_stmt|;
operator|++
name|const_labelno
expr_stmt|;
name|desc
operator|->
name|label
operator|=
name|found
operator|=
operator|(
name|char
operator|*
operator|)
name|obstack_copy0
argument_list|(
name|saveable_obstack
argument_list|,
name|label
argument_list|,
name|strlen
argument_list|(
name|label
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Add label to symbol hash table.  */
name|hash
operator|=
name|SYMHASH
argument_list|(
name|found
argument_list|)
expr_stmt|;
name|sym
operator|=
operator|(
expr|struct
name|pool_sym
operator|*
operator|)
name|oballoc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|pool_sym
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|->
name|label
operator|=
name|found
expr_stmt|;
name|sym
operator|->
name|pool
operator|=
name|pool
expr_stmt|;
name|sym
operator|->
name|next
operator|=
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
expr_stmt|;
name|const_rtx_sym_hash_table
index|[
name|hash
index|]
operator|=
name|sym
expr_stmt|;
block|}
comment|/* We have a symbol name; construct the SYMBOL_REF and the MEM.  */
name|def
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|mode
argument_list|,
name|gen_rtx
argument_list|(
name|SYMBOL_REF
argument_list|,
name|Pmode
argument_list|,
name|found
argument_list|)
argument_list|)
expr_stmt|;
name|RTX_UNCHANGING_P
argument_list|(
name|def
argument_list|)
operator|=
literal|1
expr_stmt|;
comment|/* Mark the symbol_ref as belonging to this constants pool.  */
name|CONSTANT_POOL_ADDRESS_P
argument_list|(
name|XEXP
argument_list|(
name|def
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
if|if
condition|(
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
operator|==
name|cc0_rtx
condition|)
block|{
name|CONST_DOUBLE_CHAIN
argument_list|(
name|x
argument_list|)
operator|=
name|real_constant_chain
expr_stmt|;
name|real_constant_chain
operator|=
name|x
expr_stmt|;
block|}
name|CONST_DOUBLE_MEM
argument_list|(
name|x
argument_list|)
operator|=
name|def
expr_stmt|;
block|}
return|return
name|def
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Given a SYMBOL_REF with CONSTANT_POOL_ADDRESS_P true, return a pointer to    the corresponding pool_constant structure.  */
end_comment

begin_function
specifier|static
name|struct
name|pool_constant
modifier|*
name|find_pool_constant
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
name|struct
name|pool_sym
modifier|*
name|sym
decl_stmt|;
name|char
modifier|*
name|label
init|=
name|XSTR
argument_list|(
name|addr
argument_list|,
literal|0
argument_list|)
decl_stmt|;
for|for
control|(
name|sym
operator|=
name|const_rtx_sym_hash_table
index|[
name|SYMHASH
argument_list|(
name|label
argument_list|)
index|]
init|;
name|sym
condition|;
name|sym
operator|=
name|sym
operator|->
name|next
control|)
if|if
condition|(
name|sym
operator|->
name|label
operator|==
name|label
condition|)
return|return
name|sym
operator|->
name|pool
return|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Given a constant pool SYMBOL_REF, return the corresponding constant.  */
end_comment

begin_function
name|rtx
name|get_pool_constant
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|constant
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the mode.  */
end_comment

begin_function
name|enum
name|machine_mode
name|get_pool_mode
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|mode
return|;
block|}
end_function

begin_comment
comment|/* Similar, return the offset in the constant pool.  */
end_comment

begin_function
name|int
name|get_pool_offset
parameter_list|(
name|addr
parameter_list|)
name|rtx
name|addr
decl_stmt|;
block|{
return|return
operator|(
name|find_pool_constant
argument_list|(
name|addr
argument_list|)
operator|)
operator|->
name|offset
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Write all the constants in the constant pool.  */
end_comment

begin_function
name|void
name|output_constant_pool
parameter_list|(
name|fnname
parameter_list|,
name|fndecl
parameter_list|)
name|char
modifier|*
name|fnname
decl_stmt|;
name|tree
name|fndecl
decl_stmt|;
block|{
name|struct
name|pool_constant
modifier|*
name|pool
decl_stmt|;
name|rtx
name|x
decl_stmt|;
ifdef|#
directive|ifdef
name|ASM_OUTPUT_POOL_PROLOGUE
name|ASM_OUTPUT_POOL_PROLOGUE
argument_list|(
name|asm_out_file
argument_list|,
name|fnname
argument_list|,
name|fndecl
argument_list|,
name|pool_offset
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|pool
operator|=
name|first_pool
init|;
name|pool
condition|;
name|pool
operator|=
name|pool
operator|->
name|next
control|)
block|{
name|x
operator|=
name|pool
operator|->
name|constant
expr_stmt|;
comment|/* First switch to correct section.  */
ifdef|#
directive|ifdef
name|SELECT_RTX_SECTION
name|SELECT_RTX_SECTION
argument_list|(
name|pool
operator|->
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
name|text_section
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|pool
operator|->
name|align
operator|>
literal|1
condition|)
name|ASM_OUTPUT_ALIGN
argument_list|(
name|asm_out_file
argument_list|,
name|exact_log2
argument_list|(
name|pool
operator|->
name|align
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the label.  */
name|ASM_OUTPUT_INTERNAL_LABEL
argument_list|(
name|asm_out_file
argument_list|,
literal|"LC"
argument_list|,
name|pool
operator|->
name|labelno
argument_list|)
expr_stmt|;
comment|/* Output the value of the constant itself.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST_DOUBLE
condition|)
block|{
name|union
name|real_extract
name|u
decl_stmt|;
name|bcopy
argument_list|(
operator|&
name|CONST_DOUBLE_LOW
argument_list|(
name|x
argument_list|)
argument_list|,
operator|&
name|u
argument_list|,
sizeof|sizeof
name|u
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pool
operator|->
name|mode
condition|)
block|{
comment|/* Perhaps change the following to use 		 CONST_DOUBLE_LOW and CONST_DOUBLE_HIGH, rather than u.i.  */
case|case
name|DImode
case|:
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DOUBLE_INT
name|ASM_OUTPUT_DOUBLE_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* no ASM_OUTPUT_DOUBLE_INT */
ifndef|#
directive|ifndef
name|WORDS_BIG_ENDIAN
comment|/* Output two ints.  */
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Output two ints.  */
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|u
operator|.
name|i
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|u
operator|.
name|i
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* WORDS_BIG_ENDIAN */
endif|#
directive|endif
comment|/* no ASM_OUTPUT_DOUBLE_INT */
break|break;
case|case
name|DFmode
case|:
name|ASM_OUTPUT_DOUBLE
argument_list|(
name|asm_out_file
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
break|break;
case|case
name|SFmode
case|:
name|ASM_OUTPUT_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|u
operator|.
name|d
argument_list|)
expr_stmt|;
block|}
block|}
else|else
switch|switch
condition|(
name|pool
operator|->
name|mode
condition|)
block|{
case|case
name|SImode
case|:
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|HImode
case|:
name|ASM_OUTPUT_SHORT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
case|case
name|QImode
case|:
name|ASM_OUTPUT_CHAR
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Done with this pool.  */
name|first_pool
operator|=
name|last_pool
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Find all the constants whose addresses are referenced inside of EXP,    and make sure assembler code with a label has been output for each one.  */
end_comment

begin_function
name|void
name|output_addressed_constants
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
switch|switch
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
condition|)
block|{
case|case
name|ADDR_EXPR
case|:
block|{
specifier|register
name|tree
name|constant
init|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|TREE_CODE
argument_list|(
name|constant
argument_list|)
operator|==
name|COMPONENT_REF
condition|)
block|{
name|constant
operator|=
name|TREE_OPERAND
argument_list|(
name|constant
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|TREE_LITERAL
argument_list|(
name|constant
argument_list|)
condition|)
comment|/* No need to do anything here 	     for addresses of variables or functions.  */
name|output_constant_def
argument_list|(
name|constant
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PLUS_EXPR
case|:
case|case
name|MINUS_EXPR
case|:
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|NOP_EXPR
case|:
case|case
name|CONVERT_EXPR
case|:
name|output_addressed_constants
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|CONSTRUCTOR
case|:
block|{
specifier|register
name|tree
name|link
decl_stmt|;
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
control|)
name|output_addressed_constants
argument_list|(
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ERROR_MARK
case|:
break|break;
default|default:
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|exp
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Output assembler code for constant EXP to FILE, with no label.    This includes the pseudo-op such as ".int" or ".byte", and a newline.    Assumes output_addressed_constants has been done on EXP already.     Generate exactly SIZE bytes of assembler data, padding at the end    with zeros if necessary.  SIZE must always be specified.     SIZE is important for structure constructors,    since trailing members may have been omitted from the constructor.    It is also important for initialization of arrays from string constants    since the full length of the string constant might not be wanted.    It is also needed for initialization of unions, where the initializer's    type is just one member, and that may not be as long as the union.     There a case in which we would fail to output exactly SIZE bytes:    for a structure constructor that wants to produce more than SIZE bytes.    But such constructors will never be generated for any possible input.  */
end_comment

begin_function
name|void
name|output_constant
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
specifier|register
name|tree
name|exp
decl_stmt|;
specifier|register
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|enum
name|tree_code
name|code
init|=
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
decl_stmt|;
name|rtx
name|x
decl_stmt|;
if|if
condition|(
name|size
operator|==
literal|0
condition|)
return|return;
comment|/* Eliminate the NOP_EXPR that makes a cast not be an lvalue.      That way we get the constant (we hope) inside it.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|INTEGER_TYPE
case|:
case|case
name|ENUMERAL_TYPE
case|:
case|case
name|POINTER_TYPE
case|:
case|case
name|REFERENCE_TYPE
case|:
while|while
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|NOP_EXPR
operator|||
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONVERT_EXPR
condition|)
name|exp
operator|=
name|TREE_OPERAND
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|ASM_OUTPUT_DOUBLE_INT
if|if
condition|(
name|TYPE_MODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|DImode
condition|)
block|{
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|INTEGER_CST
condition|)
block|{
ifndef|#
directive|ifndef
name|WORDS_BIG_ENDIAN
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_HIGH
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|TREE_INT_CST_LOW
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|size
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
name|error
argument_list|(
literal|"8-byte integer constant expression too complicated"
argument_list|)
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* no ASM_OUTPUT_DOUBLE_INT */
name|x
operator|=
name|expand_expr
argument_list|(
name|exp
argument_list|,
literal|0
argument_list|,
name|VOIDmode
argument_list|,
name|EXPAND_SUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|==
name|GET_MODE_SIZE
argument_list|(
name|QImode
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_CHAR
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|size
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|QImode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_SHORT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|size
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|HImode
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|size
operator|==
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|size
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|SImode
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|ASM_OUTPUT_DOUBLE_INT
elseif|else
if|if
condition|(
name|size
operator|==
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_DOUBLE_INT
argument_list|(
name|asm_out_file
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|size
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|DImode
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ASM_OUTPUT_DOUBLE_INT */
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|REAL_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|!=
name|REAL_CST
condition|)
name|error
argument_list|(
literal|"initializer for floating value is not a floating constant"
argument_list|)
expr_stmt|;
else|else
block|{
name|REAL_VALUE_TYPE
name|d
decl_stmt|;
name|jmp_buf
name|output_constant_handler
decl_stmt|;
name|d
operator|=
name|TREE_REAL_CST
argument_list|(
name|exp
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|output_constant_handler
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"floating point trap outputting a constant"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|REAL_IS_NOT_DOUBLE
name|bzero
argument_list|(
operator|&
name|d
argument_list|,
sizeof|sizeof
name|d
argument_list|)
expr_stmt|;
name|d
operator|=
name|REAL_VALUE_ATOF
argument_list|(
literal|"0"
argument_list|)
expr_stmt|;
else|#
directive|else
name|d
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
block|}
name|set_float_handler
argument_list|(
name|output_constant_handler
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
name|GET_MODE_SIZE
argument_list|(
name|SFmode
argument_list|)
condition|)
break|break;
elseif|else
if|if
condition|(
name|size
operator|<
name|GET_MODE_SIZE
argument_list|(
name|DFmode
argument_list|)
condition|)
block|{
name|ASM_OUTPUT_FLOAT
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|size
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|SFmode
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ASM_OUTPUT_DOUBLE
argument_list|(
name|asm_out_file
argument_list|,
name|d
argument_list|)
expr_stmt|;
name|size
operator|-=
name|GET_MODE_SIZE
argument_list|(
name|DFmode
argument_list|)
expr_stmt|;
block|}
name|set_float_handler
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|COMPLEX_TYPE
case|:
name|output_constant
argument_list|(
name|TREE_REALPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|output_constant
argument_list|(
name|TREE_IMAGPART
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
operator|/
literal|2
argument_list|)
expr_stmt|;
name|size
operator|-=
operator|(
name|size
operator|/
literal|2
operator|)
operator|*
literal|2
expr_stmt|;
break|break;
case|case
name|ARRAY_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
block|{
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|STRING_CST
condition|)
block|{
name|int
name|excess
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|size
operator|>
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
condition|)
block|{
name|excess
operator|=
name|size
operator|-
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
name|size
operator|=
name|TREE_STRING_LENGTH
argument_list|(
name|exp
argument_list|)
expr_stmt|;
block|}
name|assemble_string
argument_list|(
name|TREE_STRING_POINTER
argument_list|(
name|exp
argument_list|)
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|size
operator|=
name|excess
expr_stmt|;
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
break|break;
case|case
name|RECORD_TYPE
case|:
case|case
name|UNION_TYPE
case|:
if|if
condition|(
name|TREE_CODE
argument_list|(
name|exp
argument_list|)
operator|==
name|CONSTRUCTOR
condition|)
name|output_constructor
argument_list|(
name|exp
argument_list|,
name|size
argument_list|)
expr_stmt|;
else|else
name|abort
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|size
operator|>
literal|0
condition|)
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Subroutine of output_constant, used for CONSTRUCTORs    (aggregate constants).    Generate at least SIZE bytes, padding if necessary.  */
end_comment

begin_function
name|void
name|output_constructor
parameter_list|(
name|exp
parameter_list|,
name|size
parameter_list|)
name|tree
name|exp
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|register
name|tree
name|link
decl_stmt|,
name|field
init|=
literal|0
decl_stmt|;
comment|/* Number of bytes output or skipped so far.      In other words, current position within the constructor.  */
name|int
name|total_bytes
init|=
literal|0
decl_stmt|;
comment|/* Non-zero means BYTE contains part of a byte, to be output.  */
name|int
name|byte_buffer_in_use
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|byte
decl_stmt|;
if|if
condition|(
name|HOST_BITS_PER_INT
operator|<
name|BITS_PER_UNIT
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|RECORD_TYPE
operator|||
name|TREE_CODE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
operator|==
name|UNION_TYPE
condition|)
name|field
operator|=
name|TYPE_FIELDS
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
expr_stmt|;
comment|/* As LINK goes through the elements of the constant,      FIELD goes through the structure fields, if the constant is a structure.      But the constant could also be an array.  Then FIELD is zero.  */
for|for
control|(
name|link
operator|=
name|CONSTRUCTOR_ELTS
argument_list|(
name|exp
argument_list|)
init|;
name|link
condition|;
name|link
operator|=
name|TREE_CHAIN
argument_list|(
name|link
argument_list|)
operator|,
name|field
operator|=
name|field
condition|?
name|TREE_CHAIN
argument_list|(
name|field
argument_list|)
else|:
literal|0
control|)
block|{
name|tree
name|val
init|=
name|TREE_VALUE
argument_list|(
name|link
argument_list|)
decl_stmt|;
comment|/* Eliminate the NOP_EXPR that makes a cast not be an lvalue.  */
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|==
name|NOP_EXPR
operator|&&
name|TREE_TYPE
argument_list|(
name|val
argument_list|)
operator|==
name|TREE_TYPE
argument_list|(
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
name|val
operator|=
name|TREE_OPERAND
argument_list|(
name|val
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|field
operator|==
literal|0
operator|||
operator|(
name|DECL_MODE
argument_list|(
name|field
argument_list|)
operator|!=
name|BImode
operator|)
condition|)
block|{
specifier|register
name|int
name|fieldsize
decl_stmt|;
comment|/* An element that is not a bit-field. 	     Output any buffered-up bit-fields preceding it.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Advance to offset of this element. 	     Note no alignment needed in an array, since that is guaranteed 	     if each element has the proper size.  */
if|if
condition|(
name|field
operator|!=
literal|0
operator|&&
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
operator|(
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_UNIT
operator|-
name|total_bytes
operator|)
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
comment|/* Determine size this element should occupy.  */
if|if
condition|(
name|field
condition|)
block|{
if|if
condition|(
operator|!
name|TREE_LITERAL
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
condition|)
name|abort
argument_list|()
expr_stmt|;
name|fieldsize
operator|=
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
expr_stmt|;
name|fieldsize
operator|=
operator|(
name|fieldsize
operator|+
name|BITS_PER_UNIT
operator|-
literal|1
operator|)
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
else|else
name|fieldsize
operator|=
name|int_size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Output the element's initial value.  */
name|output_constant
argument_list|(
name|val
argument_list|,
name|fieldsize
argument_list|)
expr_stmt|;
comment|/* Count its size.  */
name|total_bytes
operator|+=
name|fieldsize
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|TREE_CODE
argument_list|(
name|val
argument_list|)
operator|!=
name|INTEGER_CST
condition|)
name|error
argument_list|(
literal|"invalid initial value for member `%s'"
argument_list|,
name|IDENTIFIER_POINTER
argument_list|(
name|DECL_NAME
argument_list|(
name|field
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Element that is a bit-field.  */
name|int
name|next_offset
init|=
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
decl_stmt|;
name|int
name|end_offset
init|=
operator|(
name|next_offset
operator|+
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|DECL_SIZE
argument_list|(
name|field
argument_list|)
argument_list|)
operator|*
name|DECL_SIZE_UNIT
argument_list|(
name|field
argument_list|)
operator|)
operator|)
decl_stmt|;
comment|/* If this field does not start in this (or, next) byte, 	     skip some bytes.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
comment|/* Output remnant of any bit field in previous bytes.  */
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|0
expr_stmt|;
block|}
comment|/* If still not at proper byte, advance to there.  */
if|if
condition|(
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|!=
name|total_bytes
condition|)
block|{
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|next_offset
operator|/
name|BITS_PER_UNIT
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
name|total_bytes
operator|=
name|next_offset
operator|/
name|BITS_PER_UNIT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|byte_buffer_in_use
condition|)
name|byte
operator|=
literal|0
expr_stmt|;
comment|/* We must split the element into pieces that fall within 	     separate bytes, and combine each byte with previous or 	     following bit-fields.  */
comment|/* next_offset is the offset n fbits from the begining of 	     the structure to the next bit of this element to be processed. 	     end_offset is the offset of the first bit past the end of 	     this element.  */
while|while
condition|(
name|next_offset
operator|<
name|end_offset
condition|)
block|{
name|int
name|this_time
decl_stmt|;
name|int
name|next_byte
init|=
name|next_offset
operator|/
name|BITS_PER_UNIT
decl_stmt|;
name|int
name|next_bit
init|=
name|next_offset
operator|%
name|BITS_PER_UNIT
decl_stmt|;
comment|/* Advance from byte to byte 		 within this element when necessary.  */
while|while
condition|(
name|next_byte
operator|!=
name|total_bytes
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
name|byte
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Number of bits we can process at once 		 (all part of the same byte).  */
name|this_time
operator|=
name|MIN
argument_list|(
name|end_offset
operator|-
name|next_offset
argument_list|,
name|BITS_PER_UNIT
operator|-
name|next_bit
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BYTES_BIG_ENDIAN
comment|/* On big-endian machine, take the most significant bits 		 first (of the bits that are significant) 		 and put them into bytes from the most significant end.  */
name|byte
operator||=
operator|(
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|>>
operator|(
name|end_offset
operator|-
name|next_offset
operator|-
name|this_time
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|this_time
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
operator|(
name|BITS_PER_UNIT
operator|-
name|this_time
operator|-
name|next_bit
operator|)
operator|)
expr_stmt|;
else|#
directive|else
comment|/* On little-endian machines, 		 take first the least significant bits of the value 		 and pack them starting at the least significant 		 bits of the bytes.  */
name|byte
operator||=
operator|(
operator|(
name|TREE_INT_CST_LOW
argument_list|(
name|val
argument_list|)
operator|>>
operator|(
name|next_offset
operator|-
name|DECL_OFFSET
argument_list|(
name|field
argument_list|)
operator|)
operator|)
operator|&
operator|(
operator|(
literal|1
operator|<<
name|this_time
operator|)
operator|-
literal|1
operator|)
operator|)
operator|<<
name|next_bit
expr_stmt|;
endif|#
directive|endif
name|next_offset
operator|+=
name|this_time
expr_stmt|;
name|byte_buffer_in_use
operator|=
literal|1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|byte_buffer_in_use
condition|)
block|{
name|ASM_OUTPUT_BYTE
argument_list|(
name|asm_out_file
argument_list|,
name|byte
argument_list|)
expr_stmt|;
name|total_bytes
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|total_bytes
operator|<
name|size
condition|)
name|ASM_OUTPUT_SKIP
argument_list|(
name|asm_out_file
argument_list|,
name|size
operator|-
name|total_bytes
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

