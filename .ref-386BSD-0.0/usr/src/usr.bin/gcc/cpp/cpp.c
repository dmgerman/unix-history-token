begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * This code is derived from software copyrighted by the Free Software  * Foundation.  *  * Modified 1991 by Donn Seeley at UUNET Technologies, Inc.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)cpp.c	6.3 (Berkeley) 5/8/91"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* C Compatible Compiler Preprocessor (CCCP) Copyright (C) 1986, 1987, 1989 Free Software Foundation, Inc.                     Written by Paul Rubin, June 1986 		    Adapted to ANSI C, Richard Stallman, Jan 1987  This program is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with this program; if not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.   In other words, you are welcome to use, share and improve this program.  You are forbidden to forbid anyone else to use, share and improve  what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_escape
end_escape

begin_typedef
typedef|typedef
name|unsigned
name|char
name|U_CHAR
typedef|;
end_typedef

begin_ifdef
ifdef|#
directive|ifdef
name|EMACS
end_ifdef

begin_define
define|#
directive|define
name|NO_SHORTNAMES
end_define

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|open
end_ifdef

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* open */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* EMACS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|EMACS
end_ifndef

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not EMACS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|STDC_VALUE
end_ifndef

begin_define
define|#
directive|define
name|STDC_VALUE
value|1
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* In case config.h defines these.  */
end_comment

begin_undef
undef|#
directive|undef
name|bcopy
end_undef

begin_undef
undef|#
directive|undef
name|bzero
end_undef

begin_undef
undef|#
directive|undef
name|bcmp
end_undef

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|VMS
end_ifndef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_comment
comment|/* for __DATE__ and __TIME__ */
end_comment

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|index
value|strchr
end_define

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not VMS */
end_comment

begin_comment
comment|/* VMS-specific definitions */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/* This defines "errno" properly */
end_comment

begin_include
include|#
directive|include
file|<perror.h>
end_include

begin_comment
comment|/* This defines sys_errlist/sys_nerr properly */
end_comment

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_comment
comment|/* Open arg for Read/Only  */
end_comment

begin_define
define|#
directive|define
name|O_WRONLY
value|1
end_define

begin_comment
comment|/* Open arg for Write/Only */
end_comment

begin_define
define|#
directive|define
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
value|VAX11_C_read(fd,buf,size)
end_define

begin_define
define|#
directive|define
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
value|VAX11_C_write(fd,buf,size)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_define
define|#
directive|define
name|BSTRING
end_define

begin_comment
comment|/* VMS/GCC supplies the bstring routines */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __GNUC__ */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|O_RDONLY
end_ifndef

begin_define
define|#
directive|define
name|O_RDONLY
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|max
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a)> (b) ? (a) : (b))
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|S_ISREG
end_ifndef

begin_define
define|#
directive|define
name|S_ISREG
parameter_list|(
name|m
parameter_list|)
value|(((m)& S_IFMT) == S_IFREG)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* External declarations.  */
end_comment

begin_decl_stmt
name|void
name|bcopy
argument_list|()
decl_stmt|,
name|bzero
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
name|bcmp
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|version_string
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Forward declarations.  */
end_comment

begin_struct_decl
struct_decl|struct
name|directive
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|file_buf
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|arglist
struct_decl|;
end_struct_decl

begin_struct_decl
struct_decl|struct
name|argdata
struct_decl|;
end_struct_decl

begin_decl_stmt
name|int
name|do_define
argument_list|()
decl_stmt|,
name|do_line
argument_list|()
decl_stmt|,
name|do_include
argument_list|()
decl_stmt|,
name|do_undef
argument_list|()
decl_stmt|,
name|do_error
argument_list|()
decl_stmt|,
name|do_pragma
argument_list|()
decl_stmt|,
name|do_if
argument_list|()
decl_stmt|,
name|do_xifdef
argument_list|()
decl_stmt|,
name|do_else
argument_list|()
decl_stmt|,
name|do_elif
argument_list|()
decl_stmt|,
name|do_endif
argument_list|()
decl_stmt|,
name|do_sccs
argument_list|()
decl_stmt|,
name|do_once
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|struct
name|hashnode
modifier|*
name|install
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|hashnode
modifier|*
name|lookup
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|xmalloc
argument_list|()
decl_stmt|,
modifier|*
name|xrealloc
argument_list|()
decl_stmt|,
modifier|*
name|xcalloc
argument_list|()
decl_stmt|,
modifier|*
name|savestring
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|fatal
argument_list|()
decl_stmt|,
name|fancy_abort
argument_list|()
decl_stmt|,
name|pfatal_with_name
argument_list|()
decl_stmt|,
name|perror_with_name
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|macroexpand
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|dump_all_macros
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|conditional_skip
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|skip_if_group
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|output_line_command
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Last arg to output_line_command.  */
end_comment

begin_enum
enum|enum
name|file_change_code
block|{
name|same_file
block|,
name|enter_file
block|,
name|leave_file
block|}
enum|;
end_enum

begin_function_decl
name|int
name|grow_outbuf
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|int
name|handle_directive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|memory_full
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|U_CHAR
modifier|*
name|macarg1
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|macarg
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|U_CHAR
modifier|*
name|skip_quoted_string
parameter_list|()
function_decl|;
end_function_decl

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|FATAL_EXIT_CODE
end_ifndef

begin_define
define|#
directive|define
name|FATAL_EXIT_CODE
value|33
end_define

begin_comment
comment|/* gnu cc command understands this */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SUCCESS_EXIT_CODE
end_ifndef

begin_define
define|#
directive|define
name|SUCCESS_EXIT_CODE
value|0
end_define

begin_comment
comment|/* 0 means success on Unix.  */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Name under which this program was invoked.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means handle C++ comment syntax and use    extra default include directories for C++.  */
end_comment

begin_decl_stmt
name|int
name|cplusplus
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current maximum length of directory names in the search path    for include files.  (Altered as we get more of them.)  */
end_comment

begin_decl_stmt
name|int
name|max_include_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means copy comments into the output file.  */
end_comment

begin_decl_stmt
name|int
name|put_out_comments
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't process the ANSI trigraph sequences.  */
end_comment

begin_decl_stmt
name|int
name|no_trigraphs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means print the names of included files rather than    the preprocessed output.  1 means just the #include "...",    2 means #include<...> as well.  */
end_comment

begin_decl_stmt
name|int
name|print_deps
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't output line number information.  */
end_comment

begin_decl_stmt
name|int
name|no_line_commands
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means inhibit output of the preprocessed text    and instead output the definitions of all user-defined macros    in a form suitable for use as input to cccp.  */
end_comment

begin_decl_stmt
name|int
name|dump_macros
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means give all the error messages the ANSI standard requires.  */
end_comment

begin_decl_stmt
name|int
name|pedantic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means don't print warning messages.  -w.  */
end_comment

begin_decl_stmt
name|int
name|inhibit_warnings
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if slash-star appears in a comment.  */
end_comment

begin_decl_stmt
name|int
name|warn_comments
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means warn if there are any trigraphs.  */
end_comment

begin_decl_stmt
name|int
name|warn_trigraphs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means try to imitate old fashioned non-ANSI preprocessor.  */
end_comment

begin_decl_stmt
name|int
name|traditional
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero causes output not to be done,    but directives such as #define that have side effects    are still obeyed.  */
end_comment

begin_decl_stmt
name|int
name|no_output
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* I/O buffer structure.    The `fname' field is nonzero for source files and #include files    and for the dummy text used for -D and -U.    It is zero for rescanning results of macro expansion    and for expanding macro arguments.  */
end_comment

begin_define
define|#
directive|define
name|INPUT_STACK_MAX
value|200
end_define

begin_struct
struct|struct
name|file_buf
block|{
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|lineno
decl_stmt|;
name|int
name|length
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
comment|/* Macro that this level is the expansion of.      Included so that we can reenable the macro      at the end of this level.  */
name|struct
name|hashnode
modifier|*
name|macro
decl_stmt|;
comment|/* Value of if_stack at start of this file.      Used to prohibit unmatched #endif (etc) in an include file.  */
name|struct
name|if_stack
modifier|*
name|if_stack
decl_stmt|;
comment|/* Object to be freed at end of input at this level.  */
name|U_CHAR
modifier|*
name|free_ptr
decl_stmt|;
block|}
name|instack
index|[
name|INPUT_STACK_MAX
index|]
struct|;
end_struct

begin_comment
comment|/* Current nesting level of input sources.    `instack[indepth]' is the level currently being read.  */
end_comment

begin_decl_stmt
name|int
name|indepth
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK_DEPTH
parameter_list|(
name|code
parameter_list|)
define|\
value|if (indepth>= (INPUT_STACK_MAX - 1))					\     {									\       error_with_line (line_for_error (instack[indepth].lineno),	\ 		       "macro or #include recursion too deep");		\       code;								\     }
end_define

begin_comment
comment|/* Current depth in #include directives that use<...>.  */
end_comment

begin_decl_stmt
name|int
name|system_include_depth
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_typedef
typedef|typedef
name|struct
name|file_buf
name|FILE_BUF
typedef|;
end_typedef

begin_comment
comment|/* The output buffer.  Its LENGTH field is the amount of room allocated    for the buffer, not the number of chars actually present.  To get    that, subtract outbuf.buf from outbuf.bufp. */
end_comment

begin_define
define|#
directive|define
name|OUTBUF_SIZE
value|10
end_define

begin_comment
comment|/* initial size of output buffer */
end_comment

begin_decl_stmt
name|FILE_BUF
name|outbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Grow output buffer OBUF points at    so it can hold at least NEEDED more chars.  */
end_comment

begin_define
define|#
directive|define
name|check_expand
parameter_list|(
name|OBUF
parameter_list|,
name|NEEDED
parameter_list|)
define|\
value|(((OBUF)->length - ((OBUF)->bufp - (OBUF)->buf)<= (NEEDED))   \    ? grow_outbuf ((OBUF), (NEEDED)) : 0)
end_define

begin_struct
struct|struct
name|file_name_list
block|{
name|struct
name|file_name_list
modifier|*
name|next
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* #include "file" looks in source file dir, then stack. */
end_comment

begin_comment
comment|/* #include<file> just looks in the stack. */
end_comment

begin_comment
comment|/* -I directories are added to the end, then the defaults are added. */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
name|include_defaults
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|VMS
block|{
operator|&
name|include_defaults
index|[
literal|1
index|]
block|,
name|GCC_INCLUDE_DIR
block|}
block|,
block|{
operator|&
name|include_defaults
index|[
literal|2
index|]
block|,
literal|"/usr/include"
block|}
block|,
block|{
literal|0
block|,
literal|"/usr/local/include"
block|}
else|#
directive|else
block|{
operator|&
name|include_defaults
index|[
literal|1
index|]
block|,
literal|"GNU_CC_INCLUDE:"
block|}
block|,
comment|/* GNU includes */
block|{
operator|&
name|include_defaults
index|[
literal|2
index|]
block|,
literal|"SYS$SYSROOT:[SYSLIB.]"
block|}
block|,
comment|/* VAX-11 "C" includes */
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* This makes normal VMS filespecs work OK */
endif|#
directive|endif
comment|/* VMS */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* These are used instead of the above, for C++.  */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
name|cplusplus_include_defaults
index|[]
init|=
block|{
ifndef|#
directive|ifndef
name|VMS
comment|/* Pick up GNU C++ specific include files.  */
block|{
operator|&
name|cplusplus_include_defaults
index|[
literal|1
index|]
block|,
name|GPLUSPLUS_INCLUDE_DIR
block|}
block|,
comment|/* Use GNU CC specific header files.  */
block|{
operator|&
name|cplusplus_include_defaults
index|[
literal|2
index|]
block|,
name|GCC_INCLUDE_DIR
block|}
block|,
block|{
literal|0
block|,
literal|"/usr/include"
block|}
else|#
directive|else
block|{
operator|&
name|cplusplus_include_defaults
index|[
literal|1
index|]
block|,
literal|"GNU_GXX_INCLUDE:"
block|}
block|,
block|{
operator|&
name|cplusplus_include_defaults
index|[
literal|2
index|]
block|,
literal|"GNU_CC_INCLUDE:"
block|}
block|,
comment|/* VAX-11 C includes */
block|{
operator|&
name|cplusplus_include_defaults
index|[
literal|3
index|]
block|,
literal|"SYS$SYSROOT:[SYSLIB.]"
block|}
block|,
block|{
literal|0
block|,
literal|""
block|}
block|,
comment|/* This makes normal VMS filespecs work OK */
endif|#
directive|endif
comment|/* VMS */
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* First dir to search */
end_comment

begin_comment
comment|/* First dir to search for<file> */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|first_bracket_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|last_include
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last in chain */
end_comment

begin_comment
comment|/* List of included files that contained #once.  */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|dont_repeat_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of other included files.  */
end_comment

begin_decl_stmt
name|struct
name|file_name_list
modifier|*
name|all_include_files
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Structure allocated for every #define.  For a simple replacement    such as    	#define foo bar ,    nargs = -1, the `pattern' list is null, and the expansion is just    the replacement text.  Nargs = 0 means a functionlike macro with no args,    e.g.,        #define getchar() getc (stdin) .    When there are args, the expansion is the replacement text with the    args squashed out, and the reflist is a list describing how to    build the output from the input: e.g., "3 chars, then the 1st arg,    then 9 chars, then the 3rd arg, then 0 chars, then the 2nd arg".    The chars here come from the expansion.  Whatever is left of the    expansion after the last arg-occurrence is copied after that arg.    Note that the reflist can be arbitrarily long---    its length depends on the number of times the arguments appear in    the replacement text, not how many args there are.  Example:    #define f(x) x+x+x+x+x+x+x would have replacement text "++++++" and    pattern list      { (0, 1), (1, 1), (1, 1), ..., (1, 1), NULL }    where (x, y) means (nchars, argno). */
end_comment

begin_typedef
typedef|typedef
name|struct
name|definition
name|DEFINITION
typedef|;
end_typedef

begin_struct
struct|struct
name|definition
block|{
name|int
name|nargs
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/* length of expansion string */
name|U_CHAR
modifier|*
name|expansion
decl_stmt|;
struct|struct
name|reflist
block|{
name|struct
name|reflist
modifier|*
name|next
decl_stmt|;
name|char
name|stringify
decl_stmt|;
comment|/* nonzero if this arg was preceded by a 				   # operator. */
name|char
name|raw_before
decl_stmt|;
comment|/* Nonzero if a ## operator before arg. */
name|char
name|raw_after
decl_stmt|;
comment|/* Nonzero if a ## operator after arg. */
name|int
name|nchars
decl_stmt|;
comment|/* Number of literal chars to copy before 				   this arg occurrence.  */
name|int
name|argno
decl_stmt|;
comment|/* Number of arg to substitute (origin-0) */
block|}
modifier|*
name|pattern
struct|;
comment|/* Names of macro args, concatenated in reverse order      with comma-space between them.      The only use of this is that we warn on redefinition      if this differs between the old and new definitions.  */
name|U_CHAR
modifier|*
name|argnames
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* different kinds of things that can appear in the value field    of a hash node.  Actually, this may be useless now. */
end_comment

begin_union
union|union
name|hashval
block|{
name|int
name|ival
decl_stmt|;
name|char
modifier|*
name|cpval
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
block|}
union|;
end_union

begin_comment
comment|/* The structure of a node in the hash table.  The hash table    has entries for all tokens defined by #define commands (type T_MACRO),    plus some special tokens like __LINE__ (these each have their own    type, and the appropriate code is run when that type of node is seen.    It does not contain control words like "#define", which are recognized    by a separate piece of code. */
end_comment

begin_comment
comment|/* different flavors of hash nodes --- also used in keyword table */
end_comment

begin_enum
enum|enum
name|node_type
block|{
name|T_DEFINE
init|=
literal|1
block|,
comment|/* the `#define' keyword */
name|T_INCLUDE
block|,
comment|/* the `#include' keyword */
name|T_IFDEF
block|,
comment|/* the `#ifdef' keyword */
name|T_IFNDEF
block|,
comment|/* the `#ifndef' keyword */
name|T_IF
block|,
comment|/* the `#if' keyword */
name|T_ELSE
block|,
comment|/* `#else' */
name|T_PRAGMA
block|,
comment|/* `#pragma' */
name|T_ELIF
block|,
comment|/* `#else' */
name|T_UNDEF
block|,
comment|/* `#undef' */
name|T_LINE
block|,
comment|/* `#line' */
name|T_ERROR
block|,
comment|/* `#error' */
name|T_ENDIF
block|,
comment|/* `#endif' */
name|T_SCCS
block|,
comment|/* `#sccs', used on system V.  */
name|T_IDENT
block|,
comment|/* `#ident', used on system V.  */
name|T_SPECLINE
block|,
comment|/* special symbol `__LINE__' */
name|T_DATE
block|,
comment|/* `__DATE__' */
name|T_FILE
block|,
comment|/* `__FILE__' */
name|T_BASE_FILE
block|,
comment|/* `__BASE_FILE__' */
name|T_INCLUDE_LEVEL
block|,
comment|/* `__INCLUDE_LEVEL__' */
name|T_VERSION
block|,
comment|/* `__VERSION__' */
name|T_TIME
block|,
comment|/* `__TIME__' */
name|T_CONST
block|,
comment|/* Constant value, used by `__STDC__' */
name|T_MACRO
block|,
comment|/* macro defined by `#define' */
name|T_DISABLED
block|,
comment|/* macro temporarily turned off for rescan */
name|T_SPEC_DEFINED
block|,
comment|/* special `defined' macro for use in #if statements */
name|T_UNUSED
comment|/* Used for something not defined.  */
block|}
enum|;
end_enum

begin_struct
struct|struct
name|hashnode
block|{
name|struct
name|hashnode
modifier|*
name|next
decl_stmt|;
comment|/* double links for easy deletion */
name|struct
name|hashnode
modifier|*
name|prev
decl_stmt|;
name|struct
name|hashnode
modifier|*
modifier|*
name|bucket_hdr
decl_stmt|;
comment|/* also, a back pointer to this node's hash 				   chain is kept, in case the node is the head 				   of the chain and gets deleted. */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of special token */
name|int
name|length
decl_stmt|;
comment|/* length of token, for quick comparison */
name|U_CHAR
modifier|*
name|name
decl_stmt|;
comment|/* the actual name */
name|union
name|hashval
name|value
decl_stmt|;
comment|/* pointer to expansion, or whatever */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|hashnode
name|HASHNODE
typedef|;
end_typedef

begin_comment
comment|/* Some definitions for the hash table.  The hash function MUST be    computed as shown in hashf () below.  That is because the rescan    loop computes the hash value `on the fly' for most tokens,    in order to avoid the overhead of a lot of procedure calls to    the hashf () function.  Hashf () only exists for the sake of    politeness, for use when speed isn't so important. */
end_comment

begin_define
define|#
directive|define
name|HASHSIZE
value|1403
end_define

begin_decl_stmt
name|HASHNODE
modifier|*
name|hashtab
index|[
name|HASHSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HASHSTEP
parameter_list|(
name|old
parameter_list|,
name|c
parameter_list|)
value|((old<< 2) + c)
end_define

begin_define
define|#
directive|define
name|MAKE_POS
parameter_list|(
name|v
parameter_list|)
value|(v& ~0x80000000)
end_define

begin_comment
comment|/* make number positive */
end_comment

begin_comment
comment|/* Symbols to predefine.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CPP_PREDEFINES
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|predefs
init|=
name|CPP_PREDEFINES
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|predefs
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* `struct directive' defines one #-directive, including how to handle it.  */
end_comment

begin_struct
struct|struct
name|directive
block|{
name|int
name|length
decl_stmt|;
comment|/* Length of name */
name|int
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* Function to handle directive */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* Name of directive */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* Code which describes which directive. */
name|char
name|angle_brackets
decl_stmt|;
comment|/* Nonzero =><...> is special.  */
name|char
name|traditional_comments
decl_stmt|;
comment|/* Nonzero: keep comments if -traditional.  */
name|char
name|pass_thru
decl_stmt|;
comment|/* Copy preprocessed directive to output file.  */
block|}
struct|;
end_struct

begin_comment
comment|/* Here is the actual list of #-directives, most-often-used first.  */
end_comment

begin_decl_stmt
name|struct
name|directive
name|directive_table
index|[]
init|=
block|{
block|{
literal|6
block|,
name|do_define
block|,
literal|"define"
block|,
name|T_DEFINE
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
literal|2
block|,
name|do_if
block|,
literal|"if"
block|,
name|T_IF
block|}
block|,
block|{
literal|5
block|,
name|do_xifdef
block|,
literal|"ifdef"
block|,
name|T_IFDEF
block|}
block|,
block|{
literal|6
block|,
name|do_xifdef
block|,
literal|"ifndef"
block|,
name|T_IFNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_endif
block|,
literal|"endif"
block|,
name|T_ENDIF
block|}
block|,
block|{
literal|4
block|,
name|do_else
block|,
literal|"else"
block|,
name|T_ELSE
block|}
block|,
block|{
literal|4
block|,
name|do_elif
block|,
literal|"elif"
block|,
name|T_ELIF
block|}
block|,
block|{
literal|4
block|,
name|do_line
block|,
literal|"line"
block|,
name|T_LINE
block|}
block|,
block|{
literal|7
block|,
name|do_include
block|,
literal|"include"
block|,
name|T_INCLUDE
block|,
literal|1
block|}
block|,
block|{
literal|5
block|,
name|do_undef
block|,
literal|"undef"
block|,
name|T_UNDEF
block|}
block|,
block|{
literal|5
block|,
name|do_error
block|,
literal|"error"
block|,
name|T_ERROR
block|}
block|,
ifdef|#
directive|ifdef
name|SCCS_DIRECTIVE
block|{
literal|4
block|,
name|do_sccs
block|,
literal|"sccs"
block|,
name|T_SCCS
block|}
block|,
endif|#
directive|endif
block|{
literal|6
block|,
name|do_pragma
block|,
literal|"pragma"
block|,
name|T_PRAGMA
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|}
block|,
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|""
block|,
name|T_UNUSED
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be part of a C identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idchar
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if char can be first char of a c identifier. */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_idstart
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal space.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_hor_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* table to tell if c is horizontal or vertical space.  */
end_comment

begin_decl_stmt
name|U_CHAR
name|is_space
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SKIP_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_hor_space[*p]) p++; } while (0)
end_define

begin_define
define|#
directive|define
name|SKIP_ALL_WHITE_SPACE
parameter_list|(
name|p
parameter_list|)
value|do { while (is_space[*p]) p++; } while (0)
end_define

begin_decl_stmt
name|int
name|errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Error counter for exit code */
end_comment

begin_comment
comment|/* Zero means dollar signs are punctuation.    -$ stores 0; -traditional, stores 1.  Default is 1 for VMS, 0 otherwise.    This must be 0 for correct processing of this ANSI C program: 	#define foo(a) #a 	#define lose(b) foo(b) 	#define test$ 	lose(test)	*/
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|DOLLARS_IN_IDENTIFIERS
end_ifndef

begin_define
define|#
directive|define
name|DOLLARS_IN_IDENTIFIERS
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dollars_in_ident
init|=
name|DOLLARS_IN_IDENTIFIERS
decl_stmt|;
end_decl_stmt

begin_function_decl
name|FILE_BUF
name|expand_to_temp_buffer
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Stack of conditionals currently in progress    (including both successful and failing conditionals).  */
end_comment

begin_struct
struct|struct
name|if_stack
block|{
name|struct
name|if_stack
modifier|*
name|next
decl_stmt|;
comment|/* for chaining to the next stack frame */
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* copied from input when frame is made */
name|int
name|lineno
decl_stmt|;
comment|/* similarly */
name|int
name|if_succeeded
decl_stmt|;
comment|/* true if a leg of this if-group 				    has been passed through rescan */
name|enum
name|node_type
name|type
decl_stmt|;
comment|/* type of last directive seen in this group */
block|}
struct|;
end_struct

begin_typedef
typedef|typedef
name|struct
name|if_stack
name|IF_STACK_FRAME
typedef|;
end_typedef

begin_decl_stmt
name|IF_STACK_FRAME
modifier|*
name|if_stack
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer of -M output.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|deps_buffer
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes allocated in above.  */
end_comment

begin_decl_stmt
name|int
name|deps_allocated_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes used.  */
end_comment

begin_decl_stmt
name|int
name|deps_size
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of bytes since the last newline.  */
end_comment

begin_decl_stmt
name|int
name|deps_column
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means -I- has been seen,    so don't look for #include "foo" the source-file directory.  */
end_comment

begin_decl_stmt
name|int
name|ignore_srcdir
decl_stmt|;
end_decl_stmt

begin_escape
end_escape

begin_comment
comment|/* Handler for SIGPIPE.  */
end_comment

begin_function
specifier|static
name|void
name|pipe_closed
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"output pipe has been closed"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|st_mode
decl_stmt|;
name|long
name|st_size
decl_stmt|;
name|char
modifier|*
name|in_fname
decl_stmt|,
modifier|*
name|out_fname
decl_stmt|;
name|int
name|f
decl_stmt|,
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_files
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_defs
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|char
modifier|*
modifier|*
name|pend_undefs
init|=
operator|(
name|char
operator|*
operator|*
operator|)
name|xmalloc
argument_list|(
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
decl_stmt|;
name|int
name|inhibit_predefs
init|=
literal|0
decl_stmt|;
name|int
name|no_standard_includes
init|=
literal|0
decl_stmt|;
comment|/* Non-0 means don't output the preprocessed program.  */
name|int
name|inhibit_output
init|=
literal|0
decl_stmt|;
comment|/* Stream on which to print the dependency information.  */
name|FILE
modifier|*
name|deps_stream
init|=
literal|0
decl_stmt|;
comment|/* Target-name to write with the dependency information.  */
name|char
modifier|*
name|deps_target
init|=
literal|0
decl_stmt|;
ifdef|#
directive|ifdef
name|RLIMIT_STACK
comment|/* Get rid of any avoidable limit on stack size.  */
block|{
name|struct
name|rlimit
name|rlim
decl_stmt|;
comment|/* Set the stack limit huge so that alloca (particularly stringtab      * in dbxread.c) does not fail. */
name|getrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
name|rlim
operator|.
name|rlim_cur
operator|=
name|rlim
operator|.
name|rlim_max
expr_stmt|;
name|setrlimit
argument_list|(
name|RLIMIT_STACK
argument_list|,
operator|&
name|rlim
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* RLIMIT_STACK defined */
name|progname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
block|{
comment|/* Remove directories from PROGNAME.  */
name|char
modifier|*
name|s
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
name|progname
operator|=
name|savestring
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|s
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|']'
argument_list|)
operator|)
condition|)
name|s
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
condition|)
name|strcpy
argument_list|(
name|progname
argument_list|,
name|s
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|rindex
argument_list|(
name|progname
argument_list|,
literal|'.'
argument_list|)
condition|)
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
block|}
endif|#
directive|endif
name|in_fname
operator|=
name|NULL
expr_stmt|;
name|out_fname
operator|=
name|NULL
expr_stmt|;
comment|/* Initialize is_idchar to allow $.  */
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
name|initialize_char_syntax
argument_list|()
expr_stmt|;
name|dollars_in_ident
operator|=
name|DOLLARS_IN_IDENTIFIERS
expr_stmt|;
name|no_line_commands
operator|=
literal|0
expr_stmt|;
name|no_trigraphs
operator|=
literal|1
expr_stmt|;
name|dump_macros
operator|=
literal|0
expr_stmt|;
name|no_output
operator|=
literal|0
expr_stmt|;
name|cplusplus
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CPLUSPLUS
name|cplusplus
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|pipe_closed
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
name|max_include_len
operator|=
name|max
argument_list|(
name|max
argument_list|(
sizeof|sizeof
argument_list|(
name|GCC_INCLUDE_DIR
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|GPLUSPLUS_INCLUDE_DIR
argument_list|)
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
literal|"/usr/include/CC"
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|max_include_len
operator|=
sizeof|sizeof
argument_list|(
literal|"SYS$SYSROOT:[SYSLIB.]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
name|bzero
argument_list|(
name|pend_files
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pend_defs
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|bzero
argument_list|(
name|pend_undefs
argument_list|,
name|argc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Process switches and find input file name.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Usage: %s [switches] input output"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|in_fname
operator|!=
name|NULL
condition|)
name|out_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
else|else
name|in_fname
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'i'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|pend_files
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after -i option"
argument_list|)
expr_stmt|;
else|else
name|pend_files
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|out_fname
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Output filename specified twice"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Filename missing after -o option"
argument_list|)
expr_stmt|;
name|out_fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|"-"
argument_list|)
condition|)
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|pedantic
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-traditional"
argument_list|)
condition|)
block|{
name|traditional
operator|=
literal|1
expr_stmt|;
name|dollars_in_ident
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-trigraphs"
argument_list|)
condition|)
block|{
name|no_trigraphs
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'+'
case|:
name|cplusplus
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|inhibit_warnings
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wtrigraphs"
argument_list|)
condition|)
block|{
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomments"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wcomment"
argument_list|)
condition|)
name|warn_comments
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-Wall"
argument_list|)
condition|)
block|{
name|warn_trigraphs
operator|=
literal|1
expr_stmt|;
name|warn_comments
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-M"
argument_list|)
condition|)
name|print_deps
operator|=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-MM"
argument_list|)
condition|)
name|print_deps
operator|=
literal|1
expr_stmt|;
name|inhibit_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|dump_macros
operator|=
literal|1
expr_stmt|;
name|no_output
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"GNU CPP version %s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
block|{
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|p1
decl_stmt|;
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|p
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Macro name missing after -D option"
argument_list|)
expr_stmt|;
else|else
name|p
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|p1
operator|=
operator|(
name|char
operator|*
operator|)
name|index
argument_list|(
name|p
argument_list|,
literal|'='
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|p1
operator|=
literal|' '
expr_stmt|;
name|pend_defs
index|[
name|i
index|]
operator|=
name|p
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
comment|/* JF #undef something */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|pend_undefs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Macro name missing after -U option"
argument_list|)
expr_stmt|;
else|else
name|pend_undefs
index|[
name|i
index|]
operator|=
name|argv
index|[
name|i
operator|+
literal|1
index|]
operator|,
name|i
operator|++
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|put_out_comments
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
comment|/* -E comes from cc -E; ignore it.  */
break|break;
case|case
literal|'P'
case|:
name|no_line_commands
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
comment|/* Don't include $ in identifiers.  */
name|dollars_in_ident
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* Add directory to path for includes.  */
block|{
name|struct
name|file_name_list
modifier|*
name|dirtmp
decl_stmt|;
if|if
condition|(
operator|!
name|ignore_srcdir
operator|&&
operator|!
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
operator|+
literal|2
argument_list|,
literal|"-"
argument_list|)
condition|)
name|ignore_srcdir
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|dirtmp
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|dirtmp
operator|->
name|next
operator|=
literal|0
expr_stmt|;
comment|/* New one goes on the end */
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
name|dirtmp
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
name|dirtmp
expr_stmt|;
name|last_include
operator|=
name|dirtmp
expr_stmt|;
comment|/* Tail follows the last one */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
operator|!=
literal|0
condition|)
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|+
literal|1
operator|==
name|argc
condition|)
name|fatal
argument_list|(
literal|"Directory name missing after -I option"
argument_list|)
expr_stmt|;
else|else
name|dirtmp
operator|->
name|fname
operator|=
name|argv
index|[
operator|++
name|i
index|]
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|strlen
argument_list|(
name|dirtmp
operator|->
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirtmp
operator|->
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|dirtmp
operator|->
name|fname
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|dirtmp
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
comment|/* Current directory */
if|if
condition|(
name|ignore_srcdir
operator|&&
name|first_bracket_include
operator|==
literal|0
condition|)
name|first_bracket_include
operator|=
name|dirtmp
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'n'
case|:
comment|/* -nostdinc causes no default include directories. 	   You must specify all include-file directories with -I.  */
name|no_standard_includes
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Sun compiler passes undocumented switch "-undef". 	   Let's assume it means to inhibit the predefined symbols.  */
name|inhibit_predefs
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
comment|/* JF handle '-' as file name meaning stdin or stdout */
if|if
condition|(
name|in_fname
operator|==
name|NULL
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|out_fname
operator|==
name|NULL
condition|)
block|{
name|out_fname
operator|=
literal|""
expr_stmt|;
break|break;
block|}
comment|/* else fall through into error */
default|default:
name|fatal
argument_list|(
literal|"Invalid option `%s'"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* Now that dollars_in_ident is known, initialize is_idchar.  */
name|initialize_char_syntax
argument_list|()
expr_stmt|;
comment|/* Install __LINE__, etc.  Must follow initialize_char_syntax      and option processing.  */
name|initialize_builtins
argument_list|()
expr_stmt|;
comment|/* Do standard #defines that identify processor type.  */
if|if
condition|(
operator|!
name|inhibit_predefs
condition|)
block|{
name|char
modifier|*
name|p
init|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|strlen
argument_list|(
name|predefs
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
name|predefs
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
name|char
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|p
index|[
literal|1
index|]
operator|!=
literal|'D'
condition|)
name|abort
argument_list|()
expr_stmt|;
name|q
operator|=
operator|&
name|p
index|[
literal|2
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|' '
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|make_definition
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Do defines specified with -D.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend_defs
index|[
name|i
index|]
condition|)
name|make_definition
argument_list|(
name|pend_defs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Do undefines specified with -U.  */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend_undefs
index|[
name|i
index|]
condition|)
name|make_undef
argument_list|(
name|pend_undefs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Unless -fnostdinc,      tack on the standard include file dirs to the specified list */
if|if
condition|(
operator|!
name|no_standard_includes
condition|)
block|{
if|if
condition|(
name|include
operator|==
literal|0
condition|)
name|include
operator|=
operator|(
name|cplusplus
condition|?
name|cplusplus_include_defaults
else|:
name|include_defaults
operator|)
expr_stmt|;
else|else
name|last_include
operator|->
name|next
operator|=
operator|(
name|cplusplus
condition|?
name|cplusplus_include_defaults
else|:
name|include_defaults
operator|)
expr_stmt|;
comment|/* Make sure the list for #include<...> also has the standard dirs.  */
if|if
condition|(
name|ignore_srcdir
operator|&&
name|first_bracket_include
operator|==
literal|0
condition|)
name|first_bracket_include
operator|=
operator|(
name|cplusplus
condition|?
name|cplusplus_include_defaults
else|:
name|include_defaults
operator|)
expr_stmt|;
block|}
comment|/* Initialize output buffer */
name|outbuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|OUTBUF_SIZE
argument_list|)
expr_stmt|;
name|outbuf
operator|.
name|bufp
operator|=
name|outbuf
operator|.
name|buf
expr_stmt|;
name|outbuf
operator|.
name|length
operator|=
name|OUTBUF_SIZE
expr_stmt|;
comment|/* Scan the -i files before the main input.      Much like #including them, but with no_output set      so that only their macro definitions matter.  */
name|no_output
operator|++
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|pend_files
index|[
name|i
index|]
condition|)
block|{
name|int
name|fd
init|=
name|open
argument_list|(
name|pend_files
index|[
name|i
index|]
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
decl_stmt|;
if|if
condition|(
name|fd
operator|<
literal|0
condition|)
block|{
name|perror_with_name
argument_list|(
name|pend_files
index|[
name|i
index|]
argument_list|)
expr_stmt|;
return|return
name|FATAL_EXIT_CODE
return|;
block|}
name|finclude
argument_list|(
name|fd
argument_list|,
name|pend_files
index|[
name|i
index|]
argument_list|,
operator|&
name|outbuf
argument_list|)
expr_stmt|;
block|}
name|no_output
operator|--
expr_stmt|;
comment|/* Create an input stack level for the main input file      and copy the entire contents of the file into it.  */
name|fp
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
comment|/* JF check for stdin */
if|if
condition|(
name|in_fname
operator|==
name|NULL
operator|||
operator|*
name|in_fname
operator|==
literal|0
condition|)
block|{
name|in_fname
operator|=
literal|""
expr_stmt|;
name|f
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|in_fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
comment|/* Either of two environment variables can specify output of deps.      Its value is either "OUTPUT_FILE" or "OUTPUT_FILE DEPS_TARGET",      where OUTPUT_FILE is the file to write deps info to      and DEPS_TARGET is the target to mention in the deps.  */
if|if
condition|(
name|print_deps
operator|==
literal|0
operator|&&
operator|(
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
operator|!=
literal|0
operator|||
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|char
modifier|*
name|spec
init|=
name|getenv
argument_list|(
literal|"DEPENDENCIES_OUTPUT"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|output_file
decl_stmt|;
if|if
condition|(
name|spec
operator|==
literal|0
condition|)
block|{
name|spec
operator|=
name|getenv
argument_list|(
literal|"SUNPRO_DEPENDENCIES"
argument_list|)
expr_stmt|;
name|print_deps
operator|=
literal|2
expr_stmt|;
block|}
else|else
name|print_deps
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|spec
expr_stmt|;
comment|/* Find the space before the DEPS_TARGET, if there is one.  */
comment|/* Don't use `index'; that causes trouble on USG.  */
while|while
condition|(
operator|*
name|s
operator|!=
literal|0
operator|&&
operator|*
name|s
operator|!=
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|0
condition|)
block|{
name|deps_target
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|output_file
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|s
operator|-
name|spec
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|spec
argument_list|,
name|output_file
argument_list|,
name|s
operator|-
name|spec
argument_list|)
expr_stmt|;
name|output_file
index|[
name|s
operator|-
name|spec
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|deps_target
operator|=
literal|0
expr_stmt|;
name|output_file
operator|=
name|spec
expr_stmt|;
block|}
name|deps_stream
operator|=
name|fopen
argument_list|(
name|output_file
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_stream
operator|==
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|output_file
argument_list|)
expr_stmt|;
block|}
comment|/* If the -M option was used, output the deps to standard output.  */
elseif|else
if|if
condition|(
name|print_deps
condition|)
name|deps_stream
operator|=
name|stdout
expr_stmt|;
comment|/* For -M, print the expected object file name      as the target of this Make-rule.  */
if|if
condition|(
name|print_deps
condition|)
block|{
name|deps_allocated_size
operator|=
literal|200
expr_stmt|;
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|deps_allocated_size
argument_list|)
expr_stmt|;
name|deps_buffer
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|deps_size
operator|=
literal|0
expr_stmt|;
name|deps_column
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|deps_target
condition|)
block|{
name|deps_output
argument_list|(
name|deps_target
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
literal|":"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|in_fname
operator|==
literal|0
condition|)
name|deps_output
argument_list|(
literal|"-: "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|in_fname
decl_stmt|;
name|char
modifier|*
name|p1
init|=
name|p
decl_stmt|;
comment|/* Discard all directory prefixes from P.  */
while|while
condition|(
operator|*
name|p1
condition|)
block|{
if|if
condition|(
operator|*
name|p1
operator|==
literal|'/'
condition|)
name|p
operator|=
name|p1
operator|+
literal|1
expr_stmt|;
name|p1
operator|++
expr_stmt|;
block|}
comment|/* Output P, but remove known suffixes.  */
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
operator|&&
operator|(
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'c'
operator|||
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'C'
operator|||
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'S'
operator|)
condition|)
name|deps_output
argument_list|(
name|p
argument_list|,
name|len
operator|-
literal|2
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
index|[
name|len
operator|-
literal|3
index|]
operator|==
literal|'.'
operator|&&
name|p
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'c'
operator|&&
name|p
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'c'
condition|)
name|deps_output
argument_list|(
name|p
argument_list|,
name|len
operator|-
literal|3
argument_list|)
expr_stmt|;
else|else
name|deps_output
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Supply our own suffix.  */
name|deps_output
argument_list|(
literal|".o : "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
name|in_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|file_size_and_mode
argument_list|(
name|f
argument_list|,
operator|&
name|st_mode
argument_list|,
operator|&
name|st_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fname
operator|=
name|in_fname
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* JF all this is mine about reading pipes and ttys */
if|if
condition|(
operator|!
name|S_ISREG
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
comment|/* Read input from a file that is not a normal disk file.        We cannot preallocate a buffer with the correct size,        so we must read in the file a piece at the time and make it bigger.  */
name|int
name|size
decl_stmt|;
name|int
name|bsize
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
name|bsize
operator|=
literal|2000
expr_stmt|;
name|size
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cnt
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|bufp
argument_list|,
name|bsize
operator|-
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
goto|goto
name|perror
goto|;
comment|/* error! */
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
break|break;
comment|/* End of file */
name|size
operator|+=
name|cnt
expr_stmt|;
name|bufp
operator|+=
name|cnt
expr_stmt|;
if|if
condition|(
name|bsize
operator|==
name|size
condition|)
block|{
comment|/* Buffer is full! */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|fp
operator|->
name|buf
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|fp
operator|->
name|buf
operator|+
name|size
expr_stmt|;
comment|/* May have moved */
block|}
block|}
name|fp
operator|->
name|length
operator|=
name|size
expr_stmt|;
block|}
else|else
block|{
comment|/* Read a file whose size we can determine in advance.        For the sake of VMS, st_size is just an upper bound.  */
name|long
name|i
decl_stmt|;
name|fp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
while|while
condition|(
name|st_size
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
operator|+
name|fp
operator|->
name|length
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
goto|goto
name|perror
goto|;
block|}
name|fp
operator|->
name|length
operator|+=
name|i
expr_stmt|;
name|st_size
operator|-=
name|i
expr_stmt|;
block|}
block|}
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
comment|/* Unless inhibited, convert trigraphs in the input.  */
if|if
condition|(
operator|!
name|no_trigraphs
condition|)
name|trigraph_pcp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* Make sure data ends with a newline.  And put a null after it.  */
if|if
condition|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now that we know the input file is valid, open the output.  */
if|if
condition|(
operator|!
name|out_fname
operator|||
operator|!
name|strcmp
argument_list|(
name|out_fname
argument_list|,
literal|""
argument_list|)
condition|)
name|out_fname
operator|=
literal|"stdout"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|freopen
argument_list|(
name|out_fname
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
condition|)
name|pfatal_with_name
argument_list|(
name|out_fname
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
comment|/* Scan the input, processing macros and directives.  */
name|rescan
argument_list|(
operator|&
name|outbuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Now we have processed the entire input      Write whichever kind of output has been requested.  */
if|if
condition|(
name|dump_macros
condition|)
name|dump_all_macros
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|inhibit_output
operator|&&
name|deps_stream
operator|!=
name|stdout
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|outbuf
operator|.
name|buf
argument_list|,
name|outbuf
operator|.
name|bufp
operator|-
name|outbuf
operator|.
name|buf
argument_list|)
operator|<
literal|0
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|print_deps
condition|)
block|{
name|fputs
argument_list|(
name|deps_buffer
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|deps_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_stream
operator|!=
name|stdout
condition|)
block|{
name|fclose
argument_list|(
name|deps_stream
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|deps_stream
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"I/O error on output"
argument_list|)
expr_stmt|;
if|if
condition|(
name|errors
condition|)
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|SUCCESS_EXIT_CODE
argument_list|)
expr_stmt|;
name|perror
label|:
name|pfatal_with_name
argument_list|(
name|in_fname
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Pre-C-Preprocessor to translate ANSI trigraph idiocy in BUF    before main CCCP processing.  Name `pcp' is also in honor of the    drugs the trigraph designers must have been on.     Using an extra pass through the buffer takes a little extra time,    but is infinitely less hairy than trying to handle ??/" inside    strings, etc. everywhere, and also makes sure that trigraphs are    only translated in the top level of processing. */
end_comment

begin_macro
name|trigraph_pcp
argument_list|(
argument|buf
argument_list|)
end_macro

begin_decl_stmt
name|FILE_BUF
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
name|c
decl_stmt|,
modifier|*
name|fptr
decl_stmt|,
modifier|*
name|bptr
decl_stmt|,
modifier|*
name|sptr
decl_stmt|;
name|int
name|len
decl_stmt|;
name|fptr
operator|=
name|bptr
operator|=
name|sptr
operator|=
name|buf
operator|->
name|buf
expr_stmt|;
while|while
condition|(
operator|(
name|sptr
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
name|sptr
argument_list|,
literal|'?'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
operator|++
name|sptr
operator|!=
literal|'?'
condition|)
continue|continue;
switch|switch
condition|(
operator|*
operator|++
name|sptr
condition|)
block|{
case|case
literal|'='
case|:
name|c
operator|=
literal|'#'
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|c
operator|=
literal|'['
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|c
operator|=
literal|'\\'
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|c
operator|=
literal|']'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|c
operator|=
literal|'^'
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|c
operator|=
literal|'{'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
name|c
operator|=
literal|'|'
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|c
operator|=
literal|'}'
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|c
operator|=
literal|'~'
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|sptr
operator|--
expr_stmt|;
continue|continue;
default|default:
continue|continue;
block|}
name|len
operator|=
name|sptr
operator|-
name|fptr
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|bptr
operator|!=
name|fptr
operator|&&
name|len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|fptr
argument_list|,
name|bptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
comment|/* BSD doc says bcopy () works right 				   for overlapping strings.  In ANSI 				   C, this will be memmove (). */
name|bptr
operator|+=
name|len
expr_stmt|;
operator|*
name|bptr
operator|++
operator|=
name|c
expr_stmt|;
name|fptr
operator|=
operator|++
name|sptr
expr_stmt|;
block|}
name|len
operator|=
name|buf
operator|->
name|length
operator|-
operator|(
name|fptr
operator|-
name|buf
operator|->
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|bptr
operator|!=
name|fptr
operator|&&
name|len
operator|>
literal|0
condition|)
name|bcopy
argument_list|(
name|fptr
argument_list|,
name|bptr
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|buf
operator|->
name|length
operator|-=
name|fptr
operator|-
name|bptr
expr_stmt|;
name|buf
operator|->
name|buf
index|[
name|buf
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|warn_trigraphs
operator|&&
name|fptr
operator|!=
name|bptr
condition|)
name|warning
argument_list|(
literal|"%d trigraph(s) encountered"
argument_list|,
operator|(
name|fptr
operator|-
name|bptr
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Move all backslash-newline pairs out of embarrassing places.    Exchange all such pairs following BP    with any potentially-embarrasing characters that follow them.    Potentially-embarrassing characters are / and *    (because a backslash-newline inside a comment delimiter    would cause it not to be recognized).  */
end_comment

begin_macro
name|newline_fix
argument_list|(
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\\'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
name|p
operator|=
name|bp
operator|+
name|count
operator|*
literal|2
expr_stmt|;
comment|/* Exit if what follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|(
operator|*
name|p
operator|!=
literal|'/'
operator|&&
operator|*
name|p
operator|!=
literal|'*'
operator|)
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|||
operator|*
name|p
operator|==
literal|'/'
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Like newline_fix but for use within a directive-name.    Move any backslash-newlines up past any following symbol constituents.  */
end_comment

begin_macro
name|name_newline_fix
argument_list|(
argument|bp
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|bp
decl_stmt|;
specifier|register
name|int
name|count
init|=
literal|0
decl_stmt|;
comment|/* First count the backslash-newline pairs here.  */
while|while
condition|(
operator|*
name|p
operator|++
operator|==
literal|'\\'
operator|&&
operator|*
name|p
operator|++
operator|==
literal|'\n'
condition|)
name|count
operator|++
expr_stmt|;
name|p
operator|=
name|bp
operator|+
name|count
operator|*
literal|2
expr_stmt|;
comment|/* What follows the backslash-newlines is not embarrassing.  */
if|if
condition|(
name|count
operator|==
literal|0
operator|||
operator|!
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
return|return;
comment|/* Copy all potentially embarrassing characters      that follow the backslash-newline pairs      down to where the pairs originally started.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
operator|*
name|bp
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
comment|/* Now write the same number of pairs after the embarrassing chars.  */
while|while
condition|(
name|count
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|bp
operator|++
operator|=
literal|'\\'
expr_stmt|;
operator|*
name|bp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * The main loop of the program.  *  * Read characters from the input stack, transferring them to the  * output buffer OP.  *  * Macros are expanded and push levels on the input stack.  * At the end of such a level it is popped off and we keep reading.  * At the end of any other kind of level, we return.  * #-directives are handled, except within macros.  *  * If OUTPUT_MARKS is nonzero, keep Newline markers found in the input  * and insert them when appropriate.  This is set while scanning macro  * arguments before substitution.  It is zero when scanning for final output.  *   There are three types of Newline markers:  *   * Newline -  follows a macro name that was not expanded  *     because it appeared inside an expansion of the same macro.  *     This marker prevents future expansion of that identifier.  *     When the input is rescanned into the final output, these are deleted.  *     These are also deleted by ## concatenation.  *   * Newline Space (or Newline and any other whitespace character)  *     stands for a place that tokens must be separated or whitespace  *     is otherwise desirable, but where the ANSI standard specifies there  *     is no whitespace.  This marker turns into a Space (or whichever other  *     whitespace char appears in the marker) in the final output,  *     but it turns into nothing in an argument that is stringified with #.  *     Such stringified arguments are the only place where the ANSI standard  *     specifies with precision that whitespace may not appear.  *  * During this function, IP->bufp is kept cached in IBP for speed of access.  * Likewise, OP->bufp is kept in OBP.  Before calling a subroutine  * IBP, IP and OBP must be copied back to memory.  IP and IBP are  * copied back with the RECACHE macro.  OBP must be copied back from OP->bufp  * explicitly, and before RECACHE, since RECACHE uses OBP.  */
end_comment

begin_macro
name|rescan
argument_list|(
argument|op
argument_list|,
argument|output_marks
argument_list|)
end_macro

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|output_marks
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* Character being scanned in main loop.  */
specifier|register
name|U_CHAR
name|c
decl_stmt|;
comment|/* Length of pending accumulated identifier.  */
specifier|register
name|int
name|ident_length
init|=
literal|0
decl_stmt|;
comment|/* Hash code of pending accumulated identifier.  */
specifier|register
name|int
name|hash
init|=
literal|0
decl_stmt|;
comment|/* Current input level (&instack[indepth]).  */
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
comment|/* Pointer for scanning input.  */
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
comment|/* Pointer to end of input.  End of scan is controlled by LIMIT.  */
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
comment|/* Pointer for storing output.  */
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
comment|/* REDO_CHAR is nonzero if we are processing an identifier      after backing up over the terminating character.      Sometimes we process an identifier without backing up over      the terminating character, if the terminating character      is not special.  Backing up is done so that the terminating character      will be dispatched on again once the identifier is dealt with.  */
name|int
name|redo_char
init|=
literal|0
decl_stmt|;
comment|/* 1 if within an identifier inside of which a concatenation      marker (Newline -) has been seen.  */
name|int
name|concatenated
init|=
literal|0
decl_stmt|;
comment|/* While scanning a comment or a string constant,      this records the line it started on, for error messages.  */
name|int
name|start_line
decl_stmt|;
comment|/* Record position of last `real' newline.  */
name|U_CHAR
modifier|*
name|beg_of_line
decl_stmt|;
comment|/* Pop the innermost input stack level, assuming it is a macro expansion.  */
define|#
directive|define
name|POPMACRO
define|\
value|do { ip->macro->type = T_MACRO;		\      if (ip->free_ptr) free (ip->free_ptr);	\      --indepth; } while (0)
comment|/* Reload `rescan's local variables that describe the current    level of the input stack.  */
define|#
directive|define
name|RECACHE
define|\
value|do { ip =&instack[indepth];		\      ibp = ip->bufp;			\      limit = ip->buf + ip->length;	\      op->bufp = obp;			\      check_expand (op, limit - ibp);	\      beg_of_line = 0;			\      obp = op->bufp; } while (0)
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Our caller must always put a null after the end of      the input at each input stack level.  */
if|if
condition|(
operator|*
name|limit
operator|!=
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
break|break;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Always merge lines ending with backslash-newline, 	   even in middle of identifier.  */
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|--
name|obp
expr_stmt|;
comment|/* remove backslash from obuf */
break|break;
block|}
comment|/* Otherwise, backslash suppresses specialness of following char, 	 so copy it here to prevent the switch from seeing it. 	 But first get any pending identifier processed.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
comment|/* If this is expanding a macro definition, don't recognize 	 preprocessor directives.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
comment|/* # keyword: a # must be first nonblank char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
goto|goto
name|randomchar
goto|;
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* Scan from start of line, skipping whitespace, comments 	   and backslash-newlines, and see if we reach this #. 	   If not, this # is not special.  */
name|bp
operator|=
name|beg_of_line
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
operator|(
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
operator|,
name|bp
index|[
literal|1
index|]
operator|)
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|bp
operator|==
literal|'*'
operator|&&
operator|(
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
operator|,
name|bp
index|[
literal|1
index|]
operator|)
operator|==
literal|'/'
operator|)
condition|)
name|bp
operator|++
expr_stmt|;
name|bp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cplusplus
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|&&
operator|(
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
operator|,
name|bp
index|[
literal|1
index|]
operator|)
operator|==
literal|'/'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|bp
operator|+
literal|1
operator|!=
name|ibp
condition|)
goto|goto
name|randomchar
goto|;
block|}
comment|/* This # can start a directive.  */
operator|--
name|obp
expr_stmt|;
comment|/* Don't copy the '#' */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
if|if
condition|(
operator|!
name|handle_directive
argument_list|(
name|ip
argument_list|,
name|op
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Not a known directive: treat it as ordinary text. 	   IP, OP, IBP, etc. have not been changed.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
block|{
comment|/* If not generating expanded output, 	     what we do with ordinary text is skip it. 	     Discard everything until next # directive.  */
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
block|}
operator|++
name|obp
expr_stmt|;
comment|/* Copy the '#' after all */
goto|goto
name|randomchar
goto|;
block|}
ifdef|#
directive|ifdef
name|USE_C_ALLOCA
name|alloca
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* A # directive has been successfully processed.  */
comment|/* If not generating expanded output, ignore everything until 	 next # directive.  */
if|if
condition|(
name|no_output
operator|&&
name|instack
index|[
name|indepth
index|]
operator|.
name|fname
condition|)
name|skip_if_group
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
comment|/* skip quoted string */
case|case
literal|'\''
case|:
comment|/* A single quoted string is treated like a double -- some 	 programs (e.g., troff) are perverse this way */
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Skip ahead to a matching quote.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* try harder: this string crosses a macro expansion boundary */
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
continue|continue;
block|}
block|}
else|else
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
expr_stmt|;
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
comment|/* Traditionally, end of line ends a string constant with no error. 	     So exit the loop and record the new line.  */
if|if
condition|(
name|traditional
condition|)
block|{
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
goto|goto
name|while2end
goto|;
block|}
if|if
condition|(
name|pedantic
operator|||
name|c
operator|==
literal|'\''
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
goto|goto
name|while2end
goto|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
break|break;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Backslash newline is replaced by nothing at all, 	       but keep the line counts correct.  */
operator|--
name|obp
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
else|else
block|{
comment|/* ANSI stupidly requires that in \\ the second \ 	       is *not* prevented from combining with a newline.  */
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
name|c
condition|)
goto|goto
name|while2end
goto|;
break|break;
block|}
block|}
name|while2end
label|:
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* Don't look for comments inside a macro definition.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
goto|goto
name|randomchar
goto|;
comment|/* A comment constitutes white space, so it can terminate an identifier. 	 Process the identifier, if any.  */
if|if
condition|(
name|ident_length
condition|)
goto|goto
name|specialchar
goto|;
if|if
condition|(
name|cplusplus
operator|&&
operator|*
name|ibp
operator|==
literal|'/'
condition|)
block|{
comment|/* C++ style comment... */
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
operator|--
name|ibp
expr_stmt|;
comment|/* Back over the slash */
operator|--
name|obp
expr_stmt|;
comment|/* Comments are equivalent to spaces. */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
else|else
block|{
comment|/* must fake up a comment here */
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|{
name|U_CHAR
modifier|*
name|before_bp
init|=
name|ibp
operator|+
literal|2
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|ibp
operator|++
operator|==
literal|'\n'
condition|)
block|{
name|ibp
operator|--
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
name|before_bp
argument_list|,
name|obp
argument_list|,
name|ibp
operator|-
name|before_bp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ibp
operator|-
name|before_bp
expr_stmt|;
block|}
break|break;
block|}
block|}
break|break;
block|}
block|}
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'*'
condition|)
goto|goto
name|randomchar
goto|;
comment|/* We have a comment.  Skip it, optionally copying it to output.  */
name|start_line
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|ibp
expr_stmt|;
comment|/* Skip the star. */
comment|/* Comments are equivalent to spaces. 	 Note that we already output the slash; we might not want it. 	 For -traditional, a comment is equivalent to nothing.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
name|obp
operator|--
expr_stmt|;
else|else
name|obp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
block|}
else|else
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|{
name|U_CHAR
modifier|*
name|before_bp
init|=
name|ibp
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|ibp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
if|if
condition|(
name|warn_comments
operator|&&
name|ibp
operator|<
name|limit
operator|&&
operator|*
name|ibp
operator|==
literal|'*'
condition|)
name|warning
argument_list|(
literal|"`/*' within comment"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
operator|>=
name|limit
operator|||
operator|*
name|ibp
operator|==
literal|'/'
condition|)
goto|goto
name|comment_end
goto|;
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* Copy the newline into the output buffer, in order to 	       avoid the pain of a #line every time a multiline comment 	       is seen.  */
if|if
condition|(
operator|!
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
block|}
name|comment_end
label|:
if|if
condition|(
name|ibp
operator|>=
name|limit
condition|)
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated comment"
argument_list|)
expr_stmt|;
else|else
block|{
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
name|bcopy
argument_list|(
name|before_bp
argument_list|,
name|obp
argument_list|,
name|ibp
operator|-
name|before_bp
argument_list|)
expr_stmt|;
name|obp
operator|+=
name|ibp
operator|-
name|before_bp
expr_stmt|;
block|}
block|}
block|}
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
operator|!
name|dollars_in_ident
condition|)
goto|goto
name|randomchar
goto|;
goto|goto
name|letter
goto|;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* If digit is not part of identifier, it starts a number, 	 which means that following letters are not an identifier. 	 "0x5" does not refer to an identifier "x5". 	 So copy all alphanumerics that follow without accumulating 	 as an identifier.  Periods also, for sake of "3.e7".  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|c
argument_list|)
operator|&&
name|c
operator|!=
literal|'.'
operator|&&
name|c
operator|!=
literal|'_'
condition|)
block|{
operator|--
name|ibp
expr_stmt|;
break|break;
block|}
operator|*
name|obp
operator|++
operator|=
name|c
expr_stmt|;
comment|/* A sign can be part of a preprocessing number 	     if it follows an e.  */
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
condition|)
block|{
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|ibp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ibp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|ibp
operator|==
literal|'+'
operator|||
operator|*
name|ibp
operator|==
literal|'-'
operator|)
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* But traditional C does not let the token go past the sign.  */
if|if
condition|(
name|traditional
condition|)
break|break;
block|}
block|}
block|}
break|break;
block|}
comment|/* fall through */
case|case
literal|'_'
case|:
case|case
literal|'a'
case|:
case|case
literal|'b'
case|:
case|case
literal|'c'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'f'
case|:
case|case
literal|'g'
case|:
case|case
literal|'h'
case|:
case|case
literal|'i'
case|:
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'p'
case|:
case|case
literal|'q'
case|:
case|case
literal|'r'
case|:
case|case
literal|'s'
case|:
case|case
literal|'t'
case|:
case|case
literal|'u'
case|:
case|case
literal|'v'
case|:
case|case
literal|'w'
case|:
case|case
literal|'x'
case|:
case|case
literal|'y'
case|:
case|case
literal|'z'
case|:
case|case
literal|'A'
case|:
case|case
literal|'B'
case|:
case|case
literal|'C'
case|:
case|case
literal|'D'
case|:
case|case
literal|'E'
case|:
case|case
literal|'F'
case|:
case|case
literal|'G'
case|:
case|case
literal|'H'
case|:
case|case
literal|'I'
case|:
case|case
literal|'J'
case|:
case|case
literal|'K'
case|:
case|case
literal|'L'
case|:
case|case
literal|'M'
case|:
case|case
literal|'N'
case|:
case|case
literal|'O'
case|:
case|case
literal|'P'
case|:
case|case
literal|'Q'
case|:
case|case
literal|'R'
case|:
case|case
literal|'S'
case|:
case|case
literal|'T'
case|:
case|case
literal|'U'
case|:
case|case
literal|'V'
case|:
case|case
literal|'W'
case|:
case|case
literal|'X'
case|:
case|case
literal|'Y'
case|:
case|case
literal|'Z'
case|:
name|letter
label|:
name|ident_length
operator|++
expr_stmt|;
comment|/* Compute step of hash function, to avoid a proc call on every token */
name|hash
operator|=
name|HASHSTEP
argument_list|(
name|hash
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
comment|/* If reprocessing a macro expansion, newline is a special marker.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
comment|/* Newline White is a "funny space" to separate tokens that are 	   supposed to be separate but without space between. 	   Here White means any horizontal whitespace character. 	   Newline - marks a recursive macro use that is not 	   supposed to be expandable.  */
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'-'
condition|)
block|{
comment|/* Newline - inhibits expansion of preceding token. 	     If expanding a macro arg, we keep the newline -. 	     In final output, it is deleted.  */
if|if
condition|(
operator|!
name|concatenated
condition|)
block|{
name|ident_length
operator|=
literal|0
expr_stmt|;
name|hash
operator|=
literal|0
expr_stmt|;
block|}
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
operator|--
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline -.  */
operator|*
name|obp
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_space
index|[
operator|*
name|ibp
index|]
condition|)
block|{
comment|/* Newline Space does not prevent expansion of preceding token 	     so expand the preceding token and then come back.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
comment|/* If generating final output, newline space makes a space.  */
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
name|obp
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
comment|/* And Newline Newline makes a newline, so count it.  */
if|if
condition|(
name|obp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
block|{
comment|/* If expanding a macro arg, keep the newline space. 	       If the arg gets stringified, newline space makes nothing.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
name|abort
argument_list|()
expr_stmt|;
comment|/* Newline followed by something random?  */
break|break;
block|}
comment|/* If there is a pending identifier, handle it and come back here.  */
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
goto|goto
name|specialchar
goto|;
name|beg_of_line
operator|=
name|ibp
expr_stmt|;
comment|/* Update the line counts and output a #line if necessary.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|lineno
operator|!=
name|op
operator|->
name|lineno
condition|)
block|{
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
comment|/* Come here either after (1) a null character that is part of the input 	 or (2) at the end of the input, because there is a null there.  */
case|case
literal|0
case|:
if|if
condition|(
name|ibp
operator|<=
name|limit
condition|)
comment|/* Our input really contains a null character.  */
goto|goto
name|randomchar
goto|;
comment|/* At end of a macro-expansion level, pop it and read next level.  */
if|if
condition|(
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
comment|/* If traditional, and we have an identifier that ends here, 	   process it now, so we get the right error for recursion.  */
if|if
condition|(
name|traditional
operator|&&
name|ident_length
operator|&&
operator|!
name|is_idchar
index|[
operator|*
name|instack
index|[
name|indepth
operator|-
literal|1
index|]
operator|.
name|bufp
index|]
condition|)
block|{
name|redo_char
operator|=
literal|1
expr_stmt|;
goto|goto
name|randomchar
goto|;
block|}
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
comment|/* If we don't have a pending identifier, 	 return at end of input.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|--
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
goto|goto
name|ending
goto|;
block|}
comment|/* If we do have a pending identifier, just consider this null 	 a special character and arrange to dispatch on it again. 	 The second time, IDENT_LENGTH will be zero so we will return.  */
comment|/* Fall through */
name|specialchar
label|:
comment|/* Handle the case of a character such as /, ', " or null 	 seen following an identifier.  Back over it so that 	 after the identifier is processed the special char 	 will be dispatched on again.  */
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
name|redo_char
operator|=
literal|1
expr_stmt|;
default|default:
name|randomchar
label|:
if|if
condition|(
name|ident_length
operator|>
literal|0
condition|)
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
comment|/* We have just seen an identifier end.  If it's a macro, expand it.  	   IDENT_LENGTH is the length of the identifier 	   and HASH is its hash code.  	   The identifier has already been copied to the output, 	   so if it is a macro we must remove it.  	   If REDO_CHAR is 0, the char that terminated the identifier 	   has been skipped in the output and the input. 	   OBP-IDENT_LENGTH-1 points to the identifier. 	   If the identifier is a macro, we must back over the terminator.  	   If REDO_CHAR is 1, the terminating char has already been 	   backed over.  OBP-IDENT_LENGTH points to the identifier.  */
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|MAKE_POS
argument_list|(
name|hash
argument_list|)
operator|%
name|HASHSIZE
index|]
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|ident_length
condition|)
block|{
name|U_CHAR
modifier|*
name|obufp_before_macroname
decl_stmt|;
name|int
name|op_lineno_before_macroname
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|ident_length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|hp
operator|->
name|name
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|q
init|=
name|obp
operator|-
name|i
decl_stmt|;
name|int
name|disabled
decl_stmt|;
if|if
condition|(
operator|!
name|redo_char
condition|)
name|q
operator|--
expr_stmt|;
do|do
block|{
comment|/* All this to avoid a strncmp () */
if|if
condition|(
operator|*
name|p
operator|++
operator|!=
operator|*
name|q
operator|++
condition|)
goto|goto
name|hashcollision
goto|;
block|}
do|while
condition|(
operator|--
name|i
condition|)
do|;
comment|/* We found a use of a macro name. 	       see if the context shows it is a macro call.  */
comment|/* Back up over terminating character if not already done.  */
if|if
condition|(
operator|!
name|redo_char
condition|)
block|{
name|ibp
operator|--
expr_stmt|;
name|obp
operator|--
expr_stmt|;
block|}
name|obufp_before_macroname
operator|=
name|obp
operator|-
name|ident_length
expr_stmt|;
name|op_lineno_before_macroname
operator|=
name|op
operator|->
name|lineno
expr_stmt|;
comment|/* Record whether the macro is disabled.  */
name|disabled
operator|=
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
expr_stmt|;
comment|/* This looks like a macro ref, but if the macro was disabled, 	       just copy its name and put in a marker if requested.  */
if|if
condition|(
name|disabled
condition|)
block|{
if|#
directive|if
literal|0
comment|/* This error check caught useful cases such as 		 #define foo(x,y) bar(x(y,0), y) 		 foo(foo, baz)  */
block|if (traditional) 		error ("recursive use of macro `%s'", hp->name);
endif|#
directive|endif
if|if
condition|(
name|output_marks
condition|)
block|{
name|check_expand
argument_list|(
name|op
argument_list|,
name|limit
operator|-
name|ibp
operator|+
literal|2
argument_list|)
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'-'
expr_stmt|;
block|}
break|break;
block|}
comment|/* If macro wants an arglist, verify that a '(' follows. 	       first skip all whitespace, copying it to the output 	       after the macro name.  Then, if there is no '(', 	       decide this is not a macro call and leave things that way.  */
if|if
condition|(
operator|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
operator|||
name|hp
operator|->
name|type
operator|==
name|T_DISABLED
operator|)
operator|&&
name|hp
operator|->
name|value
operator|.
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Scan forward over whitespace, copying it to the output.  */
if|if
condition|(
name|ibp
operator|==
name|limit
operator|&&
name|ip
operator|->
name|macro
operator|!=
literal|0
condition|)
block|{
name|POPMACRO
expr_stmt|;
name|RECACHE
expr_stmt|;
block|}
comment|/* A comment: copy it unchanged or discard it.  */
elseif|else
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'/'
operator|&&
name|ibp
operator|+
literal|1
operator|!=
name|limit
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|ibp
operator|+
literal|1
operator|!=
name|limit
operator|&&
operator|!
operator|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* We need not worry about newline-marks, 			 since they are never found in comments.  */
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
if|if
condition|(
name|put_out_comments
condition|)
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
else|else
name|ibp
operator|++
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|put_out_comments
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
literal|'/'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|is_space
index|[
operator|*
name|ibp
index|]
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|ibp
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|macro
operator|==
literal|0
condition|)
block|{
comment|/* Newline in a file.  Count it.  */
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|output_marks
condition|)
block|{
comment|/* A newline mark, and we don't want marks 			   in the output.  If it is newline-hyphen, 			   discard it entirely.  Otherwise, it is 			   newline-whitechar, so keep the whitechar.  */
name|obp
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'-'
condition|)
name|ibp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* A newline mark; copy both chars to the output.  */
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|ibp
operator|!=
literal|'('
condition|)
break|break;
block|}
comment|/* This is now known to be a macro call. 	       Discard the macro name from the output, 	       along with any following whitespace just copied.  */
name|obp
operator|=
name|obufp_before_macroname
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|op_lineno_before_macroname
expr_stmt|;
comment|/* Expand the macro, reading arguments as needed, 	       and push the expansion on the input stack.  */
name|ip
operator|->
name|bufp
operator|=
name|ibp
expr_stmt|;
name|op
operator|->
name|bufp
operator|=
name|obp
expr_stmt|;
name|macroexpand
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
comment|/* Reexamine input stack, since macroexpand has pushed 	       a new level on it.  */
name|obp
operator|=
name|op
operator|->
name|bufp
expr_stmt|;
name|RECACHE
expr_stmt|;
break|break;
block|}
name|hashcollision
label|:
empty_stmt|;
block|}
comment|/* End hash-table-search loop */
name|ident_length
operator|=
name|hash
operator|=
literal|0
expr_stmt|;
comment|/* Stop collecting identifier */
name|redo_char
operator|=
literal|0
expr_stmt|;
name|concatenated
operator|=
literal|0
expr_stmt|;
block|}
comment|/* End if (ident_length> 0) */
block|}
comment|/* End switch */
block|}
comment|/* End per-char loop */
comment|/* Come here to return -- but first give an error message      if there was an unterminated successful conditional.  */
name|ending
label|:
if|if
condition|(
name|if_stack
operator|!=
name|ip
operator|->
name|if_stack
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
switch|switch
condition|(
name|if_stack
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
name|str
operator|=
literal|"if"
expr_stmt|;
break|break;
case|case
name|T_IFDEF
case|:
name|str
operator|=
literal|"ifdef"
expr_stmt|;
break|break;
case|case
name|T_IFNDEF
case|:
name|str
operator|=
literal|"ifndef"
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
name|str
operator|=
literal|"else"
expr_stmt|;
break|break;
case|case
name|T_ELIF
case|:
name|str
operator|=
literal|"elif"
expr_stmt|;
break|break;
block|}
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|if_stack
operator|->
name|lineno
argument_list|)
argument_list|,
literal|"unterminated #%s conditional"
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|=
name|ip
operator|->
name|if_stack
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Rescan a string into a temporary buffer and return the result  * as a FILE_BUF.  Note this function returns a struct, not a pointer.  *  * OUTPUT_MARKS nonzero means keep Newline markers found in the input  * and insert such markers when appropriate.  See `rescan' for details.  * OUTPUT_MARKS is 1 for macroexpanding a macro argument separately  * before substitution; it is 0 for other uses.  */
end_comment

begin_function
name|FILE_BUF
name|expand_to_temp_buffer
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|output_marks
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|limit
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|output_marks
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|FILE_BUF
name|obuf
decl_stmt|;
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|U_CHAR
modifier|*
name|buf1
decl_stmt|;
name|int
name|odepth
init|=
name|indepth
decl_stmt|;
if|if
condition|(
name|length
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Set up the input on the input stack.  */
name|buf1
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|buf1
decl_stmt|;
while|while
condition|(
name|p1
operator|!=
name|limit
condition|)
operator|*
name|p2
operator|++
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
block|}
name|buf1
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set up to receive the output.  */
name|obuf
operator|.
name|length
operator|=
name|length
operator|*
literal|2
operator|+
literal|100
expr_stmt|;
comment|/* Usually enough.  Why be stingy?  */
name|obuf
operator|.
name|bufp
operator|=
name|obuf
operator|.
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|obuf
operator|.
name|length
argument_list|)
expr_stmt|;
name|obuf
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|macro
operator|=
literal|0
expr_stmt|;
name|obuf
operator|.
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|{return obuf;}
argument_list|)
empty_stmt|;
operator|++
name|indepth
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|length
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf1
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
name|obuf
operator|.
name|lineno
operator|=
literal|1
expr_stmt|;
comment|/* Scan the input, create the output.  */
name|rescan
argument_list|(
operator|&
name|obuf
argument_list|,
name|output_marks
argument_list|)
expr_stmt|;
comment|/* Pop input stack to original state.  */
operator|--
name|indepth
expr_stmt|;
if|if
condition|(
name|indepth
operator|!=
name|odepth
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Record the output.  */
name|obuf
operator|.
name|length
operator|=
name|obuf
operator|.
name|bufp
operator|-
name|obuf
operator|.
name|buf
expr_stmt|;
return|return
name|obuf
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Process a # directive.  Expects IP->bufp to point to the '#', as in  * `#define foo bar'.  Passes to the command handler  * (do_define, do_include, etc.): the addresses of the 1st and  * last chars of the command (starting immediately after the #  * keyword), plus op and the keyword table pointer.  If the command  * contains comments it is copied into a temporary buffer sans comments  * and the temporary buffer is passed to the command handler instead.  * Likewise for backslash-newlines.  *  * Returns nonzero if this was a known # directive.  * Otherwise, returns zero, without advancing the input pointer.  */
end_comment

begin_function
name|int
name|handle_directive
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
specifier|register
name|int
name|ident_length
decl_stmt|;
name|U_CHAR
modifier|*
name|resume_p
decl_stmt|;
comment|/* Nonzero means we must copy the entire command      to get rid of comments or backslash-newlines.  */
name|int
name|copy_command
init|=
literal|0
decl_stmt|;
name|U_CHAR
modifier|*
name|ident
decl_stmt|,
modifier|*
name|after_ident
decl_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
operator|(
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
operator|,
name|bp
index|[
literal|1
index|]
operator|)
operator|==
literal|'*'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
comment|/* Now find end of directive name.      If we encounter a backslash-newline, exchange it with any following      symbol-constituents so that we end up with a contiguous name.  */
name|cp
operator|=
name|bp
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
name|cp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\\'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
index|[
operator|*
name|cp
index|]
condition|)
name|cp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
name|ident_length
operator|=
name|cp
operator|-
name|bp
expr_stmt|;
name|ident
operator|=
name|bp
expr_stmt|;
name|after_ident
operator|=
name|cp
expr_stmt|;
comment|/* A line of just `#' becomes blank.  */
if|if
condition|(
name|ident_length
operator|==
literal|0
operator|&&
operator|*
name|after_ident
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|after_ident
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/*    * Decode the keyword and call the appropriate expansion    * routine, after moving the input pointer up to the next line.    */
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>
literal|0
condition|;
name|kt
operator|++
control|)
block|{
if|if
condition|(
name|kt
operator|->
name|length
operator|==
name|ident_length
operator|&&
operator|!
name|strncmp
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|ident
argument_list|,
name|ident_length
argument_list|)
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|int
name|unterminated
init|=
literal|0
decl_stmt|;
comment|/* Nonzero means do not delete comments within the directive. 	 #define needs this when -traditional.  */
name|int
name|keep_comments
init|=
name|traditional
operator|&&
name|kt
operator|->
name|traditional_comments
decl_stmt|;
comment|/* Find the end of this command (first newline not backslashed 	 and not in a string or comment). 	 Set COPY_COMMAND if the command must be copied 	 (it contains a backslash-newline or a comment).  */
name|buf
operator|=
name|bp
operator|=
name|after_ident
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|bp
operator|++
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
if|if
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
name|copy_command
operator|=
literal|1
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|copy_command
argument_list|,
operator|&
name|unterminated
argument_list|)
expr_stmt|;
comment|/* Don't bother calling the directive if we already got an error 	     message due to unterminated string.  Skip everything and pretend 	     we called the directive.  */
if|if
condition|(
name|unterminated
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
comment|/* Traditional preprocessing permits unterminated strings.  */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
literal|1
return|;
block|}
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
name|kt
operator|->
name|angle_brackets
condition|)
break|break;
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|'>'
condition|)
name|bp
operator|++
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|U_CHAR
modifier|*
name|obp
init|=
name|bp
operator|-
literal|1
decl_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|+
literal|1
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|bp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* No need to copy the command because of a comment at the end; 	       just don't include the comment in the directive.  */
if|if
condition|(
name|bp
operator|==
name|limit
operator|||
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|=
name|obp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
comment|/* Don't remove the comments if -traditional.  */
if|if
condition|(
operator|!
name|keep_comments
condition|)
name|copy_command
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|--
name|bp
expr_stmt|;
comment|/* Point to the newline */
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
goto|goto
name|endloop1
goto|;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|endloop1
label|:
name|resume_p
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
comment|/* BP is the end of the directive. 	 RESUME_P is the next interesting data after the directive. 	 A comment may come between.  */
if|if
condition|(
name|copy_command
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|xp
init|=
name|buf
decl_stmt|;
comment|/* Need to copy entire command into temp buffer before dispatching */
name|cp
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|bp
operator|-
name|buf
operator|+
literal|5
argument_list|)
expr_stmt|;
comment|/* room for cmd plus 						  some slop */
name|buf
operator|=
name|cp
expr_stmt|;
comment|/* Copy to the new buffer, deleting comments 	   and backslash-newlines (and whitespace surrounding the latter).  */
while|while
condition|(
name|xp
operator|<
name|bp
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|xp
operator|++
decl_stmt|;
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
break|break;
comment|/*<...> is special for #include.  */
case|case
literal|'<'
case|:
if|if
condition|(
operator|!
name|kt
operator|->
name|angle_brackets
condition|)
break|break;
while|while
condition|(
name|xp
operator|<
name|bp
operator|&&
name|c
operator|!=
literal|'>'
condition|)
block|{
name|c
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|xp
operator|<
name|bp
operator|&&
operator|*
name|xp
operator|==
literal|'\n'
condition|)
name|xp
operator|++
operator|,
name|ip
operator|->
name|lineno
operator|++
expr_stmt|;
else|else
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'\n'
condition|)
block|{
name|xp
operator|++
expr_stmt|;
name|cp
operator|--
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|is_space
index|[
name|cp
index|[
operator|-
literal|1
index|]
index|]
condition|)
block|{
while|while
condition|(
name|cp
operator|!=
name|buf
operator|&&
name|is_space
index|[
name|cp
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|cp
operator|--
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|is_space
index|[
operator|*
name|xp
index|]
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|xp
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp1
init|=
name|skip_quoted_string
argument_list|(
name|xp
operator|-
literal|1
argument_list|,
name|limit
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
while|while
condition|(
name|xp
operator|!=
name|bp1
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|xp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus
operator|&&
operator|*
name|xp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
name|xp
operator|+
literal|1
expr_stmt|;
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|keep_comments
condition|)
while|while
condition|(
name|xp
operator|!=
name|ip
operator|->
name|bufp
condition|)
operator|*
name|cp
operator|++
operator|=
operator|*
name|xp
operator|++
expr_stmt|;
comment|/* Delete or replace the slash.  */
elseif|else
if|if
condition|(
name|traditional
condition|)
name|cp
operator|--
expr_stmt|;
else|else
name|cp
index|[
operator|-
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|xp
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
block|}
block|}
comment|/* Null-terminate the copy.  */
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
block|}
else|else
name|cp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|resume_p
expr_stmt|;
comment|/* Some directives should be written out for cc1 to process, 	 just as if they were not defined.  */
if|if
condition|(
name|kt
operator|->
name|pass_thru
condition|)
block|{
name|int
name|len
decl_stmt|;
comment|/* Output directive name.  */
name|check_expand
argument_list|(
name|op
argument_list|,
name|kt
operator|->
name|length
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'#'
expr_stmt|;
name|bcopy
argument_list|(
name|kt
operator|->
name|name
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|kt
operator|->
name|length
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|kt
operator|->
name|length
expr_stmt|;
comment|/* Output arguments.  */
name|len
operator|=
operator|(
name|cp
operator|-
name|buf
operator|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
block|}
comment|/* Call the appropriate command handler.  buf now points to 	 either the appropriate place in the input buffer, or to 	 the temp buffer if it was necessary to make one.  cp 	 points to the first char after the contents of the (possibly 	 copied) command, in either case. */
call|(
modifier|*
name|kt
operator|->
name|func
call|)
argument_list|(
name|buf
argument_list|,
name|cp
argument_list|,
name|op
argument_list|,
name|kt
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
return|return
literal|0
return|;
block|}
end_block

begin_escape
end_escape

begin_decl_stmt
specifier|static
name|char
modifier|*
name|monthnames
index|[]
init|=
block|{
literal|"Jan"
block|,
literal|"Feb"
block|,
literal|"Mar"
block|,
literal|"Apr"
block|,
literal|"May"
block|,
literal|"Jun"
block|,
literal|"Jul"
block|,
literal|"Aug"
block|,
literal|"Sep"
block|,
literal|"Oct"
block|,
literal|"Nov"
block|,
literal|"Dec"
block|, 			    }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * expand things like __FILE__.  Place the expansion into the output  * buffer *without* rescanning.  */
end_comment

begin_macro
name|special_symbol
argument_list|(
argument|hp
argument_list|,
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|buf
decl_stmt|;
name|time_t
name|t
decl_stmt|;
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
name|int
name|true_indepth
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
specifier|static
name|struct
name|tm
modifier|*
name|timebuf
init|=
name|NULL
decl_stmt|;
name|struct
name|tm
modifier|*
name|localtime
parameter_list|()
function_decl|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
comment|/* For special `defined' keyword */
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"cccp error: not in any file?!"
argument_list|)
expr_stmt|;
return|return;
comment|/* the show must go on */
block|}
switch|switch
condition|(
name|hp
operator|->
name|type
condition|)
block|{
case|case
name|T_FILE
case|:
case|case
name|T_BASE_FILE
case|:
block|{
name|char
modifier|*
name|string
decl_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_FILE
condition|)
name|string
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
else|else
name|string
operator|=
name|instack
index|[
literal|0
index|]
operator|.
name|fname
expr_stmt|;
if|if
condition|(
name|string
condition|)
block|{
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s\""
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
else|else
name|buf
operator|=
literal|"\"\""
expr_stmt|;
break|break;
block|}
case|case
name|T_INCLUDE_LEVEL
case|:
name|true_indepth
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
name|true_indepth
operator|++
expr_stmt|;
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|8
argument_list|)
expr_stmt|;
comment|/* Eigth bytes ought to be more than enough */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|true_indepth
operator|-
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_VERSION
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|3
operator|+
name|strlen
argument_list|(
name|version_string
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s\""
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CONST
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|hp
operator|->
name|value
operator|.
name|ival
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPECLINE
case|:
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%d"
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_DATE
case|:
case|case
name|T_TIME
case|:
if|if
condition|(
name|timebuf
operator|==
name|NULL
condition|)
block|{
name|t
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|timebuf
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
block|}
name|buf
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
literal|20
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_DATE
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%s %2d %4d\""
argument_list|,
name|monthnames
index|[
name|timebuf
operator|->
name|tm_mon
index|]
argument_list|,
name|timebuf
operator|->
name|tm_mday
argument_list|,
name|timebuf
operator|->
name|tm_year
operator|+
literal|1900
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"\"%02d:%02d:%02d\""
argument_list|,
name|timebuf
operator|->
name|tm_hour
argument_list|,
name|timebuf
operator|->
name|tm_min
argument_list|,
name|timebuf
operator|->
name|tm_sec
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SPEC_DEFINED
case|:
name|buf
operator|=
literal|" 0 "
expr_stmt|;
comment|/* Assume symbol is not defined */
name|ip
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|==
literal|'('
condition|)
block|{
name|paren
operator|++
expr_stmt|;
name|ip
operator|->
name|bufp
operator|++
expr_stmt|;
comment|/* Skip over the paren */
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|lookup
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
name|buf
operator|=
literal|" 1 "
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|ip
operator|->
name|bufp
index|]
condition|)
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
if|if
condition|(
name|paren
condition|)
block|{
if|if
condition|(
operator|*
name|ip
operator|->
name|bufp
operator|!=
literal|')'
condition|)
goto|goto
name|oops
goto|;
operator|++
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
break|break;
name|oops
label|:
name|error
argument_list|(
literal|"`defined' must be followed by ident or (ident)"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"cccp error: invalid special hash type"
argument_list|)
expr_stmt|;
comment|/* time for gdb */
name|abort
argument_list|()
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Routines to handle #directives */
end_comment

begin_comment
comment|/*  * Process include file by reading it in and calling rescan.  * Expects to see "fname" or<fname> on the input.  */
end_comment

begin_macro
name|do_include
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|fname
decl_stmt|;
comment|/* Dynamically allocated fname buffer */
name|U_CHAR
modifier|*
name|fbeg
decl_stmt|,
modifier|*
name|fend
decl_stmt|;
comment|/* Beginning and end of fname */
name|struct
name|file_name_list
modifier|*
name|stackp
init|=
name|include
decl_stmt|;
comment|/* Chain of dirs to search */
name|struct
name|file_name_list
name|dsp
index|[
literal|1
index|]
decl_stmt|;
comment|/* First in chain, if #include "..." */
name|int
name|flen
decl_stmt|;
name|int
name|f
decl_stmt|;
comment|/* file number */
name|int
name|retried
init|=
literal|0
decl_stmt|;
comment|/* Have already tried macro 				   expanding the include line*/
name|FILE_BUF
name|trybuf
decl_stmt|;
comment|/* It got expanded into here */
name|int
name|system_header_p
init|=
literal|0
decl_stmt|;
comment|/* 0 for "...", 1 for<...> */
name|f
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* JF we iz paranoid! */
name|get_filename
label|:
name|fbeg
operator|=
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|fbeg
argument_list|)
expr_stmt|;
comment|/* Discard trailing whitespace so we can easily see      if we have parsed all the significant chars we were given.  */
while|while
condition|(
name|limit
operator|!=
name|fbeg
operator|&&
name|is_hor_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
switch|switch
condition|(
operator|*
name|fbeg
operator|++
condition|)
block|{
case|case
literal|'\"'
case|:
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|*
name|fend
operator|!=
literal|'\"'
condition|)
name|fend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'\"'
operator|&&
name|fend
operator|+
literal|1
operator|==
name|limit
condition|)
block|{
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* We have "filename".  Figure out directory this source 	 file is coming from and put it on the front of the list. */
comment|/* If -I- was specified, don't search current dir, only spec'd ones. */
if|if
condition|(
name|ignore_srcdir
condition|)
break|break;
for|for
control|(
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
index|]
init|;
name|fp
operator|>=
name|instack
condition|;
name|fp
operator|--
control|)
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|,
modifier|*
name|nam
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
if|if
condition|(
operator|(
name|nam
operator|=
name|fp
operator|->
name|fname
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Found a named file.  Figure out dir of the file, 	       and put it in front of the search list.  */
name|dsp
index|[
literal|0
index|]
operator|.
name|next
operator|=
name|stackp
expr_stmt|;
name|stackp
operator|=
name|dsp
expr_stmt|;
ifndef|#
directive|ifndef
name|VMS
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* VMS */
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|rindex
argument_list|(
name|nam
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
name|ep
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
name|ep
operator|!=
name|NULL
condition|)
block|{
name|n
operator|=
name|ep
operator|-
name|nam
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
argument_list|,
name|nam
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
index|[
name|n
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|n
operator|>
name|max_include_len
condition|)
name|max_include_len
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|dsp
index|[
literal|0
index|]
operator|.
name|fname
operator|=
literal|0
expr_stmt|;
comment|/* Current directory */
block|}
break|break;
block|}
block|}
break|break;
block|}
goto|goto
name|fail
goto|;
case|case
literal|'<'
case|:
name|fend
operator|=
name|fbeg
expr_stmt|;
while|while
condition|(
name|fend
operator|!=
name|limit
operator|&&
operator|*
name|fend
operator|!=
literal|'>'
condition|)
name|fend
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|fend
operator|==
literal|'>'
operator|&&
name|fend
operator|+
literal|1
operator|==
name|limit
condition|)
block|{
name|system_header_p
operator|=
literal|1
expr_stmt|;
comment|/* If -I-, start with the first -I dir after the -I-.  */
if|if
condition|(
name|first_bracket_include
condition|)
name|stackp
operator|=
name|first_bracket_include
expr_stmt|;
break|break;
block|}
goto|goto
name|fail
goto|;
default|default:
name|fail
label|:
if|if
condition|(
name|retried
condition|)
block|{
name|error
argument_list|(
literal|"#include expects \"fname\" or<fname>"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|trybuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|,
name|buf
argument_list|,
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|limit
operator|=
name|buf
operator|+
operator|(
name|trybuf
operator|.
name|bufp
operator|-
name|trybuf
operator|.
name|buf
operator|)
expr_stmt|;
name|free
argument_list|(
name|trybuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|retried
operator|++
expr_stmt|;
goto|goto
name|get_filename
goto|;
block|}
block|}
name|flen
operator|=
name|fend
operator|-
name|fbeg
expr_stmt|;
name|fname
operator|=
operator|(
name|char
operator|*
operator|)
name|alloca
argument_list|(
name|max_include_len
operator|+
name|flen
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* + 2 above for slash and terminating null.  */
comment|/* If specified file name is absolute, just open it.  */
if|if
condition|(
operator|*
name|fbeg
operator|==
literal|'/'
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Search directory path, trying to open the file.        Copy each filename tried into FNAME.  */
for|for
control|(
init|;
name|stackp
condition|;
name|stackp
operator|=
name|stackp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|stackp
operator|->
name|fname
condition|)
block|{
name|strcpy
argument_list|(
name|fname
argument_list|,
name|stackp
operator|->
name|fname
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|fname
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|fname
index|[
name|strlen
argument_list|(
name|fname
argument_list|)
operator|+
name|flen
index|]
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|fname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|strncat
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
comment|/* Change this 1/2 Unix 1/2 VMS file specification into a          full VMS file specification */
if|if
condition|(
name|stackp
operator|->
name|fname
operator|&&
operator|(
name|stackp
operator|->
name|fname
index|[
literal|0
index|]
operator|!=
literal|0
operator|)
condition|)
block|{
comment|/* Fix up the filename */
name|hack_vms_include_specification
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* This is a normal VMS filespec, so use it unchanged.  */
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* VMS */
if|if
condition|(
operator|(
name|f
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|,
literal|0666
argument_list|)
operator|)
operator|>=
literal|0
condition|)
break|break;
block|}
block|}
if|if
condition|(
name|f
operator|<
literal|0
condition|)
block|{
name|strncpy
argument_list|(
name|fname
argument_list|,
name|fbeg
argument_list|,
name|flen
argument_list|)
expr_stmt|;
name|fname
index|[
name|flen
index|]
operator|=
literal|0
expr_stmt|;
name|error_from_errno
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* For -M, add this file to the dependencies.  */
if|if
condition|(
name|print_deps
operator|>
operator|(
name|system_header_p
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|system_header_p
condition|)
name|warning
argument_list|(
literal|"nonexistent file<%.*s> omitted from dependency output"
argument_list|,
name|fend
operator|-
name|fbeg
argument_list|,
name|fbeg
argument_list|)
expr_stmt|;
else|else
block|{
name|deps_output
argument_list|(
name|fbeg
argument_list|,
name|fend
operator|-
name|fbeg
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Check to see if this include file is a once-only include file.        If so, give up.  */
name|struct
name|file_name_list
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|dont_repeat_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
block|{
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
comment|/* This file was once'd. */
block|}
block|}
for|for
control|(
name|ptr
operator|=
name|all_include_files
init|;
name|ptr
condition|;
name|ptr
operator|=
name|ptr
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|ptr
operator|->
name|fname
argument_list|,
name|fname
argument_list|)
condition|)
break|break;
comment|/* This file was included before. */
block|}
if|if
condition|(
name|ptr
operator|==
literal|0
condition|)
block|{
comment|/* This is the first time for this file.  */
comment|/* Add it to list of files included.  */
name|ptr
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|all_include_files
expr_stmt|;
name|all_include_files
operator|=
name|ptr
expr_stmt|;
name|ptr
operator|->
name|fname
operator|=
name|savestring
argument_list|(
name|fname
argument_list|)
expr_stmt|;
comment|/* For -M, add this file to the dependencies.  */
if|if
condition|(
name|print_deps
operator|>
operator|(
name|system_header_p
operator|||
operator|(
name|system_include_depth
operator|>
literal|0
operator|)
operator|)
condition|)
block|{
name|deps_output
argument_list|(
name|fname
argument_list|,
name|strlen
argument_list|(
name|fname
argument_list|)
argument_list|)
expr_stmt|;
name|deps_output
argument_list|(
literal|" "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|system_header_p
condition|)
name|system_include_depth
operator|++
expr_stmt|;
comment|/* Actually process the file.  */
name|finclude
argument_list|(
name|f
argument_list|,
name|fname
argument_list|,
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|system_header_p
condition|)
name|system_include_depth
operator|--
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Process the contents of include file FNAME, already open on descriptor F,    with output to OP.  */
end_comment

begin_macro
name|finclude
argument_list|(
argument|f
argument_list|,
argument|fname
argument_list|,
argument|op
argument_list|)
end_macro

begin_decl_stmt
name|int
name|f
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|st_mode
decl_stmt|;
name|long
name|st_size
decl_stmt|;
name|long
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|fp
decl_stmt|;
comment|/* For input stack frame */
name|int
name|success
init|=
literal|0
decl_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
if|if
condition|(
name|file_size_and_mode
argument_list|(
name|f
argument_list|,
operator|&
name|st_mode
argument_list|,
operator|&
name|st_size
argument_list|)
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* Impossible? */
name|fp
operator|=
operator|&
name|instack
index|[
name|indepth
operator|+
literal|1
index|]
expr_stmt|;
name|bzero
argument_list|(
name|fp
argument_list|,
sizeof|sizeof
argument_list|(
name|FILE_BUF
argument_list|)
argument_list|)
expr_stmt|;
name|fp
operator|->
name|fname
operator|=
name|fname
expr_stmt|;
name|fp
operator|->
name|length
operator|=
literal|0
expr_stmt|;
name|fp
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|fp
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
if|if
condition|(
name|S_ISREG
argument_list|(
name|st_mode
argument_list|)
condition|)
block|{
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
comment|/* Read the file contents, knowing that st_size is an upper bound        on the number of bytes we can read.  */
while|while
condition|(
name|st_size
operator|>
literal|0
condition|)
block|{
name|i
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|fp
operator|->
name|buf
operator|+
name|fp
operator|->
name|length
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
goto|goto
name|nope
goto|;
block|}
name|fp
operator|->
name|length
operator|+=
name|i
expr_stmt|;
name|st_size
operator|-=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Cannot count its file size before reading.        First read the entire file into heap and        copy them into buffer on stack. */
name|U_CHAR
modifier|*
name|bufp
decl_stmt|;
name|U_CHAR
modifier|*
name|basep
decl_stmt|;
name|int
name|bsize
init|=
literal|2000
decl_stmt|;
name|st_size
operator|=
literal|0
expr_stmt|;
name|basep
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|basep
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|i
operator|=
name|read
argument_list|(
name|f
argument_list|,
name|bufp
argument_list|,
name|bsize
operator|-
name|st_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
goto|goto
name|nope
goto|;
comment|/* error! */
if|if
condition|(
name|i
operator|==
literal|0
condition|)
break|break;
comment|/* End of file */
name|st_size
operator|+=
name|i
expr_stmt|;
name|bufp
operator|+=
name|i
expr_stmt|;
if|if
condition|(
name|bsize
operator|==
name|st_size
condition|)
block|{
comment|/* Buffer is full! */
name|bsize
operator|*=
literal|2
expr_stmt|;
name|basep
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|basep
argument_list|,
name|bsize
operator|+
literal|2
argument_list|)
expr_stmt|;
name|bufp
operator|=
name|basep
operator|+
name|st_size
expr_stmt|;
comment|/* May have moved */
block|}
block|}
name|fp
operator|->
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|st_size
operator|+
literal|2
argument_list|)
expr_stmt|;
name|fp
operator|->
name|bufp
operator|=
name|fp
operator|->
name|buf
expr_stmt|;
name|bcopy
argument_list|(
name|basep
argument_list|,
name|fp
operator|->
name|buf
argument_list|,
name|st_size
argument_list|)
expr_stmt|;
name|fp
operator|->
name|length
operator|=
name|st_size
expr_stmt|;
name|free
argument_list|(
name|basep
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|no_trigraphs
condition|)
name|trigraph_pcp
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|length
operator|>
literal|0
operator|&&
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|fp
operator|->
name|buf
index|[
name|fp
operator|->
name|length
index|]
operator|=
literal|'\0'
expr_stmt|;
name|success
operator|=
literal|1
expr_stmt|;
name|indepth
operator|++
expr_stmt|;
name|output_line_command
argument_list|(
name|fp
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|enter_file
argument_list|)
expr_stmt|;
name|rescan
argument_list|(
name|op
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|indepth
operator|--
expr_stmt|;
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|leave_file
argument_list|)
expr_stmt|;
name|nope
label|:
if|if
condition|(
operator|!
name|success
condition|)
name|perror_with_name
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* The arglist structure is built by do_define to tell    collect_definition where the argument names begin.  That    is, for a define like "#define f(x,y,z) foo+x-bar*y", the arglist    would contain pointers to the strings x, y, and z.    Collect_definition would then build a DEFINITION node,    with reflist nodes pointing to the places x, y, and z had    appeared.  So the arglist is just convenience data passed    between these two routines.  It is not kept around after    the current #define has been processed and entered into the    hash table. */
end_comment

begin_struct
struct|struct
name|arglist
block|{
name|struct
name|arglist
modifier|*
name|next
decl_stmt|;
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|argno
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Process a #define command. BUF points to the contents of the #define command, as a continguous string. LIMIT points to the first character past the end of the definition. KEYWORD is the keyword-table entry for #define.  */
end_comment

begin_macro
name|do_define
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
comment|/* temp ptr into input buffer */
name|U_CHAR
modifier|*
name|symname
decl_stmt|;
comment|/* remember where symbol name starts */
name|int
name|sym_length
decl_stmt|;
comment|/* and how long it is */
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
name|int
name|arglengths
init|=
literal|0
decl_stmt|;
comment|/* Accumulate lengths of arg names 				   plus number of args.  */
name|int
name|hashcode
decl_stmt|;
name|bp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
name|symname
operator|=
name|bp
expr_stmt|;
comment|/* remember where it starts */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
operator|&&
name|bp
operator|<
name|limit
condition|)
block|{
name|bp
operator|++
expr_stmt|;
block|}
name|sym_length
operator|=
name|bp
operator|-
name|symname
expr_stmt|;
if|if
condition|(
name|sym_length
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"invalid macro name"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|symname
index|]
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain... */
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sym_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|symname
argument_list|,
name|msg
argument_list|,
name|sym_length
argument_list|)
expr_stmt|;
name|msg
index|[
name|sym_length
index|]
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
literal|"invalid macro name `%s'"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|symname
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|&&
name|sym_length
operator|==
literal|7
condition|)
name|error
argument_list|(
literal|"defining `defined' as a macro"
argument_list|)
expr_stmt|;
block|}
comment|/* lossage will occur if identifiers or control keywords are broken      across lines using backslash.  This is not the right place to take      care of that. */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'('
condition|)
block|{
name|struct
name|arglist
modifier|*
name|arg_ptrs
init|=
name|NULL
decl_stmt|;
name|int
name|argno
init|=
literal|0
decl_stmt|;
name|bp
operator|++
expr_stmt|;
comment|/* skip '(' */
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Loop over macro argument names.  */
while|while
condition|(
operator|*
name|bp
operator|!=
literal|')'
condition|)
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
expr|struct
name|arglist
operator|*
operator|)
name|alloca
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|arglist
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|name
operator|=
name|bp
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|arg_ptrs
expr_stmt|;
name|temp
operator|->
name|argno
operator|=
name|argno
operator|++
expr_stmt|;
name|arg_ptrs
operator|=
name|temp
expr_stmt|;
if|if
condition|(
operator|!
name|is_idstart
index|[
operator|*
name|bp
index|]
condition|)
name|warning
argument_list|(
literal|"parameter name starts with a digit in #define"
argument_list|)
expr_stmt|;
comment|/* Find the end of the arg name.  */
while|while
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
block|{
name|bp
operator|++
expr_stmt|;
block|}
name|temp
operator|->
name|length
operator|=
name|bp
operator|-
name|temp
operator|->
name|name
expr_stmt|;
name|arglengths
operator|+=
name|temp
operator|->
name|length
operator|+
literal|2
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|length
operator|==
literal|0
operator|||
operator|(
operator|*
name|bp
operator|!=
literal|','
operator|&&
operator|*
name|bp
operator|!=
literal|')'
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"badly punctuated parameter list in #define"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|','
condition|)
block|{
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error
argument_list|(
literal|"unterminated parameter list in #define"
argument_list|)
expr_stmt|;
goto|goto
name|nope
goto|;
block|}
block|}
operator|++
name|bp
expr_stmt|;
comment|/* skip paren */
comment|/* Skip exactly one space or tab if any.  */
if|if
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|(
operator|*
name|bp
operator|==
literal|' '
operator|||
operator|*
name|bp
operator|==
literal|'\t'
operator|)
condition|)
operator|++
name|bp
expr_stmt|;
comment|/* now everything from bp before limit is the definition. */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
name|argno
argument_list|,
name|arg_ptrs
argument_list|)
expr_stmt|;
comment|/* Now set defn->argnames to the result of concatenating        the argument names in reverse order        with comma-space between them.  */
name|defn
operator|->
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|arglengths
operator|+
literal|1
argument_list|)
expr_stmt|;
block|{
name|struct
name|arglist
modifier|*
name|temp
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|;
for|for
control|(
name|temp
operator|=
name|arg_ptrs
init|;
name|temp
condition|;
name|temp
operator|=
name|temp
operator|->
name|next
control|)
block|{
name|bcopy
argument_list|(
name|temp
operator|->
name|name
argument_list|,
operator|&
name|defn
operator|->
name|argnames
index|[
name|i
index|]
argument_list|,
name|temp
operator|->
name|length
argument_list|)
expr_stmt|;
name|i
operator|+=
name|temp
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|next
operator|!=
literal|0
condition|)
block|{
name|defn
operator|->
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|','
expr_stmt|;
name|defn
operator|->
name|argnames
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|defn
operator|->
name|argnames
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* simple expansion or empty definition; gobble it */
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
operator|++
name|bp
expr_stmt|;
comment|/* skip exactly one blank/tab char */
comment|/* now everything from bp before limit is the definition. */
name|defn
operator|=
name|collect_expansion
argument_list|(
name|bp
argument_list|,
name|limit
argument_list|,
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|defn
operator|->
name|argnames
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
block|}
name|hashcode
operator|=
name|hashf
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
if|if
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|hashcode
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
operator|||
name|compare_defs
argument_list|(
name|defn
argument_list|,
name|hp
operator|->
name|value
operator|.
name|defn
argument_list|)
condition|)
block|{
name|U_CHAR
modifier|*
name|msg
decl_stmt|;
comment|/* what pain... */
name|msg
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|sym_length
operator|+
literal|20
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|symname
argument_list|,
name|msg
argument_list|,
name|sym_length
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|msg
operator|+
name|sym_length
operator|)
argument_list|,
literal|" redefined"
argument_list|)
expr_stmt|;
name|warning
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
comment|/* Replace the old definition.  */
name|hp
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|defn
operator|=
name|defn
expr_stmt|;
block|}
else|else
name|install
argument_list|(
name|symname
argument_list|,
name|sym_length
argument_list|,
name|T_MACRO
argument_list|,
name|defn
argument_list|,
name|hashcode
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
name|nope
label|:
return|return
literal|1
return|;
block|}
end_block

begin_comment
comment|/*  * return zero if two DEFINITIONs are isomorphic  */
end_comment

begin_function
name|int
name|compare_defs
parameter_list|(
name|d1
parameter_list|,
name|d2
parameter_list|)
name|DEFINITION
modifier|*
name|d1
decl_stmt|,
decl|*
name|d2
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|struct
name|reflist
modifier|*
name|a1
decl_stmt|,
modifier|*
name|a2
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|d1
operator|->
name|expansion
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p2
init|=
name|d2
operator|->
name|expansion
decl_stmt|;
name|int
name|first
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|d1
operator|->
name|nargs
operator|!=
name|d2
operator|->
name|nargs
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|d1
operator|->
name|argnames
argument_list|,
operator|(
name|char
operator|*
operator|)
name|d2
operator|->
name|argnames
argument_list|)
condition|)
return|return
literal|1
return|;
for|for
control|(
name|a1
operator|=
name|d1
operator|->
name|pattern
operator|,
name|a2
operator|=
name|d2
operator|->
name|pattern
init|;
name|a1
operator|&&
name|a2
condition|;
name|a1
operator|=
name|a1
operator|->
name|next
operator|,
name|a2
operator|=
name|a2
operator|->
name|next
control|)
block|{
if|if
condition|(
operator|!
operator|(
operator|(
name|a1
operator|->
name|nchars
operator|==
name|a2
operator|->
name|nchars
operator|&&
operator|!
name|strncmp
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|,
name|a1
operator|->
name|nchars
argument_list|)
operator|)
operator|||
operator|!
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|a1
operator|->
name|nchars
argument_list|,
name|p2
argument_list|,
name|a2
operator|->
name|nchars
argument_list|,
literal|0
argument_list|)
operator|)
operator|||
name|a1
operator|->
name|argno
operator|!=
name|a2
operator|->
name|argno
operator|||
name|a1
operator|->
name|stringify
operator|!=
name|a2
operator|->
name|stringify
operator|||
name|a1
operator|->
name|raw_before
operator|!=
name|a2
operator|->
name|raw_before
operator|||
name|a1
operator|->
name|raw_after
operator|!=
name|a2
operator|->
name|raw_after
condition|)
return|return
literal|1
return|;
name|first
operator|=
literal|0
expr_stmt|;
name|p1
operator|+=
name|a1
operator|->
name|nchars
expr_stmt|;
name|p2
operator|+=
name|a2
operator|->
name|nchars
expr_stmt|;
block|}
if|if
condition|(
name|a1
operator|!=
name|a2
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|comp_def_part
argument_list|(
name|first
argument_list|,
name|p1
argument_list|,
name|d1
operator|->
name|length
operator|-
operator|(
name|p1
operator|-
name|d1
operator|->
name|expansion
operator|)
argument_list|,
name|p2
argument_list|,
name|d2
operator|->
name|length
operator|-
operator|(
name|p2
operator|-
name|d2
operator|->
name|expansion
operator|)
argument_list|,
literal|1
argument_list|)
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return 1 if two parts of two macro definitions are effectively different.    One of the parts starts at BEG1 and has LEN1 chars;    the other has LEN2 chars at BEG2.    Any sequence of whitespace matches any other sequence of whitespace.    FIRST means these parts are the first of a macro definition;     so ignore leading whitespace entirely.    LAST means these parts are the last of a macro definition;     so ignore trailing whitespace entirely.  */
end_comment

begin_macro
name|comp_def_part
argument_list|(
argument|first
argument_list|,
argument|beg1
argument_list|,
argument|len1
argument_list|,
argument|beg2
argument_list|,
argument|len2
argument_list|,
argument|last
argument_list|)
end_macro

begin_decl_stmt
name|int
name|first
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|U_CHAR
modifier|*
name|beg1
decl_stmt|,
modifier|*
name|beg2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|last
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|end1
init|=
name|beg1
operator|+
name|len1
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|end2
init|=
name|beg2
operator|+
name|len2
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|last
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
name|end1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end1
operator|--
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
name|end2
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|end2
operator|--
expr_stmt|;
block|}
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|beg2
operator|!=
name|end2
condition|)
block|{
if|if
condition|(
name|is_space
index|[
operator|*
name|beg1
index|]
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
block|{
while|while
condition|(
name|beg1
operator|!=
name|end1
operator|&&
name|is_space
index|[
operator|*
name|beg1
index|]
condition|)
name|beg1
operator|++
expr_stmt|;
while|while
condition|(
name|beg2
operator|!=
name|end2
operator|&&
name|is_space
index|[
operator|*
name|beg2
index|]
condition|)
name|beg2
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|beg1
operator|==
operator|*
name|beg2
condition|)
block|{
name|beg1
operator|++
expr_stmt|;
name|beg2
operator|++
expr_stmt|;
block|}
else|else
break|break;
block|}
return|return
operator|(
name|beg1
operator|!=
name|end1
operator|)
operator|||
operator|(
name|beg2
operator|!=
name|end2
operator|)
return|;
block|}
end_block

begin_comment
comment|/* Read a replacement list for a macro with parameters.    Build the DEFINITION structure.    Reads characters of text starting at BUF until LIMIT.    ARGLIST specifies the formal parameters to look for    in the text of the definition; NARGS is the number of args    in that list, or -1 for a macro name that wants no argument list.    MACRONAME is the macro name itself (so we can avoid recursive expansion)    and NAMELEN is its length in characters.     Note that comments and backslash-newlines have already been deleted from the argument.  */
end_comment

begin_comment
comment|/* Leading and trailing Space, Tab, etc. are converted to markers    Newline Space, Newline Tab, etc.    Newline Space makes a space in the final output    but is discarded if stringified.  (Newline Tab is similar but    makes a Tab instead.)     If there is no trailing whitespace, a Newline Space is added at the end    to prevent concatenation that would be contrary to the standard.  */
end_comment

begin_function
name|DEFINITION
modifier|*
name|collect_expansion
parameter_list|(
name|buf
parameter_list|,
name|end
parameter_list|,
name|nargs
parameter_list|,
name|arglist
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
decl|*
name|end
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|nargs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|arglist
modifier|*
name|arglist
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|limit
decl_stmt|,
modifier|*
name|lastp
decl_stmt|,
modifier|*
name|exp_p
decl_stmt|;
name|struct
name|reflist
modifier|*
name|endpat
init|=
name|NULL
decl_stmt|;
comment|/* Pointer to first nonspace after last ## seen.  */
name|U_CHAR
modifier|*
name|concat
init|=
literal|0
decl_stmt|;
comment|/* Pointer to first nonspace after last single-# seen.  */
name|U_CHAR
modifier|*
name|stringify
init|=
literal|0
decl_stmt|;
name|int
name|maxsize
decl_stmt|;
name|int
name|expected_delimiter
init|=
literal|'\0'
decl_stmt|;
comment|/* Scan thru the replacement list, ignoring comments and quoted      strings, picking up on the macro calls.  It does a linear search      thru the arg list on every potential symbol.  Profiling might say      that something smarter should happen. */
if|if
condition|(
name|end
operator|<
name|buf
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* Find the beginning of the trailing whitespace.  */
comment|/* Find end of leading whitespace.  */
name|limit
operator|=
name|end
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
comment|/* Allocate space for the text in the macro definition.      Leading and trailing whitespace chars need 2 bytes each.      Each other input char may or may not need 1 byte,      so this is an upper bound.      The extra 2 are for invented trailing newline-marker and final null.  */
name|maxsize
operator|=
operator|(
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
operator|+
literal|2
operator|*
operator|(
name|end
operator|-
name|limit
operator|)
operator|+
literal|2
operator|*
operator|(
name|p
operator|-
name|buf
operator|)
operator|+
operator|(
name|limit
operator|-
name|p
operator|)
operator|+
literal|3
operator|)
expr_stmt|;
name|defn
operator|=
operator|(
name|DEFINITION
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
name|maxsize
argument_list|)
expr_stmt|;
name|defn
operator|->
name|nargs
operator|=
name|nargs
expr_stmt|;
name|exp_p
operator|=
name|defn
operator|->
name|expansion
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|defn
operator|+
sizeof|sizeof
argument_list|(
name|DEFINITION
argument_list|)
expr_stmt|;
name|lastp
operator|=
name|exp_p
expr_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
comment|/* Convert leading whitespace to Newline-markers.  */
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
name|is_space
index|[
operator|*
name|p
index|]
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|+
literal|1
operator|<
name|limit
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
block|{
name|error
argument_list|(
literal|"## operator at start of macro definition"
argument_list|)
expr_stmt|;
name|p
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Process the main body of the definition.  */
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
name|int
name|skipped_arg
init|=
literal|0
decl_stmt|;
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|p
operator|++
decl_stmt|;
operator|*
name|exp_p
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
for|for
control|(
init|;
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|!=
name|c
condition|;
name|p
operator|++
control|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
operator|++
name|p
expr_stmt|;
block|}
block|}
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
break|break;
comment|/* Special hack: if a \# is written in the #define 	   include a # in the definition.  This is useless for C code 	   but useful for preprocessing other things.  */
case|case
literal|'\\'
case|:
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
comment|/* Pass through this # */
name|exp_p
operator|--
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|<
name|limit
condition|)
block|{
comment|/* Otherwise backslash goes through but makes next char ordinary.  */
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'#'
case|:
if|if
condition|(
name|p
operator|<
name|limit
operator|&&
operator|*
name|p
operator|==
literal|'#'
condition|)
block|{
comment|/* ##: concatenate preceding and following tokens.  */
comment|/* Take out the first #, discard preceding whitespace.  */
name|exp_p
operator|--
expr_stmt|;
while|while
condition|(
name|exp_p
operator|>
name|lastp
operator|&&
name|is_hor_space
index|[
name|exp_p
index|[
operator|-
literal|1
index|]
index|]
condition|)
operator|--
name|exp_p
expr_stmt|;
comment|/* Skip the second #.  */
name|p
operator|++
expr_stmt|;
comment|/* Discard following whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|concat
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|limit
operator|<=
name|p
condition|)
name|error
argument_list|(
literal|"## operator at end of macro definition"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Single #: stringify following argument ref. 	     Don't leave the # in the expansion.  */
name|exp_p
operator|--
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|limit
operator|||
operator|!
name|is_idstart
index|[
operator|*
name|p
index|]
operator|||
name|nargs
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"# operator should be followed by a macro argument name"
argument_list|)
expr_stmt|;
else|else
name|stringify
operator|=
name|p
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
comment|/* In -traditional mode, recognize arguments inside strings and 	 and character constants, and ignore special properties of #. 	 Arguments inside strings are considered "stringified", but no 	 extra quote marks are supplied.  */
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|expected_delimiter
condition|)
name|expected_delimiter
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|expected_delimiter
operator|=
name|c
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Backslash quotes delimiters and itself, but not macro args.  */
if|if
condition|(
name|expected_delimiter
operator|!=
literal|0
operator|&&
name|p
operator|<
name|limit
operator|&&
operator|(
operator|*
name|p
operator|==
name|expected_delimiter
operator|||
operator|*
name|p
operator|==
literal|'\\'
operator|)
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|expected_delimiter
operator|!=
literal|'\0'
condition|)
comment|/* No comments inside strings.  */
break|break;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
condition|)
block|{
comment|/* If we find a comment that wasn't removed by handle_directive, 	     this must be -traditional.  So replace the comment with 	     nothing at all.  */
name|exp_p
operator|--
expr_stmt|;
name|p
operator|+=
literal|1
expr_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
operator|&&
operator|!
operator|(
name|p
index|[
operator|-
literal|2
index|]
operator|==
literal|'*'
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|p
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* Mark this as a concatenation-point, as if it had been ##.  */
block|concat = p;
endif|#
directive|endif
block|}
break|break;
block|}
block|}
if|if
condition|(
name|is_idchar
index|[
name|c
index|]
operator|&&
name|nargs
operator|>
literal|0
condition|)
block|{
name|U_CHAR
modifier|*
name|id_beg
init|=
name|p
operator|-
literal|1
decl_stmt|;
name|int
name|id_len
decl_stmt|;
operator|--
name|exp_p
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|limit
operator|&&
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|id_len
operator|=
name|p
operator|-
name|id_beg
expr_stmt|;
if|if
condition|(
name|is_idstart
index|[
name|c
index|]
condition|)
block|{
specifier|register
name|struct
name|arglist
modifier|*
name|arg
decl_stmt|;
for|for
control|(
name|arg
operator|=
name|arglist
init|;
name|arg
operator|!=
name|NULL
condition|;
name|arg
operator|=
name|arg
operator|->
name|next
control|)
block|{
name|struct
name|reflist
modifier|*
name|tpat
decl_stmt|;
if|if
condition|(
name|arg
operator|->
name|name
index|[
literal|0
index|]
operator|==
name|c
operator|&&
name|arg
operator|->
name|length
operator|==
name|id_len
operator|&&
name|strncmp
argument_list|(
name|arg
operator|->
name|name
argument_list|,
name|id_beg
argument_list|,
name|id_len
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* make a pat node for this arg and append it to the end of 	       the pat list */
name|tpat
operator|=
operator|(
expr|struct
name|reflist
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|reflist
argument_list|)
argument_list|)
expr_stmt|;
name|tpat
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|tpat
operator|->
name|raw_before
operator|=
name|concat
operator|==
name|id_beg
expr_stmt|;
name|tpat
operator|->
name|raw_after
operator|=
literal|0
expr_stmt|;
name|tpat
operator|->
name|stringify
operator|=
operator|(
name|traditional
condition|?
name|expected_delimiter
operator|!=
literal|'\0'
else|:
name|stringify
operator|==
name|id_beg
operator|)
expr_stmt|;
if|if
condition|(
name|endpat
operator|==
name|NULL
condition|)
name|defn
operator|->
name|pattern
operator|=
name|tpat
expr_stmt|;
else|else
name|endpat
operator|->
name|next
operator|=
name|tpat
expr_stmt|;
name|endpat
operator|=
name|tpat
expr_stmt|;
name|tpat
operator|->
name|argno
operator|=
name|arg
operator|->
name|argno
expr_stmt|;
name|tpat
operator|->
name|nchars
operator|=
name|exp_p
operator|-
name|lastp
expr_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p1
init|=
name|p
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|+
literal|2
operator|<=
name|limit
operator|&&
name|p1
index|[
literal|0
index|]
operator|==
literal|'#'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'#'
condition|)
name|tpat
operator|->
name|raw_after
operator|=
literal|1
expr_stmt|;
block|}
name|lastp
operator|=
name|exp_p
expr_stmt|;
comment|/* place to start copying from next time */
name|skipped_arg
operator|=
literal|1
expr_stmt|;
break|break;
block|}
block|}
block|}
comment|/* If this was not a macro arg, copy it into the expansion.  */
if|if
condition|(
operator|!
name|skipped_arg
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|lim1
init|=
name|p
decl_stmt|;
name|p
operator|=
name|id_beg
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|lim1
condition|)
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|stringify
operator|==
name|id_beg
condition|)
name|error
argument_list|(
literal|"# operator should be followed by a macro argument name"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|limit
operator|<
name|end
condition|)
block|{
comment|/* Convert trailing whitespace to Newline-markers.  */
while|while
condition|(
name|limit
operator|<
name|end
operator|&&
name|is_space
index|[
operator|*
name|limit
index|]
condition|)
block|{
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
operator|*
name|limit
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
comment|/* There is no trailing whitespace, so invent some.  */
operator|*
name|exp_p
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|exp_p
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|exp_p
operator|=
literal|'\0'
expr_stmt|;
name|defn
operator|->
name|length
operator|=
name|exp_p
operator|-
name|defn
operator|->
name|expansion
expr_stmt|;
comment|/* Crash now if we overrun the allocated size.  */
if|if
condition|(
name|defn
operator|->
name|length
operator|+
literal|1
operator|>
name|maxsize
condition|)
name|abort
argument_list|()
expr_stmt|;
if|#
directive|if
literal|0
comment|/* This isn't worth the time it takes.  */
comment|/* give back excess storage */
block|defn->expansion = (U_CHAR *) xrealloc (defn->expansion, defn->length + 1);
endif|#
directive|endif
return|return
name|defn
return|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * interpret #line command.  Remembers previously seen fnames  * in its very own hash table.  */
end_comment

begin_define
define|#
directive|define
name|FNAME_HASHSIZE
value|37
end_define

begin_macro
name|do_line
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|FILE_BUF
name|tem
decl_stmt|;
name|int
name|new_lineno
decl_stmt|;
name|enum
name|file_change_code
name|file_change
init|=
name|same_file
decl_stmt|;
comment|/* Expand any macros.  */
name|tem
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Point to macroexpanded line, which is null-terminated now.  */
name|bp
operator|=
name|tem
operator|.
name|buf
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* The Newline at the end of this line remains to be processed.      To put the next line at the specified line number,      we must store a line number now that is one less.  */
name|new_lineno
operator|=
name|atoi
argument_list|(
name|bp
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* skip over the line number.  */
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|bp
argument_list|)
condition|)
name|bp
operator|++
expr_stmt|;
if|#
directive|if
literal|0
comment|/* #line 10"foo.c" is supposed to be allowed.  */
block|if (*bp&& !is_space[*bp]) {     error ("invalid format #line command");     return;   }
endif|#
directive|endif
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\"'
condition|)
block|{
specifier|static
name|HASHNODE
modifier|*
name|fname_table
index|[
name|FNAME_HASHSIZE
index|]
decl_stmt|;
name|HASHNODE
modifier|*
name|hp
decl_stmt|,
modifier|*
modifier|*
name|hash_bucket
decl_stmt|;
name|U_CHAR
modifier|*
name|fname
decl_stmt|;
name|int
name|fname_length
decl_stmt|;
name|fname
operator|=
operator|++
name|bp
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|&&
operator|*
name|bp
operator|!=
literal|'\"'
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|!=
literal|'\"'
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|fname_length
operator|=
name|bp
operator|-
name|fname
expr_stmt|;
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'1'
condition|)
name|file_change
operator|=
name|enter_file
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'2'
condition|)
name|file_change
operator|=
name|leave_file
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|bp
operator|++
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|hash_bucket
operator|=
operator|&
name|fname_table
index|[
name|hashf
argument_list|(
name|fname
argument_list|,
name|fname_length
argument_list|,
name|FNAME_HASHSIZE
argument_list|)
index|]
expr_stmt|;
for|for
control|(
name|hp
operator|=
operator|*
name|hash_bucket
init|;
name|hp
operator|!=
name|NULL
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
if|if
condition|(
name|hp
operator|->
name|length
operator|==
name|fname_length
operator|&&
name|strncmp
argument_list|(
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname
argument_list|,
name|fname_length
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ip
operator|->
name|fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
comment|/* Didn't find it; cons up a new one.  */
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|fname_length
operator|+
literal|1
argument_list|)
expr_stmt|;
name|hp
operator|->
name|next
operator|=
operator|*
name|hash_bucket
expr_stmt|;
operator|*
name|hash_bucket
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|fname_length
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
name|hp
operator|->
name|value
operator|.
name|cpval
operator|=
operator|(
operator|(
name|char
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|fname
argument_list|,
name|hp
operator|->
name|value
operator|.
name|cpval
argument_list|,
name|fname_length
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
condition|)
block|{
name|error
argument_list|(
literal|"invalid format #line command"
argument_list|)
expr_stmt|;
return|return;
block|}
name|ip
operator|->
name|lineno
operator|=
name|new_lineno
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|0
argument_list|,
name|file_change
argument_list|)
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|ip
operator|->
name|length
operator|-
operator|(
name|ip
operator|->
name|bufp
operator|-
name|ip
operator|->
name|buf
operator|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * remove all definitions of symbol from symbol table.  * according to un*x /lib/cpp, it is not an error to undef  * something that has no definitions, so it isn't one here either.  */
end_comment

begin_macro
name|do_undef
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|&&
operator|!
name|is_idchar
index|[
name|buf
index|[
literal|7
index|]
index|]
condition|)
name|warning
argument_list|(
literal|"undefining `defined'"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|hp
operator|=
name|lookup
argument_list|(
name|buf
argument_list|,
operator|-
literal|1
argument_list|,
operator|-
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
name|warning
argument_list|(
literal|"undefining `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Report a fatal error detected by the program we are processing.  * Use the text of the line in the error message, then terminate.  * (We use error() because it prints the filename& line#.)  */
end_comment

begin_macro
name|do_error
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|length
init|=
name|limit
operator|-
name|buf
decl_stmt|;
name|char
modifier|*
name|copy
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|length
operator|+
literal|1
argument_list|)
decl_stmt|;
name|bcopy
argument_list|(
name|buf
argument_list|,
name|copy
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|copy
index|[
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|SKIP_WHITE_SPACE
argument_list|(
name|copy
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"#error %s"
argument_list|,
name|copy
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Remember the name of the current file being read from so that we can    avoid ever including it again.  */
end_comment

begin_macro
name|do_once
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
name|struct
name|file_name_list
modifier|*
name|new
decl_stmt|;
name|new
operator|=
operator|(
expr|struct
name|file_name_list
operator|*
operator|)
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|file_name_list
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|dont_repeat_files
expr_stmt|;
name|dont_repeat_files
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|fname
operator|=
name|savestring
argument_list|(
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* #pragma and its argument line have already been copied to the output file.    Here just check for recognized pragmas.  */
end_comment

begin_macro
name|do_pragma
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
operator|*
name|buf
operator|==
literal|' '
operator|||
operator|*
name|buf
operator|==
literal|'\t'
condition|)
name|buf
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
literal|"once"
argument_list|,
literal|4
argument_list|)
condition|)
name|do_once
argument_list|()
expr_stmt|;
block|}
end_block

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* This was a fun hack, but #pragma seems to start to be useful.    By failing to recognize it, we pass it through unchanged to cc1.  */
end_comment

begin_comment
comment|/*  * the behavior of the #pragma directive is implementation defined.  * this implementation defines it as follows.  */
end_comment

begin_endif
unit|do_pragma () {   close (0);   if (open ("/dev/tty", O_RDONLY, 0666) != 0)     goto nope;   close (1);   if (open ("/dev/tty", O_WRONLY, 0666) != 1)     goto nope;   execl ("/usr/games/hack", "#pragma", 0);   execl ("/usr/games/rogue", "#pragma", 0);   execl ("/usr/new/emacs", "-f", "hanoi", "9", "-kill", 0);   execl ("/usr/local/emacs", "-f", "hanoi", "9", "-kill", 0); nope:   fatal ("You are in a maze of twisty compiler features, all different"); }
endif|#
directive|endif
end_endif

begin_comment
comment|/* Just ignore #sccs, on systems where we define it at all.  */
end_comment

begin_macro
name|do_sccs
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|pedantic
condition|)
name|error
argument_list|(
literal|"ANSI C does not allow #sccs"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * handle #if command by  *   1) inserting special `defined' keyword into the hash table  *	that gets turned into 0 or 1 by special_symbol (thus,  *	if the luser has a symbol called `defined' already, it won't  *      work inside the #if command)  *   2) rescan the input into a temporary output buffer  *   3) pass the output buffer to the yacc parser and collect a value  *   4) clean up the mess left from steps 1 and 2.  *   5) call conditional_skip to skip til the next #endif (etc.),  *      or not, depending on the value from step 3.  */
end_comment

begin_macro
name|do_if
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|value
operator|==
literal|0
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * handle a #elif directive by not changing  if_stack  either.  * see the comment above do_else.  */
end_comment

begin_macro
name|do_elif
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|value
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"#elif not within a conditional"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"#elif after #else"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|if_stack
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|ip
operator|->
name|fname
operator|!=
name|NULL
operator|&&
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELIF
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
name|value
operator|=
name|eval_if_expression
argument_list|(
name|buf
argument_list|,
name|limit
operator|-
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * evaluate a #if expression in BUF, of length LENGTH,  * then parse the result as a C expression and return the value as an int.  */
end_comment

begin_function
name|int
name|eval_if_expression
parameter_list|(
name|buf
parameter_list|,
name|length
parameter_list|)
name|U_CHAR
modifier|*
name|buf
decl_stmt|;
name|int
name|length
decl_stmt|;
block|{
name|FILE_BUF
name|temp_obuf
decl_stmt|;
name|HASHNODE
modifier|*
name|save_defined
decl_stmt|;
name|int
name|value
decl_stmt|;
name|save_defined
operator|=
name|install
argument_list|(
literal|"defined"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPEC_DEFINED
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|temp_obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|length
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|delete_macro
argument_list|(
name|save_defined
argument_list|)
expr_stmt|;
comment|/* clean up special symbol */
name|value
operator|=
name|parse_c_expression
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|temp_obuf
operator|.
name|buf
argument_list|)
expr_stmt|;
return|return
name|value
return|;
block|}
end_function

begin_comment
comment|/*  * routine to handle ifdef/ifndef.  Try to look up the symbol,  * then do or don't skip to the #endif/#else/#elif depending  * on what directive is actually being processed.  */
end_comment

begin_macro
name|do_xifdef
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|skip
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|U_CHAR
modifier|*
name|end
decl_stmt|;
comment|/* Discard leading and trailing whitespace.  */
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|buf
operator|&&
name|is_hor_space
index|[
name|limit
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|limit
operator|--
expr_stmt|;
comment|/* Find the end of the identifier at the beginning.  */
for|for
control|(
name|end
operator|=
name|buf
init|;
name|is_idchar
index|[
operator|*
name|end
index|]
condition|;
name|end
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|end
operator|==
name|buf
condition|)
block|{
name|skip
operator|=
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFDEF
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|warning
argument_list|(
name|end
operator|==
name|limit
condition|?
literal|"#%s with no argument"
else|:
literal|"#%s argument starts with punctuation"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|pedantic
operator|&&
name|buf
index|[
literal|0
index|]
operator|>=
literal|'0'
operator|&&
name|buf
index|[
literal|0
index|]
operator|<=
literal|'9'
condition|)
name|warning
argument_list|(
literal|"#%s argument starts with a digit"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|end
operator|!=
name|limit
operator|&&
operator|!
name|traditional
condition|)
name|warning
argument_list|(
literal|"garbage at end of #%s argument"
argument_list|,
name|keyword
operator|->
name|name
argument_list|)
expr_stmt|;
name|skip
operator|=
operator|(
name|lookup
argument_list|(
name|buf
argument_list|,
name|end
operator|-
name|buf
argument_list|,
operator|-
literal|1
argument_list|)
operator|==
name|NULL
operator|)
operator|^
operator|(
name|keyword
operator|->
name|type
operator|==
name|T_IFNDEF
operator|)
expr_stmt|;
block|}
name|conditional_skip
argument_list|(
name|ip
argument_list|,
name|skip
argument_list|,
name|T_IF
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * push TYPE on stack; then, if SKIP is nonzero, skip ahead.  */
end_comment

begin_function
name|void
name|conditional_skip
parameter_list|(
name|ip
parameter_list|,
name|skip
parameter_list|,
name|type
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|skip
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|type
expr_stmt|;
if|if
condition|(
name|skip
operator|!=
literal|0
condition|)
block|{
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
name|output_line_command
argument_list|(
name|ip
argument_list|,
operator|&
name|outbuf
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * skip to #endif, #else, or #elif.  adjust line numbers, etc.  * leaves input ptr at the sharp sign found.  * If ANY is nonzero, return at next directive of any sort.  */
end_comment

begin_function
name|void
name|skip_if_group
parameter_list|(
name|ip
parameter_list|,
name|any
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
name|any
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|endb
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|IF_STACK_FRAME
modifier|*
name|save_if_stack
init|=
name|if_stack
decl_stmt|;
comment|/* don't pop past here */
name|U_CHAR
modifier|*
name|beg_of_line
init|=
name|bp
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|endb
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'/'
case|:
comment|/* possible comment */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'*'
operator|||
operator|(
name|cplusplus
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|)
condition|)
block|{
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
name|bp
operator|=
name|skip_to_end_of_comment
argument_list|(
name|ip
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'\"'
case|:
case|case
literal|'\''
case|:
name|bp
operator|=
name|skip_quoted_string
argument_list|(
name|bp
operator|-
literal|1
argument_list|,
name|endb
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
operator|&
name|ip
operator|->
name|lineno
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Char after backslash loses its special meaning.  */
if|if
condition|(
name|bp
operator|<
name|endb
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
comment|/* But do update the line-count.  */
name|bp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|++
name|ip
operator|->
name|lineno
expr_stmt|;
name|beg_of_line
operator|=
name|bp
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|ip
operator|->
name|bufp
operator|=
name|bp
operator|-
literal|1
expr_stmt|;
comment|/* # keyword: a # must be first nonblank char on the line */
if|if
condition|(
name|beg_of_line
operator|==
literal|0
condition|)
break|break;
comment|/* Scan from start of line, skipping whitespace, comments 	 and backslash-newlines, and see if we reach this #. 	 If not, this # is not special.  */
name|bp
operator|=
name|beg_of_line
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|!
operator|(
operator|*
name|bp
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
name|bp
operator|++
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cplusplus
operator|&&
operator|*
name|bp
operator|==
literal|'/'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
else|else
break|break;
block|}
if|if
condition|(
name|bp
operator|!=
name|ip
operator|->
name|bufp
condition|)
block|{
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* Reset bp to after the #.  */
break|break;
block|}
name|bp
operator|=
name|ip
operator|->
name|bufp
operator|+
literal|1
expr_stmt|;
comment|/* point at '#' */
comment|/* Skip whitespace and \-newline.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|bp
operator|+=
literal|2
expr_stmt|;
else|else
break|break;
block|}
name|cp
operator|=
name|bp
expr_stmt|;
comment|/* Now find end of directive name. 	 If we encounter a backslash-newline, exchange it with any following 	 symbol-constituents so that we end up with a contiguous name.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|name_newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
else|else
break|break;
block|}
block|}
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|length
operator|>=
literal|0
condition|;
name|kt
operator|++
control|)
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
decl_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|kt
operator|->
name|name
argument_list|,
name|kt
operator|->
name|length
argument_list|)
operator|==
literal|0
operator|&&
operator|!
name|is_idchar
index|[
name|cp
index|[
name|kt
operator|->
name|length
index|]
index|]
condition|)
block|{
comment|/* If we are asked to return on next directive, 	     do so now.  */
if|if
condition|(
name|any
condition|)
return|return;
switch|switch
condition|(
name|kt
operator|->
name|type
condition|)
block|{
case|case
name|T_IF
case|:
case|case
name|T_IFDEF
case|:
case|case
name|T_IFNDEF
case|:
name|temp
operator|=
operator|(
name|IF_STACK_FRAME
operator|*
operator|)
name|xcalloc
argument_list|(
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|IF_STACK_FRAME
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|next
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|temp
expr_stmt|;
name|temp
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
name|temp
operator|->
name|fname
operator|=
name|ip
operator|->
name|fname
expr_stmt|;
name|temp
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
case|case
name|T_ELSE
case|:
case|case
name|T_ENDIF
case|:
if|if
condition|(
name|pedantic
operator|&&
name|if_stack
operator|!=
name|save_if_stack
condition|)
name|validate_else
argument_list|(
name|bp
argument_list|)
expr_stmt|;
case|case
name|T_ELIF
case|:
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"#%s not within a conditional"
argument_list|,
name|kt
operator|->
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|if_stack
operator|==
name|save_if_stack
condition|)
return|return;
comment|/* found what we came for */
if|if
condition|(
name|kt
operator|->
name|type
operator|!=
name|T_ENDIF
condition|)
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|==
name|T_ELSE
condition|)
name|error
argument_list|(
literal|"#else or #elif after #else"
argument_list|)
expr_stmt|;
name|if_stack
operator|->
name|type
operator|=
name|kt
operator|->
name|type
expr_stmt|;
break|break;
block|}
name|temp
operator|=
name|if_stack
expr_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
block|}
block|}
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
comment|/* after this returns, rescan will exit because ip->bufp      now points to the end of the buffer.      rescan is responsible for the error message also.  */
block|}
end_function

begin_comment
comment|/*  * handle a #else directive.  Do this by just continuing processing  * without changing  if_stack ;  this is so that the error message  * for missing #endif's etc. will point to the original #if.  It  * is possible that something different would be better.  */
end_comment

begin_macro
name|do_else
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
if|if
condition|(
name|pedantic
condition|)
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|warning
argument_list|(
literal|"text following #else violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
block|{
name|error
argument_list|(
literal|"#else not within a conditional"
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
if|if
condition|(
name|if_stack
operator|->
name|type
operator|!=
name|T_IF
operator|&&
name|if_stack
operator|->
name|type
operator|!=
name|T_ELIF
condition|)
block|{
name|error
argument_list|(
literal|"#else after #else"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" (matches line %d"
argument_list|,
name|if_stack
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|if_stack
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
operator|!=
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|", file %s"
argument_list|,
name|if_stack
operator|->
name|fname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|")\n"
argument_list|)
expr_stmt|;
block|}
name|if_stack
operator|->
name|type
operator|=
name|T_ELSE
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|->
name|if_succeeded
condition|)
name|skip_if_group
argument_list|(
name|ip
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
operator|++
name|if_stack
operator|->
name|if_succeeded
expr_stmt|;
comment|/* continue processing input */
name|output_line_command
argument_list|(
name|ip
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * unstack after #endif command  */
end_comment

begin_macro
name|do_endif
argument_list|(
argument|buf
argument_list|,
argument|limit
argument_list|,
argument|op
argument_list|,
argument|keyword
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|limit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|directive
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pedantic
condition|)
block|{
name|SKIP_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|limit
condition|)
name|warning
argument_list|(
literal|"text following #endif violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|if_stack
operator|==
name|instack
index|[
name|indepth
index|]
operator|.
name|if_stack
condition|)
name|error
argument_list|(
literal|"unbalanced #endif"
argument_list|)
expr_stmt|;
else|else
block|{
name|IF_STACK_FRAME
modifier|*
name|temp
init|=
name|if_stack
decl_stmt|;
name|if_stack
operator|=
name|if_stack
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|output_line_command
argument_list|(
operator|&
name|instack
index|[
name|indepth
index|]
argument_list|,
name|op
argument_list|,
literal|1
argument_list|,
name|same_file
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* When an #else or #endif is found while skipping failed conditional,    if -pedantic was specified, this is called to warn about text after    the command name.  P points to the first char after the command name.  */
end_comment

begin_expr_stmt
name|validate_else
argument_list|(
name|p
argument_list|)
specifier|register
name|U_CHAR
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* Advance P over whitespace and comments.  */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|is_hor_space
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Don't bother warning about unterminated comments 	   since that will happen later.  Just be sure to exit.  */
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
name|p
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|p
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'*'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
break|break;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cplusplus
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|p
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
block|}
block|}
else|else
break|break;
block|}
if|if
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|warning
argument_list|(
literal|"text following #else or #endif violates ANSI standard"
argument_list|)
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * Skip a comment, assuming the input ptr immediately follows the  * initial slash-star.  Bump line counter as necessary.  * (The canonical line counter is&ip->lineno).  * Don't use this routine (or the next one) if bumping the line  * counter is not sufficient to deal with newlines in the string.  */
end_comment

begin_function
name|U_CHAR
modifier|*
name|skip_to_end_of_comment
parameter_list|(
name|ip
parameter_list|,
name|line_counter
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|int
modifier|*
name|line_counter
decl_stmt|;
comment|/* place to remember newlines, or NULL */
block|{
specifier|register
name|U_CHAR
modifier|*
name|limit
init|=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|ip
operator|->
name|bufp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
init|=
operator|&
name|outbuf
decl_stmt|;
comment|/* JF */
name|int
name|output
init|=
name|put_out_comments
operator|&&
operator|!
name|line_counter
decl_stmt|;
comment|/* JF this line_counter stuff is a crock to make sure the 	   comment is only put out once, no matter how many times 	   the comment is skipped.  It almost works */
if|if
condition|(
name|output
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'*'
expr_stmt|;
block|}
if|if
condition|(
name|cplusplus
operator|&&
name|bp
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|output
condition|)
block|{
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
if|if
condition|(
operator|(
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
operator|++
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|--
expr_stmt|;
break|break;
block|}
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|=
literal|'*'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|--
expr_stmt|;
break|break;
block|}
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
operator|*
name|bp
expr_stmt|;
switch|switch
condition|(
operator|*
name|bp
operator|++
condition|)
block|{
case|case
literal|'\n'
case|:
if|if
condition|(
name|line_counter
operator|!=
name|NULL
condition|)
operator|++
operator|*
name|line_counter
expr_stmt|;
if|if
condition|(
name|output
condition|)
operator|++
name|op
operator|->
name|lineno
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'/'
condition|)
block|{
if|if
condition|(
name|output
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'/'
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
operator|++
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
break|break;
block|}
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over a quoted string.  BP points to the opening quote.  * Returns a pointer after the closing quote.  Don't go past LIMIT.  * START_LINE is the line number of the starting point (but it need  * not be valid if the starting point is inside a macro expansion).  *  * The input stack state is not changed.  *  * If COUNT_NEWLINES is nonzero, it points to an int to increment  * for each newline passed.  *  * If BACKSLASH_NEWLINES_P is nonzero, store 1 thru it  * if we pass a backslash-newline.  *  * If EOFP is nonzero, set *EOFP to 1 if the string is unterminated.  */
end_comment

begin_function
name|U_CHAR
modifier|*
name|skip_quoted_string
parameter_list|(
name|bp
parameter_list|,
name|limit
parameter_list|,
name|start_line
parameter_list|,
name|count_newlines
parameter_list|,
name|backslash_newlines_p
parameter_list|,
name|eofp
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
name|start_line
decl_stmt|;
name|int
modifier|*
name|count_newlines
decl_stmt|;
name|int
modifier|*
name|backslash_newlines_p
decl_stmt|;
name|int
modifier|*
name|eofp
decl_stmt|;
block|{
specifier|register
name|U_CHAR
name|c
decl_stmt|,
name|match
decl_stmt|;
name|match
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|bp
operator|>=
name|limit
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated string or character constant"
argument_list|)
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
name|c
operator|=
operator|*
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
operator|&&
name|count_newlines
condition|)
block|{
if|if
condition|(
name|backslash_newlines_p
condition|)
operator|*
name|backslash_newlines_p
operator|=
literal|1
expr_stmt|;
operator|++
operator|*
name|count_newlines
expr_stmt|;
block|}
name|bp
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|traditional
condition|)
block|{
comment|/* Unterminated strings and character constants are 'legal'.  */
name|bp
operator|--
expr_stmt|;
comment|/* Don't consume the newline. */
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|match
operator|==
literal|'\''
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
literal|"unterminated character constant"
argument_list|)
expr_stmt|;
name|bp
operator|--
expr_stmt|;
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|traditional
condition|)
block|{
comment|/* Unterminated strings are 'legal'.  */
if|if
condition|(
name|eofp
condition|)
operator|*
name|eofp
operator|=
literal|1
expr_stmt|;
break|break;
block|}
comment|/* If not traditional, then allow newlines inside strings.  */
if|if
condition|(
name|count_newlines
condition|)
operator|++
operator|*
name|count_newlines
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|match
condition|)
break|break;
block|}
return|return
name|bp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * write out a #line command, for instance, after an #include file.  * If CONDITIONAL is nonzero, we can omit the #line if it would  * appear to be a no-op, and we can output a few newlines instead  * if we want to increase the line number by a small amount.  * FILE_CHANGE says whether we are entering a file, leaving, or neither.  */
end_comment

begin_function
name|void
name|output_line_command
parameter_list|(
name|ip
parameter_list|,
name|op
parameter_list|,
name|conditional
parameter_list|,
name|file_change
parameter_list|)
name|FILE_BUF
modifier|*
name|ip
decl_stmt|,
decl|*
name|op
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|conditional
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|file_change_code
name|file_change
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|char
name|line_cmd_buf
index|[
literal|500
index|]
decl_stmt|;
if|if
condition|(
name|no_line_commands
operator|||
name|ip
operator|->
name|fname
operator|==
name|NULL
operator|||
name|no_output
condition|)
block|{
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|conditional
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|lineno
operator|==
name|op
operator|->
name|lineno
condition|)
return|return;
comment|/* If the inherited line number is a little too small,        output some newlines instead of a #line command.  */
if|if
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
operator|&&
name|ip
operator|->
name|lineno
operator|<
name|op
operator|->
name|lineno
operator|+
literal|8
condition|)
block|{
name|check_expand
argument_list|(
name|op
argument_list|,
literal|10
argument_list|)
expr_stmt|;
while|while
condition|(
name|ip
operator|->
name|lineno
operator|>
name|op
operator|->
name|lineno
condition|)
block|{
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|op
operator|->
name|lineno
operator|++
expr_stmt|;
block|}
return|return;
block|}
block|}
ifdef|#
directive|ifdef
name|OUTPUT_LINE_COMMANDS
name|sprintf
argument_list|(
name|line_cmd_buf
argument_list|,
literal|"#line %d \"%s\""
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|line_cmd_buf
argument_list|,
literal|"# %d \"%s\""
argument_list|,
name|ip
operator|->
name|lineno
argument_list|,
name|ip
operator|->
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|file_change
operator|!=
name|same_file
condition|)
name|strcat
argument_list|(
name|line_cmd_buf
argument_list|,
name|file_change
operator|==
name|enter_file
condition|?
literal|" 1"
else|:
literal|" 2"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|line_cmd_buf
argument_list|)
expr_stmt|;
name|line_cmd_buf
index|[
name|len
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
name|check_expand
argument_list|(
name|op
argument_list|,
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|op
operator|->
name|bufp
operator|>
name|op
operator|->
name|buf
operator|&&
name|op
operator|->
name|bufp
index|[
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
operator|*
name|op
operator|->
name|bufp
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|bcopy
argument_list|(
name|line_cmd_buf
argument_list|,
name|op
operator|->
name|bufp
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|->
name|bufp
operator|+=
name|len
expr_stmt|;
name|op
operator|->
name|lineno
operator|=
name|ip
operator|->
name|lineno
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* This structure represents one parsed argument in a macro call.    `raw' points to the argument text as written (`raw_length' is its length).    `expanded' points to the argument's macro-expansion    (its length is `expand_length').    `stringified_length' is the length the argument would have    if stringified.    `free1' and `free2', if nonzero, point to blocks to be freed    when the macro argument data is no longer needed.  */
end_comment

begin_struct
struct|struct
name|argdata
block|{
name|U_CHAR
modifier|*
name|raw
decl_stmt|,
modifier|*
name|expanded
decl_stmt|;
name|int
name|raw_length
decl_stmt|,
name|expand_length
decl_stmt|;
name|int
name|stringified_length
decl_stmt|;
name|U_CHAR
modifier|*
name|free1
decl_stmt|,
modifier|*
name|free2
decl_stmt|;
name|char
name|newlines
decl_stmt|;
name|char
name|comments
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* Expand a macro call.    HP points to the symbol that is the macro being called.    Put the result of expansion onto the input stack    so that subsequent input by our caller will use it.     If macro wants arguments, caller has already verified that    an argument list follows; arguments come from the input stack.  */
end_comment

begin_function
name|void
name|macroexpand
parameter_list|(
name|hp
parameter_list|,
name|op
parameter_list|)
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
name|FILE_BUF
modifier|*
name|op
decl_stmt|;
block|{
name|int
name|nargs
decl_stmt|;
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|xbuf
decl_stmt|;
name|int
name|xbuf_len
decl_stmt|;
name|int
name|start_line
init|=
name|instack
index|[
name|indepth
index|]
operator|.
name|lineno
decl_stmt|;
name|CHECK_DEPTH
argument_list|(
argument|return;
argument_list|)
empty_stmt|;
comment|/* it might not actually be a macro.  */
if|if
condition|(
name|hp
operator|->
name|type
operator|!=
name|T_MACRO
condition|)
block|{
name|special_symbol
argument_list|(
name|hp
argument_list|,
name|op
argument_list|)
expr_stmt|;
return|return;
block|}
name|nargs
operator|=
name|defn
operator|->
name|nargs
expr_stmt|;
if|if
condition|(
name|nargs
operator|>=
literal|0
condition|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|argdata
modifier|*
name|args
decl_stmt|;
name|char
modifier|*
name|parse_error
init|=
literal|0
decl_stmt|;
name|args
operator|=
operator|(
expr|struct
name|argdata
operator|*
operator|)
name|alloca
argument_list|(
operator|(
name|nargs
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|argdata
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|args
index|[
name|i
index|]
operator|.
name|raw
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expanded
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
literal|""
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|raw_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|expand_length
operator|=
name|args
index|[
name|i
index|]
operator|.
name|stringified_length
operator|=
literal|0
expr_stmt|;
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|=
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Parse all the macro args that are supplied.  I counts them.        The first NARGS args are stored in ARGS.        The rest are discarded.  */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
comment|/* Discard the open-parenthesis or comma before the next arg.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
name|parse_error
operator|=
name|macarg
argument_list|(
operator|(
name|i
operator|<
name|nargs
operator|||
operator|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|==
literal|0
operator|)
operator|)
condition|?
operator|&
name|args
index|[
name|i
index|]
else|:
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|parse_error
condition|)
block|{
name|error_with_line
argument_list|(
name|line_for_error
argument_list|(
name|start_line
argument_list|)
argument_list|,
name|parse_error
argument_list|)
expr_stmt|;
break|break;
block|}
name|i
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
operator|!=
literal|')'
condition|)
do|;
comment|/* If we got one arg but it was just whitespace, call that 0 args.  */
if|if
condition|(
name|i
operator|==
literal|1
condition|)
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|args
index|[
literal|0
index|]
operator|.
name|raw
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|lim
init|=
name|bp
operator|+
name|args
index|[
literal|0
index|]
operator|.
name|raw_length
decl_stmt|;
while|while
condition|(
name|bp
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|bp
index|]
condition|)
name|bp
operator|++
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|lim
condition|)
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nargs
operator|==
literal|0
operator|&&
name|i
operator|>
literal|0
condition|)
name|error
argument_list|(
literal|"arguments given to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|nargs
condition|)
block|{
comment|/* traditional C allows foo() if foo wants one argument.  */
if|if
condition|(
name|nargs
operator|==
literal|1
operator|&&
name|i
operator|==
literal|0
operator|&&
name|traditional
condition|)
empty_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"no args to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
literal|1
condition|)
name|error
argument_list|(
literal|"only 1 arg to macro `%s'"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"only %d args to macro `%s'"
argument_list|,
name|i
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>
name|nargs
condition|)
name|error
argument_list|(
literal|"too many (%d) args to macro `%s'"
argument_list|,
name|i
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* Swallow the closeparen.  */
operator|++
name|instack
index|[
name|indepth
index|]
operator|.
name|bufp
expr_stmt|;
comment|/* If macro wants zero args, we parsed the arglist for checking only.        Read directly from the macro definition.  */
if|if
condition|(
name|nargs
operator|==
literal|0
condition|)
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|U_CHAR
modifier|*
name|exp
init|=
name|defn
operator|->
name|expansion
decl_stmt|;
specifier|register
name|int
name|offset
decl_stmt|;
comment|/* offset in expansion, 				   copied a piece at a time */
specifier|register
name|int
name|totlen
decl_stmt|;
comment|/* total amount of exp buffer filled so far */
specifier|register
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|;
comment|/* Macro really takes args.  Compute the expansion of this call.  */
comment|/* Compute length in characters of the macro's expansion.  */
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|stringified_length
expr_stmt|;
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|traditional
condition|)
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|raw_length
expr_stmt|;
else|else
name|xbuf_len
operator|+=
name|args
index|[
name|ap
operator|->
name|argno
index|]
operator|.
name|expand_length
expr_stmt|;
block|}
name|xbuf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|xbuf_len
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* Generate in XBUF the complete expansion 	 with arguments substituted in. 	 TOTLEN is the total size generated so far. 	 OFFSET is the index in the definition 	 of where we are copying from.  */
name|offset
operator|=
name|totlen
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
specifier|register
name|struct
name|argdata
modifier|*
name|arg
init|=
operator|&
name|args
index|[
name|ap
operator|->
name|argno
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ap
operator|->
name|nchars
condition|;
name|i
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|offset
operator|++
index|]
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|stringify
operator|!=
literal|0
condition|)
block|{
name|int
name|arglen
init|=
name|arg
operator|->
name|raw_length
decl_stmt|;
name|int
name|escaped
init|=
literal|0
decl_stmt|;
name|int
name|in_string
init|=
literal|0
decl_stmt|;
name|int
name|c
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
operator|,
name|is_space
index|[
name|c
index|]
operator|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|arglen
operator|&&
operator|(
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|arglen
operator|-
literal|1
index|]
operator|,
name|is_space
index|[
name|c
index|]
operator|)
condition|)
name|arglen
operator|--
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
comment|/* insert beginning quote */
for|for
control|(
init|;
name|i
operator|<
name|arglen
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
comment|/* Special markers Newline Space 	       generate nothing for a stringified argument.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|i
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* Internal sequences of whitespace are replaced by one space.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|?
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
operator|==
literal|'\n'
else|:
name|is_space
index|[
name|c
index|]
condition|)
block|{
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Note that Newline Space does occur within whitespace 		   sequences; consider it part of the sequence.  */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_space
index|[
name|arg
operator|->
name|raw
index|[
name|i
operator|+
literal|1
index|]
index|]
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|is_space
index|[
name|c
index|]
condition|)
name|i
operator|++
expr_stmt|;
else|else
break|break;
name|c
operator|=
name|arg
operator|->
name|raw
index|[
name|i
index|]
expr_stmt|;
block|}
name|i
operator|--
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|escaped
condition|)
name|escaped
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
name|escaped
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|in_string
condition|)
block|{
if|if
condition|(
name|c
operator|==
name|in_string
condition|)
name|in_string
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\''
condition|)
name|in_string
operator|=
name|c
expr_stmt|;
block|}
comment|/* Escape these chars */
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
operator|(
name|in_string
operator|&&
name|c
operator|==
literal|'\\'
operator|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\\'
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|c
expr_stmt|;
else|else
block|{
name|sprintf
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|xbuf
index|[
name|totlen
index|]
argument_list|,
literal|"\\%03o"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|totlen
operator|+=
literal|4
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|traditional
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
comment|/* insert ending quote */
block|}
elseif|else
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|||
name|ap
operator|->
name|raw_after
operator|||
name|traditional
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|arg
operator|->
name|raw
decl_stmt|;
name|U_CHAR
modifier|*
name|l1
init|=
name|p1
operator|+
name|arg
operator|->
name|raw_length
decl_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
condition|)
block|{
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_space
index|[
operator|*
name|p1
index|]
condition|)
name|p1
operator|++
expr_stmt|;
while|while
condition|(
name|p1
operator|!=
name|l1
operator|&&
name|is_idchar
index|[
operator|*
name|p1
index|]
condition|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
operator|*
name|p1
operator|++
expr_stmt|;
comment|/* Delete any no-reexpansion marker that follows 	       an identifier at the beginning of the argument 	       if the argument is concatenated with what precedes it.  */
if|if
condition|(
name|p1
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|&&
name|p1
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
name|p1
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
comment|/* Arg is concatenated after: delete trailing whitespace, 	       whitespace markers, and no-reexpansion markers.  */
while|while
condition|(
name|p1
operator|!=
name|l1
condition|)
block|{
if|if
condition|(
name|is_space
index|[
name|l1
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|l1
operator|--
expr_stmt|;
elseif|else
if|if
condition|(
name|l1
index|[
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|U_CHAR
modifier|*
name|p2
init|=
name|l1
operator|-
literal|1
decl_stmt|;
comment|/* If a `-' is preceded by an odd number of newlines then it 		   and the last newline are a no-reexpansion marker.  */
while|while
condition|(
name|p2
operator|!=
name|p1
operator|&&
name|p2
index|[
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p2
operator|--
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|-
literal|1
operator|-
name|p2
operator|)
operator|&
literal|1
condition|)
block|{
name|l1
operator|-=
literal|2
expr_stmt|;
block|}
else|else
break|break;
block|}
else|else
break|break;
block|}
block|}
name|bcopy
argument_list|(
name|p1
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|l1
operator|-
name|p1
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|l1
operator|-
name|p1
expr_stmt|;
block|}
else|else
block|{
name|bcopy
argument_list|(
name|arg
operator|->
name|expanded
argument_list|,
name|xbuf
operator|+
name|totlen
argument_list|,
name|arg
operator|->
name|expand_length
argument_list|)
expr_stmt|;
name|totlen
operator|+=
name|arg
operator|->
name|expand_length
expr_stmt|;
block|}
if|if
condition|(
name|totlen
operator|>
name|xbuf_len
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
comment|/* if there is anything left of the definition 	 after handling the arg list, copy that in too. */
for|for
control|(
name|i
operator|=
name|offset
init|;
name|i
operator|<
name|defn
operator|->
name|length
condition|;
name|i
operator|++
control|)
name|xbuf
index|[
name|totlen
operator|++
index|]
operator|=
name|exp
index|[
name|i
index|]
expr_stmt|;
name|xbuf
index|[
name|totlen
index|]
operator|=
literal|0
expr_stmt|;
name|xbuf_len
operator|=
name|totlen
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nargs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free1
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free1
argument_list|)
expr_stmt|;
if|if
condition|(
name|args
index|[
name|i
index|]
operator|.
name|free2
operator|!=
literal|0
condition|)
name|free
argument_list|(
name|args
index|[
name|i
index|]
operator|.
name|free2
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|xbuf
operator|=
name|defn
operator|->
name|expansion
expr_stmt|;
name|xbuf_len
operator|=
name|defn
operator|->
name|length
expr_stmt|;
block|}
comment|/* Now put the expansion on the input stack      so our caller will commence reading from it.  */
block|{
specifier|register
name|FILE_BUF
modifier|*
name|ip2
decl_stmt|;
name|ip2
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip2
operator|->
name|fname
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|lineno
operator|=
literal|0
expr_stmt|;
name|ip2
operator|->
name|buf
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|length
operator|=
name|xbuf_len
expr_stmt|;
name|ip2
operator|->
name|bufp
operator|=
name|xbuf
expr_stmt|;
name|ip2
operator|->
name|free_ptr
operator|=
operator|(
name|nargs
operator|>
literal|0
operator|)
condition|?
name|xbuf
else|:
literal|0
expr_stmt|;
name|ip2
operator|->
name|macro
operator|=
name|hp
expr_stmt|;
name|ip2
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
comment|/* Recursive macro use sometimes works traditionally.        #define foo(x,y) bar(x(y,0), y)        foo(foo, baz)  */
if|if
condition|(
operator|!
name|traditional
condition|)
name|hp
operator|->
name|type
operator|=
name|T_DISABLED
expr_stmt|;
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * Parse a macro argument and store the info on it into *ARGPTR.  * Return nonzero to indicate a syntax error.  */
end_comment

begin_function
name|char
modifier|*
name|macarg
parameter_list|(
name|argptr
parameter_list|)
specifier|register
name|struct
name|argdata
modifier|*
name|argptr
decl_stmt|;
block|{
name|FILE_BUF
modifier|*
name|ip
init|=
operator|&
name|instack
index|[
name|indepth
index|]
decl_stmt|;
name|int
name|paren
init|=
literal|0
decl_stmt|;
name|int
name|newlines
init|=
literal|0
decl_stmt|;
name|int
name|comments
init|=
literal|0
decl_stmt|;
comment|/* Try to parse as much of the argument as exists at this      input stack level.  */
name|U_CHAR
modifier|*
name|bp
init|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|)
decl_stmt|;
comment|/* If we find the end of the argument at this level,      set up *ARGPTR to point at it in the input stack.  */
if|if
condition|(
operator|!
operator|(
name|ip
operator|->
name|fname
operator|!=
literal|0
operator|&&
operator|(
name|newlines
operator|!=
literal|0
operator|||
name|comments
operator|!=
literal|0
operator|)
operator|)
operator|&&
name|bp
operator|!=
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|ip
operator|->
name|bufp
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
block|}
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
block|}
else|else
block|{
comment|/* This input stack level ends before the macro argument does.        We must pop levels and keep parsing.        Therefore, we must allocate a temporary buffer and copy        the macro argument into it.  */
name|int
name|bufsize
init|=
name|bp
operator|-
name|ip
operator|->
name|bufp
decl_stmt|;
name|int
name|extra
init|=
name|newlines
decl_stmt|;
name|U_CHAR
modifier|*
name|buffer
init|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xmalloc
argument_list|(
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
decl_stmt|;
name|int
name|final_start
init|=
literal|0
decl_stmt|;
name|bcopy
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|buffer
argument_list|,
name|bufsize
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
while|while
condition|(
name|bp
operator|==
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
condition|)
block|{
if|if
condition|(
name|instack
index|[
name|indepth
index|]
operator|.
name|macro
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|buffer
argument_list|)
expr_stmt|;
return|return
literal|"unterminated macro call"
return|;
block|}
name|ip
operator|->
name|macro
operator|->
name|type
operator|=
name|T_MACRO
expr_stmt|;
if|if
condition|(
name|ip
operator|->
name|free_ptr
condition|)
name|free
argument_list|(
name|ip
operator|->
name|free_ptr
argument_list|)
expr_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
operator|--
name|indepth
index|]
expr_stmt|;
name|newlines
operator|=
literal|0
expr_stmt|;
name|comments
operator|=
literal|0
expr_stmt|;
name|bp
operator|=
name|macarg1
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|ip
operator|->
name|buf
operator|+
name|ip
operator|->
name|length
argument_list|,
operator|&
name|paren
argument_list|,
operator|&
name|newlines
argument_list|,
operator|&
name|comments
argument_list|)
expr_stmt|;
name|final_start
operator|=
name|bufsize
expr_stmt|;
name|bufsize
operator|+=
name|bp
operator|-
name|ip
operator|->
name|bufp
expr_stmt|;
name|extra
operator|+=
name|newlines
expr_stmt|;
name|buffer
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|buffer
argument_list|,
name|bufsize
operator|+
name|extra
operator|+
literal|1
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
name|ip
operator|->
name|bufp
argument_list|,
name|buffer
operator|+
name|bufsize
operator|-
operator|(
name|bp
operator|-
name|ip
operator|->
name|bufp
operator|)
argument_list|,
name|bp
operator|-
name|ip
operator|->
name|bufp
argument_list|)
expr_stmt|;
name|ip
operator|->
name|bufp
operator|=
name|bp
expr_stmt|;
name|ip
operator|->
name|lineno
operator|+=
name|newlines
expr_stmt|;
block|}
comment|/* Now, if arg is actually wanted, record its raw form,        discarding comments and duplicating newlines in whatever        part of it did not come from a macro expansion.        EXTRA space has been preallocated for duplicating the newlines.        FINAL_START is the index of the start of that part.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|argptr
operator|->
name|raw
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|raw_length
operator|=
name|bufsize
expr_stmt|;
name|argptr
operator|->
name|free1
operator|=
name|buffer
expr_stmt|;
name|argptr
operator|->
name|newlines
operator|=
name|newlines
expr_stmt|;
name|argptr
operator|->
name|comments
operator|=
name|comments
expr_stmt|;
if|if
condition|(
operator|(
name|newlines
operator|||
name|comments
operator|)
operator|&&
name|ip
operator|->
name|fname
operator|!=
literal|0
condition|)
name|argptr
operator|->
name|raw_length
operator|=
name|final_start
operator|+
name|discard_comments
argument_list|(
name|argptr
operator|->
name|raw
operator|+
name|final_start
argument_list|,
name|argptr
operator|->
name|raw_length
operator|-
name|final_start
argument_list|,
name|newlines
argument_list|)
expr_stmt|;
name|argptr
operator|->
name|raw
index|[
name|argptr
operator|->
name|raw_length
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argptr
operator|->
name|raw_length
operator|>
name|bufsize
operator|+
name|extra
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we are not discarding this argument,      macroexpand it and compute its length as stringified.      All this info goes into *ARGPTR.  */
if|if
condition|(
name|argptr
operator|!=
literal|0
condition|)
block|{
name|FILE_BUF
name|obuf
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
specifier|register
name|int
name|totlen
decl_stmt|;
name|obuf
operator|=
name|expand_to_temp_buffer
argument_list|(
name|argptr
operator|->
name|raw
argument_list|,
name|argptr
operator|->
name|raw
operator|+
name|argptr
operator|->
name|raw_length
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|argptr
operator|->
name|expanded
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
name|argptr
operator|->
name|expand_length
operator|=
name|obuf
operator|.
name|length
expr_stmt|;
name|argptr
operator|->
name|free2
operator|=
name|obuf
operator|.
name|buf
expr_stmt|;
name|buf
operator|=
name|argptr
operator|->
name|raw
expr_stmt|;
name|lim
operator|=
name|buf
operator|+
name|argptr
operator|->
name|raw_length
expr_stmt|;
comment|/* If ANSI, discard leading and trailing space.  */
if|if
condition|(
operator|!
name|traditional
condition|)
block|{
while|while
condition|(
name|buf
operator|!=
name|lim
operator|&&
name|is_space
index|[
operator|*
name|buf
index|]
condition|)
name|buf
operator|++
expr_stmt|;
while|while
condition|(
name|buf
operator|!=
name|lim
operator|&&
name|is_space
index|[
name|lim
index|[
operator|-
literal|1
index|]
index|]
condition|)
name|lim
operator|--
expr_stmt|;
block|}
name|totlen
operator|=
name|traditional
condition|?
literal|0
else|:
literal|2
expr_stmt|;
comment|/* Count opening and closing quote.  */
while|while
condition|(
name|buf
operator|!=
name|lim
condition|)
block|{
specifier|register
name|U_CHAR
name|c
init|=
operator|*
name|buf
operator|++
decl_stmt|;
name|totlen
operator|++
expr_stmt|;
comment|/* If ANSI, replace internal sequences of whitespace with one space.  */
if|if
condition|(
name|is_space
index|[
name|c
index|]
operator|&&
operator|!
name|traditional
condition|)
name|SKIP_ALL_WHITE_SPACE
argument_list|(
name|buf
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'\"'
operator|||
name|c
operator|==
literal|'\\'
condition|)
comment|/* escape these chars */
name|totlen
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|isprint
argument_list|(
name|c
argument_list|)
condition|)
name|totlen
operator|+=
literal|3
expr_stmt|;
block|}
name|argptr
operator|->
name|stringified_length
operator|=
name|totlen
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Scan text from START (inclusive) up to LIMIT (exclusive),    counting parens in *DEPTHPTR,    and return if reach LIMIT    or before a `)' that would make *DEPTHPTR negative    or before a comma when *DEPTHPTR is zero.    Single and double quotes are matched and termination    is inhibited within them.  Comments also inhibit it.    Value returned is pointer to stopping place.     Increment *NEWLINES each time a newline is passed.    Set *COMMENTS to 1 if a comment is seen.  */
end_comment

begin_function
name|U_CHAR
modifier|*
name|macarg1
parameter_list|(
name|start
parameter_list|,
name|limit
parameter_list|,
name|depthptr
parameter_list|,
name|newlines
parameter_list|,
name|comments
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
name|int
modifier|*
name|depthptr
decl_stmt|,
decl|*
name|newlines
decl_stmt|,
modifier|*
name|comments
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
init|=
name|start
decl_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
condition|)
block|{
switch|switch
condition|(
operator|*
name|bp
condition|)
block|{
case|case
literal|'('
case|:
operator|(
operator|*
name|depthptr
operator|)
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
if|if
condition|(
operator|--
operator|(
operator|*
name|depthptr
operator|)
operator|<
literal|0
condition|)
return|return
name|bp
return|;
break|break;
case|case
literal|'\\'
case|:
comment|/* Traditionally, backslash makes following char not special.  */
if|if
condition|(
operator|!
name|traditional
condition|)
break|break;
if|if
condition|(
name|bp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
name|bp
operator|++
expr_stmt|;
comment|/* But count source lines anyway.  */
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
operator|++
operator|*
name|newlines
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cplusplus
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
operator|*
name|comments
operator|=
literal|1
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|bp
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
operator|++
operator|*
name|newlines
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|bp
index|[
literal|1
index|]
operator|!=
literal|'*'
operator|||
name|bp
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
operator|*
name|comments
operator|=
literal|1
expr_stmt|;
name|bp
operator|+=
literal|2
expr_stmt|;
while|while
condition|(
name|bp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|bp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
name|bp
operator|++
expr_stmt|;
block|}
name|bp
operator|+=
literal|1
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
block|{
name|int
name|quotec
decl_stmt|;
for|for
control|(
name|quotec
operator|=
operator|*
name|bp
operator|++
init|;
name|bp
operator|+
literal|1
operator|<
name|limit
operator|&&
operator|*
name|bp
operator|!=
name|quotec
condition|;
name|bp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\\'
condition|)
block|{
name|bp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
operator|++
operator|*
name|newlines
expr_stmt|;
while|while
condition|(
operator|*
name|bp
operator|==
literal|'\\'
operator|&&
name|bp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|bp
operator|+=
literal|2
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|bp
operator|==
literal|'\n'
condition|)
block|{
operator|++
operator|*
name|newlines
expr_stmt|;
if|if
condition|(
name|quotec
operator|==
literal|'\''
condition|)
break|break;
block|}
block|}
block|}
break|break;
case|case
literal|','
case|:
if|if
condition|(
operator|(
operator|*
name|depthptr
operator|)
operator|==
literal|0
condition|)
return|return
name|bp
return|;
break|break;
block|}
name|bp
operator|++
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
end_block

begin_comment
comment|/* Discard comments and duplicate newlines    in the string of length LENGTH at START,    except inside of string constants.    The string is copied into itself with its beginning staying fixed.       NEWLINES is the number of newlines that must be duplicated.    We assume that that much extra space is available past the end    of the string.  */
end_comment

begin_function
name|int
name|discard_comments
parameter_list|(
name|start
parameter_list|,
name|length
parameter_list|,
name|newlines
parameter_list|)
name|U_CHAR
modifier|*
name|start
decl_stmt|;
name|int
name|length
decl_stmt|;
name|int
name|newlines
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|ibp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|obp
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|limit
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
comment|/* If we have newlines to duplicate, copy everything      that many characters up.  Then, in the second part,      we will have room to insert the newlines      while copying down.      NEWLINES may actually be too large, because it counts      newlines in string constants, and we don't duplicate those.      But that does no harm.  */
if|if
condition|(
name|newlines
operator|>
literal|0
condition|)
block|{
name|ibp
operator|=
name|start
operator|+
name|length
expr_stmt|;
name|obp
operator|=
name|ibp
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|limit
operator|!=
name|ibp
condition|)
operator|*
operator|--
name|obp
operator|=
operator|*
operator|--
name|ibp
expr_stmt|;
block|}
name|ibp
operator|=
name|start
operator|+
name|newlines
expr_stmt|;
name|limit
operator|=
name|start
operator|+
name|length
operator|+
name|newlines
expr_stmt|;
name|obp
operator|=
name|start
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\n'
case|:
comment|/* Duplicate the newline.  */
operator|*
name|obp
operator|++
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\n'
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
argument_list|)
expr_stmt|;
comment|/* Delete any comment.  */
if|if
condition|(
name|cplusplus
operator|&&
name|ibp
index|[
literal|0
index|]
operator|==
literal|'/'
condition|)
block|{
name|obp
operator|--
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
operator|&&
operator|*
name|ibp
operator|++
operator|!=
literal|'\n'
condition|)
empty_stmt|;
break|break;
block|}
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|!=
literal|'*'
operator|||
name|ibp
operator|+
literal|1
operator|>=
name|limit
condition|)
break|break;
name|obp
operator|--
expr_stmt|;
name|ibp
operator|++
expr_stmt|;
while|while
condition|(
name|ibp
operator|+
literal|1
operator|<
name|limit
condition|)
block|{
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|2
index|]
operator|==
literal|'\n'
condition|)
name|newline_fix
argument_list|(
name|ibp
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ibp
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
break|break;
name|ibp
operator|++
expr_stmt|;
block|}
name|ibp
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
case|case
literal|'\"'
case|:
comment|/* Notice and skip strings, so that we don't 	 think that comments start inside them, 	 and so we don't duplicate newlines in them.  */
block|{
name|int
name|quotec
init|=
name|c
decl_stmt|;
while|while
condition|(
name|ibp
operator|<
name|limit
condition|)
block|{
operator|*
name|obp
operator|++
operator|=
name|c
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|quotec
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|quotec
operator|==
literal|'\''
condition|)
break|break;
if|if
condition|(
name|c
operator|==
literal|'\\'
operator|&&
name|ibp
operator|<
name|limit
condition|)
block|{
while|while
condition|(
operator|*
name|ibp
operator|==
literal|'\\'
operator|&&
name|ibp
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|ibp
operator|+=
literal|2
expr_stmt|;
operator|*
name|obp
operator|++
operator|=
operator|*
name|ibp
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
block|}
return|return
name|obp
operator|-
name|start
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  * error - print error message and increment count of errors.  */
end_comment

begin_macro
name|error
argument_list|(
argument|msg
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Error including a message from `errno'.  */
end_comment

begin_macro
name|error_from_errno
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: undocumented I/O error\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Print error message but don't count it.  */
end_comment

begin_macro
name|warning
argument_list|(
argument|msg
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|inhibit_warnings
condition|)
return|return
literal|0
return|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|fname
argument_list|,
name|ip
operator|->
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_macro
name|error_with_line
argument_list|(
argument|line
argument_list|,
argument|msg
argument_list|,
argument|arg1
argument_list|,
argument|arg2
argument_list|,
argument|arg3
argument_list|)
end_macro

begin_decl_stmt
name|int
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
decl_stmt|;
name|FILE_BUF
modifier|*
name|ip
init|=
name|NULL
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
name|NULL
condition|)
block|{
name|ip
operator|=
operator|&
name|instack
index|[
name|i
index|]
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: "
argument_list|,
name|ip
operator|->
name|fname
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|msg
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/* Return the line at which an error occurred.    The error is not necessarily associated with the current spot    in the input stack, so LINE says where.  LINE will have been    copied from ip->lineno for the current input level.    If the current level is for a file, we return LINE.    But if the current level is not for a file, LINE is meaningless.    In that case, we return the lineno of the innermost file.  */
end_comment

begin_function
name|int
name|line_for_error
parameter_list|(
name|line
parameter_list|)
name|int
name|line
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|int
name|line1
init|=
name|line
decl_stmt|;
for|for
control|(
name|i
operator|=
name|indepth
init|;
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|instack
index|[
name|i
index|]
operator|.
name|fname
operator|!=
literal|0
condition|)
return|return
name|line1
return|;
name|i
operator|--
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|line1
operator|=
name|instack
index|[
name|i
index|]
operator|.
name|lineno
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * If OBUF doesn't have NEEDED bytes after OPTR, make it bigger.  *  * As things stand, nothing is ever placed in the output buffer to be  * removed again except when it's KNOWN to be part of an identifier,  * so flushing and moving down everything left, instead of expanding,  * should work ok.  */
end_comment

begin_function
name|int
name|grow_outbuf
parameter_list|(
name|obuf
parameter_list|,
name|needed
parameter_list|)
specifier|register
name|FILE_BUF
modifier|*
name|obuf
decl_stmt|;
specifier|register
name|int
name|needed
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|;
name|int
name|minsize
decl_stmt|;
if|if
condition|(
name|obuf
operator|->
name|length
operator|-
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
operator|>
name|needed
condition|)
return|return;
comment|/* Make it at least twice as big as it is now.  */
name|obuf
operator|->
name|length
operator|*=
literal|2
expr_stmt|;
comment|/* Make it have at least 150% of the free space we will need.  */
name|minsize
operator|=
operator|(
literal|3
operator|*
name|needed
operator|)
operator|/
literal|2
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
if|if
condition|(
name|minsize
operator|>
name|obuf
operator|->
name|length
condition|)
name|obuf
operator|->
name|length
operator|=
name|minsize
expr_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|xrealloc
argument_list|(
name|obuf
operator|->
name|buf
argument_list|,
name|obuf
operator|->
name|length
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|memory_full
argument_list|()
expr_stmt|;
name|obuf
operator|->
name|bufp
operator|=
name|p
operator|+
operator|(
name|obuf
operator|->
name|bufp
operator|-
name|obuf
operator|->
name|buf
operator|)
expr_stmt|;
name|obuf
operator|->
name|buf
operator|=
name|p
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Symbol table for macro names and special symbols */
end_comment

begin_comment
comment|/*  * install a name in the main hash table, even if it is already there.  *   name stops with first non alphanumeric, except leading '#'.  * caller must check against redefinition if that is desired.  * delete_macro () removes things installed by install () in fifo order.  * this is important because of the `defined' special symbol used  * in #if, and also if pushdef/popdef directives are ever implemented.  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|install
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|type
parameter_list|,
name|value
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|enum
name|node_type
name|type
decl_stmt|;
name|int
name|value
decl_stmt|;
name|int
name|hash
decl_stmt|;
comment|/* watch out here if sizeof (U_CHAR *) != sizeof (int) */
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|,
name|bucket
decl_stmt|;
specifier|register
name|U_CHAR
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|p
operator|=
name|name
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
name|len
operator|=
name|p
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|i
operator|=
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
operator|+
name|len
operator|+
literal|1
expr_stmt|;
name|hp
operator|=
operator|(
name|HASHNODE
operator|*
operator|)
name|xmalloc
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hash
expr_stmt|;
name|hp
operator|->
name|bucket_hdr
operator|=
operator|&
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hp
operator|->
name|next
operator|=
name|hashtab
index|[
name|bucket
index|]
expr_stmt|;
name|hashtab
index|[
name|bucket
index|]
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|prev
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
expr_stmt|;
name|hp
operator|->
name|type
operator|=
name|type
expr_stmt|;
name|hp
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|hp
operator|->
name|value
operator|.
name|ival
operator|=
name|value
expr_stmt|;
name|hp
operator|->
name|name
operator|=
operator|(
operator|(
name|U_CHAR
operator|*
operator|)
name|hp
operator|)
operator|+
sizeof|sizeof
argument_list|(
name|HASHNODE
argument_list|)
expr_stmt|;
name|p
operator|=
name|hp
operator|->
name|name
expr_stmt|;
name|q
operator|=
name|name
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
operator|*
name|p
operator|++
operator|=
operator|*
name|q
operator|++
expr_stmt|;
name|hp
operator|->
name|name
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
return|return
name|hp
return|;
block|}
end_function

begin_comment
comment|/*  * find the most recent hash node for name name (ending with first  * non-identifier char) installed by install  *  * If LEN is>= 0, it is the length of the name.  * Otherwise, compute the length by scanning the entire name.  *  * If HASH is>= 0, it is the precomputed hash code.  * Otherwise, compute the hash code.  */
end_comment

begin_function
name|HASHNODE
modifier|*
name|lookup
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hash
parameter_list|)
name|U_CHAR
modifier|*
name|name
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|hash
decl_stmt|;
block|{
specifier|register
name|U_CHAR
modifier|*
name|bp
decl_stmt|;
specifier|register
name|HASHNODE
modifier|*
name|bucket
decl_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|bp
operator|=
name|name
init|;
name|is_idchar
index|[
operator|*
name|bp
index|]
condition|;
name|bp
operator|++
control|)
empty_stmt|;
name|len
operator|=
name|bp
operator|-
name|name
expr_stmt|;
block|}
if|if
condition|(
name|hash
operator|<
literal|0
condition|)
name|hash
operator|=
name|hashf
argument_list|(
name|name
argument_list|,
name|len
argument_list|,
name|HASHSIZE
argument_list|)
expr_stmt|;
name|bucket
operator|=
name|hashtab
index|[
name|hash
index|]
expr_stmt|;
while|while
condition|(
name|bucket
condition|)
block|{
if|if
condition|(
name|bucket
operator|->
name|length
operator|==
name|len
operator|&&
name|strncmp
argument_list|(
name|bucket
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
return|return
name|bucket
return|;
name|bucket
operator|=
name|bucket
operator|->
name|next
expr_stmt|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Delete a hash node.  Some weirdness to free junk from macros.  * More such weirdness will have to be added if you define more hash  * types that need it.  */
end_comment

begin_comment
comment|/* Note that the DEFINITION of a macro is removed from the hash table    but its storage is not freed.  This would be a storage leak    except that it is not reasonable to keep undefining and redefining    large numbers of macros many times.    In any case, this is necessary, because a macro can be #undef'd    in the middle of reading the arguments to a call to it.    If #undef freed the DEFINITION, that would crash.  */
end_comment

begin_macro
name|delete_macro
argument_list|(
argument|hp
argument_list|)
end_macro

begin_decl_stmt
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|hp
operator|->
name|prev
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|prev
operator|->
name|next
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|next
operator|!=
name|NULL
condition|)
name|hp
operator|->
name|next
operator|->
name|prev
operator|=
name|hp
operator|->
name|prev
expr_stmt|;
comment|/* make sure that the bucket chain header that      the deleted guy was on points to the right thing afterwards. */
if|if
condition|(
name|hp
operator|==
operator|*
name|hp
operator|->
name|bucket_hdr
condition|)
operator|*
name|hp
operator|->
name|bucket_hdr
operator|=
name|hp
operator|->
name|next
expr_stmt|;
if|#
directive|if
literal|0
block|if (hp->type == T_MACRO) {     DEFINITION *d = hp->value.defn;     struct reflist *ap, *nextap;      for (ap = d->pattern; ap != NULL; ap = nextap) {       nextap = ap->next;       free (ap);     }     free (d);   }
endif|#
directive|endif
name|free
argument_list|(
name|hp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * return hash function on name.  must be compatible with the one  * computed a step at a time, elsewhere  */
end_comment

begin_function
name|int
name|hashf
parameter_list|(
name|name
parameter_list|,
name|len
parameter_list|,
name|hashsize
parameter_list|)
specifier|register
name|U_CHAR
modifier|*
name|name
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|int
name|hashsize
decl_stmt|;
block|{
specifier|register
name|int
name|r
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|len
operator|--
condition|)
name|r
operator|=
name|HASHSTEP
argument_list|(
name|r
argument_list|,
operator|*
name|name
operator|++
argument_list|)
expr_stmt|;
return|return
name|MAKE_POS
argument_list|(
name|r
argument_list|)
operator|%
name|hashsize
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Dump all macro definitions as #defines to stdout.  */
end_comment

begin_function
name|void
name|dump_all_macros
parameter_list|()
block|{
name|int
name|bucket
decl_stmt|;
for|for
control|(
name|bucket
operator|=
literal|0
init|;
name|bucket
operator|<
name|HASHSIZE
condition|;
name|bucket
operator|++
control|)
block|{
specifier|register
name|HASHNODE
modifier|*
name|hp
decl_stmt|;
for|for
control|(
name|hp
operator|=
name|hashtab
index|[
name|bucket
index|]
init|;
name|hp
condition|;
name|hp
operator|=
name|hp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|hp
operator|->
name|type
operator|==
name|T_MACRO
condition|)
block|{
specifier|register
name|DEFINITION
modifier|*
name|defn
init|=
name|hp
operator|->
name|value
operator|.
name|defn
decl_stmt|;
name|struct
name|reflist
modifier|*
name|ap
decl_stmt|;
name|int
name|offset
decl_stmt|;
name|int
name|concat
decl_stmt|;
comment|/* Print the definition of the macro HP.  */
name|printf
argument_list|(
literal|"#define %s"
argument_list|,
name|hp
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|defn
operator|->
name|nargs
operator|>=
literal|0
condition|)
block|{
name|int
name|i
decl_stmt|;
name|printf
argument_list|(
literal|"("
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|defn
operator|->
name|nargs
condition|;
name|i
operator|++
control|)
block|{
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
name|printf
argument_list|(
literal|", "
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|")"
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|concat
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|defn
operator|->
name|pattern
init|;
name|ap
operator|!=
name|NULL
condition|;
name|ap
operator|=
name|ap
operator|->
name|next
control|)
block|{
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|ap
operator|->
name|nchars
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|nchars
operator|!=
literal|0
condition|)
name|concat
operator|=
literal|0
expr_stmt|;
name|offset
operator|+=
name|ap
operator|->
name|nchars
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|stringify
condition|)
name|printf
argument_list|(
literal|" #"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_before
operator|&&
operator|!
name|concat
condition|)
name|printf
argument_list|(
literal|" ## "
argument_list|)
expr_stmt|;
name|concat
operator|=
literal|0
expr_stmt|;
name|dump_arg_n
argument_list|(
name|defn
argument_list|,
name|ap
operator|->
name|argno
argument_list|)
expr_stmt|;
if|if
condition|(
name|ap
operator|->
name|raw_after
condition|)
block|{
name|printf
argument_list|(
literal|" ## "
argument_list|)
expr_stmt|;
name|concat
operator|=
literal|1
expr_stmt|;
block|}
block|}
name|dump_defn_1
argument_list|(
name|defn
operator|->
name|expansion
argument_list|,
name|offset
argument_list|,
name|defn
operator|->
name|length
operator|-
name|offset
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* Output to stdout a substring of a macro definition.    BASE is the beginning of the definition.    Output characters START thru LENGTH.    Discard newlines outside of strings, thus    converting funny-space markers to ordinary spaces.  */
end_comment

begin_macro
name|dump_defn_1
argument_list|(
argument|base
argument_list|,
argument|start
argument_list|,
argument|length
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|base
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|start
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|U_CHAR
modifier|*
name|p
init|=
name|base
operator|+
name|start
decl_stmt|;
name|U_CHAR
modifier|*
name|limit
init|=
name|base
operator|+
name|start
operator|+
name|length
decl_stmt|;
while|while
condition|(
name|p
operator|<
name|limit
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\n'
condition|)
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\"'
operator|||
operator|*
name|p
operator|==
literal|'\''
condition|)
block|{
name|U_CHAR
modifier|*
name|p1
init|=
name|skip_quoted_string
argument_list|(
name|p
argument_list|,
name|limit
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|fwrite
argument_list|(
name|p
argument_list|,
name|p1
operator|-
name|p
argument_list|,
literal|1
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|p
operator|=
name|p1
operator|-
literal|1
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Print the name of argument number ARGNUM of macro definition DEFN.    Recall that DEFN->argnames contains all the arg names    concatenated in reverse order with comma-space in between.  */
end_comment

begin_macro
name|dump_arg_n
argument_list|(
argument|defn
argument_list|,
argument|argnum
argument_list|)
end_macro

begin_decl_stmt
name|DEFINITION
modifier|*
name|defn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|argnum
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|U_CHAR
modifier|*
name|p
init|=
name|defn
operator|->
name|argnames
decl_stmt|;
while|while
condition|(
name|argnum
operator|+
literal|1
operator|<
name|defn
operator|->
name|nargs
condition|)
block|{
name|p
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|index
argument_list|(
name|p
argument_list|,
literal|' '
argument_list|)
operator|+
literal|1
expr_stmt|;
name|argnum
operator|++
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|','
condition|)
block|{
name|putchar
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Initialize syntactic classifications of characters.  */
end_comment

begin_macro
name|initialize_char_syntax
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/*    * Set up is_idchar and is_idstart tables.  These should be    * faster than saying (is_alpha (c) || c == '_'), etc.    * Must do set up these things before calling any routines tthat    * refer to them.    */
for|for
control|(
name|i
operator|=
literal|'a'
init|;
name|i
operator|<=
literal|'z'
condition|;
name|i
operator|++
control|)
block|{
name|is_idchar
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
operator|-
literal|'a'
operator|+
literal|'A'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|'0'
init|;
name|i
operator|<=
literal|'9'
condition|;
name|i
operator|++
control|)
name|is_idchar
index|[
name|i
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idstart
index|[
literal|'_'
index|]
operator|=
literal|1
expr_stmt|;
name|is_idchar
index|[
literal|'$'
index|]
operator|=
name|dollars_in_ident
expr_stmt|;
name|is_idstart
index|[
literal|'$'
index|]
operator|=
name|dollars_in_ident
expr_stmt|;
comment|/* horizontal space table */
name|is_hor_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_hor_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|' '
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\t'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\v'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\f'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\n'
index|]
operator|=
literal|1
expr_stmt|;
name|is_space
index|[
literal|'\r'
index|]
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Initialize the built-in macros.  */
end_comment

begin_macro
name|initialize_builtins
argument_list|()
end_macro

begin_block
block|{
name|install
argument_list|(
literal|"__LINE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_SPECLINE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__DATE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_DATE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_FILE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__BASE_FILE__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_BASE_FILE
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__INCLUDE_LEVEL__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_INCLUDE_LEVEL
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__VERSION__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_VERSION
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|install
argument_list|(
literal|"__TIME__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_TIME
argument_list|,
literal|0
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|traditional
condition|)
name|install
argument_list|(
literal|"__STDC__"
argument_list|,
operator|-
literal|1
argument_list|,
name|T_CONST
argument_list|,
name|STDC_VALUE
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
comment|/*  install ("__GNU__", -1, T_CONST, 1, -1);  */
comment|/*  This is supplied using a -D by the compiler driver     so that it is present only when truly compiling with GNU C.  */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  * process a given definition string, for initialization  * If STR is just an identifier, define it with value 1.  * If STR has anything after the identifier, then it should  * be identifier-space-definition.  */
end_comment

begin_macro
name|make_definition
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|U_CHAR
modifier|*
name|buf
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|buf
operator|=
name|str
expr_stmt|;
name|p
operator|=
name|str
expr_stmt|;
while|while
condition|(
name|is_idchar
index|[
operator|*
name|p
index|]
condition|)
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|str
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
name|p
operator|-
name|buf
operator|+
literal|4
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
argument_list|,
literal|" 1"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|p
operator|!=
literal|' '
condition|)
block|{
name|error
argument_list|(
literal|"malformed option `-D %s'"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
block|{
name|U_CHAR
modifier|*
name|q
decl_stmt|;
comment|/* Copy the entire option so we can modify it.  */
name|buf
operator|=
operator|(
name|U_CHAR
operator|*
operator|)
name|alloca
argument_list|(
literal|2
operator|*
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|buf
argument_list|,
name|str
argument_list|,
name|p
operator|-
name|str
argument_list|)
expr_stmt|;
comment|/* Change the = to a space.  */
name|buf
index|[
name|p
operator|-
name|str
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* Scan for any backslash-newline and remove it.  */
name|p
operator|++
expr_stmt|;
name|q
operator|=
operator|&
name|buf
index|[
name|p
operator|-
name|str
index|]
expr_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|p
operator|+=
literal|2
expr_stmt|;
comment|/* Change newline chars into newline-markers.  */
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|q
operator|++
operator|=
literal|'\n'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|0
expr_stmt|;
block|}
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|"*Initialization*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|buf
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_DEFINE
condition|;
name|kt
operator|++
control|)
empty_stmt|;
comment|/* pass NULL as output ptr to do_define since we KNOW it never      does any output.... */
name|do_define
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|,
name|NULL
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_block

begin_comment
comment|/* JF, this does the work for the -U option */
end_comment

begin_macro
name|make_undef
argument_list|(
argument|str
argument_list|)
end_macro

begin_decl_stmt
name|U_CHAR
modifier|*
name|str
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE_BUF
modifier|*
name|ip
decl_stmt|;
name|struct
name|directive
modifier|*
name|kt
decl_stmt|;
name|ip
operator|=
operator|&
name|instack
index|[
operator|++
name|indepth
index|]
expr_stmt|;
name|ip
operator|->
name|fname
operator|=
literal|"*undef*"
expr_stmt|;
name|ip
operator|->
name|buf
operator|=
name|ip
operator|->
name|bufp
operator|=
name|str
expr_stmt|;
name|ip
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ip
operator|->
name|lineno
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|macro
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|free_ptr
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|if_stack
operator|=
name|if_stack
expr_stmt|;
for|for
control|(
name|kt
operator|=
name|directive_table
init|;
name|kt
operator|->
name|type
operator|!=
name|T_UNDEF
condition|;
name|kt
operator|++
control|)
empty_stmt|;
name|do_undef
argument_list|(
name|str
argument_list|,
name|str
operator|+
name|strlen
argument_list|(
name|str
argument_list|)
operator|-
literal|1
argument_list|,
name|NULL
argument_list|,
name|kt
argument_list|)
expr_stmt|;
operator|--
name|indepth
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/* Add output to `deps_buffer' for the -M switch.    STRING points to the text to be output.    SIZE is the number of bytes, or 0 meaning output until a null.    If SIZE is nonzero, we break the line first, if it is long enough.  */
end_comment

begin_macro
name|deps_output
argument_list|(
argument|string
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifndef|#
directive|ifndef
name|MAX_OUTPUT_COLUMNS
define|#
directive|define
name|MAX_OUTPUT_COLUMNS
value|75
endif|#
directive|endif
if|if
condition|(
name|size
operator|!=
literal|0
operator|&&
name|deps_column
operator|!=
literal|0
operator|&&
name|size
operator|+
name|deps_column
operator|>
name|MAX_OUTPUT_COLUMNS
condition|)
block|{
name|deps_output
argument_list|(
literal|"\\\n  "
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|deps_column
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|size
operator|==
literal|0
condition|)
name|size
operator|=
name|strlen
argument_list|(
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|deps_size
operator|+
name|size
operator|+
literal|1
operator|>
name|deps_allocated_size
condition|)
block|{
name|deps_allocated_size
operator|=
name|deps_size
operator|+
name|size
operator|+
literal|50
expr_stmt|;
name|deps_allocated_size
operator|*=
literal|2
expr_stmt|;
name|deps_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|xrealloc
argument_list|(
name|deps_buffer
argument_list|,
name|deps_allocated_size
argument_list|)
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|string
argument_list|,
operator|&
name|deps_buffer
index|[
name|deps_size
index|]
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|deps_size
operator|+=
name|size
expr_stmt|;
name|deps_column
operator|+=
name|size
expr_stmt|;
name|deps_buffer
index|[
name|deps_size
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_escape
end_escape

begin_ifndef
ifndef|#
directive|ifndef
name|BSD
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|BSTRING
end_ifndef

begin_function
name|void
name|bzero
parameter_list|(
name|b
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|short
name|zero
init|=
literal|0
decl_stmt|;
name|long
name|max_str
init|=
literal|65535
decl_stmt|;
while|while
condition|(
name|length
operator|>
name|max_str
condition|)
block|{
operator|(
name|void
operator|)
name|LIB$MOVC5
argument_list|(
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|max_str
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|length
operator|-=
name|max_str
expr_stmt|;
name|b
operator|+=
name|max_str
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|LIB$MOVC5
argument_list|(
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|zero
argument_list|,
operator|&
name|length
argument_list|,
name|b
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b
operator|++
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_function
name|void
name|bcopy
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|long
name|max_str
init|=
literal|65535
decl_stmt|;
while|while
condition|(
name|length
operator|>
name|max_str
condition|)
block|{
operator|(
name|void
operator|)
name|LIB$MOVC3
argument_list|(
operator|&
name|max_str
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
name|length
operator|-=
name|max_str
expr_stmt|;
name|b1
operator|+=
name|max_str
expr_stmt|;
name|b2
operator|+=
name|max_str
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|LIB$MOVC3
argument_list|(
operator|&
name|length
argument_list|,
name|b1
argument_list|,
name|b2
argument_list|)
expr_stmt|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
operator|*
name|b2
operator|++
operator|=
operator|*
name|b1
operator|++
expr_stmt|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_function
name|int
name|bcmp
parameter_list|(
name|b1
parameter_list|,
name|b2
parameter_list|,
name|length
parameter_list|)
comment|/* This could be a macro! */
specifier|register
name|char
modifier|*
name|b1
decl_stmt|;
specifier|register
name|char
modifier|*
name|b2
decl_stmt|;
specifier|register
name|int
name|length
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|VMS
name|struct
name|dsc$descriptor_s
name|src1
init|=
block|{
name|length
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|b1
block|}
decl_stmt|;
name|struct
name|dsc$descriptor_s
name|src2
init|=
block|{
name|length
block|,
name|DSC$K_DTYPE_T
block|,
name|DSC$K_CLASS_S
block|,
name|b2
block|}
decl_stmt|;
return|return
name|STR$COMPARE
argument_list|(
operator|&
name|src1
argument_list|,
operator|&
name|src2
argument_list|)
return|;
else|#
directive|else
while|while
condition|(
name|length
operator|--
operator|>
literal|0
condition|)
if|if
condition|(
operator|*
name|b1
operator|++
operator|!=
operator|*
name|b2
operator|++
condition|)
return|return
literal|1
return|;
return|return
literal|0
return|;
endif|#
directive|endif
comment|/* not VMS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSTRING */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD */
end_comment

begin_escape
end_escape

begin_function
name|void
name|fatal
parameter_list|(
name|str
parameter_list|,
name|arg
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|,
decl|*
name|arg
decl_stmt|;
end_function

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|str
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* More 'friendly' abort that prints the line and file.    config.h can #define abort fancy_abort if you like that sort of thing.  */
end_comment

begin_function
name|void
name|fancy_abort
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Internal gcc abort."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|perror_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|progname
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s\n"
argument_list|,
name|name
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: undocumented I/O error\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pfatal_with_name
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|perror_with_name
argument_list|(
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|VMS
name|exit
argument_list|(
name|vaxc$errno
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
name|FATAL_EXIT_CODE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_escape
end_escape

begin_function
name|void
name|memory_full
parameter_list|()
block|{
name|fatal
argument_list|(
literal|"Memory exhausted."
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|char
modifier|*
name|xrealloc
parameter_list|(
name|old
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|old
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|realloc
parameter_list|()
function_decl|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|realloc
argument_list|(
name|old
argument_list|,
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|char
modifier|*
name|xcalloc
parameter_list|(
name|number
parameter_list|,
name|size
parameter_list|)
name|int
name|number
decl_stmt|,
name|size
decl_stmt|;
block|{
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
specifier|register
name|int
name|total
init|=
name|number
operator|*
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
init|=
name|malloc
argument_list|(
name|total
argument_list|)
decl_stmt|;
if|if
condition|(
name|ptr
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|total
operator|>
literal|100
condition|)
name|bzero
argument_list|(
name|ptr
argument_list|,
name|total
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* It's not too long, so loop, zeroing by longs. 	 It must be safe because malloc values are always well aligned.  */
specifier|register
name|long
modifier|*
name|zp
init|=
operator|(
name|long
operator|*
operator|)
name|ptr
decl_stmt|;
specifier|register
name|long
modifier|*
name|zl
init|=
operator|(
name|long
operator|*
operator|)
operator|(
name|ptr
operator|+
name|total
operator|-
literal|4
operator|)
decl_stmt|;
specifier|register
name|int
name|i
init|=
name|total
operator|-
literal|4
decl_stmt|;
while|while
condition|(
name|zp
operator|<
name|zl
condition|)
operator|*
name|zp
operator|++
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|total
condition|)
name|ptr
index|[
name|i
operator|++
index|]
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|ptr
return|;
block|}
name|memory_full
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_function
name|char
modifier|*
name|savestring
parameter_list|(
name|input
parameter_list|)
name|char
modifier|*
name|input
decl_stmt|;
block|{
name|int
name|size
init|=
name|strlen
argument_list|(
name|input
argument_list|)
decl_stmt|;
name|char
modifier|*
name|output
init|=
name|xmalloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|output
argument_list|,
name|input
argument_list|)
expr_stmt|;
return|return
name|output
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Get the file-mode and data size of the file open on FD    and store them in *MODE_POINTER and *SIZE_POINTER.  */
end_comment

begin_function
name|int
name|file_size_and_mode
parameter_list|(
name|fd
parameter_list|,
name|mode_pointer
parameter_list|,
name|size_pointer
parameter_list|)
name|int
name|fd
decl_stmt|;
name|int
modifier|*
name|mode_pointer
decl_stmt|;
name|long
name|int
modifier|*
name|size_pointer
decl_stmt|;
block|{
name|struct
name|stat
name|sbuf
decl_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sbuf
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|mode_pointer
condition|)
operator|*
name|mode_pointer
operator|=
name|sbuf
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
name|size_pointer
condition|)
operator|*
name|size_pointer
operator|=
name|sbuf
operator|.
name|st_size
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* Under VMS we need to fix up the "include" specification    filename so that everything following the 1st slash is    changed into its correct VMS file specification. */
end_comment

begin_macro
name|hack_vms_include_specification
argument_list|(
argument|fname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|char
name|Local
index|[
literal|512
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|rindex
argument_list|()
decl_stmt|;
comment|/* Ignore leading "./"s */
while|while
condition|(
name|fname
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|fname
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
name|strcpy
argument_list|(
name|fname
argument_list|,
name|fname
operator|+
literal|2
argument_list|)
expr_stmt|;
comment|/* Look for the boundary between the VMS and UNIX filespecs */
name|cp
operator|=
name|rindex
argument_list|(
name|fname
argument_list|,
literal|']'
argument_list|)
expr_stmt|;
comment|/* Look for end of dirspec. */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|==
name|rindex
argument_list|(
name|fname
argument_list|,
literal|'>'
argument_list|)
expr_stmt|;
comment|/* ... Ditto		    */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
name|cp
operator|==
name|rindex
argument_list|(
name|fname
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
comment|/* Look for end of devspec. */
if|if
condition|(
name|cp
condition|)
block|{
name|cp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|index
argument_list|(
name|fname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* Look for the "/" */
block|}
comment|/* See if we found that 1st slash */
if|if
condition|(
name|cp
operator|==
literal|0
condition|)
return|return;
comment|/* Nothing to do!!! */
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'/'
condition|)
return|return;
comment|/* Nothing to do!!! */
comment|/* Point to the UNIX filename part (which needs to be fixed!) */
name|cp1
operator|=
name|cp
operator|+
literal|1
expr_stmt|;
comment|/* If the directory spec is not rooted, we can just copy      the UNIX filename part and we are done */
if|if
condition|(
operator|(
operator|(
name|cp
operator|-
name|fname
operator|)
operator|>
literal|2
operator|)
operator|&&
operator|(
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|']'
operator|)
operator|||
operator|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|)
operator|&&
operator|(
name|cp
index|[
operator|-
literal|2
index|]
operator|!=
literal|'.'
operator|)
condition|)
block|{
name|strcpy
argument_list|(
name|cp
argument_list|,
name|cp1
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If there are no other slashes then the filename will be      in the "root" directory.  Otherwise, we need to add      directory specifications. */
if|if
condition|(
name|index
argument_list|(
name|cp1
argument_list|,
literal|'/'
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* Just add "[000000]" as the directory string */
name|strcpy
argument_list|(
name|Local
argument_list|,
literal|"[000000]"
argument_list|)
expr_stmt|;
name|cp2
operator|=
name|Local
operator|+
name|strlen
argument_list|(
name|Local
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Open the directory specification */
name|cp2
operator|=
name|Local
expr_stmt|;
operator|*
name|cp2
operator|++
operator|=
literal|'['
expr_stmt|;
comment|/* As long as there are still subdirectories to add, do them. */
while|while
condition|(
name|index
argument_list|(
name|cp1
argument_list|,
literal|'/'
argument_list|)
operator|!=
literal|0
condition|)
block|{
comment|/* If this token is "." we can ignore it */
if|if
condition|(
operator|(
name|cp1
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|cp1
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
name|cp1
operator|+=
literal|2
expr_stmt|;
continue|continue;
block|}
comment|/* Add a subdirectory spec. */
if|if
condition|(
name|cp2
operator|!=
name|Local
operator|+
literal|1
condition|)
operator|*
name|cp2
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* If this is ".." then the spec becomes "-" */
if|if
condition|(
operator|(
name|cp1
index|[
literal|0
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|cp1
index|[
literal|1
index|]
operator|==
literal|'.'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|2
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* Add "-" and skip the ".." */
operator|*
name|cp2
operator|++
operator|=
literal|'-'
expr_stmt|;
name|cp1
operator|+=
literal|3
expr_stmt|;
continue|continue;
block|}
comment|/* Copy the subdirectory */
while|while
condition|(
operator|*
name|cp1
operator|!=
literal|'/'
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
name|cp1
operator|++
expr_stmt|;
comment|/* Skip the "/" */
block|}
comment|/* Close the directory specification */
operator|*
name|cp2
operator|++
operator|=
literal|']'
expr_stmt|;
block|}
comment|/* Now add the filename */
while|while
condition|(
operator|*
name|cp1
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
operator|++
expr_stmt|;
operator|*
name|cp2
operator|=
literal|0
expr_stmt|;
comment|/* Now append it to the original VMS spec. */
name|strcpy
argument_list|(
name|cp
argument_list|,
name|Local
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

begin_escape
end_escape

begin_ifdef
ifdef|#
directive|ifdef
name|VMS
end_ifdef

begin_comment
comment|/* These are the read/write replacement routines for    VAX-11 "C".  They make read/write behave enough    like their UNIX counterparts that CCCP will work */
end_comment

begin_function
name|int
name|read
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
undef|#
directive|undef
name|read
comment|/* Get back the REAL read routine */
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|total
init|=
literal|0
decl_stmt|;
comment|/* Read until the buffer is exhausted */
while|while
condition|(
name|size
operator|>
literal|0
condition|)
block|{
comment|/* Limit each read to 32KB */
name|i
operator|=
operator|(
name|size
operator|>
operator|(
literal|32
operator|*
literal|1024
operator|)
operator|)
condition|?
operator|(
literal|32
operator|*
literal|1024
operator|)
else|:
name|size
expr_stmt|;
name|i
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|==
literal|0
condition|)
return|return
operator|(
name|total
operator|)
return|;
return|return
operator|(
name|i
operator|)
return|;
block|}
comment|/* Account for this read */
name|total
operator|+=
name|i
expr_stmt|;
name|buf
operator|+=
name|i
expr_stmt|;
name|size
operator|-=
name|i
expr_stmt|;
block|}
return|return
operator|(
name|total
operator|)
return|;
block|}
end_function

begin_function
name|int
name|write
parameter_list|(
name|fd
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|fd
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
undef|#
directive|undef
name|write
comment|/* Get back the REAL write routine */
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
comment|/* Limit individual writes to 32Kb */
name|i
operator|=
name|size
expr_stmt|;
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|j
operator|=
operator|(
name|i
operator|>
operator|(
literal|32
operator|*
literal|1024
operator|)
operator|)
condition|?
operator|(
literal|32
operator|*
literal|1024
operator|)
else|:
name|i
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|j
argument_list|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* Account for the data written */
name|buf
operator|+=
name|j
expr_stmt|;
name|i
operator|-=
name|j
expr_stmt|;
block|}
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* VMS */
end_comment

end_unit

