begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Subroutines for manipulating rtx's in semantically interesting ways.    Copyright (C) 1987 Free Software Foundation, Inc.  This file is part of GNU CC.  GNU CC is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 1, or (at your option) any later version.  GNU CC is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details.  You should have received a copy of the GNU General Public License along with GNU CC; see the file COPYING.  If not, write to the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"rtl.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"flags.h"
end_include

begin_include
include|#
directive|include
file|"expr.h"
end_include

begin_comment
comment|/* Return an rtx for the sum of X and the integer C.  */
end_comment

begin_function
name|rtx
name|plus_constant
parameter_list|(
name|x
parameter_list|,
name|c
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
block|{
specifier|register
name|RTX_CODE
name|code
init|=
name|GET_CODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
specifier|register
name|enum
name|machine_mode
name|mode
init|=
name|GET_MODE
argument_list|(
name|x
argument_list|)
decl_stmt|;
name|int
name|all_constant
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|c
operator|==
literal|0
condition|)
return|return
name|x
return|;
if|if
condition|(
name|code
operator|==
name|CONST_INT
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
operator|(
name|INTVAL
argument_list|(
name|x
argument_list|)
operator|+
name|c
operator|)
argument_list|)
return|;
comment|/* If adding to something entirely constant, set a flag      so that we can add a CONST around the result.  */
if|if
condition|(
name|code
operator|==
name|CONST
condition|)
block|{
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|all_constant
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|code
operator|==
name|SYMBOL_REF
operator|||
name|code
operator|==
name|LABEL_REF
condition|)
name|all_constant
operator|=
literal|1
expr_stmt|;
comment|/* The interesting case is adding the integer to a sum.      Look for constant term in the sum and combine      with C.  For an integer constant term, we make a combined      integer.  For a constant term that is not an explicit integer,      we cannot really combine, but group them together anyway.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|c
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|x
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
condition|)
block|{
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
block|}
ifdef|#
directive|ifdef
name|OLD_INDEXING
comment|/* Detect adding a constant to an indexed address 	 of the form (PLUS (MULT (REG) (CONST)) regs-and-constants). 	 Keep the (MULT ...) at the top level of addition so that 	 the result is still suitable for indexing and constants 	 are combined.  */
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|)
return|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|MULT
condition|)
block|{
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|plus_constant
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|c
argument_list|)
argument_list|,
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
return|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|mode
argument_list|,
name|x
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|c
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|LABEL_REF
condition|)
return|return
name|x
return|;
elseif|else
if|if
condition|(
name|all_constant
condition|)
return|return
name|gen_rtx
argument_list|(
name|CONST
argument_list|,
name|mode
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* If X is a sum, return a new sum like X but lacking any constant terms.    Add all the removed constant terms into *CONSTPTR.    X itself is not altered.  The result != X if and only if    it is not isomorphic to X.  */
end_comment

begin_function
name|rtx
name|eliminate_constant_term
parameter_list|(
name|x
parameter_list|,
name|constptr
parameter_list|)
name|rtx
name|x
decl_stmt|;
name|int
modifier|*
name|constptr
decl_stmt|;
block|{
name|int
name|c
decl_stmt|;
specifier|register
name|rtx
name|x0
decl_stmt|,
name|x1
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|PLUS
condition|)
return|return
name|x
return|;
comment|/* First handle constants appearing at this level explicitly.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|constptr
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
name|constptr
argument_list|)
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
operator|*
name|constptr
operator|+=
name|INTVAL
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
name|constptr
argument_list|)
return|;
block|}
name|c
operator|=
literal|0
expr_stmt|;
name|x0
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
name|x1
operator|=
name|eliminate_constant_term
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|,
operator|&
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|x1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
operator|||
name|x0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
condition|)
block|{
operator|*
name|constptr
operator|+=
name|c
expr_stmt|;
return|return
name|gen_rtx
argument_list|(
name|PLUS
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|x0
argument_list|,
name|x1
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx for the size in bytes of the value of EXP.  */
end_comment

begin_function
name|rtx
name|expr_size
parameter_list|(
name|exp
parameter_list|)
name|tree
name|exp
decl_stmt|;
block|{
return|return
name|expand_expr
argument_list|(
name|size_in_bytes
argument_list|(
name|TREE_TYPE
argument_list|(
name|exp
argument_list|)
argument_list|)
argument_list|,
literal|0
argument_list|,
name|SImode
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Not yet really written since C does not need it.  */
end_comment

begin_function
name|rtx
name|lookup_static_chain
parameter_list|(
name|context
parameter_list|)
name|rtx
name|context
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a copy of X in which all memory references    and all constants that involve symbol refs    have been replaced with new temporary registers.    Also emit code to load the memory locations and constants    into those registers.     If X contains no such constants or memory references,    X itself (not a copy) is returned.     X may contain no arithmetic except addition, subtraction and multiplication.    Values returned by expand_expr with 1 for sum_ok fit this constraint.  */
end_comment

begin_function
specifier|static
name|rtx
name|break_out_memory_refs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|CONST
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|SYMBOL_REF
condition|)
block|{
specifier|register
name|rtx
name|temp
init|=
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
decl_stmt|;
name|mark_reg_pointer
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|x
operator|=
name|temp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
condition|)
block|{
specifier|register
name|rtx
name|op0
init|=
name|break_out_memory_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|break_out_memory_refs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Given a memory address or facsimile X, construct a new address,    currently equivalent, that is stable: future stores won't change it.     X must be composed of constants, register and memory references    combined with addition, subtraction and multiplication:    in other words, just what you can get from expand_expr if sum_ok is 1.     Works by making copies of all regs and memory locations used    by X and combining them the same way X does.    You could also stabilize the reference to this address    by copying the address to a register with copy_to_reg;    but then you wouldn't get indexed addressing in the reference.  */
end_comment

begin_function
name|rtx
name|copy_all_regs
parameter_list|(
name|x
parameter_list|)
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
block|{
if|if
condition|(
name|REGNO
argument_list|(
name|x
argument_list|)
operator|!=
name|FRAME_POINTER_REGNUM
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MEM
condition|)
name|x
operator|=
name|copy_to_reg
argument_list|(
name|x
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
condition|)
block|{
specifier|register
name|rtx
name|op0
init|=
name|copy_all_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
argument_list|)
decl_stmt|;
specifier|register
name|rtx
name|op1
init|=
name|copy_all_regs
argument_list|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
argument_list|)
decl_stmt|;
if|if
condition|(
name|op0
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|||
name|op1
operator|!=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
condition|)
name|x
operator|=
name|gen_rtx
argument_list|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|Pmode
argument_list|,
name|op0
argument_list|,
name|op1
argument_list|)
expr_stmt|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return something equivalent to X but valid as a memory address    for something of mode MODE.  When X is not itself valid, this    works by copying X or subexpressions of it into registers.  */
end_comment

begin_function
name|rtx
name|memory_address
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
specifier|register
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|oldx
decl_stmt|;
comment|/* By passing constant addresses thru registers      we get a chance to cse them.  */
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
comment|/* Accept a QUEUED that refers to a REG      even though that isn't a valid address.      On attempting to put this in an insn we will call protect_from_queue      which will turn it into a REG, which is valid.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|QUEUED
operator|&&
name|GET_CODE
argument_list|(
name|QUEUED_VAR
argument_list|(
name|x
argument_list|)
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
comment|/* We get better cse by rejecting indirect addressing at this stage.      Let the combiner create indirect addresses where appropriate.      For now, generate the code so that the subexpressions useful to share      are visible.  But not if cse won't be done!  */
name|oldx
operator|=
name|x
expr_stmt|;
if|if
condition|(
operator|!
name|cse_not_expected
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
condition|)
name|x
operator|=
name|break_out_memory_refs
argument_list|(
name|x
argument_list|)
expr_stmt|;
comment|/* At this point, any valid address is accepted.  */
name|GO_IF_LEGITIMATE_ADDRESS
argument_list|(
name|mode
argument_list|,
name|x
argument_list|,
name|win
argument_list|)
expr_stmt|;
comment|/* If it was valid before but breaking out memory refs invalidated it,      use it the old way.  */
if|if
condition|(
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|oldx
argument_list|)
condition|)
goto|goto
name|win2
goto|;
comment|/* Perform machine-dependent transformations on X      in certain cases.  This is not necessary since the code      below can handle all possible cases, but machine-dependent      transformations can make better code.  */
name|LEGITIMIZE_ADDRESS
argument_list|(
name|x
argument_list|,
name|oldx
argument_list|,
name|mode
argument_list|,
name|win
argument_list|)
expr_stmt|;
comment|/* PLUS and MULT can appear in special ways      as the result of attempts to make an address usable for indexing.      Usually they are dealt with by calling force_operand, below.      But a sum containing constant terms is special      if removing them makes the sum a valid address:      then we generate that address in a register      and index off of it.  We do this because it often makes      shorter code, and because the addresses thus generated      in registers often become common subexpressions.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
condition|)
block|{
name|int
name|constant_term
init|=
literal|0
decl_stmt|;
name|rtx
name|y
init|=
name|eliminate_constant_term
argument_list|(
name|x
argument_list|,
operator|&
name|constant_term
argument_list|)
decl_stmt|;
if|if
condition|(
name|constant_term
operator|==
literal|0
operator|||
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
condition|)
return|return
name|force_operand
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
name|y
operator|=
name|plus_constant
argument_list|(
name|copy_to_reg
argument_list|(
name|y
argument_list|)
argument_list|,
name|constant_term
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|memory_address_p
argument_list|(
name|mode
argument_list|,
name|y
argument_list|)
condition|)
return|return
name|force_operand
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
return|return
name|y
return|;
block|}
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MULT
operator|||
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|MINUS
condition|)
return|return
name|force_operand
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
comment|/* If we have a register that's an invalid address,      it must be a hard reg of the wrong class.  Copy it to a pseudo.  */
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|copy_to_reg
argument_list|(
name|x
argument_list|)
return|;
comment|/* Last resort: copy the value to a register, since      the register is a valid address.  */
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
name|win2
label|:
name|x
operator|=
name|oldx
expr_stmt|;
name|win
label|:
if|if
condition|(
name|flag_force_addr
operator|&&
name|optimize
operator|&&
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|REG
comment|/* Don't copy an addr via a reg if it is one of our stack slots. 	 If we did, it would cause invalid REG_EQUIV notes for parms.  */
operator|&&
operator|!
operator|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|PLUS
operator|&&
operator|(
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|frame_pointer_rtx
operator|||
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
operator|==
name|arg_pointer_rtx
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|general_operand
argument_list|(
name|x
argument_list|,
name|Pmode
argument_list|)
condition|)
return|return
name|force_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
else|else
return|return
name|force_operand
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_comment
comment|/* Like `memory_address' but pretend `flag_force_addr' is 0.  */
end_comment

begin_function
name|rtx
name|memory_address_noforce
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
name|int
name|ambient_force_addr
init|=
name|flag_force_addr
decl_stmt|;
name|rtx
name|val
decl_stmt|;
name|flag_force_addr
operator|=
literal|0
expr_stmt|;
name|val
operator|=
name|memory_address
argument_list|(
name|mode
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|flag_force_addr
operator|=
name|ambient_force_addr
expr_stmt|;
return|return
name|val
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Return a modified copy of X with its memory address copied    into a temporary register to protect it from side effects.    If X is not a MEM, it is returned unchanged (and not copied).    Perhaps even if it is a MEM, if there is no need to change it.  */
end_comment

begin_function
name|rtx
name|stabilize
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|addr
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|x
return|;
name|addr
operator|=
name|XEXP
argument_list|(
name|x
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtx_unstable_p
argument_list|(
name|addr
argument_list|)
condition|)
block|{
name|rtx
name|temp
init|=
name|copy_all_regs
argument_list|(
name|addr
argument_list|)
decl_stmt|;
name|rtx
name|mem
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|temp
argument_list|)
operator|!=
name|REG
condition|)
name|temp
operator|=
name|copy_to_reg
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|mem
operator|=
name|gen_rtx
argument_list|(
name|MEM
argument_list|,
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|,
name|temp
argument_list|)
expr_stmt|;
comment|/* Mark returned memref with in_struct 	 if it's in an array or structure. */
if|if
condition|(
name|GET_CODE
argument_list|(
name|addr
argument_list|)
operator|==
name|PLUS
operator|||
name|MEM_IN_STRUCT_P
argument_list|(
name|x
argument_list|)
condition|)
name|MEM_IN_STRUCT_P
argument_list|(
name|mem
argument_list|)
operator|=
literal|1
expr_stmt|;
return|return
name|mem
return|;
block|}
return|return
name|x
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Copy the value or contents of X to a new temp reg and return that reg.  */
end_comment

begin_function
name|rtx
name|copy_to_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
decl_stmt|;
comment|/* If not an operand, must be an address with PLUS and MULT so      do the computation.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Like copy_to_reg but always give the new register mode Pmode    in case X is a constant.  */
end_comment

begin_function
name|rtx
name|copy_addr_to_reg
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
return|return
name|copy_to_mode_reg
argument_list|(
name|Pmode
argument_list|,
name|x
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Like copy_to_reg but always give the new register mode MODE    in case X is a constant.  */
end_comment

begin_function
name|rtx
name|copy_to_mode_reg
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
init|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
decl_stmt|;
comment|/* If not an operand, must be an address with PLUS and MULT so      do the computation.  */
if|if
condition|(
operator|!
name|general_operand
argument_list|(
name|x
argument_list|,
name|VOIDmode
argument_list|)
condition|)
name|x
operator|=
name|force_operand
argument_list|(
name|x
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|mode
operator|&&
name|GET_MODE
argument_list|(
name|x
argument_list|)
operator|!=
name|VOIDmode
condition|)
name|abort
argument_list|()
expr_stmt|;
if|if
condition|(
name|x
operator|!=
name|temp
condition|)
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Load X into a register if it is not already one.    Use mode MODE for the register.    X should be valid for mode MODE, but it may be a constant which    is valid for all integer modes; that's why caller must specify MODE.     The caller must not alter the value in the register we return,    since we mark it as a "constant" register.  */
end_comment

begin_function
name|rtx
name|force_reg
parameter_list|(
name|mode
parameter_list|,
name|x
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|,
name|insn
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|==
name|REG
condition|)
return|return
name|x
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|mode
argument_list|)
expr_stmt|;
name|insn
operator|=
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
comment|/* Let optimizers know that TEMP's value never changes      and that X can be substituted for it.  */
if|if
condition|(
name|CONSTANT_P
argument_list|(
name|x
argument_list|)
condition|)
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
operator|=
name|gen_rtx
argument_list|(
name|EXPR_LIST
argument_list|,
name|REG_EQUIV
argument_list|,
name|x
argument_list|,
name|REG_NOTES
argument_list|(
name|insn
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* If X is a memory ref, copy its contents to a new temp reg and return    that reg.  Otherwise, return X.  */
end_comment

begin_function
name|rtx
name|force_not_mem
parameter_list|(
name|x
parameter_list|)
name|rtx
name|x
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|x
argument_list|)
operator|!=
name|MEM
condition|)
return|return
name|x
return|;
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_comment
comment|/* Copy X to TARGET (if it's nonzero and a reg)    or to a new temp reg and return that reg.  */
end_comment

begin_function
name|rtx
name|copy_to_suggested_reg
parameter_list|(
name|x
parameter_list|,
name|target
parameter_list|)
name|rtx
name|x
decl_stmt|,
name|target
decl_stmt|;
block|{
specifier|register
name|rtx
name|temp
decl_stmt|;
if|if
condition|(
name|target
operator|&&
name|GET_CODE
argument_list|(
name|target
argument_list|)
operator|==
name|REG
condition|)
name|temp
operator|=
name|target
expr_stmt|;
else|else
name|temp
operator|=
name|gen_reg_rtx
argument_list|(
name|GET_MODE
argument_list|(
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|emit_move_insn
argument_list|(
name|temp
argument_list|,
name|x
argument_list|)
expr_stmt|;
return|return
name|temp
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Adjust the stack pointer by ADJUST (an rtx for a number of bytes).    This pops when ADJUST is positive.  ADJUST need not be constant.  */
end_comment

begin_function
name|void
name|adjust_stack
parameter_list|(
name|adjust
parameter_list|)
name|rtx
name|adjust
decl_stmt|;
block|{
name|adjust
operator|=
name|protect_from_queue
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_sub2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Adjust the stack pointer by minus ADJUST (an rtx for a number of bytes).    This pushes when ADJUST is positive.  ADJUST need not be constant.  */
end_comment

begin_function
name|void
name|anti_adjust_stack
parameter_list|(
name|adjust
parameter_list|)
name|rtx
name|adjust
decl_stmt|;
block|{
name|adjust
operator|=
name|protect_from_queue
argument_list|(
name|adjust
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|STACK_GROWS_DOWNWARD
name|emit_insn
argument_list|(
name|gen_sub2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|emit_insn
argument_list|(
name|gen_add2_insn
argument_list|(
name|stack_pointer_rtx
argument_list|,
name|adjust
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* Round the size of a block to be pushed up to the boundary required    by this machine.  SIZE is the desired size, which need not be constant.  */
end_comment

begin_function
name|rtx
name|round_push
parameter_list|(
name|size
parameter_list|)
name|rtx
name|size
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|STACK_BOUNDARY
name|int
name|align
init|=
name|STACK_BOUNDARY
operator|/
name|BITS_PER_UNIT
decl_stmt|;
if|if
condition|(
name|align
operator|==
literal|1
condition|)
return|return
name|size
return|;
if|if
condition|(
name|GET_CODE
argument_list|(
name|size
argument_list|)
operator|==
name|CONST_INT
condition|)
block|{
name|int
name|new
init|=
operator|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|+
name|align
operator|-
literal|1
operator|)
operator|/
name|align
operator|*
name|align
decl_stmt|;
if|if
condition|(
name|INTVAL
argument_list|(
name|size
argument_list|)
operator|!=
name|new
condition|)
name|size
operator|=
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|new
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|expand_divmod
argument_list|(
literal|0
argument_list|,
name|CEIL_DIV_EXPR
argument_list|,
name|Pmode
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|size
operator|=
name|expand_mult
argument_list|(
name|Pmode
argument_list|,
name|size
argument_list|,
name|gen_rtx
argument_list|(
name|CONST_INT
argument_list|,
name|VOIDmode
argument_list|,
name|align
argument_list|)
argument_list|,
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* STACK_BOUNDARY */
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing the register or memory location    in which a scalar value of data type VALTYPE    was returned by a function call to function FUNC.    FUNC is a FUNCTION_DECL node if the precise function is known,    otherwise 0.  */
end_comment

begin_function
name|rtx
name|hard_function_value
parameter_list|(
name|valtype
parameter_list|,
name|func
parameter_list|)
name|tree
name|valtype
decl_stmt|;
name|tree
name|func
decl_stmt|;
block|{
return|return
name|FUNCTION_VALUE
argument_list|(
name|valtype
argument_list|,
name|func
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Return an rtx representing the register or memory location    in which a scalar value of mode MODE was returned by a library call.  */
end_comment

begin_function
name|rtx
name|hard_libcall_value
parameter_list|(
name|mode
parameter_list|)
name|enum
name|machine_mode
name|mode
decl_stmt|;
block|{
return|return
name|LIBCALL_VALUE
argument_list|(
name|mode
argument_list|)
return|;
block|}
end_function

end_unit

