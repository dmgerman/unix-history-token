begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vi.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/* This array describes what each key does */
end_comment

begin_define
define|#
directive|define
name|NO_FUNC
value|(MARK (*)())0
end_define

begin_define
define|#
directive|define
name|NO_ARGS
value|0
end_define

begin_define
define|#
directive|define
name|CURSOR_COUNT
value|1
end_define

begin_define
define|#
directive|define
name|CURSOR
value|2
end_define

begin_define
define|#
directive|define
name|CURSOR_CNT_KEY
value|3
end_define

begin_define
define|#
directive|define
name|CURSOR_MOVED
value|4
end_define

begin_define
define|#
directive|define
name|CURSOR_EOL
value|5
end_define

begin_define
define|#
directive|define
name|ZERO
value|6
end_define

begin_define
define|#
directive|define
name|DIGIT
value|7
end_define

begin_define
define|#
directive|define
name|CURSOR_TEXT
value|8
end_define

begin_define
define|#
directive|define
name|CURSOR_CNT_CMD
value|9
end_define

begin_define
define|#
directive|define
name|KEYWORD
value|10
end_define

begin_define
define|#
directive|define
name|NO_FLAGS
value|0x00
end_define

begin_define
define|#
directive|define
name|MVMT
value|0x01
end_define

begin_comment
comment|/* this is a movement command */
end_comment

begin_define
define|#
directive|define
name|PTMV
value|0x02
end_define

begin_comment
comment|/* this can be *part* of a movement command */
end_comment

begin_define
define|#
directive|define
name|FRNT
value|0x04
end_define

begin_comment
comment|/* after move, go to front of line */
end_comment

begin_define
define|#
directive|define
name|INCL
value|0x08
end_define

begin_comment
comment|/* include last char when used with c/d/y */
end_comment

begin_define
define|#
directive|define
name|LNMD
value|0x10
end_define

begin_comment
comment|/* use line mode of c/d/y */
end_comment

begin_define
define|#
directive|define
name|NCOL
value|0x20
end_define

begin_comment
comment|/* this command can't change the column# */
end_comment

begin_define
define|#
directive|define
name|NREL
value|0x40
end_define

begin_comment
comment|/* this is "non-relative" -- set the '' mark */
end_comment

begin_define
define|#
directive|define
name|SDOT
value|0x80
end_define

begin_comment
comment|/* set the "dot" variables, for the "." cmd */
end_comment

begin_struct
specifier|static
struct|struct
name|keystru
block|{
name|MARK
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* the function to run */
name|uchar
name|args
decl_stmt|;
comment|/* description of the args needed */
name|uchar
name|flags
decl_stmt|;
comment|/* other stuff */
block|}
name|vikeys
index|[]
init|=
block|{
comment|/* NUL not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^A  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^B  page backward	*/
block|{
name|m_scroll
block|,
name|CURSOR_CNT_CMD
block|,
name|FRNT
block|}
block|,
comment|/* ^C  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^D  scroll dn 1/2page*/
block|{
name|m_scroll
block|,
name|CURSOR_CNT_CMD
block|,
name|NCOL
block|}
block|,
comment|/* ^E  scroll up	*/
block|{
name|m_scroll
block|,
name|CURSOR_CNT_CMD
block|,
name|NCOL
block|}
block|,
comment|/* ^F  page forward	*/
block|{
name|m_scroll
block|,
name|CURSOR_CNT_CMD
block|,
name|FRNT
block|}
block|,
comment|/* ^G  show file status	*/
block|{
name|v_status
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^H  move left, like h*/
block|{
name|m_left
block|,
name|CURSOR_COUNT
block|,
name|MVMT
block|}
block|,
comment|/* ^I  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^J  move down	*/
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|LNMD
block|}
block|,
comment|/* ^K  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^L  redraw screen	*/
block|{
name|v_redraw
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^M  mv front next ln */
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|FRNT
operator||
name|LNMD
block|}
block|,
comment|/* ^N  move down	*/
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|LNMD
block|}
block|,
comment|/* ^O  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^P  move up		*/
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|LNMD
block|}
block|,
comment|/* ^Q  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^R  redraw screen	*/
block|{
name|v_redraw
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^S  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^T  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^U  scroll up 1/2page*/
block|{
name|m_scroll
block|,
name|CURSOR_CNT_CMD
block|,
name|NCOL
block|}
block|,
comment|/* ^V  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^W  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^X  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^Y  scroll down	*/
block|{
name|m_scroll
block|,
name|CURSOR_CNT_CMD
block|,
name|NCOL
block|}
block|,
comment|/* ^Z  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ESC not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^\  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^]  keyword is tag	*/
block|{
name|v_tag
block|,
name|KEYWORD
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^^  previous file	*/
block|{
name|v_switch
block|,
name|CURSOR
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^_  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* SPC move right,like l*/
block|{
name|m_right
block|,
name|CURSOR_COUNT
block|,
name|MVMT
block|}
block|,
comment|/*  !  run thru filter	*/
block|{
name|v_filter
block|,
name|CURSOR_MOVED
block|,
name|FRNT
operator||
name|LNMD
operator||
name|INCL
block|}
block|,
comment|/*  "  select cut buffer*/
block|{
name|v_selcut
block|,
name|CURSOR_CNT_KEY
block|,
name|PTMV
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/*  #  increment number	*/
block|{
name|v_increment
block|,
name|KEYWORD
block|,
name|SDOT
block|}
block|,
else|#
directive|else
comment|/*  #  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  $  move to rear	*/
block|{
name|m_rear
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
comment|/*  %  move to match	*/
block|{
name|m_match
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
comment|/*&  repeat subst	*/
block|{
name|v_again
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|NCOL
operator||
name|LNMD
operator||
name|INCL
block|}
block|,
comment|/*  '  move to a mark	*/
block|{
name|m_tomark
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|FRNT
operator||
name|NREL
operator||
name|LNMD
operator||
name|INCL
block|}
block|,
ifndef|#
directive|ifndef
name|NO_SENTENCE
comment|/*  (  mv back sentence	*/
block|{
name|m_bsentence
block|,
name|CURSOR_COUNT
block|,
name|MVMT
block|}
block|,
comment|/*  )  mv fwd sentence	*/
block|{
name|m_fsentence
block|,
name|CURSOR_COUNT
block|,
name|MVMT
block|}
block|,
else|#
directive|else
comment|/*  (  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  )  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
comment|/*  *  errlist		*/
block|{
name|v_errlist
block|,
name|CURSOR
block|,
name|FRNT
operator||
name|NREL
block|}
block|,
else|#
directive|else
comment|/*  *  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  +  mv front next ln */
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|FRNT
operator||
name|LNMD
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  ,  reverse [fFtT] cmd*/
block|{
name|m__ch
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
else|#
directive|else
comment|/*  ,  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  -  mv front prev ln	*/
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|FRNT
operator||
name|LNMD
block|}
block|,
comment|/*  .  special...	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  /  forward search	*/
block|{
name|m_fsrch
block|,
name|CURSOR_TEXT
block|,
name|MVMT
operator||
name|NREL
block|}
block|,
comment|/*  0  part of count?	*/
block|{
name|NO_FUNC
block|,
name|ZERO
block|,
name|MVMT
operator||
name|PTMV
block|}
block|,
comment|/*  1  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  2  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  3  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  4  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  5  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  6  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  7  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  8  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  9  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
block|}
block|,
comment|/*  :  run single EX cmd*/
block|{
name|v_1ex
block|,
name|CURSOR_TEXT
block|,
name|NO_FLAGS
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  ;  repeat [fFtT] cmd*/
block|{
name|m__ch
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
else|#
directive|else
comment|/*  ;  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*<  shift text left	*/
block|{
name|v_lshift
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|INCL
block|}
block|,
comment|/*  =  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*>  shift text right	*/
block|{
name|v_rshift
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|INCL
block|}
block|,
comment|/*  ?  backward search	*/
block|{
name|m_bsrch
block|,
name|CURSOR_TEXT
block|,
name|MVMT
operator||
name|NREL
block|}
block|,
ifndef|#
directive|ifndef
name|NO_AT
comment|/*  @  execute a cutbuf */
block|{
name|v_at
block|,
name|CURSOR_CNT_KEY
block|,
name|NO_FLAGS
block|}
block|,
else|#
directive|else
comment|/*  @  undefined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  A  append at EOL	*/
block|{
name|v_insert
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  B  move back Word	*/
block|{
name|m_bword
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
block|}
block|,
comment|/*  C  change to EOL	*/
block|{
name|v_change
block|,
name|CURSOR_EOL
block|,
name|SDOT
block|}
block|,
comment|/*  D  delete to EOL	*/
block|{
name|v_delete
block|,
name|CURSOR_EOL
block|,
name|SDOT
block|}
block|,
comment|/*  E  move end of Word	*/
block|{
name|m_eword
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  F  move bk to char	*/
block|{
name|m_Fch
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
else|#
directive|else
comment|/*  F  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  G  move to line #	*/
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|NREL
operator||
name|LNMD
operator||
name|FRNT
operator||
name|INCL
block|}
block|,
comment|/*  H  move to row	*/
block|{
name|m_row
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|FRNT
block|}
block|,
comment|/*  I  insert at front	*/
block|{
name|v_insert
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  J  join lines	*/
block|{
name|v_join
block|,
name|CURSOR_COUNT
block|,
name|SDOT
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/*  K  look up keyword	*/
block|{
name|v_keyword
block|,
name|KEYWORD
block|,
name|NO_FLAGS
block|}
block|,
else|#
directive|else
comment|/*  K  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  L  move to last row	*/
block|{
name|m_row
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|FRNT
block|}
block|,
comment|/*  M  move to mid row	*/
block|{
name|m_row
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|FRNT
block|}
block|,
comment|/*  N  reverse prev srch*/
block|{
name|m_Nsrch
block|,
name|CURSOR
block|,
name|MVMT
block|}
block|,
comment|/*  O  insert above line*/
block|{
name|v_insert
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  P  paste before	*/
block|{
name|v_paste
block|,
name|CURSOR_CNT_CMD
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  Q  quit to EX mode	*/
block|{
name|v_quit
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  R  overtype		*/
block|{
name|v_overtype
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  S  change line	*/
block|{
name|v_change
block|,
name|CURSOR_MOVED
block|,
name|SDOT
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  T  move bk to char	*/
block|{
name|m_Tch
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
else|#
directive|else
comment|/*  T  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  U  undo whole line	*/
block|{
name|v_undoline
block|,
name|CURSOR
block|,
name|FRNT
block|}
block|,
comment|/*  V  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  W  move forward Word*/
block|{
name|m_fword
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
block|}
block|,
comment|/*  X  delete to left	*/
block|{
name|v_xchar
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  Y  yank text	*/
block|{
name|v_yank
block|,
name|CURSOR_MOVED
block|,
name|NCOL
block|}
block|,
comment|/*  Z  save file& exit	*/
block|{
name|v_xit
block|,
name|CURSOR_CNT_KEY
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  [  move back section*/
block|{
name|m_bsection
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|LNMD
operator||
name|NREL
block|}
block|,
comment|/*  \  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  ]  move fwd section */
block|{
name|m_fsection
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|LNMD
operator||
name|NREL
block|}
block|,
comment|/*  ^  move to front	*/
block|{
name|m_front
block|,
name|CURSOR
block|,
name|MVMT
block|}
block|,
comment|/*  _  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  `  move to mark	*/
block|{
name|m_tomark
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|NREL
block|}
block|,
comment|/*  a  append at cursor	*/
block|{
name|v_insert
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  b  move back word	*/
block|{
name|m_bword
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
block|}
block|,
comment|/*  c  change text	*/
block|{
name|v_change
block|,
name|CURSOR_MOVED
block|,
name|SDOT
block|}
block|,
comment|/*  d  delete op	*/
block|{
name|v_delete
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|NCOL
block|}
block|,
comment|/*  e  move end word	*/
block|{
name|m_eword
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  f  move fwd for char*/
block|{
name|m_fch
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
else|#
directive|else
comment|/*  f  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  g  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  h  move left	*/
block|{
name|m_left
block|,
name|CURSOR_COUNT
block|,
name|MVMT
block|}
block|,
comment|/*  i  insert at cursor	*/
block|{
name|v_insert
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  j  move down	*/
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|NCOL
operator||
name|LNMD
block|}
block|,
comment|/*  k  move up		*/
block|{
name|m_updnto
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
operator||
name|NCOL
operator||
name|LNMD
block|}
block|,
comment|/*  l  move right	*/
block|{
name|m_right
block|,
name|CURSOR_COUNT
block|,
name|MVMT
block|}
block|,
comment|/*  m  define a mark	*/
block|{
name|v_mark
block|,
name|CURSOR_CNT_KEY
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  n  repeat prev srch	*/
block|{
name|m_nsrch
block|,
name|CURSOR
block|,
name|MVMT
block|}
block|,
comment|/*  o  insert below line*/
block|{
name|v_insert
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  p  paste after	*/
block|{
name|v_paste
block|,
name|CURSOR_CNT_CMD
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  q  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  r  replace chars	*/
block|{
name|v_replace
block|,
name|CURSOR_CNT_KEY
block|,
name|SDOT
block|}
block|,
comment|/*  s  subst N chars	*/
block|{
name|v_subst
block|,
name|CURSOR_COUNT
block|,
name|SDOT
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  t  move fwd to char	*/
block|{
name|m_tch
block|,
name|CURSOR_CNT_KEY
block|,
name|MVMT
operator||
name|INCL
block|}
block|,
else|#
directive|else
comment|/*  t  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  u  undo		*/
block|{
name|v_undo
block|,
name|CURSOR
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  v  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  w  move fwd word	*/
block|{
name|m_fword
block|,
name|CURSOR_CNT_CMD
block|,
name|MVMT
block|}
block|,
comment|/*  x  delete character	*/
block|{
name|v_xchar
block|,
name|CURSOR_CNT_CMD
block|,
name|SDOT
block|}
block|,
comment|/*  y  yank text	*/
block|{
name|v_yank
block|,
name|CURSOR_MOVED
block|,
name|NCOL
block|}
block|,
comment|/*  z  adjust scrn row	*/
block|{
name|m_z
block|,
name|CURSOR_CNT_KEY
block|,
name|NCOL
block|}
block|,
comment|/*  {  back paragraph	*/
block|{
name|m_bparagraph
block|,
name|CURSOR_COUNT
block|,
name|MVMT
operator||
name|LNMD
block|}
block|,
comment|/*  |  move to column	*/
block|{
name|m_tocol
block|,
name|CURSOR_COUNT
block|,
name|NREL
block|}
block|,
comment|/*  }  fwd paragraph	*/
block|{
name|m_fparagraph
block|,
name|CURSOR_COUNT
block|,
name|MVMT
operator||
name|LNMD
block|}
block|,
comment|/*  ~  upper/lowercase	*/
block|{
name|v_ulcase
block|,
name|CURSOR_COUNT
block|,
name|SDOT
block|}
block|,
comment|/* DEL not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|vi
parameter_list|()
block|{
name|REG
name|int
name|key
decl_stmt|;
comment|/* keystroke from user */
name|long
name|count
decl_stmt|;
comment|/* numeric argument to some functions */
name|REG
name|struct
name|keystru
modifier|*
name|keyptr
decl_stmt|;
comment|/* pointer to vikeys[] element */
name|MARK
name|tcurs
decl_stmt|;
comment|/* temporary cursor */
name|int
name|prevkey
decl_stmt|;
comment|/* previous key, if d/c/y/</>/! */
name|MARK
name|range
decl_stmt|;
comment|/* start of range for d/c/y/</>/! */
name|char
name|text
index|[
literal|100
index|]
decl_stmt|;
name|int
name|dotkey
decl_stmt|;
comment|/* last "key" of a change */
name|int
name|dotpkey
decl_stmt|;
comment|/* last "prevkey" of a change */
name|int
name|dotkey2
decl_stmt|;
comment|/* last extra "getkey()" of a change */
name|int
name|dotcnt
decl_stmt|;
comment|/* last "count" of a change */
name|int
name|firstkey
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
comment|/* tell the redraw() function to start from scratch */
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
comment|/* lint says that "range" might be used before it is set.  This 	 * can't really happen due to the way "range" and "prevkey" are used, 	 * but lint doesn't know that.  This line is here ONLY to keep lint 	 * happy. 	 */
name|range
operator|=
literal|0L
expr_stmt|;
endif|#
directive|endif
comment|/* safeguard against '.' with no previous command */
name|dotkey
operator|=
literal|0
expr_stmt|;
comment|/* go immediately into insert mode, if ":set inputmode" */
name|firstkey
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
operator|*
name|o_inputmode
condition|)
block|{
name|firstkey
operator|=
literal|'i'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Repeatedly handle VI commands */
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|prevkey
operator|=
literal|'\0'
init|;
name|mode
operator|==
name|MODE_VI
condition|;
control|)
block|{
comment|/* if we've moved off the undoable line, then we can't undo it at all */
if|if
condition|(
name|markline
argument_list|(
name|cursor
argument_list|)
operator|!=
name|U_line
condition|)
block|{
name|U_line
operator|=
literal|0L
expr_stmt|;
block|}
comment|/* report any changes from the previous command */
if|if
condition|(
name|rptlines
operator|>=
operator|*
name|o_report
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"%ld lines %s"
argument_list|,
name|rptlines
argument_list|,
name|rptlabel
argument_list|)
expr_stmt|;
block|}
name|rptlines
operator|=
literal|0L
expr_stmt|;
comment|/* get the next command key.  It must be ASCII */
if|if
condition|(
name|firstkey
condition|)
block|{
name|key
operator|=
name|firstkey
expr_stmt|;
name|firstkey
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|key
operator|=
name|getkey
argument_list|(
name|WHEN_VICMD
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|key
operator|<
literal|0
operator|||
name|key
operator|>
literal|127
condition|)
do|;
block|}
comment|/* change cw and cW commands to ce and cE, respectively */
comment|/* (Why?  because the real vi does it that way!) */
if|if
condition|(
name|prevkey
operator|==
literal|'c'
condition|)
block|{
if|if
condition|(
name|key
operator|==
literal|'w'
condition|)
name|key
operator|=
literal|'e'
expr_stmt|;
elseif|else
if|if
condition|(
name|key
operator|==
literal|'W'
condition|)
name|key
operator|=
literal|'E'
expr_stmt|;
comment|/* wouldn't work right at the end of a word unless we 			 * backspace one character before doing the move.  This 			 * will fix most cases.  !!! but not all. 			 */
if|if
condition|(
name|markidx
argument_list|(
name|cursor
argument_list|)
operator|>
literal|0
operator|&&
operator|(
name|key
operator|==
literal|'e'
operator|||
name|key
operator|==
literal|'E'
operator|)
condition|)
block|{
name|cursor
operator|--
expr_stmt|;
block|}
block|}
comment|/* look up the structure describing this command */
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
comment|/* if we're in the middle of a d/c/y/</>/! command, reject 		 * anything but movement or a doubled version like "dd". 		 */
if|if
condition|(
name|prevkey
operator|&&
name|key
operator|!=
name|prevkey
operator|&&
operator|!
operator|(
name|keyptr
operator|->
name|flags
operator|&
operator|(
name|MVMT
operator||
name|PTMV
operator|)
operator|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|prevkey
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* set the "dot" variables, if we're supposed to */
if|if
condition|(
operator|(
name|keyptr
operator|->
name|flags
operator|&
name|SDOT
operator|)
operator|||
operator|(
name|prevkey
operator|&&
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
operator|&
name|SDOT
operator|)
condition|)
block|{
name|dotkey
operator|=
name|key
expr_stmt|;
name|dotpkey
operator|=
name|prevkey
expr_stmt|;
name|dotkey2
operator|=
literal|'\0'
expr_stmt|;
name|dotcnt
operator|=
name|count
expr_stmt|;
comment|/* remember the line before any changes are made */
if|if
condition|(
name|U_line
operator|!=
name|markline
argument_list|(
name|cursor
argument_list|)
condition|)
block|{
name|U_line
operator|=
name|markline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|U_text
argument_list|,
name|fetchline
argument_list|(
name|U_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if this is "." then set other vars from the "dot" vars */
if|if
condition|(
name|key
operator|==
literal|'.'
condition|)
block|{
name|key
operator|=
name|dotkey
expr_stmt|;
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
name|prevkey
operator|=
name|dotpkey
expr_stmt|;
if|if
condition|(
name|prevkey
condition|)
block|{
name|range
operator|=
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|count
operator|=
name|dotcnt
expr_stmt|;
block|}
name|doingdot
operator|=
name|TRUE
expr_stmt|;
comment|/* remember the line before any changes are made */
if|if
condition|(
name|U_line
operator|!=
name|markline
argument_list|(
name|cursor
argument_list|)
condition|)
block|{
name|U_line
operator|=
name|markline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|U_text
argument_list|,
name|fetchline
argument_list|(
name|U_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|doingdot
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* process the key as a command */
name|tcurs
operator|=
name|cursor
expr_stmt|;
switch|switch
condition|(
name|keyptr
operator|->
name|args
condition|)
block|{
case|case
name|ZERO
case|:
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|tcurs
operator|=
name|cursor
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through& treat like other digits... */
case|case
name|DIGIT
case|:
name|count
operator|=
name|count
operator|*
literal|10
operator|+
name|key
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
name|KEYWORD
case|:
comment|/* if not on a keyword, fail */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|markidx
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
name|isascii
argument_list|(
name|ptext
index|[
name|key
index|]
argument_list|)
operator|&&
operator|!
name|isalnum
argument_list|(
name|ptext
index|[
name|key
index|]
argument_list|)
operator|&&
name|ptext
index|[
name|key
index|]
operator|!=
literal|'_'
condition|)
block|{
name|tcurs
operator|=
name|MARK_UNSET
expr_stmt|;
break|break;
block|}
comment|/* find the start of the keyword */
while|while
condition|(
name|key
operator|>
literal|0
operator|&&
operator|(
operator|!
name|isascii
argument_list|(
name|ptext
index|[
name|key
operator|-
literal|1
index|]
argument_list|)
operator|||
name|isalnum
argument_list|(
name|ptext
index|[
name|key
operator|-
literal|1
index|]
argument_list|)
operator|||
name|ptext
index|[
name|key
operator|-
literal|1
index|]
operator|==
literal|'_'
operator|)
condition|)
block|{
name|key
operator|--
expr_stmt|;
block|}
name|tcurs
operator|=
operator|(
name|cursor
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|key
expr_stmt|;
comment|/* copy it into a buffer, and NUL-terminate it */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|text
index|[
name|i
operator|++
index|]
operator|=
name|ptext
index|[
name|key
operator|++
index|]
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|isascii
argument_list|(
name|ptext
index|[
name|key
index|]
argument_list|)
operator|||
name|isalnum
argument_list|(
name|ptext
index|[
name|key
index|]
argument_list|)
operator|||
name|ptext
index|[
name|key
index|]
operator|==
literal|'_'
condition|)
do|;
name|text
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* call the function */
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|text
argument_list|,
name|tcurs
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|NO_ARGS
case|:
if|if
condition|(
name|keyptr
operator|->
name|func
condition|)
block|{
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR_COUNT
case|:
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR
case|:
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR_CNT_KEY
case|:
if|if
condition|(
name|doingdot
condition|)
block|{
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|count
argument_list|,
name|dotkey2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get a key */
name|i
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'\033'
condition|)
comment|/* ESC */
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|tcurs
operator|=
name|MARK_UNSET
expr_stmt|;
break|break;
comment|/* exit from "case CURSOR_CNT_KEY" */
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|(
literal|'V'
operator|&
literal|0x1f
operator|)
condition|)
block|{
name|i
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* if part of an SDOT command, remember it */
if|if
condition|(
name|keyptr
operator|->
name|flags
operator|&
name|SDOT
operator|||
operator|(
name|prevkey
operator|&&
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
operator|&
name|SDOT
operator|)
condition|)
block|{
name|dotkey2
operator|=
name|i
expr_stmt|;
block|}
comment|/* do it */
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|count
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR_MOVED
case|:
comment|/* '&' and uppercase keys always act like doubled */
if|if
condition|(
name|key
operator|==
literal|'&'
operator|||
name|isascii
argument_list|(
name|key
argument_list|)
operator|&&
name|isupper
argument_list|(
name|key
argument_list|)
condition|)
block|{
name|prevkey
operator|=
name|key
expr_stmt|;
block|}
if|if
condition|(
name|prevkey
condition|)
block|{
comment|/* doubling up a command */
if|if
condition|(
operator|!
name|count
condition|)
name|count
operator|=
literal|1L
expr_stmt|;
name|range
operator|=
name|cursor
expr_stmt|;
name|tcurs
operator|=
name|range
operator|+
name|MARK_AT_LINE
argument_list|(
name|count
operator|-
literal|1L
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|prevkey
operator|=
name|key
expr_stmt|;
name|range
operator|=
name|cursor
expr_stmt|;
name|key
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* so we don't think we doubled yet */
block|}
break|break;
case|case
name|CURSOR_EOL
case|:
name|prevkey
operator|=
name|key
expr_stmt|;
comment|/* a zero-length line needs special treatment */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
comment|/* act on a zero-length section of text */
name|range
operator|=
name|tcurs
operator|=
name|cursor
expr_stmt|;
name|key
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
comment|/* act like CURSOR_MOVED with '$' movement */
name|range
operator|=
name|cursor
expr_stmt|;
name|tcurs
operator|=
name|m_rear
argument_list|(
name|cursor
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|key
operator|=
literal|'$'
expr_stmt|;
block|}
name|count
operator|=
literal|0L
expr_stmt|;
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
break|break;
case|case
name|CURSOR_TEXT
case|:
do|do
block|{
name|text
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
if|if
condition|(
name|vgets
argument_list|(
name|key
argument_list|,
name|text
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|text
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* reassure user that<CR> was hit */
name|qaddch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* call the function with the text */
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exwrote
operator|||
name|mode
operator|==
name|MODE_COLON
condition|)
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|MODE_VI
expr_stmt|;
block|}
block|}
do|while
condition|(
name|mode
operator|==
name|MODE_COLON
condition|)
do|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR_CNT_CMD
case|:
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|count
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
block|}
comment|/* if that command took us out of vi mode, then exit the loop 		 * NOW, without tweaking the cursor or anything.  This is very 		 * important when mode == MODE_QUIT. 		 */
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
condition|)
block|{
break|break;
block|}
comment|/* now move the cursor, as appropriate */
if|if
condition|(
name|keyptr
operator|->
name|args
operator|==
name|CURSOR_MOVED
condition|)
block|{
comment|/* the< and> keys have FRNT, 			 * but it shouldn't be applied yet 			 */
name|tcurs
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|tcurs
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcurs
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|tcurs
argument_list|,
operator|(
name|int
operator|)
name|keyptr
operator|->
name|flags
argument_list|)
expr_stmt|;
block|}
comment|/* was that the end of a d/c/y/</>/! command? */
if|if
condition|(
name|prevkey
operator|&&
operator|(
name|prevkey
operator|==
name|key
operator|||
operator|(
name|keyptr
operator|->
name|flags
operator|&
name|MVMT
operator|)
operator|)
operator|&&
name|count
operator|==
literal|0L
condition|)
block|{
comment|/* if the movement command failed, cancel operation */
if|if
condition|(
name|tcurs
operator|==
name|MARK_UNSET
condition|)
block|{
name|prevkey
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* make sure range=front and tcurs=rear.  Either way, 			 * leave cursor=range since that's where we started. 			 */
name|cursor
operator|=
name|range
expr_stmt|;
if|if
condition|(
name|tcurs
operator|<
name|range
condition|)
block|{
name|range
operator|=
name|tcurs
expr_stmt|;
name|tcurs
operator|=
name|cursor
expr_stmt|;
block|}
comment|/* adjust for line mode& inclusion of last char/line */
name|i
operator|=
operator|(
name|keyptr
operator|->
name|flags
operator||
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
operator|)
expr_stmt|;
if|if
condition|(
name|key
operator|==
name|prevkey
condition|)
block|{
name|i
operator||=
operator|(
name|INCL
operator||
name|LNMD
operator|)
expr_stmt|;
block|}
switch|switch
condition|(
name|i
operator|&
operator|(
name|INCL
operator||
name|LNMD
operator|)
condition|)
block|{
case|case
name|INCL
case|:
name|tcurs
operator|++
expr_stmt|;
break|break;
case|case
name|INCL
operator||
name|LNMD
case|:
name|tcurs
operator|+=
name|BLKSIZE
expr_stmt|;
comment|/* fall through... */
case|case
name|LNMD
case|:
name|range
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tcurs
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
comment|/* run the function */
name|tcurs
operator|=
operator|(
operator|*
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|func
operator|)
operator|(
name|range
operator|,
name|tcurs
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|tcurs
argument_list|,
operator|(
name|int
operator|)
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
argument_list|)
expr_stmt|;
comment|/* cleanup */
name|prevkey
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prevkey
condition|)
block|{
name|cursor
operator|=
name|tcurs
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function adjusts the MARK value that they return; here we make sure  * it isn't past the end of the line, and that the column hasn't been  * *accidentally* changed.  */
end_comment

begin_function
name|MARK
name|adjmove
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|flags
parameter_list|)
name|MARK
name|old
decl_stmt|;
comment|/* the cursor position before the command */
name|REG
name|MARK
name|new
decl_stmt|;
comment|/* the cursor position after the command */
name|int
name|flags
decl_stmt|;
comment|/* various flags regarding cursor mvmt */
block|{
specifier|static
name|int
name|colno
decl_stmt|;
comment|/* the column number that we want */
name|REG
name|char
modifier|*
name|text
decl_stmt|;
comment|/* used to scan through the line's text */
name|REG
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|watch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* if the command failed, bag it! */
if|if
condition|(
name|new
operator|==
name|MARK_UNSET
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return
name|old
return|;
block|}
comment|/* if this is a non-relative movement, set the '' mark */
if|if
condition|(
name|flags
operator|&
name|NREL
condition|)
block|{
name|mark
index|[
literal|26
index|]
operator|=
name|old
expr_stmt|;
block|}
comment|/* make sure it isn't past the end of the file */
if|if
condition|(
name|markline
argument_list|(
name|new
argument_list|)
operator|<
literal|1
condition|)
block|{
name|new
operator|=
name|MARK_FIRST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markline
argument_list|(
name|new
argument_list|)
operator|>
name|nlines
condition|)
block|{
name|new
operator|=
name|MARK_LAST
expr_stmt|;
block|}
comment|/* fetch the new line */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move to the front, if we're supposed to */
if|if
condition|(
name|flags
operator|&
name|FRNT
condition|)
block|{
name|new
operator|=
name|m_front
argument_list|(
name|new
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
block|}
comment|/* change the column#, or change the mark to suit the column# */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|NCOL
operator|)
condition|)
block|{
comment|/* change the column# */
name|i
operator|=
name|markidx
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|BLKSIZE
operator|-
literal|1
condition|)
block|{
name|new
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|new
operator|+=
name|plen
operator|-
literal|1
expr_stmt|;
block|}
name|colno
operator|=
name|BLKSIZE
operator|*
literal|8
expr_stmt|;
comment|/* one heck of a big colno */
block|}
elseif|else
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|plen
condition|)
block|{
name|new
operator|=
operator|(
name|new
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
operator|-
literal|1
expr_stmt|;
block|}
name|colno
operator|=
name|idx2col
argument_list|(
name|new
argument_list|,
name|ptext
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|colno
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* adjust the mark to get as close as possible to column# */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|text
operator|=
name|ptext
init|;
name|i
operator|<=
name|colno
operator|&&
operator|*
name|text
condition|;
name|text
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|text
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|i
operator|+=
operator|*
name|o_tabstop
operator|-
operator|(
name|i
operator|%
operator|*
name|o_tabstop
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UCHAR
argument_list|(
operator|*
name|text
argument_list|)
operator|<
literal|' '
operator|||
operator|*
name|text
operator|==
literal|127
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_CHARATTR
elseif|else
if|if
condition|(
operator|*
name|o_charattr
operator|&&
name|text
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|text
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|text
index|[
literal|2
index|]
condition|)
block|{
name|text
operator|+=
literal|2
expr_stmt|;
comment|/* plus one more in "for()" stmt */
block|}
endif|#
directive|endif
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|text
operator|>
name|ptext
condition|)
block|{
name|text
operator|--
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|new
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
call|(
name|int
call|)
argument_list|(
name|text
operator|-
name|ptext
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|watch
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|wasset
expr_stmt|;
if|if
condition|(
operator|*
name|origname
condition|)
block|{
name|wasset
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wasset
condition|)
block|{
name|msg
argument_list|(
literal|"origname was clobbered"
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|nlines
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"nlines=0"
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

