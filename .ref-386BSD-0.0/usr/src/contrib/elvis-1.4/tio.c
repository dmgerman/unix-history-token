begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tio.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains terminal I/O functions */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_if
if|#
directive|if
name|BSD
operator|||
name|COHERENT
end_if

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/* This function reads in a line from the terminal. */
end_comment

begin_function
name|int
name|vgets
parameter_list|(
name|prompt
parameter_list|,
name|buf
parameter_list|,
name|bsize
parameter_list|)
name|char
name|prompt
decl_stmt|;
comment|/* the prompt character, or '\0' for none */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* buffer into which the string is read */
name|int
name|bsize
decl_stmt|;
comment|/* size of the buffer */
block|{
name|int
name|len
decl_stmt|;
comment|/* how much we've read so far */
name|int
name|ch
decl_stmt|;
comment|/* a character from the user */
name|int
name|quoted
decl_stmt|;
comment|/* is the next char quoted? */
name|int
name|tab
decl_stmt|;
comment|/* column position of cursor */
name|char
name|widths
index|[
literal|132
index|]
decl_stmt|;
comment|/* widths of characters */
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|int
name|erased
decl_stmt|;
comment|/* 0, or first char of a digraph */
endif|#
directive|endif
comment|/* show the prompt */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
block|{
name|addch
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|tab
operator|=
literal|1
expr_stmt|;
block|}
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* read in the line */
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|erased
operator|=
endif|#
directive|endif
name|quoted
operator|=
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|getkey
argument_list|(
name|quoted
condition|?
literal|0
else|:
name|WHEN_EX
argument_list|)
expr_stmt|;
comment|/* some special conversions */
if|if
condition|(
name|ch
operator|==
name|ctrl
argument_list|(
literal|'D'
argument_list|)
operator|&&
name|len
operator|==
literal|0
condition|)
name|ch
operator|=
name|ctrl
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DIGRAPH
if|if
condition|(
operator|*
name|o_digraph
operator|&&
name|erased
operator|!=
literal|0
operator|&&
name|ch
operator|!=
literal|'\b'
condition|)
block|{
name|ch
operator|=
name|digraph
argument_list|(
name|erased
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|erased
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* inhibit detection of special chars (except ^J) after a ^V */
if|if
condition|(
name|quoted
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
name|ch
operator||=
literal|256
expr_stmt|;
block|}
comment|/* process the character */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|ctrl
argument_list|(
literal|'V'
argument_list|)
case|:
name|qaddch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|quoted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ctrl
argument_list|(
literal|'['
argument_list|)
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'\n'
case|:
if|#
directive|if
name|OSK
case|case
literal|'\l'
case|:
else|#
directive|else
case|case
literal|'\r'
case|:
endif|#
directive|endif
name|clrtoeol
argument_list|()
expr_stmt|;
goto|goto
name|BreakBreak
goto|;
case|case
literal|'\b'
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|--
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|erased
operator|=
name|buf
index|[
name|len
index|]
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ch
operator|=
name|widths
index|[
name|len
index|]
init|;
name|ch
operator|>
literal|0
condition|;
name|ch
operator|--
control|)
name|addch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_EX
condition|)
block|{
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
name|tab
operator|-=
name|widths
index|[
name|len
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
comment|/* strip off quotation bit */
if|if
condition|(
name|ch
operator|&
literal|256
condition|)
block|{
name|ch
operator|&=
operator|~
literal|256
expr_stmt|;
name|quoted
operator|=
name|FALSE
expr_stmt|;
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
comment|/* add& echo the char */
if|if
condition|(
name|len
operator|<
name|bsize
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\t'
condition|)
block|{
name|widths
index|[
name|len
index|]
operator|=
operator|*
name|o_tabstop
operator|-
operator|(
name|tab
operator|%
operator|*
name|o_tabstop
operator|)
expr_stmt|;
name|addstr
argument_list|(
literal|"        "
operator|+
literal|8
operator|-
name|widths
index|[
name|len
index|]
argument_list|)
expr_stmt|;
name|tab
operator|+=
name|widths
index|[
name|len
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>
literal|0
operator|&&
name|ch
operator|<
literal|' '
condition|)
comment|/*> 0 by GB */
block|{
name|addch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ch
operator|+
literal|'@'
argument_list|)
expr_stmt|;
name|widths
index|[
name|len
index|]
operator|=
literal|2
expr_stmt|;
name|tab
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\177'
condition|)
block|{
name|addch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|widths
index|[
name|len
index|]
operator|=
literal|2
expr_stmt|;
name|tab
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|widths
index|[
name|len
index|]
operator|=
literal|1
expr_stmt|;
name|tab
operator|++
expr_stmt|;
block|}
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
block|}
block|}
name|BreakBreak
label|:
name|refresh
argument_list|()
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/* ring the terminal's bell */
end_comment

begin_function
name|void
name|beep
parameter_list|()
block|{
if|if
condition|(
operator|*
name|o_vbell
condition|)
block|{
name|do_VB
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|o_errorbells
condition|)
block|{
name|ttywrite
argument_list|(
literal|"\007"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|manymsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable keeps msgs from overwriting each other */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pmsg
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous message (waiting to be displayed) */
end_comment

begin_function
specifier|static
name|int
name|showmsg
parameter_list|()
block|{
comment|/* if there is no message to show, then don't */
if|if
condition|(
operator|!
name|manymsgs
condition|)
return|return
name|FALSE
return|;
comment|/* display the message */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pmsg
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|pmsg
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
block|}
name|clrtoeol
argument_list|()
expr_stmt|;
name|manymsgs
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|endmsgs
parameter_list|()
block|{
if|if
condition|(
name|manymsgs
condition|)
block|{
name|showmsg
argument_list|()
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write a message in an appropriate way.  This should really be a varargs  * function, but there is no such thing as vwprintw.  Hack!!!  *  * In MODE_EX or MODE_COLON, the message is written immediately, with a  * newline at the end.  *  * In MODE_VI, the message is stored in a character buffer.  It is not  * displayed until getkey() is called.  msg() will call getkey() itself,  * if necessary, to prevent messages from being lost.  *  * msg("")		- clears the message line  * msg("%s %d", ...)	- does a printf onto the message line  */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|msg
parameter_list|(
name|fmt
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|,
name|arg6
parameter_list|,
name|arg7
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|long
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|,
name|arg5
decl_stmt|,
name|arg6
decl_stmt|,
name|arg7
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
condition|)
block|{
name|sprintf
argument_list|(
name|pmsg
argument_list|,
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|pmsg
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* wait for keypress between consecutive msgs */
if|if
condition|(
name|manymsgs
condition|)
block|{
name|getkey
argument_list|(
name|WHEN_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* real message */
name|sprintf
argument_list|(
name|pmsg
argument_list|,
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|)
expr_stmt|;
name|manymsgs
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function calls refresh() if the option exrefresh is set */
end_comment

begin_function
name|void
name|exrefresh
parameter_list|()
block|{
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* If this ex command wrote ANYTHING set exwrote so vi's  :  command 	 * can tell that it must wait for a user keystroke before redrawing. 	 */
for|for
control|(
name|scan
operator|=
name|kbuf
init|;
name|scan
operator|<
name|stdscr
condition|;
name|scan
operator|++
control|)
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\n'
condition|)
name|exwrote
operator|=
name|TRUE
expr_stmt|;
if|#
directive|if
name|MICROSOFT
comment|/* avoid compiler bug */
name|scan
operator|=
name|stdscr
expr_stmt|;
define|#
directive|define
name|stdscr
value|scan
endif|#
directive|endif
comment|/* now we do the refresh thing */
if|if
condition|(
operator|*
name|o_exrefresh
condition|)
block|{
name|refresh
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|wqrefresh
argument_list|(
name|stdscr
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MICROSOFT
undef|#
directive|undef
name|stdscr
name|stdscr
operator|=
name|scan
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
condition|)
block|{
name|manymsgs
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* These are used for typeahead, and also for fudging the visual @ command */
end_comment

begin_decl_stmt
specifier|static
name|char
name|keybuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* array of already-read keys */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nkeys
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of keys in keybuf */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of next key to return */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AT
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|atnext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of next key for "@", or 0 normally */
end_comment

begin_function
name|int
name|fromcutbuf
parameter_list|(
name|cbname
parameter_list|)
name|int
name|cbname
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
comment|/* fail if we're already doing an @ macro */
if|if
condition|(
name|atnext
operator|>
literal|0
operator|&&
name|keybuf
index|[
name|atnext
index|]
condition|)
block|{
name|msg
argument_list|(
literal|"Can't nest @ commands"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* use the empty portion of keybuf[] to get chars from the cut buffer */
name|len
operator|=
name|cb2str
argument_list|(
name|cbname
argument_list|,
name|keybuf
operator|+
name|nkeys
argument_list|,
sizeof|sizeof
name|keybuf
operator|-
name|nkeys
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Invalid cut buffer name.  Must be a-z"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Cut buffer \"%c is empty"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
if|if
condition|(
name|len
operator|>=
sizeof|sizeof
name|keybuf
operator|-
name|nkeys
condition|)
block|{
name|msg
argument_list|(
literal|"Cut buffer \"%c is too large to execute"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* prepare to "read" those keys on subsequent getkey() calls */
name|atnext
operator|=
name|nkeys
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This array describes mapped key sequences */
end_comment

begin_struct
specifier|static
struct|struct
name|_keymap
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the key, or NULL */
name|char
name|rawin
index|[
name|LONGKEY
index|]
decl_stmt|;
comment|/* the unmapped version of input */
name|char
name|cooked
index|[
literal|80
index|]
decl_stmt|;
comment|/* the mapped version of input */
name|int
name|len
decl_stmt|;
comment|/* length of the unmapped version */
name|int
name|when
decl_stmt|;
comment|/* when is this key mapped? */
block|}
name|mapped
index|[
name|MAXMAPS
index|]
struct|;
end_struct

begin_if
if|#
directive|if
operator|!
name|MSDOS
operator|&&
operator|!
name|TOS
end_if

begin_if
if|#
directive|if
name|BSD
operator|||
name|COHERENT
end_if

begin_decl_stmt
specifier|static
name|jmp_buf
name|env_timeout
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|dummy
parameter_list|()
block|{
name|longjmp
argument_list|(
name|env_timeout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_function
specifier|static
name|int
name|dummy
parameter_list|()
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function reads in a keystroke for VI mode.  It automatically handles  * key mapping.  */
end_comment

begin_function
name|int
name|getkey
parameter_list|(
name|when
parameter_list|)
name|int
name|when
decl_stmt|;
comment|/* which bits must be ON? */
block|{
specifier|static
name|char
modifier|*
name|cooked
decl_stmt|;
comment|/* rawin, or pointer to converted key */
specifier|static
name|int
name|oldwhen
decl_stmt|;
comment|/* "when" from last time */
specifier|static
name|int
name|oldleft
decl_stmt|;
specifier|static
name|long
name|oldtop
decl_stmt|;
specifier|static
name|long
name|oldnlines
decl_stmt|;
specifier|static
name|char
modifier|*
name|cshape
decl_stmt|;
comment|/* current cursor shape */
name|REG
name|char
modifier|*
name|kptr
decl_stmt|;
comment|/*&keybuf[next] */
name|REG
name|struct
name|_keymap
modifier|*
name|km
decl_stmt|;
comment|/* used to count through keymap */
name|REG
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|watch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* if this key is needed for delay between multiple error messages, 	 * then reset the manymsgs flag and abort any mapped key sequence. 	 */
if|if
condition|(
name|showmsg
argument_list|()
condition|)
block|{
if|if
condition|(
name|when
operator|==
name|WHEN_MSG
condition|)
block|{
name|qaddstr
argument_list|(
literal|"[More...]"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|cooked
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|when
operator|==
name|WHEN_VIINP
operator|||
name|when
operator|==
name|WHEN_VIREP
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_AT
comment|/* if we're in the middle of a visual @ macro, take atnext */
if|if
condition|(
name|atnext
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|keybuf
index|[
name|atnext
index|]
condition|)
block|{
return|return
name|keybuf
index|[
name|atnext
operator|++
index|]
return|;
block|}
name|atnext
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if we're doing a mapped key, get the next char */
if|if
condition|(
name|cooked
operator|&&
operator|*
name|cooked
condition|)
block|{
return|return
operator|*
name|cooked
operator|++
return|;
block|}
comment|/* if keybuf is empty, fill it */
if|if
condition|(
name|next
operator|==
name|nkeys
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
comment|/* make sure the cursor is the right shape */
if|if
condition|(
name|has_CQ
condition|)
block|{
name|cooked
operator|=
name|cshape
expr_stmt|;
switch|switch
condition|(
name|when
condition|)
block|{
case|case
name|WHEN_EX
case|:
name|cooked
operator|=
name|CX
expr_stmt|;
break|break;
case|case
name|WHEN_VICMD
case|:
name|cooked
operator|=
name|CV
expr_stmt|;
break|break;
case|case
name|WHEN_VIINP
case|:
name|cooked
operator|=
name|CI
expr_stmt|;
break|break;
case|case
name|WHEN_VIREP
case|:
name|cooked
operator|=
name|CR
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|cooked
operator|!=
name|cshape
condition|)
block|{
name|cshape
operator|=
name|cooked
expr_stmt|;
switch|switch
condition|(
name|when
condition|)
block|{
case|case
name|WHEN_EX
case|:
name|do_CX
argument_list|()
expr_stmt|;
break|break;
case|case
name|WHEN_VICMD
case|:
name|do_CV
argument_list|()
expr_stmt|;
break|break;
case|case
name|WHEN_VIINP
case|:
name|do_CI
argument_list|()
expr_stmt|;
break|break;
case|case
name|WHEN_VIREP
case|:
name|do_CR
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
name|cooked
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SHOWMODE
comment|/* if "showmode" then say which mode we're in */
if|if
condition|(
operator|*
name|o_smd
operator|&&
name|mode
operator|==
name|MODE_VI
operator|&&
operator|(
name|when
operator|!=
name|oldwhen
operator|||
name|topline
operator|!=
name|oldtop
operator|||
name|leftcol
operator|!=
name|oldleft
operator|||
name|nlines
operator|!=
name|oldnlines
operator|)
condition|)
block|{
name|oldwhen
operator|=
name|when
expr_stmt|;
name|oldtop
operator|=
name|topline
expr_stmt|;
name|oldleft
operator|=
name|leftcol
expr_stmt|;
name|oldnlines
operator|=
name|nlines
expr_stmt|;
if|if
condition|(
name|when
operator|&
name|WHEN_VICMD
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|10
argument_list|)
expr_stmt|;
name|standout
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Command"
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
name|redraw
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_VIINP
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|10
argument_list|)
expr_stmt|;
name|standout
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|" Input "
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_VIREP
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|10
argument_list|)
expr_stmt|;
name|standout
argument_list|()
expr_stmt|;
name|addstr
argument_list|(
literal|"Replace"
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
endif|#
directive|endif
comment|/* redraw if getting a VI command */
if|if
condition|(
name|when
operator|&
name|WHEN_VICMD
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* read the rawin keystrokes */
name|refresh
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|nkeys
operator|=
name|ttyread
argument_list|(
name|keybuf
argument_list|,
sizeof|sizeof
name|keybuf
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* terminal was probably resized */
operator|*
name|o_lines
operator|=
name|LINES
expr_stmt|;
operator|*
name|o_columns
operator|=
name|COLS
expr_stmt|;
if|if
condition|(
name|when
operator|&
operator|(
name|WHEN_VICMD
operator||
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
condition|)
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|redraw
argument_list|(
name|cursor
argument_list|,
operator|(
name|when
operator|&
name|WHEN_VICMD
operator|)
operator|==
literal|0
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
block|}
name|next
operator|=
literal|0
expr_stmt|;
comment|/* if nkeys == 0 then we've reached EOF of an ex script. */
if|if
condition|(
name|nkeys
operator|==
literal|0
condition|)
block|{
name|tmpabort
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* see how many mapped keys this might be */
name|kptr
operator|=
operator|&
name|keybuf
index|[
name|next
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
operator|,
name|k
operator|=
operator|-
literal|1
operator|,
name|km
operator|=
name|mapped
init|;
name|i
operator|<
name|MAXMAPS
condition|;
name|i
operator|++
operator|,
name|km
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|km
operator|->
name|when
operator|&
name|when
operator|)
operator|&&
name|km
operator|->
name|len
operator|>
literal|0
operator|&&
operator|*
name|km
operator|->
name|rawin
operator|==
operator|*
name|kptr
condition|)
block|{
if|if
condition|(
name|km
operator|->
name|len
operator|>
name|nkeys
operator|-
name|next
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|km
operator|->
name|rawin
argument_list|,
name|kptr
argument_list|,
name|nkeys
operator|-
name|next
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|km
operator|->
name|rawin
argument_list|,
name|kptr
argument_list|,
name|km
operator|->
name|len
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* if more than one, try to read some more */
while|while
condition|(
name|j
operator|>
literal|1
condition|)
block|{
if|#
directive|if
name|BSD
operator|||
name|COHERENT
if|if
condition|(
name|setjmp
argument_list|(
name|env_timeout
argument_list|)
condition|)
block|{
comment|/* we timed out - assume no mapping */
name|j
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
if|#
directive|if
name|ANY_UNIX
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|OSK
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|alarm
argument_list|(
operator|(
name|unsigned
operator|)
operator|*
name|o_keytime
argument_list|)
expr_stmt|;
name|i
operator|=
name|nkeys
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|=
name|ttyread
argument_list|(
name|keybuf
operator|+
name|nkeys
argument_list|,
sizeof|sizeof
name|keybuf
operator|-
name|nkeys
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
name|nkeys
operator|+=
name|k
expr_stmt|;
block|}
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
ifndef|#
directive|ifndef
name|DEBUG
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* if we couldn't read any more, pretend 0 mapped keys */
if|if
condition|(
name|i
operator|==
name|nkeys
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* else we got some more - try again */
block|{
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
operator|,
name|k
operator|=
operator|-
literal|1
operator|,
name|km
operator|=
name|mapped
init|;
name|i
operator|<
name|MAXMAPS
condition|;
name|i
operator|++
operator|,
name|km
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|km
operator|->
name|when
operator|&
name|when
operator|)
operator|&&
name|km
operator|->
name|len
operator|>
literal|0
operator|&&
operator|*
name|km
operator|->
name|rawin
operator|==
operator|*
name|kptr
condition|)
block|{
if|if
condition|(
name|km
operator|->
name|len
operator|>
name|nkeys
operator|-
name|next
condition|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|km
operator|->
name|rawin
argument_list|,
name|kptr
argument_list|,
name|nkeys
operator|-
name|next
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|km
operator|->
name|rawin
argument_list|,
name|kptr
argument_list|,
name|km
operator|->
name|len
argument_list|)
condition|)
block|{
name|j
operator|++
expr_stmt|;
name|k
operator|=
name|i
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
block|}
comment|/* if unambiguously mapped key, use it! */
if|if
condition|(
name|j
operator|==
literal|1
operator|&&
name|k
operator|>=
literal|0
condition|)
block|{
name|next
operator|+=
name|mapped
index|[
name|k
index|]
operator|.
name|len
expr_stmt|;
name|cooked
operator|=
name|mapped
index|[
name|k
index|]
operator|.
name|cooked
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
operator|(
name|when
operator|&
operator|(
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
operator|&&
operator|(
name|mapped
index|[
name|k
index|]
operator|.
name|when
operator|&
name|WHEN_INMV
operator|)
condition|)
block|{
return|return
literal|0
return|;
comment|/* special case, means "a movement char follows" */
block|}
else|else
endif|#
directive|endif
block|{
return|return
operator|*
name|cooked
operator|++
return|;
block|}
block|}
elseif|else
comment|/* assume key is unmapped, but still translate weird erase key to '\b' */
if|if
condition|(
name|keybuf
index|[
name|next
index|]
operator|==
name|ERASEKEY
operator|&&
name|when
operator|!=
literal|0
condition|)
block|{
name|next
operator|++
expr_stmt|;
return|return
literal|'\b'
return|;
block|}
elseif|else
if|if
condition|(
name|keybuf
index|[
name|next
index|]
operator|==
literal|'\0'
condition|)
block|{
name|next
operator|++
expr_stmt|;
return|return
operator|(
literal|'A'
operator|&
literal|0x1f
operator|)
return|;
block|}
else|else
block|{
return|return
name|keybuf
index|[
name|next
operator|++
index|]
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function maps or unmaps a key */
end_comment

begin_function
name|void
name|mapkey
parameter_list|(
name|rawin
parameter_list|,
name|cooked
parameter_list|,
name|when
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|rawin
decl_stmt|;
comment|/* the input key sequence, before mapping */
name|char
modifier|*
name|cooked
decl_stmt|;
comment|/* after mapping */
name|short
name|when
decl_stmt|;
comment|/* bitmap of when mapping should happen */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the key, if any */
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/* if the mapped version starts with the word "visual" then set WHEN_INMV */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|cooked
argument_list|,
literal|"visual "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|when
operator||=
name|WHEN_INMV
expr_stmt|;
name|cooked
operator|+=
literal|7
expr_stmt|;
block|}
comment|/* if WHEN_INMV is set, then WHEN_VIINP and WHEN_VIREP must be set */
if|if
condition|(
name|when
operator|&
name|WHEN_INMV
condition|)
block|{
name|when
operator||=
operator|(
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* see if the key sequence was mapped before */
name|j
operator|=
name|strlen
argument_list|(
name|rawin
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAPS
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|mapped
index|[
name|i
index|]
operator|.
name|len
operator|==
name|j
operator|&&
operator|!
name|strncmp
argument_list|(
name|mapped
index|[
name|i
index|]
operator|.
name|rawin
argument_list|,
name|rawin
argument_list|,
name|j
argument_list|)
operator|&&
operator|(
name|mapped
index|[
name|i
index|]
operator|.
name|when
operator|&
name|when
operator|)
condition|)
block|{
break|break;
block|}
block|}
comment|/* if not already mapped, then try to find a new slot to use */
if|if
condition|(
name|i
operator|==
name|MAXMAPS
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAPS
operator|&&
name|mapped
index|[
name|i
index|]
operator|.
name|len
operator|>
literal|0
condition|;
name|i
operator|++
control|)
block|{ 		}
block|}
comment|/* no room for the new key? */
if|if
condition|(
name|i
operator|==
name|MAXMAPS
condition|)
block|{
name|msg
argument_list|(
literal|"No room left in the key map table"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* map the key */
if|if
condition|(
name|cooked
operator|&&
operator|*
name|cooked
condition|)
block|{
comment|/* Map the key */
name|mapped
index|[
name|i
index|]
operator|.
name|len
operator|=
name|j
expr_stmt|;
name|strncpy
argument_list|(
name|mapped
index|[
name|i
index|]
operator|.
name|rawin
argument_list|,
name|rawin
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mapped
index|[
name|i
index|]
operator|.
name|cooked
argument_list|,
name|cooked
argument_list|)
expr_stmt|;
name|mapped
index|[
name|i
index|]
operator|.
name|when
operator|=
name|when
expr_stmt|;
name|mapped
index|[
name|i
index|]
operator|.
name|name
operator|=
name|name
expr_stmt|;
block|}
else|else
comment|/* unmap the key */
block|{
name|mapped
index|[
name|i
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Dump keys of a given type - WHEN_VICMD dumps the ":map" keys, and  * WHEN_VIINP|WHEN_VIREP dumps the ":map!" keys  */
end_comment

begin_function
name|void
name|dumpkey
parameter_list|(
name|when
parameter_list|)
name|int
name|when
decl_stmt|;
comment|/* WHEN_XXXX of mappings to be dumped */
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|mlen
decl_stmt|;
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|mraw
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAPS
condition|;
name|i
operator|++
control|)
block|{
comment|/* skip unused entries, or entries that don't match "when" */
if|if
condition|(
name|mapped
index|[
name|i
index|]
operator|.
name|len
operator|<=
literal|0
operator|||
operator|!
operator|(
name|mapped
index|[
name|i
index|]
operator|.
name|when
operator|&
name|when
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* dump the key label, if any */
name|len
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|mapped
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
name|qaddstr
argument_list|(
name|mapped
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|len
operator|-=
name|strlen
argument_list|(
name|mapped
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
do|;
comment|/* dump the raw version */
name|len
operator|=
literal|0
expr_stmt|;
name|mlen
operator|=
name|mapped
index|[
name|i
index|]
operator|.
name|len
expr_stmt|;
name|mraw
operator|=
name|mapped
index|[
name|i
index|]
operator|.
name|rawin
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|mraw
init|;
name|scan
operator|<
name|mraw
operator|+
name|mlen
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|UCHAR
argument_list|(
operator|*
name|scan
argument_list|)
operator|<
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\177'
condition|)
block|{
name|qaddch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
operator|*
name|scan
operator|^
literal|'@'
argument_list|)
expr_stmt|;
name|len
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|qaddch
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
name|len
operator|++
expr_stmt|;
block|}
block|}
do|do
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|len
operator|<
literal|8
condition|)
do|;
comment|/* dump the mapped version */
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
operator|(
name|mapped
index|[
name|i
index|]
operator|.
name|when
operator|&
name|WHEN_INMV
operator|)
operator|&&
operator|(
name|when
operator|&
operator|(
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
condition|)
block|{
name|qaddstr
argument_list|(
literal|"visual "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
name|scan
operator|=
name|mapped
index|[
name|i
index|]
operator|.
name|cooked
init|;
operator|*
name|scan
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
name|UCHAR
argument_list|(
operator|*
name|scan
argument_list|)
operator|<
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\177'
condition|)
block|{
name|qaddch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
operator|*
name|scan
operator|^
literal|'@'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|qaddch
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MKEXRC
end_ifndef

begin_comment
comment|/* This function saves the current configuration of mapped keys to a file */
end_comment

begin_function
name|void
name|savekeys
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* file descriptor to save them to */
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
comment|/* now write a map command for each key other than the arrows */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAXMAPS
condition|;
name|i
operator|++
control|)
block|{
comment|/* ignore keys that came from termcap */
if|if
condition|(
name|mapped
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
continue|continue;
block|}
comment|/* If this isn't used, ignore it */
if|if
condition|(
name|mapped
index|[
name|i
index|]
operator|.
name|len
operator|<=
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* write the map command */
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|mapped
index|[
name|i
index|]
operator|.
name|when
operator|&
name|WHEN_INMV
condition|)
block|{
if|#
directive|if
name|OSK
name|char
name|fmt
index|[
literal|80
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|fmt
argument_list|,
literal|"map%%s %%.%ds %%s\n"
argument_list|,
name|mapped
index|[
name|i
index|]
operator|.
name|len
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
argument|buf
argument_list|,
argument|fmt
argument_list|,
argument|(mapped[i].when& WHEN_VICMD) ?
literal|""
argument|:
literal|"!"
argument_list|,
else|#
directive|else
argument|sprintf(buf,
literal|"map%s %.*s visual %s\n"
argument|, 				(mapped[i].when& WHEN_VICMD) ?
literal|""
argument|:
literal|"!"
argument|, 				mapped[i].len,
endif|#
directive|endif
argument|mapped[i].rawin, 				mapped[i].cooked); 			twrite(fd, buf, strlen(buf)); 		} 		else
endif|#
directive|endif
argument|{ 			if (mapped[i].when& WHEN_VICMD) 			{
if|#
directive|if
name|OSK
argument|char	fmt[
literal|80
argument|]; 				sprintf(fmt,
literal|"map %%.%ds %%s\n"
argument|, mapped[i].len); 				sprintf(buf, fmt,
else|#
directive|else
argument|sprintf(buf,
literal|"map %.*s %s\n"
argument|, mapped[i].len,
endif|#
directive|endif
argument|mapped[i].rawin, 					mapped[i].cooked); 				twrite(fd, buf, strlen(buf)); 			} 			if (mapped[i].when& (WHEN_VIINP | WHEN_VIREP)) 			{
if|#
directive|if
name|OSK
argument|char	fmt[
literal|80
argument|]; 				sprintf(fmt,
literal|"map! %%.%ds %%s\n"
argument|, mapped[i].len); 				sprintf(buf, fmt,
else|#
directive|else
argument|sprintf(buf,
literal|"map! %.*s %s\n"
argument|, mapped[i].len,
endif|#
directive|endif
argument|mapped[i].rawin, 					mapped[i].cooked); 				twrite(fd, buf, strlen(buf)); 			} 		} 	} }
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

