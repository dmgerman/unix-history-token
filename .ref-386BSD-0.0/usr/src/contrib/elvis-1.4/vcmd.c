begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vcmd.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the functions that handle VI commands */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_include
include|#
directive|include
file|<osbind.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|OSK
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function puts the editor in EX mode */
end_comment

begin_function
name|MARK
name|v_quit
parameter_list|()
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE_EX
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function causes the screen to be redrawn */
end_comment

begin_function
name|MARK
name|v_redraw
parameter_list|()
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function executes a single EX command, and waits for a user keystroke  * before returning to the VI screen.  If that keystroke is another ':', then  * another EX command is read and executed.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_1ex
parameter_list|(
name|m
parameter_list|,
name|text
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* the current line */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* the first command to execute */
block|{
comment|/* run the command.  be careful about modes& output */
name|exwrote
operator|=
operator|(
name|mode
operator|==
name|MODE_COLON
operator|)
expr_stmt|;
name|doexcmd
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
comment|/* if mode is no longer MODE_VI, then we should quit right away! */
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
operator|&&
name|mode
operator|!=
name|MODE_COLON
condition|)
return|return
name|cursor
return|;
comment|/* The command did some output.  Wait for a keystoke. */
if|if
condition|(
name|exwrote
condition|)
block|{
name|mode
operator|=
name|MODE_VI
expr_stmt|;
name|msg
argument_list|(
literal|"[Hit<RETURN> to continue]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getkey
argument_list|(
literal|0
argument_list|)
operator|==
literal|':'
condition|)
block|{
name|mode
operator|=
name|MODE_COLON
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function undoes the last change */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_undo
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* (ignored) */
block|{
if|if
condition|(
name|undo
argument_list|()
condition|)
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function deletes the character(s) that the cursor is on */
end_comment

begin_function
name|MARK
name|v_xchar
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|cmd
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to start deletions */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to delete */
name|int
name|cmd
decl_stmt|;
comment|/* either 'x' or 'X' */
block|{
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* for 'X', adjust so chars are deleted *BEFORE* cursor */
if|if
condition|(
name|cmd
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
name|markidx
argument_list|(
name|m
argument_list|)
operator|<
name|cnt
condition|)
return|return
name|MARK_UNSET
return|;
name|m
operator|-=
name|cnt
expr_stmt|;
block|}
comment|/* make sure we don't try to delete more thars than there are */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|m
operator|+
name|cnt
argument_list|)
operator|>
name|plen
condition|)
block|{
name|cnt
operator|=
name|plen
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|0L
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* do it */
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function defines a mark */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_mark
parameter_list|(
name|m
parameter_list|,
name|count
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where the mark will be */
name|long
name|count
decl_stmt|;
comment|/* (ignored) */
name|int
name|key
decl_stmt|;
comment|/* the ASCII label of the mark */
block|{
if|if
condition|(
name|key
operator|<
literal|'a'
operator|||
name|key
operator|>
literal|'z'
condition|)
block|{
name|msg
argument_list|(
literal|"Marks must be from a to z"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mark
index|[
name|key
operator|-
literal|'a'
index|]
operator|=
name|m
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function toggles upper& lower case letters */
end_comment

begin_function
name|MARK
name|v_ulcase
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to make the change */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to flip */
block|{
name|REG
name|char
modifier|*
name|pos
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|static
name|char
name|flip
index|[]
init|=
literal|"aAbBcCdDeEfFgGhHiIjJkKlLmMnNoOpPqQrRsStTuUvVwWxXyYzZ[](){}<>"
decl_stmt|;
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* fetch the current version of the line */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for each position in the line */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|i
operator|=
name|markidx
argument_list|(
name|m
argument_list|)
init|;
name|j
operator|<
name|cnt
operator|&&
name|ptext
index|[
name|i
index|]
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
literal|0
expr_stmt|;
comment|/* one of the standard chars? */
for|for
control|(
name|pos
operator|=
name|flip
init|;
operator|*
name|pos
operator|&&
operator|*
name|pos
operator|!=
name|ptext
index|[
name|i
index|]
condition|;
name|pos
operator|++
control|)
block|{ 		}
if|if
condition|(
operator|*
name|pos
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
name|flip
index|[
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|flip
argument_list|)
operator|^
literal|1
index|]
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_DIGRAPH
else|else
comment|/* one of the non-standard chars? */
block|{
for|for
control|(
name|pos
operator|=
name|o_flipcase
init|;
operator|*
name|pos
operator|&&
operator|*
name|pos
operator|!=
name|ptext
index|[
name|i
index|]
condition|;
name|pos
operator|++
control|)
block|{ 			}
if|if
condition|(
operator|*
name|pos
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
name|o_flipcase
index|[
call|(
name|int
call|)
argument_list|(
name|pos
operator|-
name|o_flipcase
argument_list|)
operator|^
literal|1
index|]
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* if nothing special, then don't change it */
if|if
condition|(
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|==
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
name|ptext
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* if the new text is different from the old, then change it */
if|if
condition|(
name|strncmp
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
operator|&
name|ptext
index|[
name|markidx
argument_list|(
name|m
argument_list|)
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|ChangeText
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|change
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|j
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m
operator|+
name|j
return|;
block|}
end_function

begin_function
name|MARK
name|v_replace
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* first char to be replaced */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to replace */
name|int
name|key
decl_stmt|;
comment|/* what to replace them with */
block|{
name|REG
name|char
modifier|*
name|text
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* map ^M to '\n' */
if|if
condition|(
name|key
operator|==
literal|'\r'
condition|)
block|{
name|key
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/* make sure the resulting line isn't too long */
if|if
condition|(
name|cnt
operator|>
name|BLKSIZE
operator|-
literal|2
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|cnt
operator|=
name|BLKSIZE
operator|-
literal|2
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* build a string of the desired character with the desired length */
for|for
control|(
name|text
operator|=
name|tmpblk
operator|.
name|c
operator|,
name|i
operator|=
name|cnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|text
operator|++
operator|=
name|key
expr_stmt|;
block|}
operator|*
name|text
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure cnt doesn't extend past EOL */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|+
name|cnt
operator|>
name|plen
condition|)
block|{
name|cnt
operator|=
name|plen
operator|-
name|key
expr_stmt|;
block|}
comment|/* do the replacement */
name|ChangeText
block|{
name|change
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tmpblk
operator|.
name|c
operator|==
literal|'\n'
condition|)
block|{
return|return
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|cnt
operator|*
name|BLKSIZE
return|;
block|}
else|else
block|{
return|return
name|m
operator|+
name|cnt
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|MARK
name|v_overtype
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to start overtyping */
block|{
name|MARK
name|end
decl_stmt|;
comment|/* end of a substitution */
specifier|static
name|long
name|width
decl_stmt|;
comment|/* width of a single-line replace */
comment|/* the "doingdot" version of replace is really a substitution */
if|if
condition|(
name|doingdot
condition|)
block|{
comment|/* was the last one really repeatable? */
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't repeat a multi-line overtype command"
argument_list|)
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
comment|/* replacing nothing by nothing?  Don't bother */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
return|return
name|m
return|;
block|}
comment|/* replace some chars by repeated text */
return|return
name|v_subst
argument_list|(
name|m
argument_list|,
name|width
argument_list|)
return|;
block|}
comment|/* Normally, we input starting here, in replace mode */
name|ChangeText
block|{
name|end
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|WHEN_VIREP
argument_list|)
expr_stmt|;
block|}
comment|/* if we ended on the same line we started on, then this 	 * overtype is repeatable via the dot key. 	 */
if|if
condition|(
name|markline
argument_list|(
name|end
argument_list|)
operator|==
name|markline
argument_list|(
name|m
argument_list|)
operator|&&
name|end
operator|>=
name|m
operator|-
literal|1L
condition|)
block|{
name|width
operator|=
name|end
operator|-
name|m
operator|+
literal|1L
expr_stmt|;
block|}
else|else
comment|/* it isn't repeatable */
block|{
name|width
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
return|return
name|end
return|;
block|}
end_function

begin_comment
comment|/* This function selects which cut buffer to use */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_selcut
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
name|int
name|key
decl_stmt|;
block|{
name|cutname
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function pastes text from a cut buffer */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_paste
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|cmd
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to paste the text */
name|long
name|cnt
decl_stmt|;
comment|/* (ignored) */
name|int
name|cmd
decl_stmt|;
comment|/* either 'p' or 'P' */
block|{
name|ChangeText
block|{
name|m
operator|=
name|paste
argument_list|(
name|m
argument_list|,
name|cmd
operator|==
literal|'p'
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function yanks text into a cut buffer */
end_comment

begin_function
name|MARK
name|v_yank
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of text to yank */
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function deletes a range of text */
end_comment

begin_function
name|MARK
name|v_delete
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of text to delete */
block|{
comment|/* illegal to try and delete nothing */
if|if
condition|(
name|n
operator|<=
name|m
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* Do it */
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This starts input mode without deleting anything */
end_comment

begin_function
name|MARK
name|v_insert
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to start (sort of) */
name|long
name|cnt
decl_stmt|;
comment|/* repeat how many times? */
name|int
name|key
decl_stmt|;
comment|/* what command is this for? {a,A,i,I,o,O} */
block|{
name|int
name|wasdot
decl_stmt|;
name|long
name|reps
decl_stmt|;
name|int
name|after
decl_stmt|;
comment|/* are we appending or inserting? */
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ChangeText
block|{
comment|/* tweak the insertion point, based on command key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'i'
case|:
name|after
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
block|}
name|after
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|m
operator|=
name|m_front
argument_list|(
name|m
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|after
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
expr_stmt|;
name|after
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|m
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|add
argument_list|(
name|m
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|after
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|m
operator|=
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
name|add
argument_list|(
name|m
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|after
operator|=
name|FALSE
expr_stmt|;
break|break;
block|}
comment|/* insert the same text once or more */
for|for
control|(
name|reps
operator|=
name|cnt
operator|,
name|wasdot
operator|=
name|doingdot
init|;
name|reps
operator|>
literal|0
condition|;
name|reps
operator|--
operator|,
name|doingdot
operator|=
name|TRUE
control|)
block|{
name|m
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|WHEN_VIINP
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|after
condition|)
block|{
name|m
operator|--
expr_stmt|;
block|}
name|doingdot
operator|=
name|wasdot
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|key
operator|==
literal|'i'
operator|&&
operator|*
name|o_inputmode
operator|&&
name|mode
operator|==
name|MODE_VI
condition|)
block|{
name|msg
argument_list|(
literal|"Now in visual command mode!  To return to input mode, hit<i>."
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This starts input mode with some text deleted */
end_comment

begin_function
name|MARK
name|v_change
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* the range of text to change */
block|{
name|int
name|lnmode
decl_stmt|;
comment|/* is this a line-mode change? */
comment|/* swap them if they're in reverse order */
if|if
condition|(
name|m
operator|>
name|n
condition|)
block|{
name|MARK
name|tmp
decl_stmt|;
name|tmp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* for line mode, retain the last newline char */
name|lnmode
operator|=
operator|(
name|markidx
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|m
operator|!=
name|n
operator|)
expr_stmt|;
if|if
condition|(
name|lnmode
condition|)
block|{
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
name|pfetch
argument_list|(
name|markline
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
expr_stmt|;
block|}
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|m
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|WHEN_VIINP
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function replaces a given number of characters with input */
end_comment

begin_function
name|MARK
name|v_subst
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where substitutions start */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to replace */
block|{
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure we don't try replacing past EOL */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|m
argument_list|)
operator|+
name|cnt
operator|>
name|plen
condition|)
block|{
name|cnt
operator|=
name|plen
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Go for it! */
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|m
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|,
name|WHEN_VIINP
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This calls the ex "join" command to join some lines together */
end_comment

begin_function
name|MARK
name|v_join
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* the first line to be joined */
name|long
name|cnt
decl_stmt|;
comment|/* number of other lines to join */
block|{
name|MARK
name|joint
decl_stmt|;
comment|/* where the lines were joined */
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* figure out where the joint will be */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|joint
operator|=
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
expr_stmt|;
comment|/* join the lines */
name|cmd_join
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|MARK_AT_LINE
argument_list|(
name|cnt
argument_list|)
argument_list|,
name|CMD_JOIN
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mustredraw
operator|=
name|TRUE
expr_stmt|;
comment|/* the cursor should be left at the joint */
return|return
name|joint
return|;
block|}
end_function

begin_comment
comment|/* This calls the ex shifter command to shift some lines */
end_comment

begin_function
specifier|static
name|MARK
name|shift_help
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|,
name|excmd
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
name|CMD
name|excmd
decl_stmt|;
comment|/* which way do we shift? */
block|{
comment|/* adjust for inclusive endmarks in ex */
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
name|cmd_shift
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|excmd
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This calls the ex "<" command to shift some lines left */
end_comment

begin_function
name|MARK
name|v_lshift
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
block|{
return|return
name|shift_help
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|CMD_SHIFTL
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This calls the ex ">" command to shift some lines right */
end_comment

begin_function
name|MARK
name|v_rshift
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
block|{
return|return
name|shift_help
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|CMD_SHIFTR
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This runs some lines through a filter program */
end_comment

begin_function
name|MARK
name|v_filter
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
block|{
name|char
name|cmdln
index|[
literal|100
index|]
decl_stmt|;
comment|/* a shell command line */
comment|/* adjust for inclusive endmarks in ex */
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
if|if
condition|(
name|vgets
argument_list|(
literal|'!'
argument_list|,
name|cmdln
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdln
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|filter
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|cmdln
argument_list|)
expr_stmt|;
block|}
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function runs the ex "file" command to show the file's status */
end_comment

begin_function
name|MARK
name|v_status
parameter_list|()
block|{
name|cmd_file
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|CMD_FILE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function runs the ":&" command to repeat the previous :s// */
end_comment

begin_function
name|MARK
name|v_again
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
block|{
name|cmd_substitute
argument_list|(
name|m
argument_list|,
name|n
operator|-
name|BLKSIZE
argument_list|,
name|CMD_SUBAGAIN
argument_list|,
name|TRUE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function switches to the previous file, if possible */
end_comment

begin_function
name|MARK
name|v_switch
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|*
name|prevorig
condition|)
name|msg
argument_list|(
literal|"No previous file"
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|prevorig
argument_list|)
expr_stmt|;
name|cmd_edit
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|CMD_EDIT
argument_list|,
literal|0
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function does a tag search on a keyword */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_tag
parameter_list|(
name|keyword
parameter_list|,
name|m
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|keyword
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
block|{
comment|/* move the cursor to the start of the tag name, where m is */
name|cursor
operator|=
name|m
expr_stmt|;
comment|/* perform the tag search */
name|cmd_tag
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|CMD_TAG
argument_list|,
literal|0
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
end_ifndef

begin_comment
comment|/* This function looks up a keyword by calling the helpprog program */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_keyword
parameter_list|(
name|keyword
parameter_list|,
name|m
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|keyword
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
block|{
name|int
name|waswarn
decl_stmt|;
name|char
name|cmdline
index|[
literal|130
index|]
decl_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s %s"
argument_list|,
name|o_keywordprg
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|waswarn
operator|=
operator|*
name|o_warn
expr_stmt|;
operator|*
name|o_warn
operator|=
name|FALSE
expr_stmt|;
name|suspend_curses
argument_list|()
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|cmdline
argument_list|)
condition|)
block|{
name|addstr
argument_list|(
literal|"<<< failed>>>\n"
argument_list|)
expr_stmt|;
block|}
name|resume_curses
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE_VI
expr_stmt|;
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|o_warn
operator|=
name|waswarn
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
name|MARK
name|v_increment
parameter_list|(
name|keyword
parameter_list|,
name|m
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|keyword
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
block|{
specifier|static
name|sign
expr_stmt|;
name|char
name|newval
index|[
literal|12
index|]
decl_stmt|;
name|long
name|atol
parameter_list|()
function_decl|;
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* get one more keystroke, unless doingdot */
if|if
condition|(
operator|!
name|doingdot
condition|)
block|{
name|sign
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* adjust the number, based on that second keystroke */
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'#'
case|:
name|cnt
operator|=
name|atol
argument_list|(
name|keyword
argument_list|)
operator|+
name|cnt
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|cnt
operator|=
name|atol
argument_list|(
name|keyword
argument_list|)
operator|-
name|cnt
expr_stmt|;
break|break;
case|case
literal|'='
case|:
break|break;
default|default:
return|return
name|MARK_UNSET
return|;
block|}
name|sprintf
argument_list|(
name|newval
argument_list|,
literal|"%ld"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|ChangeText
block|{
name|change
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|strlen
argument_list|(
name|keyword
argument_list|)
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function acts like the EX command "xit" */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_xit
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* ignored */
name|long
name|cnt
decl_stmt|;
comment|/* ignored */
name|int
name|key
decl_stmt|;
comment|/* must be a second 'Z' */
block|{
comment|/* if second char wasn't 'Z', fail */
if|if
condition|(
name|key
operator|!=
literal|'Z'
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* move the cursor to the bottom of the screen */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* do the xit command */
name|cmd_xit
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|CMD_XIT
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* return the cursor */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function undoes changes to a single line, if possible */
end_comment

begin_function
name|MARK
name|v_undoline
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where we hope to undo the change */
block|{
comment|/* make sure we have the right line in the buffer */
if|if
condition|(
name|markline
argument_list|(
name|m
argument_list|)
operator|!=
name|U_line
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* fix it */
name|ChangeText
block|{
name|strcat
argument_list|(
name|U_text
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|change
argument_list|(
name|MARK_AT_LINE
argument_list|(
name|U_line
argument_list|)
argument_list|,
name|MARK_AT_LINE
argument_list|(
name|U_line
operator|+
literal|1
argument_list|)
argument_list|,
name|U_text
argument_list|)
expr_stmt|;
block|}
comment|/* nothing in the buffer anymore */
name|U_line
operator|=
operator|-
literal|1L
expr_stmt|;
comment|/* return, with the cursor at the front of the line */
return|return
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRLIST
end_ifndef

begin_function
name|MARK
name|v_errlist
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
block|{
name|cmd_errlist
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|CMD_ERRLIST
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AT
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_at
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
name|int
name|key
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|fromcutbuf
argument_list|(
name|key
argument_list|)
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

