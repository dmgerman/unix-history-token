begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Tar -- a tape archiver.  	Copyright (C) 1988 Free Software Foundation  GNU tar is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing. Refer to the GNU tar General Public License for full details.  Everyone is granted permission to copy, modify and redistribute GNU tar, but only under the conditions described in the GNU tar General Public License.  A copy of this license is supposed to have been given to you along with GNU tar so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  In other words, go ahead and share GNU tar, but don't try to stop anyone else from sharing it farther.  Help stamp out software hoarding! */
end_comment

begin_comment
comment|/*  * A tar (tape archiver) program.  *  * Written by John Gilmore, ihnp4!hoptoad!gnu, starting 25 Aug 85.  *  * @(#)tar.c 1.34 11/6/87 - gnu  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_comment
comment|/* Needed for typedefs in tar.h */
end_comment

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_comment
comment|/* JF */
end_comment

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|"regex.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_define
define|#
directive|define
name|rindex
value|strrchr
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BSD42
end_ifdef

begin_include
include|#
directive|include
file|<sys/dir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|__MSDOS__
end_ifdef

begin_include
include|#
directive|include
file|"msd_dir.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|NDIR
end_ifdef

begin_include
include|#
directive|include
file|<ndir.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DIRECT
end_ifndef

begin_define
define|#
directive|define
name|direct
value|dirent
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|DP_NAMELEN
parameter_list|(
name|x
parameter_list|)
value|strlen((x)->d_name)
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * FIXME: On other systems there is no standard place for the header file  * for the portable directory access routines.  Change the #include line  * below to bring it in from wherever it is.  */
end_comment

begin_include
include|#
directive|include
file|"ndir.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DP_NAMELEN
end_ifndef

begin_define
define|#
directive|define
name|DP_NAMELEN
parameter_list|(
name|x
parameter_list|)
value|(x)->d_namlen
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strncpy
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* JF */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|strcat
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* JF */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pointer to argument */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|optind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Global argv index from getopt */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|ck_malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|ck_realloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * The following causes "tar.h" to produce definitions of all the  * global variables, rather than just "extern" declarations of them.  */
end_comment

begin_define
define|#
directive|define
name|TAR_EXTERN
end_define

begin_comment
comment|/**/
end_comment

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_comment
comment|/*  * We should use a conversion routine that does reasonable error  * checking -- atoi doesn't.  For now, punt.  FIXME.  */
end_comment

begin_define
define|#
directive|define
name|intconv
value|atoi
end_define

begin_function_decl
specifier|extern
name|int
name|getoldopt
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|read_and
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|list_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|extract_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|diff_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|create_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|update_archive
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|void
name|junk_archive
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* JF */
end_comment

begin_function_decl
specifier|extern
name|time_t
name|get_date
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|time_t
name|new_time
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|namef
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* File to read names from */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|n_argv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Argv used by name routines */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_argc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Argc used by name routines */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|n_ind
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Store an array of names */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_indalloc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How big is the array? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_indused
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many entries does it have? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_indscan
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* How many of the entries have we scanned? */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|describe
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|options
parameter_list|()
function_decl|;
end_function_decl

begin_ifndef
ifndef|#
directive|ifndef
name|S_IFLNK
end_ifndef

begin_define
define|#
directive|define
name|lstat
value|stat
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEFBLOCKING
end_ifndef

begin_define
define|#
directive|define
name|DEFBLOCKING
value|20
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|DEF_AR_FILE
end_ifndef

begin_define
define|#
directive|define
name|DEF_AR_FILE
value|"tar.out"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* For long options that unconditionally set a single flag, we have getopt    do it.  For the others, we share the code for the equivalent short    named option, the name of which is stored in the otherwise-unused `val'    field of the `struct option'; for long options that have no equivalent    short option, we use nongraphic characters as pseudo short option    characters, starting (for no particular reason) with character 10. */
end_comment

begin_decl_stmt
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"create"
block|,
literal|0
block|,
literal|0
block|,
literal|'c'
block|}
block|,
block|{
literal|"append"
block|,
literal|0
block|,
literal|0
block|,
literal|'r'
block|}
block|,
block|{
literal|"extract"
block|,
literal|0
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"get"
block|,
literal|0
block|,
literal|0
block|,
literal|'x'
block|}
block|,
block|{
literal|"list"
block|,
literal|0
block|,
literal|0
block|,
literal|'t'
block|}
block|,
block|{
literal|"update"
block|,
literal|0
block|,
literal|0
block|,
literal|'u'
block|}
block|,
block|{
literal|"catenate"
block|,
literal|0
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"concatenate"
block|,
literal|0
block|,
literal|0
block|,
literal|'A'
block|}
block|,
block|{
literal|"compare"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"diff"
block|,
literal|0
block|,
literal|0
block|,
literal|'d'
block|}
block|,
block|{
literal|"delete"
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|}
block|,
block|{
literal|"help"
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|}
block|,
block|{
literal|"directory"
block|,
literal|1
block|,
literal|0
block|,
literal|'C'
block|}
block|,
block|{
literal|"record-number"
block|,
literal|0
block|,
operator|&
name|f_sayblock
block|,
literal|1
block|}
block|,
block|{
literal|"files-from"
block|,
literal|1
block|,
literal|0
block|,
literal|'T'
block|}
block|,
block|{
literal|"label"
block|,
literal|1
block|,
literal|0
block|,
literal|'V'
block|}
block|,
block|{
literal|"exclude-from"
block|,
literal|1
block|,
literal|0
block|,
literal|'X'
block|}
block|,
block|{
literal|"exclude"
block|,
literal|1
block|,
literal|0
block|,
literal|15
block|}
block|,
block|{
literal|"file"
block|,
literal|1
block|,
literal|0
block|,
literal|'f'
block|}
block|,
block|{
literal|"block-size"
block|,
literal|1
block|,
literal|0
block|,
literal|'b'
block|}
block|,
block|{
literal|"version"
block|,
literal|0
block|,
literal|0
block|,
literal|11
block|}
block|,
block|{
literal|"verbose"
block|,
literal|0
block|,
literal|0
block|,
literal|'v'
block|}
block|,
block|{
literal|"totals"
block|,
literal|0
block|,
operator|&
name|f_totals
block|,
literal|1
block|}
block|,
block|{
literal|"read-full-blocks"
block|,
literal|0
block|,
operator|&
name|f_reblock
block|,
literal|1
block|}
block|,
block|{
literal|"starting-file"
block|,
literal|1
block|,
literal|0
block|,
literal|'K'
block|}
block|,
block|{
literal|"to-stdout"
block|,
literal|0
block|,
operator|&
name|f_exstdout
block|,
literal|1
block|}
block|,
block|{
literal|"ignore-zeros"
block|,
literal|0
block|,
operator|&
name|f_ignorez
block|,
literal|1
block|}
block|,
block|{
literal|"keep-old-files"
block|,
literal|0
block|,
literal|0
block|,
literal|'k'
block|}
block|,
block|{
literal|"uncompress"
block|,
literal|0
block|,
operator|&
name|f_compress
block|,
literal|1
block|}
block|,
block|{
literal|"same-permissions"
block|,
literal|0
block|,
operator|&
name|f_use_protection
block|,
literal|1
block|}
block|,
block|{
literal|"preserve-permissions"
block|,
literal|0
block|,
operator|&
name|f_use_protection
block|,
literal|1
block|}
block|,
block|{
literal|"modification-time"
block|,
literal|0
block|,
operator|&
name|f_modified
block|,
literal|1
block|}
block|,
block|{
literal|"preserve"
block|,
literal|0
block|,
literal|0
block|,
literal|10
block|}
block|,
block|{
literal|"same-order"
block|,
literal|0
block|,
operator|&
name|f_sorted_names
block|,
literal|1
block|}
block|,
block|{
literal|"same-owner"
block|,
literal|0
block|,
operator|&
name|f_do_chown
block|,
literal|1
block|}
block|,
block|{
literal|"preserve-order"
block|,
literal|0
block|,
operator|&
name|f_sorted_names
block|,
literal|1
block|}
block|,
block|{
literal|"newer"
block|,
literal|1
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"after-date"
block|,
literal|1
block|,
literal|0
block|,
literal|'N'
block|}
block|,
block|{
literal|"newer-mtime"
block|,
literal|1
block|,
literal|0
block|,
literal|13
block|}
block|,
block|{
literal|"incremental"
block|,
literal|0
block|,
literal|0
block|,
literal|'G'
block|}
block|,
block|{
literal|"listed-incremental"
block|,
literal|1
block|,
literal|0
block|,
literal|'g'
block|}
block|,
block|{
literal|"multi-volume"
block|,
literal|0
block|,
operator|&
name|f_multivol
block|,
literal|1
block|}
block|,
block|{
literal|"info-script"
block|,
literal|1
block|,
operator|&
name|f_run_script_at_end
block|,
literal|1
block|}
block|,
block|{
literal|"absolute-paths"
block|,
literal|0
block|,
operator|&
name|f_absolute_paths
block|,
literal|1
block|}
block|,
block|{
literal|"interactive"
block|,
literal|0
block|,
operator|&
name|f_confirm
block|,
literal|1
block|}
block|,
block|{
literal|"confirmation"
block|,
literal|0
block|,
operator|&
name|f_confirm
block|,
literal|1
block|}
block|,
block|{
literal|"verify"
block|,
literal|0
block|,
operator|&
name|f_verify
block|,
literal|1
block|}
block|,
block|{
literal|"dereference"
block|,
literal|0
block|,
operator|&
name|f_follow_links
block|,
literal|1
block|}
block|,
block|{
literal|"one-file-system"
block|,
literal|0
block|,
operator|&
name|f_local_filesys
block|,
literal|1
block|}
block|,
block|{
literal|"old-archive"
block|,
literal|0
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"portability"
block|,
literal|0
block|,
literal|0
block|,
literal|'o'
block|}
block|,
block|{
literal|"compress"
block|,
literal|0
block|,
operator|&
name|f_compress
block|,
literal|1
block|}
block|,
block|{
literal|"compress-block"
block|,
literal|0
block|,
operator|&
name|f_compress
block|,
literal|2
block|}
block|,
block|{
literal|"sparse"
block|,
literal|0
block|,
operator|&
name|f_sparse_files
block|,
literal|1
block|}
block|,
block|{
literal|"tape-length"
block|,
literal|1
block|,
literal|0
block|,
literal|'L'
block|}
block|,
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Main routine for tar.  */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|extern
name|char
name|version_string
index|[]
decl_stmt|;
name|tar
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* JF: was "tar" Set program name */
name|errors
operator|=
literal|0
expr_stmt|;
name|options
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|n_argv
condition|)
name|name_init
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|cmd_mode
condition|)
block|{
case|case
name|CMD_CAT
case|:
case|case
name|CMD_UPDATE
case|:
case|case
name|CMD_APPEND
case|:
name|update_archive
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_DELETE
case|:
name|junk_archive
argument_list|()
expr_stmt|;
break|break;
case|case
name|CMD_CREATE
case|:
name|create_archive
argument_list|()
expr_stmt|;
if|if
condition|(
name|f_totals
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Total bytes written: %d\n"
argument_list|,
name|tot_written
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_EXTRACT
case|:
if|if
condition|(
name|f_volhdr
condition|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|label_pattern
operator|=
operator|(
expr|struct
name|re_pattern_buffer
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
expr|*
name|label_pattern
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|f_volhdr
argument_list|,
name|strlen
argument_list|(
name|f_volhdr
argument_list|)
argument_list|,
name|label_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad regular expression: %s\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|extr_init
argument_list|()
expr_stmt|;
name|read_and
argument_list|(
name|extract_archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_LIST
case|:
if|if
condition|(
name|f_volhdr
condition|)
block|{
name|char
modifier|*
name|err
decl_stmt|;
name|label_pattern
operator|=
operator|(
expr|struct
name|re_pattern_buffer
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
expr|*
name|label_pattern
argument_list|)
expr_stmt|;
name|err
operator|=
name|re_compile_pattern
argument_list|(
name|f_volhdr
argument_list|,
name|strlen
argument_list|(
name|f_volhdr
argument_list|)
argument_list|,
name|label_pattern
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad regular expression: %s\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|errors
operator|++
expr_stmt|;
break|break;
block|}
block|}
name|read_and
argument_list|(
name|list_archive
argument_list|)
expr_stmt|;
if|#
directive|if
literal|0
block|if (!errors) 			errors = different;
endif|#
directive|endif
break|break;
case|case
name|CMD_DIFF
case|:
name|diff_init
argument_list|()
expr_stmt|;
name|read_and
argument_list|(
name|diff_archive
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_VERSION
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|version_string
argument_list|)
expr_stmt|;
break|break;
case|case
name|CMD_NONE
case|:
name|msg
argument_list|(
literal|"you must specify exactly one of the r, c, t, x, or d options\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"For more information, type ``%s +help''.\n"
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|errors
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * Parse the options for tar.  */
end_comment

begin_function
name|void
name|options
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
specifier|register
name|int
name|c
decl_stmt|;
comment|/* Option letter */
name|int
name|ind
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Set default option values */
name|blocking
operator|=
name|DEFBLOCKING
expr_stmt|;
comment|/* From Makefile */
name|ar_file
operator|=
name|getenv
argument_list|(
literal|"TAPE"
argument_list|)
expr_stmt|;
comment|/* From environment, or */
if|if
condition|(
name|ar_file
operator|==
literal|0
condition|)
name|ar_file
operator|=
name|DEF_AR_FILE
expr_stmt|;
comment|/* From Makefile */
comment|/* Parse options */
while|while
condition|(
operator|(
name|c
operator|=
name|getoldopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"-01234567Ab:BcC:df:F:g:GhikK:lL:mMN:oOpPrRsStT:uvV:wWxX:zZ"
argument_list|,
name|long_options
argument_list|,
operator|&
name|ind
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
comment|/* long options that set a single flag */
break|break;
case|case
literal|1
case|:
comment|/* File name or non-parsed option */
name|name_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
name|name_add
argument_list|(
literal|"-C"
argument_list|)
expr_stmt|;
name|name_add
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|10
case|:
comment|/* preserve */
name|f_use_protection
operator|=
name|f_sorted_names
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|11
case|:
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_VERSION
expr_stmt|;
break|break;
case|case
literal|12
case|:
comment|/* help */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"This is GNU tar, the tape archiving program.\n"
argument_list|)
expr_stmt|;
name|describe
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
case|case
literal|13
case|:
name|f_new_files
operator|++
expr_stmt|;
goto|goto
name|get_newer
goto|;
case|case
literal|14
case|:
comment|/* Delete in the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_DELETE
expr_stmt|;
break|break;
case|case
literal|15
case|:
name|f_exclude
operator|++
expr_stmt|;
name|add_exclude
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* We are making a GNU dump; save 						   directories at the beginning of 						   the archive, and include in each 						   directory its contents */
if|if
condition|(
name|f_oldarch
condition|)
goto|goto
name|badopt
goto|;
name|f_gnudump
operator|++
expr_stmt|;
name|gnu_dumpfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
block|{
comment|/* JF this'll have to be modified for other 				   systems, of course! */
name|int
name|d
decl_stmt|,
name|add
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|50
index|]
decl_stmt|;
name|d
operator|=
name|getoldopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"lmh"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAYBEDEF
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"/dev/rmt/%d%c"
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
else|#
directive|else
ifndef|#
directive|ifndef
name|LOW_NUM
define|#
directive|define
name|LOW_NUM
value|0
define|#
directive|define
name|MID_NUM
value|8
define|#
directive|define
name|HGH_NUM
value|16
endif|#
directive|endif
if|if
condition|(
name|d
operator|==
literal|'l'
condition|)
name|add
operator|=
name|LOW_NUM
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
literal|'m'
condition|)
name|add
operator|=
name|MID_NUM
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|==
literal|'h'
condition|)
name|add
operator|=
name|HGH_NUM
expr_stmt|;
else|else
goto|goto
name|badopt
goto|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"/dev/rmt%d"
argument_list|,
name|add
operator|+
name|c
operator|-
literal|'0'
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ar_file
operator|=
name|buf
expr_stmt|;
block|}
break|break;
case|case
literal|'A'
case|:
comment|/* Arguments are tar files, 						   just cat them onto the end 						   of the archive.  */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_CAT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* Set blocking factor */
name|blocking
operator|=
name|intconv
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* Try to reblock input */
name|f_reblock
operator|++
expr_stmt|;
comment|/* For reading 4.2BSD pipes */
break|break;
case|case
literal|'c'
case|:
comment|/* Create an archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_CREATE
expr_stmt|;
break|break;
comment|/*		case 'C': 			if(chdir(optarg)<0) 				msg_perror("Can't change directory to %d",optarg); 			break; */
case|case
literal|'d'
case|:
comment|/* Find difference tape/disk */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_DIFF
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* Use ar_file for the archive */
name|ar_file
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
comment|/* Since -F is only useful with -M , make it implied */
name|f_run_script_at_end
operator|++
expr_stmt|;
comment|/* run this script at the end */
name|info_script
operator|=
name|optarg
expr_stmt|;
comment|/* of each tape */
name|f_multivol
operator|++
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
comment|/* We are making a GNU dump; save 						   directories at the beginning of 						   the archive, and include in each 						   directory its contents */
if|if
condition|(
name|f_oldarch
condition|)
goto|goto
name|badopt
goto|;
name|f_gnudump
operator|++
expr_stmt|;
name|gnu_dumpfile
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|f_follow_links
operator|++
expr_stmt|;
comment|/* follow symbolic links */
break|break;
case|case
literal|'i'
case|:
name|f_ignorez
operator|++
expr_stmt|;
comment|/* Ignore zero records (eofs) */
comment|/* 			 * This can't be the default, because Unix tar 			 * writes two records of zeros, then pads out the 			 * block with garbage. 			 */
break|break;
case|case
literal|'k'
case|:
comment|/* Don't overwrite files */
ifdef|#
directive|ifdef
name|NO_OPEN3
name|msg
argument_list|(
literal|"can't do -k option on this system"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
else|#
directive|else
name|f_keep
operator|++
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
literal|'K'
case|:
name|f_startfile
operator|++
expr_stmt|;
name|addname
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* When dumping directories, don't 						   dump files/subdirectories that are 						   on other filesystems. */
name|f_local_filesys
operator|++
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|tape_length
operator|=
name|intconv
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|f_multivol
operator|++
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|f_modified
operator|++
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* Make Multivolume archive: 						   When we can't write any more 						   into the archive, re-open it, 						   and continue writing */
name|f_multivol
operator|++
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
comment|/* Only write files newer than X */
name|get_newer
label|:
name|f_new_files
operator|++
expr_stmt|;
name|new_time
operator|=
name|get_date
argument_list|(
name|optarg
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* Generate old archive */
if|if
condition|(
name|f_gnudump
comment|/* || f_dironly */
condition|)
goto|goto
name|badopt
goto|;
name|f_oldarch
operator|++
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|f_exstdout
operator|++
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|f_use_protection
operator|++
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|f_absolute_paths
operator|++
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
comment|/* Append files to the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_APPEND
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
name|f_sayblock
operator|++
expr_stmt|;
comment|/* Print block #s for debug */
break|break;
comment|/* of bad tar archives */
case|case
literal|'s'
case|:
name|f_sorted_names
operator|++
expr_stmt|;
comment|/* Names to extr are sorted */
break|break;
case|case
literal|'S'
case|:
comment|/* deal with sparse files */
name|f_sparse_files
operator|++
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_LIST
expr_stmt|;
name|f_verbose
operator|++
expr_stmt|;
comment|/* "t" output == "cv" or "xv" */
break|break;
case|case
literal|'T'
case|:
name|name_file
operator|=
name|optarg
expr_stmt|;
name|f_namefile
operator|++
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* Append files to the archive that 						   aren't there, or are newer than the 						   copy in the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_UPDATE
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|f_verbose
operator|++
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|f_volhdr
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|f_confirm
operator|++
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
name|f_verify
operator|++
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
comment|/* Extract files from the archive */
if|if
condition|(
name|cmd_mode
operator|!=
name|CMD_NONE
condition|)
goto|goto
name|badopt
goto|;
name|cmd_mode
operator|=
name|CMD_EXTRACT
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|f_exclude
operator|++
expr_stmt|;
name|add_exclude_file
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* Easy to type */
case|case
literal|'Z'
case|:
comment|/* Like the filename extension .Z */
name|f_compress
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|badopt
label|:
name|msg
argument_list|(
literal|"Unknown option.  Use '%s +help' for a complete list of options."
argument_list|,
name|tar
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
block|}
name|blocksize
operator|=
name|blocking
operator|*
name|RECORDSIZE
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print as much help as the user's gonna get.  *  * We have to sprinkle in the KLUDGE lines because too many compilers  * cannot handle character strings longer than about 512 bytes.  Yuk!  * In particular, MSDOS and Xenix MSC and PDP-11 V7 Unix have this  * problem.  */
end_comment

begin_function
name|void
name|describe
parameter_list|()
block|{
name|msg
argument_list|(
literal|"choose one of the following:"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ -A, +catenate,\n\     +concatenate	append tar files to an archive\n\ -c, +create		create a new archive\n\ -d, +diff,\n\     +compare		find differences between archive and file system\n\ +delete			delete from the archive (not for use on mag tapes!)\n\ -r, +append		append files to the end of an archive\n\ -t, +list		list the contents of an archive\n\ -u, +update		only append files that are newer than copy in archive\n\ -x, +extract,\n\     +get		extract files from an archive\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Other options:\n\ -b, +block-size N	block size of Nx512 bytes (default N=%d)\n"
argument_list|,
name|DEFBLOCKING
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ -B, +read-full-blocks	reblock as we read (for reading 4.2BSD pipes)\n\ -C, +directory DIR	change to directory DIR\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ -f, +file [HOSTNAME:]F	use archive file or device F (default %s)\n"
argument_list|,
name|DEF_AR_FILE
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ -F, +info-script F	run script at end of each tape (implies -M)\n\ -G, +incremental	create/list/extract old GNU-format incremental backup\n\ -g, +listed-incremental F create/list/extract new GNU-format incremental backup\n\ -h, +dereference	don't dump symlinks; dump the files they point to\n\ -i, +ignore-zeros	ignore blocks of zeros in archive (normally mean EOF)\n\ -k, +keep-old-files	keep existing files; don't overwrite them from archive\n\ -K, +starting-file FILE	begin at FILE in the archive\n\ -l, +one-file-system	stay in local file system when creating an archive\n\ -L, +tape-length LENGTH change tapes after writing LENGTH\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fputs
argument_list|(
literal|"\ -m, +modification-time	don't extract file modified time\n\ -M, +multi-volume	create/list/extract multi-volume archive\n\ -N, +after-date DATE,\n\     +newer DATE		only store files newer than DATE\n\ -o, +old-archive,\n\     +portability	write a V7 format archive, rather than ANSI format\n\ -O, +to-stdout		extract files to standard output\n\ -p, +same-permissions,\n\     +preserve-permissions extract all protection information\n\ -P, +absolute-paths	don't strip leading `/'s from file names\n\ +preserve		like -p -s\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fputs
argument_list|(
literal|"\ -R, +record-number	show record number within archive with each message\n\ -s, +same-order,\n\     +preserve-order	list of names to extract is sorted to match archive\n\ +same-order		create extracted files with the same ownership \n\ -S, +sparse		handle sparse files efficiently\n\ -T, +files-from F	get names to extract or create from file F\n\ +totals			print total bytes written with +create\n\ -v, +verbose		verbosely list files processed\n\ -V, +label NAME		create archive with volume name NAME\n\ +version		print tar program version number\n\ -w, +interactive,\n\     +confirmation	ask for confirmation for every action\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* KLUDGE */
name|fputs
argument_list|(
literal|"\ -W, +verify		attempt to verify the archive after writing it\n\ -X, +exclude FILE	exclude file FILE\n\ +exclude-from FILE	exclude files listed in FILE\n\ -z, -Z, +compress,\n\     +uncompress      	filter the archive through compress\n\ -[0-7][lmh]		specify drive and density\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|name_add
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|n_indalloc
operator|==
name|n_indused
condition|)
block|{
name|n_indalloc
operator|+=
literal|10
expr_stmt|;
name|n_ind
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|n_indused
condition|?
name|ck_realloc
argument_list|(
name|n_ind
argument_list|,
name|n_indalloc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
else|:
name|ck_malloc
argument_list|(
name|n_indalloc
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
expr_stmt|;
block|}
name|n_ind
index|[
name|n_indused
operator|++
index|]
operator|=
name|name
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Set up to gather file names for tar.  *  * They can either come from stdin or from argv.  */
end_comment

begin_macro
name|name_init
argument_list|(
argument|argc
argument_list|,
argument|argv
argument_list|)
end_macro

begin_decl_stmt
name|int
name|argc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|f_namefile
condition|)
block|{
if|if
condition|(
name|optind
operator|<
name|argc
condition|)
block|{
name|msg
argument_list|(
literal|"too many args with -T option"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name_file
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|namef
operator|=
name|stdin
expr_stmt|;
block|}
else|else
block|{
name|namef
operator|=
name|fopen
argument_list|(
name|name_file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|namef
operator|==
name|NULL
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open file %s"
argument_list|,
name|name_file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_BADFILE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* Get file names from argv, after options. */
name|n_argc
operator|=
name|argc
expr_stmt|;
name|n_argv
operator|=
name|argv
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Get the next name from argv or the name file.  *  * Result is in static storage and can't be relied upon across two calls.  */
end_comment

begin_comment
comment|/* C is non-zero if we should deal with -C */
end_comment

begin_function
name|char
modifier|*
name|name_next
parameter_list|(
name|c
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buffer
decl_stmt|;
comment|/* Holding pattern */
specifier|static
name|buffer_siz
expr_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|char
modifier|*
name|q
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|q2
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|un_quote_string
parameter_list|()
function_decl|;
if|if
condition|(
name|buffer_siz
operator|==
literal|0
condition|)
block|{
name|buffer
operator|=
name|ck_malloc
argument_list|(
name|NAMSIZ
operator|+
literal|2
argument_list|)
expr_stmt|;
name|buffer_siz
operator|=
name|NAMSIZ
expr_stmt|;
block|}
name|tryagain
label|:
if|if
condition|(
name|namef
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|n_indscan
operator|<
name|n_indused
condition|)
name|p
operator|=
name|n_ind
index|[
name|n_indscan
operator|++
index|]
expr_stmt|;
elseif|else
if|if
condition|(
name|optind
operator|<
name|n_argc
condition|)
comment|/* Names come from argv, after options */
name|p
operator|=
name|n_argv
index|[
name|optind
operator|++
index|]
expr_stmt|;
else|else
block|{
if|if
condition|(
name|q
condition|)
name|msg
argument_list|(
literal|"Missing filename after -C"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
comment|/* JF trivial support for -C option.  I don't know if 		   chdir'ing at this point is dangerous or not. 		   It seems to work, which is all I ask. */
if|if
condition|(
name|c
operator|&&
operator|!
name|q
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|q
operator|=
name|p
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|q
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Can't chdir to %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q
operator|=
literal|0
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
comment|/* End of JF quick -C hack */
if|if
condition|(
name|f_exclude
operator|&&
name|check_exclude
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|tryagain
goto|;
return|return
name|un_quote_string
argument_list|(
name|p
argument_list|)
return|;
block|}
while|while
condition|(
name|p
operator|=
name|fgets
argument_list|(
name|buffer
argument_list|,
name|buffer_siz
operator|+
literal|1
comment|/*nl*/
argument_list|,
name|namef
argument_list|)
condition|)
block|{
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/* Find the newline */
if|if
condition|(
name|q
operator|<=
name|p
condition|)
comment|/* Ignore empty lines */
continue|continue;
while|while
condition|(
name|q
operator|==
name|p
operator|+
name|buffer_siz
operator|&&
operator|*
name|q
operator|!=
literal|'\n'
condition|)
block|{
name|buffer
operator|=
name|ck_realloc
argument_list|(
name|buffer
argument_list|,
name|buffer_siz
operator|+
name|NAMSIZ
operator|+
literal|2
argument_list|)
expr_stmt|;
name|p
operator|=
name|buffer
expr_stmt|;
name|q
operator|=
name|buffer
operator|+
name|buffer_siz
expr_stmt|;
name|buffer_siz
operator|+=
name|NAMSIZ
expr_stmt|;
name|fgets
argument_list|(
name|q
operator|+
literal|1
argument_list|,
name|NAMSIZ
argument_list|,
name|namef
argument_list|)
expr_stmt|;
name|q
operator|=
name|p
operator|+
name|strlen
argument_list|(
name|p
argument_list|)
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|q
operator|--
operator|=
literal|'\0'
expr_stmt|;
comment|/* Zap the newline */
while|while
condition|(
name|q
operator|>
name|p
operator|&&
operator|*
name|q
operator|==
literal|'/'
condition|)
comment|/* Zap trailing /s */
operator|*
name|q
operator|--
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|c
operator|&&
operator|!
name|q2
operator|&&
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|q2
operator|=
name|p
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|q2
condition|)
block|{
if|if
condition|(
name|chdir
argument_list|(
name|p
argument_list|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"Can't chdir to %s"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|q2
operator|=
literal|0
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
if|if
condition|(
name|f_exclude
operator|&&
name|check_exclude
argument_list|(
name|p
argument_list|)
condition|)
goto|goto
name|tryagain
goto|;
return|return
name|un_quote_string
argument_list|(
name|p
argument_list|)
return|;
block|}
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * Close the name file, if any.  */
end_comment

begin_macro
name|name_close
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|namef
operator|!=
name|NULL
operator|&&
name|namef
operator|!=
name|stdin
condition|)
name|fclose
argument_list|(
name|namef
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Gather names in a list for scanning.  * Could hash them later if we really care.  *  * If the names are already sorted to match the archive, we just  * read them one by one.  name_gather reads the first one, and it  * is called by name_match as appropriate to read the next ones.  * At EOF, the last name read is just left in the buffer.  * This option lets users of small machines extract an arbitrary  * number of files by doing "tar t" and editing down the list of files.  */
end_comment

begin_macro
name|name_gather
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|static
name|struct
name|name
modifier|*
name|namebuf
decl_stmt|;
comment|/* One-name buffer */
specifier|static
name|namelen
expr_stmt|;
specifier|static
name|char
modifier|*
name|chdir_name
decl_stmt|;
if|if
condition|(
name|f_sorted_names
condition|)
block|{
if|if
condition|(
operator|!
name|namelen
condition|)
block|{
name|namelen
operator|=
name|NAMSIZ
expr_stmt|;
name|namebuf
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
operator|+
name|NAMSIZ
argument_list|)
expr_stmt|;
block|}
name|p
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|p
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|chdir_name
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|p
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
name|msg
argument_list|(
literal|"Missing file name after -C"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
name|namebuf
operator|->
name|change_dir
operator|=
name|chdir_name
expr_stmt|;
block|}
name|namebuf
operator|->
name|length
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|namebuf
operator|->
name|length
operator|>=
name|namelen
condition|)
block|{
name|namebuf
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|ck_realloc
argument_list|(
name|namebuf
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
operator|+
name|namebuf
operator|->
name|length
argument_list|)
expr_stmt|;
name|namelen
operator|=
name|namebuf
operator|->
name|length
expr_stmt|;
block|}
name|strncpy
argument_list|(
name|namebuf
operator|->
name|name
argument_list|,
name|p
argument_list|,
name|namebuf
operator|->
name|length
argument_list|)
expr_stmt|;
name|namebuf
operator|->
name|name
index|[
name|namebuf
operator|->
name|length
index|]
operator|=
literal|0
expr_stmt|;
name|namebuf
operator|->
name|next
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
name|namebuf
operator|->
name|found
operator|=
literal|0
expr_stmt|;
name|namelist
operator|=
name|namebuf
expr_stmt|;
name|namelast
operator|=
name|namelist
expr_stmt|;
block|}
return|return;
block|}
comment|/* Non sorted names -- read them all in */
while|while
condition|(
name|p
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
condition|)
name|addname
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Add a name to the namelist.  */
end_comment

begin_macro
name|addname
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to name */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* Length of string */
specifier|register
name|struct
name|name
modifier|*
name|p
decl_stmt|;
comment|/* Current struct pointer */
specifier|static
name|char
modifier|*
name|chdir_name
decl_stmt|;
name|char
modifier|*
name|new_name
parameter_list|()
function_decl|;
define|#
directive|define
name|MAXPATHLEN
value|1024
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|name
index|[
literal|1
index|]
operator|==
literal|'C'
operator|&&
name|name
index|[
literal|2
index|]
operator|==
literal|'\0'
condition|)
block|{
name|chdir_name
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|name
operator|=
name|name_next
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|chdir_name
condition|)
block|{
name|msg
argument_list|(
literal|"Missing file name after -C"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_ARGSBAD
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|chdir_name
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
block|{
name|char
name|path
index|[
name|MAXPATHLEN
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|USG
argument_list|)
name|int
name|getcwd
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|getcwd
argument_list|(
name|path
argument_list|,
name|MAXPATHLEN
argument_list|)
condition|)
name|msg
argument_list|(
literal|"Couldn't get current directory."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
if|if
condition|(
operator|!
name|getwd
argument_list|(
name|path
argument_list|)
condition|)
block|{
name|msg
argument_list|(
literal|"Couldn't get current directory: %s"
argument_list|,
name|path
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|chdir_name
operator|=
name|new_name
argument_list|(
name|path
argument_list|,
name|chdir_name
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|name
condition|)
block|{
name|i
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
comment|/*NOSTRICT*/
name|p
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|p
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|name
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|p
condition|)
block|{
if|if
condition|(
name|name
condition|)
name|msg
argument_list|(
literal|"cannot allocate mem for name '%s'."
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"cannot allocate mem for chdir record."
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|next
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|name
condition|)
block|{
name|p
operator|->
name|fake
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|length
operator|=
name|i
expr_stmt|;
name|strncpy
argument_list|(
name|p
operator|->
name|name
argument_list|,
name|name
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p
operator|->
name|name
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Null term */
block|}
else|else
name|p
operator|->
name|fake
operator|=
literal|1
expr_stmt|;
name|p
operator|->
name|found
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|regexp
operator|=
literal|0
expr_stmt|;
comment|/* Assume not a regular expression */
name|p
operator|->
name|firstch
operator|=
literal|1
expr_stmt|;
comment|/* Assume first char is literal */
name|p
operator|->
name|change_dir
operator|=
name|chdir_name
expr_stmt|;
name|p
operator|->
name|dir_contents
operator|=
literal|0
expr_stmt|;
comment|/* JF */
if|if
condition|(
name|name
condition|)
block|{
if|if
condition|(
name|index
argument_list|(
name|name
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|name
argument_list|,
literal|'['
argument_list|)
operator|||
name|index
argument_list|(
name|name
argument_list|,
literal|'?'
argument_list|)
condition|)
block|{
name|p
operator|->
name|regexp
operator|=
literal|1
expr_stmt|;
comment|/* No, it's a regexp */
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'*'
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'['
operator|||
name|name
index|[
literal|0
index|]
operator|==
literal|'?'
condition|)
name|p
operator|->
name|firstch
operator|=
literal|0
expr_stmt|;
comment|/* Not even 1st char literal */
block|}
block|}
if|if
condition|(
name|namelast
condition|)
name|namelast
operator|->
name|next
operator|=
name|p
expr_stmt|;
name|namelast
operator|=
name|p
expr_stmt|;
if|if
condition|(
operator|!
name|namelist
condition|)
name|namelist
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Match a name from an archive, p, with a name from the namelist.  */
end_comment

begin_expr_stmt
name|name_match
argument_list|(
name|p
argument_list|)
specifier|register
name|char
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|name
modifier|*
name|nlp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|again
label|:
if|if
condition|(
literal|0
operator|==
operator|(
name|nlp
operator|=
name|namelist
operator|)
condition|)
comment|/* Empty namelist is easy */
return|return
literal|1
return|;
if|if
condition|(
name|nlp
operator|->
name|fake
condition|)
block|{
if|if
condition|(
name|nlp
operator|->
name|change_dir
operator|&&
name|chdir
argument_list|(
name|nlp
operator|->
name|change_dir
argument_list|)
condition|)
name|msg_perror
argument_list|(
literal|"Can't change to directory %d"
argument_list|,
name|nlp
operator|->
name|change_dir
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
return|return
literal|1
return|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nlp
operator|!=
literal|0
condition|;
name|nlp
operator|=
name|nlp
operator|->
name|next
control|)
block|{
comment|/* If first chars don't match, quick skip */
if|if
condition|(
name|nlp
operator|->
name|firstch
operator|&&
name|nlp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|p
index|[
literal|0
index|]
condition|)
continue|continue;
comment|/* Regular expressions */
if|if
condition|(
name|nlp
operator|->
name|regexp
condition|)
block|{
if|if
condition|(
name|wildmat
argument_list|(
name|p
argument_list|,
name|nlp
operator|->
name|name
argument_list|)
condition|)
block|{
name|nlp
operator|->
name|found
operator|=
literal|1
expr_stmt|;
comment|/* Remember it matched */
if|if
condition|(
name|f_startfile
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nlp
operator|->
name|change_dir
operator|&&
name|chdir
argument_list|(
name|nlp
operator|->
name|change_dir
argument_list|)
condition|)
name|msg_perror
argument_list|(
literal|"Can't change to directory %s"
argument_list|,
name|nlp
operator|->
name|change_dir
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* We got a match */
block|}
continue|continue;
block|}
comment|/* Plain Old Strings */
if|if
condition|(
name|nlp
operator|->
name|length
operator|<=
name|len
comment|/* Archive len>= specified */
operator|&&
operator|(
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'/'
operator|)
comment|/* Full match on file/dirname */
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|nlp
operator|->
name|name
argument_list|,
name|nlp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
comment|/* Name compare */
block|{
name|nlp
operator|->
name|found
operator|=
literal|1
expr_stmt|;
comment|/* Remember it matched */
if|if
condition|(
name|f_startfile
condition|)
block|{
name|free
argument_list|(
operator|(
name|void
operator|*
operator|)
name|namelist
argument_list|)
expr_stmt|;
name|namelist
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|nlp
operator|->
name|change_dir
operator|&&
name|chdir
argument_list|(
name|nlp
operator|->
name|change_dir
argument_list|)
condition|)
name|msg_perror
argument_list|(
literal|"Can't change to directory %s"
argument_list|,
name|nlp
operator|->
name|change_dir
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
comment|/* We got a match */
block|}
block|}
comment|/* 	 * Filename from archive not found in namelist. 	 * If we have the whole namelist here, just return 0. 	 * Otherwise, read the next name in and compare it. 	 * If this was the last name, namelist->found will remain on. 	 * If not, we loop to compare the newly read name. 	 */
if|if
condition|(
name|f_sorted_names
operator|&&
name|namelist
operator|->
name|found
condition|)
block|{
name|name_gather
argument_list|()
expr_stmt|;
comment|/* Read one more */
if|if
condition|(
operator|!
name|namelist
operator|->
name|found
condition|)
goto|goto
name|again
goto|;
block|}
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * Print the names of things in the namelist that were not matched.  */
end_comment

begin_macro
name|names_notfound
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|name
modifier|*
name|nlp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|nlp
operator|=
name|namelist
init|;
name|nlp
operator|!=
literal|0
condition|;
name|nlp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|nlp
operator|->
name|next
expr_stmt|;
if|if
condition|(
operator|!
name|nlp
operator|->
name|found
condition|)
name|msg
argument_list|(
literal|"%s not found in archive"
argument_list|,
name|nlp
operator|->
name|name
argument_list|)
expr_stmt|;
comment|/* 		 * We could free() the list, but the process is about 		 * to die anyway, so save some CPU time.  Amigas and 		 * other similarly broken software will need to waste 		 * the time, though. 		 */
ifndef|#
directive|ifndef
name|unix
if|if
condition|(
operator|!
name|f_sorted_names
condition|)
name|free
argument_list|(
name|nlp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|namelist
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
name|namelast
operator|=
operator|(
expr|struct
name|name
operator|*
operator|)
name|NULL
expr_stmt|;
if|if
condition|(
name|f_sorted_names
condition|)
block|{
while|while
condition|(
literal|0
operator|!=
operator|(
name|p
operator|=
name|name_next
argument_list|(
literal|1
argument_list|)
operator|)
condition|)
name|msg
argument_list|(
literal|"%s not found in archive"
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* These next routines were created by JF */
end_comment

begin_macro
name|name_expand
argument_list|()
end_macro

begin_block
block|{
empty_stmt|;
block|}
end_block

begin_comment
comment|/* This is like name_match(), except that it returns a pointer to the name    it matched, and doesn't set ->found  The caller will have to do that    if it wants to.  Oh, and if the namelist is empty, it returns 0, unlike    name_match(), which returns TRUE */
end_comment

begin_function
name|struct
name|name
modifier|*
name|name_scan
parameter_list|(
name|p
parameter_list|)
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|name
modifier|*
name|nlp
decl_stmt|;
specifier|register
name|int
name|len
decl_stmt|;
name|again
label|:
if|if
condition|(
literal|0
operator|==
operator|(
name|nlp
operator|=
name|namelist
operator|)
condition|)
comment|/* Empty namelist is easy */
return|return
literal|0
return|;
name|len
operator|=
name|strlen
argument_list|(
name|p
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|nlp
operator|!=
literal|0
condition|;
name|nlp
operator|=
name|nlp
operator|->
name|next
control|)
block|{
comment|/* If first chars don't match, quick skip */
if|if
condition|(
name|nlp
operator|->
name|firstch
operator|&&
name|nlp
operator|->
name|name
index|[
literal|0
index|]
operator|!=
name|p
index|[
literal|0
index|]
condition|)
continue|continue;
comment|/* Regular expressions */
if|if
condition|(
name|nlp
operator|->
name|regexp
condition|)
block|{
if|if
condition|(
name|wildmat
argument_list|(
name|p
argument_list|,
name|nlp
operator|->
name|name
argument_list|)
condition|)
return|return
name|nlp
return|;
comment|/* We got a match */
continue|continue;
block|}
comment|/* Plain Old Strings */
if|if
condition|(
name|nlp
operator|->
name|length
operator|<=
name|len
comment|/* Archive len>= specified */
operator|&&
operator|(
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'\0'
operator|||
name|p
index|[
name|nlp
operator|->
name|length
index|]
operator|==
literal|'/'
operator|)
comment|/* Full match on file/dirname */
operator|&&
name|strncmp
argument_list|(
name|p
argument_list|,
name|nlp
operator|->
name|name
argument_list|,
name|nlp
operator|->
name|length
argument_list|)
operator|==
literal|0
condition|)
comment|/* Name compare */
return|return
name|nlp
return|;
comment|/* We got a match */
block|}
comment|/* 	 * Filename from archive not found in namelist. 	 * If we have the whole namelist here, just return 0. 	 * Otherwise, read the next name in and compare it. 	 * If this was the last name, namelist->found will remain on. 	 * If not, we loop to compare the newly read name. 	 */
if|if
condition|(
name|f_sorted_names
operator|&&
name|namelist
operator|->
name|found
condition|)
block|{
name|name_gather
argument_list|()
expr_stmt|;
comment|/* Read one more */
if|if
condition|(
operator|!
name|namelist
operator|->
name|found
condition|)
goto|goto
name|again
goto|;
block|}
return|return
operator|(
expr|struct
name|name
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This returns a name from the namelist which doesn't have ->found set.    It sets ->found before returning, so successive calls will find and return    all the non-found names in the namelist */
end_comment

begin_decl_stmt
name|struct
name|name
modifier|*
name|gnu_list_name
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|name_from_list
parameter_list|()
block|{
if|if
condition|(
operator|!
name|gnu_list_name
condition|)
name|gnu_list_name
operator|=
name|namelist
expr_stmt|;
while|while
condition|(
name|gnu_list_name
operator|&&
name|gnu_list_name
operator|->
name|found
condition|)
name|gnu_list_name
operator|=
name|gnu_list_name
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|gnu_list_name
condition|)
block|{
name|gnu_list_name
operator|->
name|found
operator|++
expr_stmt|;
if|if
condition|(
name|gnu_list_name
operator|->
name|change_dir
condition|)
if|if
condition|(
name|chdir
argument_list|(
name|gnu_list_name
operator|->
name|change_dir
argument_list|)
operator|<
literal|0
condition|)
name|msg_perror
argument_list|(
literal|"can't chdir to %s"
argument_list|,
name|gnu_list_name
operator|->
name|change_dir
argument_list|)
expr_stmt|;
return|return
name|gnu_list_name
operator|->
name|name
return|;
block|}
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_macro
name|blank_name_list
argument_list|()
end_macro

begin_block
block|{
name|struct
name|name
modifier|*
name|n
decl_stmt|;
name|gnu_list_name
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|n
operator|=
name|namelist
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|next
control|)
name|n
operator|->
name|found
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|new_name
parameter_list|(
name|path
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|path
decl_stmt|,
decl|*
name|name
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|path_buf
decl_stmt|;
name|path_buf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|path
argument_list|)
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|path_buf
operator|==
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't allocate memory for name '%s/%s"
argument_list|,
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|path_buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|path
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
name|path_buf
return|;
block|}
end_block

begin_comment
comment|/* returns non-zero if the luser typed 'y' or 'Y', zero otherwise. */
end_comment

begin_function
name|int
name|confirm
parameter_list|(
name|action
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|action
decl_stmt|,
decl|*
name|file
decl_stmt|;
end_function

begin_block
block|{
name|int
name|c
decl_stmt|,
name|nl
decl_stmt|;
specifier|static
name|FILE
modifier|*
name|confirm_file
init|=
literal|0
decl_stmt|;
specifier|extern
name|FILE
modifier|*
name|msg_file
decl_stmt|;
specifier|extern
name|char
name|TTY_NAME
index|[]
decl_stmt|;
name|fprintf
argument_list|(
name|msg_file
argument_list|,
literal|"%s %s?"
argument_list|,
name|action
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|msg_file
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|confirm_file
condition|)
block|{
name|confirm_file
operator|=
operator|(
name|archive
operator|==
literal|0
operator|)
condition|?
name|fopen
argument_list|(
name|TTY_NAME
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|confirm_file
condition|)
block|{
name|msg
argument_list|(
literal|"Can't read confirmation from user"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_SYSTEM
argument_list|)
expr_stmt|;
block|}
block|}
name|c
operator|=
name|getc
argument_list|(
name|confirm_file
argument_list|)
expr_stmt|;
for|for
control|(
name|nl
operator|=
name|c
init|;
name|nl
operator|!=
literal|'\n'
operator|&&
name|nl
operator|!=
name|EOF
condition|;
name|nl
operator|=
name|getc
argument_list|(
name|confirm_file
argument_list|)
control|)
empty_stmt|;
return|return
operator|(
name|c
operator|==
literal|'y'
operator|||
name|c
operator|==
literal|'Y'
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|x_buffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_x_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_x_buffer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|re_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size_re_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|free_re_exclude
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|add_exclude
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|rname
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp_ptr
decl_stmt|;
name|int
name|size_buf
decl_stmt|;
name|un_quote_string
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|size_buf
operator|=
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|x_buffer
operator|==
literal|0
condition|)
block|{
name|x_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_malloc
argument_list|(
name|size_buf
operator|+
literal|1024
argument_list|)
expr_stmt|;
name|free_x_buffer
operator|=
literal|1024
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|free_x_buffer
operator|<=
name|size_buf
condition|)
block|{
name|char
modifier|*
name|old_x_buffer
decl_stmt|;
name|char
modifier|*
modifier|*
name|tmp_ptr
decl_stmt|;
name|old_x_buffer
operator|=
name|x_buffer
expr_stmt|;
name|x_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|ck_realloc
argument_list|(
name|x_buffer
argument_list|,
name|size_x_buffer
operator|+
literal|1024
argument_list|)
expr_stmt|;
name|free_x_buffer
operator|=
literal|1024
expr_stmt|;
for|for
control|(
name|tmp_ptr
operator|=
name|exclude
init|;
name|tmp_ptr
operator|<
name|exclude
operator|+
name|size_exclude
condition|;
name|tmp_ptr
operator|++
control|)
operator|*
name|tmp_ptr
operator|=
name|x_buffer
operator|+
operator|(
operator|(
operator|*
name|tmp_ptr
operator|)
operator|-
name|old_x_buffer
operator|)
expr_stmt|;
for|for
control|(
name|tmp_ptr
operator|=
name|re_exclude
init|;
name|tmp_ptr
operator|<
name|re_exclude
operator|+
name|size_re_exclude
condition|;
name|tmp_ptr
operator|++
control|)
operator|*
name|tmp_ptr
operator|=
name|x_buffer
operator|+
operator|(
operator|(
operator|*
name|tmp_ptr
operator|)
operator|-
name|old_x_buffer
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|is_regex
argument_list|(
name|name
argument_list|)
condition|)
block|{
if|if
condition|(
name|free_re_exclude
operator|==
literal|0
condition|)
block|{
name|re_exclude
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|re_exclude
condition|?
name|ck_realloc
argument_list|(
name|re_exclude
argument_list|,
operator|(
name|size_re_exclude
operator|+
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
else|:
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
literal|32
argument_list|)
operator|)
expr_stmt|;
name|free_re_exclude
operator|+=
literal|32
expr_stmt|;
block|}
name|re_exclude
index|[
name|size_re_exclude
index|]
operator|=
name|x_buffer
operator|+
name|size_x_buffer
expr_stmt|;
name|size_re_exclude
operator|++
expr_stmt|;
name|free_re_exclude
operator|--
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|free_exclude
operator|==
literal|0
condition|)
block|{
name|exclude
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
operator|(
name|exclude
condition|?
name|ck_realloc
argument_list|(
name|exclude
argument_list|,
operator|(
name|size_exclude
operator|+
literal|32
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
else|:
name|ck_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
literal|32
argument_list|)
operator|)
expr_stmt|;
name|free_exclude
operator|+=
literal|32
expr_stmt|;
block|}
name|exclude
index|[
name|size_exclude
index|]
operator|=
name|x_buffer
operator|+
name|size_x_buffer
expr_stmt|;
name|size_exclude
operator|++
expr_stmt|;
name|free_exclude
operator|--
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|x_buffer
operator|+
name|size_x_buffer
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|size_x_buffer
operator|+=
name|size_buf
operator|+
literal|1
expr_stmt|;
name|free_x_buffer
operator|-=
name|size_buf
operator|+
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|add_exclude_file
argument_list|(
argument|file
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"-"
argument_list|)
condition|)
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
comment|/* Let's hope the person knows what they're doing. */
comment|/* Using -X - -T - -f - will get you *REALLY* strange 		   results. . . */
name|fp
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|msg_perror
argument_list|(
literal|"can't open %s"
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
literal|1024
argument_list|,
name|fp
argument_list|)
condition|)
block|{
name|int
name|size_buf
decl_stmt|;
name|char
modifier|*
name|end_str
decl_stmt|;
name|end_str
operator|=
name|rindex
argument_list|(
name|buf
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|end_str
condition|)
operator|*
name|end_str
operator|=
literal|'\0'
expr_stmt|;
name|add_exclude
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|is_regex
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
return|return
name|index
argument_list|(
name|str
argument_list|,
literal|'*'
argument_list|)
operator|||
name|index
argument_list|(
name|str
argument_list|,
literal|'['
argument_list|)
operator|||
name|index
argument_list|(
name|str
argument_list|,
literal|'?'
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* Returns non-zero if the file 'name' should not be added/extracted */
end_comment

begin_function
name|int
name|check_exclude
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
specifier|extern
name|char
modifier|*
name|strstr
parameter_list|()
function_decl|;
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size_re_exclude
condition|;
name|n
operator|++
control|)
block|{
if|if
condition|(
name|wildmat
argument_list|(
name|name
argument_list|,
name|re_exclude
index|[
name|n
index|]
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
name|size_exclude
condition|;
name|n
operator|++
control|)
block|{
comment|/* Accept the output from strstr only if it is the last 		   part of the string.  There is certainly a faster way to 		   do this. . . */
if|if
condition|(
operator|(
name|str
operator|=
name|strstr
argument_list|(
name|name
argument_list|,
name|exclude
index|[
name|n
index|]
argument_list|)
operator|)
operator|&&
operator|(
name|str
operator|==
name|name
operator|||
name|str
index|[
operator|-
literal|1
index|]
operator|==
literal|'/'
operator|)
operator|&&
name|str
index|[
name|strlen
argument_list|(
name|exclude
index|[
name|n
index|]
argument_list|)
index|]
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

end_unit

