begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***********************license start***************  * Copyright (c) 2003-2010  Cavium Inc. (support@cavium.com). All rights  * reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions are  * met:  *  *   * Redistributions of source code must retain the above copyright  *     notice, this list of conditions and the following disclaimer.  *  *   * Redistributions in binary form must reproduce the above  *     copyright notice, this list of conditions and the following  *     disclaimer in the documentation and/or other materials provided  *     with the distribution.   *   * Neither the name of Cavium Inc. nor the names of  *     its contributors may be used to endorse or promote products  *     derived from this software without specific prior written  *     permission.   * This Software, including technical data, may be subject to U.S. export  control  * laws, including the U.S. Export Administration Act and its  associated  * regulations, and may be subject to export or import  regulations in other  * countries.   * TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS"  * AND WITH ALL FAULTS AND CAVIUM INC. MAKES NO PROMISES, REPRESENTATIONS OR  * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO  * THE SOFTWARE, INCLUDING ITS CONDITION, ITS CONFORMITY TO ANY REPRESENTATION OR  * DESCRIPTION, OR THE EXISTENCE OF ANY LATENT OR PATENT DEFECTS, AND CAVIUM  * SPECIFICALLY DISCLAIMS ALL IMPLIED (IF ANY) WARRANTIES OF TITLE,  * MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, LACK OF  * VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION OR  * CORRESPONDENCE TO DESCRIPTION. THE ENTIRE  RISK ARISING OUT OF USE OR  * PERFORMANCE OF THE SOFTWARE LIES WITH YOU.  ***********************license end**************************************/
end_comment

begin_comment
comment|/**  * @file  *  * Support library for the ILK  *  *<hr>$Revision: 49448 $<hr>  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_include
include|#
directive|include
file|<linux/module.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-config.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-sysinfo.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-pko.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ilk.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-ilk-defs.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-util.h>
end_include

begin_include
include|#
directive|include
file|<asm/octeon/cvmx-helper-ilk.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|"cvmx.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-config.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-sysinfo.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-pko.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-ilk.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-util.h"
end_include

begin_include
include|#
directive|include
file|"cvmx-helper-ilk.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ENABLE_HELPER_FUNCTIONS
end_ifdef

begin_comment
comment|/*  * global configurations. to disable the 2nd ILK, set  * cvmx_ilk_lane_mask[CVMX_NUM_ILK_INTF] = {0xff, 0x0} and  * cvmx_ilk_chans[CVMX_NUM_ILK_INTF] = {8, 0}  */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|cvmx_ilk_lane_mask
index|[
name|CVMX_NUM_ILK_INTF
index|]
init|=
block|{
literal|0xf
block|,
literal|0xf0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|//#define SINGLE_PORT_SIM_ILK
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SINGLE_PORT_SIM_ILK
end_ifdef

begin_decl_stmt
name|unsigned
name|char
name|cvmx_ilk_chans
index|[
name|CVMX_NUM_ILK_INTF
index|]
init|=
block|{
literal|1
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|cvmx_ilk_chan_map
index|[
name|CVMX_NUM_ILK_INTF
index|]
index|[
name|CVMX_MAX_ILK_CHANS
index|]
init|=
block|{
block|{
literal|0
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* sample case */
end_comment

begin_decl_stmt
name|unsigned
name|char
name|cvmx_ilk_chans
index|[
name|CVMX_NUM_ILK_INTF
index|]
init|=
block|{
literal|8
block|,
literal|8
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|unsigned
name|char
name|cvmx_ilk_chan_map
index|[
name|CVMX_NUM_ILK_INTF
index|]
index|[
name|CVMX_MAX_ILK_CHANS
index|]
init|=
block|{
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
block|,
block|{
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Default callbacks, can be overridden  *  using cvmx_ilk_get_callbacks/cvmx_ilk_set_callbacks  */
end_comment

begin_decl_stmt
specifier|static
name|cvmx_ilk_callbacks_t
name|cvmx_ilk_callbacks
init|=
block|{
operator|.
name|calendar_setup_rx
operator|=
name|cvmx_ilk_cal_setup_rx
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|cvmx_ilk_intf_t
name|cvmx_ilk_intf_cfg
index|[
name|CVMX_NUM_ILK_INTF
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/**  * Get current ILK initialization callbacks  *  * @param callbacks  Pointer to the callbacks structure.to fill  *  * @return Pointer to cvmx_ilk_callbacks_t structure.  */
end_comment

begin_function
name|void
name|cvmx_ilk_get_callbacks
parameter_list|(
name|cvmx_ilk_callbacks_t
modifier|*
name|callbacks
parameter_list|)
block|{
name|memcpy
argument_list|(
name|callbacks
argument_list|,
operator|&
name|cvmx_ilk_callbacks
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_ilk_callbacks
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Set new ILK initialization callbacks  *  * @param new_callbacks  Pointer to an updated callbacks structure.  */
end_comment

begin_function
name|void
name|cvmx_ilk_set_callbacks
parameter_list|(
name|cvmx_ilk_callbacks_t
modifier|*
name|new_callbacks
parameter_list|)
block|{
name|memcpy
argument_list|(
operator|&
name|cvmx_ilk_callbacks
argument_list|,
name|new_callbacks
argument_list|,
sizeof|sizeof
argument_list|(
name|cvmx_ilk_callbacks
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/**  * Initialize and start the ILK interface.  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param lane_mask the lane group for this interface  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_start_interface
parameter_list|(
name|int
name|interface
parameter_list|,
name|unsigned
name|char
name|lane_mask
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|other_intf
decl_stmt|,
name|this_qlm
decl_stmt|,
name|other_qlm
decl_stmt|;
name|unsigned
name|char
name|uni_mask
decl_stmt|;
name|cvmx_mio_qlmx_cfg_t
name|mio_qlmx_cfg
decl_stmt|,
name|other_mio_qlmx_cfg
decl_stmt|;
name|cvmx_ilk_txx_cfg0_t
name|ilk_txx_cfg0
decl_stmt|;
name|cvmx_ilk_rxx_cfg0_t
name|ilk_rxx_cfg0
decl_stmt|;
name|cvmx_ilk_ser_cfg_t
name|ilk_ser_cfg
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
if|if
condition|(
name|lane_mask
operator|==
literal|0
condition|)
return|return
name|res
return|;
comment|/* check conflicts between 2 ilk interfaces. 1 lane can be assigned to 1      * interface only */
name|other_intf
operator|=
operator|!
name|interface
expr_stmt|;
name|this_qlm
operator|=
name|interface
operator|+
name|CVMX_ILK_QLM_BASE
expr_stmt|;
name|other_qlm
operator|=
name|other_intf
operator|+
name|CVMX_ILK_QLM_BASE
expr_stmt|;
if|if
condition|(
name|cvmx_ilk_intf_cfg
index|[
name|other_intf
index|]
operator|.
name|lane_en_mask
operator|&
name|lane_mask
condition|)
block|{
name|cvmx_dprintf
argument_list|(
literal|"ILK%d: %s: lane assignment conflict\n"
argument_list|,
name|interface
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* check the legality of the lane mask. interface 0 can have 8 lanes,      * while interface 1 can have 4 lanes at most */
name|uni_mask
operator|=
name|lane_mask
operator|>>
operator|(
name|interface
operator|*
literal|4
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|uni_mask
operator|!=
literal|0x1
operator|&&
name|uni_mask
operator|!=
literal|0x3
operator|&&
name|uni_mask
operator|!=
literal|0xf
operator|&&
name|uni_mask
operator|!=
literal|0xff
operator|)
operator|||
operator|(
name|interface
operator|==
literal|1
operator|&&
name|lane_mask
operator|>
literal|0xf0
operator|)
condition|)
block|{
if|#
directive|if
name|CVMX_ENABLE_DEBUG_PRINTS
name|cvmx_dprintf
argument_list|(
literal|"ILK%d: %s: incorrect lane mask: 0x%x \n"
argument_list|,
name|interface
argument_list|,
name|__FUNCTION__
argument_list|,
name|uni_mask
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
comment|/* check the availability of qlms. qlm_cfg = 001 means the chip is fused      * to give this qlm to ilk */
name|mio_qlmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_QLMX_CFG
argument_list|(
name|this_qlm
argument_list|)
argument_list|)
expr_stmt|;
name|other_mio_qlmx_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_MIO_QLMX_CFG
argument_list|(
name|other_qlm
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mio_qlmx_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|!=
literal|1
operator|||
operator|(
name|uni_mask
operator|==
literal|0xff
operator|&&
name|other_mio_qlmx_cfg
operator|.
name|s
operator|.
name|qlm_cfg
operator|!=
literal|1
operator|)
condition|)
block|{
if|#
directive|if
name|CVMX_ENABLE_DEBUG_PRINTS
name|cvmx_dprintf
argument_list|(
literal|"ILK%d: %s: qlm unavailable\n"
argument_list|,
name|interface
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
comment|/* power up the serdes */
name|ilk_ser_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_SER_CFG
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_ser_cfg
operator|.
name|s
operator|.
name|ser_pwrup
operator|==
literal|0
condition|)
block|{
name|ilk_ser_cfg
operator|.
name|s
operator|.
name|ser_rxpol_auto
operator|=
literal|1
expr_stmt|;
name|ilk_ser_cfg
operator|.
name|s
operator|.
name|ser_rxpol
operator|=
literal|0
expr_stmt|;
name|ilk_ser_cfg
operator|.
name|s
operator|.
name|ser_txpol
operator|=
literal|0
expr_stmt|;
name|ilk_ser_cfg
operator|.
name|s
operator|.
name|ser_reset_n
operator|=
literal|0xff
expr_stmt|;
name|ilk_ser_cfg
operator|.
name|s
operator|.
name|ser_haul
operator|=
literal|0
expr_stmt|;
block|}
name|ilk_ser_cfg
operator|.
name|s
operator|.
name|ser_pwrup
operator||=
operator|(
operator|(
name|interface
operator|==
literal|0
operator|)
operator|&&
operator|(
name|lane_mask
operator|>
literal|0xf
operator|)
operator|)
condition|?
literal|0x3
else|:
operator|(
literal|1
operator|<<
name|interface
operator|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_SER_CFG
argument_list|,
name|ilk_ser_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* configure the lane enable of the interface */
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|lane_ena
operator|=
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|lane_ena
operator|=
name|lane_mask
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* write to local cache. for lane speed, if interface 0 has 8 lanes,      * assume both qlms have the same speed */
name|cvmx_ilk_intf_cfg
index|[
name|interface
index|]
operator|.
name|intf_en
operator|=
literal|1
expr_stmt|;
name|cvmx_ilk_intf_cfg
index|[
name|interface
index|]
operator|.
name|lane_en_mask
operator|=
name|lane_mask
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * set pipe group base and length for the interface  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param pipe_base the base of the pipe group  * @param pipe_len  the length of the pipe group  *   * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_set_pipe
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|pipe_base
parameter_list|,
name|unsigned
name|int
name|pipe_len
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_txx_pipe_t
name|ilk_txx_pipe
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
comment|/* base should be between 0 and 127. base + length should be<127 */
if|if
condition|(
operator|!
operator|(
name|pipe_base
operator|>=
literal|0
operator|&&
name|pipe_base
operator|<=
literal|127
operator|)
operator|||
operator|(
name|pipe_base
operator|+
name|pipe_len
operator|>
literal|127
operator|)
condition|)
block|{
if|#
directive|if
name|CVMX_ENABLE_DEBUG_PRINTS
name|cvmx_dprintf
argument_list|(
literal|"ILK%d: %s: pipe base/length out of bounds\n"
argument_list|,
name|interface
argument_list|,
name|__FUNCTION__
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|res
return|;
block|}
comment|/* set them in ilk tx section */
name|ilk_txx_pipe
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_PIPE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_pipe
operator|.
name|s
operator|.
name|base
operator|=
name|pipe_base
expr_stmt|;
name|ilk_txx_pipe
operator|.
name|s
operator|.
name|nump
operator|=
name|pipe_len
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_PIPE
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_pipe
operator|.
name|u64
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * set logical channels for tx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param pch     pointer to an array of pipe-channel pair  * @param num_chs the number of entries in the pipe-channel array  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_tx_set_channel
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_ilk_pipe_chan_t
modifier|*
name|pch
parameter_list|,
name|unsigned
name|int
name|num_chs
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_txx_idx_pmap_t
name|ilk_txx_idx_pmap
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
if|if
condition|(
name|pch
operator|==
name|NULL
operator|||
name|num_chs
operator|>
name|CVMX_MAX_ILK_PIPES
condition|)
return|return
name|res
return|;
comment|/* write the pair to ilk tx */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_chs
condition|;
name|i
operator|++
control|)
block|{
name|ilk_txx_idx_pmap
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_pmap
operator|.
name|s
operator|.
name|index
operator|=
name|pch
operator|->
name|pipe
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_PMAP
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_pmap
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_PMAP
argument_list|(
name|interface
argument_list|)
argument_list|,
name|pch
operator|->
name|chan
argument_list|)
expr_stmt|;
name|pch
operator|++
expr_stmt|;
block|}
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * set pkind for rx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param chpknd    pointer to an array of channel-pkind pair  * @param num_pknd the number of entries in the channel-pkind array  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_rx_set_pknd
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_ilk_chan_pknd_t
modifier|*
name|chpknd
parameter_list|,
name|unsigned
name|int
name|num_pknd
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_rxf_idx_pmap_t
name|ilk_rxf_idx_pmap
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
if|if
condition|(
name|chpknd
operator|==
name|NULL
operator|||
name|num_pknd
operator|>
name|CVMX_MAX_ILK_PKNDS
condition|)
return|return
name|res
return|;
comment|/* write the pair to ilk rx. note the channels for different interfaces      * are given in *chpknd and interface is not used as a param */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_pknd
condition|;
name|i
operator|++
control|)
block|{
name|ilk_rxf_idx_pmap
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxf_idx_pmap
operator|.
name|s
operator|.
name|index
operator|=
name|interface
operator|*
literal|256
operator|+
name|chpknd
operator|->
name|chan
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXF_IDX_PMAP
argument_list|,
name|ilk_rxf_idx_pmap
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXF_MEM_PMAP
argument_list|,
name|chpknd
operator|->
name|pknd
argument_list|)
expr_stmt|;
name|chpknd
operator|++
expr_stmt|;
block|}
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * configure calendar for rx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param cal_depth the number of calendar entries  * @param pent      pointer to calendar entries  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_rx_cal_conf
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|cal_depth
parameter_list|,
name|cvmx_ilk_cal_entry_t
modifier|*
name|pent
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|,
name|num_grp
decl_stmt|,
name|num_rest
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cvmx_ilk_rxx_cfg0_t
name|ilk_rxx_cfg0
decl_stmt|;
name|cvmx_ilk_rxx_idx_cal_t
name|ilk_rxx_idx_cal
decl_stmt|;
name|cvmx_ilk_rxx_mem_cal0_t
name|ilk_rxx_mem_cal0
decl_stmt|;
name|cvmx_ilk_rxx_mem_cal1_t
name|ilk_rxx_mem_cal1
decl_stmt|;
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
if|if
condition|(
name|cal_depth
operator|<
name|CVMX_ILK_RX_MIN_CAL
operator|||
name|cal_depth
operator|>
name|CVMX_ILK_MAX_CAL
operator|||
name|pent
operator|==
name|NULL
condition|)
return|return
name|res
return|;
comment|/* mandatory link-level fc as workarounds for ILK-15397 and ILK-15479 */
comment|/* TODO: test effectiveness */
if|#
directive|if
literal|0
block|if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_0)&& pent->ent_ctrl == PIPE_BPID)         for (i = 0; i< cal_depth; i++)             pent->ent_ctrl = LINK;
endif|#
directive|endif
comment|/* set the depth */
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|cal_depth
operator|=
name|cal_depth
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* set the calendar index */
name|num_grp
operator|=
name|cal_depth
operator|/
name|CVMX_ILK_CAL_GRP_SZ
expr_stmt|;
name|num_rest
operator|=
name|cal_depth
operator|%
name|CVMX_ILK_CAL_GRP_SZ
expr_stmt|;
name|ilk_rxx_idx_cal
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxx_idx_cal
operator|.
name|s
operator|.
name|inc
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_IDX_CAL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_idx_cal
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* set the calendar entries. each group has both cal0 and cal1 registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_grp
condition|;
name|i
operator|++
control|)
block|{
name|ilk_rxx_mem_cal0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|pipe_bpid
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_PIPE_BPID_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
expr_stmt|;
name|ilk_rxx_mem_cal0
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|ent_ctrl
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
operator|+
name|CVMX_ILK_PIPE_BPID_SZ
expr_stmt|;
name|ilk_rxx_mem_cal0
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|pent
operator|++
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_CAL0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_mem_cal0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_mem_cal1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|pipe_bpid
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_PIPE_BPID_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
expr_stmt|;
name|ilk_rxx_mem_cal1
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|ent_ctrl
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
operator|+
name|CVMX_ILK_PIPE_BPID_SZ
expr_stmt|;
name|ilk_rxx_mem_cal1
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|pent
operator|++
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_CAL1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_mem_cal1
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
comment|/* set the calendar entries, the fraction of a group. but both cal0 and      * cal1 must be written */
name|ilk_rxx_mem_cal0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxx_mem_cal1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_rest
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|<
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|pipe_bpid
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_PIPE_BPID_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|i
expr_stmt|;
name|ilk_rxx_mem_cal0
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|ent_ctrl
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|i
operator|+
name|CVMX_ILK_PIPE_BPID_SZ
expr_stmt|;
name|ilk_rxx_mem_cal0
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|pent
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
condition|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|pipe_bpid
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_PIPE_BPID_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
operator|(
name|i
operator|-
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
operator|)
expr_stmt|;
name|ilk_rxx_mem_cal1
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|ent_ctrl
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
operator|(
name|i
operator|-
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
operator|)
operator|+
name|CVMX_ILK_PIPE_BPID_SZ
expr_stmt|;
name|ilk_rxx_mem_cal1
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|pent
operator|++
expr_stmt|;
block|}
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_CAL0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_mem_cal0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_CAL1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_mem_cal1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_CAL1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * set high water mark for rx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param hi_wm     high water mark for this interface  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_rx_set_hwm
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|hi_wm
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_rxx_cfg1_t
name|ilk_rxx_cfg1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
if|if
condition|(
name|hi_wm
operator|<=
literal|0
condition|)
return|return
name|res
return|;
comment|/* set the hwm */
name|ilk_rxx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg1
operator|.
name|s
operator|.
name|rx_fifo_hwm
operator|=
name|hi_wm
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * enable calendar for rx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param cal_ena   enable or disable calendar  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_rx_cal_ena
parameter_list|(
name|int
name|interface
parameter_list|,
name|unsigned
name|char
name|cal_ena
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_rxx_cfg0_t
name|ilk_rxx_cfg0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
comment|/* set the enable */
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|cal_ena
operator|=
name|cal_ena
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * set up calendar for rx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param cal_depth the number of calendar entries  * @param pent      pointer to calendar entries  * @param hi_wm     high water mark for this interface  * @param cal_ena   enable or disable calendar  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_cal_setup_rx
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|cal_depth
parameter_list|,
name|cvmx_ilk_cal_entry_t
modifier|*
name|pent
parameter_list|,
name|int
name|hi_wm
parameter_list|,
name|unsigned
name|char
name|cal_ena
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
name|res
operator|=
name|cvmx_ilk_rx_cal_conf
argument_list|(
name|interface
argument_list|,
name|cal_depth
argument_list|,
name|pent
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
name|res
return|;
name|res
operator|=
name|cvmx_ilk_rx_set_hwm
argument_list|(
name|interface
argument_list|,
name|hi_wm
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
name|res
return|;
name|res
operator|=
name|cvmx_ilk_rx_cal_ena
argument_list|(
name|interface
argument_list|,
name|cal_ena
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_ilk_cal_setup_rx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * configure calendar for tx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param cal_depth the number of calendar entries  * @param pent      pointer to calendar entries  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_tx_cal_conf
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|cal_depth
parameter_list|,
name|cvmx_ilk_cal_entry_t
modifier|*
name|pent
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|,
name|num_grp
decl_stmt|,
name|num_rest
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|cvmx_ilk_txx_cfg0_t
name|ilk_txx_cfg0
decl_stmt|;
name|cvmx_ilk_txx_idx_cal_t
name|ilk_txx_idx_cal
decl_stmt|;
name|cvmx_ilk_txx_mem_cal0_t
name|ilk_txx_mem_cal0
decl_stmt|;
name|cvmx_ilk_txx_mem_cal1_t
name|ilk_txx_mem_cal1
decl_stmt|;
name|unsigned
name|long
name|int
name|tmp
decl_stmt|;
name|cvmx_ilk_cal_entry_t
modifier|*
name|ent_tmp
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
if|if
condition|(
name|cal_depth
operator|<
name|CVMX_ILK_TX_MIN_CAL
operator|||
name|cal_depth
operator|>
name|CVMX_ILK_MAX_CAL
operator|||
name|pent
operator|==
name|NULL
condition|)
return|return
name|res
return|;
comment|/* mandatory link-level fc as workarounds for ILK-15397 and ILK-15479 */
comment|/* TODO: test effectiveness */
if|#
directive|if
literal|0
block|if (OCTEON_IS_MODEL(OCTEON_CN68XX_PASS1_0)&& pent->ent_ctrl == PIPE_BPID)         for (i = 0; i< cal_depth; i++)             pent->ent_ctrl = LINK;
endif|#
directive|endif
comment|/* tx calendar depth must be a multiple of 8 */
name|num_grp
operator|=
operator|(
name|cal_depth
operator|-
literal|1
operator|)
operator|/
name|CVMX_ILK_CAL_GRP_SZ
operator|+
literal|1
expr_stmt|;
name|num_rest
operator|=
name|cal_depth
operator|%
name|CVMX_ILK_CAL_GRP_SZ
expr_stmt|;
if|if
condition|(
name|num_rest
operator|!=
literal|0
condition|)
block|{
name|ent_tmp
operator|=
name|pent
operator|+
name|cal_depth
expr_stmt|;
for|for
control|(
name|i
operator|=
name|num_rest
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
operator|,
name|ent_tmp
operator|++
control|)
block|{
name|ent_tmp
operator|->
name|pipe_bpid
operator|=
literal|0
expr_stmt|;
name|ent_tmp
operator|->
name|ent_ctrl
operator|=
name|XOFF
expr_stmt|;
block|}
block|}
name|cal_depth
operator|=
name|num_grp
operator|*
literal|8
expr_stmt|;
comment|/* set the depth */
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|cal_depth
operator|=
name|cal_depth
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* set the calendar index */
name|ilk_txx_idx_cal
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_cal
operator|.
name|s
operator|.
name|inc
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_CAL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_cal
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* set the calendar entries. each group has both cal0 and cal1 registers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|num_grp
condition|;
name|i
operator|++
control|)
block|{
name|ilk_txx_mem_cal0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|pipe_bpid
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_PIPE_BPID_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
expr_stmt|;
name|ilk_txx_mem_cal0
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|ent_ctrl
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
operator|+
name|CVMX_ILK_PIPE_BPID_SZ
expr_stmt|;
name|ilk_txx_mem_cal0
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|pent
operator|++
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_CAL0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_mem_cal0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_mem_cal1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|CVMX_ILK_CAL_GRP_SZ
operator|/
literal|2
condition|;
name|j
operator|++
control|)
block|{
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|pipe_bpid
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_PIPE_BPID_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
expr_stmt|;
name|ilk_txx_mem_cal1
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|tmp
operator|=
literal|0
expr_stmt|;
name|tmp
operator|=
name|pent
operator|->
name|ent_ctrl
operator|&
operator|~
operator|(
operator|~
name|tmp
operator|<<
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
expr_stmt|;
name|tmp
operator|<<=
operator|(
name|CVMX_ILK_PIPE_BPID_SZ
operator|+
name|CVMX_ILK_ENT_CTRL_SZ
operator|)
operator|*
name|j
operator|+
name|CVMX_ILK_PIPE_BPID_SZ
expr_stmt|;
name|ilk_txx_mem_cal1
operator|.
name|u64
operator||=
name|tmp
expr_stmt|;
name|pent
operator|++
expr_stmt|;
block|}
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_CAL1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_mem_cal1
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_CAL1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * configure backpressure for tx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param cal_depth the number of calendar entries  * @param pent      pointer to calendar entries  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_bp_conf
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|cal_depth
parameter_list|,
name|cvmx_ilk_cal_entry_t
modifier|*
name|pent
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|,
name|i
decl_stmt|;
name|cvmx_ipd_ctl_status_t
name|ipd_ctl_status
decl_stmt|;
name|cvmx_ilk_cal_entry_t
modifier|*
name|tmp
decl_stmt|;
name|unsigned
name|char
name|bpid
decl_stmt|;
name|cvmx_ipd_bpidx_mbuf_th_t
name|ipd_bpidx_mbuf_th
decl_stmt|;
comment|/* enable bp for the interface */
name|ipd_ctl_status
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_CTL_STATUS
argument_list|)
expr_stmt|;
name|ipd_ctl_status
operator|.
name|s
operator|.
name|pbp_en
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_CTL_STATUS
argument_list|,
name|ipd_ctl_status
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* enable bp for each id */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|tmp
operator|=
name|pent
init|;
name|i
operator|<
name|cal_depth
condition|;
name|i
operator|++
operator|,
name|tmp
operator|++
control|)
block|{
name|bpid
operator|=
name|tmp
operator|->
name|pipe_bpid
expr_stmt|;
name|ipd_bpidx_mbuf_th
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_IPD_BPIDX_MBUF_TH
argument_list|(
name|bpid
argument_list|)
argument_list|)
expr_stmt|;
name|ipd_bpidx_mbuf_th
operator|.
name|s
operator|.
name|page_cnt
operator|=
literal|1
expr_stmt|;
comment|/* 256 buffers */
name|ipd_bpidx_mbuf_th
operator|.
name|s
operator|.
name|bp_enb
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_IPD_BPIDX_MBUF_TH
argument_list|(
name|bpid
argument_list|)
argument_list|,
name|ipd_bpidx_mbuf_th
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * enable calendar for tx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param cal_ena   enable or disable calendar  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_tx_cal_ena
parameter_list|(
name|int
name|interface
parameter_list|,
name|unsigned
name|char
name|cal_ena
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_txx_cfg0_t
name|ilk_txx_cfg0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
comment|/* set the enable */
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|cal_ena
operator|=
name|cal_ena
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_comment
comment|/**  * set up calendar for tx  *  * @param interface The identifier of the packet interface to configure and  *                  use as a ILK interface. cn68xx has 2 interfaces: ilk0 and  *                  ilk1.  *  * @param cal_depth the number of calendar entries  * @param pent      pointer to calendar entries  * @param cal_ena   enable or disable calendar  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_cal_setup_tx
parameter_list|(
name|int
name|interface
parameter_list|,
name|int
name|cal_depth
parameter_list|,
name|cvmx_ilk_cal_entry_t
modifier|*
name|pent
parameter_list|,
name|unsigned
name|char
name|cal_ena
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
name|res
operator|=
name|cvmx_ilk_tx_cal_conf
argument_list|(
name|interface
argument_list|,
name|cal_depth
argument_list|,
name|pent
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
name|res
return|;
ifdef|#
directive|ifdef
name|CVMX_ILK_BP_CONF_ENA
name|res
operator|=
name|cvmx_ilk_bp_conf
argument_list|(
name|interface
argument_list|,
name|cal_depth
argument_list|,
name|pent
argument_list|)
expr_stmt|;
if|if
condition|(
name|res
operator|<
literal|0
condition|)
return|return
name|res
return|;
endif|#
directive|endif
name|res
operator|=
name|cvmx_ilk_tx_cal_ena
argument_list|(
name|interface
argument_list|,
name|cal_ena
argument_list|)
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_BUILD_FOR_LINUX_KERNEL
end_ifdef

begin_expr_stmt
name|EXPORT_SYMBOL
argument_list|(
name|cvmx_ilk_cal_setup_tx
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ILK_STATS_ENA
end_ifdef

begin_function
specifier|static
name|void
name|cvmx_ilk_reg_dump_rx
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_ilk_rxx_cfg0_t
name|ilk_rxx_cfg0
decl_stmt|;
name|cvmx_ilk_rxx_cfg1_t
name|ilk_rxx_cfg1
decl_stmt|;
name|cvmx_ilk_rxx_int_t
name|ilk_rxx_int
decl_stmt|;
name|cvmx_ilk_rxx_jabber_t
name|ilk_rxx_jabber
decl_stmt|;
name|cvmx_ilk_rx_lnex_cfg_t
name|ilk_rx_lnex_cfg
decl_stmt|;
name|cvmx_ilk_rx_lnex_int_t
name|ilk_rx_lnex_int
decl_stmt|;
name|cvmx_ilk_gbl_cfg_t
name|ilk_gbl_cfg
decl_stmt|;
name|cvmx_ilk_ser_cfg_t
name|ilk_ser_cfg
decl_stmt|;
name|cvmx_ilk_rxf_idx_pmap_t
name|ilk_rxf_idx_pmap
decl_stmt|;
name|cvmx_ilk_rxf_mem_pmap_t
name|ilk_rxf_mem_pmap
decl_stmt|;
name|cvmx_ilk_rxx_idx_cal_t
name|ilk_rxx_idx_cal
decl_stmt|;
name|cvmx_ilk_rxx_mem_cal0_t
name|ilk_rxx_mem_cal0
decl_stmt|;
name|cvmx_ilk_rxx_mem_cal1_t
name|ilk_rxx_mem_cal1
decl_stmt|;
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxx cfg0: 0x%16lx\n"
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxx cfg1: 0x%16lx\n"
argument_list|,
name|ilk_rxx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_int
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_INT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxx int: 0x%16lx\n"
argument_list|,
name|ilk_rxx_int
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_INT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_int
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_jabber
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_JABBER
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxx jabber: 0x%16lx\n"
argument_list|,
name|ilk_rxx_jabber
operator|.
name|u64
argument_list|)
expr_stmt|;
define|#
directive|define
name|LNE_NUM_DBG
value|4
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LNE_NUM_DBG
condition|;
name|i
operator|++
control|)
block|{
name|ilk_rx_lnex_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RX_LNEX_CFG
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rx lnex cfg lane: %d  0x%16lx\n"
argument_list|,
name|i
argument_list|,
name|ilk_rx_lnex_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|LNE_NUM_DBG
condition|;
name|i
operator|++
control|)
block|{
name|ilk_rx_lnex_int
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RX_LNEX_INT
argument_list|(
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rx lnex int lane: %d  0x%16lx\n"
argument_list|,
name|i
argument_list|,
name|ilk_rx_lnex_int
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RX_LNEX_INT
argument_list|(
name|i
argument_list|)
argument_list|,
name|ilk_rx_lnex_int
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|ilk_gbl_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_GBL_CFG
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk gbl cfg: 0x%16lx\n"
argument_list|,
name|ilk_gbl_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_ser_cfg
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_SER_CFG
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk ser cfg: 0x%16lx\n"
argument_list|,
name|ilk_ser_cfg
operator|.
name|u64
argument_list|)
expr_stmt|;
define|#
directive|define
name|CHAN_NUM_DBG
value|8
name|ilk_rxf_idx_pmap
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxf_idx_pmap
operator|.
name|s
operator|.
name|index
operator|=
name|interface
operator|*
literal|256
expr_stmt|;
name|ilk_rxf_idx_pmap
operator|.
name|s
operator|.
name|inc
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXF_IDX_PMAP
argument_list|,
name|ilk_rxf_idx_pmap
operator|.
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHAN_NUM_DBG
condition|;
name|i
operator|++
control|)
block|{
name|ilk_rxf_mem_pmap
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXF_MEM_PMAP
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxf mem pmap chan: %3d  0x%16lx\n"
argument_list|,
name|i
argument_list|,
name|ilk_rxf_mem_pmap
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
define|#
directive|define
name|CAL_NUM_DBG
value|2
name|ilk_rxx_idx_cal
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxx_idx_cal
operator|.
name|s
operator|.
name|inc
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_IDX_CAL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_idx_cal
operator|.
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAL_NUM_DBG
condition|;
name|i
operator|++
control|)
block|{
name|ilk_rxx_idx_cal
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_IDX_CAL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxx idx cal: 0x%16lx\n"
argument_list|,
name|ilk_rxx_idx_cal
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_mem_cal0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_CAL0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxx mem cal0: 0x%16lx\n"
argument_list|,
name|ilk_rxx_mem_cal0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_mem_cal1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_CAL1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk rxx mem cal1: 0x%16lx\n"
argument_list|,
name|ilk_rxx_mem_cal1
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|cvmx_ilk_reg_dump_tx
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|cvmx_ilk_txx_cfg0_t
name|ilk_txx_cfg0
decl_stmt|;
name|cvmx_ilk_txx_cfg1_t
name|ilk_txx_cfg1
decl_stmt|;
name|cvmx_ilk_txx_idx_pmap_t
name|ilk_txx_idx_pmap
decl_stmt|;
name|cvmx_ilk_txx_mem_pmap_t
name|ilk_txx_mem_pmap
decl_stmt|;
name|cvmx_ilk_txx_int_t
name|ilk_txx_int
decl_stmt|;
name|cvmx_ilk_txx_pipe_t
name|ilk_txx_pipe
decl_stmt|;
name|cvmx_ilk_txx_idx_cal_t
name|ilk_txx_idx_cal
decl_stmt|;
name|cvmx_ilk_txx_mem_cal0_t
name|ilk_txx_mem_cal0
decl_stmt|;
name|cvmx_ilk_txx_mem_cal1_t
name|ilk_txx_mem_cal1
decl_stmt|;
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx cfg0: 0x%16lx\n"
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx cfg1: 0x%16lx\n"
argument_list|,
name|ilk_txx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_pipe
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_PIPE
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx pipe: 0x%16lx\n"
argument_list|,
name|ilk_txx_pipe
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_idx_pmap
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_pmap
operator|.
name|s
operator|.
name|index
operator|=
name|ilk_txx_pipe
operator|.
name|s
operator|.
name|base
expr_stmt|;
name|ilk_txx_idx_pmap
operator|.
name|s
operator|.
name|inc
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_PMAP
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_pmap
operator|.
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CHAN_NUM_DBG
condition|;
name|i
operator|++
control|)
block|{
name|ilk_txx_mem_pmap
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_PMAP
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx mem pmap pipe: %3d  0x%16lx\n"
argument_list|,
name|ilk_txx_pipe
operator|.
name|s
operator|.
name|base
operator|+
name|i
argument_list|,
name|ilk_txx_mem_pmap
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|ilk_txx_int
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_INT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx int: 0x%16lx\n"
argument_list|,
name|ilk_txx_int
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_idx_cal
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_cal
operator|.
name|s
operator|.
name|inc
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_CAL
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_cal
operator|.
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|CAL_NUM_DBG
condition|;
name|i
operator|++
control|)
block|{
name|ilk_txx_idx_cal
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_CAL
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx idx cal: 0x%16lx\n"
argument_list|,
name|ilk_txx_idx_cal
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_mem_cal0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_CAL0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx mem cal0: 0x%16lx\n"
argument_list|,
name|ilk_txx_mem_cal0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_mem_cal1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_CAL1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ilk txx mem cal1: 0x%16lx\n"
argument_list|,
name|ilk_txx_mem_cal1
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * show run time status  *  * @param interface The identifier of the packet interface to enable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  *  * @return nothing  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CVMX_ILK_RUNTIME_DBG
end_ifdef

begin_function
name|void
name|cvmx_ilk_runtime_status
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|cvmx_ilk_txx_cfg1_t
name|ilk_txx_cfg1
decl_stmt|;
name|cvmx_ilk_txx_flow_ctl0_t
name|ilk_txx_flow_ctl0
decl_stmt|;
name|cvmx_ilk_rxx_cfg1_t
name|ilk_rxx_cfg1
decl_stmt|;
name|cvmx_ilk_rxx_int_t
name|ilk_rxx_int
decl_stmt|;
name|cvmx_ilk_rxx_flow_ctl0_t
name|ilk_rxx_flow_ctl0
decl_stmt|;
name|cvmx_ilk_rxx_flow_ctl1_t
name|ilk_rxx_flow_ctl1
decl_stmt|;
name|cvmx_ilk_gbl_int_t
name|ilk_gbl_int
decl_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk run-time status: interface: %d\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|ilk_txx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk txx cfg1: 0x%16lx\n"
argument_list|,
name|ilk_txx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_txx_cfg1
operator|.
name|s
operator|.
name|rx_link_fc
condition|)
name|cvmx_dprintf
argument_list|(
literal|"link flow control received\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_txx_cfg1
operator|.
name|s
operator|.
name|tx_link_fc
condition|)
name|cvmx_dprintf
argument_list|(
literal|"link flow control sent\n"
argument_list|)
expr_stmt|;
name|ilk_txx_flow_ctl0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_FLOW_CTL0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk txx flow ctl0: 0x%16lx\n"
argument_list|,
name|ilk_txx_flow_ctl0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk rxx cfg1: 0x%16lx\n"
argument_list|,
name|ilk_rxx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"rx fifo count: %d\n"
argument_list|,
name|ilk_rxx_cfg1
operator|.
name|s
operator|.
name|rx_fifo_cnt
argument_list|)
expr_stmt|;
name|ilk_rxx_int
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_INT
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk rxx int: 0x%16lx\n"
argument_list|,
name|ilk_rxx_int
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_rxx_int
operator|.
name|s
operator|.
name|pkt_drop_rxf
condition|)
name|cvmx_dprintf
argument_list|(
literal|"rx fifo packet drop\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_rxx_int
operator|.
name|u64
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_INT
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_int
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_flow_ctl0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_FLOW_CTL0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk rxx flow ctl0: 0x%16lx\n"
argument_list|,
name|ilk_rxx_flow_ctl0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_flow_ctl1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_FLOW_CTL1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk rxx flow ctl1: 0x%16lx\n"
argument_list|,
name|ilk_rxx_flow_ctl1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_gbl_int
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_GBL_INT
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"\nilk gbl int: 0x%16lx\n"
argument_list|,
name|ilk_gbl_int
operator|.
name|u64
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_gbl_int
operator|.
name|s
operator|.
name|rxf_push_full
condition|)
name|cvmx_dprintf
argument_list|(
literal|"rx fifo overflow\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_gbl_int
operator|.
name|u64
condition|)
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_GBL_INT
argument_list|,
name|ilk_gbl_int
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**  * enable interface  *  * @param interface The identifier of the packet interface to enable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  *  * @return Zero on success, negative of failure.  */
end_comment

begin_comment
comment|//#define CVMX_ILK_STATS_ENA 1
end_comment

begin_function
name|int
name|cvmx_ilk_enable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|retry_count
init|=
literal|0
decl_stmt|;
name|cvmx_helper_link_info_t
name|result
decl_stmt|;
name|cvmx_ilk_txx_cfg1_t
name|ilk_txx_cfg1
decl_stmt|;
name|cvmx_ilk_rxx_cfg1_t
name|ilk_rxx_cfg1
decl_stmt|;
ifdef|#
directive|ifdef
name|CVMX_ILK_STATS_ENA
name|cvmx_ilk_rxx_cfg0_t
name|ilk_rxx_cfg0
decl_stmt|;
name|cvmx_ilk_txx_cfg0_t
name|ilk_txx_cfg0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
name|result
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_ILK_STATS_ENA
name|cvmx_dprintf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"<<<< ILK%d: Before enabling ilk\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|cvmx_ilk_reg_dump_rx
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|cvmx_ilk_reg_dump_tx
argument_list|(
name|interface
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* RX packet will be enabled only if link is up */
comment|/* TX side */
name|ilk_txx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg1
operator|.
name|s
operator|.
name|pkt_ena
operator|=
literal|1
expr_stmt|;
name|ilk_txx_cfg1
operator|.
name|s
operator|.
name|rx_link_fc_ign
operator|=
literal|1
expr_stmt|;
comment|/* cannot use link fc workaround */
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_ILK_STATS_ENA
comment|/* RX side stats */
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|lnk_stats_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* TX side stats */
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|lnk_stats_ena
operator|=
literal|1
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|retry
label|:
name|retry_count
operator|++
expr_stmt|;
if|if
condition|(
name|retry_count
operator|>
literal|10
condition|)
goto|goto
name|out
goto|;
comment|/* Make sure the link is up, so that packets can be sent. */
name|result
operator|=
name|__cvmx_helper_ilk_link_get
argument_list|(
name|cvmx_helper_get_ipd_port
argument_list|(
name|interface
operator|+
name|CVMX_ILK_GBL_BASE
argument_list|,
literal|0
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Small delay before another retry. */
name|cvmx_wait_usec
argument_list|(
literal|100
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ilk_rxx_cfg1
operator|.
name|s
operator|.
name|pkt_ena
operator|==
literal|0
condition|)
goto|goto
name|retry
goto|;
name|out
label|:
ifdef|#
directive|ifdef
name|CVMX_ILK_STATS_ENA
name|cvmx_dprintf
argument_list|(
literal|">>>> ILK%d: After ILK is enabled\n"
argument_list|,
name|interface
argument_list|)
expr_stmt|;
name|cvmx_ilk_reg_dump_rx
argument_list|(
name|interface
argument_list|)
expr_stmt|;
name|cvmx_ilk_reg_dump_tx
argument_list|(
name|interface
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|result
operator|.
name|s
operator|.
name|link_up
condition|)
return|return
literal|0
return|;
return|return
operator|-
literal|1
return|;
block|}
end_function

begin_comment
comment|/**  * Disable interface  *  * @param interface The identifier of the packet interface to disable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_disable
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_txx_cfg1_t
name|ilk_txx_cfg1
decl_stmt|;
name|cvmx_ilk_rxx_cfg1_t
name|ilk_rxx_cfg1
decl_stmt|;
ifdef|#
directive|ifdef
name|CVMX_ILK_STATS_ENA
name|cvmx_ilk_rxx_cfg0_t
name|ilk_rxx_cfg0
decl_stmt|;
name|cvmx_ilk_txx_cfg0_t
name|ilk_txx_cfg0
decl_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
comment|/* TX side */
name|ilk_txx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg1
operator|.
name|s
operator|.
name|pkt_ena
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* RX side */
name|ilk_rxx_cfg1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg1
operator|.
name|s
operator|.
name|pkt_ena
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg1
operator|.
name|u64
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CVMX_ILK_STATS_ENA
comment|/* RX side stats */
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|lnk_stats_ena
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
comment|/* RX side stats */
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|lnk_stats_ena
operator|=
literal|0
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Provide interface enable status  *  * @param interface The identifier of the packet interface to disable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  *  * @return Zero, not enabled; One, enabled.  */
end_comment

begin_function
name|int
name|cvmx_ilk_get_intf_ena
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
return|return
name|cvmx_ilk_intf_cfg
index|[
name|interface
index|]
operator|.
name|intf_en
return|;
block|}
end_function

begin_comment
comment|/**  * bit counter  *  * @param uc the byte to be counted  *  * @return number of bits set  */
end_comment

begin_function
name|unsigned
name|char
name|cvmx_ilk_bit_count
parameter_list|(
name|unsigned
name|char
name|uc
parameter_list|)
block|{
name|unsigned
name|char
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
init|;
name|uc
operator|>
literal|0
condition|;
name|uc
operator|&=
name|uc
operator|-
literal|1
control|)
name|count
operator|++
expr_stmt|;
return|return
name|count
return|;
block|}
end_function

begin_comment
comment|/**  * Provide interface lane mask  *  * @param interface The identifier of the packet interface to disable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  *  * @return lane mask  */
end_comment

begin_function
name|unsigned
name|char
name|cvmx_ilk_get_intf_ln_msk
parameter_list|(
name|int
name|interface
parameter_list|)
block|{
return|return
name|cvmx_ilk_intf_cfg
index|[
name|interface
index|]
operator|.
name|lane_en_mask
return|;
block|}
end_function

begin_comment
comment|/**  * Provide channel info  *  * @param interface The identifier of the packet interface to disable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  * @param chans    A pointer to a channel array  * @param num_chan A pointer to the number of channels  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_get_chan_info
parameter_list|(
name|int
name|interface
parameter_list|,
name|unsigned
name|char
modifier|*
modifier|*
name|chans
parameter_list|,
name|unsigned
name|char
modifier|*
name|num_chan
parameter_list|)
block|{
operator|*
name|chans
operator|=
name|cvmx_ilk_chan_map
index|[
name|interface
index|]
expr_stmt|;
operator|*
name|num_chan
operator|=
name|cvmx_ilk_chans
index|[
name|interface
index|]
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/**  * Show channel statistics  *  * @param interface The identifier of the packet interface to disable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  * @param pstats A pointer to cvmx_ilk_stats_ctrl_t that specifies which  *               logical channels to access  *  * @return nothing  */
end_comment

begin_function
name|void
name|cvmx_ilk_show_stats
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_ilk_stats_ctrl_t
modifier|*
name|pstats
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|cvmx_ilk_rxx_idx_stat0_t
name|ilk_rxx_idx_stat0
decl_stmt|;
name|cvmx_ilk_rxx_idx_stat1_t
name|ilk_rxx_idx_stat1
decl_stmt|;
name|cvmx_ilk_rxx_mem_stat0_t
name|ilk_rxx_mem_stat0
decl_stmt|;
name|cvmx_ilk_rxx_mem_stat1_t
name|ilk_rxx_mem_stat1
decl_stmt|;
name|cvmx_ilk_txx_idx_stat0_t
name|ilk_txx_idx_stat0
decl_stmt|;
name|cvmx_ilk_txx_idx_stat1_t
name|ilk_txx_idx_stat1
decl_stmt|;
name|cvmx_ilk_txx_mem_stat0_t
name|ilk_txx_mem_stat0
decl_stmt|;
name|cvmx_ilk_txx_mem_stat1_t
name|ilk_txx_mem_stat1
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return;
if|if
condition|(
name|pstats
operator|==
name|NULL
condition|)
return|return;
comment|/* discrete channels */
if|if
condition|(
name|pstats
operator|->
name|chan_list
operator|!=
name|NULL
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pstats
operator|->
name|num_chans
condition|;
name|i
operator|++
control|)
block|{
comment|/* get the number of rx packets */
name|ilk_rxx_idx_stat0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxx_idx_stat0
operator|.
name|s
operator|.
name|index
operator|=
operator|*
name|pstats
operator|->
name|chan_list
expr_stmt|;
name|ilk_rxx_idx_stat0
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_IDX_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_idx_stat0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_mem_stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get the number of rx bytes */
name|ilk_rxx_idx_stat1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxx_idx_stat1
operator|.
name|s
operator|.
name|index
operator|=
operator|*
name|pstats
operator|->
name|chan_list
expr_stmt|;
name|ilk_rxx_idx_stat1
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_IDX_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_idx_stat1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_mem_stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ILK%d Channel%d Rx: %d packets %d bytes\n"
argument_list|,
name|interface
argument_list|,
operator|*
name|pstats
operator|->
name|chan_list
argument_list|,
name|ilk_rxx_mem_stat0
operator|.
name|s
operator|.
name|rx_pkt
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ilk_rxx_mem_stat1
operator|.
name|s
operator|.
name|rx_bytes
argument_list|)
expr_stmt|;
comment|/* get the number of tx packets */
name|ilk_txx_idx_stat0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_stat0
operator|.
name|s
operator|.
name|index
operator|=
operator|*
name|pstats
operator|->
name|chan_list
expr_stmt|;
name|ilk_txx_idx_stat0
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_stat0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_mem_stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get the number of tx bytes */
name|ilk_txx_idx_stat1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_stat1
operator|.
name|s
operator|.
name|index
operator|=
operator|*
name|pstats
operator|->
name|chan_list
expr_stmt|;
name|ilk_txx_idx_stat1
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_stat1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_mem_stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ILK%d Channel%d Tx: %d packets %d bytes\n"
argument_list|,
name|interface
argument_list|,
operator|*
name|pstats
operator|->
name|chan_list
argument_list|,
name|ilk_txx_mem_stat0
operator|.
name|s
operator|.
name|tx_pkt
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ilk_txx_mem_stat1
operator|.
name|s
operator|.
name|tx_bytes
argument_list|)
expr_stmt|;
name|pstats
operator|++
expr_stmt|;
block|}
return|return;
block|}
comment|/* continuous channels */
name|ilk_rxx_idx_stat0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxx_idx_stat0
operator|.
name|s
operator|.
name|index
operator|=
name|pstats
operator|->
name|chan_start
expr_stmt|;
name|ilk_rxx_idx_stat0
operator|.
name|s
operator|.
name|inc
operator|=
name|pstats
operator|->
name|chan_step
expr_stmt|;
name|ilk_rxx_idx_stat0
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_IDX_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_idx_stat0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_idx_stat1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_rxx_idx_stat1
operator|.
name|s
operator|.
name|index
operator|=
name|pstats
operator|->
name|chan_start
expr_stmt|;
name|ilk_rxx_idx_stat1
operator|.
name|s
operator|.
name|inc
operator|=
name|pstats
operator|->
name|chan_step
expr_stmt|;
name|ilk_rxx_idx_stat1
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_IDX_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_idx_stat1
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_idx_stat0
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_stat0
operator|.
name|s
operator|.
name|index
operator|=
name|pstats
operator|->
name|chan_start
expr_stmt|;
name|ilk_txx_idx_stat0
operator|.
name|s
operator|.
name|inc
operator|=
name|pstats
operator|->
name|chan_step
expr_stmt|;
name|ilk_txx_idx_stat0
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_stat0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_txx_idx_stat1
operator|.
name|u64
operator|=
literal|0
expr_stmt|;
name|ilk_txx_idx_stat1
operator|.
name|s
operator|.
name|index
operator|=
name|pstats
operator|->
name|chan_start
expr_stmt|;
name|ilk_txx_idx_stat1
operator|.
name|s
operator|.
name|inc
operator|=
name|pstats
operator|->
name|chan_step
expr_stmt|;
name|ilk_txx_idx_stat1
operator|.
name|s
operator|.
name|clr
operator|=
name|pstats
operator|->
name|clr_on_rd
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_IDX_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_idx_stat1
operator|.
name|u64
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|pstats
operator|->
name|chan_start
init|;
name|i
operator|<=
name|pstats
operator|->
name|chan_end
condition|;
name|i
operator|+=
name|pstats
operator|->
name|chan_step
control|)
block|{
name|ilk_rxx_mem_stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_mem_stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_MEM_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ILK%d Channel%d Rx: %d packets %d bytes\n"
argument_list|,
name|interface
argument_list|,
name|i
argument_list|,
name|ilk_rxx_mem_stat0
operator|.
name|s
operator|.
name|rx_pkt
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ilk_rxx_mem_stat1
operator|.
name|s
operator|.
name|rx_bytes
argument_list|)
expr_stmt|;
name|ilk_txx_mem_stat0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_STAT0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_mem_stat1
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_MEM_STAT1
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|cvmx_dprintf
argument_list|(
literal|"ILK%d Channel%d Tx: %d packets %d bytes\n"
argument_list|,
name|interface
argument_list|,
name|i
argument_list|,
name|ilk_rxx_mem_stat0
operator|.
name|s
operator|.
name|rx_pkt
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|ilk_rxx_mem_stat1
operator|.
name|s
operator|.
name|rx_bytes
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/**  * enable or disable loopbacks  *  * @param interface The identifier of the packet interface to disable. cn68xx  *                  has 2 interfaces: ilk0 and ilk1.  * @param enable    Enable or disable loopback  * @param mode      Internal or external loopback  *  * @return Zero on success, negative of failure.  */
end_comment

begin_function
name|int
name|cvmx_ilk_lpbk
parameter_list|(
name|int
name|interface
parameter_list|,
name|cvmx_ilk_lpbk_ena_t
name|enable
parameter_list|,
name|cvmx_ilk_lpbk_mode_t
name|mode
parameter_list|)
block|{
name|int
name|res
init|=
operator|-
literal|1
decl_stmt|;
name|cvmx_ilk_txx_cfg0_t
name|ilk_txx_cfg0
decl_stmt|;
name|cvmx_ilk_rxx_cfg0_t
name|ilk_rxx_cfg0
decl_stmt|;
if|if
condition|(
operator|!
operator|(
name|OCTEON_IS_MODEL
argument_list|(
name|OCTEON_CN68XX
argument_list|)
operator|)
condition|)
return|return
name|res
return|;
if|if
condition|(
name|interface
operator|>=
name|CVMX_NUM_ILK_INTF
condition|)
return|return
name|res
return|;
comment|/* internal loopback. only 1 type of loopback can be on at 1 time */
if|if
condition|(
name|mode
operator|==
name|CVMX_ILK_LPBK_INT
condition|)
block|{
if|if
condition|(
name|enable
operator|==
name|CVMX_ILK_LPBK_ENA
condition|)
block|{
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk
operator|=
name|CVMX_ILK_LPBK_DISA
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk_fc
operator|=
name|CVMX_ILK_LPBK_DISA
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk
operator|=
name|CVMX_ILK_LPBK_DISA
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk_fc
operator|=
name|CVMX_ILK_LPBK_DISA
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|int_lpbk
operator|=
name|enable
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
comment|/* external loopback. only 1 type of loopback can be on at 1 time */
if|if
condition|(
name|enable
operator|==
name|CVMX_ILK_LPBK_ENA
condition|)
block|{
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|int_lpbk
operator|=
name|CVMX_ILK_LPBK_DISA
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
block|}
name|ilk_txx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk
operator|=
name|enable
expr_stmt|;
name|ilk_txx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk_fc
operator|=
name|enable
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_TXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_txx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|u64
operator|=
name|cvmx_read_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|)
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk
operator|=
name|enable
expr_stmt|;
name|ilk_rxx_cfg0
operator|.
name|s
operator|.
name|ext_lpbk_fc
operator|=
name|enable
expr_stmt|;
name|cvmx_write_csr
argument_list|(
name|CVMX_ILK_RXX_CFG0
argument_list|(
name|interface
argument_list|)
argument_list|,
name|ilk_rxx_cfg0
operator|.
name|u64
argument_list|)
expr_stmt|;
name|res
operator|=
literal|0
expr_stmt|;
return|return
name|res
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CVMX_ENABLE_HELPER_FUNCTIONS */
end_comment

end_unit

