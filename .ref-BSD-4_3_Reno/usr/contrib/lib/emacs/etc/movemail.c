begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* movemail foo bar -- move file foo to file bar,    locking file foo the way /bin/mail respects.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but without any warranty.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the document "GNU Emacs copying permission notice".   An exact copy of the document is supposed to have been given to you along with GNU Emacs so that you can know how you may redistribute it all. It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/*  * Modified January, 1986 by Michael R. Gretzinger (Project Athena)  *  * Added POP (Post Office Protocol) service.  When compiled -DPOP  * movemail will accept input filename arguments of the form  * "po:username".  This will cause movemail to open a connection to  * a pop server running on $MAILHOST (environment variable).  Movemail  * must be setuid to root in order to work with POP.  *   * New module: popmail.c  * Modified routines:  *	main - added code within #ifdef MAIL_USE_POP; added setuid(getuid())  *		after POP code.   * New routines in movemail.c:  *	get_errmsg - return pointer to system error message  *  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_define
define|#
directive|define
name|NO_SHORTNAMES
end_define

begin_comment
comment|/* Tell config not to load remap.h */
end_comment

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|F_OK
end_ifndef

begin_define
define|#
directive|define
name|F_OK
value|0
end_define

begin_define
define|#
directive|define
name|X_OK
value|1
end_define

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|R_OK
value|4
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|XENIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/locking.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Cancel substitutions made by config.h for Emacs.  */
end_comment

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_function_decl
name|char
modifier|*
name|concat
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Nonzero means this is name of a lock file to delete on fatal error.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|delete_lockname
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
modifier|*
name|inname
decl_stmt|,
modifier|*
name|outname
decl_stmt|;
name|int
name|indesc
decl_stmt|,
name|outdesc
decl_stmt|;
name|char
name|buf
index|[
literal|1024
index|]
decl_stmt|;
name|int
name|nread
decl_stmt|;
ifndef|#
directive|ifndef
name|MAIL_USE_FLOCK
name|struct
name|stat
name|st
decl_stmt|;
name|long
name|now
decl_stmt|;
name|int
name|tem
decl_stmt|;
name|char
modifier|*
name|lockname
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|char
name|tempname
index|[
literal|40
index|]
decl_stmt|;
name|int
name|desc
decl_stmt|;
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
name|delete_lockname
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|fatal
argument_list|(
literal|"two arguments required"
argument_list|)
expr_stmt|;
name|inname
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|outname
operator|=
name|argv
index|[
literal|2
index|]
expr_stmt|;
comment|/* Check access to input and output file.  */
if|if
condition|(
name|access
argument_list|(
name|inname
argument_list|,
name|R_OK
operator||
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|inname
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|outname
argument_list|,
name|F_OK
argument_list|)
operator|==
literal|0
operator|&&
name|access
argument_list|(
name|outname
argument_list|,
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|outname
argument_list|)
expr_stmt|;
comment|/* Also check that outname's directory is writeable to the real uid.  */
block|{
name|char
modifier|*
name|buf
init|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|outname
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|q
decl_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|>
name|buf
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|*
operator|--
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|buf
condition|)
operator|*
name|p
operator|++
operator|=
literal|'.'
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|buf
argument_list|,
name|W_OK
argument_list|)
operator|!=
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAIL_USE_POP
if|if
condition|(
operator|!
name|bcmp
argument_list|(
name|inname
argument_list|,
literal|"po:"
argument_list|,
literal|3
argument_list|)
condition|)
block|{
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|;
name|user
operator|=
operator|(
name|char
operator|*
operator|)
name|rindex
argument_list|(
name|inname
argument_list|,
literal|':'
argument_list|)
operator|+
literal|1
expr_stmt|;
name|status
operator|=
name|popmail
argument_list|(
name|user
argument_list|,
name|outname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
name|setuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MAIL_USE_POP */
ifndef|#
directive|ifndef
name|MAIL_USE_FLOCK
comment|/* Use a lock file named /usr/spool/mail/$USER.lock:      If it exists, the mail file is locked.  */
name|lockname
operator|=
name|concat
argument_list|(
name|inname
argument_list|,
literal|".lock"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tempname
argument_list|,
name|inname
argument_list|)
expr_stmt|;
name|p
operator|=
name|tempname
operator|+
name|strlen
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
while|while
condition|(
name|p
operator|!=
name|tempname
operator|&&
name|p
index|[
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|p
operator|--
expr_stmt|;
operator|*
name|p
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|p
argument_list|,
literal|"EXXXXXX"
argument_list|)
expr_stmt|;
name|mktemp
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
comment|/* Create the lock file, but not under the lock file name.  */
comment|/* Give up if cannot do that.  */
name|desc
operator|=
name|open
argument_list|(
name|tempname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|desc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|concat
argument_list|(
literal|"temporary file \""
argument_list|,
name|tempname
argument_list|,
literal|"\""
argument_list|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|desc
argument_list|)
expr_stmt|;
name|tem
operator|=
name|link
argument_list|(
name|tempname
argument_list|,
name|lockname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
if|if
condition|(
name|tem
operator|>=
literal|0
condition|)
break|break;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If lock file is a minute old, unlock it.  */
if|if
condition|(
name|stat
argument_list|(
name|lockname
argument_list|,
operator|&
name|st
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|now
operator|=
name|time
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|st
operator|.
name|st_ctime
operator|<
name|now
operator|-
literal|60
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
block|}
block|}
name|delete_lockname
operator|=
name|lockname
expr_stmt|;
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
ifdef|#
directive|ifdef
name|MAIL_USE_FLOCK
name|indesc
operator|=
name|open
argument_list|(
name|inname
argument_list|,
name|O_RDWR
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* if not MAIL_USE_FLOCK */
name|indesc
operator|=
name|open
argument_list|(
name|inname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
if|if
condition|(
name|indesc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|inname
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|XENIX
argument_list|)
comment|/* In case movemail is setuid to root, make sure the user can      read the output file.  */
comment|/* This is desirable for all systems      but I don't want to assume all have the umask system call */
name|umask
argument_list|(
name|umask
argument_list|(
literal|0
argument_list|)
operator|&
literal|0333
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* BSD or Xenix */
name|outdesc
operator|=
name|open
argument_list|(
name|outname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|outdesc
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|outname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MAIL_USE_FLOCK
ifdef|#
directive|ifdef
name|XENIX
if|if
condition|(
name|locking
argument_list|(
name|indesc
argument_list|,
name|LK_RLCK
argument_list|,
literal|0L
argument_list|)
operator|<
literal|0
condition|)
name|pfatal_with_name
argument_list|(
name|inname
argument_list|)
expr_stmt|;
else|#
directive|else
name|flock
argument_list|(
name|indesc
argument_list|,
name|LOCK_EX
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* MAIL_USE_FLOCK */
while|while
condition|(
literal|1
condition|)
block|{
name|nread
operator|=
name|read
argument_list|(
name|indesc
argument_list|,
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|nread
operator|!=
name|write
argument_list|(
name|outdesc
argument_list|,
name|buf
argument_list|,
name|nread
argument_list|)
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|pfatal_with_name
argument_list|(
name|outname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nread
operator|<
sizeof|sizeof
name|buf
condition|)
break|break;
block|}
ifdef|#
directive|ifdef
name|BSD
name|fsync
argument_list|(
name|outdesc
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check to make sure no errors before we zap the inbox.  */
if|if
condition|(
name|close
argument_list|(
name|outdesc
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|int
name|saved_errno
init|=
name|errno
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outname
argument_list|)
expr_stmt|;
name|errno
operator|=
name|saved_errno
expr_stmt|;
name|pfatal_with_name
argument_list|(
name|outname
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MAIL_USE_FLOCK
if|#
directive|if
name|defined
argument_list|(
name|STRIDE
argument_list|)
operator|||
name|defined
argument_list|(
name|XENIX
argument_list|)
comment|/* Stride, xenix have file locking, but no ftruncate.  This mess will do. */
operator|(
name|void
operator|)
name|close
argument_list|(
name|open
argument_list|(
name|inname
argument_list|,
name|O_CREAT
operator||
name|O_TRUNC
operator||
name|O_RDWR
argument_list|,
literal|0666
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|ftruncate
argument_list|(
name|indesc
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* STRIDE or XENIX */
endif|#
directive|endif
comment|/* MAIL_USE_FLOCK */
name|close
argument_list|(
name|indesc
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MAIL_USE_FLOCK
comment|/* Delete the input file; if we can't, at least get rid of its contents.  */
if|if
condition|(
name|unlink
argument_list|(
name|inname
argument_list|)
operator|<
literal|0
condition|)
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
name|creat
argument_list|(
name|inname
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|lockname
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not MAIL_USE_FLOCK */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* Print error message and exit.  */
end_comment

begin_macro
name|fatal
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|delete_lockname
condition|)
name|unlink
argument_list|(
name|delete_lockname
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Print error message.  `s1' is printf control string, `s2' is arg for it. */
end_comment

begin_macro
name|error
argument_list|(
argument|s1
argument_list|,
argument|s2
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"movemail: "
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|pfatal_with_name
argument_list|(
argument|name
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|name
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|concat
argument_list|(
literal|""
argument_list|,
name|sys_errlist
index|[
name|errno
index|]
argument_list|,
literal|" for %s"
argument_list|)
expr_stmt|;
else|else
name|s
operator|=
literal|"cannot open %s"
expr_stmt|;
name|fatal
argument_list|(
name|s
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Return a newly-allocated string whose contents concatenate those of s1, s2, s3.  */
end_comment

begin_function
name|char
modifier|*
name|concat
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|s3
parameter_list|)
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|,
modifier|*
name|s3
decl_stmt|;
end_function

begin_block
block|{
name|int
name|len1
init|=
name|strlen
argument_list|(
name|s1
argument_list|)
decl_stmt|,
name|len2
init|=
name|strlen
argument_list|(
name|s2
argument_list|)
decl_stmt|,
name|len3
init|=
name|strlen
argument_list|(
name|s3
argument_list|)
decl_stmt|;
name|char
modifier|*
name|result
init|=
operator|(
name|char
operator|*
operator|)
name|xmalloc
argument_list|(
name|len1
operator|+
name|len2
operator|+
name|len3
operator|+
literal|1
argument_list|)
decl_stmt|;
name|strcpy
argument_list|(
name|result
argument_list|,
name|s1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|result
operator|+
name|len1
operator|+
name|len2
argument_list|,
name|s3
argument_list|)
expr_stmt|;
operator|*
operator|(
name|result
operator|+
name|len1
operator|+
name|len2
operator|+
name|len3
operator|)
operator|=
literal|0
expr_stmt|;
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/* Like malloc but get fatal error if memory is exhausted.  */
end_comment

begin_function
name|int
name|xmalloc
parameter_list|(
name|size
parameter_list|)
name|int
name|size
decl_stmt|;
block|{
name|int
name|result
init|=
name|malloc
argument_list|(
name|size
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|result
condition|)
name|fatal
argument_list|(
literal|"virtual memory exhausted"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|result
return|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/* This is the guts of the interface to the Post Office Protocol.  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAIL_USE_POP
end_ifdef

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_comment
comment|/* Cancel substitutions made by config.h for Emacs.  */
end_comment

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* USG */
end_comment

begin_define
define|#
directive|define
name|NOTOK
value|(-1)
end_define

begin_define
define|#
directive|define
name|OK
value|0
end_define

begin_define
define|#
directive|define
name|DONE
value|1
end_define

begin_decl_stmt
name|char
modifier|*
name|progname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sfi
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|sfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|Errmsg
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_macro
name|popmail
argument_list|(
argument|user
argument_list|,
argument|outfile
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|user
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|outfile
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|host
decl_stmt|;
name|int
name|nmsgs
decl_stmt|,
name|nbytes
decl_stmt|;
name|char
name|response
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|mbfi
decl_stmt|;
name|FILE
modifier|*
name|mbf
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|int
name|mbx_write
parameter_list|()
function_decl|;
name|char
modifier|*
name|get_errmsg
parameter_list|()
function_decl|;
name|host
operator|=
name|getenv
argument_list|(
literal|"MAILHOST"
argument_list|)
expr_stmt|;
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
name|fatal
argument_list|(
literal|"no MAILHOST defined"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pop_init
argument_list|(
name|host
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|error
argument_list|(
name|Errmsg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|getline
argument_list|(
name|response
argument_list|,
sizeof|sizeof
name|response
argument_list|,
name|sfi
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|error
argument_list|(
name|response
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pop_command
argument_list|(
literal|"USER %s"
argument_list|,
name|user
argument_list|)
operator|==
name|NOTOK
operator|||
name|pop_command
argument_list|(
literal|"RPOP %s"
argument_list|,
name|user
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|error
argument_list|(
name|Errmsg
argument_list|)
expr_stmt|;
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|pop_stat
argument_list|(
operator|&
name|nmsgs
argument_list|,
operator|&
name|nbytes
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|error
argument_list|(
name|Errmsg
argument_list|)
expr_stmt|;
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|nmsgs
condition|)
block|{
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|mbfi
operator|=
name|open
argument_list|(
name|outfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_EXCL
argument_list|,
literal|0666
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbfi
operator|<
literal|0
condition|)
block|{
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Error in open: %s, %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|fchown
argument_list|(
name|mbfi
argument_list|,
name|getuid
argument_list|()
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mbf
operator|=
name|fdopen
argument_list|(
name|mbfi
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Error in fdopen: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|mbfi
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
name|mbx_delimit_begin
argument_list|(
name|mbf
argument_list|)
expr_stmt|;
if|if
condition|(
name|pop_retr
argument_list|(
name|i
argument_list|,
name|mbx_write
argument_list|,
name|mbf
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|error
argument_list|(
name|Errmsg
argument_list|)
expr_stmt|;
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|mbfi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|mbx_delimit_end
argument_list|(
name|mbf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|mbf
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|nmsgs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pop_command
argument_list|(
literal|"DELE %d"
argument_list|,
name|i
argument_list|)
operator|==
name|NOTOK
condition|)
block|{
name|error
argument_list|(
name|Errmsg
argument_list|)
expr_stmt|;
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|mbfi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|pop_command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|mbfi
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|pop_init
argument_list|(
argument|host
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|host
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|register
name|struct
name|servent
modifier|*
name|sp
decl_stmt|;
name|int
name|lport
init|=
name|IPPORT_RESERVED
operator|-
literal|1
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
specifier|register
name|int
name|s
decl_stmt|;
name|char
modifier|*
name|get_errmsg
parameter_list|()
function_decl|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|Errmsg
argument_list|,
literal|"MAILHOST unknown: %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|sp
operator|=
name|getservbyname
argument_list|(
literal|"pop"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|Errmsg
argument_list|,
literal|"tcp/pop: unknown service"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|sin
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|sp
operator|->
name|s_port
expr_stmt|;
name|s
operator|=
name|rresvport
argument_list|(
operator|&
name|lport
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|Errmsg
argument_list|,
literal|"error creating socket: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
name|sin
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|Errmsg
argument_list|,
literal|"error during connect: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
name|sfi
operator|=
name|fdopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|sfo
operator|=
name|fdopen
argument_list|(
name|s
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sfi
operator|==
name|NULL
operator|||
name|sfo
operator|==
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|Errmsg
argument_list|,
literal|"error in fdopen: %s"
argument_list|,
name|get_errmsg
argument_list|()
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_macro
name|pop_command
argument_list|(
argument|fmt
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|,
argument|d
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fmt
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|char
name|errmsg
index|[
literal|64
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
name|fmt
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|,
name|d
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---> %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|putline
argument_list|(
name|buf
argument_list|,
name|Errmsg
argument_list|,
name|sfo
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|getline
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|sfi
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|strcpy
argument_list|(
name|Errmsg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<--- %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'+'
condition|)
block|{
name|strcpy
argument_list|(
name|Errmsg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|OK
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|pop_stat
argument_list|(
argument|nmsgs
argument_list|,
argument|nbytes
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|nmsgs
decl_stmt|,
modifier|*
name|nbytes
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"---> STAT\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|putline
argument_list|(
literal|"STAT"
argument_list|,
name|Errmsg
argument_list|,
name|sfo
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|getline
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|sfi
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|strcpy
argument_list|(
name|Errmsg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"<--- %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'+'
condition|)
block|{
name|strcpy
argument_list|(
name|Errmsg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
else|else
block|{
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"+OK %d %d"
argument_list|,
name|nmsgs
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|pop_retr
argument_list|(
argument|msgno
argument_list|,
argument|action
argument_list|,
argument|arg
argument_list|)
end_macro

begin_function_decl
name|int
function_decl|(
modifier|*
name|action
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|char
name|buf
index|[
literal|128
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"RETR %d"
argument_list|,
name|msgno
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|putline
argument_list|(
name|buf
argument_list|,
name|Errmsg
argument_list|,
name|sfo
argument_list|)
operator|==
name|NOTOK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
name|getline
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|sfi
argument_list|)
operator|!=
name|OK
condition|)
block|{
name|strcpy
argument_list|(
name|Errmsg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
while|while
condition|(
literal|1
condition|)
block|{
switch|switch
condition|(
name|multiline
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|sfi
argument_list|)
condition|)
block|{
case|case
name|OK
case|:
call|(
modifier|*
name|action
call|)
argument_list|(
name|buf
argument_list|,
name|arg
argument_list|)
expr_stmt|;
break|break;
case|case
name|DONE
case|:
return|return
operator|(
name|OK
operator|)
return|;
case|case
name|NOTOK
case|:
name|strcpy
argument_list|(
name|Errmsg
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
block|}
block|}
end_block

begin_macro
name|getline
argument_list|(
argument|buf
argument_list|,
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|c
decl_stmt|;
name|p
operator|=
name|buf
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>
literal|0
operator|&&
operator|(
name|c
operator|=
name|fgetc
argument_list|(
name|f
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|(
operator|*
name|p
operator|++
operator|=
name|c
operator|)
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"error on connection"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|p
operator|==
name|buf
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"connection closed by foreign host"
argument_list|)
expr_stmt|;
return|return
operator|(
name|DONE
operator|)
return|;
block|}
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'\n'
condition|)
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|*
operator|--
name|p
operator|==
literal|'\r'
condition|)
operator|*
name|p
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_macro
name|multiline
argument_list|(
argument|buf
argument_list|,
argument|n
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|n
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|getline
argument_list|(
name|buf
argument_list|,
name|n
argument_list|,
name|f
argument_list|)
operator|!=
name|OK
condition|)
return|return
operator|(
name|NOTOK
operator|)
return|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|buf
operator|+
literal|1
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
name|DONE
operator|)
return|;
block|}
else|else
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|get_errmsg
parameter_list|()
block|{
specifier|extern
name|int
name|errno
decl_stmt|,
name|sys_nerr
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|errno
operator|<
name|sys_nerr
condition|)
name|s
operator|=
name|sys_errlist
index|[
name|errno
index|]
expr_stmt|;
else|else
name|s
operator|=
literal|"unknown error"
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_macro
name|putline
argument_list|(
argument|buf
argument_list|,
argument|err
argument_list|,
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|err
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|f
argument_list|,
literal|"%s\r\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
block|{
name|strcpy
argument_list|(
name|err
argument_list|,
literal|"lost connection"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOTOK
operator|)
return|;
block|}
return|return
operator|(
name|OK
operator|)
return|;
block|}
end_block

begin_macro
name|mbx_write
argument_list|(
argument|line
argument_list|,
argument|mbf
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|mbf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputs
argument_list|(
name|line
argument_list|,
name|mbf
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|0x0a
argument_list|,
name|mbf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mbx_delimit_begin
argument_list|(
argument|mbf
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|mbf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fputs
argument_list|(
literal|"\f\n0,unseen,,\n"
argument_list|,
name|mbf
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|mbx_delimit_end
argument_list|(
argument|mbf
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|mbf
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putc
argument_list|(
literal|'\037'
argument_list|,
name|mbf
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAIL_USE_POP */
end_comment

end_unit

