begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* File name wild card expansion for VMS.    This file is part of the etags program.    Copyright (C) 1987 Free Software Foundation, Inc. 3 Feb 1987       This program is distributed in the hope that it will be useful, but without any warranty.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.          Permission is granted to anyone to distribute verbatim copies    of this program's source code as received, in any medium, provided that    the copyright notice, the nonwarraty notice above    and this permission notice are preserved,    and that the distributor grants the recipient all rights    for further redistribution as permitted by this notice,    and informs him of these rights.          Permission is granted to distribute modified versions of this    program's source code, or of portions of it, under the above    conditions, plus the conditions that all changed files carry    prominent notices stating who last changed them and that the    derived material, including anything packaged together with it and    conceptually functioning as a modification of it rather than an    application of it, is in its entirety subject to a permission    notice identical to this one.          Permission is granted to distribute this program (verbatim or    as modified) in compiled or executable form, provided verbatim    redistribution is permitted as stated above for source code, and     A.  it is accompanied by the corresponding machine-readable       source code, under the above conditions, or     B.  it is accompanied by a written offer, with no time limit,       to distribute the corresponding machine-readable source code,       under the above conditions, to any one, in return for reimbursement       of the cost of distribution.   Verbatim redistribution of the       written offer must be permitted.  Or,     C.  it is distributed by someone who received only the       compiled or executable form, and is accompanied by a copy of the       written offer of source code which he received along with it.          Permission is granted to distribute this program (verbatim or as modified)    in executable form as part of a larger system provided that the source    code for this program, including any modifications used,    is also distributed or offered as stated in the preceding paragraph.       In other words, you are welcome to use, share and improve this program. You are forbidden to forbid anyone else to use, share and improve what you give them.   Help stamp out software-hoarding!  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_typedef
typedef|typedef
name|char
name|tbool
typedef|;
end_typedef

begin_comment
comment|/* This is a BUG!  ANY arbitrary limit is a BUG!    Won't someone please fix this?  */
end_comment

begin_define
define|#
directive|define
name|MAX_FILE_SPEC_LEN
value|255
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|short
name|curlen
decl_stmt|;
name|char
name|body
index|[
name|MAX_FILE_SPEC_LEN
operator|+
literal|1
index|]
decl_stmt|;
block|}
name|vspec
typedef|;
end_typedef

begin_define
define|#
directive|define
name|EOS
value|'\0'
end_define

begin_define
define|#
directive|define
name|NO
value|0
end_define

begin_define
define|#
directive|define
name|YES
value|1
end_define

begin_define
define|#
directive|define
name|NULL
value|0
end_define

begin_comment
comment|/* v1.01 nmm 19-Aug-85 gfnames - return in successive calls the   name of each file specified by all the remaining args in the command-line  expanding wild cards and   stepping over arguments when they have been processed completely */
end_comment

begin_function
name|char
modifier|*
name|gfnames
parameter_list|(
name|pac
parameter_list|,
name|pav
parameter_list|,
name|p_error
parameter_list|)
name|int
modifier|*
name|pac
decl_stmt|;
name|char
modifier|*
modifier|*
name|pav
index|[]
decl_stmt|;
name|tbool
modifier|*
name|p_error
decl_stmt|;
block|{
specifier|static
name|vspec
name|filename
init|=
block|{
name|MAX_FILE_SPEC_LEN
block|,
literal|"\0"
block|}
decl_stmt|;
name|short
name|fn_exp
parameter_list|()
function_decl|;
while|while
condition|(
literal|1
condition|)
if|if
condition|(
operator|*
name|pac
operator|==
literal|0
condition|)
block|{
operator|*
name|p_error
operator|=
name|NO
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
else|else
switch|switch
condition|(
name|fn_exp
argument_list|(
operator|&
name|filename
argument_list|,
operator|*
operator|*
name|pav
argument_list|)
condition|)
block|{
case|case
literal|1
case|:
operator|*
name|p_error
operator|=
name|NO
expr_stmt|;
return|return
operator|(
name|filename
operator|.
name|body
operator|)
return|;
break|break;
case|case
literal|0
case|:
operator|--
operator|*
name|pac
expr_stmt|;
operator|++
operator|*
name|pav
expr_stmt|;
break|break;
default|default:
operator|*
name|p_error
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|filename
operator|.
name|body
operator|)
return|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* v1.05 nmm 26-Jun-86 fn_exp - expand specification of list of file names  returning in each successive call the next filename matching the input  spec. The function expects that each in_spec passed  to it will be processed to completion; in particular, up to and  including the call following that in which the last matching name  is returned, the function ignores the value of in_spec, and will  only start processing a new spec with the following call.   If an error occurs, on return out_spec contains the value  of in_spec when the error occurred.   With each successive filename returned in out_spec, the  function's return value is one. When there are no more matching  names the function returns zero. If on the first call no file  matches in_spec, or there is any other error, -1 is returned.  */
end_comment

begin_include
include|#
directive|include
file|<rmsdef.h>
end_include

begin_include
include|#
directive|include
file|<descrip.h>
end_include

begin_define
define|#
directive|define
name|OUTSIZE
value|MAX_FILE_SPEC_LEN
end_define

begin_function
name|short
name|fn_exp
parameter_list|(
name|out
parameter_list|,
name|in
parameter_list|)
name|vspec
modifier|*
name|out
decl_stmt|;
name|char
modifier|*
name|in
decl_stmt|;
block|{
specifier|static
name|long
name|context
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|dsc$descriptor_s
name|o
decl_stmt|;
specifier|static
name|struct
name|dsc$descriptor_s
name|i
decl_stmt|;
specifier|static
name|tbool
name|pass1
init|=
name|YES
decl_stmt|;
name|long
name|status
decl_stmt|;
name|short
name|retval
decl_stmt|;
if|if
condition|(
name|pass1
condition|)
block|{
name|pass1
operator|=
name|NO
expr_stmt|;
name|o
operator|.
name|dsc$a_pointer
operator|=
name|out
expr_stmt|;
name|o
operator|.
name|dsc$w_length
operator|=
operator|(
name|short
operator|)
name|OUTSIZE
expr_stmt|;
name|i
operator|.
name|dsc$a_pointer
operator|=
name|in
expr_stmt|;
name|i
operator|.
name|dsc$w_length
operator|=
operator|(
name|short
operator|)
name|strlen
argument_list|(
name|in
argument_list|)
expr_stmt|;
name|i
operator|.
name|dsc$b_dtype
operator|=
name|DSC$K_DTYPE_T
expr_stmt|;
name|i
operator|.
name|dsc$b_class
operator|=
name|DSC$K_CLASS_S
expr_stmt|;
name|o
operator|.
name|dsc$b_dtype
operator|=
name|DSC$K_DTYPE_VT
expr_stmt|;
name|o
operator|.
name|dsc$b_class
operator|=
name|DSC$K_CLASS_VS
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|status
operator|=
name|lib$find_file
argument_list|(
operator|&
name|i
argument_list|,
operator|&
name|o
argument_list|,
operator|&
name|context
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
name|RMS$_NORMAL
condition|)
block|{
name|out
operator|->
name|body
index|[
name|out
operator|->
name|curlen
index|]
operator|=
name|EOS
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|status
operator|==
name|RMS$_NMF
condition|)
name|retval
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|out
operator|->
name|body
argument_list|,
name|in
argument_list|)
expr_stmt|;
name|retval
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|lib$find_file_end
argument_list|(
operator|&
name|context
argument_list|)
expr_stmt|;
name|pass1
operator|=
name|YES
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|OLD
end_ifndef

begin_comment
comment|/* Newer versions of VMS do provide `system'.  */
end_comment

begin_macro
name|system
argument_list|(
argument|cmd
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"system() function not implemented under VMS\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|VERSION_DELIM
value|';'
end_define

begin_function
name|char
modifier|*
name|massage_name
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|char
modifier|*
name|start
init|=
name|s
decl_stmt|;
for|for
control|(
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
name|VERSION_DELIM
condition|)
block|{
operator|*
name|s
operator|=
name|EOS
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|s
operator|=
name|tolower
argument_list|(
operator|*
name|s
argument_list|)
expr_stmt|;
return|return
operator|(
name|start
operator|)
return|;
block|}
end_function

end_unit

