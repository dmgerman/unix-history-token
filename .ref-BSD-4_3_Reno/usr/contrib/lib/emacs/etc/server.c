begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* Communication subprocess for GNU Emacs acting as server.    Copyright (C) 1986, 1987 Free Software Foundation, Inc.  This file is part of GNU Emacs.  GNU Emacs is distributed in the hope that it will be useful, but without any warranty.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Everyone is granted permission to copy, modify and redistribute GNU Emacs, but only under the conditions described in the document "GNU Emacs copying permission notice".   An exact copy of the document is supposed to have been given to you along with GNU Emacs so that you can know how you may redistribute it all. It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* The GNU Emacs edit server process is run as a subprocess of Emacs    under control of the file lisp/server.el.    This program accepts communication from client (program emacsclient.c)    and passes their commands (consisting of keyboard characters)    up to the Emacs which then executes them.  */
end_comment

begin_define
define|#
directive|define
name|NO_SHORTNAMES
end_define

begin_include
include|#
directive|include
file|"../src/config.h"
end_include

begin_undef
undef|#
directive|undef
name|read
end_undef

begin_undef
undef|#
directive|undef
name|write
end_undef

begin_undef
undef|#
directive|undef
name|open
end_undef

begin_undef
undef|#
directive|undef
name|close
end_undef

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SYSVIPC
argument_list|)
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|main
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Sorry, the Emacs server is supported only on Berkeley Unix\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"or System V systems with IPC\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* BSD or HAVE_SYSVIPC */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|HAVE_SYSVIPC
argument_list|)
end_if

begin_comment
comment|/* BSD code is very different from SYSV IPC code */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
specifier|extern
name|int
name|errno
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|()
block|{
name|int
name|s
decl_stmt|,
name|infd
decl_stmt|,
name|fromlen
decl_stmt|;
name|struct
name|sockaddr_un
name|server
decl_stmt|,
name|fromunix
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
name|string
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|code
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|openfiles
decl_stmt|;
name|int
name|openfiles_size
decl_stmt|;
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
name|openfiles_size
operator|=
literal|20
expr_stmt|;
name|openfiles
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|malloc
argument_list|(
name|openfiles_size
operator|*
sizeof|sizeof
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfiles
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/*     * Open up an AF_UNIX socket in this person's home directory    */
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_UNIX
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|server
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
if|if
condition|(
operator|(
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No home directory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|server
operator|.
name|sun_path
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|server
operator|.
name|sun_path
argument_list|,
literal|"/.emacs_server"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|s
argument_list|,
operator|&
name|server
argument_list|,
name|strlen
argument_list|(
name|server
operator|.
name|sun_path
argument_list|)
operator|+
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/*    * Now, just wait for everything to come in..    */
if|if
condition|(
name|listen
argument_list|(
name|s
argument_list|,
literal|5
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"listen"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Disable sigpipes in case luser kills client... */
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|int
name|rmask
init|=
operator|(
literal|1
operator|<<
name|s
operator|)
operator|+
literal|1
decl_stmt|;
if|if
condition|(
name|select
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|rmask
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
if|if
condition|(
name|rmask
operator|&
operator|(
literal|1
operator|<<
name|s
operator|)
condition|)
comment|/* client sends list of filenames */
block|{
name|fromlen
operator|=
sizeof|sizeof
argument_list|(
name|fromunix
argument_list|)
expr_stmt|;
name|fromunix
operator|.
name|sun_family
operator|=
name|AF_UNIX
expr_stmt|;
name|infd
operator|=
name|accept
argument_list|(
name|s
argument_list|,
operator|&
name|fromunix
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
comment|/* open socket fd */
if|if
condition|(
name|infd
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EMFILE
operator|||
name|errno
operator|==
name|ENFILE
condition|)
name|printf
argument_list|(
literal|"Too many clients.\n"
argument_list|)
expr_stmt|;
else|else
name|perror
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|infd
operator|>=
name|openfiles_size
condition|)
block|{
name|openfiles_size
operator|*=
literal|2
expr_stmt|;
name|openfiles
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|openfiles
argument_list|,
name|openfiles_size
operator|*
sizeof|sizeof
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|openfiles
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
block|}
name|infile
operator|=
name|fdopen
argument_list|(
name|infd
argument_list|,
literal|"r+"
argument_list|)
expr_stmt|;
comment|/* open stream */
if|if
condition|(
name|infile
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"Too many clients.\n"
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|infd
argument_list|,
literal|"Too many clients.\n"
argument_list|,
literal|18
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
comment|/* Prevent descriptor leak.. */
continue|continue;
block|}
name|str
operator|=
name|fgets
argument_list|(
name|string
argument_list|,
name|BUFSIZ
argument_list|,
name|infile
argument_list|)
expr_stmt|;
if|if
condition|(
name|str
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
literal|"fgets"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
comment|/* Prevent descriptor leak.. */
continue|continue;
block|}
name|openfiles
index|[
name|infd
index|]
operator|=
name|infile
expr_stmt|;
name|printf
argument_list|(
literal|"Client: %d %s"
argument_list|,
name|infd
argument_list|,
name|string
argument_list|)
expr_stmt|;
comment|/* If what we read did not end in a newline, 	     it means there is more.  Keep reading from the socket 	     and outputting to Emacs, until we get the newline.  */
while|while
condition|(
name|string
index|[
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|string
argument_list|,
name|BUFSIZ
argument_list|,
name|infile
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|infile
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|rmask
operator|&
literal|1
condition|)
comment|/* emacs sends codeword, fd, and string message */
block|{
comment|/* Read command codeword and fd */
name|scanf
argument_list|(
literal|"%s %d%*c"
argument_list|,
name|code
argument_list|,
operator|&
name|infd
argument_list|)
expr_stmt|;
comment|/* Transfer text from Emacs to the client, up to a newline.  */
name|infile
operator|=
name|openfiles
index|[
name|infd
index|]
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|fgets
argument_list|(
name|string
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|fprintf
argument_list|(
name|infile
argument_list|,
literal|"%s"
argument_list|,
name|string
argument_list|)
expr_stmt|;
if|if
condition|(
name|string
index|[
name|strlen
argument_list|(
name|string
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
break|break;
block|}
name|fflush
argument_list|(
name|infile
argument_list|)
expr_stmt|;
comment|/* If command is close, close connection to client.  */
if|if
condition|(
name|strncmp
argument_list|(
name|code
argument_list|,
literal|"Close:"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|infd
operator|>
literal|2
condition|)
block|{
name|fclose
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|infd
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
block|}
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* This is the SYSV IPC section */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ipc.h>
end_include

begin_include
include|#
directive|include
file|<sys/msg.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_decl_stmt
name|jmp_buf
name|msgenv
decl_stmt|;
end_decl_stmt

begin_macro
name|msgcatch
argument_list|()
end_macro

begin_block
block|{
name|longjmp
argument_list|(
name|msgenv
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* "THIS has to be fixed.  Remember, stderr may not exist...-rlk."    Incorrect.  This program runs as an inferior of Emacs.    Its stderr always exists--rms.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_function
name|main
parameter_list|()
block|{
name|int
name|s
decl_stmt|,
name|infd
decl_stmt|,
name|fromlen
decl_stmt|;
name|key_t
name|key
decl_stmt|;
name|struct
name|msgbuf
modifier|*
name|msgp
init|=
operator|(
expr|struct
name|msgbuf
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|msgp
operator|+
name|BUFSIZ
argument_list|)
decl_stmt|;
name|struct
name|msqid_ds
name|msg_st
decl_stmt|;
name|int
name|p
decl_stmt|;
name|char
modifier|*
name|homedir
decl_stmt|,
modifier|*
name|getenv
argument_list|()
decl_stmt|;
name|char
name|string
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|FILE
modifier|*
name|infile
decl_stmt|;
comment|/*    * Create a message queue using ~/.emacs_server as the path for ftok    */
if|if
condition|(
operator|(
name|homedir
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No home directory\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|string
argument_list|,
name|homedir
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|string
argument_list|,
literal|"/.emacs_server"
argument_list|)
expr_stmt|;
name|creat
argument_list|(
name|string
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
name|key
operator|=
name|ftok
argument_list|(
name|string
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* unlikely to be anyone else using it */
name|s
operator|=
name|msgget
argument_list|(
name|key
argument_list|,
literal|0600
operator||
name|IPC_CREAT
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"msgget"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Fork so we can close connection even if parent dies */
name|p
operator|=
name|fork
argument_list|()
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|msgenv
argument_list|)
condition|)
block|{
name|msgctl
argument_list|(
name|s
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|p
argument_list|,
name|SIGKILL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|msgcatch
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|msgcatch
argument_list|)
expr_stmt|;
comment|/* If parent goes away, remove message box and exit */
if|if
condition|(
name|p
operator|==
literal|0
condition|)
block|{
name|p
operator|=
name|getppid
argument_list|()
expr_stmt|;
name|setpgrp
argument_list|()
expr_stmt|;
comment|/* Gnu kills process group on exit */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|kill
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
condition|)
block|{
name|msgctl
argument_list|(
name|s
argument_list|,
name|IPC_RMID
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|fromlen
operator|=
name|msgrcv
argument_list|(
name|s
argument_list|,
name|msgp
argument_list|,
name|BUFSIZ
operator|-
literal|1
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"msgrcv"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msgctl
argument_list|(
name|s
argument_list|,
name|IPC_STAT
argument_list|,
operator|&
name|msg_st
argument_list|)
expr_stmt|;
name|strncpy
argument_list|(
name|string
argument_list|,
name|msgp
operator|->
name|mtext
argument_list|,
name|fromlen
argument_list|)
expr_stmt|;
name|string
index|[
name|fromlen
index|]
operator|=
literal|0
expr_stmt|;
comment|/* make sure */
comment|/* Newline is part of string.. */
name|printf
argument_list|(
literal|"Client: %d %s"
argument_list|,
name|s
argument_list|,
name|string
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* Now, wait for a wakeup */
name|fgets
argument_list|(
name|msgp
operator|->
name|mtext
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|msgp
operator|->
name|mtext
index|[
name|strlen
argument_list|(
name|msgp
operator|->
name|mtext
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/*	  strcpy (msgp->mtext, "done");*/
name|msgp
operator|->
name|mtype
operator|=
name|msg_st
operator|.
name|msg_lspid
expr_stmt|;
name|msgsnd
argument_list|(
name|s
argument_list|,
name|msgp
argument_list|,
name|strlen
argument_list|(
name|msgp
operator|->
name|mtext
argument_list|)
operator|+
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SYSV IPC */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* BSD&& IPC */
end_comment

end_unit

