begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Phil Karn, derived from original work by Jim Gillogly and  * Richard Outerbridge.  *  * Redistribution and use in source and binary forms are permitted  * provided that: (1) source distributions retain this entire copyright  * notice and comment, and (2) distributions including binaries display  * the following acknowledgement:  ``This product includes software  * developed by the University of California, Berkeley and its contributors''  * in the documentation or other materials provided with the distribution  * and in all advertising materials mentioning features or use of this  * software. Neither the name of the University nor the names of its  * contributors may be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)des.c	5.3 (Berkeley) 6/1/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* Sofware DES functions  * written 12 Dec 1986 by Phil Karn, KA9Q; large sections adapted from  * the 1977 public-domain program by Jim Gillogly  */
end_comment

begin_include
include|#
directive|include
file|<machine/endian.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_function_decl
specifier|static
name|long
name|byteswap
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|permute
argument_list|()
decl_stmt|,
name|perminit
argument_list|()
decl_stmt|,
name|spinit
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|long
name|f
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* Tables defined in the Data Encryption Standard documents */
end_comment

begin_comment
comment|/* initial permutation IP */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ip
index|[]
init|=
block|{
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|64
block|,
literal|56
block|,
literal|48
block|,
literal|40
block|,
literal|32
block|,
literal|24
block|,
literal|16
block|,
literal|8
block|,
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* final permutation IP^-1 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fp
index|[]
init|=
block|{
literal|40
block|,
literal|8
block|,
literal|48
block|,
literal|16
block|,
literal|56
block|,
literal|24
block|,
literal|64
block|,
literal|32
block|,
literal|39
block|,
literal|7
block|,
literal|47
block|,
literal|15
block|,
literal|55
block|,
literal|23
block|,
literal|63
block|,
literal|31
block|,
literal|38
block|,
literal|6
block|,
literal|46
block|,
literal|14
block|,
literal|54
block|,
literal|22
block|,
literal|62
block|,
literal|30
block|,
literal|37
block|,
literal|5
block|,
literal|45
block|,
literal|13
block|,
literal|53
block|,
literal|21
block|,
literal|61
block|,
literal|29
block|,
literal|36
block|,
literal|4
block|,
literal|44
block|,
literal|12
block|,
literal|52
block|,
literal|20
block|,
literal|60
block|,
literal|28
block|,
literal|35
block|,
literal|3
block|,
literal|43
block|,
literal|11
block|,
literal|51
block|,
literal|19
block|,
literal|59
block|,
literal|27
block|,
literal|34
block|,
literal|2
block|,
literal|42
block|,
literal|10
block|,
literal|50
block|,
literal|18
block|,
literal|58
block|,
literal|26
block|,
literal|33
block|,
literal|1
block|,
literal|41
block|,
literal|9
block|,
literal|49
block|,
literal|17
block|,
literal|57
block|,
literal|25
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* expansion operation matrix  * This is for reference only; it is unused in the code  * as the f() function performs it implicitly for speed  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|ei
index|[]
init|=
block|{
literal|32
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|4
block|,
literal|5
block|,
literal|4
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|8
block|,
literal|9
block|,
literal|10
block|,
literal|11
block|,
literal|12
block|,
literal|13
block|,
literal|12
block|,
literal|13
block|,
literal|14
block|,
literal|15
block|,
literal|16
block|,
literal|17
block|,
literal|16
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|23
block|,
literal|24
block|,
literal|25
block|,
literal|24
block|,
literal|25
block|,
literal|26
block|,
literal|27
block|,
literal|28
block|,
literal|29
block|,
literal|28
block|,
literal|29
block|,
literal|30
block|,
literal|31
block|,
literal|32
block|,
literal|1
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* permuted choice table (key) */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pc1
index|[]
init|=
block|{
literal|57
block|,
literal|49
block|,
literal|41
block|,
literal|33
block|,
literal|25
block|,
literal|17
block|,
literal|9
block|,
literal|1
block|,
literal|58
block|,
literal|50
block|,
literal|42
block|,
literal|34
block|,
literal|26
block|,
literal|18
block|,
literal|10
block|,
literal|2
block|,
literal|59
block|,
literal|51
block|,
literal|43
block|,
literal|35
block|,
literal|27
block|,
literal|19
block|,
literal|11
block|,
literal|3
block|,
literal|60
block|,
literal|52
block|,
literal|44
block|,
literal|36
block|,
literal|63
block|,
literal|55
block|,
literal|47
block|,
literal|39
block|,
literal|31
block|,
literal|23
block|,
literal|15
block|,
literal|7
block|,
literal|62
block|,
literal|54
block|,
literal|46
block|,
literal|38
block|,
literal|30
block|,
literal|22
block|,
literal|14
block|,
literal|6
block|,
literal|61
block|,
literal|53
block|,
literal|45
block|,
literal|37
block|,
literal|29
block|,
literal|21
block|,
literal|13
block|,
literal|5
block|,
literal|28
block|,
literal|20
block|,
literal|12
block|,
literal|4
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number left rotations of pc1 */
end_comment

begin_decl_stmt
specifier|static
name|char
name|totrot
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|6
block|,
literal|8
block|,
literal|10
block|,
literal|12
block|,
literal|14
block|,
literal|15
block|,
literal|17
block|,
literal|19
block|,
literal|21
block|,
literal|23
block|,
literal|25
block|,
literal|27
block|,
literal|28
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* permuted choice key (table) */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pc2
index|[]
init|=
block|{
literal|14
block|,
literal|17
block|,
literal|11
block|,
literal|24
block|,
literal|1
block|,
literal|5
block|,
literal|3
block|,
literal|28
block|,
literal|15
block|,
literal|6
block|,
literal|21
block|,
literal|10
block|,
literal|23
block|,
literal|19
block|,
literal|12
block|,
literal|4
block|,
literal|26
block|,
literal|8
block|,
literal|16
block|,
literal|7
block|,
literal|27
block|,
literal|20
block|,
literal|13
block|,
literal|2
block|,
literal|41
block|,
literal|52
block|,
literal|31
block|,
literal|37
block|,
literal|47
block|,
literal|55
block|,
literal|30
block|,
literal|40
block|,
literal|51
block|,
literal|45
block|,
literal|33
block|,
literal|48
block|,
literal|44
block|,
literal|49
block|,
literal|39
block|,
literal|56
block|,
literal|34
block|,
literal|53
block|,
literal|46
block|,
literal|42
block|,
literal|50
block|,
literal|36
block|,
literal|29
block|,
literal|32
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The (in)famous S-boxes */
end_comment

begin_decl_stmt
specifier|static
name|char
name|si
index|[
literal|8
index|]
index|[
literal|64
index|]
init|=
block|{
comment|/* S1 */
literal|14
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|2
block|,
literal|15
block|,
literal|11
block|,
literal|8
block|,
literal|3
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|5
block|,
literal|9
block|,
literal|0
block|,
literal|7
block|,
literal|0
block|,
literal|15
block|,
literal|7
block|,
literal|4
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|12
block|,
literal|11
block|,
literal|9
block|,
literal|5
block|,
literal|3
block|,
literal|8
block|,
literal|4
block|,
literal|1
block|,
literal|14
block|,
literal|8
block|,
literal|13
block|,
literal|6
block|,
literal|2
block|,
literal|11
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|3
block|,
literal|10
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|12
block|,
literal|8
block|,
literal|2
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|3
block|,
literal|14
block|,
literal|10
block|,
literal|0
block|,
literal|6
block|,
literal|13
block|,
comment|/* S2 */
literal|15
block|,
literal|1
block|,
literal|8
block|,
literal|14
block|,
literal|6
block|,
literal|11
block|,
literal|3
block|,
literal|4
block|,
literal|9
block|,
literal|7
block|,
literal|2
block|,
literal|13
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|10
block|,
literal|3
block|,
literal|13
block|,
literal|4
block|,
literal|7
block|,
literal|15
block|,
literal|2
block|,
literal|8
block|,
literal|14
block|,
literal|12
block|,
literal|0
block|,
literal|1
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|11
block|,
literal|5
block|,
literal|0
block|,
literal|14
block|,
literal|7
block|,
literal|11
block|,
literal|10
block|,
literal|4
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|8
block|,
literal|12
block|,
literal|6
block|,
literal|9
block|,
literal|3
block|,
literal|2
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|1
block|,
literal|3
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|11
block|,
literal|6
block|,
literal|7
block|,
literal|12
block|,
literal|0
block|,
literal|5
block|,
literal|14
block|,
literal|9
block|,
comment|/* S3 */
literal|10
block|,
literal|0
block|,
literal|9
block|,
literal|14
block|,
literal|6
block|,
literal|3
block|,
literal|15
block|,
literal|5
block|,
literal|1
block|,
literal|13
block|,
literal|12
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|2
block|,
literal|8
block|,
literal|13
block|,
literal|7
block|,
literal|0
block|,
literal|9
block|,
literal|3
block|,
literal|4
block|,
literal|6
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|14
block|,
literal|12
block|,
literal|11
block|,
literal|15
block|,
literal|1
block|,
literal|13
block|,
literal|6
block|,
literal|4
block|,
literal|9
block|,
literal|8
block|,
literal|15
block|,
literal|3
block|,
literal|0
block|,
literal|11
block|,
literal|1
block|,
literal|2
block|,
literal|12
block|,
literal|5
block|,
literal|10
block|,
literal|14
block|,
literal|7
block|,
literal|1
block|,
literal|10
block|,
literal|13
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|8
block|,
literal|7
block|,
literal|4
block|,
literal|15
block|,
literal|14
block|,
literal|3
block|,
literal|11
block|,
literal|5
block|,
literal|2
block|,
literal|12
block|,
comment|/* S4 */
literal|7
block|,
literal|13
block|,
literal|14
block|,
literal|3
block|,
literal|0
block|,
literal|6
block|,
literal|9
block|,
literal|10
block|,
literal|1
block|,
literal|2
block|,
literal|8
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|4
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|11
block|,
literal|5
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|3
block|,
literal|4
block|,
literal|7
block|,
literal|2
block|,
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|9
block|,
literal|10
block|,
literal|6
block|,
literal|9
block|,
literal|0
block|,
literal|12
block|,
literal|11
block|,
literal|7
block|,
literal|13
block|,
literal|15
block|,
literal|1
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|3
block|,
literal|15
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|8
block|,
literal|9
block|,
literal|4
block|,
literal|5
block|,
literal|11
block|,
literal|12
block|,
literal|7
block|,
literal|2
block|,
literal|14
block|,
comment|/* S5 */
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|1
block|,
literal|7
block|,
literal|10
block|,
literal|11
block|,
literal|6
block|,
literal|8
block|,
literal|5
block|,
literal|3
block|,
literal|15
block|,
literal|13
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|14
block|,
literal|11
block|,
literal|2
block|,
literal|12
block|,
literal|4
block|,
literal|7
block|,
literal|13
block|,
literal|1
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|10
block|,
literal|3
block|,
literal|9
block|,
literal|8
block|,
literal|6
block|,
literal|4
block|,
literal|2
block|,
literal|1
block|,
literal|11
block|,
literal|10
block|,
literal|13
block|,
literal|7
block|,
literal|8
block|,
literal|15
block|,
literal|9
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|3
block|,
literal|0
block|,
literal|14
block|,
literal|11
block|,
literal|8
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|14
block|,
literal|2
block|,
literal|13
block|,
literal|6
block|,
literal|15
block|,
literal|0
block|,
literal|9
block|,
literal|10
block|,
literal|4
block|,
literal|5
block|,
literal|3
block|,
comment|/* S6 */
literal|12
block|,
literal|1
block|,
literal|10
block|,
literal|15
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|13
block|,
literal|3
block|,
literal|4
block|,
literal|14
block|,
literal|7
block|,
literal|5
block|,
literal|11
block|,
literal|10
block|,
literal|15
block|,
literal|4
block|,
literal|2
block|,
literal|7
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|14
block|,
literal|0
block|,
literal|11
block|,
literal|3
block|,
literal|8
block|,
literal|9
block|,
literal|14
block|,
literal|15
block|,
literal|5
block|,
literal|2
block|,
literal|8
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|0
block|,
literal|4
block|,
literal|10
block|,
literal|1
block|,
literal|13
block|,
literal|11
block|,
literal|6
block|,
literal|4
block|,
literal|3
block|,
literal|2
block|,
literal|12
block|,
literal|9
block|,
literal|5
block|,
literal|15
block|,
literal|10
block|,
literal|11
block|,
literal|14
block|,
literal|1
block|,
literal|7
block|,
literal|6
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
comment|/* S7 */
literal|4
block|,
literal|11
block|,
literal|2
block|,
literal|14
block|,
literal|15
block|,
literal|0
block|,
literal|8
block|,
literal|13
block|,
literal|3
block|,
literal|12
block|,
literal|9
block|,
literal|7
block|,
literal|5
block|,
literal|10
block|,
literal|6
block|,
literal|1
block|,
literal|13
block|,
literal|0
block|,
literal|11
block|,
literal|7
block|,
literal|4
block|,
literal|9
block|,
literal|1
block|,
literal|10
block|,
literal|14
block|,
literal|3
block|,
literal|5
block|,
literal|12
block|,
literal|2
block|,
literal|15
block|,
literal|8
block|,
literal|6
block|,
literal|1
block|,
literal|4
block|,
literal|11
block|,
literal|13
block|,
literal|12
block|,
literal|3
block|,
literal|7
block|,
literal|14
block|,
literal|10
block|,
literal|15
block|,
literal|6
block|,
literal|8
block|,
literal|0
block|,
literal|5
block|,
literal|9
block|,
literal|2
block|,
literal|6
block|,
literal|11
block|,
literal|13
block|,
literal|8
block|,
literal|1
block|,
literal|4
block|,
literal|10
block|,
literal|7
block|,
literal|9
block|,
literal|5
block|,
literal|0
block|,
literal|15
block|,
literal|14
block|,
literal|2
block|,
literal|3
block|,
literal|12
block|,
comment|/* S8 */
literal|13
block|,
literal|2
block|,
literal|8
block|,
literal|4
block|,
literal|6
block|,
literal|15
block|,
literal|11
block|,
literal|1
block|,
literal|10
block|,
literal|9
block|,
literal|3
block|,
literal|14
block|,
literal|5
block|,
literal|0
block|,
literal|12
block|,
literal|7
block|,
literal|1
block|,
literal|15
block|,
literal|13
block|,
literal|8
block|,
literal|10
block|,
literal|3
block|,
literal|7
block|,
literal|4
block|,
literal|12
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|,
literal|0
block|,
literal|14
block|,
literal|9
block|,
literal|2
block|,
literal|7
block|,
literal|11
block|,
literal|4
block|,
literal|1
block|,
literal|9
block|,
literal|12
block|,
literal|14
block|,
literal|2
block|,
literal|0
block|,
literal|6
block|,
literal|10
block|,
literal|13
block|,
literal|15
block|,
literal|3
block|,
literal|5
block|,
literal|8
block|,
literal|2
block|,
literal|1
block|,
literal|14
block|,
literal|7
block|,
literal|4
block|,
literal|10
block|,
literal|8
block|,
literal|13
block|,
literal|15
block|,
literal|12
block|,
literal|9
block|,
literal|0
block|,
literal|3
block|,
literal|5
block|,
literal|6
block|,
literal|11
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 32-bit permutation function P used on the output of the S-boxes */
end_comment

begin_decl_stmt
specifier|static
name|char
name|p32i
index|[]
init|=
block|{
literal|16
block|,
literal|7
block|,
literal|20
block|,
literal|21
block|,
literal|29
block|,
literal|12
block|,
literal|28
block|,
literal|17
block|,
literal|1
block|,
literal|15
block|,
literal|23
block|,
literal|26
block|,
literal|5
block|,
literal|18
block|,
literal|31
block|,
literal|10
block|,
literal|2
block|,
literal|8
block|,
literal|24
block|,
literal|14
block|,
literal|32
block|,
literal|27
block|,
literal|3
block|,
literal|9
block|,
literal|19
block|,
literal|13
block|,
literal|30
block|,
literal|6
block|,
literal|22
block|,
literal|11
block|,
literal|4
block|,
literal|25
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* End of DES-defined tables */
end_comment

begin_comment
comment|/* Lookup tables initialized once only at startup by desinit() */
end_comment

begin_expr_stmt
specifier|static
name|long
argument_list|(
operator|*
name|sp
argument_list|)
index|[
literal|64
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Combined S and P boxes */
end_comment

begin_expr_stmt
specifier|static
name|char
argument_list|(
operator|*
name|iperm
argument_list|)
index|[
literal|16
index|]
index|[
literal|8
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* Initial and final permutations */
end_comment

begin_expr_stmt
specifier|static
name|char
argument_list|(
operator|*
name|fperm
argument_list|)
index|[
literal|16
index|]
index|[
literal|8
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* 8 6-bit subkeys for each of 16 rounds, initialized by setkey() */
end_comment

begin_expr_stmt
specifier|static
name|char
argument_list|(
operator|*
name|kn
argument_list|)
index|[
literal|8
index|]
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* bit 0 is left-most in byte */
end_comment

begin_decl_stmt
specifier|static
name|int
name|bytebit
index|[]
init|=
block|{
literal|0200
block|,
literal|0100
block|,
literal|040
block|,
literal|020
block|,
literal|010
block|,
literal|04
block|,
literal|02
block|,
literal|01
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|nibblebit
index|[]
init|=
block|{
literal|010
block|,
literal|04
block|,
literal|02
block|,
literal|01
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|desmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Allocate space and initialize DES lookup arrays  * mode == 0: standard Data Encryption Algorithm  * mode == 1: DEA without initial and final permutations for speed  * mode == 2: DEA without permutations and with 128-byte key (completely  *            independent subkeys for each round)  */
end_comment

begin_function
name|int
name|desinit
parameter_list|(
name|mode
parameter_list|)
name|int
name|mode
decl_stmt|;
block|{
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
if|if
condition|(
name|sp
operator|!=
name|NULL
condition|)
block|{
comment|/* Already initialized */
return|return
literal|0
return|;
block|}
name|desmode
operator|=
name|mode
expr_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
operator|(
name|long
argument_list|(
operator|*
argument_list|)
index|[
literal|64
index|]
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|long
argument_list|)
operator|*
literal|8
operator|*
literal|64
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|spinit
argument_list|()
expr_stmt|;
name|kn
operator|=
operator|(
name|char
argument_list|(
operator|*
argument_list|)
index|[
literal|8
index|]
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|8
operator|*
literal|16
argument_list|)
expr_stmt|;
if|if
condition|(
name|kn
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
if|if
condition|(
name|mode
operator|==
literal|1
operator|||
name|mode
operator|==
literal|2
condition|)
comment|/* No permutations */
return|return
literal|0
return|;
name|iperm
operator|=
operator|(
name|char
argument_list|(
operator|*
argument_list|)
index|[
literal|16
index|]
index|[
literal|8
index|]
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|16
operator|*
literal|16
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|iperm
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kn
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|perminit
argument_list|(
name|iperm
argument_list|,
name|ip
argument_list|)
expr_stmt|;
name|fperm
operator|=
operator|(
name|char
argument_list|(
operator|*
argument_list|)
index|[
literal|16
index|]
index|[
literal|8
index|]
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|*
literal|16
operator|*
literal|16
operator|*
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|fperm
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kn
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iperm
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
name|perminit
argument_list|(
name|fperm
argument_list|,
name|fp
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Free up storage used by DES */
end_comment

begin_function
name|void
name|desdone
parameter_list|()
block|{
if|if
condition|(
name|sp
operator|==
name|NULL
condition|)
return|return;
comment|/* Already done */
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|sp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kn
argument_list|)
expr_stmt|;
if|if
condition|(
name|iperm
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|iperm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fperm
operator|!=
name|NULL
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|fperm
argument_list|)
expr_stmt|;
name|sp
operator|=
name|NULL
expr_stmt|;
name|iperm
operator|=
name|NULL
expr_stmt|;
name|fperm
operator|=
name|NULL
expr_stmt|;
name|kn
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Set key (initialize key schedule array) */
end_comment

begin_function
name|void
name|setkey
parameter_list|(
name|key
parameter_list|)
name|char
modifier|*
name|key
decl_stmt|;
comment|/* 64 bits (will use only 56) */
block|{
name|char
name|pc1m
index|[
literal|56
index|]
decl_stmt|;
comment|/* place to modify pc1 into */
name|char
name|pcr
index|[
literal|56
index|]
decl_stmt|;
comment|/* place to rotate pc1 into */
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|l
decl_stmt|;
name|int
name|m
decl_stmt|;
comment|/* In mode 2, the 128 bytes of subkey are set directly from the 	 * user's key, allowing him to use completely independent 	 * subkeys for each round. Note that the user MUST specify a 	 * full 128 bytes. 	 * 	 * I would like to think that this technique gives the NSA a real 	 * headache, but I'm not THAT naive. 	 */
if|if
condition|(
name|desmode
operator|==
literal|2
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
name|kn
index|[
name|i
index|]
index|[
name|j
index|]
operator|=
operator|*
name|key
operator|++
expr_stmt|;
return|return;
block|}
comment|/* Clear key schedule */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|kn
argument_list|,
literal|0
argument_list|,
literal|16
operator|*
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|56
condition|;
name|j
operator|++
control|)
block|{
comment|/* convert pc1 to bits of key */
name|l
operator|=
name|pc1
index|[
name|j
index|]
operator|-
literal|1
expr_stmt|;
comment|/* integer bit location	 */
name|m
operator|=
name|l
operator|&
literal|07
expr_stmt|;
comment|/* find bit		 */
name|pc1m
index|[
name|j
index|]
operator|=
operator|(
name|key
index|[
name|l
operator|>>
literal|3
index|]
operator|&
comment|/* find which key byte l is in */
name|bytebit
index|[
name|m
index|]
operator|)
comment|/* and which bit of that byte */
condition|?
literal|1
else|:
literal|0
expr_stmt|;
comment|/* and store 1-bit result */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
block|{
comment|/* key chunk for each iteration */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|56
condition|;
name|j
operator|++
control|)
comment|/* rotate pc1 the right amount */
name|pcr
index|[
name|j
index|]
operator|=
name|pc1m
index|[
operator|(
name|l
operator|=
name|j
operator|+
name|totrot
index|[
name|i
index|]
operator|)
operator|<
operator|(
name|j
operator|<
literal|28
condition|?
literal|28
else|:
literal|56
operator|)
condition|?
name|l
else|:
name|l
operator|-
literal|28
index|]
expr_stmt|;
comment|/* rotate left and right halves independently */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|48
condition|;
name|j
operator|++
control|)
block|{
comment|/* select bits individually */
comment|/* check bit that goes to kn[j] */
if|if
condition|(
name|pcr
index|[
name|pc2
index|[
name|j
index|]
operator|-
literal|1
index|]
condition|)
block|{
comment|/* mask it in if it's there */
name|l
operator|=
name|j
operator|%
literal|6
expr_stmt|;
name|kn
index|[
name|i
index|]
index|[
name|j
operator|/
literal|6
index|]
operator||=
name|bytebit
index|[
name|l
index|]
operator|>>
literal|2
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* In-place encryption of 64-bit block */
end_comment

begin_function
name|void
name|endes
parameter_list|(
name|block
parameter_list|)
name|char
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|long
name|left
decl_stmt|,
name|right
decl_stmt|;
specifier|register
name|char
modifier|*
name|knp
decl_stmt|;
name|long
name|work
index|[
literal|2
index|]
decl_stmt|;
comment|/* Working data storage */
name|permute
argument_list|(
name|block
argument_list|,
name|iperm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|work
argument_list|)
expr_stmt|;
comment|/* Initial Permutation */
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|left
operator|=
name|byteswap
argument_list|(
name|work
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|right
operator|=
name|byteswap
argument_list|(
name|work
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|left
operator|=
name|work
index|[
literal|0
index|]
expr_stmt|;
name|right
operator|=
name|work
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Do the 16 rounds. 	 * The rounds are numbered from 0 to 15. On even rounds 	 * the right half is fed to f() and the result exclusive-ORs 	 * the left half; on odd rounds the reverse is done. 	 */
name|knp
operator|=
operator|&
name|kn
index|[
literal|0
index|]
index|[
literal|0
index|]
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|+=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
comment|/* Left/right half swap, plus byte swap if little-endian */
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|work
index|[
literal|1
index|]
operator|=
name|byteswap
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|work
index|[
literal|0
index|]
operator|=
name|byteswap
argument_list|(
name|right
argument_list|)
expr_stmt|;
else|#
directive|else
name|work
index|[
literal|0
index|]
operator|=
name|right
expr_stmt|;
name|work
index|[
literal|1
index|]
operator|=
name|left
expr_stmt|;
endif|#
directive|endif
name|permute
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
argument_list|,
name|fperm
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* Inverse initial permutation */
block|}
end_function

begin_comment
comment|/* In-place decryption of 64-bit block. This function is the mirror  * image of encryption; exactly the same steps are taken, but in  * reverse order  */
end_comment

begin_function
name|void
name|dedes
parameter_list|(
name|block
parameter_list|)
name|char
modifier|*
name|block
decl_stmt|;
block|{
specifier|register
name|long
name|left
decl_stmt|,
name|right
decl_stmt|;
specifier|register
name|char
modifier|*
name|knp
decl_stmt|;
name|long
name|work
index|[
literal|2
index|]
decl_stmt|;
comment|/* Working data storage */
name|permute
argument_list|(
name|block
argument_list|,
name|iperm
argument_list|,
operator|(
name|char
operator|*
operator|)
name|work
argument_list|)
expr_stmt|;
comment|/* Initial permutation */
comment|/* Left/right half swap, plus byte swap if little-endian */
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|right
operator|=
name|byteswap
argument_list|(
name|work
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|left
operator|=
name|byteswap
argument_list|(
name|work
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|#
directive|else
name|right
operator|=
name|work
index|[
literal|0
index|]
expr_stmt|;
name|left
operator|=
name|work
index|[
literal|1
index|]
expr_stmt|;
endif|#
directive|endif
comment|/* Do the 16 rounds in reverse order. 	 * The rounds are numbered from 15 to 0. On even rounds 	 * the right half is fed to f() and the result exclusive-ORs 	 * the left half; on odd rounds the reverse is done. 	 */
name|knp
operator|=
operator|&
name|kn
index|[
literal|15
index|]
index|[
literal|0
index|]
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|right
operator|^=
name|f
argument_list|(
name|left
argument_list|,
name|knp
argument_list|)
expr_stmt|;
name|knp
operator|-=
literal|8
expr_stmt|;
name|left
operator|^=
name|f
argument_list|(
name|right
argument_list|,
name|knp
argument_list|)
expr_stmt|;
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
name|work
index|[
literal|0
index|]
operator|=
name|byteswap
argument_list|(
name|left
argument_list|)
expr_stmt|;
name|work
index|[
literal|1
index|]
operator|=
name|byteswap
argument_list|(
name|right
argument_list|)
expr_stmt|;
else|#
directive|else
name|work
index|[
literal|0
index|]
operator|=
name|left
expr_stmt|;
name|work
index|[
literal|1
index|]
operator|=
name|right
expr_stmt|;
endif|#
directive|endif
name|permute
argument_list|(
operator|(
name|char
operator|*
operator|)
name|work
argument_list|,
name|fperm
argument_list|,
name|block
argument_list|)
expr_stmt|;
comment|/* Inverse initial permutation */
block|}
end_function

begin_comment
comment|/* Permute inblock with perm */
end_comment

begin_function
specifier|static
name|void
name|permute
parameter_list|(
name|inblock
parameter_list|,
name|perm
parameter_list|,
name|outblock
parameter_list|)
name|char
modifier|*
name|inblock
decl_stmt|,
decl|*
name|outblock
decl_stmt|;
end_function

begin_comment
comment|/* result into outblock,64 bits */
end_comment

begin_decl_stmt
name|char
name|perm
index|[
literal|16
index|]
index|[
literal|16
index|]
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 2K bytes defining perm. */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|ib
decl_stmt|,
modifier|*
name|ob
decl_stmt|;
comment|/* ptr to input or output block */
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
specifier|register
name|int
name|j
decl_stmt|;
if|if
condition|(
name|perm
operator|==
name|NULL
condition|)
block|{
comment|/* No permutation, just copy */
name|memcpy
argument_list|(
name|outblock
argument_list|,
name|inblock
argument_list|,
literal|8
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Clear output block */
name|memset
argument_list|(
name|outblock
argument_list|,
literal|'\0'
argument_list|,
literal|8
argument_list|)
expr_stmt|;
name|ib
operator|=
name|inblock
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|+=
literal|2
operator|,
name|ib
operator|++
control|)
block|{
comment|/* for each input nibble */
name|ob
operator|=
name|outblock
expr_stmt|;
name|p
operator|=
name|perm
index|[
name|j
index|]
index|[
operator|(
operator|*
name|ib
operator|>>
literal|4
operator|)
operator|&
literal|0xf
index|]
expr_stmt|;
name|q
operator|=
name|perm
index|[
name|j
operator|+
literal|1
index|]
index|[
operator|*
name|ib
operator|&
literal|0xf
index|]
expr_stmt|;
comment|/* and each output byte, OR the masks together */
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
operator|*
name|ob
operator|++
operator||=
operator|*
name|p
operator|++
operator||
operator|*
name|q
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* The nonlinear function f(r,k), the heart of DES */
end_comment

begin_function
specifier|static
name|long
name|f
parameter_list|(
name|r
parameter_list|,
name|subkey
parameter_list|)
specifier|register
name|long
name|r
decl_stmt|;
comment|/* 32 bits */
specifier|register
name|char
modifier|*
name|subkey
decl_stmt|;
comment|/* 48-bit key for this round */
block|{
specifier|register
name|long
modifier|*
name|spp
decl_stmt|;
specifier|register
name|long
name|rval
decl_stmt|,
name|rt
decl_stmt|;
specifier|register
name|int
name|er
decl_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|"f(%08lx, %02x %02x %02x %02x %02x %02x %02x %02x) = "
argument_list|,
name|r
argument_list|,
name|subkey
index|[
literal|0
index|]
argument_list|,
name|subkey
index|[
literal|1
index|]
argument_list|,
name|subkey
index|[
literal|2
index|]
argument_list|,
name|subkey
index|[
literal|3
index|]
argument_list|,
name|subkey
index|[
literal|4
index|]
argument_list|,
name|subkey
index|[
literal|5
index|]
argument_list|,
name|subkey
index|[
literal|6
index|]
argument_list|,
name|subkey
index|[
literal|7
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Run E(R) ^ K through the combined S& P boxes. 	 * This code takes advantage of a convenient regularity in 	 * E, namely that each group of 6 bits in E(R) feeding 	 * a single S-box is a contiguous segment of R. 	 */
name|subkey
operator|+=
literal|7
expr_stmt|;
comment|/* Compute E(R) for each block of 6 bits, and run thru boxes */
name|er
operator|=
operator|(
operator|(
name|int
operator|)
name|r
operator|<<
literal|1
operator|)
operator||
operator|(
operator|(
name|r
operator|&
literal|0x80000000
operator|)
condition|?
literal|1
else|:
literal|0
operator|)
expr_stmt|;
name|spp
operator|=
operator|&
name|sp
index|[
literal|7
index|]
index|[
literal|0
index|]
expr_stmt|;
name|rval
operator|=
name|spp
index|[
operator|(
name|er
operator|^
operator|*
name|subkey
operator|--
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|spp
operator|-=
literal|64
expr_stmt|;
name|rt
operator|=
operator|(
name|unsigned
name|long
operator|)
name|r
operator|>>
literal|3
expr_stmt|;
name|rval
operator||=
name|spp
index|[
operator|(
operator|(
name|int
operator|)
name|rt
operator|^
operator|*
name|subkey
operator|--
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|spp
operator|-=
literal|64
expr_stmt|;
name|rt
operator|>>=
literal|4
expr_stmt|;
name|rval
operator||=
name|spp
index|[
operator|(
operator|(
name|int
operator|)
name|rt
operator|^
operator|*
name|subkey
operator|--
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|spp
operator|-=
literal|64
expr_stmt|;
name|rt
operator|>>=
literal|4
expr_stmt|;
name|rval
operator||=
name|spp
index|[
operator|(
operator|(
name|int
operator|)
name|rt
operator|^
operator|*
name|subkey
operator|--
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|spp
operator|-=
literal|64
expr_stmt|;
name|rt
operator|>>=
literal|4
expr_stmt|;
name|rval
operator||=
name|spp
index|[
operator|(
operator|(
name|int
operator|)
name|rt
operator|^
operator|*
name|subkey
operator|--
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|spp
operator|-=
literal|64
expr_stmt|;
name|rt
operator|>>=
literal|4
expr_stmt|;
name|rval
operator||=
name|spp
index|[
operator|(
operator|(
name|int
operator|)
name|rt
operator|^
operator|*
name|subkey
operator|--
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|spp
operator|-=
literal|64
expr_stmt|;
name|rt
operator|>>=
literal|4
expr_stmt|;
name|rval
operator||=
name|spp
index|[
operator|(
operator|(
name|int
operator|)
name|rt
operator|^
operator|*
name|subkey
operator|--
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
name|spp
operator|-=
literal|64
expr_stmt|;
name|rt
operator|>>=
literal|4
expr_stmt|;
name|rt
operator||=
operator|(
name|r
operator|&
literal|1
operator|)
operator|<<
literal|5
expr_stmt|;
name|rval
operator||=
name|spp
index|[
operator|(
operator|(
name|int
operator|)
name|rt
operator|^
operator|*
name|subkey
operator|)
operator|&
literal|0x3f
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|TRACE
name|printf
argument_list|(
literal|" %08lx\n"
argument_list|,
name|rval
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|rval
return|;
block|}
end_function

begin_comment
comment|/* initialize a perm array */
end_comment

begin_function
specifier|static
name|void
name|perminit
parameter_list|(
name|perm
parameter_list|,
name|p
parameter_list|)
name|char
name|perm
index|[
literal|16
index|]
index|[
literal|16
index|]
index|[
literal|8
index|]
decl_stmt|;
comment|/* 64-bit, either init or final */
name|char
name|p
index|[
literal|64
index|]
decl_stmt|;
block|{
specifier|register
name|int
name|l
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|i
decl_stmt|,
name|m
decl_stmt|;
comment|/* Clear the permutation array */
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|perm
argument_list|,
literal|0
argument_list|,
literal|16
operator|*
literal|16
operator|*
literal|8
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|16
condition|;
name|i
operator|++
control|)
comment|/* each input nibble position */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|16
condition|;
name|j
operator|++
control|)
comment|/* each possible input nibble */
for|for
control|(
name|k
operator|=
literal|0
init|;
name|k
operator|<
literal|64
condition|;
name|k
operator|++
control|)
comment|/* each output bit position */
block|{
name|l
operator|=
name|p
index|[
name|k
index|]
operator|-
literal|1
expr_stmt|;
comment|/* where does this bit come from*/
if|if
condition|(
operator|(
name|l
operator|>>
literal|2
operator|)
operator|!=
name|i
condition|)
comment|/* does it come from input posn?*/
continue|continue;
comment|/* if not, bit k is 0	 */
if|if
condition|(
operator|!
operator|(
name|j
operator|&
name|nibblebit
index|[
name|l
operator|&
literal|3
index|]
operator|)
condition|)
continue|continue;
comment|/* any such bit in input? */
name|m
operator|=
name|k
operator|&
literal|07
expr_stmt|;
comment|/* which bit is this in the byte*/
name|perm
index|[
name|i
index|]
index|[
name|j
index|]
index|[
name|k
operator|>>
literal|3
index|]
operator||=
name|bytebit
index|[
name|m
index|]
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Initialize the lookup table for the combined S and P boxes */
end_comment

begin_function
specifier|static
name|void
name|spinit
parameter_list|()
block|{
name|char
name|pbox
index|[
literal|32
index|]
decl_stmt|;
name|int
name|p
decl_stmt|,
name|i
decl_stmt|,
name|s
decl_stmt|,
name|j
decl_stmt|,
name|rowcol
decl_stmt|;
name|long
name|val
decl_stmt|;
comment|/* Compute pbox, the inverse of p32i. 	 * This is easier to work with 	 */
for|for
control|(
name|p
operator|=
literal|0
init|;
name|p
operator|<
literal|32
condition|;
name|p
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|p32i
index|[
name|i
index|]
operator|-
literal|1
operator|==
name|p
condition|)
block|{
name|pbox
index|[
name|p
index|]
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
block|}
for|for
control|(
name|s
operator|=
literal|0
init|;
name|s
operator|<
literal|8
condition|;
name|s
operator|++
control|)
block|{
comment|/* For each S-box */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|64
condition|;
name|i
operator|++
control|)
block|{
comment|/* For each possible input */
name|val
operator|=
literal|0
expr_stmt|;
comment|/* The row number is formed from the first and last 			 * bits; the column number is from the middle 4 			 */
name|rowcol
operator|=
operator|(
name|i
operator|&
literal|32
operator|)
operator||
operator|(
operator|(
name|i
operator|&
literal|1
operator|)
condition|?
literal|16
else|:
literal|0
operator|)
operator||
operator|(
operator|(
name|i
operator|>>
literal|1
operator|)
operator|&
literal|0xf
operator|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|4
condition|;
name|j
operator|++
control|)
block|{
comment|/* For each output bit */
if|if
condition|(
name|si
index|[
name|s
index|]
index|[
name|rowcol
index|]
operator|&
operator|(
literal|8
operator|>>
name|j
operator|)
condition|)
block|{
name|val
operator||=
literal|1L
operator|<<
operator|(
literal|31
operator|-
name|pbox
index|[
literal|4
operator|*
name|s
operator|+
name|j
index|]
operator|)
expr_stmt|;
block|}
block|}
name|sp
index|[
name|s
index|]
index|[
name|i
index|]
operator|=
name|val
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"sp[%d][%2d] = %08lx\n"
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|sp
index|[
name|s
index|]
index|[
name|i
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
block|}
end_function

begin_if
if|#
directive|if
name|BYTE_ORDER
operator|==
name|LITTLE_ENDIAN
end_if

begin_comment
comment|/* Byte swap a long */
end_comment

begin_function
specifier|static
name|long
name|byteswap
parameter_list|(
name|x
parameter_list|)
name|unsigned
name|long
name|x
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|,
name|tmp
decl_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|x
expr_stmt|;
name|tmp
operator|=
name|cp
index|[
literal|3
index|]
expr_stmt|;
name|cp
index|[
literal|3
index|]
operator|=
name|cp
index|[
literal|0
index|]
expr_stmt|;
name|cp
index|[
literal|0
index|]
operator|=
name|tmp
expr_stmt|;
name|tmp
operator|=
name|cp
index|[
literal|2
index|]
expr_stmt|;
name|cp
index|[
literal|2
index|]
operator|=
name|cp
index|[
literal|1
index|]
expr_stmt|;
name|cp
index|[
literal|1
index|]
operator|=
name|tmp
expr_stmt|;
return|return
name|x
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

