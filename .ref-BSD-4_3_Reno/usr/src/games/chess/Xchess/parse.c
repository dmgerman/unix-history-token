begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.2 $ on $Date: 86/11/23 17:17:59 $  *           $Source: /users/faustus/xchess/RCS/parse.c,v $  * Copyright (c) 1986 Wayne A. Christopher, U. C. Berkeley CAD Group  *	Permission is granted to do anything with this code except sell it  *	or remove this message.  *  * Parse a sequence of chess moves...  */
end_comment

begin_include
include|#
directive|include
file|"xchess.h"
end_include

begin_decl_stmt
name|bool
name|loading_flag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|loading_paused
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Load a record file in.  This returns a number of things -- the board, the  * list of moves, and whose turn it is.  */
end_comment

begin_function
name|void
name|load_game
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|;
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|bool
name|eflag
decl_stmt|;
name|move
modifier|*
name|m
decl_stmt|;
name|board
modifier|*
name|tmpboard
init|=
name|alloc
argument_list|(
name|board
argument_list|)
decl_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|file
argument_list|,
literal|"xchess.game"
argument_list|)
operator|&&
name|saveflag
condition|)
block|{
name|message_add
argument_list|(
name|win1
argument_list|,
literal|"Oops, I just overwrote the\nfile xchess.game...\n"
argument_list|,
name|true
argument_list|)
expr_stmt|;
name|message_add
argument_list|(
name|win1
argument_list|,
literal|"I hope you had another copy.\n"
argument_list|,
name|true
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|file
argument_list|,
literal|"r"
argument_list|)
operator|)
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Get a few lines... */
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|message_add
argument_list|(
name|win1
argument_list|,
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
name|message_add
argument_list|(
name|win2
argument_list|,
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|message_add
argument_list|(
name|win1
argument_list|,
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
condition|)
name|message_add
argument_list|(
name|win2
argument_list|,
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
name|buf
argument_list|,
literal|"\tenglish\n"
argument_list|)
condition|)
name|eflag
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|eq
argument_list|(
name|buf
argument_list|,
literal|"\talgebraic\n"
argument_list|)
condition|)
name|eflag
operator|=
name|false
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't decide whether this is english...\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|board_init
argument_list|(
name|tmpboard
argument_list|)
expr_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
name|m
operator|=
name|parse_file
argument_list|(
name|fp
argument_list|,
name|tmpboard
argument_list|,
name|eflag
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|tmpboard
argument_list|)
expr_stmt|;
comment|/* Now apply these moves to the board we were given... */
name|loading_flag
operator|=
name|true
expr_stmt|;
while|while
condition|(
name|m
condition|)
block|{
if|if
condition|(
operator|!
name|quickflag
condition|)
name|XSync
argument_list|(
name|win1
operator|->
name|display
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|win_process
argument_list|(
name|true
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quickflag
condition|)
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|loading_paused
condition|)
block|{
name|prog_move
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
name|m
operator|->
name|next
expr_stmt|;
block|}
block|}
name|loading_flag
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|line
condition|)
name|message_add
argument_list|(
name|win1
argument_list|,
name|line
argument_list|,
name|false
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|fp
argument_list|)
condition|)
name|message_add
argument_list|(
name|win1
argument_list|,
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_comment
comment|/* Given a starting position (usually the beginning board configuration),  * read in a file of moves.  */
end_comment

begin_function
name|move
modifier|*
name|parse_file
parameter_list|(
name|fp
parameter_list|,
name|b
parameter_list|,
name|english
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|board
modifier|*
name|b
decl_stmt|;
name|bool
name|english
decl_stmt|;
block|{
name|move
modifier|*
name|mvs
init|=
name|NULL
decl_stmt|,
modifier|*
name|end
init|=
name|NULL
decl_stmt|;
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|fp
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|buf
operator|==
literal|'#'
condition|)
continue|continue;
name|s
operator|=
name|buf
expr_stmt|;
comment|/* The move number... */
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|gettok
argument_list|(
operator|&
name|s
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|t
argument_list|)
condition|)
block|{
name|line
operator|=
name|copy
argument_list|(
name|buf
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|gettok
argument_list|(
operator|&
name|s
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|end
condition|)
name|end
operator|=
name|end
operator|->
name|next
operator|=
operator|(
name|english
condition|?
name|parse_move
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|WHITE
argument_list|)
else|:
name|parse_imove
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|WHITE
argument_list|)
operator|)
expr_stmt|;
else|else
name|mvs
operator|=
name|end
operator|=
operator|(
name|english
condition|?
name|parse_move
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|WHITE
argument_list|)
else|:
name|parse_imove
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|WHITE
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't parse %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|board_move
argument_list|(
name|b
argument_list|,
name|end
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|t
operator|=
name|gettok
argument_list|(
operator|&
name|s
argument_list|)
operator|)
condition|)
break|break;
if|if
condition|(
name|end
condition|)
name|end
operator|=
name|end
operator|->
name|next
operator|=
operator|(
name|english
condition|?
name|parse_move
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|BLACK
argument_list|)
else|:
name|parse_imove
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|BLACK
argument_list|)
operator|)
expr_stmt|;
else|else
name|mvs
operator|=
name|end
operator|=
operator|(
name|english
condition|?
name|parse_move
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|BLACK
argument_list|)
else|:
name|parse_imove
argument_list|(
name|b
argument_list|,
name|t
argument_list|,
name|BLACK
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|end
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't parse %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|board_move
argument_list|(
name|b
argument_list|,
name|end
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|mvs
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse a move.  The move format accepted is as follows -  *	move:		spec-spec  *	capture:	specxspec  *	kcastle:	2 o's  *	qcastle:	3 o's  * A spec is either piece/pos, piece, or just pos.  A pos consists of a column  * name followed by a row number.  If the column name is kr, kn, kb, k, q,  * qb, qn, or qr, then the row number is according to the english system,  * or if it is a-h then it is according to the international system.  *   *** As of now the spec must include the position.  */
end_comment

begin_function
name|move
modifier|*
name|parse_move
parameter_list|(
name|b
parameter_list|,
name|str
parameter_list|,
name|w
parameter_list|)
name|board
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|color
name|w
decl_stmt|;
block|{
name|move
modifier|*
name|m
init|=
name|alloc
argument_list|(
name|move
argument_list|)
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|spec1
index|[
literal|16
index|]
decl_stmt|,
name|spec2
index|[
literal|16
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"parsing %s\n"
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* Check for castles. */
for|for
control|(
name|s
operator|=
name|str
operator|,
name|i
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'o'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'O'
operator|)
condition|)
name|i
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|2
condition|)
block|{
name|m
operator|->
name|type
operator|=
name|KCASTLE
expr_stmt|;
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|KING
expr_stmt|;
name|m
operator|->
name|piece
operator|.
name|color
operator|=
name|w
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
literal|3
condition|)
block|{
name|m
operator|->
name|type
operator|=
name|QCASTLE
expr_stmt|;
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|KING
expr_stmt|;
name|m
operator|->
name|piece
operator|.
name|color
operator|=
name|w
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
if|if
condition|(
name|index
argument_list|(
name|str
argument_list|,
literal|'-'
argument_list|)
condition|)
name|m
operator|->
name|type
operator|=
name|MOVE
expr_stmt|;
elseif|else
if|if
condition|(
name|index
argument_list|(
name|str
argument_list|,
literal|'x'
argument_list|)
condition|)
name|m
operator|->
name|type
operator|=
name|CAPTURE
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|(
name|str
index|[
name|i
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|str
index|[
name|i
index|]
operator|==
literal|'-'
operator|)
condition|)
break|break;
else|else
name|spec1
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|spec1
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|++
operator|,
name|j
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
if|if
condition|(
operator|(
name|str
index|[
name|i
index|]
operator|==
literal|'x'
operator|)
operator|||
operator|(
name|str
index|[
name|i
index|]
operator|==
literal|'-'
operator|)
condition|)
break|break;
else|else
name|spec2
index|[
name|j
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|spec2
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Now decode the specifications. */
name|s
operator|=
name|spec1
expr_stmt|;
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|PAWN
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|ROOK
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|KNIGHT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|BISHOP
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|QUEEN
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|m
operator|->
name|piece
operator|.
name|type
operator|=
name|KING
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|piece
operator|.
name|color
operator|=
name|w
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
comment|/* Now get the {q,k}{,b,n,r}n string... */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'r'
operator|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|0
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'n'
operator|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|1
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|2
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|3
operator|,
name|s
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|4
operator|,
name|s
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|5
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'n'
operator|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|6
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'r'
operator|)
condition|)
name|m
operator|->
name|fromx
operator|=
literal|7
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
name|m
operator|->
name|fromy
operator|=
operator|(
operator|(
name|w
operator|==
name|WHITE
operator|)
condition|?
operator|(
name|SIZE
operator|-
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
else|:
operator|(
name|atoi
argument_list|(
name|s
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
name|m
operator|->
name|fromx
index|]
operator|.
name|color
operator|!=
name|w
operator|)
operator|||
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
name|m
operator|->
name|fromx
index|]
operator|.
name|type
operator|!=
name|m
operator|->
name|piece
operator|.
name|type
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: bad stuff\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|s
operator|=
name|spec2
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|type
operator|==
name|CAPTURE
condition|)
block|{
switch|switch
condition|(
operator|*
name|s
condition|)
block|{
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|m
operator|->
name|taken
operator|.
name|type
operator|=
name|PAWN
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
name|m
operator|->
name|taken
operator|.
name|type
operator|=
name|ROOK
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
case|case
literal|'N'
case|:
name|m
operator|->
name|taken
operator|.
name|type
operator|=
name|KNIGHT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
name|m
operator|->
name|taken
operator|.
name|type
operator|=
name|BISHOP
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
case|case
literal|'Q'
case|:
name|m
operator|->
name|taken
operator|.
name|type
operator|=
name|QUEEN
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
name|m
operator|->
name|taken
operator|.
name|type
operator|=
name|KING
expr_stmt|;
break|break;
default|default:
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|m
operator|->
name|taken
operator|.
name|color
operator|=
operator|(
operator|(
name|w
operator|==
name|WHITE
operator|)
condition|?
name|BLACK
else|:
name|WHITE
operator|)
expr_stmt|;
name|s
operator|+=
literal|2
expr_stmt|;
block|}
comment|/* Now get the {q,k}{,b,n,r}n string... */
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'r'
operator|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|0
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'n'
operator|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|1
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|2
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'q'
operator|)
operator|&&
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|3
operator|,
name|s
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
name|isdigit
argument_list|(
name|s
index|[
literal|1
index|]
argument_list|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|4
operator|,
name|s
operator|+=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'b'
operator|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|5
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'n'
operator|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|6
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|s
index|[
literal|0
index|]
operator|==
literal|'k'
operator|)
operator|&&
operator|(
name|s
index|[
literal|1
index|]
operator|==
literal|'r'
operator|)
condition|)
name|m
operator|->
name|tox
operator|=
literal|7
operator|,
name|s
operator|+=
literal|2
expr_stmt|;
name|m
operator|->
name|toy
operator|=
operator|(
operator|(
name|w
operator|==
name|WHITE
operator|)
condition|?
operator|(
name|SIZE
operator|-
name|atoi
argument_list|(
name|s
argument_list|)
operator|)
else|:
operator|(
name|atoi
argument_list|(
name|s
argument_list|)
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|type
operator|==
name|CAPTURE
operator|)
operator|&&
operator|(
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|toy
index|]
index|[
name|m
operator|->
name|tox
index|]
operator|.
name|color
operator|!=
name|m
operator|->
name|taken
operator|.
name|color
operator|)
operator|||
operator|(
name|b
operator|->
name|square
index|[
name|m
operator|->
name|toy
index|]
index|[
name|m
operator|->
name|tox
index|]
operator|.
name|type
operator|!=
name|m
operator|->
name|taken
operator|.
name|type
operator|)
operator|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: bad stuff\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Parse an algebraic notation move.  This is a lot easier... */
end_comment

begin_function
name|move
modifier|*
name|parse_imove
parameter_list|(
name|b
parameter_list|,
name|buf
parameter_list|,
name|w
parameter_list|)
name|board
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|color
name|w
decl_stmt|;
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|move
modifier|*
name|m
init|=
name|alloc
argument_list|(
name|move
argument_list|)
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"(alg) parsing %s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
operator|,
name|n
operator|=
literal|0
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|(
operator|*
name|s
operator|==
literal|'o'
operator|)
operator|||
operator|(
operator|*
name|s
operator|==
literal|'O'
operator|)
condition|)
name|n
operator|++
expr_stmt|;
name|s
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|2
condition|)
name|m
operator|->
name|type
operator|=
name|KCASTLE
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|==
literal|3
condition|)
name|m
operator|->
name|type
operator|=
name|QCASTLE
expr_stmt|;
else|else
block|{
name|m
operator|->
name|fromx
operator|=
operator|*
name|s
operator|++
operator|-
literal|'a'
expr_stmt|;
name|m
operator|->
name|fromy
operator|=
name|SIZE
operator|-
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|m
operator|->
name|tox
operator|=
operator|*
name|s
operator|++
operator|-
literal|'a'
expr_stmt|;
name|m
operator|->
name|toy
operator|=
name|SIZE
operator|-
operator|(
operator|*
name|s
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|m
operator|->
name|piece
operator|=
name|b
operator|->
name|square
index|[
name|m
operator|->
name|fromy
index|]
index|[
name|m
operator|->
name|fromx
index|]
expr_stmt|;
name|m
operator|->
name|taken
operator|=
name|b
operator|->
name|square
index|[
name|m
operator|->
name|toy
index|]
index|[
name|m
operator|->
name|tox
index|]
expr_stmt|;
if|if
condition|(
name|m
operator|->
name|taken
operator|.
name|color
operator|==
name|NONE
condition|)
name|m
operator|->
name|type
operator|=
name|MOVE
expr_stmt|;
else|else
name|m
operator|->
name|type
operator|=
name|CAPTURE
expr_stmt|;
comment|/* for pawns we must account for en passant */
if|if
condition|(
name|m
operator|->
name|piece
operator|.
name|type
operator|==
name|PAWN
condition|)
block|{
if|if
condition|(
name|m
operator|->
name|type
operator|==
name|MOVE
operator|&&
name|m
operator|->
name|fromx
operator|!=
name|m
operator|->
name|tox
condition|)
block|{
name|m
operator|->
name|enpassant
operator|=
literal|1
expr_stmt|;
name|m
operator|->
name|type
operator|=
name|CAPTURE
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|m
operator|->
name|piece
operator|.
name|color
operator|!=
name|w
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: parse_imove: piece of wrong color!\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|type
operator|==
name|KING
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromx
operator|==
literal|4
operator|)
operator|&&
operator|(
name|m
operator|->
name|tox
operator|==
literal|6
operator|)
condition|)
name|m
operator|->
name|type
operator|=
name|KCASTLE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|m
operator|->
name|piece
operator|.
name|type
operator|==
name|KING
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromy
operator|==
name|m
operator|->
name|toy
operator|)
operator|&&
operator|(
name|m
operator|->
name|fromx
operator|==
literal|4
operator|)
operator|&&
operator|(
name|m
operator|->
name|tox
operator|==
literal|2
operator|)
condition|)
name|m
operator|->
name|type
operator|=
name|QCASTLE
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

end_unit

