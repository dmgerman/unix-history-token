begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.2 $ on $Date: 86/11/23 17:18:10 $  *           $Source: /users/faustus/xchess/RCS/program.c,v $  * Copyright (c) 1986 Wayne A. Christopher, U. C. Berkeley CAD Group  *	Permission is granted to do anything with this code except sell it  *	or remove this message.  *  * The interface to whichever chess playing program we are using...  */
end_comment

begin_include
include|#
directive|include
file|"xchess.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_decl_stmt
specifier|static
name|int
name|pid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|from
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|to
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|bool
name|easy
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|bool
name|program_init
parameter_list|(
name|name
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|int
name|toprog
index|[
literal|2
index|]
decl_stmt|,
name|fromprog
index|[
literal|2
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
name|char
name|time
index|[
literal|10
index|]
decl_stmt|;
name|char
name|moves
index|[
literal|10
index|]
decl_stmt|;
name|pipe
argument_list|(
name|toprog
argument_list|)
expr_stmt|;
name|pipe
argument_list|(
name|fromprog
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
condition|)
block|{
comment|/* Start up the program. */
name|dup2
argument_list|(
name|toprog
index|[
literal|0
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|dup2
argument_list|(
name|fromprog
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|toprog
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|toprog
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fromprog
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fromprog
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|time
argument_list|,
literal|"%d"
argument_list|,
name|timeunit
operator|/
literal|60
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|moves
argument_list|,
literal|"%d"
argument_list|,
name|movesperunit
argument_list|)
expr_stmt|;
if|if
condition|(
name|proghost
condition|)
name|execl
argument_list|(
literal|"/usr/ucb/rsh"
argument_list|,
literal|"rsh"
argument_list|,
name|proghost
argument_list|,
name|name
argument_list|,
name|moves
argument_list|,
name|time
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
else|else
name|execl
argument_list|(
name|name
argument_list|,
name|name
argument_list|,
name|moves
argument_list|,
name|time
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|toprog
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fromprog
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|from
operator|=
name|fdopen
argument_list|(
name|fromprog
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|from
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|to
operator|=
name|fdopen
argument_list|(
name|toprog
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|to
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* Get the first line... */
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"program says %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|blackflag
condition|)
block|{
name|fputs
argument_list|(
literal|"switch\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"program says %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
name|message_add
argument_list|(
name|win1
argument_list|,
literal|"GNU Chess playing white\n"
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
else|else
name|message_add
argument_list|(
name|win1
argument_list|,
literal|"GNU Chess playing black\n"
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_function
name|void
name|program_end
parameter_list|()
block|{
name|fclose
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|to
argument_list|)
expr_stmt|;
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGTERM
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|program_send
parameter_list|(
name|m
parameter_list|)
name|move
modifier|*
name|m
decl_stmt|;
block|{
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|m
operator|->
name|type
operator|==
name|MOVE
operator|)
operator|||
operator|(
name|m
operator|->
name|type
operator|==
name|CAPTURE
operator|)
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%c%d%c%d\n"
argument_list|,
literal|'a'
operator|+
name|m
operator|->
name|fromx
argument_list|,
name|SIZE
operator|-
name|m
operator|->
name|fromy
argument_list|,
literal|'a'
operator|+
name|m
operator|->
name|tox
argument_list|,
name|SIZE
operator|-
name|m
operator|->
name|toy
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|type
operator|==
name|KCASTLE
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
condition|?
literal|"e1g1\n"
else|:
literal|"e8g8\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|m
operator|->
name|type
operator|==
name|QCASTLE
condition|)
name|strcpy
argument_list|(
name|buf
argument_list|,
operator|(
name|m
operator|->
name|piece
operator|.
name|color
operator|==
name|WHITE
operator|)
condition|?
literal|"e1c1\n"
else|:
literal|"e8c8\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"sending program %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|easy
condition|)
name|kill
argument_list|(
name|pid
argument_list|,
name|SIGINT
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|to
argument_list|)
expr_stmt|;
comment|/* One junk line... */
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"program says %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|move
modifier|*
name|program_get
parameter_list|()
block|{
name|int
name|rfd
init|=
operator|(
literal|1
operator|<<
name|fileno
argument_list|(
name|from
argument_list|)
operator|)
decl_stmt|,
name|wfd
init|=
literal|0
decl_stmt|,
name|xfd
init|=
literal|0
decl_stmt|;
specifier|static
name|struct
name|timeval
name|notime
init|=
block|{
literal|0
block|,
literal|0
block|}
decl_stmt|;
name|char
name|buf
index|[
name|BSIZE
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|move
modifier|*
name|m
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Do a poll... */
if|if
condition|(
operator|!
operator|(
name|i
operator|=
name|select
argument_list|(
literal|32
argument_list|,
operator|&
name|rfd
argument_list|,
operator|&
name|wfd
argument_list|,
operator|&
name|xfd
argument_list|,
operator|&
name|notime
argument_list|)
operator|)
operator|&&
operator|!
name|from
operator|->
name|_cnt
condition|)
block|{
comment|/* Bad stuff... */
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"poll: nothing\n"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|fgets
argument_list|(
name|buf
argument_list|,
name|BSIZE
argument_list|,
name|from
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\n'
operator|||
operator|*
name|buf
operator|==
literal|'\0'
condition|)
block|{
name|message_add
argument_list|(
name|win1
argument_list|,
literal|"program died"
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"got from program %s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|!
name|isalpha
argument_list|(
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
name|m
operator|=
name|parse_imove
argument_list|(
name|chessboard
argument_list|,
name|s
argument_list|,
name|nexttomove
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
if|if
condition|(
operator|!
name|valid_move
argument_list|(
name|m
argument_list|,
name|chessboard
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Error: move %s is invalid!!\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
comment|/* 	fgets(buf, BSIZE, from); 	if (debug) 		fprintf(stderr, "program says %s", buf); 	*/
name|message_add
argument_list|(
name|win1
argument_list|,
name|buf
argument_list|,
name|false
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|)
return|;
block|}
end_function

begin_function
name|void
name|program_undo
parameter_list|()
block|{
name|fputs
argument_list|(
literal|"undo\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
name|void
name|program_easy
parameter_list|(
name|mode
parameter_list|)
name|bool
name|mode
decl_stmt|;
block|{
name|fputs
argument_list|(
literal|"easy\n"
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|easy
operator|=
name|mode
expr_stmt|;
block|}
end_function

end_unit

