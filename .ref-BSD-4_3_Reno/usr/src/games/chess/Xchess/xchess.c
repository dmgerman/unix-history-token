begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* This file contains code for X-CHESS.    Copyright (C) 1986 Free Software Foundation, Inc.  This file is part of X-CHESS.  X-CHESS is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY.  No author or distributor accepts responsibility to anyone for the consequences of using it or for whether it serves any particular purpose or works at all, unless he says so in writing.  Refer to the X-CHESS General Public License for full details.  Everyone is granted permission to copy, modify and redistribute X-CHESS, but only under the conditions described in the X-CHESS General Public License.   A copy of this license is supposed to have been given to you along with X-CHESS so you can know your rights and responsibilities.  It should be in a file named COPYING.  Among other things, the copyright notice and this notice must be preserved on all copies.  */
end_comment

begin_comment
comment|/* RCS Info: $Revision: 1.2 $ on $Date: 89/04/28 08:44:02 $  *           $Source: /usr/local/src/source/X.V11R3/contrib/games/xchess/Xchess/RCS/xchess.c,v $  * Copyright (c) 1986 Wayne A. Christopher, U. C. Berkeley CAD Group  *	Permission is granted to do anything with this code except sell it  *	or remove this message.  */
end_comment

begin_define
define|#
directive|define
name|USAGE
value|"xchess [ -d ] [ -f recordfile ] [ -r savedfile ] [ -i ]\n\ \t[ -t moves/timeunit ] [ -c ] [ -p program ]  [ -b ] [ -bnw ] [ -s ]\n\ \t[ -n ] [ -h host ] [ -v ] [ -R ] [ whitedisplay ] [ blackdisplay ]"
end_define

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|"xchess.h"
end_include

begin_decl_stmt
name|bool
name|debug
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|oneboard
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|bnwflag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|progflag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|blackflag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bool
name|quickflag
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|progname
init|=
name|DEF_PROGRAM
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|proghost
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|piecenames
index|[]
init|=
block|{
literal|"pawn"
block|,
literal|"rook"
block|,
literal|"knight"
block|,
literal|"bishop"
block|,
literal|"queen"
block|,
literal|"king"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|colornames
index|[]
init|=
block|{
literal|"white"
block|,
literal|"black"
block|,
literal|"none"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|movetypenames
index|[]
init|=
block|{
literal|"move"
block|,
literal|"qcastle"
block|,
literal|"kcastle"
block|,
literal|"capture"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|dispname1
init|=
name|NULL
decl_stmt|,
modifier|*
name|dispname2
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|black_piece_color
init|=
name|BLACK_PIECE_COLOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|white_piece_color
init|=
name|WHITE_PIECE_COLOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|black_square_color
init|=
name|BLACK_SQUARE_COLOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|white_square_color
init|=
name|WHITE_SQUARE_COLOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|border_color
init|=
name|BORDER_COLOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text_color
init|=
name|TEXT_COLOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|text_back
init|=
name|TEXT_BACK
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|error_text
init|=
name|ERROR_TEXT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|player_text
init|=
name|PLAYER_TEXT
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cursor_color
init|=
name|CURSOR_COLOR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_flashes
init|=
name|NUM_FLASHES
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flash_size
init|=
name|FLASH_SIZE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|program
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|recfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|notdef
end_ifdef

begin_comment
comment|/*  * Serves no purpose.  */
end_comment

begin_macro
name|die
argument_list|()
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"child proc changed status?!\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|bool
name|randflag
init|=
name|false
decl_stmt|;
name|move
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|program
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|signal
argument_list|(
name|SIGCHLD
argument_list|,
name|die
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Process args. */
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
while|while
condition|(
name|ac
operator|>
literal|0
operator|&&
operator|*
operator|*
name|av
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-d"
argument_list|)
condition|)
block|{
name|debug
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-f"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|av
condition|)
name|record_file
operator|=
operator|*
name|av
expr_stmt|;
else|else
goto|goto
name|usage
goto|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-r"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|av
condition|)
name|recfile
operator|=
operator|*
name|av
expr_stmt|;
else|else
goto|goto
name|usage
goto|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-i"
argument_list|)
condition|)
block|{
name|record_english
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-R"
argument_list|)
condition|)
block|{
name|randflag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-v"
argument_list|)
condition|)
block|{
name|win_flashmove
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-q"
argument_list|)
condition|)
block|{
name|quickflag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-t"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|av
condition|)
block|{
name|movesperunit
operator|=
name|atoi
argument_list|(
operator|*
name|av
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|=
name|index
argument_list|(
operator|*
name|av
argument_list|,
literal|'/'
argument_list|)
condition|)
name|timeunit
operator|=
name|atoi
argument_list|(
name|s
operator|+
literal|1
argument_list|)
operator|*
literal|60
expr_stmt|;
else|else
name|timeunit
operator|=
literal|60
expr_stmt|;
block|}
else|else
goto|goto
name|usage
goto|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-p"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|av
condition|)
name|progname
operator|=
operator|*
name|av
expr_stmt|;
else|else
goto|goto
name|usage
goto|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-h"
argument_list|)
condition|)
block|{
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|av
condition|)
name|proghost
operator|=
operator|*
name|av
expr_stmt|;
else|else
goto|goto
name|usage
goto|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-b"
argument_list|)
condition|)
block|{
name|blackflag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-c"
argument_list|)
condition|)
block|{
name|progflag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-bnw"
argument_list|)
condition|)
block|{
name|bnwflag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-s"
argument_list|)
condition|)
block|{
name|saveflag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|eq
argument_list|(
operator|*
name|av
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
name|noisyflag
operator|=
name|true
expr_stmt|;
block|}
else|else
goto|goto
name|usage
goto|;
name|av
operator|++
expr_stmt|;
name|ac
operator|--
expr_stmt|;
block|}
if|if
condition|(
name|ac
operator|>
literal|0
condition|)
name|dispname1
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|1
condition|)
name|dispname2
operator|=
name|av
index|[
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|ac
operator|>
literal|2
condition|)
goto|goto
name|usage
goto|;
if|if
condition|(
operator|!
name|dispname2
condition|)
name|oneboard
operator|=
name|true
expr_stmt|;
name|srandom
argument_list|(
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|oneboard
operator|&&
name|randflag
operator|&&
operator|(
name|random
argument_list|()
operator|%
literal|2
operator|)
condition|)
block|{
name|s
operator|=
name|dispname1
expr_stmt|;
name|dispname1
operator|=
name|dispname2
expr_stmt|;
name|dispname2
operator|=
name|s
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|dispname1
condition|)
name|dispname1
operator|=
name|getenv
argument_list|(
literal|"DISPLAY"
argument_list|)
expr_stmt|;
comment|/* Set up the board. */
name|board_setup
argument_list|()
expr_stmt|;
comment|/* Create the windows. */
name|win_setup
argument_list|(
name|dispname1
argument_list|,
name|dispname2
argument_list|)
expr_stmt|;
name|board_drawall
argument_list|()
expr_stmt|;
comment|/* Start the program if necessary. */
if|if
condition|(
name|progflag
condition|)
if|if
condition|(
operator|!
name|program_init
argument_list|(
name|progname
argument_list|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|recfile
condition|)
name|load_game
argument_list|(
name|recfile
argument_list|)
expr_stmt|;
comment|/* Go into a loop of prompting players alternately for moves, checking 	 * them, and updating things. 	 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|win_process
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|clock_update
argument_list|()
expr_stmt|;
if|if
condition|(
name|progflag
operator|&&
operator|(
operator|(
operator|!
name|blackflag
operator|&&
operator|(
name|nexttomove
operator|==
name|BLACK
operator|)
operator|)
operator|||
operator|(
name|blackflag
operator|&&
operator|(
name|nexttomove
operator|==
name|WHITE
operator|)
operator|)
operator|)
condition|)
block|{
name|m
operator|=
name|program_get
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
condition|)
name|prog_move
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
name|usage
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s\n"
argument_list|,
name|USAGE
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

