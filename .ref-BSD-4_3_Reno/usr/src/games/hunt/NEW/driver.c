begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  *  *  Copyright (c) 1985 Regents of the University of California.  *  All rights reserved.  The Berkeley software License Agreement  *  specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HPUX
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|pdp11
end_ifndef

begin_define
define|#
directive|define
name|RN
value|(((Seed = Seed * 11109 + 13849)>> 16)& 0xffff)
end_define

begin_else
else|#
directive|else
else|pdp11
end_else

begin_define
define|#
directive|define
name|RN
value|((Seed = Seed * 11109 + 13849)& 0x7fff)
end_define

begin_endif
endif|#
directive|endif
endif|pdp11
end_endif

begin_decl_stmt
name|int
name|Seed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|SOCKET
name|Daemon
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|First_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to argv[0] */
end_comment

begin_decl_stmt
name|char
modifier|*
name|Last_arg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to end of argv/environ */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_decl_stmt
name|int
name|Test_socket
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* test socket to answer datagrams */
end_comment

begin_decl_stmt
name|FLAG
name|inetd_spawned
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* invoked via inetd */
end_comment

begin_decl_stmt
name|FLAG
name|standard_port
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if listening on standard port */
end_comment

begin_decl_stmt
name|u_short
name|sock_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* port # of tcp listen socket */
end_comment

begin_decl_stmt
name|u_short
name|stat_port
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* port # of statistics tcp socket */
end_comment

begin_define
define|#
directive|define
name|DAEMON_SIZE
value|(sizeof Daemon)
end_define

begin_else
else|#
directive|else
else|INTERNET
end_else

begin_define
define|#
directive|define
name|DAEMON_SIZE
value|(sizeof Daemon - 1)
end_define

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_comment
comment|/*  * main:  *	The main program.  */
end_comment

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|,
name|ep
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|,
decl|*
modifier|*
name|ep
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|had_char
decl_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
specifier|register
name|long
name|test_mask
decl_stmt|;
name|u_short
name|msg
decl_stmt|;
name|short
name|port_num
decl_stmt|,
name|reply
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|SOCKET
name|test
decl_stmt|;
endif|#
directive|endif
endif|INTERNET
specifier|static
name|long
name|read_fds
decl_stmt|;
specifier|static
name|FLAG
name|first
init|=
name|TRUE
decl_stmt|;
specifier|static
name|FLAG
name|server
init|=
name|FALSE
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|static
name|struct
name|timeval
name|linger
init|=
block|{
literal|90
block|,
literal|0
block|}
decl_stmt|;
name|First_arg
operator|=
name|av
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|NULL
operator|||
operator|*
name|ep
operator|==
name|NULL
condition|)
name|ep
operator|=
name|av
operator|+
name|ac
expr_stmt|;
while|while
condition|(
operator|*
name|ep
condition|)
name|ep
operator|++
expr_stmt|;
name|Last_arg
operator|=
name|ep
index|[
operator|-
literal|1
index|]
operator|+
name|strlen
argument_list|(
name|ep
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"sp:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'s'
case|:
name|server
operator|=
name|TRUE
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|INTERNET
case|case
literal|'p'
case|:
name|standard_port
operator|=
name|FALSE
expr_stmt|;
name|Test_port
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
default|default:
name|erred
label|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [-s] [-p port]\n"
argument_list|,
name|av
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|optind
operator|<
name|ac
condition|)
goto|goto
name|erred
goto|;
name|init
argument_list|()
expr_stmt|;
name|Sock_mask
operator|=
operator|(
literal|1
operator|<<
name|Socket
operator|)
expr_stmt|;
name|Stat_mask
operator|=
operator|(
literal|1
operator|<<
name|Status
operator|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|test_mask
operator|=
operator|(
literal|1
operator|<<
name|Test_socket
operator|)
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|again
label|:
do|do
block|{
name|read_fds
operator|=
name|Fds_mask
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|select
argument_list|(
name|Num_fds
argument_list|,
operator|&
name|read_fds
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
expr|struct
name|timeval
operator|*
operator|)
name|NULL
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EINTR
condition|)
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"select: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"select"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|errno
operator|=
literal|0
expr_stmt|;
block|}
name|Have_inp
operator|=
name|read_fds
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|read_fds
operator|&
name|test_mask
condition|)
block|{
name|namelen
operator|=
name|DAEMON_SIZE
expr_stmt|;
name|port_num
operator|=
name|htons
argument_list|(
name|sock_port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|recvfrom
argument_list|(
name|Test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
operator|&
name|namelen
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|ntohs
argument_list|(
name|msg
argument_list|)
condition|)
block|{
case|case
name|C_MESSAGE
case|:
if|if
condition|(
name|Nplayer
operator|<=
literal|0
condition|)
break|break;
name|reply
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|Nplayer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|Test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
sizeof|sizeof
name|reply
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_SCORES
case|:
name|reply
operator|=
name|htons
argument_list|(
name|stat_port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|Test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
sizeof|sizeof
name|reply
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
break|break;
case|case
name|C_PLAYER
case|:
case|case
name|C_MONITOR
case|:
if|if
condition|(
name|msg
operator|==
name|C_MONITOR
operator|&&
name|Nplayer
operator|<=
literal|0
condition|)
break|break;
name|reply
operator|=
name|htons
argument_list|(
name|sock_port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|Test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|reply
argument_list|,
sizeof|sizeof
name|reply
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
endif|INTERNET
for|for
control|(
init|;
condition|;
control|)
block|{
name|had_char
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|havechar
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|execute
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_nexec
operator|++
expr_stmt|;
name|had_char
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|havechar
argument_list|(
name|pp
argument_list|)
condition|)
block|{
name|mon_execute
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_nexec
operator|++
expr_stmt|;
name|had_char
operator|++
expr_stmt|;
block|}
endif|#
directive|endif
endif|MONITOR
if|if
condition|(
operator|!
name|had_char
condition|)
break|break;
name|moveshots
argument_list|()
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
control|)
if|if
condition|(
name|pp
operator|->
name|p_death
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|zap
argument_list|(
name|pp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|pp
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
control|)
if|if
condition|(
name|pp
operator|->
name|p_death
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|zap
argument_list|(
name|pp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
else|else
name|pp
operator|++
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
block|}
if|if
condition|(
name|read_fds
operator|&
name|Sock_mask
condition|)
if|if
condition|(
name|answer
argument_list|()
condition|)
block|{
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|first
operator|&&
name|standard_port
condition|)
name|faketalk
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|first
operator|=
name|FALSE
expr_stmt|;
block|}
if|if
condition|(
name|read_fds
operator|&
name|Stat_mask
condition|)
name|send_stats
argument_list|()
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|read_fds
operator|&
name|pp
operator|->
name|p_mask
condition|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|READY
argument_list|,
name|pp
operator|->
name|p_nexec
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_nexec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|read_fds
operator|&
name|pp
operator|->
name|p_mask
condition|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|READY
argument_list|,
name|pp
operator|->
name|p_nexec
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_nexec
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MONITOR
block|}
do|while
condition|(
name|Nplayer
operator|>
literal|0
condition|)
do|;
name|read_fds
operator|=
name|Fds_mask
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|Num_fds
argument_list|,
operator|&
name|read_fds
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|(
name|int
operator|*
operator|)
name|NULL
argument_list|,
operator|&
name|linger
argument_list|)
operator|>
literal|0
condition|)
block|{
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|server
condition|)
block|{
name|clear_scores
argument_list|()
expr_stmt|;
name|makemaze
argument_list|()
expr_stmt|;
name|clearwalls
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTS
name|makeboots
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|BOOTS
name|first
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|again
goto|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
control|)
name|zap
argument_list|(
name|pp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
name|cleanup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * init:  *	Initialize the global parameters.  */
end_comment

begin_macro
name|init
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
specifier|auto
name|SOCKET
name|test_port
decl_stmt|;
specifier|auto
name|int
name|msg
decl_stmt|;
specifier|auto
name|int
name|len
decl_stmt|;
endif|#
directive|endif
endif|INTERNET
ifndef|#
directive|ifndef
name|DEBUG
ifdef|#
directive|ifdef
name|TIOCNOTTY
operator|(
name|void
operator|)
name|ioctl
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|TIOCNOTTY
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|cleanup
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
operator|(
name|void
operator|)
name|chdir
argument_list|(
literal|"/usr/tmp"
argument_list|)
expr_stmt|;
comment|/* just in case it core dumps */
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* No privacy at all! */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG
ifdef|#
directive|ifdef
name|SYSLOG_43
name|openlog
argument_list|(
literal|"HUNT"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSLOG_42
name|openlog
argument_list|(
literal|"HUNT"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* 	 * Initialize statistics socket 	 */
ifdef|#
directive|ifdef
name|INTERNET
name|Daemon
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|Daemon
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|Daemon
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|INTERNET
name|Daemon
operator|.
name|sun_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Daemon
operator|.
name|sun_path
argument_list|,
name|Stat_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|Status
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|Status
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|listen
argument_list|(
name|Status
argument_list|,
literal|5
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|len
operator|=
sizeof|sizeof
argument_list|(
name|SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|Status
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getsockname: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"getsockname"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|stat_port
operator|=
name|ntohs
argument_list|(
name|Daemon
operator|.
name|sin_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
comment|/* 	 * Initialize main socket 	 */
ifdef|#
directive|ifdef
name|INTERNET
name|Daemon
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|Daemon
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|INADDR_ANY
expr_stmt|;
name|Daemon
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|INTERNET
name|Daemon
operator|.
name|sun_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Daemon
operator|.
name|sun_path
argument_list|,
name|Sock_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|INTERNET
argument_list|)
name|msg
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|Socket
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_USELOOPBACK
argument_list|,
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|)
operator|<
literal|0
condition|)
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_WARNING
argument_list|,
literal|"setsockopt loopback %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"setsockopt loopback"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
endif|#
directive|endif
endif|INTERNET
if|if
condition|(
name|bind
argument_list|(
name|Socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EADDRINUSE
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|listen
argument_list|(
name|Socket
argument_list|,
literal|5
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|len
operator|=
sizeof|sizeof
argument_list|(
name|SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
name|Socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"getsockname: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"getsockname"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sock_port
operator|=
name|ntohs
argument_list|(
name|Daemon
operator|.
name|sin_port
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
comment|/* 	 * Initialize minimal select mask 	 */
name|Fds_mask
operator|=
operator|(
literal|1
operator|<<
name|Socket
operator|)
operator||
operator|(
literal|1
operator|<<
name|Status
operator|)
expr_stmt|;
name|Num_fds
operator|=
operator|(
operator|(
name|Socket
operator|>
name|Status
operator|)
condition|?
name|Socket
else|:
name|Status
operator|)
operator|+
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|len
operator|=
sizeof|sizeof
argument_list|(
name|SOCKET
argument_list|)
expr_stmt|;
if|if
condition|(
name|getsockname
argument_list|(
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test_port
argument_list|,
operator|&
name|len
argument_list|)
operator|>=
literal|0
operator|&&
name|test_port
operator|.
name|sin_family
operator|==
name|AF_INET
condition|)
block|{
name|inetd_spawned
operator|=
name|TRUE
expr_stmt|;
name|Test_socket
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|test_port
operator|.
name|sin_port
operator|!=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|Test_port
argument_list|)
condition|)
block|{
name|standard_port
operator|=
name|FALSE
expr_stmt|;
name|Test_port
operator|=
name|ntohs
argument_list|(
name|test_port
operator|.
name|sin_port
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|test_port
operator|=
name|Daemon
expr_stmt|;
name|test_port
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|Test_port
argument_list|)
expr_stmt|;
name|Test_socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|bind
argument_list|(
name|Test_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test_port
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"bind: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"bind"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|listen
argument_list|(
name|Test_socket
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
name|Fds_mask
operator||=
operator|(
literal|1
operator|<<
name|Test_socket
operator|)
expr_stmt|;
if|if
condition|(
name|Test_socket
operator|+
literal|1
operator|>
name|Num_fds
condition|)
name|Num_fds
operator|=
name|Test_socket
operator|+
literal|1
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|Seed
operator|=
name|getpid
argument_list|()
operator|+
name|time
argument_list|(
operator|(
name|time_t
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|makemaze
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTS
name|makeboots
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|BOOTS
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NASCII
condition|;
name|i
operator|++
control|)
name|See_over
index|[
name|i
index|]
operator|=
name|TRUE
expr_stmt|;
name|See_over
index|[
name|DOOR
index|]
operator|=
name|FALSE
expr_stmt|;
name|See_over
index|[
name|WALL1
index|]
operator|=
name|FALSE
expr_stmt|;
name|See_over
index|[
name|WALL2
index|]
operator|=
name|FALSE
expr_stmt|;
name|See_over
index|[
name|WALL3
index|]
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|REFLECT
name|See_over
index|[
name|WALL4
index|]
operator|=
name|FALSE
expr_stmt|;
name|See_over
index|[
name|WALL5
index|]
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
endif|REFLECT
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BOOTS
end_ifdef

begin_comment
comment|/*  * makeboots:  *	Put the boots in the maze  */
end_comment

begin_macro
name|makeboots
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|BOOT_PAIR
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Boot
init|;
name|pp
operator|<
operator|&
name|Boot
index|[
name|NBOOTS
index|]
condition|;
name|pp
operator|++
control|)
name|pp
operator|->
name|p_flying
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * checkdam:  *	Check the damage to the given player, and see if s/he is killed  */
end_comment

begin_expr_stmt
name|checkdam
argument_list|(
name|ouch
argument_list|,
name|gotcha
argument_list|,
name|credit
argument_list|,
name|amt
argument_list|,
name|shot_type
argument_list|)
specifier|register
name|PLAYER
operator|*
name|ouch
operator|,
operator|*
name|gotcha
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|IDENT
modifier|*
name|credit
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|amt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|shot_type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
if|if
condition|(
name|ouch
operator|->
name|p_death
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return;
ifdef|#
directive|ifdef
name|BOOTS
if|if
condition|(
name|shot_type
operator|==
name|SLIME
condition|)
switch|switch
condition|(
name|ouch
operator|->
name|p_nboots
condition|)
block|{
default|default:
break|break;
case|case
literal|1
case|:
name|amt
operator|=
operator|(
name|amt
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|2
case|:
if|if
condition|(
name|gotcha
operator|!=
name|NULL
condition|)
name|message
argument_list|(
name|gotcha
argument_list|,
literal|"He has boots on!"
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
name|ouch
operator|->
name|p_damage
operator|+=
name|amt
expr_stmt|;
if|if
condition|(
name|ouch
operator|->
name|p_damage
operator|<=
name|ouch
operator|->
name|p_damcap
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%2d"
argument_list|,
name|ouch
operator|->
name|p_damage
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|ouch
argument_list|,
name|STAT_DAM_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|ouch
argument_list|,
name|Buf
argument_list|,
literal|2
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* Someone DIED */
switch|switch
condition|(
name|shot_type
condition|)
block|{
default|default:
name|cp
operator|=
literal|"Killed"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FLY
case|case
name|FALL
case|:
name|cp
operator|=
literal|"Killed on impact"
expr_stmt|;
break|break;
endif|#
directive|endif
endif|FLY
case|case
name|KNIFE
case|:
name|cp
operator|=
literal|"Stabbed to death"
expr_stmt|;
name|ouch
operator|->
name|p_ammo
operator|=
literal|0
expr_stmt|;
comment|/* No exploding */
break|break;
case|case
name|SHOT
case|:
name|cp
operator|=
literal|"Shot to death"
expr_stmt|;
break|break;
case|case
name|GRENADE
case|:
case|case
name|SATCHEL
case|:
case|case
name|BOMB
case|:
name|cp
operator|=
literal|"Bombed"
expr_stmt|;
break|break;
case|case
name|MINE
case|:
case|case
name|GMINE
case|:
name|cp
operator|=
literal|"Blown apart"
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OOZE
case|case
name|SLIME
case|:
name|cp
operator|=
literal|"Slimed"
expr_stmt|;
if|if
condition|(
name|credit
operator|!=
name|NULL
condition|)
name|credit
operator|->
name|i_slime
operator|++
expr_stmt|;
break|break;
endif|#
directive|endif
endif|OOZE
ifdef|#
directive|ifdef
name|VOLCANO
case|case
name|LAVA
case|:
name|cp
operator|=
literal|"Baked"
expr_stmt|;
break|break;
endif|#
directive|endif
endif|VOLCANO
ifdef|#
directive|ifdef
name|DRONE
case|case
name|DSHOT
case|:
name|cp
operator|=
literal|"Eliminated"
expr_stmt|;
break|break;
endif|#
directive|endif
endif|DRONE
block|}
if|if
condition|(
name|credit
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ouch
operator|->
name|p_death
argument_list|,
literal|"| %s by %s |"
argument_list|,
name|cp
argument_list|,
operator|(
name|shot_type
operator|==
name|MINE
operator|||
name|shot_type
operator|==
name|GMINE
operator|)
condition|?
literal|"a mine"
else|:
literal|"act of God"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|ouch
operator|->
name|p_death
argument_list|,
literal|"| %s by %s |"
argument_list|,
name|cp
argument_list|,
name|credit
operator|->
name|i_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|ouch
operator|==
name|gotcha
condition|)
block|{
comment|/* No use killing yourself */
name|credit
operator|->
name|i_kills
operator|--
expr_stmt|;
name|credit
operator|->
name|i_bkills
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ouch
operator|->
name|p_ident
operator|->
name|i_team
operator|==
literal|' '
operator|||
name|ouch
operator|->
name|p_ident
operator|->
name|i_team
operator|!=
name|credit
operator|->
name|i_team
condition|)
block|{
name|credit
operator|->
name|i_kills
operator|++
expr_stmt|;
name|credit
operator|->
name|i_gkills
operator|++
expr_stmt|;
block|}
else|else
block|{
name|credit
operator|->
name|i_kills
operator|--
expr_stmt|;
name|credit
operator|->
name|i_bkills
operator|++
expr_stmt|;
block|}
name|credit
operator|->
name|i_score
operator|=
name|credit
operator|->
name|i_kills
operator|/
operator|(
name|double
operator|)
name|credit
operator|->
name|i_entries
expr_stmt|;
name|ouch
operator|->
name|p_ident
operator|->
name|i_deaths
operator|++
expr_stmt|;
if|if
condition|(
name|ouch
operator|->
name|p_nchar
operator|==
literal|0
condition|)
name|ouch
operator|->
name|p_ident
operator|->
name|i_stillb
operator|++
expr_stmt|;
if|if
condition|(
name|gotcha
operator|==
name|NULL
condition|)
return|return;
name|gotcha
operator|->
name|p_damcap
operator|+=
name|STABDAM
expr_stmt|;
name|gotcha
operator|->
name|p_damage
operator|-=
name|STABDAM
expr_stmt|;
if|if
condition|(
name|gotcha
operator|->
name|p_damage
operator|<
literal|0
condition|)
name|gotcha
operator|->
name|p_damage
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%2d/%2d"
argument_list|,
name|gotcha
operator|->
name|p_damage
argument_list|,
name|gotcha
operator|->
name|p_damcap
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|gotcha
argument_list|,
name|STAT_DAM_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|gotcha
argument_list|,
name|Buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
operator|(
name|gotcha
operator|->
name|p_damcap
operator|-
name|MAXDAM
operator|)
operator|/
literal|2
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|gotcha
argument_list|,
name|STAT_KILL_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|gotcha
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%5.2f"
argument_list|,
name|gotcha
operator|->
name|p_ident
operator|->
name|i_score
argument_list|)
expr_stmt|;
for|for
control|(
name|ouch
operator|=
name|Player
init|;
name|ouch
operator|<
name|End_player
condition|;
name|ouch
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|ouch
argument_list|,
name|STAT_PLAY_ROW
operator|+
literal|1
operator|+
operator|(
name|gotcha
operator|-
name|Player
operator|)
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|ouch
argument_list|,
name|Buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|ouch
operator|=
name|Monitor
init|;
name|ouch
operator|<
name|End_monitor
condition|;
name|ouch
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|ouch
argument_list|,
name|STAT_PLAY_ROW
operator|+
literal|1
operator|+
operator|(
name|gotcha
operator|-
name|Player
operator|)
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|ouch
argument_list|,
name|Buf
argument_list|,
literal|5
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MONITOR
block|}
end_block

begin_comment
comment|/*  * zap:  *	Kill off a player and take him out of the game.  */
end_comment

begin_expr_stmt
name|zap
argument_list|(
name|pp
argument_list|,
name|was_player
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FLAG
name|was_player
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|len
decl_stmt|;
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|np
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
name|int
name|savefd
decl_stmt|,
name|savemask
decl_stmt|;
if|if
condition|(
name|was_player
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_undershot
condition|)
name|fixshots
argument_list|(
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|pp
operator|->
name|p_over
argument_list|)
expr_stmt|;
name|drawplayer
argument_list|(
name|pp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|Nplayer
operator|--
expr_stmt|;
block|}
name|len
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|p_death
argument_list|)
expr_stmt|;
comment|/* Display the cause of death */
name|x
operator|=
operator|(
name|WIDTH
operator|-
name|len
operator|)
operator|/
literal|2
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|HEIGHT
operator|/
literal|2
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|pp
operator|->
name|p_death
argument_list|,
name|len
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
name|pp
operator|->
name|p_death
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
name|pp
operator|->
name|p_death
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|pp
operator|->
name|p_death
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'+'
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|HEIGHT
operator|/
literal|2
operator|-
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|pp
operator|->
name|p_death
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|HEIGHT
operator|/
literal|2
operator|+
literal|1
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|pp
operator|->
name|p_death
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|HEIGHT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|savefd
operator|=
name|pp
operator|->
name|p_fd
expr_stmt|;
name|savemask
operator|=
name|pp
operator|->
name|p_mask
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|was_player
condition|)
block|{
endif|#
directive|endif
endif|MONITOR
for|for
control|(
name|bp
operator|=
name|Bullets
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_owner
operator|==
name|pp
condition|)
name|bp
operator|->
name|b_owner
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_x
operator|==
name|pp
operator|->
name|p_x
operator|&&
name|bp
operator|->
name|b_y
operator|==
name|pp
operator|->
name|p_y
condition|)
name|bp
operator|->
name|b_over
operator|=
name|SPACE
expr_stmt|;
block|}
name|i
operator|=
name|rand_num
argument_list|(
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|x
operator|=
name|rand_num
argument_list|(
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
if|if
condition|(
name|x
operator|>
name|i
condition|)
name|i
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_ammo
operator|==
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|pp
operator|->
name|p_ammo
operator|-
literal|1
condition|)
block|{
name|x
operator|=
name|pp
operator|->
name|p_ammo
expr_stmt|;
name|len
operator|=
name|SLIME
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|x
operator|=
name|MAXBOMB
operator|-
literal|1
init|;
name|x
operator|>
literal|0
condition|;
name|x
operator|--
control|)
if|if
condition|(
name|i
operator|>=
name|shot_req
index|[
name|x
index|]
condition|)
break|break;
for|for
control|(
name|y
operator|=
name|MAXSLIME
operator|-
literal|1
init|;
name|y
operator|>
literal|0
condition|;
name|y
operator|--
control|)
if|if
condition|(
name|i
operator|>=
name|slime_req
index|[
name|y
index|]
condition|)
break|break;
if|if
condition|(
name|y
operator|>=
literal|0
operator|&&
name|slime_req
index|[
name|y
index|]
operator|>
name|shot_req
index|[
name|x
index|]
condition|)
block|{
name|x
operator|=
name|slime_req
index|[
name|y
index|]
expr_stmt|;
name|len
operator|=
name|SLIME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|!=
literal|0
condition|)
block|{
name|len
operator|=
name|shot_type
index|[
name|x
index|]
expr_stmt|;
name|x
operator|=
name|shot_req
index|[
name|x
index|]
expr_stmt|;
block|}
block|}
if|if
condition|(
name|x
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|add_shot
argument_list|(
name|len
argument_list|,
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|pp
operator|->
name|p_face
argument_list|,
name|x
argument_list|,
operator|(
name|PLAYER
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%s detonated."
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_name
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|Player
init|;
name|np
operator|<
name|End_player
condition|;
name|np
operator|++
control|)
name|message
argument_list|(
name|np
argument_list|,
name|Buf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|np
operator|=
name|Monitor
init|;
name|np
operator|<
name|End_monitor
condition|;
name|np
operator|++
control|)
name|message
argument_list|(
name|np
argument_list|,
name|Buf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
ifdef|#
directive|ifdef
name|BOOTS
while|while
condition|(
name|pp
operator|->
name|p_nboots
operator|--
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|np
operator|=
name|Boot
init|;
name|np
operator|<
operator|&
name|Boot
index|[
name|NBOOTS
index|]
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|p_flying
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
name|np
operator|>=
operator|&
name|Boot
index|[
name|NBOOTS
index|]
condition|)
name|abort
argument_list|(
literal|1
argument_list|,
literal|"Too many boots"
argument_list|)
expr_stmt|;
name|np
operator|->
name|p_undershot
operator|=
name|FALSE
expr_stmt|;
name|np
operator|->
name|p_x
operator|=
name|pp
operator|->
name|p_x
expr_stmt|;
name|np
operator|->
name|p_y
operator|=
name|pp
operator|->
name|p_y
expr_stmt|;
name|np
operator|->
name|p_flying
operator|=
name|rand_num
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|np
operator|->
name|p_flyx
operator|=
literal|2
operator|*
name|rand_num
argument_list|(
literal|6
argument_list|)
operator|-
literal|5
expr_stmt|;
name|np
operator|->
name|p_flyy
operator|=
literal|2
operator|*
name|rand_num
argument_list|(
literal|6
argument_list|)
operator|-
literal|5
expr_stmt|;
name|np
operator|->
name|p_over
operator|=
name|SPACE
expr_stmt|;
name|np
operator|->
name|p_face
operator|=
name|BOOT
expr_stmt|;
name|showexpl
argument_list|(
name|np
operator|->
name|p_y
argument_list|,
name|np
operator|->
name|p_x
argument_list|,
name|BOOT
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|BOOTS
block|}
ifdef|#
directive|ifdef
name|BOOTS
elseif|else
if|if
condition|(
name|pp
operator|->
name|p_nboots
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_nboots
operator|==
literal|2
condition|)
name|Maze
index|[
name|pp
operator|->
name|p_y
index|]
index|[
name|pp
operator|->
name|p_x
index|]
operator|=
name|BOOT_PAIR
expr_stmt|;
else|else
name|Maze
index|[
name|pp
operator|->
name|p_y
index|]
index|[
name|pp
operator|->
name|p_x
index|]
operator|=
name|BOOT
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_undershot
condition|)
name|fixshots
argument_list|(
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|Maze
index|[
name|pp
operator|->
name|p_y
index|]
index|[
name|pp
operator|->
name|p_x
index|]
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|BOOTS
ifdef|#
directive|ifdef
name|VOLCANO
name|volcano
operator|+=
name|pp
operator|->
name|p_ammo
operator|-
name|x
expr_stmt|;
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
name|volcano
operator|/
literal|50
condition|)
block|{
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|/
literal|2
argument_list|)
operator|+
name|WIDTH
operator|/
literal|4
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|/
literal|2
argument_list|)
operator|+
name|HEIGHT
operator|/
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
operator|(
name|void
operator|)
name|add_shot
argument_list|(
name|LAVA
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|LEFTS
argument_list|,
name|volcano
argument_list|,
operator|(
name|PLAYER
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|Player
init|;
name|np
operator|<
name|End_player
condition|;
name|np
operator|++
control|)
name|message
argument_list|(
name|np
argument_list|,
literal|"Volcano eruption."
argument_list|)
expr_stmt|;
name|volcano
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
endif|VOLCANO
ifdef|#
directive|ifdef
name|DRONE
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|2
condition|)
block|{
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|/
literal|2
argument_list|)
operator|+
name|WIDTH
operator|/
literal|4
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|/
literal|2
argument_list|)
operator|+
name|HEIGHT
operator|/
literal|4
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|add_shot
argument_list|(
name|DSHOT
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|rand_dir
argument_list|()
argument_list|,
name|shot_req
index|[
name|MINDSHOT
operator|+
name|rand_num
argument_list|(
name|MAXBOMB
operator|-
name|MINDSHOT
argument_list|)
index|]
argument_list|,
operator|(
name|PLAYER
operator|*
operator|)
name|NULL
argument_list|,
name|FALSE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DRONE
name|sendcom
argument_list|(
name|pp
argument_list|,
name|ENDWIN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
name|End_player
operator|--
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|End_player
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|End_player
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
sizeof|sizeof
argument_list|(
name|PLAYER
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%5.2f%c%-10.10s %c"
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_score
argument_list|,
name|stat_char
argument_list|(
name|pp
argument_list|)
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_name
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_team
argument_list|)
expr_stmt|;
name|i
operator|=
name|STAT_PLAY_ROW
operator|+
literal|1
operator|+
operator|(
name|pp
operator|-
name|Player
operator|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|Player
init|;
name|np
operator|<
name|End_player
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|np
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|np
operator|=
name|Monitor
init|;
name|np
operator|<
name|End_monitor
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|np
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MONITOR
block|}
comment|/* Erase the last player */
name|i
operator|=
name|STAT_PLAY_ROW
operator|+
literal|1
operator|+
name|Nplayer
expr_stmt|;
for|for
control|(
name|np
operator|=
name|Player
init|;
name|np
operator|<
name|End_player
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|ce
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|np
operator|=
name|Monitor
init|;
name|np
operator|<
name|End_monitor
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|ce
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|sendcom
argument_list|(
name|pp
argument_list|,
name|ENDWIN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|LAST_PLAYER
argument_list|,
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
name|End_monitor
operator|--
expr_stmt|;
if|if
condition|(
name|pp
operator|!=
name|End_monitor
condition|)
block|{
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|End_monitor
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pp
argument_list|,
sizeof|sizeof
argument_list|(
name|PLAYER
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%5.5s %-10.10s %c"
argument_list|,
literal|" "
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_name
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_team
argument_list|)
expr_stmt|;
name|i
operator|=
name|STAT_MON_ROW
operator|+
literal|1
operator|+
operator|(
name|pp
operator|-
name|Player
operator|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|Player
init|;
name|np
operator|<
name|End_player
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|np
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|np
operator|=
name|Monitor
init|;
name|np
operator|<
name|End_monitor
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|np
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Erase the last monitor */
name|i
operator|=
name|STAT_MON_ROW
operator|+
literal|1
operator|+
operator|(
name|End_monitor
operator|-
name|Monitor
operator|)
expr_stmt|;
for|for
control|(
name|np
operator|=
name|Player
init|;
name|np
operator|<
name|End_player
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|ce
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|np
operator|=
name|Monitor
init|;
name|np
operator|<
name|End_monitor
condition|;
name|np
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|np
argument_list|,
name|i
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|ce
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|MONITOR
name|Fds_mask
operator|&=
operator|~
name|savemask
expr_stmt|;
if|if
condition|(
name|Num_fds
operator|==
name|savefd
operator|+
literal|1
condition|)
block|{
name|Num_fds
operator|=
name|Socket
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|Test_socket
operator|>
name|Socket
condition|)
name|Num_fds
operator|=
name|Test_socket
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
for|for
control|(
name|np
operator|=
name|Player
init|;
name|np
operator|<
name|End_player
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|p_fd
operator|>
name|Num_fds
condition|)
name|Num_fds
operator|=
name|np
operator|->
name|p_fd
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|np
operator|=
name|Monitor
init|;
name|np
operator|<
name|End_monitor
condition|;
name|np
operator|++
control|)
if|if
condition|(
name|np
operator|->
name|p_fd
operator|>
name|Num_fds
condition|)
name|Num_fds
operator|=
name|np
operator|->
name|p_fd
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
name|Num_fds
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * rand_num:  *	Return a random number in a given range.  */
end_comment

begin_macro
name|rand_num
argument_list|(
argument|range
argument_list|)
end_macro

begin_decl_stmt
name|int
name|range
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|range
operator|==
literal|0
condition|?
literal|0
else|:
name|RN
operator|%
name|range
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * havechar:  *	Check to see if we have any characters in the input queue; if  *	we do, read them, stash them away, and return TRUE; else return  *	FALSE.  */
end_comment

begin_expr_stmt
name|havechar
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_ncount
operator|<
name|pp
operator|->
name|p_nchar
condition|)
return|return
name|TRUE
return|;
if|if
condition|(
operator|!
operator|(
name|Have_inp
operator|&
name|pp
operator|->
name|p_mask
operator|)
condition|)
return|return
name|FALSE
return|;
name|Have_inp
operator|&=
operator|~
name|pp
operator|->
name|p_mask
expr_stmt|;
name|check_again
label|:
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|pp
operator|->
name|p_nchar
operator|=
name|read
argument_list|(
name|pp
operator|->
name|p_fd
argument_list|,
name|pp
operator|->
name|p_cbuf
argument_list|,
sizeof|sizeof
name|pp
operator|->
name|p_cbuf
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
goto|goto
name|check_again
goto|;
name|pp
operator|->
name|p_cbuf
index|[
literal|0
index|]
operator|=
literal|'q'
expr_stmt|;
block|}
name|pp
operator|->
name|p_ncount
operator|=
literal|0
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_comment
comment|/*  * cleanup:  *	Exit with the given value, cleaning up any droppings lying around  */
end_comment

begin_macro
name|cleanup
argument_list|(
argument|eval
argument_list|)
end_macro

begin_decl_stmt
name|int
name|eval
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|HEIGHT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|ENDWIN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|LAST_PLAYER
argument_list|,
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|HEIGHT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|ENDWIN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
name|LAST_PLAYER
argument_list|,
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MONITOR
operator|(
name|void
operator|)
name|close
argument_list|(
name|Socket
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|AF_UNIX_HACK
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|Sock_name
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|AF_UNIX_HACK
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * send_stats:  *	Print stats to requestor  */
end_comment

begin_macro
name|send_stats
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|IDENT
modifier|*
name|ip
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|SOCKET
name|sockstruct
decl_stmt|;
name|int
name|socklen
decl_stmt|;
comment|/* 	 * Get the output stream ready 	 */
ifdef|#
directive|ifdef
name|INTERNET
name|socklen
operator|=
sizeof|sizeof
name|sockstruct
expr_stmt|;
else|#
directive|else
name|socklen
operator|=
sizeof|sizeof
name|sockstruct
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|s
operator|=
name|accept
argument_list|(
name|Status
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockstruct
argument_list|,
operator|&
name|socklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return;
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"accept: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
return|return;
block|}
name|fp
operator|=
name|fdopen
argument_list|(
name|s
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"fdopen: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
name|perror
argument_list|(
literal|"fdopen"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Send output to requestor 	 */
name|fputs
argument_list|(
literal|"Name\t\tScore\tDucked\tAbsorb\tFaced\tShot\tRobbed\tMissed\tSlimeK\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|Scores
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t"
argument_list|,
name|ip
operator|->
name|i_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ip
operator|->
name|i_name
argument_list|)
operator|<
literal|8
condition|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%.2f\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n"
argument_list|,
name|ip
operator|->
name|i_score
argument_list|,
name|ip
operator|->
name|i_ducked
argument_list|,
name|ip
operator|->
name|i_absorbed
argument_list|,
name|ip
operator|->
name|i_faced
argument_list|,
name|ip
operator|->
name|i_shot
argument_list|,
name|ip
operator|->
name|i_robbed
argument_list|,
name|ip
operator|->
name|i_missed
argument_list|,
name|ip
operator|->
name|i_slime
argument_list|)
expr_stmt|;
block|}
name|fputs
argument_list|(
literal|"\n\nName\t\tEnemy\tFriend\tDeaths\tStill\tSaved\n"
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|ip
operator|=
name|Scores
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_team
operator|==
literal|' '
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\t"
argument_list|,
name|ip
operator|->
name|i_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ip
operator|->
name|i_name
argument_list|)
operator|<
literal|8
condition|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s[%c]\t"
argument_list|,
name|ip
operator|->
name|i_name
argument_list|,
name|ip
operator|->
name|i_team
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|ip
operator|->
name|i_name
argument_list|)
operator|+
literal|3
operator|<
literal|8
condition|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%d\t%d\t%d\t%d\t%d\n"
argument_list|,
name|ip
operator|->
name|i_gkills
argument_list|,
name|ip
operator|->
name|i_bkills
argument_list|,
name|ip
operator|->
name|i_deaths
argument_list|,
name|ip
operator|->
name|i_stillb
argument_list|,
name|ip
operator|->
name|i_saved
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * clear_scores:  *	Clear out the scores so the next session start clean  */
end_comment

begin_macro
name|clear_scores
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|IDENT
modifier|*
name|ip
decl_stmt|,
modifier|*
name|nextip
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|Scores
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|nextip
control|)
block|{
name|nextip
operator|=
name|ip
operator|->
name|i_next
expr_stmt|;
operator|(
name|void
operator|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ip
argument_list|)
expr_stmt|;
block|}
name|Scores
operator|=
name|NULL
expr_stmt|;
block|}
end_block

end_unit

