begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  *  *  Copyright (c) 1985 Regents of the University of California.  *  All rights reserved.  The Berkeley software License Agreement  *  specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_define
define|#
directive|define
name|SCOREDECAY
value|15
end_define

begin_decl_stmt
specifier|static
name|char
name|Ttyname
index|[
name|NAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|answer
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|newsock
decl_stmt|;
specifier|static
name|u_long
name|mode
decl_stmt|;
specifier|static
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
specifier|static
name|char
name|team
decl_stmt|;
specifier|static
name|int
name|enter_status
decl_stmt|;
specifier|static
name|int
name|socklen
decl_stmt|;
specifier|static
name|u_long
name|machine
decl_stmt|;
specifier|static
name|u_long
name|uid
decl_stmt|;
specifier|static
name|SOCKET
name|sockstruct
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|flags
decl_stmt|;
name|long
name|version
decl_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
name|socklen
operator|=
sizeof|sizeof
name|sockstruct
expr_stmt|;
else|#
directive|else
name|socklen
operator|=
sizeof|sizeof
name|sockstruct
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|errno
operator|=
literal|0
expr_stmt|;
name|newsock
operator|=
name|accept
argument_list|(
name|Socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sockstruct
argument_list|,
operator|&
name|socklen
argument_list|)
expr_stmt|;
if|if
condition|(
name|newsock
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
condition|)
return|return
name|FALSE
return|;
ifdef|#
directive|ifdef
name|LOG
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"accept: %m"
argument_list|)
expr_stmt|;
else|#
directive|else
else|LOG
name|perror
argument_list|(
literal|"accept"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|LOG
name|cleanup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INTERNET
name|machine
operator|=
name|ntohl
argument_list|(
operator|(
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
operator|&
name|sockstruct
operator|)
operator|->
name|sin_addr
operator|.
name|s_addr
argument_list|)
expr_stmt|;
else|#
directive|else
else|INTERNET
if|if
condition|(
name|machine
operator|==
literal|0
condition|)
name|machine
operator|=
name|gethostid
argument_list|()
expr_stmt|;
endif|#
directive|endif
endif|INTERNET
name|version
operator|=
name|htonl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|HUNT_VERSION
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|version
argument_list|,
name|LONGLEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|uid
argument_list|,
name|LONGLEN
argument_list|)
expr_stmt|;
name|uid
operator|=
name|ntohl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|uid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
name|name
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
operator|&
name|team
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|enter_status
argument_list|,
name|LONGLEN
argument_list|)
expr_stmt|;
name|enter_status
operator|=
name|ntohl
argument_list|(
operator|(
name|unsigned
name|long
operator|)
name|enter_status
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
name|Ttyname
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|read
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mode
argument_list|,
sizeof|sizeof
name|mode
argument_list|)
expr_stmt|;
name|mode
operator|=
name|ntohl
argument_list|(
name|mode
argument_list|)
expr_stmt|;
comment|/* 	 * Turn off blocking I/O, so a slow or dead terminal won't stop 	 * the game.  All subsequent reads check how many bytes they read. 	 */
name|flags
operator|=
name|fcntl
argument_list|(
name|newsock
argument_list|,
name|F_GETFL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|flags
operator||=
name|O_NDELAY
expr_stmt|;
operator|(
name|void
operator|)
name|fcntl
argument_list|(
name|newsock
argument_list|,
name|F_SETFL
argument_list|,
name|flags
argument_list|)
expr_stmt|;
comment|/* 	 * Make sure the name contains only printable characters 	 * since we use control characters for cursor control 	 * between driver and player processes 	 */
for|for
control|(
name|cp1
operator|=
name|cp2
operator|=
name|name
init|;
operator|*
name|cp1
operator|!=
literal|'\0'
condition|;
name|cp1
operator|++
control|)
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|cp1
argument_list|)
operator|||
operator|*
name|cp1
operator|==
literal|' '
condition|)
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
expr_stmt|;
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|mode
operator|==
name|C_MESSAGE
condition|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
if|if
condition|(
name|team
operator|==
literal|' '
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s: "
argument_list|,
name|name
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s[%c]: "
argument_list|,
name|name
argument_list|,
name|team
argument_list|)
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|HEIGHT
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|newsock
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
name|outstr
argument_list|(
name|pp
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
name|ce
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
endif|#
directive|endif
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|mode
operator|==
name|C_MONITOR
condition|)
if|if
condition|(
name|End_monitor
operator|<
operator|&
name|Monitor
index|[
name|MAXMON
index|]
condition|)
name|pp
operator|=
name|End_monitor
operator|++
expr_stmt|;
else|else
block|{
name|socklen
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|socklen
argument_list|,
sizeof|sizeof
name|socklen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
elseif|else
endif|#
directive|endif
endif|MONITOR
if|if
condition|(
name|End_player
operator|<
operator|&
name|Player
index|[
name|MAXPL
index|]
condition|)
name|pp
operator|=
name|End_player
operator|++
expr_stmt|;
else|else
block|{
name|socklen
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|newsock
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|socklen
argument_list|,
sizeof|sizeof
name|socklen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|newsock
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|mode
operator|==
name|C_MONITOR
operator|&&
name|team
operator|==
literal|' '
condition|)
name|team
operator|=
literal|'*'
expr_stmt|;
endif|#
directive|endif
name|pp
operator|->
name|p_ident
operator|=
name|get_ident
argument_list|(
name|machine
argument_list|,
name|uid
argument_list|,
name|name
argument_list|,
name|team
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_output
operator|=
name|fdopen
argument_list|(
name|newsock
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_death
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|pp
operator|->
name|p_fd
operator|=
name|newsock
expr_stmt|;
name|pp
operator|->
name|p_mask
operator|=
operator|(
literal|1
operator|<<
name|pp
operator|->
name|p_fd
operator|)
expr_stmt|;
name|Fds_mask
operator||=
name|pp
operator|->
name|p_mask
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_fd
operator|>=
name|Num_fds
condition|)
name|Num_fds
operator|=
name|pp
operator|->
name|p_fd
operator|+
literal|1
expr_stmt|;
name|pp
operator|->
name|p_y
operator|=
literal|0
expr_stmt|;
name|pp
operator|->
name|p_x
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|mode
operator|==
name|C_MONITOR
condition|)
name|stmonitor
argument_list|(
name|pp
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|MONITOR
name|stplayer
argument_list|(
name|pp
argument_list|,
name|enter_status
argument_list|)
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|MONITOR
end_ifdef

begin_expr_stmt
name|stmonitor
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|line
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|npp
decl_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|Maze
argument_list|,
operator|(
name|char
operator|*
operator|)
name|pp
operator|->
name|p_maze
argument_list|,
sizeof|sizeof
name|Maze
argument_list|)
expr_stmt|;
name|drawmaze
argument_list|(
name|pp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%5.5s%c%-10.10s %c"
argument_list|,
literal|" "
argument_list|,
name|stat_char
argument_list|(
name|pp
argument_list|)
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_name
argument_list|,
name|pp
operator|->
name|p_ident
operator|->
name|i_team
argument_list|)
expr_stmt|;
name|line
operator|=
name|STAT_MON_ROW
operator|+
literal|1
operator|+
operator|(
name|pp
operator|-
name|Monitor
operator|)
expr_stmt|;
for|for
control|(
name|npp
operator|=
name|Player
init|;
name|npp
operator|<
name|End_player
condition|;
name|npp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|npp
argument_list|,
name|line
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|npp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|npp
operator|=
name|Monitor
init|;
name|npp
operator|<
name|End_monitor
condition|;
name|npp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|npp
argument_list|,
name|line
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|npp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|pp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MONITOR
end_endif

begin_expr_stmt
name|stplayer
argument_list|(
name|newpp
argument_list|,
name|enter_status
argument_list|)
specifier|register
name|PLAYER
operator|*
name|newpp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|enter_status
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
name|Nplayer
operator|++
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|UBOUND
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|WIDTH
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
init|;
name|y
operator|<
name|DBOUND
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|LBOUND
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
for|for
control|(
init|;
name|x
operator|<
name|RBOUND
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
for|for
control|(
init|;
name|x
operator|<
name|WIDTH
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
block|}
for|for
control|(
init|;
name|y
operator|<
name|HEIGHT
condition|;
name|y
operator|++
control|)
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|WIDTH
condition|;
name|x
operator|++
control|)
name|newpp
operator|->
name|p_maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|newpp
operator|->
name|p_over
operator|=
name|SPACE
expr_stmt|;
name|newpp
operator|->
name|p_x
operator|=
name|x
expr_stmt|;
name|newpp
operator|->
name|p_y
operator|=
name|y
expr_stmt|;
name|newpp
operator|->
name|p_undershot
operator|=
name|FALSE
expr_stmt|;
ifdef|#
directive|ifdef
name|FLY
if|if
condition|(
name|enter_status
operator|==
name|Q_FLY
condition|)
block|{
name|newpp
operator|->
name|p_flying
operator|=
name|rand_num
argument_list|(
literal|20
argument_list|)
expr_stmt|;
name|newpp
operator|->
name|p_flyx
operator|=
literal|2
operator|*
name|rand_num
argument_list|(
literal|6
argument_list|)
operator|-
literal|5
expr_stmt|;
name|newpp
operator|->
name|p_flyy
operator|=
literal|2
operator|*
name|rand_num
argument_list|(
literal|6
argument_list|)
operator|-
literal|5
expr_stmt|;
name|newpp
operator|->
name|p_face
operator|=
name|FLYER
expr_stmt|;
block|}
else|else
endif|#
directive|endif
endif|FLY
block|{
name|newpp
operator|->
name|p_flying
operator|=
operator|-
literal|1
expr_stmt|;
name|newpp
operator|->
name|p_face
operator|=
name|rand_dir
argument_list|()
expr_stmt|;
block|}
name|newpp
operator|->
name|p_damage
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_damcap
operator|=
name|MAXDAM
expr_stmt|;
name|newpp
operator|->
name|p_nchar
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_ncount
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_nexec
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_ammo
operator|=
name|ISHOTS
expr_stmt|;
ifdef|#
directive|ifdef
name|BOOTS
name|newpp
operator|->
name|p_nboots
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|BOOTS
if|if
condition|(
name|enter_status
operator|==
name|Q_SCAN
condition|)
block|{
name|newpp
operator|->
name|p_scan
operator|=
name|SCANLEN
expr_stmt|;
name|newpp
operator|->
name|p_cloak
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|newpp
operator|->
name|p_scan
operator|=
literal|0
expr_stmt|;
name|newpp
operator|->
name|p_cloak
operator|=
name|CLOAKLEN
expr_stmt|;
block|}
name|newpp
operator|->
name|p_ncshot
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|GMINE
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
do|do
block|{
name|x
operator|=
name|rand_num
argument_list|(
name|WIDTH
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
name|y
operator|=
name|rand_num
argument_list|(
name|HEIGHT
operator|-
literal|1
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
name|SPACE
condition|)
do|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|MINE
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%5.2f%c%-10.10s %c"
argument_list|,
name|newpp
operator|->
name|p_ident
operator|->
name|i_score
argument_list|,
name|stat_char
argument_list|(
name|newpp
argument_list|)
argument_list|,
name|newpp
operator|->
name|p_ident
operator|->
name|i_name
argument_list|,
name|newpp
operator|->
name|p_ident
operator|->
name|i_team
argument_list|)
expr_stmt|;
name|y
operator|=
name|STAT_PLAY_ROW
operator|+
literal|1
operator|+
operator|(
name|newpp
operator|-
name|Player
operator|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|!=
name|newpp
condition|)
block|{
name|char
name|smallbuf
index|[
literal|10
index|]
decl_stmt|;
name|pp
operator|->
name|p_ammo
operator|+=
name|NSHOTS
expr_stmt|;
name|newpp
operator|->
name|p_ammo
operator|+=
name|NSHOTS
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|smallbuf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|smallbuf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|STAT_NAME_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
name|STAT_NAME_LEN
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|MONITOR
name|drawmaze
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
name|drawplayer
argument_list|(
name|newpp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|look
argument_list|(
name|newpp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLY
if|if
condition|(
name|enter_status
operator|==
name|Q_FLY
condition|)
comment|/* Make sure that the position you enter in will be erased */
name|showexpl
argument_list|(
name|newpp
operator|->
name|p_y
argument_list|,
name|newpp
operator|->
name|p_x
argument_list|,
name|FLYER
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|sendcom
argument_list|(
name|newpp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|newpp
argument_list|,
name|READY
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|newpp
operator|->
name|p_output
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * rand_dir:  *	Return a random direction  */
end_comment

begin_macro
name|rand_dir
argument_list|()
end_macro

begin_block
block|{
switch|switch
condition|(
name|rand_num
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
return|return
name|LEFTS
return|;
case|case
literal|1
case|:
return|return
name|RIGHT
return|;
case|case
literal|2
case|:
return|return
name|BELOW
return|;
case|case
literal|3
case|:
return|return
name|ABOVE
return|;
block|}
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * get_ident:  *	Get the score structure of a player  */
end_comment

begin_function
name|IDENT
modifier|*
name|get_ident
parameter_list|(
name|machine
parameter_list|,
name|uid
parameter_list|,
name|name
parameter_list|,
name|team
parameter_list|)
name|u_long
name|machine
decl_stmt|;
name|u_long
name|uid
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|;
name|char
name|team
decl_stmt|;
block|{
specifier|register
name|IDENT
modifier|*
name|ip
decl_stmt|;
specifier|static
name|IDENT
name|punt
decl_stmt|;
for|for
control|(
name|ip
operator|=
name|Scores
init|;
name|ip
operator|!=
name|NULL
condition|;
name|ip
operator|=
name|ip
operator|->
name|i_next
control|)
if|if
condition|(
name|ip
operator|->
name|i_machine
operator|==
name|machine
operator|&&
name|ip
operator|->
name|i_uid
operator|==
name|uid
operator|&&
name|ip
operator|->
name|i_team
operator|==
name|team
operator|&&
name|strncmp
argument_list|(
name|ip
operator|->
name|i_name
argument_list|,
name|name
argument_list|,
name|NAMELEN
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|ip
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ip
operator|->
name|i_entries
operator|<
name|SCOREDECAY
condition|)
name|ip
operator|->
name|i_entries
operator|++
expr_stmt|;
else|else
name|ip
operator|->
name|i_kills
operator|=
operator|(
name|ip
operator|->
name|i_kills
operator|*
operator|(
name|SCOREDECAY
operator|-
literal|1
operator|)
operator|)
operator|/
name|SCOREDECAY
expr_stmt|;
name|ip
operator|->
name|i_score
operator|=
name|ip
operator|->
name|i_kills
operator|/
operator|(
name|double
operator|)
name|ip
operator|->
name|i_entries
expr_stmt|;
block|}
else|else
block|{
name|ip
operator|=
operator|(
name|IDENT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|IDENT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ip
operator|==
name|NULL
condition|)
block|{
comment|/* Fourth down, time to punt */
name|ip
operator|=
operator|&
name|punt
expr_stmt|;
block|}
name|ip
operator|->
name|i_machine
operator|=
name|machine
expr_stmt|;
name|ip
operator|->
name|i_team
operator|=
name|team
expr_stmt|;
name|ip
operator|->
name|i_uid
operator|=
name|uid
expr_stmt|;
name|strncpy
argument_list|(
name|ip
operator|->
name|i_name
argument_list|,
name|name
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|ip
operator|->
name|i_kills
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_entries
operator|=
literal|1
expr_stmt|;
name|ip
operator|->
name|i_score
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_absorbed
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_faced
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_shot
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_robbed
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_slime
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_missed
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_ducked
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_gkills
operator|=
name|ip
operator|->
name|i_bkills
operator|=
name|ip
operator|->
name|i_deaths
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_stillb
operator|=
name|ip
operator|->
name|i_saved
operator|=
literal|0
expr_stmt|;
name|ip
operator|->
name|i_next
operator|=
name|Scores
expr_stmt|;
name|Scores
operator|=
name|ip
expr_stmt|;
block|}
return|return
name|ip
return|;
block|}
end_function

end_unit

