begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  *  *  Copyright (c) 1985 Regents of the University of California.  *  All rights reserved.  The Berkeley software License Agreement  *  specifies the terms and conditions for redistribution.  */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|HPUX
end_ifndef

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMINFO
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_define
define|#
directive|define
name|CM
value|cursor_address
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/*  * Some old versions of curses don't have these defined  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|cbreak
end_ifndef

begin_define
define|#
directive|define
name|cbreak
parameter_list|()
value|crmode()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	these numbers are contrived to allow 3 users on a VAX 11/750  *	i.e. an spin loop of 10000 iterations in 30 milliseconds.  */
end_comment

begin_define
define|#
directive|define
name|LOOP_COUNT
value|10000
end_define

begin_define
define|#
directive|define
name|FUDGE_FACTOR
value|30
end_define

begin_decl_stmt
name|FLAG
name|Last_player
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MONITOR
end_ifdef

begin_decl_stmt
name|FLAG
name|Am_monitor
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|MONITOR
end_endif

begin_decl_stmt
name|char
name|Buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|Socket
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|Sock_host
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|use_port
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLAG
name|Query_driver
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|Send_message
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FLAG
name|Show_scores
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_decl_stmt
name|SOCKET
name|Daemon
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_define
define|#
directive|define
name|DAEMON_SIZE
value|(sizeof Daemon)
end_define

begin_else
else|#
directive|else
else|INTERNET
end_else

begin_define
define|#
directive|define
name|DAEMON_SIZE
value|(sizeof Daemon - 1)
end_define

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_decl_stmt
name|char
name|map_key
index|[
literal|256
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* what to map keys to */
end_comment

begin_decl_stmt
name|FLAG
name|no_beep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|name
index|[
name|NAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|team
init|=
literal|' '
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|in_visual
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|cur_row
decl_stmt|,
name|cur_col
decl_stmt|,
name|_putchar
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_function_decl
specifier|extern
name|SOCKET
modifier|*
name|list_drivers
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * main:  *	Main program for local process  */
end_comment

begin_function
name|main
parameter_list|(
name|ac
parameter_list|,
name|av
parameter_list|)
name|int
name|ac
decl_stmt|;
name|char
modifier|*
modifier|*
name|av
decl_stmt|;
block|{
name|char
modifier|*
name|term
decl_stmt|;
name|int
name|c
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|int
name|Otto_mode
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
name|long
name|enter_status
decl_stmt|;
name|int
name|intr
argument_list|()
decl_stmt|,
name|sigterm
argument_list|()
decl_stmt|,
name|sigemt
argument_list|()
decl_stmt|,
name|tstp
argument_list|()
decl_stmt|;
name|long
name|env_init
argument_list|()
decl_stmt|,
name|quit
argument_list|()
decl_stmt|;
name|enter_status
operator|=
name|env_init
argument_list|(
operator|(
name|long
operator|)
name|Q_CLOAK
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"Sbcfh:l:mn:op:qst:w:"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|INTERNET
case|case
literal|'S'
case|:
name|Show_scores
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
case|case
literal|'l'
case|:
comment|/* rsh compatibility */
case|case
literal|'n'
case|:
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|name
argument_list|,
name|optarg
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|team
operator|=
operator|*
name|optarg
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|team
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Team names must be numeric\n"
argument_list|)
expr_stmt|;
name|team
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|'o'
case|:
ifndef|#
directive|ifndef
name|OTTO
name|fputs
argument_list|(
literal|"The -o flag is reserved for future use.\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
else|#
directive|else
else|OTTO
name|Otto_mode
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
endif|OTTO
ifdef|#
directive|ifdef
name|MONITOR
case|case
literal|'m'
case|:
name|Am_monitor
operator|=
name|TRUE
expr_stmt|;
break|break;
endif|#
directive|endif
endif|MONITOR
ifdef|#
directive|ifdef
name|INTERNET
case|case
literal|'q'
case|:
comment|/* query whether hunt is running */
name|Query_driver
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|Send_message
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|Sock_host
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|use_port
operator|=
name|optarg
expr_stmt|;
name|Test_port
operator|=
name|atoi
argument_list|(
name|use_port
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|INTERNET
case|case
literal|'c'
case|:
name|enter_status
operator|=
name|Q_CLOAK
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FLY
case|case
literal|'f'
case|:
name|enter_status
operator|=
name|Q_FLY
expr_stmt|;
break|break;
endif|#
directive|endif
endif|FLY
case|case
literal|'s'
case|:
name|enter_status
operator|=
name|Q_SCAN
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|no_beep
operator|=
operator|!
name|no_beep
expr_stmt|;
break|break;
default|default:
name|usage
label|:
ifdef|#
directive|ifdef
name|INTERNET
ifdef|#
directive|ifdef
name|MONITOR
define|#
directive|define
name|USAGE
value|"usage:\thunt [-qmcsfS] [-n name] [-t team]\n\t[-p port] [-w message] [host]\n"
else|#
directive|else
else|MONITOR
define|#
directive|define
name|USAGE
value|"usage:\thunt [-qcsfS] [-n name] [-t team]\n\t[-p port] [-w message] [host]\n"
endif|#
directive|endif
endif|MONITOR
else|#
directive|else
else|INTERNET
ifdef|#
directive|ifdef
name|MONITOR
define|#
directive|define
name|USAGE
value|"usage:\thunt [-mcsf] [-n name] [-t team]\n"
else|#
directive|else
else|MONITOR
define|#
directive|define
name|USAGE
value|"usage:\thunt [-csf] [-n name] [-t team]\n"
endif|#
directive|endif
endif|MONITOR
endif|#
directive|endif
endif|INTERNET
name|fputs
argument_list|(
name|USAGE
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
undef|#
directive|undef
name|USAGE
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|optind
operator|+
literal|1
operator|<
name|ac
condition|)
goto|goto
name|usage
goto|;
elseif|else
if|if
condition|(
name|optind
operator|+
literal|1
operator|==
name|ac
condition|)
name|Sock_host
operator|=
name|av
index|[
name|ac
operator|-
literal|1
index|]
expr_stmt|;
else|#
directive|else
else|INTERNET
if|if
condition|(
name|optind
operator|>
name|ac
condition|)
goto|goto
name|usage
goto|;
endif|#
directive|endif
endif|INTERNET
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|Show_scores
condition|)
block|{
name|SOCKET
modifier|*
name|hosts
decl_stmt|;
for|for
control|(
name|hosts
operator|=
name|list_drivers
argument_list|()
init|;
name|hosts
operator|->
name|sin_port
operator|!=
literal|0
condition|;
name|hosts
operator|+=
literal|1
control|)
name|dump_scores
argument_list|(
operator|*
name|hosts
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Query_driver
condition|)
block|{
name|SOCKET
modifier|*
name|hosts
decl_stmt|;
for|for
control|(
name|hosts
operator|=
name|list_drivers
argument_list|()
init|;
name|hosts
operator|->
name|sin_port
operator|!=
literal|0
condition|;
name|hosts
operator|+=
literal|1
control|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|num_players
decl_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hosts
operator|->
name|sin_addr
argument_list|,
sizeof|sizeof
name|hosts
operator|->
name|sin_addr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|num_players
operator|=
name|ntohs
argument_list|(
name|hosts
operator|->
name|sin_port
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%d player%s hunting on %s!\n"
argument_list|,
name|num_players
argument_list|,
operator|(
name|num_players
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|,
name|hp
operator|!=
name|NULL
condition|?
name|hp
operator|->
name|h_name
else|:
name|inet_ntoa
argument_list|(
name|hosts
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|INTERNET
ifdef|#
directive|ifdef
name|OTTO
if|if
condition|(
name|Otto_mode
condition|)
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|name
argument_list|,
literal|"otto"
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
endif|OTTO
name|fill_in_blanks
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isatty
argument_list|(
literal|0
argument_list|)
operator|||
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no terminal type\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|TERMINFO
name|initscr
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|noecho
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cbreak
argument_list|()
expr_stmt|;
else|#
directive|else
name|_tty_ch
operator|=
literal|0
expr_stmt|;
name|gettmode
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|setterm
argument_list|(
name|term
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|noecho
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|cbreak
argument_list|()
expr_stmt|;
name|_puts
argument_list|(
name|TI
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|VS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|in_visual
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|LINES
operator|<
name|SCREEN_HEIGHT
operator|||
name|COLS
operator|<
name|SCREEN_WIDTH
condition|)
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Need a larger window"
argument_list|)
expr_stmt|;
name|clear_the_screen
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTERM
argument_list|,
name|sigterm
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|sigemt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SIGTSTP
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstp
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
block|{
specifier|register
name|int
name|loop
decl_stmt|;
name|struct
name|timeval
name|start
decl_stmt|,
name|stop
decl_stmt|;
name|int
name|elapsed_time
decl_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|loop
operator|=
literal|0
init|;
name|loop
operator|<
name|LOOP_COUNT
condition|;
name|loop
operator|++
control|)
continue|continue;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|stop
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|elapsed_time
operator|=
operator|(
name|stop
operator|.
name|tv_sec
operator|-
name|start
operator|.
name|tv_sec
operator|)
operator|*
literal|1000000
operator|+
name|stop
operator|.
name|tv_usec
operator|-
name|start
operator|.
name|tv_usec
expr_stmt|;
if|if
condition|(
name|elapsed_time
operator|>
name|LOOP_COUNT
operator|*
name|FUDGE_FACTOR
condition|)
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Response time too slow"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INTERNET
name|find_driver
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|Daemon
operator|.
name|sin_port
operator|==
literal|0
condition|)
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Game not found, try again"
argument_list|)
expr_stmt|;
name|jump_in
label|:
do|do
block|{
name|int
name|option
decl_stmt|;
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|Socket
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|option
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|Socket
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_USELOOPBACK
argument_list|,
operator|&
name|option
argument_list|,
sizeof|sizeof
name|option
argument_list|)
operator|<
literal|0
condition|)
name|perror
argument_list|(
literal|"setsockopt loopback"
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|Socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ECONNREFUSED
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"connect"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
break|break;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|close
argument_list|(
name|Socket
argument_list|)
operator|==
literal|0
condition|)
do|;
else|#
directive|else
else|INTERNET
comment|/* 		 * set up a socket 		 */
if|if
condition|(
operator|(
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* 		 * attempt to connect the socket to a name; if it fails that 		 * usually means that the driver isn't running, so we start 		 * up the driver. 		 */
name|Daemon
operator|.
name|sun_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|Daemon
operator|.
name|sun_path
argument_list|,
name|Sock_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|connect
argument_list|(
name|Socket
argument_list|,
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"connect2"
argument_list|)
expr_stmt|;
block|}
name|start_driver
argument_list|()
expr_stmt|;
do|do
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|Socket
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|Socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|connect
argument_list|(
name|Socket
argument_list|,
operator|&
name|Daemon
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
do|;
block|}
endif|#
directive|endif
endif|INTERNET
name|do_connect
argument_list|(
name|name
argument_list|,
name|team
argument_list|,
name|enter_status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|Send_message
operator|!=
name|NULL
condition|)
block|{
name|do_message
argument_list|()
expr_stmt|;
if|if
condition|(
name|enter_status
operator|==
name|Q_MESSAGE
condition|)
break|break;
name|Send_message
operator|=
name|NULL
expr_stmt|;
comment|/* don't continue as that will call find_driver */
goto|goto
name|jump_in
goto|;
block|}
endif|#
directive|endif
name|playit
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|enter_status
operator|=
name|quit
argument_list|(
name|enter_status
argument_list|)
operator|)
operator|==
name|Q_QUIT
condition|)
break|break;
block|}
name|leave
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_ifdef
ifdef|#
directive|ifdef
name|BROADCAST
end_ifdef

begin_macro
name|broadcast_vec
argument_list|(
argument|s
argument_list|,
argument|vector
argument_list|)
end_macro

begin_decl_stmt
name|int
name|s
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* socket */
end_comment

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
modifier|*
name|vector
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|if_buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|struct
name|ifconf
name|ifc
decl_stmt|;
name|struct
name|ifreq
modifier|*
name|ifr
decl_stmt|;
name|unsigned
name|int
name|n
decl_stmt|;
name|int
name|vec_cnt
decl_stmt|;
operator|*
name|vector
operator|=
name|NULL
expr_stmt|;
name|ifc
operator|.
name|ifc_len
operator|=
sizeof|sizeof
name|if_buf
expr_stmt|;
name|ifc
operator|.
name|ifc_buf
operator|=
name|if_buf
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFCONF
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|ifc
argument_list|)
operator|<
literal|0
condition|)
return|return
literal|0
return|;
name|vec_cnt
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|ifc
operator|.
name|ifc_len
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|ifreq
argument_list|)
expr_stmt|;
operator|*
name|vector
operator|=
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|malloc
argument_list|(
name|n
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|ifr
operator|=
name|ifc
operator|.
name|ifc_req
init|;
name|n
operator|!=
literal|0
condition|;
name|n
operator|--
operator|,
name|ifr
operator|++
control|)
if|if
condition|(
name|ioctl
argument_list|(
name|s
argument_list|,
name|SIOCGIFBRDADDR
argument_list|,
name|ifr
argument_list|)
operator|>=
literal|0
condition|)
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ifr
operator|->
name|ifr_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
operator|(
operator|*
name|vector
operator|)
index|[
name|vec_cnt
operator|++
index|]
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|sockaddr
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|vec_cnt
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|BROADCAST
end_endif

begin_function
name|SOCKET
modifier|*
name|list_drivers
parameter_list|()
block|{
name|int
name|option
decl_stmt|;
name|u_short
name|msg
decl_stmt|;
name|u_short
name|port_num
decl_stmt|;
specifier|static
name|SOCKET
name|test
decl_stmt|;
name|int
name|test_socket
decl_stmt|;
name|int
name|namelen
decl_stmt|;
name|char
name|local_name
index|[
literal|256
index|]
decl_stmt|;
specifier|static
name|initial
operator|=
name|TRUE
expr_stmt|;
specifier|static
name|struct
name|in_addr
name|local_address
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
specifier|extern
name|int
name|errno
decl_stmt|;
ifdef|#
directive|ifdef
name|BROADCAST
specifier|static
name|int
name|brdc
decl_stmt|;
specifier|static
name|SOCKET
modifier|*
name|brdv
decl_stmt|;
else|#
directive|else
name|u_long
name|local_net
decl_stmt|;
endif|#
directive|endif
endif|BROADCAST
name|int
name|i
decl_stmt|;
specifier|static
name|SOCKET
modifier|*
name|listv
decl_stmt|;
specifier|static
name|unsigned
name|int
name|listmax
decl_stmt|;
name|unsigned
name|int
name|listc
decl_stmt|;
name|int
name|mask
decl_stmt|;
name|struct
name|timeval
name|wait
decl_stmt|;
if|if
condition|(
name|initial
condition|)
block|{
comment|/* do one time initialization */
ifndef|#
directive|ifndef
name|BROADCAST
name|sethostent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* don't bother to close host file */
endif|#
directive|endif
endif|BROADCAST
if|if
condition|(
name|gethostname
argument_list|(
name|local_name
argument_list|,
sizeof|sizeof
name|local_name
argument_list|)
operator|<
literal|0
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Sorry, I have no name."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|local_name
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Can't find myself."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|local_address
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
expr_stmt|;
name|listmax
operator|=
literal|20
expr_stmt|;
name|listv
operator|=
operator|(
name|SOCKET
operator|*
operator|)
name|malloc
argument_list|(
name|listmax
operator|*
sizeof|sizeof
argument_list|(
name|SOCKET
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|Sock_host
operator|!=
name|NULL
condition|)
return|return
name|listv
return|;
comment|/* address already valid */
name|test_socket
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_DGRAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|test_socket
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"socket system call failed"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|test
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|test
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
name|Test_port
argument_list|)
expr_stmt|;
name|listc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|Sock_host
operator|!=
name|NULL
condition|)
block|{
comment|/* explicit host given */
if|if
condition|(
operator|(
name|hp
operator|=
name|gethostbyname
argument_list|(
name|Sock_host
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Unknown host"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|test
operator|.
name|sin_addr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
expr_stmt|;
goto|goto
name|test_one_host
goto|;
block|}
if|if
condition|(
operator|!
name|initial
condition|)
block|{
comment|/* favor host of previous session by broadcasting to it first */
name|test
operator|.
name|sin_addr
operator|=
name|Daemon
operator|.
name|sin_addr
expr_stmt|;
name|msg
operator|=
name|htons
argument_list|(
name|C_PLAYER
argument_list|)
expr_stmt|;
comment|/* Must be playing! */
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BROADCAST
if|if
condition|(
name|initial
condition|)
name|brdc
operator|=
name|broadcast_vec
argument_list|(
name|test_socket
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|*
operator|)
operator|&
name|brdv
argument_list|)
expr_stmt|;
if|if
condition|(
name|brdc
operator|<=
literal|0
condition|)
block|{
name|initial
operator|=
name|FALSE
expr_stmt|;
name|test
operator|.
name|sin_addr
operator|=
name|local_address
expr_stmt|;
goto|goto
name|test_one_host
goto|;
block|}
ifdef|#
directive|ifdef
name|SO_BROADCAST
comment|/* Sun's will broadcast even though this option can't be set */
name|option
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|test_socket
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_BROADCAST
argument_list|,
operator|(
name|int
operator|)
operator|&
name|option
argument_list|,
sizeof|sizeof
name|option
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"setsockopt broadcast"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"setsockopt broadcast"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
comment|/* send broadcast packets on all interfaces */
name|msg
operator|=
name|htons
argument_list|(
name|C_TESTMSG
argument_list|()
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|brdc
condition|;
name|i
operator|++
control|)
block|{
name|test
operator|.
name|sin_addr
operator|=
name|brdv
index|[
name|i
index|]
operator|.
name|sin_addr
expr_stmt|;
if|if
condition|(
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"sendto"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"sendto"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
else|#
directive|else
else|BROADCAST
comment|/* loop thru all hosts on local net and send msg to them. */
name|msg
operator|=
name|htons
argument_list|(
name|C_TESTMSG
argument_list|()
argument_list|)
expr_stmt|;
name|local_net
operator|=
name|inet_netof
argument_list|(
name|local_address
argument_list|)
expr_stmt|;
name|sethostent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* rewind host file */
while|while
condition|(
name|hp
operator|=
name|gethostent
argument_list|()
condition|)
block|{
if|if
condition|(
name|local_net
operator|==
name|inet_netof
argument_list|(
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
argument_list|)
condition|)
block|{
name|test
operator|.
name|sin_addr
operator|=
operator|*
operator|(
operator|(
expr|struct
name|in_addr
operator|*
operator|)
name|hp
operator|->
name|h_addr
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|BROADCAST
name|get_response
label|:
name|namelen
operator|=
name|DAEMON_SIZE
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|wait
operator|.
name|tv_sec
operator|=
literal|1
expr_stmt|;
name|wait
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|listc
operator|+
literal|1
operator|>=
name|listmax
condition|)
block|{
name|listmax
operator|+=
literal|20
expr_stmt|;
name|listv
operator|=
operator|(
name|SOCKET
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|listv
argument_list|,
name|listmax
operator|*
sizeof|sizeof
argument_list|(
name|SOCKET
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mask
operator|=
literal|1
operator|<<
name|test_socket
expr_stmt|;
if|if
condition|(
name|select
argument_list|(
name|test_socket
operator|+
literal|1
argument_list|,
operator|&
name|mask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|wait
argument_list|)
operator|==
literal|1
operator|&&
name|recvfrom
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|port_num
argument_list|,
sizeof|sizeof
name|port_num
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|listv
index|[
name|listc
index|]
argument_list|,
operator|&
name|namelen
argument_list|)
operator|>
literal|0
condition|)
block|{
comment|/* 			 * Note that we do *not* convert from network to host 			 * order since the port number *should* be in network 			 * order: 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|listc
condition|;
name|i
operator|+=
literal|1
control|)
if|if
condition|(
name|listv
index|[
name|listc
index|]
operator|.
name|sin_addr
operator|.
name|s_addr
operator|==
name|listv
index|[
name|i
index|]
operator|.
name|sin_addr
operator|.
name|s_addr
condition|)
break|break;
if|if
condition|(
name|i
operator|==
name|listc
condition|)
name|listv
index|[
name|listc
operator|++
index|]
operator|.
name|sin_port
operator|=
name|port_num
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|errno
operator|!=
literal|0
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|perror
argument_list|(
literal|"select/recvfrom"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"select/recvfrom"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
comment|/* terminate list with local address */
name|listv
index|[
name|listc
index|]
operator|.
name|sin_family
operator|=
name|SOCK_FAMILY
expr_stmt|;
name|listv
index|[
name|listc
index|]
operator|.
name|sin_addr
operator|=
name|local_address
expr_stmt|;
name|listv
index|[
name|listc
index|]
operator|.
name|sin_port
operator|=
name|htons
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|test_socket
argument_list|)
expr_stmt|;
name|initial
operator|=
name|FALSE
expr_stmt|;
return|return
name|listv
return|;
block|}
name|test_one_host
label|:
name|msg
operator|=
name|htons
argument_list|(
name|C_TESTMSG
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sendto
argument_list|(
name|test_socket
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|msg
argument_list|,
sizeof|sizeof
name|msg
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|test
argument_list|,
name|DAEMON_SIZE
argument_list|)
expr_stmt|;
goto|goto
name|get_response
goto|;
block|}
end_function

begin_macro
name|find_driver
argument_list|(
argument|do_startup
argument_list|)
end_macro

begin_decl_stmt
name|FLAG
name|do_startup
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|SOCKET
modifier|*
name|hosts
decl_stmt|;
name|hosts
operator|=
name|list_drivers
argument_list|()
expr_stmt|;
if|if
condition|(
name|hosts
index|[
literal|0
index|]
operator|.
name|sin_port
operator|!=
name|htons
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|int
name|i
decl_stmt|,
name|c
decl_stmt|;
if|if
condition|(
name|hosts
index|[
literal|1
index|]
operator|.
name|sin_port
operator|==
name|htons
argument_list|(
literal|0
argument_list|)
condition|)
block|{
name|Daemon
operator|=
name|hosts
index|[
literal|0
index|]
expr_stmt|;
return|return;
block|}
comment|/* go thru list and return host that matches daemon */
name|clear_the_screen
argument_list|()
expr_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|1
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Pick one:"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|HEIGHT
operator|-
literal|4
operator|&&
name|hosts
index|[
name|i
index|]
operator|.
name|sin_port
operator|!=
name|htons
argument_list|(
literal|0
argument_list|)
condition|;
name|i
operator|+=
literal|1
control|)
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
name|buf
index|[
literal|80
index|]
decl_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|3
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|3
operator|+
name|i
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hosts
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
name|hosts
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%8c    %.64s"
argument_list|,
literal|'a'
operator|+
name|i
argument_list|,
name|hp
operator|!=
name|NULL
condition|?
name|hp
operator|->
name|h_name
else|:
name|inet_ntoa
argument_list|(
name|hosts
operator|->
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|put_str
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|4
operator|+
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|4
operator|+
name|i
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Enter letter: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|islower
argument_list|(
name|c
operator|=
name|getchar
argument_list|()
argument_list|)
operator|||
operator|(
name|c
operator|-=
literal|'a'
operator|)
operator|>=
name|i
condition|)
block|{
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|CTRL
argument_list|(
name|G
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|Daemon
operator|=
name|hosts
index|[
name|c
index|]
expr_stmt|;
name|clear_the_screen
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|do_startup
condition|)
return|return;
name|start_driver
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|find_driver
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|dump_scores
argument_list|(
argument|host
argument_list|)
end_macro

begin_decl_stmt
name|SOCKET
name|host
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|int
name|s
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|hp
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|host
operator|.
name|sin_addr
argument_list|,
sizeof|sizeof
name|host
operator|.
name|sin_addr
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n%s:\n"
argument_list|,
name|hp
operator|!=
name|NULL
condition|?
name|hp
operator|->
name|h_name
else|:
name|inet_ntoa
argument_list|(
name|host
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|SOCK_FAMILY
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"socket"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|host
argument_list|,
sizeof|sizeof
name|host
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
literal|"connect"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|cnt
operator|=
name|read
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|,
name|buf
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_macro
name|start_driver
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|procid
decl_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
if|if
condition|(
name|Am_monitor
condition|)
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"No one playing."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
endif|#
directive|endif
endif|MONITOR
ifdef|#
directive|ifdef
name|INTERNET
if|if
condition|(
name|Sock_host
operator|!=
name|NULL
condition|)
block|{
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
endif|INTERNET
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Starting..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|BSD_RELEASE
name|procid
operator|=
name|fork
argument_list|()
expr_stmt|;
else|#
directive|else
name|procid
operator|=
name|vfork
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|procid
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"fork"
argument_list|)
expr_stmt|;
name|leave
argument_list|(
literal|1
argument_list|,
literal|"fork failed."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|procid
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|INTERNET
operator|(
name|void
operator|)
name|close
argument_list|(
name|Socket
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|use_port
operator|==
name|NULL
condition|)
endif|#
directive|endif
name|execl
argument_list|(
name|Driver
argument_list|,
literal|"HUNT"
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|INTERNET
else|else
name|execl
argument_list|(
name|Driver
argument_list|,
literal|"HUNT"
argument_list|,
literal|"-p"
argument_list|,
name|use_port
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* only get here if exec failed */
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getppid
argument_list|()
argument_list|,
name|SIGEMT
argument_list|)
expr_stmt|;
comment|/* tell mom */
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Connecting..."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * bad_con:  *	We had a bad connection.  For the moment we assume that this  *	means the game is full.  */
end_comment

begin_macro
name|bad_con
argument_list|()
end_macro

begin_block
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"The game is full.  Sorry."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * bad_ver:  *	version number mismatch.  */
end_comment

begin_macro
name|bad_ver
argument_list|()
end_macro

begin_block
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Version number mismatch. No go."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * sigterm:  *	Handle a terminate signal  */
end_comment

begin_macro
name|sigterm
argument_list|()
end_macro

begin_block
block|{
name|leave
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_comment
comment|/*  * sigemt:  *	Handle a emt signal - shouldn't happen on vaxes(?)  */
end_comment

begin_macro
name|sigemt
argument_list|()
end_macro

begin_block
block|{
name|leave
argument_list|(
literal|1
argument_list|,
literal|"Unable to start driver.  Try again."
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|INTERNET
end_ifdef

begin_comment
comment|/*  * sigalrm:  *	Handle an alarm signal  */
end_comment

begin_macro
name|sigalrm
argument_list|()
end_macro

begin_block
block|{
return|return;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|INTERNET
end_endif

begin_comment
comment|/*  * rmnl:  *	Remove a '\n' at the end of a string if there is one  */
end_comment

begin_macro
name|rmnl
argument_list|(
argument|s
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|rindex
parameter_list|()
function_decl|;
name|cp
operator|=
name|rindex
argument_list|(
name|s
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * intr:  *	Handle a interrupt signal  */
end_comment

begin_macro
name|intr
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|ch
decl_stmt|;
specifier|register
name|int
name|explained
decl_stmt|;
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|y
operator|=
name|cur_row
expr_stmt|;
name|x
operator|=
name|cur_col
expr_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
name|put_str
argument_list|(
literal|"Really quit? "
argument_list|)
expr_stmt|;
name|clear_eol
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|explained
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isupper
argument_list|(
name|ch
argument_list|)
condition|)
name|ch
operator|=
name|tolower
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|'y'
condition|)
block|{
if|if
condition|(
name|Socket
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
name|Socket
argument_list|,
literal|"q"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|Socket
argument_list|)
expr_stmt|;
block|}
name|leave
argument_list|(
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'n'
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|cur_row
operator|=
name|y
expr_stmt|;
name|cur_col
operator|=
name|x
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|explained
condition|)
block|{
name|put_str
argument_list|(
literal|"(Yes or No) "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|explained
operator|=
name|TRUE
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putchar
argument_list|(
name|CTRL
argument_list|(
name|G
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * leave:  *	Leave the game somewhat gracefully, restoring all current  *	tty stats.  */
end_comment

begin_macro
name|leave
argument_list|(
argument|eval
argument_list|,
argument|mesg
argument_list|)
end_macro

begin_decl_stmt
name|int
name|eval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mesg
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|in_visual
condition|)
block|{
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/* flush in case VE changes pages */
ifdef|#
directive|ifdef
name|TERMINFO
name|putp
argument_list|(
name|cursor_normal
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|exit_ca_mode
argument_list|)
expr_stmt|;
name|reset_shell_mode
argument_list|()
expr_stmt|;
else|#
directive|else
name|resetty
argument_list|()
expr_stmt|;
name|_puts
argument_list|(
name|VE
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|TE
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|mesg
operator|!=
name|NULL
condition|)
name|puts
argument_list|(
name|mesg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|eval
argument_list|)
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_comment
comment|/*  * tstp:  *	Handle stop and start signals  */
end_comment

begin_macro
name|tstp
argument_list|()
end_macro

begin_block
block|{
ifndef|#
directive|ifndef
name|TERMINFO
specifier|static
name|struct
name|sgttyb
name|tty
decl_stmt|;
endif|#
directive|endif
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|y
operator|=
name|cur_row
expr_stmt|;
name|x
operator|=
name|cur_col
expr_stmt|;
name|mvcur
argument_list|(
name|cur_row
argument_list|,
name|cur_col
argument_list|,
literal|23
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cur_row
operator|=
literal|23
expr_stmt|;
name|cur_col
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMINFO
name|putp
argument_list|(
name|cursor_normal
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|exit_ca_mode
argument_list|)
expr_stmt|;
name|reset_shell_mode
argument_list|()
expr_stmt|;
else|#
directive|else
name|tty
operator|=
name|_tty
expr_stmt|;
name|_puts
argument_list|(
name|VE
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|TE
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|resetty
argument_list|()
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|kill
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|SIGSTOP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTSTP
argument_list|,
name|tstp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMINFO
name|reset_prog_mode
argument_list|()
expr_stmt|;
name|putp
argument_list|(
name|enter_ca_mode
argument_list|)
expr_stmt|;
name|putp
argument_list|(
name|cursor_visible
argument_list|)
expr_stmt|;
else|#
directive|else
name|_tty
operator|=
name|tty
expr_stmt|;
name|ioctl
argument_list|(
name|_tty_ch
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|TI
argument_list|)
expr_stmt|;
name|_puts
argument_list|(
name|VS
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|cur_row
operator|=
name|y
expr_stmt|;
name|cur_col
operator|=
name|x
expr_stmt|;
ifdef|#
directive|ifdef
name|TERMINFO
name|putp
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
name|cur_row
argument_list|,
name|cur_col
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|_puts
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
name|cur_row
argument_list|,
name|cur_col
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|redraw_screen
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|long
name|env_init
parameter_list|(
name|enter_status
parameter_list|)
name|long
name|enter_status
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|envp
decl_stmt|,
modifier|*
name|envname
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|index
argument_list|()
decl_stmt|,
modifier|*
name|strpbrk
argument_list|()
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|256
condition|;
name|i
operator|++
control|)
name|map_key
index|[
name|i
index|]
operator|=
operator|(
name|char
operator|)
name|i
expr_stmt|;
name|envname
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|envp
operator|=
name|getenv
argument_list|(
literal|"HUNT"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
operator|(
name|s
operator|=
name|strpbrk
argument_list|(
name|envp
argument_list|,
literal|"=,"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"cloak,"
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enter_status
operator|=
name|Q_CLOAK
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"scan,"
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enter_status
operator|=
name|Q_SCAN
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"fly,"
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|enter_status
operator|=
name|Q_FLY
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"nobeep,"
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|no_beep
operator|=
name|TRUE
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"name="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|envname
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|envname
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
break|break;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|strncpy
argument_list|(
name|name
argument_list|,
name|envname
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|INTERNET
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"port="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|use_port
operator|=
name|s
operator|+
literal|1
expr_stmt|;
name|Test_port
operator|=
name|atoi
argument_list|(
name|use_port
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"host="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Sock_host
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"message="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Send_message
operator|=
name|s
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"team="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|team
operator|=
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|team
argument_list|)
condition|)
name|team
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
comment|/* must be last option */
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|envp
argument_list|,
literal|"mapkey="
argument_list|,
name|s
operator|-
name|envp
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|s
operator|=
name|s
operator|+
literal|1
init|;
operator|*
name|s
operator|!=
literal|'\0'
condition|;
name|s
operator|+=
literal|2
control|)
block|{
name|map_key
index|[
operator|(
name|unsigned
name|int
operator|)
operator|*
name|s
index|]
operator|=
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
operator|==
literal|'\0'
condition|)
block|{
break|break;
block|}
block|}
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
block|{
operator|*
name|s
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"unknown option %s\n"
argument_list|,
name|envp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|index
argument_list|(
name|envp
argument_list|,
literal|','
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|envp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
name|envp
operator|=
name|s
operator|+
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|envp
operator|!=
literal|'\0'
condition|)
if|if
condition|(
name|envname
operator|==
name|NULL
condition|)
name|strncpy
argument_list|(
name|name
argument_list|,
name|envp
argument_list|,
name|NAMELEN
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"unknown option %s\n"
argument_list|,
name|envp
argument_list|)
expr_stmt|;
block|}
return|return
name|enter_status
return|;
block|}
end_function

begin_macro
name|fill_in_blanks
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|again
label|:
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|printf
argument_list|(
literal|"Entering as '%s'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|team
operator|!=
literal|' '
condition|)
name|printf
argument_list|(
literal|" on team %c.\n"
argument_list|,
name|team
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"Enter your code name: "
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|name
argument_list|,
name|NAMELEN
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|rmnl
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"You have to have a code name!\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
for|for
control|(
name|cp
operator|=
name|name
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|!
name|isprint
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|"Illegal character in your code name.\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
if|if
condition|(
name|team
operator|==
literal|' '
condition|)
block|{
name|printf
argument_list|(
literal|"Enter your team (0-9 or nothing): "
argument_list|)
expr_stmt|;
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
name|i
argument_list|)
condition|)
name|team
operator|=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|!=
literal|'\n'
operator|&&
name|i
operator|!=
name|EOF
condition|)
name|i
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|BSD_RELEASE
end_ifdef

begin_if
if|#
directive|if
name|BSD_RELEASE
operator|<
literal|43
end_if

begin_function
name|char
modifier|*
name|strpbrk
parameter_list|(
name|s
parameter_list|,
name|brk
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|brk
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|c
expr_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|s
condition|)
block|{
for|for
control|(
name|p
operator|=
name|brk
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
if|if
condition|(
name|c
operator|==
operator|*
name|p
condition|)
return|return
operator|(
name|s
operator|)
return|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

end_unit

