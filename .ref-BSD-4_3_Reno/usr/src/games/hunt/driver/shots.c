begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)shots.c	5.2 (Berkeley) 6/27/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  */
end_comment

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|PLUS_DELTA
parameter_list|(
name|x
parameter_list|,
name|max
parameter_list|)
value|if (x< max) x++; else x--
end_define

begin_define
define|#
directive|define
name|MINUS_DELTA
parameter_list|(
name|x
parameter_list|,
name|min
parameter_list|)
value|if (x> min) x--; else x++
end_define

begin_comment
comment|/*  * moveshots:  *	Move the shots already in the air, taking explosions into account  */
end_comment

begin_macro
name|moveshots
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|,
modifier|*
name|next
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|BULLET
modifier|*
name|blist
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|rollexpl
argument_list|()
expr_stmt|;
if|if
condition|(
name|Bullets
operator|==
name|NULL
condition|)
goto|goto
name|ret
goto|;
comment|/* 	 * First we move through the bullet list BULSPD times, looking 	 * for things we may have run into.  If we do run into 	 * something, we set up the explosion and disappear, checking 	 * for damage to any player who got in the way. 	 */
name|blist
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bp
operator|->
name|b_next
expr_stmt|;
name|x
operator|=
name|bp
operator|->
name|b_x
expr_stmt|;
name|y
operator|=
name|bp
operator|->
name|b_y
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|bp
operator|->
name|b_over
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|BULSPD
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_expl
condition|)
break|break;
name|x
operator|=
name|bp
operator|->
name|b_x
expr_stmt|;
name|y
operator|=
name|bp
operator|->
name|b_y
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|x
operator|--
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|x
operator|++
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|y
operator|--
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|y
operator|++
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|SHOT
case|:
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|5
condition|)
block|{
name|zapshot
argument_list|(
name|Bullets
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|zapshot
argument_list|(
name|next
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|GRENADE
case|:
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|10
condition|)
block|{
name|zapshot
argument_list|(
name|Bullets
argument_list|,
name|bp
argument_list|)
expr_stmt|;
name|zapshot
argument_list|(
name|next
argument_list|,
name|bp
argument_list|)
expr_stmt|;
block|}
break|break;
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
comment|/* reflecting walls */
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|bp
operator|->
name|b_face
operator|=
name|BELOW
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|bp
operator|->
name|b_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|bp
operator|->
name|b_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|bp
operator|->
name|b_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
block|}
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|WALL5
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
break|break;
case|case
name|WALL5
case|:
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|bp
operator|->
name|b_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|bp
operator|->
name|b_face
operator|=
name|BELOW
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|bp
operator|->
name|b_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|bp
operator|->
name|b_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
block|}
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|WALL4
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
break|break;
endif|#
directive|endif
endif|REFLECT
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
switch|switch
condition|(
name|rand_num
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|bp
operator|->
name|b_face
operator|=
name|ABOVE
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|bp
operator|->
name|b_face
operator|=
name|BELOW
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|bp
operator|->
name|b_face
operator|=
name|LEFTS
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|bp
operator|->
name|b_face
operator|=
name|RIGHT
expr_stmt|;
break|break;
block|}
break|break;
endif|#
directive|endif
endif|RANDOM
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|BELOW
case|:
case|case
name|ABOVE
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
endif|FLY
comment|/* 				 * give the person a chance to catch a 				 * grenade if s/he is facing it 				 */
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
literal|10
operator|&&
name|opposite
argument_list|(
name|bp
operator|->
name|b_face
argument_list|,
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_owner
operator|!=
name|NULL
condition|)
name|message
argument_list|(
name|bp
operator|->
name|b_owner
argument_list|,
literal|"Your charge was absorbed!"
argument_list|)
expr_stmt|;
name|pp
operator|=
name|play_at
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_ammo
operator|+=
name|bp
operator|->
name|b_charge
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"Absorbed charge (good shield!)"
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
goto|goto
name|next_bullet
goto|;
block|}
comment|/* FALLTHROUGH */
ifndef|#
directive|ifndef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
endif|RANDOM
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
name|bp
operator|->
name|b_expl
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
name|bp
operator|->
name|b_x
operator|=
name|x
expr_stmt|;
name|bp
operator|->
name|b_y
operator|=
name|y
expr_stmt|;
block|}
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
name|next_bullet
label|:
empty_stmt|;
block|}
name|blist
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|next
control|)
block|{
name|next
operator|=
name|bp
operator|->
name|b_next
expr_stmt|;
if|if
condition|(
operator|!
name|bp
operator|->
name|b_expl
condition|)
block|{
name|save_bullet
argument_list|(
name|bp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|check
argument_list|(
name|pp
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
continue|continue;
block|}
name|chkshot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
name|Maze
index|[
name|pp
operator|->
name|p_y
index|]
index|[
name|pp
operator|->
name|p_x
index|]
operator|=
name|pp
operator|->
name|p_face
expr_stmt|;
name|ret
label|:
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|FLY
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|>=
literal|0
condition|)
block|{
name|Maze
index|[
name|pp
operator|->
name|p_y
index|]
index|[
name|pp
operator|->
name|p_x
index|]
operator|=
name|pp
operator|->
name|p_over
expr_stmt|;
name|x
operator|=
name|pp
operator|->
name|p_x
operator|+
name|pp
operator|->
name|p_flyx
expr_stmt|;
name|y
operator|=
name|pp
operator|->
name|p_y
operator|+
name|pp
operator|->
name|p_flyy
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|1
condition|)
block|{
name|x
operator|=
literal|1
operator|-
name|x
expr_stmt|;
name|pp
operator|->
name|p_flyx
operator|=
operator|-
name|pp
operator|->
name|p_flyx
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|x
operator|>
name|WIDTH
operator|-
literal|2
condition|)
block|{
name|x
operator|=
operator|(
name|WIDTH
operator|-
literal|2
operator|)
operator|-
operator|(
name|x
operator|-
operator|(
name|WIDTH
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
name|pp
operator|->
name|p_flyx
operator|=
operator|-
name|pp
operator|->
name|p_flyx
expr_stmt|;
block|}
if|if
condition|(
name|y
operator|<
literal|1
condition|)
block|{
name|y
operator|=
literal|1
operator|-
name|y
expr_stmt|;
name|pp
operator|->
name|p_flyy
operator|=
operator|-
name|pp
operator|->
name|p_flyy
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|y
operator|>
name|HEIGHT
operator|-
literal|2
condition|)
block|{
name|y
operator|=
operator|(
name|HEIGHT
operator|-
literal|2
operator|)
operator|-
operator|(
name|y
operator|-
operator|(
name|HEIGHT
operator|-
literal|2
operator|)
operator|)
expr_stmt|;
name|pp
operator|->
name|p_flyy
operator|=
operator|-
name|pp
operator|->
name|p_flyy
expr_stmt|;
block|}
name|again
label|:
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
case|case
name|FLYER
case|:
switch|switch
condition|(
name|rand_num
argument_list|(
literal|4
argument_list|)
condition|)
block|{
case|case
literal|0
case|:
name|PLUS_DELTA
argument_list|(
name|x
argument_list|,
name|WIDTH
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|MINUS_DELTA
argument_list|(
name|x
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|PLUS_DELTA
argument_list|(
name|y
argument_list|,
name|HEIGHT
operator|-
literal|2
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|MINUS_DELTA
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|again
goto|;
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
case|case
name|WALL5
case|:
endif|#
directive|endif
endif|REFLECT
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
endif|RANDOM
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|==
literal|0
condition|)
name|pp
operator|->
name|p_flying
operator|++
expr_stmt|;
break|break;
case|case
name|MINE
case|:
name|checkdam
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MINDAM
argument_list|,
name|MINE
argument_list|)
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
break|break;
case|case
name|GMINE
case|:
name|checkdam
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MINDAM
argument_list|,
name|GMINE
argument_list|)
expr_stmt|;
name|checkdam
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|MINDAM
argument_list|,
name|GMINE
argument_list|)
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
break|break;
block|}
name|pp
operator|->
name|p_y
operator|=
name|y
expr_stmt|;
name|pp
operator|->
name|p_x
operator|=
name|x
expr_stmt|;
name|pp
operator|->
name|p_over
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|--
operator|==
literal|0
condition|)
block|{
name|checkdam
argument_list|(
name|pp
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|rand_num
argument_list|(
name|pp
operator|->
name|p_damage
operator|/
literal|5
argument_list|)
argument_list|,
name|FALL
argument_list|)
expr_stmt|;
name|rand_face
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|showstat
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|pp
operator|->
name|p_face
expr_stmt|;
name|showexpl
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|pp
operator|->
name|p_face
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|FLY
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
comment|/* Flush out the explosions */
name|look
argument_list|(
name|pp
argument_list|)
expr_stmt|;
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
ifdef|#
directive|ifdef
name|CONSTANT_MOVE
if|if
condition|(
name|Bullets
operator|!=
name|NULL
condition|)
block|{
name|bul_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|EXPLEN
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|Expl
index|[
name|i
index|]
operator|!=
name|NULL
condition|)
block|{
name|bul_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return;
block|}
name|bul_alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CONSTANT_MOVE
return|return;
block|}
end_block

begin_expr_stmt
name|save_bullet
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|bp
operator|->
name|b_over
operator|=
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_over
condition|)
block|{
case|case
name|SHOT
case|:
case|case
name|GRENADE
case|:
case|case
name|SATCHEL
case|:
case|case
name|BOMB
case|:
ifdef|#
directive|ifdef
name|OOZE
case|case
name|SLIME
case|:
ifdef|#
directive|ifdef
name|VOLCANO
case|case
name|LAVA
case|:
endif|#
directive|endif
endif|VOLCANO
endif|#
directive|endif
endif|OOZE
name|find_under
argument_list|(
name|Bullets
argument_list|,
name|bp
argument_list|)
expr_stmt|;
break|break;
block|}
switch|switch
condition|(
name|bp
operator|->
name|b_over
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
endif|FLY
name|mark_player
argument_list|(
name|bp
argument_list|)
expr_stmt|;
break|break;
default|default:
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
operator|=
name|bp
operator|->
name|b_type
expr_stmt|;
break|break;
block|}
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * chkshot  *	Handle explosions  */
end_comment

begin_expr_stmt
name|chkshot
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
specifier|register
name|int
name|dy
decl_stmt|,
name|dx
decl_stmt|,
name|absdy
decl_stmt|;
specifier|register
name|int
name|delta
decl_stmt|,
name|damage
decl_stmt|;
specifier|register
name|char
name|expl
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_type
condition|)
block|{
case|case
name|SHOT
case|:
case|case
name|MINE
case|:
name|delta
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GRENADE
case|:
case|case
name|GMINE
case|:
name|delta
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SATCHEL
case|:
name|delta
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|BOMB
case|:
name|delta
operator|=
literal|3
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OOZE
case|case
name|SLIME
case|:
ifdef|#
directive|ifdef
name|VOLCANO
case|case
name|LAVA
case|:
endif|#
directive|endif
endif|VOLCANO
name|chkslime
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
endif|OOZE
block|}
for|for
control|(
name|y
operator|=
name|bp
operator|->
name|b_y
operator|-
name|delta
init|;
name|y
operator|<=
name|bp
operator|->
name|b_y
operator|+
name|delta
condition|;
name|y
operator|++
control|)
block|{
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|y
operator|>=
name|HEIGHT
condition|)
continue|continue;
name|dy
operator|=
name|y
operator|-
name|bp
operator|->
name|b_y
expr_stmt|;
name|absdy
operator|=
operator|(
name|dy
operator|<
literal|0
operator|)
condition|?
operator|-
name|dy
else|:
name|dy
expr_stmt|;
for|for
control|(
name|x
operator|=
name|bp
operator|->
name|b_x
operator|-
name|delta
init|;
name|x
operator|<=
name|bp
operator|->
name|b_x
operator|+
name|delta
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|x
operator|<
literal|0
operator|||
name|x
operator|>=
name|WIDTH
condition|)
continue|continue;
name|dx
operator|=
name|x
operator|-
name|bp
operator|->
name|b_x
expr_stmt|;
if|if
condition|(
name|dx
operator|==
literal|0
condition|)
name|expl
operator|=
operator|(
name|dy
operator|==
literal|0
operator|)
condition|?
literal|'*'
else|:
literal|'|'
expr_stmt|;
elseif|else
if|if
condition|(
name|dy
operator|==
literal|0
condition|)
name|expl
operator|=
literal|'-'
expr_stmt|;
elseif|else
if|if
condition|(
name|dx
operator|==
name|dy
condition|)
name|expl
operator|=
literal|'\\'
expr_stmt|;
elseif|else
if|if
condition|(
name|dx
operator|==
operator|-
name|dy
condition|)
name|expl
operator|=
literal|'/'
expr_stmt|;
else|else
name|expl
operator|=
literal|'*'
expr_stmt|;
name|showexpl
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|expl
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
endif|FLY
if|if
condition|(
name|dx
operator|<
literal|0
condition|)
name|dx
operator|=
operator|-
name|dx
expr_stmt|;
if|if
condition|(
name|absdy
operator|>
name|dx
condition|)
name|damage
operator|=
name|delta
operator|-
name|absdy
operator|+
literal|1
expr_stmt|;
else|else
name|damage
operator|=
name|delta
operator|-
name|dx
operator|+
literal|1
expr_stmt|;
name|pp
operator|=
name|play_at
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
while|while
condition|(
name|damage
operator|--
operator|>
literal|0
condition|)
name|checkdam
argument_list|(
name|pp
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|MINDAM
argument_list|,
name|bp
operator|->
name|b_type
argument_list|)
expr_stmt|;
break|break;
case|case
name|GMINE
case|:
case|case
name|MINE
case|:
name|add_shot
argument_list|(
operator|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|GMINE
operator|)
condition|?
name|GRENADE
else|:
name|SHOT
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|LEFTS
argument_list|,
operator|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|==
name|GMINE
operator|)
condition|?
name|GRENREQ
else|:
name|BULREQ
argument_list|,
operator|(
name|PLAYER
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OOZE
end_ifdef

begin_comment
comment|/*  * chkslime:  *	handle slime shot exploding  */
end_comment

begin_expr_stmt
name|chkslime
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|nbp
decl_stmt|;
switch|switch
condition|(
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
condition|)
block|{
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
case|case
name|WALL5
case|:
endif|#
directive|endif
endif|REFLECT
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
endif|RANDOM
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
name|bp
operator|->
name|b_x
operator|++
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|bp
operator|->
name|b_x
operator|--
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|bp
operator|->
name|b_y
operator|++
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|bp
operator|->
name|b_y
operator|--
expr_stmt|;
break|break;
block|}
break|break;
block|}
name|nbp
operator|=
operator|(
name|BULLET
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BULLET
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|nbp
operator|=
operator|*
name|bp
expr_stmt|;
ifdef|#
directive|ifdef
name|VOLCANO
name|moveslime
argument_list|(
name|nbp
argument_list|,
name|nbp
operator|->
name|b_type
operator|==
name|SLIME
condition|?
name|SLIMESPEED
else|:
name|LAVASPEED
argument_list|)
expr_stmt|;
else|#
directive|else
else|VOLCANO
name|moveslime
argument_list|(
name|nbp
argument_list|,
name|SLIMESPEED
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VOLCANO
block|}
end_block

begin_comment
comment|/*  * moveslime:  *	move the given slime shot speed times and add it back if  *	it hasn't fizzled yet  */
end_comment

begin_expr_stmt
name|moveslime
argument_list|(
name|bp
argument_list|,
name|speed
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|speed
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|dirmask
decl_stmt|,
name|count
decl_stmt|;
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
specifier|register
name|BULLET
modifier|*
name|nbp
decl_stmt|;
if|if
condition|(
name|speed
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_charge
operator|<=
literal|0
condition|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
else|else
name|save_bullet
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
ifdef|#
directive|ifdef
name|VOLCANO
name|showexpl
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
name|bp
operator|->
name|b_type
operator|==
name|LAVA
condition|?
name|LAVA
else|:
literal|'*'
argument_list|)
expr_stmt|;
else|#
directive|else
else|VOLCANO
name|showexpl
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
literal|'*'
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|VOLCANO
switch|switch
condition|(
name|Maze
index|[
name|bp
operator|->
name|b_y
index|]
index|[
name|bp
operator|->
name|b_x
index|]
condition|)
block|{
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
endif|FLY
name|pp
operator|=
name|play_at
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|pp
argument_list|,
literal|"You've been slimed."
argument_list|)
expr_stmt|;
name|checkdam
argument_list|(
name|pp
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|MINDAM
argument_list|,
name|bp
operator|->
name|b_type
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|bp
operator|->
name|b_charge
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
name|dirmask
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|bp
operator|->
name|b_face
condition|)
block|{
case|case
name|LEFTS
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|SOUTH
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|WEST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|)
condition|)
name|dirmask
operator||=
name|EAST
operator|,
name|count
operator|++
expr_stmt|;
if|if
condition|(
name|dirmask
operator|==
literal|0
condition|)
if|if
condition|(
operator|!
name|iswall
argument_list|(
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|)
condition|)
name|dirmask
operator||=
name|NORTH
operator|,
name|count
operator|++
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
comment|/* 		 * No place to go.  Just sit here for a while and wait 		 * for adjacent squares to clear out. 		 */
name|save_bullet
argument_list|(
name|bp
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|bp
operator|->
name|b_charge
operator|<
name|count
condition|)
block|{
comment|/* Only bp->b_charge paths may be taken */
while|while
condition|(
name|count
operator|>
name|bp
operator|->
name|b_charge
condition|)
block|{
if|if
condition|(
name|dirmask
operator|&
name|WEST
condition|)
name|dirmask
operator|&=
operator|~
name|WEST
expr_stmt|;
elseif|else
if|if
condition|(
name|dirmask
operator|&
name|EAST
condition|)
name|dirmask
operator|&=
operator|~
name|EAST
expr_stmt|;
elseif|else
if|if
condition|(
name|dirmask
operator|&
name|NORTH
condition|)
name|dirmask
operator|&=
operator|~
name|NORTH
expr_stmt|;
elseif|else
if|if
condition|(
name|dirmask
operator|&
name|SOUTH
condition|)
name|dirmask
operator|&=
operator|~
name|SOUTH
expr_stmt|;
name|count
operator|--
expr_stmt|;
block|}
block|}
name|i
operator|=
name|bp
operator|->
name|b_charge
operator|/
name|count
expr_stmt|;
name|j
operator|=
name|bp
operator|->
name|b_charge
operator|%
name|count
expr_stmt|;
if|if
condition|(
name|dirmask
operator|&
name|WEST
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|-
literal|1
argument_list|,
name|LEFTS
argument_list|,
name|i
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|moveslime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirmask
operator|&
name|EAST
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
argument_list|,
name|bp
operator|->
name|b_x
operator|+
literal|1
argument_list|,
name|RIGHT
argument_list|,
operator|(
name|count
operator|<
name|j
operator|)
condition|?
name|i
operator|+
literal|1
else|:
name|i
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|moveslime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirmask
operator|&
name|NORTH
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
operator|-
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
name|ABOVE
argument_list|,
operator|(
name|count
operator|<
name|j
operator|)
condition|?
name|i
operator|+
literal|1
else|:
name|i
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|moveslime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|dirmask
operator|&
name|SOUTH
condition|)
block|{
name|count
operator|--
expr_stmt|;
name|nbp
operator|=
name|create_shot
argument_list|(
name|bp
operator|->
name|b_type
argument_list|,
name|bp
operator|->
name|b_y
operator|+
literal|1
argument_list|,
name|bp
operator|->
name|b_x
argument_list|,
name|BELOW
argument_list|,
operator|(
name|count
operator|<
name|j
operator|)
condition|?
name|i
operator|+
literal|1
else|:
name|i
argument_list|,
name|bp
operator|->
name|b_owner
argument_list|,
name|bp
operator|->
name|b_score
argument_list|,
name|TRUE
argument_list|,
name|SPACE
argument_list|)
expr_stmt|;
name|moveslime
argument_list|(
name|nbp
argument_list|,
name|speed
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|bp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * iswall:  *	returns whether the given location is a wall  */
end_comment

begin_expr_stmt
name|iswall
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
specifier|register
name|int
name|y
operator|,
name|x
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|y
operator|<
literal|0
operator|||
name|x
operator|<
literal|0
operator|||
name|y
operator|>=
name|HEIGHT
operator|||
name|x
operator|>=
name|WIDTH
condition|)
return|return
name|TRUE
return|;
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
case|case
name|WALL5
case|:
endif|#
directive|endif
endif|REFLECT
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
endif|RANDOM
ifdef|#
directive|ifdef
name|VOLCANO
case|case
name|LAVA
case|:
endif|#
directive|endif
endif|VOLCANO
return|return
name|TRUE
return|;
block|}
return|return
name|FALSE
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OOZE
end_endif

begin_comment
comment|/*  * zapshot:  *	Take a shot out of the air.  */
end_comment

begin_expr_stmt
name|zapshot
argument_list|(
name|blist
argument_list|,
name|obp
argument_list|)
specifier|register
name|BULLET
operator|*
name|blist
operator|,
operator|*
name|obp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
specifier|register
name|FLAG
name|explode
decl_stmt|;
name|explode
operator|=
name|FALSE
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
block|{
if|if
condition|(
name|bp
operator|->
name|b_x
operator|!=
name|obp
operator|->
name|b_x
operator|||
name|bp
operator|->
name|b_y
operator|!=
name|obp
operator|->
name|b_y
condition|)
continue|continue;
if|if
condition|(
name|bp
operator|->
name|b_face
operator|==
name|obp
operator|->
name|b_face
condition|)
continue|continue;
name|explode
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|explode
condition|)
return|return;
name|explshot
argument_list|(
name|blist
argument_list|,
name|obp
operator|->
name|b_y
argument_list|,
name|obp
operator|->
name|b_x
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * explshot -  *	Make all shots at this location blow up  */
end_comment

begin_expr_stmt
name|explshot
argument_list|(
name|blist
argument_list|,
name|y
argument_list|,
name|x
argument_list|)
specifier|register
name|BULLET
operator|*
name|blist
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|blist
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_x
operator|==
name|x
operator|&&
name|bp
operator|->
name|b_y
operator|==
name|y
condition|)
block|{
name|bp
operator|->
name|b_expl
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_owner
operator|!=
name|NULL
condition|)
name|message
argument_list|(
name|bp
operator|->
name|b_owner
argument_list|,
literal|"Shot intercepted"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * play_at:  *	Return a pointer to the player at the given location  */
end_comment

begin_function
name|PLAYER
modifier|*
name|play_at
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_x
operator|==
name|x
operator|&&
name|pp
operator|->
name|p_y
operator|==
name|y
condition|)
return|return
name|pp
return|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"driver: couldn't find player at (%d,%d)\n"
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * opposite:  *	Return TRUE if the bullet direction faces the opposite direction  *	of the player in the maze  */
end_comment

begin_macro
name|opposite
argument_list|(
argument|face
argument_list|,
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|int
name|face
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|face
condition|)
block|{
case|case
name|LEFTS
case|:
return|return
operator|(
name|dir
operator|==
name|RIGHT
operator|)
return|;
case|case
name|RIGHT
case|:
return|return
operator|(
name|dir
operator|==
name|LEFTS
operator|)
return|;
case|case
name|ABOVE
case|:
return|return
operator|(
name|dir
operator|==
name|BELOW
operator|)
return|;
case|case
name|BELOW
case|:
return|return
operator|(
name|dir
operator|==
name|ABOVE
operator|)
return|;
default|default:
return|return
name|FALSE
return|;
block|}
block|}
end_block

begin_comment
comment|/*  * is_bullet:  *	Is there a bullet at the given coordinates?  If so, return  *	a pointer to the bullet, otherwise return NULL  */
end_comment

begin_function
name|BULLET
modifier|*
name|is_bullet
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|)
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|Bullets
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_y
operator|==
name|y
operator|&&
name|bp
operator|->
name|b_x
operator|==
name|x
condition|)
return|return
name|bp
return|;
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * fixshots:  *	change the underlying character of the shots at a location  *	to the given character.  */
end_comment

begin_expr_stmt
name|fixshots
argument_list|(
name|y
argument_list|,
name|x
argument_list|,
name|over
argument_list|)
specifier|register
name|int
name|y
operator|,
name|x
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
name|over
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|Bullets
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_y
operator|==
name|y
operator|&&
name|bp
operator|->
name|b_x
operator|==
name|x
condition|)
name|bp
operator|->
name|b_over
operator|=
name|over
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * find_under:  *	find the underlying character for a bullet when it lands  *	on another bullet.  */
end_comment

begin_expr_stmt
name|find_under
argument_list|(
name|blist
argument_list|,
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|blist
operator|,
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|nbp
decl_stmt|;
for|for
control|(
name|nbp
operator|=
name|blist
init|;
name|nbp
operator|!=
name|NULL
condition|;
name|nbp
operator|=
name|nbp
operator|->
name|b_next
control|)
if|if
condition|(
name|bp
operator|->
name|b_y
operator|==
name|nbp
operator|->
name|b_y
operator|&&
name|bp
operator|->
name|b_x
operator|==
name|nbp
operator|->
name|b_x
condition|)
block|{
name|bp
operator|->
name|b_over
operator|=
name|nbp
operator|->
name|b_over
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * mark_player:  *	mark a player as under a shot  */
end_comment

begin_expr_stmt
name|mark_player
argument_list|(
name|bp
argument_list|)
specifier|register
name|BULLET
operator|*
name|bp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|pp
decl_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
if|if
condition|(
name|pp
operator|->
name|p_y
operator|==
name|bp
operator|->
name|b_y
operator|&&
name|pp
operator|->
name|p_x
operator|==
name|bp
operator|->
name|b_x
condition|)
block|{
name|pp
operator|->
name|p_undershot
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

