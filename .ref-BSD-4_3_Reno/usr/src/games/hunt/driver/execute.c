begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by the University of California, Berkeley.  The name of the  * University may not be used to endorse or promote products derived  * from this software without specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)execute.c	5.2 (Berkeley) 6/27/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/*  *  Hunt  *  Copyright (c) 1985 Conrad C. Huang, Gregory S. Couch, Kenneth C.R.C. Arnold  *  San Francisco, California  */
end_comment

begin_include
include|#
directive|include
file|"hunt.h"
end_include

begin_undef
undef|#
directive|undef
name|CTRL
end_undef

begin_define
define|#
directive|define
name|CTRL
parameter_list|(
name|x
parameter_list|)
value|('x'& 037)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MONITOR
end_ifdef

begin_comment
comment|/*  * mon_execute:  *	Execute a single monitor command  */
end_comment

begin_expr_stmt
name|mon_execute
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|ch
decl_stmt|;
name|ch
operator|=
name|pp
operator|->
name|p_cbuf
index|[
name|pp
operator|->
name|p_ncount
operator|++
index|]
expr_stmt|;
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|CTRL
argument_list|(
name|L
argument_list|)
case|:
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REDRAW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pp
operator|->
name|p_death
argument_list|,
literal|"| Quit |"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
endif|MONITOR
end_endif

begin_comment
comment|/*  * execute:  *	Execute a single command  */
end_comment

begin_expr_stmt
name|execute
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
name|ch
decl_stmt|;
name|ch
operator|=
name|pp
operator|->
name|p_cbuf
index|[
name|pp
operator|->
name|p_ncount
operator|++
index|]
expr_stmt|;
ifdef|#
directive|ifdef
name|FLY
if|if
condition|(
name|pp
operator|->
name|p_flying
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|CTRL
argument_list|(
name|L
argument_list|)
case|:
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REDRAW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pp
operator|->
name|p_death
argument_list|,
literal|"| Quit |"
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
endif|#
directive|endif
endif|FLY
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|CTRL
argument_list|(
name|L
argument_list|)
case|:
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REDRAW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|move
argument_list|(
name|pp
argument_list|,
name|LEFTS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|face
argument_list|(
name|pp
argument_list|,
name|LEFTS
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|move
argument_list|(
name|pp
argument_list|,
name|BELOW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
name|face
argument_list|(
name|pp
argument_list|,
name|BELOW
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
name|move
argument_list|(
name|pp
argument_list|,
name|ABOVE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|face
argument_list|(
name|pp
argument_list|,
name|ABOVE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|move
argument_list|(
name|pp
argument_list|,
name|RIGHT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|face
argument_list|(
name|pp
argument_list|,
name|RIGHT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fire
argument_list|(
name|pp
argument_list|,
name|SHOT
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
name|fire
argument_list|(
name|pp
argument_list|,
name|GRENADE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fire
argument_list|(
name|pp
argument_list|,
name|SATCHEL
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|fire
argument_list|(
name|pp
argument_list|,
name|BOMB
argument_list|)
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|OOZE
case|case
literal|'o'
case|:
name|fire_slime
argument_list|(
name|pp
argument_list|,
name|SLIMEREQ
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|fire_slime
argument_list|(
name|pp
argument_list|,
name|SSLIMEREQ
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|OOZE
case|case
literal|'s'
case|:
name|scan
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cloak
argument_list|(
name|pp
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pp
operator|->
name|p_death
argument_list|,
literal|"| Quit |"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_block

begin_comment
comment|/*  * move:  *	Execute a move in the given direction  */
end_comment

begin_expr_stmt
name|move
argument_list|(
name|pp
argument_list|,
name|dir
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|PLAYER
modifier|*
name|newp
decl_stmt|;
specifier|register
name|int
name|x
decl_stmt|,
name|y
decl_stmt|;
specifier|register
name|FLAG
name|moved
decl_stmt|;
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
name|y
operator|=
name|pp
operator|->
name|p_y
expr_stmt|;
name|x
operator|=
name|pp
operator|->
name|p_x
expr_stmt|;
switch|switch
condition|(
name|dir
condition|)
block|{
case|case
name|LEFTS
case|:
name|x
operator|--
expr_stmt|;
break|break;
case|case
name|RIGHT
case|:
name|x
operator|++
expr_stmt|;
break|break;
case|case
name|ABOVE
case|:
name|y
operator|--
expr_stmt|;
break|break;
case|case
name|BELOW
case|:
name|y
operator|++
expr_stmt|;
break|break;
block|}
name|moved
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
case|case
name|SPACE
case|:
ifdef|#
directive|ifdef
name|RANDOM
case|case
name|DOOR
case|:
endif|#
directive|endif
endif|RANDOM
name|moved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|WALL1
case|:
case|case
name|WALL2
case|:
case|case
name|WALL3
case|:
ifdef|#
directive|ifdef
name|REFLECT
case|case
name|WALL4
case|:
case|case
name|WALL5
case|:
endif|#
directive|endif
endif|REFLECT
break|break;
case|case
name|MINE
case|:
case|case
name|GMINE
case|:
if|if
condition|(
name|dir
operator|==
name|pp
operator|->
name|p_face
condition|)
name|pickup
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
literal|5
argument_list|,
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opposite
argument_list|(
name|dir
argument_list|,
name|pp
operator|->
name|p_face
argument_list|)
condition|)
name|pickup
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
literal|95
argument_list|,
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
else|else
name|pickup
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
literal|50
argument_list|,
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
name|moved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|SHOT
case|:
case|case
name|GRENADE
case|:
case|case
name|SATCHEL
case|:
case|case
name|BOMB
case|:
name|bp
operator|=
name|is_bullet
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
name|NULL
condition|)
name|bp
operator|->
name|b_expl
operator|=
name|TRUE
expr_stmt|;
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
operator|=
name|SPACE
expr_stmt|;
name|moved
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|LEFTS
case|:
case|case
name|RIGHT
case|:
case|case
name|ABOVE
case|:
case|case
name|BELOW
case|:
ifdef|#
directive|ifdef
name|FLY
case|case
name|FLYER
case|:
endif|#
directive|endif
endif|FLY
if|if
condition|(
name|dir
operator|!=
name|pp
operator|->
name|p_face
condition|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|BELL
argument_list|)
expr_stmt|;
else|else
block|{
name|newp
operator|=
name|play_at
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|checkdam
argument_list|(
name|newp
argument_list|,
name|pp
argument_list|,
name|pp
operator|->
name|p_ident
argument_list|,
name|STABDAM
argument_list|,
name|KNIFE
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
name|moved
condition|)
block|{
if|if
condition|(
name|pp
operator|->
name|p_ncshot
operator|>
literal|0
condition|)
if|if
condition|(
operator|--
name|pp
operator|->
name|p_ncshot
operator|==
name|MAXNCSHOT
condition|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_GUN_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
literal|" ok"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pp
operator|->
name|p_undershot
condition|)
block|{
name|fixshots
argument_list|(
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|pp
operator|->
name|p_over
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_undershot
operator|=
name|FALSE
expr_stmt|;
block|}
name|drawplayer
argument_list|(
name|pp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_over
operator|=
name|Maze
index|[
name|y
index|]
index|[
name|x
index|]
expr_stmt|;
name|pp
operator|->
name|p_y
operator|=
name|y
expr_stmt|;
name|pp
operator|->
name|p_x
operator|=
name|x
expr_stmt|;
name|drawplayer
argument_list|(
name|pp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * face:  *	Change the direction the player is facing  */
end_comment

begin_expr_stmt
name|face
argument_list|(
name|pp
argument_list|,
name|dir
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|dir
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pp
operator|->
name|p_face
operator|!=
name|dir
condition|)
block|{
name|pp
operator|->
name|p_face
operator|=
name|dir
expr_stmt|;
name|drawplayer
argument_list|(
name|pp
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * fire:  *	Fire a shot of the given type in the given direction  */
end_comment

begin_expr_stmt
name|fire
argument_list|(
name|pp
argument_list|,
name|type
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|req_index
decl_stmt|;
specifier|static
name|int
name|req
index|[
literal|4
index|]
init|=
block|{
name|BULREQ
block|,
name|GRENREQ
block|,
name|SATREQ
block|,
name|BOMBREQ
block|}
decl_stmt|;
specifier|static
name|int
name|shot_type
index|[
literal|4
index|]
init|=
block|{
name|SHOT
block|,
name|GRENADE
block|,
name|SATCHEL
block|,
name|BOMB
block|}
decl_stmt|;
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|p_ammo
operator|==
literal|0
condition|)
block|{
name|message
argument_list|(
name|pp
argument_list|,
literal|"No more charges."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pp
operator|->
name|p_ncshot
operator|>
name|MAXNCSHOT
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|p_ncshot
operator|++
operator|==
name|MAXNCSHOT
condition|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_GUN_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
literal|"   "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHOT
case|:
name|req_index
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|GRENADE
case|:
name|req_index
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SATCHEL
case|:
name|req_index
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|BOMB
case|:
name|req_index
operator|=
literal|3
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|DEBUG
default|default:
name|message
argument_list|(
name|pp
argument_list|,
literal|"What you do!!!"
argument_list|)
expr_stmt|;
return|return;
endif|#
directive|endif
endif|DEBUG
block|}
while|while
condition|(
name|pp
operator|->
name|p_ammo
operator|<
name|req
index|[
name|req_index
index|]
condition|)
name|req_index
operator|--
expr_stmt|;
name|pp
operator|->
name|p_ammo
operator|-=
name|req
index|[
name|req_index
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|add_shot
argument_list|(
name|shot_type
index|[
name|req_index
index|]
argument_list|,
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|pp
operator|->
name|p_face
argument_list|,
name|req
index|[
name|req_index
index|]
argument_list|,
name|pp
argument_list|,
name|FALSE
argument_list|,
name|pp
operator|->
name|p_face
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_undershot
operator|=
name|TRUE
expr_stmt|;
comment|/* 	 * Show the object to everyone 	 */
name|showexpl
argument_list|(
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|shot_type
index|[
name|req_index
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|OOZE
end_ifdef

begin_comment
comment|/*  * fire_slime:  *	Fire a slime shot in the given direction  */
end_comment

begin_expr_stmt
name|fire_slime
argument_list|(
name|pp
argument_list|,
name|req
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|req
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|pp
operator|==
name|NULL
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|p_ammo
operator|<
name|req
condition|)
block|{
name|message
argument_list|(
name|pp
argument_list|,
literal|"Not enough charges."
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|pp
operator|->
name|p_ncshot
operator|>
name|MAXNCSHOT
condition|)
return|return;
if|if
condition|(
name|pp
operator|->
name|p_ncshot
operator|++
operator|==
name|MAXNCSHOT
condition|)
block|{
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_GUN_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
literal|"   "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|pp
operator|->
name|p_ammo
operator|-=
name|req
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|add_shot
argument_list|(
name|SLIME
argument_list|,
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|pp
operator|->
name|p_face
argument_list|,
name|req
argument_list|,
name|pp
argument_list|,
name|FALSE
argument_list|,
name|pp
operator|->
name|p_face
argument_list|)
expr_stmt|;
comment|/* 	 * Show the object to everyone 	 */
name|showexpl
argument_list|(
name|pp
operator|->
name|p_y
argument_list|,
name|pp
operator|->
name|p_x
argument_list|,
name|SLIME
argument_list|)
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|Player
init|;
name|pp
operator|<
name|End_player
condition|;
name|pp
operator|++
control|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MONITOR
for|for
control|(
name|pp
operator|=
name|Monitor
init|;
name|pp
operator|<
name|End_monitor
condition|;
name|pp
operator|++
control|)
name|sendcom
argument_list|(
name|pp
argument_list|,
name|REFRESH
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|MONITOR
block|}
end_block

begin_endif
endif|#
directive|endif
endif|OOZE
end_endif

begin_comment
comment|/*  * create_shot:  *	Create a shot with the given properties  */
end_comment

begin_macro
name|add_shot
argument_list|(
argument|type
argument_list|,
argument|y
argument_list|,
argument|x
argument_list|,
argument|face
argument_list|,
argument|charge
argument_list|,
argument|owner
argument_list|,
argument|expl
argument_list|,
argument|over
argument_list|)
end_macro

begin_decl_stmt
name|int
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|face
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|charge
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|PLAYER
modifier|*
name|owner
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|expl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|over
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
ifdef|#
directive|ifdef
name|CONSTANT_MOVE
comment|/* 	 * if there are no bullets in flight, set up the alarm 	 */
if|if
condition|(
name|Bullets
operator|==
name|NULL
condition|)
name|bul_alarm
argument_list|(
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CONSTANT_MOVE
name|bp
operator|=
name|create_shot
argument_list|(
name|type
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|face
argument_list|,
name|charge
argument_list|,
name|owner
argument_list|,
operator|(
name|owner
operator|==
name|NULL
operator|)
condition|?
name|NULL
else|:
name|owner
operator|->
name|p_ident
argument_list|,
name|expl
argument_list|,
name|over
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_next
operator|=
name|Bullets
expr_stmt|;
name|Bullets
operator|=
name|bp
expr_stmt|;
block|}
end_block

begin_function
name|BULLET
modifier|*
name|create_shot
parameter_list|(
name|type
parameter_list|,
name|y
parameter_list|,
name|x
parameter_list|,
name|face
parameter_list|,
name|charge
parameter_list|,
name|owner
parameter_list|,
name|score
parameter_list|,
name|expl
parameter_list|,
name|over
parameter_list|)
name|int
name|type
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|char
name|face
decl_stmt|;
name|int
name|charge
decl_stmt|;
name|PLAYER
modifier|*
name|owner
decl_stmt|;
name|IDENT
modifier|*
name|score
decl_stmt|;
name|int
name|expl
decl_stmt|;
name|char
name|over
decl_stmt|;
block|{
specifier|register
name|BULLET
modifier|*
name|bp
decl_stmt|;
name|bp
operator|=
operator|(
name|BULLET
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|BULLET
argument_list|)
argument_list|)
expr_stmt|;
comment|/* NOSTRICT */
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|owner
operator|!=
name|NULL
condition|)
name|message
argument_list|(
name|owner
argument_list|,
literal|"Out of memory"
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|bp
operator|->
name|b_face
operator|=
name|face
expr_stmt|;
name|bp
operator|->
name|b_x
operator|=
name|x
expr_stmt|;
name|bp
operator|->
name|b_y
operator|=
name|y
expr_stmt|;
name|bp
operator|->
name|b_charge
operator|=
name|charge
expr_stmt|;
name|bp
operator|->
name|b_owner
operator|=
name|owner
expr_stmt|;
name|bp
operator|->
name|b_score
operator|=
name|score
expr_stmt|;
name|bp
operator|->
name|b_type
operator|=
name|type
expr_stmt|;
name|bp
operator|->
name|b_expl
operator|=
name|expl
expr_stmt|;
name|bp
operator|->
name|b_over
operator|=
name|over
expr_stmt|;
name|bp
operator|->
name|b_next
operator|=
name|NULL
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/*  * cloak:  *	Turn on or increase length of a cloak  */
end_comment

begin_expr_stmt
name|cloak
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|pp
operator|->
name|p_ammo
operator|<=
literal|0
condition|)
block|{
name|message
argument_list|(
name|pp
argument_list|,
literal|"No more charges"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
operator|--
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_cloak
operator|+=
name|CLOAKLEN
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_CLOAK_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
literal|" on"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_scan
operator|>=
literal|0
condition|)
block|{
name|pp
operator|->
name|p_scan
operator|=
operator|-
literal|1
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_SCAN_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
literal|"   "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|showstat
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * scan:  *	Turn on or increase length of a scan  */
end_comment

begin_expr_stmt
name|scan
argument_list|(
name|pp
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|pp
operator|->
name|p_ammo
operator|<=
literal|0
condition|)
block|{
name|message
argument_list|(
name|pp
argument_list|,
literal|"No more charges"
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
operator|--
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
name|pp
operator|->
name|p_scan
operator|+=
name|SCANLEN
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_SCAN_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
literal|" on"
argument_list|,
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|p_cloak
operator|>=
literal|0
condition|)
block|{
name|pp
operator|->
name|p_cloak
operator|=
operator|-
literal|1
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_CLOAK_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
literal|"   "
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
name|showstat
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * pickup:  *	check whether the object blew up or whether he picked it up  */
end_comment

begin_expr_stmt
name|pickup
argument_list|(
name|pp
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|prob
argument_list|,
name|obj
argument_list|)
specifier|register
name|PLAYER
operator|*
name|pp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prob
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|obj
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|req
decl_stmt|;
switch|switch
condition|(
name|obj
condition|)
block|{
case|case
name|MINE
case|:
name|req
operator|=
name|BULREQ
expr_stmt|;
break|break;
case|case
name|GMINE
case|:
name|req
operator|=
name|GRENREQ
expr_stmt|;
break|break;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|rand_num
argument_list|(
literal|100
argument_list|)
operator|<
name|prob
condition|)
name|add_shot
argument_list|(
name|obj
argument_list|,
name|y
argument_list|,
name|x
argument_list|,
name|LEFTS
argument_list|,
name|req
argument_list|,
operator|(
name|PLAYER
operator|*
operator|)
name|NULL
argument_list|,
name|TRUE
argument_list|,
name|pp
operator|->
name|p_face
argument_list|)
expr_stmt|;
else|else
block|{
name|pp
operator|->
name|p_ammo
operator|+=
name|req
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|Buf
argument_list|,
literal|"%3d"
argument_list|,
name|pp
operator|->
name|p_ammo
argument_list|)
expr_stmt|;
name|cgoto
argument_list|(
name|pp
argument_list|,
name|STAT_AMMO_ROW
argument_list|,
name|STAT_VALUE_COL
argument_list|)
expr_stmt|;
name|outstr
argument_list|(
name|pp
argument_list|,
name|Buf
argument_list|,
literal|3
argument_list|)
expr_stmt|;
block|}
block|}
end_block

end_unit

