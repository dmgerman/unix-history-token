begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $Header: term.c,v 7.0.1.2 86/12/12 17:04:09 lwall Exp $ */
end_comment

begin_comment
comment|/* $Log:	term.c,v $  * Revision 7.0.1.2  86/12/12  17:04:09  lwall  * Baseline for net release.  *   * Revision 7.0.1.1  86/10/16  10:53:20  lwall  * Added Damage.  Fixed random bugs.  *   * Revision 7.0  86/10/08  15:14:02  lwall  * Split into separate files.  Added amoebas and pirates.  *   */
end_comment

begin_include
include|#
directive|include
file|"EXTERN.h"
end_include

begin_include
include|#
directive|include
file|"warp.h"
end_include

begin_include
include|#
directive|include
file|"bang.h"
end_include

begin_include
include|#
directive|include
file|"intrp.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"play.h"
end_include

begin_include
include|#
directive|include
file|"score.h"
end_include

begin_include
include|#
directive|include
file|"sig.h"
end_include

begin_include
include|#
directive|include
file|"us.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"weapon.h"
end_include

begin_include
include|#
directive|include
file|"INTERN.h"
end_include

begin_include
include|#
directive|include
file|"term.h"
end_include

begin_decl_stmt
name|int
name|typeahead
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tcarea
index|[
name|TCSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* area for "compiled" termcap strings */
end_comment

begin_comment
comment|/* guarantee capability pointer != Nullch */
end_comment

begin_comment
comment|/* (I believe terminfo will ignore the&tmpaddr argument.) */
end_comment

begin_define
define|#
directive|define
name|Tgetstr
parameter_list|(
name|key
parameter_list|)
value|((tstr = tgetstr(key,&tmpaddr)) ? tstr : nullstr)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_struct
struct|struct
name|keymap
block|{
name|char
name|km_type
index|[
literal|128
index|]
decl_stmt|;
union|union
name|km_union
block|{
name|struct
name|keymap
modifier|*
name|km_km
decl_stmt|;
name|char
modifier|*
name|km_str
decl_stmt|;
block|}
name|km_ptr
index|[
literal|128
index|]
union|;
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|KM_NOTHIN
value|0
end_define

begin_define
define|#
directive|define
name|KM_STRING
value|1
end_define

begin_define
define|#
directive|define
name|KM_KEYMAP
value|2
end_define

begin_define
define|#
directive|define
name|KM_BOGUS
value|3
end_define

begin_define
define|#
directive|define
name|KM_TMASK
value|3
end_define

begin_define
define|#
directive|define
name|KM_GSHIFT
value|4
end_define

begin_define
define|#
directive|define
name|KM_GMASK
value|7
end_define

begin_typedef
typedef|typedef
name|struct
name|keymap
name|KEYMAP
typedef|;
end_typedef

begin_decl_stmt
name|KEYMAP
modifier|*
name|topmap
name|INIT
argument_list|(
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function_decl
name|void
name|mac_init
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|KEYMAP
modifier|*
name|newkeymap
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|void
name|pushstring
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* terminal initialization */
end_comment

begin_function
name|void
name|term_init
parameter_list|()
block|{
name|savetty
argument_list|()
expr_stmt|;
comment|/* remember current tty state */
ifdef|#
directive|ifdef
name|TERMIO
name|ospeed
operator|=
name|_tty
operator|.
name|c_cflag
operator|&
name|CBAUD
expr_stmt|;
comment|/* for tputs() */
name|ERASECH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
comment|/* for finish_command() */
name|KILLCH
operator|=
name|_tty
operator|.
name|c_cc
index|[
name|VKILL
index|]
expr_stmt|;
comment|/* for finish_command() */
else|#
directive|else
name|ospeed
operator|=
name|_tty
operator|.
name|sg_ospeed
expr_stmt|;
comment|/* for tputs() */
name|ERASECH
operator|=
name|_tty
operator|.
name|sg_erase
expr_stmt|;
comment|/* for finish_command() */
name|KILLCH
operator|=
name|_tty
operator|.
name|sg_kill
expr_stmt|;
comment|/* for finish_command() */
endif|#
directive|endif
comment|/* The following could be a table but I can't be sure that there isn't */
comment|/* some degree of sparsity out there in the world. */
switch|switch
condition|(
name|ospeed
condition|)
block|{
comment|/* 1 second of padding */
ifdef|#
directive|ifdef
name|BEXTA
case|case
name|BEXTA
case|:
name|just_a_sec
operator|=
literal|1920
expr_stmt|;
break|break;
else|#
directive|else
ifdef|#
directive|ifdef
name|B19200
case|case
name|B19200
case|:
name|just_a_sec
operator|=
literal|1920
expr_stmt|;
break|break;
endif|#
directive|endif
endif|#
directive|endif
case|case
name|B9600
case|:
name|just_a_sec
operator|=
literal|960
expr_stmt|;
break|break;
case|case
name|B4800
case|:
name|just_a_sec
operator|=
literal|480
expr_stmt|;
break|break;
case|case
name|B2400
case|:
name|just_a_sec
operator|=
literal|240
expr_stmt|;
break|break;
case|case
name|B1800
case|:
name|just_a_sec
operator|=
literal|180
expr_stmt|;
break|break;
case|case
name|B1200
case|:
name|just_a_sec
operator|=
literal|120
expr_stmt|;
break|break;
case|case
name|B600
case|:
name|just_a_sec
operator|=
literal|60
expr_stmt|;
break|break;
case|case
name|B300
case|:
name|just_a_sec
operator|=
literal|30
expr_stmt|;
break|break;
comment|/* do I really have to type the rest of this??? */
case|case
name|B200
case|:
name|just_a_sec
operator|=
literal|20
expr_stmt|;
break|break;
case|case
name|B150
case|:
name|just_a_sec
operator|=
literal|15
expr_stmt|;
break|break;
case|case
name|B134
case|:
name|just_a_sec
operator|=
literal|13
expr_stmt|;
break|break;
case|case
name|B110
case|:
name|just_a_sec
operator|=
literal|11
expr_stmt|;
break|break;
case|case
name|B75
case|:
name|just_a_sec
operator|=
literal|8
expr_stmt|;
break|break;
case|case
name|B50
case|:
name|just_a_sec
operator|=
literal|5
expr_stmt|;
break|break;
default|default:
name|just_a_sec
operator|=
literal|960
expr_stmt|;
break|break;
comment|/* if we are running detached I */
block|}
comment|/*  don't want to know about it! */
block|}
end_function

begin_comment
comment|/* set terminal characteristics */
end_comment

begin_function
name|void
name|term_set
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
comment|/* temp area for "uncompiled" termcap entry */
block|{
name|char
modifier|*
name|tmpaddr
decl_stmt|;
comment|/* must not be register */
name|Reg1
name|char
modifier|*
name|tstr
decl_stmt|;
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|retval
decl_stmt|;
ifdef|#
directive|ifdef
name|PENDING
ifndef|#
directive|ifndef
name|FIONREAD
ifndef|#
directive|ifndef
name|RDCHK
comment|/* do no delay reads on something that always gets closed on exit */
name|devtty
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|devtty
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
name|cantopen
argument_list|,
literal|"/dev/tty"
argument_list|)
expr_stmt|;
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|fcntl
argument_list|(
name|devtty
argument_list|,
name|F_SETFL
argument_list|,
name|O_NDELAY
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
comment|/* get all that good termcap stuff */
name|retval
operator|=
name|tgetent
argument_list|(
name|tcbuf
argument_list|,
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* get termcap entry */
if|if
condition|(
name|retval
operator|<
literal|1
condition|)
block|{
ifdef|#
directive|ifdef
name|VERBOSE
name|printf
argument_list|(
literal|"No termcap %s found.\n"
argument_list|,
name|retval
condition|?
literal|"file"
else|:
literal|"entry"
argument_list|)
expr_stmt|;
else|#
directive|else
name|fputs
argument_list|(
literal|"Termcap botch\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|finalize
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|tmpaddr
operator|=
name|tcarea
expr_stmt|;
comment|/* set up strange tgetstr pointer */
name|s
operator|=
name|Tgetstr
argument_list|(
literal|"pc"
argument_list|)
expr_stmt|;
comment|/* get pad character */
name|PC
operator|=
operator|*
name|s
expr_stmt|;
comment|/* get it where tputs wants it */
if|if
condition|(
operator|!
name|tgetflag
argument_list|(
literal|"bs"
argument_list|)
condition|)
block|{
comment|/* is backspace not used? */
name|BC
operator|=
name|Tgetstr
argument_list|(
literal|"bc"
argument_list|)
expr_stmt|;
comment|/* find out what is */
if|if
condition|(
name|BC
operator|==
name|nullstr
condition|)
comment|/* terminfo grok's 'bs' but not 'bc' */
name|BC
operator|=
name|Tgetstr
argument_list|(
literal|"le"
argument_list|)
expr_stmt|;
block|}
else|else
name|BC
operator|=
literal|"\b"
expr_stmt|;
comment|/* make a backspace handy */
name|UP
operator|=
name|Tgetstr
argument_list|(
literal|"up"
argument_list|)
expr_stmt|;
comment|/* move up a line */
name|ND
operator|=
name|Tgetstr
argument_list|(
literal|"nd"
argument_list|)
expr_stmt|;
comment|/* non-destructive move cursor right */
name|DO
operator|=
name|Tgetstr
argument_list|(
literal|"do"
argument_list|)
expr_stmt|;
comment|/* move cursor down */
if|if
condition|(
operator|!
operator|*
name|DO
condition|)
name|DO
operator|=
name|Tgetstr
argument_list|(
literal|"nl"
argument_list|)
expr_stmt|;
name|CL
operator|=
name|Tgetstr
argument_list|(
literal|"cl"
argument_list|)
expr_stmt|;
comment|/* get clear string */
name|CE
operator|=
name|Tgetstr
argument_list|(
literal|"ce"
argument_list|)
expr_stmt|;
comment|/* clear to end of line string */
name|CM
operator|=
name|Tgetstr
argument_list|(
literal|"cm"
argument_list|)
expr_stmt|;
comment|/* cursor motion - PWP */
name|HO
operator|=
name|Tgetstr
argument_list|(
literal|"ho"
argument_list|)
expr_stmt|;
comment|/* home cursor if no CM - PWP */
name|CD
operator|=
name|Tgetstr
argument_list|(
literal|"cd"
argument_list|)
expr_stmt|;
comment|/* clear to end of display - PWP */
name|SO
operator|=
name|Tgetstr
argument_list|(
literal|"so"
argument_list|)
expr_stmt|;
comment|/* begin standout */
name|SE
operator|=
name|Tgetstr
argument_list|(
literal|"se"
argument_list|)
expr_stmt|;
comment|/* end standout */
if|if
condition|(
operator|(
name|SG
operator|=
name|tgetnum
argument_list|(
literal|"sg"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|SG
operator|=
literal|0
expr_stmt|;
comment|/* blanks left by SG, SE */
name|US
operator|=
name|Tgetstr
argument_list|(
literal|"us"
argument_list|)
expr_stmt|;
comment|/* start underline */
name|UE
operator|=
name|Tgetstr
argument_list|(
literal|"ue"
argument_list|)
expr_stmt|;
comment|/* end underline */
if|if
condition|(
operator|(
name|UG
operator|=
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|UG
operator|=
literal|0
expr_stmt|;
comment|/* blanks left by US, UE */
if|if
condition|(
operator|*
name|US
condition|)
name|UC
operator|=
name|nullstr
expr_stmt|;
comment|/* UC must not be NULL */
else|else
name|UC
operator|=
name|Tgetstr
argument_list|(
literal|"uc"
argument_list|)
expr_stmt|;
comment|/* underline a character */
if|if
condition|(
operator|!
operator|*
name|US
operator|&&
operator|!
operator|*
name|UC
condition|)
block|{
comment|/* no underline mode? */
name|US
operator|=
name|SO
expr_stmt|;
comment|/* substitute standout mode */
name|UE
operator|=
name|SE
expr_stmt|;
name|UG
operator|=
name|SG
expr_stmt|;
block|}
name|LINES
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
comment|/* lines per page */
name|COLS
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
comment|/* columns on page */
name|AM
operator|=
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
expr_stmt|;
comment|/* terminal wraps automatically? */
name|XN
operator|=
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
expr_stmt|;
comment|/* then eats next newline? */
name|VB
operator|=
name|Tgetstr
argument_list|(
literal|"vb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|VB
condition|)
name|VB
operator|=
literal|"\007"
expr_stmt|;
name|CR
operator|=
name|Tgetstr
argument_list|(
literal|"cr"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|CR
condition|)
block|{
if|if
condition|(
name|tgetflag
argument_list|(
literal|"nc"
argument_list|)
operator|&&
operator|*
name|UP
condition|)
block|{
name|CR
operator|=
name|safemalloc
argument_list|(
operator|(
name|MEM_SIZE
operator|)
name|strlen
argument_list|(
name|UP
argument_list|)
operator|+
literal|2
argument_list|)
expr_stmt|;
name|Sprintf
argument_list|(
name|CR
argument_list|,
literal|"%s\r"
argument_list|,
name|UP
argument_list|)
expr_stmt|;
block|}
else|else
name|CR
operator|=
literal|"\r"
expr_stmt|;
block|}
if|if
condition|(
name|LINES
operator|<=
literal|0
condition|)
name|LINES
operator|=
literal|24
expr_stmt|;
if|if
condition|(
name|COLS
operator|<=
literal|0
condition|)
name|COLS
operator|=
literal|80
expr_stmt|;
name|BCsize
operator|=
name|comp_tc
argument_list|(
name|bsptr
argument_list|,
name|BC
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|BC
operator|=
name|bsptr
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|ND
condition|)
comment|/* not defined? */
name|NDsize
operator|=
literal|1000
expr_stmt|;
comment|/* force cursor addressing */
else|else
block|{
name|NDsize
operator|=
name|comp_tc
argument_list|(
name|cmbuffer
argument_list|,
name|ND
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|myND
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|NDsize
argument_list|)
expr_stmt|;
name|movc3
argument_list|(
name|NDsize
argument_list|,
name|cmbuffer
argument_list|,
name|myND
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
name|int
name|scr
decl_stmt|;
name|printf
argument_list|(
literal|"ND"
argument_list|)
expr_stmt|;
for|for
control|(
name|scr
operator|=
literal|0
init|;
name|scr
operator|<
name|NDsize
condition|;
name|scr
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|myND
index|[
name|scr
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|UP
condition|)
comment|/* not defined? */
name|UPsize
operator|=
literal|1000
expr_stmt|;
comment|/* force cursor addressing */
else|else
block|{
name|UPsize
operator|=
name|comp_tc
argument_list|(
name|cmbuffer
argument_list|,
name|UP
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|myUP
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|UPsize
argument_list|)
expr_stmt|;
name|movc3
argument_list|(
name|UPsize
argument_list|,
name|cmbuffer
argument_list|,
name|myUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
name|int
name|scr
decl_stmt|;
name|printf
argument_list|(
literal|"UP"
argument_list|)
expr_stmt|;
for|for
control|(
name|scr
operator|=
literal|0
init|;
name|scr
operator|<
name|UPsize
condition|;
name|scr
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|myUP
index|[
name|scr
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
operator|*
name|DO
condition|)
block|{
comment|/* not defined? */
name|myDO
operator|=
name|DO
operator|=
literal|"\n"
expr_stmt|;
comment|/* assume a newline */
name|DOsize
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|DOsize
operator|=
name|comp_tc
argument_list|(
name|cmbuffer
argument_list|,
name|DO
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|myDO
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|DOsize
argument_list|)
expr_stmt|;
name|movc3
argument_list|(
name|DOsize
argument_list|,
name|cmbuffer
argument_list|,
name|myDO
argument_list|)
expr_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
name|int
name|scr
decl_stmt|;
name|printf
argument_list|(
literal|"DO"
argument_list|)
expr_stmt|;
for|for
control|(
name|scr
operator|=
literal|0
init|;
name|scr
operator|<
name|DOsize
condition|;
name|scr
operator|++
control|)
name|printf
argument_list|(
literal|" %d"
argument_list|,
name|myDO
index|[
name|scr
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|debugging
condition|)
name|Fgets
argument_list|(
name|cmbuffer
argument_list|,
operator|(
sizeof|sizeof
name|cmbuffer
operator|)
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|CMsize
operator|=
name|comp_tc
argument_list|(
name|cmbuffer
argument_list|,
name|tgoto
argument_list|(
name|CM
argument_list|,
literal|20
argument_list|,
literal|20
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PC
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|filler
operator|+
operator|(
sizeof|sizeof
name|filler
operator|)
operator|-
literal|1
init|;
operator|!
operator|*
name|p
condition|;
operator|--
name|p
control|)
operator|*
name|p
operator|=
name|PC
expr_stmt|;
block|}
name|charsperhalfsec
operator|=
name|ospeed
operator|>=
name|B9600
condition|?
literal|480
else|:
name|ospeed
operator|==
name|B4800
condition|?
literal|240
else|:
name|ospeed
operator|==
name|B2400
condition|?
literal|120
else|:
name|ospeed
operator|==
name|B1200
condition|?
literal|60
else|:
name|ospeed
operator|==
name|B600
condition|?
literal|30
else|:
comment|/* speed is 300 (?) */
literal|15
expr_stmt|;
name|gfillen
operator|=
name|ospeed
operator|>=
name|B9600
condition|?
operator|(
sizeof|sizeof
name|filler
operator|)
else|:
name|ospeed
operator|==
name|B4800
condition|?
literal|13
else|:
name|ospeed
operator|==
name|B2400
condition|?
literal|7
else|:
name|ospeed
operator|==
name|B1200
condition|?
literal|4
else|:
literal|1
operator|+
name|BCsize
expr_stmt|;
if|if
condition|(
name|ospeed
operator|<
name|B2400
condition|)
name|lowspeed
operator|=
name|TRUE
expr_stmt|;
name|strcpy
argument_list|(
name|term
argument_list|,
name|ttyname
argument_list|(
literal|2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|CM
operator|||
operator|!
name|BCsize
condition|)
name|no_can_do
argument_list|(
literal|"dumb"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|scorespec
operator|&&
operator|(
name|LINES
operator|<
literal|24
operator|||
name|COLS
operator|<
literal|80
operator|)
condition|)
name|no_can_do
argument_list|(
literal|"puny"
argument_list|)
expr_stmt|;
name|crmode
argument_list|()
expr_stmt|;
name|raw
argument_list|()
expr_stmt|;
name|noecho
argument_list|()
expr_stmt|;
comment|/* turn off echo */
name|nonl
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSHBACK
name|mac_init
argument_list|(
name|tcbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_function
name|void
name|mac_init
parameter_list|(
name|tcbuf
parameter_list|)
name|char
modifier|*
name|tcbuf
decl_stmt|;
block|{
name|char
name|tmpbuf
index|[
literal|1024
index|]
decl_stmt|;
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filexp
argument_list|(
name|getval
argument_list|(
literal|"WARPMACRO"
argument_list|,
name|WARPMACRO
argument_list|)
argument_list|)
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfp
operator|!=
name|Nullfp
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|tcbuf
argument_list|,
literal|1024
argument_list|,
name|tmpfp
argument_list|)
operator|!=
name|Nullch
condition|)
block|{
name|mac_line
argument_list|(
name|tcbuf
argument_list|,
name|tmpbuf
argument_list|,
operator|(
sizeof|sizeof
name|tmpbuf
operator|)
argument_list|)
expr_stmt|;
block|}
name|Fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mac_line
parameter_list|(
name|line
parameter_list|,
name|tmpbuf
parameter_list|,
name|tbsize
parameter_list|)
name|char
modifier|*
name|line
decl_stmt|;
name|char
modifier|*
name|tmpbuf
decl_stmt|;
name|int
name|tbsize
decl_stmt|;
block|{
name|Reg1
name|char
modifier|*
name|s
decl_stmt|;
name|Reg2
name|char
modifier|*
name|m
decl_stmt|;
name|Reg3
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
name|Reg4
name|int
name|ch
decl_stmt|;
name|Reg5
name|int
name|garbage
init|=
literal|0
decl_stmt|;
specifier|static
name|char
name|override
index|[]
init|=
literal|"\r\nkeymap overrides string\r\n"
decl_stmt|;
if|if
condition|(
name|topmap
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
name|topmap
operator|=
name|newkeymap
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|line
operator|==
literal|'#'
operator|||
operator|*
name|line
operator|==
literal|'\n'
condition|)
return|return;
if|if
condition|(
name|line
index|[
name|ch
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
name|line
index|[
name|ch
index|]
operator|=
literal|'\0'
expr_stmt|;
name|m
operator|=
name|dointerp
argument_list|(
name|tmpbuf
argument_list|,
name|tbsize
argument_list|,
name|line
argument_list|,
literal|" \t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|m
condition|)
return|return;
while|while
condition|(
operator|*
name|m
operator|==
literal|' '
operator|||
operator|*
name|m
operator|==
literal|'\t'
condition|)
name|m
operator|++
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tmpbuf
operator|,
name|curmap
operator|=
name|topmap
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
block|{
name|ch
operator|=
operator|*
name|s
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
operator|==
literal|'+'
operator|&&
name|isdigit
argument_list|(
name|s
index|[
literal|2
index|]
argument_list|)
condition|)
block|{
name|s
operator|+=
literal|2
expr_stmt|;
name|garbage
operator|=
operator|(
operator|*
name|s
operator|&
name|KM_GMASK
operator|)
operator|<<
name|KM_GSHIFT
expr_stmt|;
block|}
else|else
name|garbage
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s
index|[
literal|1
index|]
condition|)
block|{
if|if
condition|(
operator|(
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|&
name|KM_TMASK
operator|)
operator|==
name|KM_STRING
condition|)
block|{
name|puts
argument_list|(
name|override
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
argument_list|)
expr_stmt|;
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
operator|=
name|Nullch
expr_stmt|;
block|}
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|=
name|KM_KEYMAP
operator|+
name|garbage
expr_stmt|;
if|if
condition|(
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
operator|=
name|newkeymap
argument_list|()
expr_stmt|;
name|curmap
operator|=
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_km
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|(
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|&
name|KM_TMASK
operator|)
operator|==
name|KM_KEYMAP
condition|)
name|puts
argument_list|(
name|override
argument_list|)
expr_stmt|;
else|else
block|{
name|curmap
operator|->
name|km_type
index|[
name|ch
index|]
operator|=
name|KM_STRING
operator|+
name|garbage
expr_stmt|;
name|curmap
operator|->
name|km_ptr
index|[
name|ch
index|]
operator|.
name|km_str
operator|=
name|savestr
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
name|KEYMAP
modifier|*
name|newkeymap
parameter_list|()
block|{
name|Reg1
name|int
name|i
decl_stmt|;
name|Reg2
name|KEYMAP
modifier|*
name|map
decl_stmt|;
ifndef|#
directive|ifndef
name|lint
name|map
operator|=
operator|(
name|KEYMAP
operator|*
operator|)
name|safemalloc
argument_list|(
sizeof|sizeof
argument_list|(
name|KEYMAP
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|map
operator|=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* lint */
for|for
control|(
name|i
operator|=
literal|127
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|map
operator|->
name|km_ptr
index|[
name|i
index|]
operator|.
name|km_km
operator|=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
expr_stmt|;
name|map
operator|->
name|km_type
index|[
name|i
index|]
operator|=
name|KM_NOTHIN
expr_stmt|;
block|}
return|return
name|map
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* print out a file, stopping at form feeds */
end_comment

begin_function
name|void
name|page
parameter_list|(
name|filename
parameter_list|,
name|num
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
name|bool
name|num
decl_stmt|;
block|{
name|int
name|linenum
init|=
literal|1
decl_stmt|;
name|tmpfp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpfp
operator|!=
name|NULL
condition|)
block|{
while|while
condition|(
name|fgets
argument_list|(
name|spbuf
argument_list|,
operator|(
sizeof|sizeof
name|spbuf
operator|)
argument_list|,
name|tmpfp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|spbuf
operator|==
literal|'\f'
condition|)
block|{
name|printf
argument_list|(
literal|"[Type anything to continue] "
argument_list|)
expr_stmt|;
name|Fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|getcmd
argument_list|(
name|spbuf
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\r\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|spbuf
operator|==
name|INTRCH
condition|)
name|finalize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|spbuf
operator|==
literal|'q'
operator|||
operator|*
name|spbuf
operator|==
literal|'Q'
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|num
condition|)
name|printf
argument_list|(
literal|"%3d   %s\r"
argument_list|,
name|linenum
operator|++
argument_list|,
name|spbuf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s\r"
argument_list|,
name|spbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|Fclose
argument_list|(
name|tmpfp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|move
parameter_list|(
name|y
parameter_list|,
name|x
parameter_list|,
name|chadd
parameter_list|)
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
name|int
name|chadd
decl_stmt|;
block|{
name|Reg1
name|int
name|ydist
decl_stmt|;
name|Reg2
name|int
name|xdist
decl_stmt|;
name|Reg3
name|int
name|i
decl_stmt|;
name|Reg4
name|char
modifier|*
name|s
decl_stmt|;
name|ydist
operator|=
name|y
operator|-
name|real_y
expr_stmt|;
name|xdist
operator|=
name|x
operator|-
name|real_x
expr_stmt|;
name|i
operator|=
name|ydist
operator|*
operator|(
name|ydist
operator|<
literal|0
condition|?
operator|-
name|UPsize
else|:
name|DOsize
operator|)
operator|+
name|xdist
operator|*
operator|(
name|xdist
operator|<
literal|0
condition|?
operator|-
name|BCsize
else|:
name|NDsize
operator|)
expr_stmt|;
name|beg_qwrite
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|<=
name|CMsize
condition|)
block|{
if|if
condition|(
name|ydist
operator|<
literal|0
condition|)
for|for
control|(
init|;
name|ydist
condition|;
name|ydist
operator|++
control|)
for|for
control|(
name|i
operator|=
name|UPsize
operator|,
name|s
operator|=
name|myUP
init|;
name|i
condition|;
name|i
operator|--
control|)
name|qaddch
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|ydist
condition|;
name|ydist
operator|--
control|)
for|for
control|(
name|i
operator|=
name|DOsize
operator|,
name|s
operator|=
name|myDO
init|;
name|i
condition|;
name|i
operator|--
control|)
name|qaddch
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdist
operator|<
literal|0
condition|)
for|for
control|(
init|;
name|xdist
condition|;
name|xdist
operator|++
control|)
for|for
control|(
name|i
operator|=
name|BCsize
operator|,
name|s
operator|=
name|BC
init|;
name|i
condition|;
name|i
operator|--
control|)
name|qaddch
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
else|else
for|for
control|(
init|;
name|xdist
condition|;
name|xdist
operator|--
control|)
for|for
control|(
name|i
operator|=
name|NDsize
operator|,
name|s
operator|=
name|myND
init|;
name|i
condition|;
name|i
operator|--
control|)
name|qaddch
argument_list|(
operator|*
name|s
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tputs
argument_list|(
name|tgoto
argument_list|(
name|CM
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|,
literal|0
argument_list|,
name|cmstore
argument_list|)
expr_stmt|;
block|}
name|real_y
operator|=
name|y
expr_stmt|;
name|real_x
operator|=
name|x
expr_stmt|;
if|if
condition|(
name|chadd
condition|)
block|{
name|qaddch
argument_list|(
name|chadd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|maxcmstring
operator|!=
name|cmbuffer
condition|)
name|end_qwrite
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|do_tc
parameter_list|(
name|s
parameter_list|,
name|l
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
block|{
name|beg_qwrite
argument_list|()
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|l
argument_list|,
name|cmstore
argument_list|)
expr_stmt|;
name|end_qwrite
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|comp_tc
parameter_list|(
name|dest
parameter_list|,
name|s
parameter_list|,
name|l
parameter_list|)
name|char
modifier|*
name|dest
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|l
decl_stmt|;
block|{
name|maxcmstring
operator|=
name|dest
expr_stmt|;
name|tputs
argument_list|(
name|s
argument_list|,
name|l
argument_list|,
name|cmstore
argument_list|)
expr_stmt|;
return|return
operator|(
name|maxcmstring
operator|-
name|dest
operator|)
return|;
block|}
end_function

begin_function
name|void
name|helper
parameter_list|()
block|{
name|clear
argument_list|()
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|4
argument_list|,
literal|"h or 4          left"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|1
argument_list|,
literal|4
argument_list|,
literal|"j or 2          down                Use with SHIFT to fire torpedoes."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|2
argument_list|,
literal|4
argument_list|,
literal|"k or 8          up                  Use with CTRL or FUNCT to fire"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|3
argument_list|,
literal|4
argument_list|,
literal|"l or 6          right                   phasers or turbolasers."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|4
argument_list|,
literal|4
argument_list|,
literal|"b or 1          down and left       Use preceded by 'a' or 'r' for"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|5
argument_list|,
literal|4
argument_list|,
literal|"n or 3          down and right          attractors or repulsors."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|6
argument_list|,
literal|4
argument_list|,
literal|"y or 7          up and left         Use normally for E or B motion."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|7
argument_list|,
literal|4
argument_list|,
literal|"u or 9          up and right"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|8
argument_list|,
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|9
argument_list|,
literal|4
argument_list|,
literal|"del or %        fire photon torpedoes in every (reasonable) direction."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|10
argument_list|,
literal|4
argument_list|,
literal|"s               stop all torpedoes."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|11
argument_list|,
literal|4
argument_list|,
literal|"S or 0          stop the Enterprise when in warp mode."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|12
argument_list|,
literal|4
argument_list|,
literal|"d/D             destruct all torpedoes/current vessel."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|13
argument_list|,
literal|4
argument_list|,
literal|"i/w             switch to Enterprise& put into impulse/warp mode."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|14
argument_list|,
literal|4
argument_list|,
literal|"c/v             switch to Enterprise& make cloaked/visible."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|15
argument_list|,
literal|4
argument_list|,
literal|"p               switch to Base."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|16
argument_list|,
literal|4
argument_list|,
literal|"o               toggle to other vessel (from E to B, or vice versa.)"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|17
argument_list|,
literal|4
argument_list|,
literal|"z               zap (suppress) blasts near Enterprise next cycle"
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|18
argument_list|,
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|19
argument_list|,
literal|4
argument_list|,
literal|"^R      refresh the screen.              ^Z      suspend the game."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|20
argument_list|,
literal|4
argument_list|,
literal|"q       exit this round (if you haven't typed q within 10 cycles)."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|21
argument_list|,
literal|4
argument_list|,
literal|"Q       exit this game."
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|22
argument_list|,
literal|4
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|23
argument_list|,
literal|4
argument_list|,
literal|"                   [Hit space to continue]"
argument_list|)
expr_stmt|;
name|Fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
do|do
block|{
name|getcmd
argument_list|(
name|spbuf
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|spbuf
operator|!=
literal|' '
condition|)
do|;
name|rewrite
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|rewrite
parameter_list|()
block|{
name|Reg1
name|int
name|x
decl_stmt|;
name|Reg2
name|int
name|y
decl_stmt|;
name|Reg3
name|OBJECT
modifier|*
name|obj
decl_stmt|;
name|clear
argument_list|()
expr_stmt|;
for|for
control|(
name|y
operator|=
literal|0
init|;
name|y
operator|<
name|YSIZE
condition|;
name|y
operator|++
control|)
block|{
for|for
control|(
name|x
operator|=
literal|0
init|;
name|x
operator|<
name|XSIZE
condition|;
name|x
operator|++
control|)
block|{
if|if
condition|(
name|numamoebas
operator|&&
name|amb
index|[
name|y
index|]
index|[
name|x
index|]
operator|!=
literal|' '
condition|)
name|mvaddc
argument_list|(
name|y
operator|+
literal|1
argument_list|,
name|x
operator|*
literal|2
argument_list|,
name|amb
index|[
name|y
index|]
index|[
name|x
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|obj
operator|=
name|occupant
index|[
name|y
index|]
index|[
name|x
index|]
condition|)
block|{
if|if
condition|(
name|obj
operator|->
name|image
operator|!=
literal|' '
condition|)
name|mvaddc
argument_list|(
name|y
operator|+
literal|1
argument_list|,
name|x
operator|*
literal|2
argument_list|,
name|obj
operator|->
name|image
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|Sprintf
argument_list|(
name|spbuf
argument_list|,
literal|"%-4s E: %4d %2d B: %5d %3d Enemies: %-3d Stars: %-3d Stardate%5d.%1d %9ld"
argument_list|,
literal|"   "
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|timer
operator|/
literal|10
operator|+
name|smarts
operator|*
literal|100
argument_list|,
name|timer
operator|%
literal|10
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
name|mvaddstr
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|spbuf
argument_list|)
expr_stmt|;
name|oldeenergy
operator|=
name|oldbenergy
operator|=
name|oldcurscore
operator|=
name|oldstatus
operator|=
name|oldetorp
operator|=
name|oldbtorp
operator|=
name|oldstrs
operator|=
name|oldenemies
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* force everything to fill in */
if|if
condition|(
name|damage
condition|)
name|olddamage
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|ent
condition|)
name|etorp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|base
condition|)
name|btorp
operator|=
literal|0
expr_stmt|;
name|display_status
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|char
name|cmstore
parameter_list|(
name|ch
parameter_list|)
name|Reg1
name|char
name|ch
decl_stmt|;
block|{
operator|*
name|maxcmstring
operator|++
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_comment
comment|/* discard any characters typed ahead */
end_comment

begin_function
name|void
name|eat_typeahead
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|PUSHBACK
if|if
condition|(
operator|!
name|typeahead
operator|&&
name|nextin
operator|==
name|nextout
condition|)
comment|/* cancel only keyboard stuff */
else|#
directive|else
if|if
condition|(
operator|!
name|typeahead
condition|)
endif|#
directive|endif
block|{
ifdef|#
directive|ifdef
name|PENDING
while|while
condition|(
name|input_pending
argument_list|()
condition|)
name|Read_tty
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* this is probably v7, with no rdchk() */
name|ioctl
argument_list|(
name|_tty_ch
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|_tty
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

begin_function
name|void
name|settle_down
parameter_list|()
block|{
name|dingaling
argument_list|()
expr_stmt|;
name|Fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|PUSHBACK
name|nextout
operator|=
name|nextin
expr_stmt|;
comment|/* empty circlebuf */
endif|#
directive|endif
name|eat_typeahead
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_comment
comment|/* read a character from the terminal, with multi-character pushback */
end_comment

begin_function
name|int
name|read_tty
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
comment|/* ignored for now */
block|{
ifdef|#
directive|ifdef
name|lint
name|size
operator|=
name|size
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nextout
operator|!=
name|nextin
condition|)
block|{
operator|*
name|addr
operator|=
name|circlebuf
index|[
name|nextout
operator|++
index|]
expr_stmt|;
name|nextout
operator|%=
name|PUSHSIZE
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|size
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|sig_catcher
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|metakey
condition|)
block|{
if|if
condition|(
operator|*
name|addr
operator|&
literal|0200
condition|)
block|{
name|pushchar
argument_list|(
operator|*
name|addr
operator|&
literal|0177
argument_list|)
expr_stmt|;
operator|*
name|addr
operator|=
literal|'\001'
expr_stmt|;
block|}
block|}
else|else
operator|*
name|addr
operator|&=
literal|0177
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PENDING
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|FIONREAD
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|RDCHK
end_ifndef

begin_function
name|int
name|circfill
parameter_list|()
block|{
name|Reg1
name|int
name|howmany
decl_stmt|;
name|Reg2
name|int
name|i
decl_stmt|;
name|assert
argument_list|(
name|nextin
operator|==
name|nextout
argument_list|)
expr_stmt|;
name|howmany
operator|=
name|read
argument_list|(
name|devtty
argument_list|,
name|circlebuf
operator|+
name|nextin
argument_list|,
name|metakey
condition|?
literal|1
else|:
name|PUSHSIZE
operator|-
name|nextin
argument_list|)
expr_stmt|;
if|if
condition|(
name|howmany
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|metakey
condition|)
block|{
if|if
condition|(
name|circlebuf
index|[
name|nextin
index|]
operator|&
literal|0200
condition|)
block|{
name|circlebuf
index|[
name|nextin
index|]
operator|&=
literal|0177
expr_stmt|;
name|pushchar
argument_list|(
literal|'\001'
argument_list|)
expr_stmt|;
block|}
block|}
else|else
for|for
control|(
name|i
operator|=
name|howmany
operator|+
name|nextin
operator|-
literal|1
init|;
name|i
operator|>=
name|nextin
condition|;
name|i
operator|--
control|)
name|circlebuf
index|[
name|i
index|]
operator|&=
literal|0177
expr_stmt|;
name|nextin
operator|+=
name|howmany
expr_stmt|;
name|nextin
operator|%=
name|PUSHSIZE
expr_stmt|;
comment|/* may end up 1 if metakey */
block|}
return|return
name|howmany
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* RDCHK */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* FIONREAD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PENDING */
end_comment

begin_function
name|void
name|pushchar
parameter_list|(
name|ch
parameter_list|)
name|char
name|ch
decl_stmt|;
block|{
name|nextout
operator|--
expr_stmt|;
if|if
condition|(
name|nextout
operator|<
literal|0
condition|)
name|nextout
operator|=
name|PUSHSIZE
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|nextout
operator|==
name|nextin
condition|)
block|{
name|fputs
argument_list|(
literal|"\r\npushback buffer overflow\r\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|circlebuf
index|[
name|nextout
index|]
operator|=
name|ch
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* PUSHBACK */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|read_tty
end_ifndef

begin_comment
comment|/* read a character from the terminal, with hacks for O_NDELAY reads */
end_comment

begin_function
name|int
name|read_tty
parameter_list|(
name|addr
parameter_list|,
name|size
parameter_list|)
name|char
modifier|*
name|addr
decl_stmt|;
name|int
name|size
decl_stmt|;
block|{
if|if
condition|(
name|is_input
condition|)
block|{
operator|*
name|addr
operator|=
name|pending_ch
expr_stmt|;
name|is_input
operator|=
name|FALSE
expr_stmt|;
return|return
literal|1
return|;
block|}
else|else
block|{
name|size
operator|=
name|read
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|0
condition|)
name|sig_catcher
argument_list|(
name|SIGHUP
argument_list|)
expr_stmt|;
if|if
condition|(
name|metakey
condition|)
block|{
if|if
condition|(
operator|*
name|addr
operator|&
literal|0200
condition|)
block|{
name|pending_ch
operator|=
operator|*
name|addr
operator|&
literal|0177
expr_stmt|;
name|is_input
operator|=
name|TRUE
expr_stmt|;
operator|*
name|addr
operator|=
literal|'\001'
expr_stmt|;
block|}
block|}
else|else
operator|*
name|addr
operator|&=
literal|0177
expr_stmt|;
return|return
name|size
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* read_tty */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* PUSHBACK */
end_comment

begin_function
name|int
name|read_nd
parameter_list|(
name|buff
parameter_list|,
name|siz
parameter_list|)
name|char
modifier|*
name|buff
decl_stmt|;
name|int
name|siz
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|input_pending
argument_list|()
condition|)
return|return
literal|0
return|;
name|getcmd
argument_list|(
name|buff
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* get a character into a buffer */
end_comment

begin_function
name|void
name|getcmd
parameter_list|(
name|whatbuf
parameter_list|)
name|Reg3
name|char
modifier|*
name|whatbuf
decl_stmt|;
block|{
ifdef|#
directive|ifdef
name|PUSHBACK
name|Reg1
name|KEYMAP
modifier|*
name|curmap
decl_stmt|;
name|Reg2
name|int
name|i
decl_stmt|;
name|bool
name|no_macros
decl_stmt|;
name|int
name|times
init|=
literal|0
decl_stmt|;
comment|/* loop detector */
name|char
name|scrchar
decl_stmt|;
name|tryagain
label|:
name|curmap
operator|=
name|topmap
expr_stmt|;
comment|/*    no_macros = (whatbuf != buf&& nextin == nextout);  */
name|no_macros
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
for|for
control|(
init|;
condition|;
control|)
block|{
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|read_tty
argument_list|(
name|whatbuf
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|&&
operator|!
name|errno
condition|)
name|errno
operator|=
name|EINTR
expr_stmt|;
ifdef|#
directive|ifdef
name|read_tty
if|if
condition|(
name|metakey
condition|)
block|{
if|if
condition|(
operator|*
name|whatbuf
operator|&
literal|0200
condition|)
block|{
operator|*
name|what_buf
operator|&=
literal|037
expr_stmt|;
comment|/* punt and hope they don't notice */
block|}
block|}
else|else
operator|*
name|whatbuf
operator|&=
literal|0177
expr_stmt|;
endif|#
directive|endif
comment|/* read_tty */
if|if
condition|(
name|errno
operator|&&
name|errno
operator|!=
name|EINTR
condition|)
block|{
name|perror
argument_list|(
name|readerr
argument_list|)
expr_stmt|;
name|sig_catcher
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|PUSHBACK
if|if
condition|(
operator|*
name|whatbuf
operator|&
literal|0200
operator|||
name|no_macros
condition|)
block|{
operator|*
name|whatbuf
operator|&=
literal|0177
expr_stmt|;
goto|goto
name|got_canonical
goto|;
block|}
if|if
condition|(
name|curmap
operator|==
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
condition|)
goto|goto
name|got_canonical
goto|;
for|for
control|(
name|i
operator|=
operator|(
name|curmap
operator|->
name|km_type
index|[
operator|*
name|whatbuf
index|]
operator|>>
name|KM_GSHIFT
operator|)
operator|&
name|KM_GMASK
init|;
name|i
condition|;
operator|--
name|i
control|)
block|{
name|Read_tty
argument_list|(
operator|&
name|scrchar
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|curmap
operator|->
name|km_type
index|[
operator|*
name|whatbuf
index|]
operator|&
name|KM_TMASK
condition|)
block|{
case|case
name|KM_NOTHIN
case|:
comment|/* no entry? */
if|if
condition|(
name|curmap
operator|==
name|topmap
condition|)
comment|/* unmapped canonical */
goto|goto
name|got_canonical
goto|;
name|settle_down
argument_list|()
expr_stmt|;
goto|goto
name|tryagain
goto|;
case|case
name|KM_KEYMAP
case|:
comment|/* another keymap? */
name|curmap
operator|=
name|curmap
operator|->
name|km_ptr
index|[
operator|*
name|whatbuf
index|]
operator|.
name|km_km
expr_stmt|;
name|assert
argument_list|(
name|curmap
operator|!=
name|Null
argument_list|(
name|KEYMAP
operator|*
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|KM_STRING
case|:
comment|/* a string? */
name|pushstring
argument_list|(
name|curmap
operator|->
name|km_ptr
index|[
operator|*
name|whatbuf
index|]
operator|.
name|km_str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|times
operator|>
literal|20
condition|)
block|{
comment|/* loop? */
name|fputs
argument_list|(
literal|"\r\nmacro loop?\r\n"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|settle_down
argument_list|()
expr_stmt|;
block|}
name|no_macros
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|tryagain
goto|;
block|}
else|#
directive|else
operator|*
name|whatbuf
operator|&=
literal|0177
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
name|got_canonical
label|:
ifndef|#
directive|ifndef
name|TERMIO
if|if
condition|(
operator|*
name|whatbuf
operator|==
literal|'\r'
condition|)
operator|*
name|whatbuf
operator|=
literal|'\n'
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|whatbuf
operator|==
name|buf
condition|)
name|whatbuf
index|[
literal|1
index|]
operator|=
name|FINISHCMD
expr_stmt|;
comment|/* tell finish_command to work */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|PUSHBACK
end_ifdef

begin_function
name|void
name|pushstring
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|Reg1
name|int
name|i
decl_stmt|;
name|char
name|tmpbuf
index|[
name|PUSHSIZE
index|]
decl_stmt|;
name|Reg2
name|char
modifier|*
name|s
init|=
name|tmpbuf
decl_stmt|;
name|assert
argument_list|(
name|str
operator|!=
name|Nullch
argument_list|)
expr_stmt|;
name|interp
argument_list|(
name|s
argument_list|,
name|PUSHSIZE
argument_list|,
name|str
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
operator|--
name|i
control|)
block|{
name|s
index|[
name|i
index|]
operator|^=
literal|0200
expr_stmt|;
name|pushchar
argument_list|(
name|s
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

