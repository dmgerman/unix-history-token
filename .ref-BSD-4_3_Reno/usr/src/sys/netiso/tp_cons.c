begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  * $Header: tp_cons.c,v 5.6 88/11/18 17:27:13 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_cons.c,v $  *	@(#)tp_cons.c	7.3 (Berkeley) 8/29/89 *  *  * Here is where you find the iso-dependent code.  We've tried  * keep all net-level and (primarily) address-family-dependent stuff  * out of the tp source, and everthing here is reached indirectly  * through a switch table (struct nl_protosw *) tpcb->tp_nlproto   * (see tp_pcb.c).   * The routines here are:  *		tpcons_mtu: figure out what size tpdu to use  *		tpcons_input: pullup and call tp_input w/ correct arguments  *		tpcons_output_dg: package a pkt for cons given 2 addresses& some data  *		tpcons_output: package a pkt for cons given an isopcb& some data  *		cons_chan_to_tpcb: find a tpcb based on the channel #  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: tp_cons.c,v 5.6 88/11/18 17:27:13 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"argoxtwentyfive.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|ISO
end_ifdef

begin_if
if|#
directive|if
name|NARGOXTWENTYFIVE
operator|>
literal|0
end_if

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"../net/if.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"../net/route.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"iso_pcb.h"
end_include

begin_include
include|#
directive|include
file|"cons.h"
end_include

begin_include
include|#
directive|include
file|"tp_seq.h"
end_include

begin_function_decl
name|int
name|tpcons_output
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * CALLED FROM:  *  tp_input() on incoming CR, CC, and pr_usrreq() for PRU_CONNECT  * FUNCTION, ARGUMENTS, SIDE EFFECTS and RETURN VALUE:  *  version of the previous procedure for X.25  */
end_comment

begin_function
name|void
name|tpcons_mtu
parameter_list|(
name|so
parameter_list|,
name|isop
parameter_list|,
name|size
parameter_list|,
name|negot
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|int
modifier|*
name|size
decl_stmt|;
name|u_char
modifier|*
name|negot
decl_stmt|;
block|{
specifier|register
name|struct
name|ifnet
modifier|*
name|ifp
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
name|int
name|windowsize
init|=
name|so
operator|->
name|so_rcv
operator|.
name|sb_hiwat
decl_stmt|;
name|struct
name|ifnet
modifier|*
name|iso_routeifp
parameter_list|()
function_decl|;
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"ENTER GET MTU: size negot "
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
modifier|*
name|size
init|=
literal|1
operator|<<
operator|*
name|negot
decl_stmt|;
if|if
condition|(
operator|(
name|ifp
operator|=
name|iso_routeifp
argument_list|(
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|ifnet
operator|*
operator|)
literal|0
condition|)
return|return;
if|if
condition|(
operator|*
name|size
operator|>
name|windowsize
condition|)
block|{
operator|*
name|size
operator|=
name|windowsize
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|size
operator|>
name|ifp
operator|->
name|if_mtu
condition|)
block|{
operator|*
name|size
operator|=
name|ifp
operator|->
name|if_mtu
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
condition|)
block|{
comment|/* size was changed by this routine - have to transform it to 		 * the log2 of size 		 */
for|for
control|(
name|i
operator|=
name|TP_MIN_TPDUSIZE
init|;
operator|(
name|i
operator|<
name|TP_MAX_TPDUSIZE
operator|&&
operator|(
operator|(
literal|1
operator|<<
name|i
operator|)
operator|<
operator|*
name|size
operator|)
operator|)
condition|;
name|i
operator|++
control|)
empty_stmt|;
comment|/* are we on the same LAN? if so, negotiate one tpdu size larger, 		 * and actually send the real mtu size 		 */
comment|/* PHASE2: replace with iso_on_localnet(&isop->isop_faddr); 		 */
if|if
condition|(
operator|!
name|iso_netmatch
argument_list|(
operator|&
name|isop
operator|->
name|isop_laddr
argument_list|,
operator|&
name|isop
operator|->
name|isop_faddr
argument_list|)
condition|)
block|{
name|i
operator|--
expr_stmt|;
operator|*
name|size
operator|=
literal|1
operator|<<
name|i
expr_stmt|;
block|}
operator|*
name|negot
operator|=
name|i
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"GET MTU RETURNS: ifp %s size 0x%x negot 0x%x\n"
argument_list|,
name|ifp
operator|->
name|if_name
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
argument_list|(
name|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"EXIT GET MTU: tpcb size negot "
argument_list|,
operator|*
name|size
argument_list|,
operator|*
name|negot
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
decl_stmt|;
name|ENDTRACE
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	cons  * FUNCTION and ARGUMENTS:  * THIS MAYBE BELONGS IN SOME OTHER PLACE??? but i think not -  */
end_comment

begin_function
name|ProtoHook
name|tpcons_ctlinput
parameter_list|(
name|cmd
parameter_list|,
name|siso
parameter_list|,
name|isop
parameter_list|)
name|int
name|cmd
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|siso
decl_stmt|;
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
block|{
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
name|PRC_CONS_SEND_DONE
case|:
if|if
condition|(
name|isop
operator|->
name|isop_socket
condition|)
block|{
comment|/* tp 0 only */
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
decl_stmt|;
name|struct
name|tp_event
name|E
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
comment|/* only if class is exactly class zero, not 				 * still in class negotiation 				 */
comment|/* fake an ack */
specifier|register
name|SeqNum
name|seq
init|=
name|SEQ_ADD
argument_list|(
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_snduna
argument_list|,
literal|1
argument_list|)
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_DATA
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"FAKE ACK seq cdt 1"
argument_list|,
name|seq
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_DATA
argument_list|)
name|printf
argument_list|(
literal|"FAKE ACK seq 0x%x cdt 1\n"
argument_list|,
name|seq
argument_list|)
decl_stmt|;
name|ENDDEBUG
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
decl|.
name|e_cdt
init|=
literal|1
decl_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|seq
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_subseq
operator|=
literal|0
expr_stmt|;
name|E
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_fcc_present
operator|=
literal|0
expr_stmt|;
name|error
operator|=
name|DoEvent
argument_list|(
name|AK_TPDU
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
block|}
block|}
comment|/* else ignore it */
block|}
break|break;
case|case
name|PRC_ROUTEDEAD
case|:
if|if
condition|(
name|isop
operator|->
name|isop_socket
condition|)
block|{
comment|/* tp 0 only */
name|tpiso_reset
argument_list|(
name|isop
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* else drop through */
default|default:
operator|(
name|void
operator|)
name|tpclnp_ctlinput
argument_list|(
name|cmd
argument_list|,
name|siso
argument_list|)
expr_stmt|;
break|break;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  * 	cons's intr routine  * FUNCTION and ARGUMENTS:  * Take a packet (m) from cons, pullup m as required by tp,  *  ignore the socket argument, and call tp_input.   * No return value.    */
end_comment

begin_function
name|ProtoHook
name|tpcons_input
parameter_list|(
name|m
parameter_list|,
name|faddr
parameter_list|,
name|laddr
parameter_list|,
name|so
parameter_list|,
name|channel
parameter_list|)
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|struct
name|sockaddr_iso
modifier|*
name|faddr
decl_stmt|,
decl|*
name|laddr
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* not used */
end_comment

begin_decl_stmt
name|int
name|channel
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|m
operator|==
name|MNULL
condition|)
return|return
literal|0
return|;
name|m
operator|=
operator|(
expr|struct
name|mbuf
operator|*
operator|)
name|tp_inputprep
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tpcons_input before tp_input(m 0x%x)\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|m
argument_list|,
literal|12
operator|+
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|tp_input
parameter_list|(
name|m
parameter_list|,
name|faddr
parameter_list|,
name|laddr
parameter_list|,
name|channel
parameter_list|,
name|tpcons_output
parameter_list|)
function_decl|;
return|return
literal|0
return|;
block|}
end_block

begin_comment
comment|/*  * CALLED FROM:  *  tp_emit()  * FUNCTION and ARGUMENTS:  *  Take a packet(m0) from tp and package it so that cons will accept it.  *  This means filling in a few of the fields.  *  inp is the isopcb structure; datalen is the length of the data in the  *  mbuf string m0.  * RETURN VALUE:  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpcons_output
parameter_list|(
name|isop
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|isopcb
modifier|*
name|isop
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
name|int
name|datalen
decl_stmt|;
name|int
name|nochksum
decl_stmt|;
block|{
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
name|int
name|error
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_EMIT
argument_list|)
name|printf
argument_list|(
literal|"tpcons_output(isop 0x%x, m 0x%x, len 0x%x socket 0x%x\n"
argument_list|,
name|isop
argument_list|,
name|m0
argument_list|,
name|datalen
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|m0
operator|==
name|MNULL
condition|)
return|return
literal|0
return|;
name|ASSERT
argument_list|(
name|m0
operator|->
name|m_len
operator|>
literal|0
argument_list|)
expr_stmt|;
name|tpcb
operator|=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
expr_stmt|;
comment|/* check is for class EQUAL to 4: if still in negotiation stage,  	 * cannot send as dgm 	 */
name|error
operator|=
name|cons_output
argument_list|(
name|isop
argument_list|,
name|m0
argument_list|,
name|datalen
argument_list|,
operator|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
operator|)
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_tpdu_sent
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_EMIT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tpcons_output( isop  m isdgm cons_output returns"
argument_list|,
name|isop
argument_list|,
name|m0
argument_list|,
operator|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
operator|)
argument_list|,
name|error
argument_list|)
expr_stmt|;
name|ENDTRACE
return|return
name|error
return|;
block|}
end_function

begin_comment
comment|/*  * CALLED FROM:  *  tp_error_emit()  * FUNCTION and ARGUMENTS:  *  This is a copy of tpcons_output that takes the addresses  *  instead of a pcb.  It's used by the tp_error_emit, when we  *  don't have an iso_pcb with which to call the normal output rtn.  * RETURN VALUE:  *  ENOBUFS or  *  whatever (E*) is returned form the net layer output routine.  */
end_comment

begin_function
name|int
name|tpcons_output_dg
parameter_list|(
name|laddr
parameter_list|,
name|faddr
parameter_list|,
name|m0
parameter_list|,
name|datalen
parameter_list|,
name|ro
parameter_list|,
name|nochksum
parameter_list|)
name|struct
name|iso_addr
modifier|*
name|laddr
decl_stmt|,
decl|*
name|faddr
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|mbuf
modifier|*
name|m0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datalen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|route
modifier|*
name|ro
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nochksum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|IFDEBUG
argument_list|(
argument|D_TPISO
argument_list|)
name|printf
argument_list|(
literal|"PANIC: tpcons_output_dg  datalen 0x%x m0 0x%x\n"
argument_list|,
name|datalen
argument_list|,
name|m0
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
literal|0
return|;
block|}
end_block

begin_function
name|struct
name|tp_pcb
modifier|*
name|cons_chan_to_tpcb
parameter_list|(
name|chan
parameter_list|)
name|int
name|chan
decl_stmt|;
block|{
specifier|extern
name|struct
name|isopcb
modifier|*
name|cons_chan_to_pcb
parameter_list|()
function_decl|;
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|struct
name|isopcb
modifier|*
name|isop
init|=
name|cons_chan_to_pcb
argument_list|(
name|chan
argument_list|,
operator|-
literal|1
argument_list|)
decl_stmt|;
else|#
directive|else
else|ARGO_DEBUG
name|struct
name|isopcb
modifier|*
name|isop
init|=
name|cons_chan_to_pcb
argument_list|(
name|chan
argument_list|)
decl_stmt|;
endif|#
directive|endif
endif|ARGO_DEBUG
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"vc->tpcb(chan) socket"
argument_list|,
name|chan
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"vc->tpcb(0x%x) socket 0x%x, *ISOP dump:"
argument_list|,
name|chan
argument_list|,
name|isop
operator|->
name|isop_socket
argument_list|)
decl_stmt|;
name|dump_buf
argument_list|(
name|isop
argument_list|,
literal|32
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|isop
operator|->
name|isop_socket
operator|==
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
condition|)
return|return
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
literal|0
return|;
else|else
block|{
return|return
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
operator|(
name|isop
operator|->
name|isop_socket
operator|->
name|so_tpcb
operator|)
return|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
endif|NARGOXTWENTYFIVE
end_endif

begin_endif
endif|#
directive|endif
endif|ISO
end_endif

end_unit

