begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** 		Copyright IBM Corporation 1987                        All Rights Reserved  Permission to use, copy, modify, and distribute this software and its  documentation for any purpose and without fee is hereby granted,  provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in  supporting documentation, and that the name of IBM not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.    IBM DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL IBM BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  ******************************************************************/
end_comment

begin_comment
comment|/*  * ARGO Project, Computer Sciences Dept., University of Wisconsin - Madison  */
end_comment

begin_comment
comment|/*   * ARGO TP  *  * $Header: tp_input.c,v 5.6 88/11/18 17:27:38 nhall Exp $  * $Source: /usr/argo/sys/netiso/RCS/tp_input.c,v $  *	@(#)tp_input.c	7.14 (Berkeley) 7/24/90 *  *  * tp_input() gets an mbuf chain from ip.  Actually, not directly  * from ip, because ip calls a net-level routine that strips off  * the net header and then calls tp_input(), passing the proper type  * of addresses for the address family in use (how it figures out  * which AF is not yet determined.  *  * Decomposing the tpdu is some of the most laughable code.  The variable-length  * parameters and the problem of non-aligned memory references  * necessitates such abominations as the macros WHILE_OPTIONS (q.v. below)  * to loop through the header and decompose it.  *  * The routine tp_newsocket() is called when a CR comes in for a listening  * socket.  tp_input calls sonewconn() and tp_newsocket() to set up the  * "child" socket.  Most tpcb values are copied from the parent tpcb into  * the child.  *   * Also in here is tp_headersize() (grot) which tells the expected size  * of a tp header, to be used by other layers.  It's in here because it  * uses the static structure tpdu_info.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: tp_input.c,v 5.6 88/11/18 17:27:38 nhall Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_include
include|#
directive|include
file|"argoxtwentyfive.h"
end_include

begin_include
include|#
directive|include
file|"param.h"
end_include

begin_include
include|#
directive|include
file|"systm.h"
end_include

begin_include
include|#
directive|include
file|"mbuf.h"
end_include

begin_include
include|#
directive|include
file|"socket.h"
end_include

begin_include
include|#
directive|include
file|"socketvar.h"
end_include

begin_include
include|#
directive|include
file|"domain.h"
end_include

begin_include
include|#
directive|include
file|"protosw.h"
end_include

begin_include
include|#
directive|include
file|"errno.h"
end_include

begin_include
include|#
directive|include
file|"time.h"
end_include

begin_include
include|#
directive|include
file|"kernel.h"
end_include

begin_include
include|#
directive|include
file|"types.h"
end_include

begin_include
include|#
directive|include
file|"iso_errno.h"
end_include

begin_include
include|#
directive|include
file|"tp_param.h"
end_include

begin_include
include|#
directive|include
file|"tp_timer.h"
end_include

begin_include
include|#
directive|include
file|"tp_stat.h"
end_include

begin_include
include|#
directive|include
file|"tp_pcb.h"
end_include

begin_include
include|#
directive|include
file|"argo_debug.h"
end_include

begin_include
include|#
directive|include
file|"tp_trace.h"
end_include

begin_include
include|#
directive|include
file|"tp_tpdu.h"
end_include

begin_include
include|#
directive|include
file|"iso.h"
end_include

begin_include
include|#
directive|include
file|"cons.h"
end_include

begin_decl_stmt
name|int
name|iso_check_csum
argument_list|()
decl_stmt|,
name|tp_driver
argument_list|()
decl_stmt|,
name|tp_headersize
argument_list|()
decl_stmt|,
name|tp_error_emit
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 	#ifdef lint 	#undef ATTR 	#define ATTR(X)ev_number 	#endif lint */
end_comment

begin_function
name|struct
name|mbuf
modifier|*
name|tp_inputprep
parameter_list|(
name|m
parameter_list|)
specifier|register
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
block|{
name|int
name|hdrlen
decl_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_inputprep: m 0x%x\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
while|while
condition|(
name|m
operator|->
name|m_len
operator|<
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_free
argument_list|(
name|m
argument_list|)
operator|)
operator|==
name|MNULL
condition|)
block|{
return|return
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
return|;
block|}
block|}
if|if
condition|(
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_data
operator|)
operator|&
literal|0x3
condition|)
block|{
comment|/* If we are not 4-byte aligned, we have to be 		 * above the beginning of the mbuf, and it is ok just 		 * to slide it back.  		 */
name|caddr_t
name|ocp
init|=
name|m
operator|->
name|m_data
decl_stmt|;
name|m
operator|->
name|m_data
operator|=
call|(
name|caddr_t
call|)
argument_list|(
operator|(
operator|(
name|int
operator|)
name|m
operator|->
name|m_data
operator|)
operator|&
operator|~
literal|0x3
argument_list|)
expr_stmt|;
name|ovbcopy
argument_list|(
name|ocp
argument_list|,
name|m
operator|->
name|m_data
argument_list|,
operator|(
name|unsigned
operator|)
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
block|}
name|CHANGE_MTYPE
argument_list|(
name|m
argument_list|,
name|TPMT_DATA
argument_list|)
expr_stmt|;
comment|/* we KNOW that there is at least 1 byte in this mbuf 	   and that it is hdr->tpdu_li XXXXXXX!  */
name|hdrlen
operator|=
literal|1
operator|+
operator|*
name|mtod
argument_list|(
name|m
argument_list|,
name|u_char
operator|*
argument_list|)
expr_stmt|;
comment|/* 	 * now pull up the whole tp header  	 */
if|if
condition|(
name|m
operator|->
name|m_len
operator|<
name|hdrlen
condition|)
block|{
if|if
condition|(
operator|(
name|m
operator|=
name|m_pullup
argument_list|(
name|m
argument_list|,
name|hdrlen
argument_list|)
operator|)
operator|==
name|MNULL
condition|)
block|{
name|IncStat
argument_list|(
name|ts_recv_drop
argument_list|)
expr_stmt|;
return|return
operator|(
expr|struct
name|mbuf
operator|*
operator|)
literal|0
return|;
block|}
block|}
name|IFDEBUG
argument_list|(
argument|D_INPUT
argument_list|)
name|printf
argument_list|(
literal|" at end: m 0x%x hdr->tpdu_li 0x%x m_len 0x%x\n"
argument_list|,
name|m
argument_list|,
name|hdrlen
argument_list|,
name|m
operator|->
name|m_len
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* begin groan  * -- this array and the following macros allow you to step through the  * parameters of the variable part of a header  * note that if for any reason the values of the **_TPDU macros (in tp_events.h)  * should change, this array has to be rearranged  */
end_comment

begin_define
define|#
directive|define
name|TP_LEN_CLASS_0_INDEX
value|2
end_define

begin_define
define|#
directive|define
name|TP_MAX_DATA_INDEX
value|3
end_define

begin_decl_stmt
specifier|static
name|u_char
name|tpdu_info
index|[]
index|[
literal|4
index|]
init|=
block|{
comment|/*								length						 max data len */
comment|/*								reg fmt 	xtd fmt  class 0  		 	  */
comment|/* UNUSED		0x0 */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* XPD_TPDU_type 0x1 */
literal|0x5
block|,
literal|0x8
block|,
literal|0x0
block|,
name|TP_MAX_XPD_DATA
block|,
comment|/* XAK_TPDU_type 0x2 */
literal|0x5
block|,
literal|0x8
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* GR_TPDU_type	0x3 */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* UNUSED		0x4 */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* UNUSED		0x5 */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* AK_TPDU_type 0x6 */
literal|0x5
block|,
literal|0xa
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* ER_TPDU_type 0x7 */
literal|0x5
block|,
literal|0x5
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* DR_TPDU_type 0x8 */
literal|0x7
block|,
literal|0x7
block|,
literal|0x7
block|,
name|TP_MAX_DR_DATA
block|,
comment|/* UNUSED		0x9 */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* UNUSED		0xa */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* UNUSED		0xb */
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* DC_TPDU_type 0xc */
literal|0x6
block|,
literal|0x6
block|,
literal|0x0
block|,
literal|0x0
block|,
comment|/* CC_TPDU_type 0xd */
literal|0x7
block|,
literal|0x7
block|,
literal|0x7
block|,
name|TP_MAX_CC_DATA
block|,
comment|/* CR_TPDU_type 0xe */
literal|0x7
block|,
literal|0x7
block|,
literal|0x7
block|,
name|TP_MAX_CR_DATA
block|,
comment|/* DT_TPDU_type 0xf */
literal|0x5
block|,
literal|0x8
block|,
literal|0x3
block|,
literal|0x0
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|CHECK
parameter_list|(
name|Phrase
parameter_list|,
name|Erval
parameter_list|,
name|Stat
parameter_list|,
name|Whattodo
parameter_list|,
name|Loc
parameter_list|)
define|\
value|if (Phrase) {error = (Erval); errlen = (int)(Loc); IncStat(Stat); tpibrk();\ 	goto Whattodo; }
end_define

begin_macro
name|tpibrk
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/*   * WHENEVER YOU USE THE FOLLOWING MACRO,  * BE SURE THE TPDUTYPE IS A LEGIT VALUE FIRST!   */
end_comment

begin_define
define|#
directive|define
name|WHILE_OPTIONS
parameter_list|(
name|P
parameter_list|,
name|hdr
parameter_list|,
name|format
parameter_list|)
define|\
value|{	register caddr_t P = tpdu_info[(hdr)->tpdu_type][(format)] + (caddr_t)hdr;\ 	caddr_t PLIM = 1 + hdr->tpdu_li + (caddr_t)hdr;\ 	for (;; P += 2 + ((struct tp_vbp *)P)->tpv_len) {\ 		CHECK((P> PLIM), E_TP_LENGTH_INVAL, ts_inv_length,\ 				respond, P - (caddr_t)hdr);\ 		if (P == PLIM) break;
end_define

begin_define
define|#
directive|define
name|END_WHILE_OPTIONS
parameter_list|(
name|P
parameter_list|)
value|} }
end_define

begin_comment
comment|/* end groan */
end_comment

begin_comment
comment|/*  * NAME:  tp_newsocket()  *  * CALLED FROM:  *  tp_input() on incoming CR, when a socket w/ the called suffix  * is awaiting a  connection request  *  * FUNCTION and ARGUMENTS:  *  Create a new socket structure, attach to it a new transport pcb,  *  using a copy of the net level pcb for the parent socket.  *  (so) is the parent socket.  *  (fname) is the foreign address (all that's used is the nsap portion)  *  * RETURN VALUE:  *  a new socket structure, being this end of the newly formed connection.  *  * SIDE EFFECTS:  *  Sets a few things in the tpcb and net level pcb  *  * NOTES:  */
end_comment

begin_function
specifier|static
name|struct
name|socket
modifier|*
name|tp_newsocket
parameter_list|(
name|so
parameter_list|,
name|fname
parameter_list|,
name|cons_channel
parameter_list|,
name|class_to_use
parameter_list|,
name|netservice
parameter_list|)
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|sockaddr
modifier|*
name|fname
decl_stmt|;
name|u_int
name|cons_channel
decl_stmt|;
name|u_char
name|class_to_use
decl_stmt|;
name|u_int
name|netservice
decl_stmt|;
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
name|sototpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
comment|/* old tpcb, needed below */
name|struct
name|tp_pcb
modifier|*
name|newtpcb
decl_stmt|;
comment|/*  	 * sonewconn() gets a new socket structure, 	 * a new lower layer pcb and a new tpcb, 	 * but the pcbs are unnamed (not bound) 	 */
name|IFTRACE
argument_list|(
argument|D_NEWSOCK
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"newsock: listg_so, _tpcb, so_head"
argument_list|,
name|so
argument_list|,
name|tpcb
argument_list|,
name|so
operator|->
name|so_head
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
operator|(
name|so
operator|=
name|sonewconn
argument_list|(
name|so
argument_list|,
name|SS_ISCONFIRMING
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
condition|)
return|return
name|so
return|;
name|IFTRACE
argument_list|(
argument|D_NEWSOCK
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTmisc
argument_list|,
literal|"newsock: after newconn so, so_head"
argument_list|,
name|so
argument_list|,
name|so
operator|->
name|so_head
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|IFDEBUG
argument_list|(
name|D_NEWSOCK
argument_list|)
name|printf
argument_list|(
literal|"tp_newsocket(channel 0x%x)  after sonewconn so 0x%x \n"
argument_list|,
name|cons_channel
argument_list|,
name|so
argument_list|)
decl_stmt|;
name|dump_addr
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|{
name|struct
name|socket
modifier|*
name|t
decl_stmt|,
modifier|*
name|head
decl_stmt|;
name|head
operator|=
name|so
operator|->
name|so_head
expr_stmt|;
name|t
operator|=
name|so
expr_stmt|;
name|printf
argument_list|(
literal|"so 0x%x so_head 0x%x so_q0 0x%x, q0len %d\n"
argument_list|,
name|t
argument_list|,
name|t
operator|->
name|so_head
argument_list|,
name|t
operator|->
name|so_q0
argument_list|,
name|t
operator|->
name|so_q0len
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|t
operator|=
name|t
operator|->
name|so_q0
operator|)
operator|&&
name|t
operator|!=
name|so
operator|&&
name|t
operator|!=
name|head
condition|)
name|printf
argument_list|(
literal|"so 0x%x so_head 0x%x so_q0 0x%x, q0len %d\n"
argument_list|,
name|t
argument_list|,
name|t
operator|->
name|so_head
argument_list|,
name|t
operator|->
name|so_q0
argument_list|,
name|t
operator|->
name|so_q0len
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
comment|/*  	 * before we clobber the old tpcb ptr, get these items from the parent pcb  	 */
name|newtpcb
init|=
name|sototpcb
argument_list|(
name|so
argument_list|)
decl_stmt|;
name|newtpcb
operator|->
name|_tp_param
operator|=
name|tpcb
operator|->
name|_tp_param
expr_stmt|;
name|newtpcb
operator|->
name|tp_flags
operator|=
name|tpcb
operator|->
name|tp_flags
expr_stmt|;
name|newtpcb
operator|->
name|tp_lcredit
operator|=
name|tpcb
operator|->
name|tp_lcredit
expr_stmt|;
name|newtpcb
operator|->
name|tp_l_tpdusize
operator|=
name|tpcb
operator|->
name|tp_l_tpdusize
expr_stmt|;
name|newtpcb
operator|->
name|tp_lsuffixlen
operator|=
name|tpcb
operator|->
name|tp_lsuffixlen
expr_stmt|;
name|bcopy
argument_list|(
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|newtpcb
operator|->
name|tp_lsuffix
argument_list|,
name|newtpcb
operator|->
name|tp_lsuffixlen
argument_list|)
expr_stmt|;
name|soreserve
argument_list|(
name|so
argument_list|,
operator|(
name|u_long
operator|)
name|tpcb
operator|->
name|tp_winsize
argument_list|,
operator|(
name|u_long
operator|)
name|tpcb
operator|->
name|tp_winsize
argument_list|)
expr_stmt|;
if|if
condition|(
comment|/* old */
name|tpcb
operator|->
name|tp_ucddata
condition|)
block|{
comment|/*  		 * These data are the connect- , confirm- or disconnect- data. 		 */
name|struct
name|mbuf
modifier|*
name|conndata
decl_stmt|;
name|conndata
operator|=
name|m_copy
argument_list|(
name|tpcb
operator|->
name|tp_ucddata
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|)
name|M_COPYALL
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|dump_mbuf
argument_list|(
name|conndata
argument_list|,
literal|"conndata after mcopy"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|newtpcb
operator|->
name|tp_ucddata
init|=
name|conndata
decl_stmt|;
block|}
name|tpcb
operator|=
name|newtpcb
expr_stmt|;
name|tpcb
operator|->
name|tp_state
operator|=
name|TP_LISTENING
expr_stmt|;
name|tpcb
operator|->
name|tp_class
operator|=
name|class_to_use
expr_stmt|;
name|tpcb
operator|->
name|tp_netservice
operator|=
name|netservice
expr_stmt|;
name|ASSERT
argument_list|(
name|fname
operator|!=
literal|0
argument_list|)
expr_stmt|;
comment|/* just checking */
if|if
condition|(
name|fname
condition|)
block|{
comment|/* 		 *	tp_route_to takes its address argument in the form of an mbuf. 		 */
name|struct
name|mbuf
modifier|*
name|m
decl_stmt|;
name|int
name|err
decl_stmt|;
name|MGET
argument_list|(
name|m
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_SONAME
argument_list|)
expr_stmt|;
comment|/* mbuf type used is confusing */
if|if
condition|(
name|m
condition|)
block|{
comment|/* 			 * this seems a bit grotesque, but tp_route_to expects 			 * an mbuf * instead of simply a sockaddr; it calls the ll 			 * pcb_connect, which expects the name/addr in an mbuf as well. 			 * sigh. 			 */
name|bcopy
argument_list|(
operator|(
name|caddr_t
operator|)
name|fname
argument_list|,
name|mtod
argument_list|(
name|m
argument_list|,
name|caddr_t
argument_list|)
argument_list|,
name|fname
operator|->
name|sa_len
argument_list|)
expr_stmt|;
name|m
operator|->
name|m_len
operator|=
name|fname
operator|->
name|sa_len
expr_stmt|;
comment|/* grot  : have to say the kernel can override params in 			 * the passive open case 			 */
name|tpcb
operator|->
name|tp_dont_change_params
operator|=
literal|0
expr_stmt|;
name|err
operator|=
name|tp_route_to
argument_list|(
name|m
argument_list|,
name|tpcb
argument_list|,
name|cons_channel
argument_list|)
expr_stmt|;
name|m_free
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|err
condition|)
goto|goto
name|ok
goto|;
block|}
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_route_to FAILED! detaching tpcb 0x%x, so 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|so
argument_list|)
expr_stmt|;
name|ENDDEBUG
argument_list|(
argument|void
argument_list|)
name|tp_detach
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|ok
label|:
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_newsocket returning so 0x%x, sototpcb(so) 0x%x\n"
argument_list|,
name|so
argument_list|,
name|sototpcb
argument_list|(
name|so
argument_list|)
argument_list|)
expr_stmt|;
name|ENDDEBUG
return|return
name|so
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CONS
end_ifndef

begin_macro
name|tpcons_output
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
endif|!CONS
end_endif

begin_comment
comment|/*   * NAME: 	tp_input()  *  * CALLED FROM:  *  net layer input routine  *  * FUNCTION and ARGUMENTS:  *  Process an incoming TPDU (m), finding the associated tpcb if there  *  is one. Create the appropriate type of event and call the driver.  *  (faddr) and (laddr) are the foreign and local addresses.  *   * 	When tp_input() is called we KNOW that the ENTIRE TP HEADER  * 	has been m_pullup-ed.  *  * RETURN VALUE: Nada  *    * SIDE EFFECTS:  *	When using COSNS it may affect the state of the net-level pcb  *  * NOTE:  *  The initial value of acktime is 2 so that we will never  *  have a 0 value for tp_peer_acktime.  It gets used in the  *  computation of the retransmission timer value, and so it  *  mustn't be zero.  *  2 seems like a reasonable minimum.  */
end_comment

begin_decl_stmt
name|ProtoHook
name|tp_input
argument_list|(
name|m
argument_list|,
name|faddr
argument_list|,
name|laddr
argument_list|,
name|cons_channel
argument_list|,
name|dgout_routine
argument_list|,
name|ce_bit
argument_list|)
decl|register	struct
name|mbuf
modifier|*
name|m
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr
modifier|*
name|faddr
decl_stmt|,
modifier|*
name|laddr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* NSAP addresses */
end_comment

begin_decl_stmt
name|u_int
name|cons_channel
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|dgout_routine
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|ce_bit
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|tpcb
init|=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
literal|0
decl_stmt|;
specifier|register
name|struct
name|tpdu
modifier|*
name|hdr
decl_stmt|;
name|struct
name|socket
modifier|*
name|so
decl_stmt|;
name|struct
name|tp_event
name|e
decl_stmt|;
name|int
name|error
init|=
literal|0
decl_stmt|;
name|unsigned
name|dutype
decl_stmt|;
name|u_short
name|dref
decl_stmt|,
name|sref
init|=
literal|0
decl_stmt|,
name|acktime
init|=
literal|2
decl_stmt|,
name|subseq
init|=
literal|0
decl_stmt|;
comment|/*VAX*/
name|u_char
name|preferred_class
init|=
literal|0
decl_stmt|,
name|class_to_use
init|=
literal|0
decl_stmt|;
name|u_char
name|opt
decl_stmt|,
name|dusize
init|=
name|TP_DFL_TPDUSIZE
decl_stmt|,
name|addlopt
init|=
literal|0
decl_stmt|,
name|version
decl_stmt|;
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
name|u_char
name|perf_meas
decl_stmt|;
endif|#
directive|endif
endif|TP_PERF_MEAS
name|u_char
name|fsufxlen
init|=
literal|0
decl_stmt|,
name|lsufxlen
init|=
literal|0
decl_stmt|,
name|intercepted
init|=
literal|0
decl_stmt|;
name|caddr_t
name|fsufxloc
init|=
literal|0
decl_stmt|,
name|lsufxloc
init|=
literal|0
decl_stmt|;
name|int
name|tpdu_len
init|=
literal|0
decl_stmt|;
name|u_int
name|takes_data
init|=
name|FALSE
decl_stmt|;
name|u_int
name|fcc_present
init|=
name|FALSE
decl_stmt|;
name|int
name|errlen
init|=
literal|0
decl_stmt|;
name|struct
name|tp_conn_param
name|tpp
decl_stmt|;
name|int
name|tpcons_output
parameter_list|()
function_decl|;
name|again
label|:
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tpdu
operator|*
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
name|GET_CUR_TIME
argument_list|(
operator|&
name|e
operator|.
name|e_time
argument_list|)
expr_stmt|;
name|perf_meas
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
endif|TP_PERF_MEAS
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_input(0x%x, ... 0x%x)\n"
argument_list|,
name|m
argument_list|,
name|cons_channel
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/*  	 * get the actual tpdu length - necessary for monitoring 	 * and for checksumming 	 *  	 * Also, maybe measure the mbuf chain lengths and sizes. 	 */
block|{
specifier|register
name|struct
name|mbuf
modifier|*
name|n
init|=
name|m
decl_stmt|;
ifdef|#
directive|ifdef
name|ARGO_DEBUG
name|int
name|chain_length
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
endif|ARGO_DEBUG
for|for
control|(
init|;
condition|;
control|)
block|{
name|tpdu_len
operator|+=
name|n
operator|->
name|m_len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_MBUF_MEAS
argument_list|)
if|if
condition|(
name|n
operator|->
name|m_flags
operator|&
name|M_EXT
condition|)
block|{
name|IncStat
argument_list|(
name|ts_mb_cluster
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|IncStat
argument_list|(
name|ts_mb_small
argument_list|)
expr_stmt|;
block|}
name|chain_length
operator|++
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
name|n
operator|->
name|m_next
operator|==
name|MNULL
condition|)
block|{
break|break;
block|}
name|n
operator|=
name|n
operator|->
name|m_next
expr_stmt|;
block|}
name|IFDEBUG
argument_list|(
argument|D_MBUF_MEAS
argument_list|)
if|if
condition|(
name|chain_length
operator|>
literal|16
condition|)
name|chain_length
operator|=
literal|0
expr_stmt|;
comment|/* zero used for anything> 16 */
name|tp_stat
operator|.
name|ts_mb_len_distr
index|[
name|chain_length
index|]
operator|++
expr_stmt|;
name|ENDDEBUG
block|}
name|IFTRACE
argument_list|(
argument|D_TPINPUT
argument_list|)
name|tptraceTPCB
argument_list|(
name|TPPTtpduin
argument_list|,
name|hdr
operator|->
name|tpdu_type
argument_list|,
name|hdr
argument_list|,
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
argument_list|,
name|tpdu_len
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|dref
init|=
name|ntohs
argument_list|(
operator|(
name|short
operator|)
name|hdr
operator|->
name|tpdu_dref
argument_list|)
decl_stmt|;
name|sref
operator|=
name|ntohs
argument_list|(
operator|(
name|short
operator|)
name|hdr
operator|->
name|tpdu_sref
argument_list|)
expr_stmt|;
name|dutype
operator|=
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_type
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"input: dutype 0x%x cons_channel 0x%x dref 0x%x\n"
argument_list|,
name|dutype
argument_list|,
name|cons_channel
argument_list|,
name|dref
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"input: dref 0x%x sref 0x%x\n"
argument_list|,
name|dref
argument_list|,
name|sref
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_TPINPUT
parameter_list|)
function_decl|tptrace
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"channel dutype dref "
operator|,
function_decl|cons_channel
operator|,
function_decl|dutype
operator|,
function_decl|dref
operator|,
function_decl|0
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDTRACE
end_macro

begin_ifdef
ifdef|#
directive|ifdef
name|ARGO_DEBUG
end_ifdef

begin_if
if|if
condition|(
operator|(
name|dutype
operator|<
name|TP_MIN_TPDUTYPE
operator|)
operator|||
operator|(
name|dutype
operator|>
name|TP_MAX_TPDUTYPE
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"BAD dutype! 0x%x, channel 0x%x dref 0x%x\n"
argument_list|,
name|dutype
argument_list|,
name|cons_channel
argument_list|,
name|dref
argument_list|)
expr_stmt|;
name|dump_buf
argument_list|(
name|m
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|mbuf
argument_list|)
argument_list|)
expr_stmt|;
name|IncStat
argument_list|(
name|ts_inv_dutype
argument_list|)
expr_stmt|;
goto|goto
name|discard
goto|;
block|}
end_if

begin_endif
endif|#
directive|endif
endif|ARGO_DEBUG
end_endif

begin_expr_stmt
name|CHECK
argument_list|(
operator|(
name|dutype
operator|<
name|TP_MIN_TPDUTYPE
operator|||
name|dutype
operator|>
name|TP_MAX_TPDUTYPE
operator|)
argument_list|,
name|E_TP_INV_TPDU
argument_list|,
name|ts_inv_dutype
argument_list|,
name|respond
argument_list|,
literal|2
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/* unfortunately we can't take the address of the tpdu_type field, 		 * since it's a bit field - so we just use the constant offset 2 		 */
end_comment

begin_comment
comment|/* Now this isn't very neat but since you locate a pcb one way 	 * at the beginning of connection establishment, and by 	 * the dref for each tpdu after that, we have to treat CRs differently 	 */
end_comment

begin_if
if|if
condition|(
name|dutype
operator|==
name|CR_TPDU_type
condition|)
block|{
name|u_char
name|alt_classes
init|=
literal|0
decl_stmt|;
name|preferred_class
operator|=
literal|1
operator|<<
name|hdr
operator|->
name|tpdu_CRclass
expr_stmt|;
name|opt
operator|=
name|hdr
operator|->
name|tpdu_CRoptions
expr_stmt|;
name|WHILE_OPTIONS
argument_list|(
argument|P
argument_list|,
argument|hdr
argument_list|,
literal|1
argument_list|)
comment|/* { */
switch|switch
condition|(
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_code
condition|)
block|{
case|case
name|TPP_tpdu_size
case|:
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_char
argument_list|,
name|dusize
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CR dusize 0x%x\n"
argument_list|,
name|dusize
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* COS tests: NBS IA (Dec. 1987) Sec. 4.5.2.1 */
if|if
condition|(
name|dusize
operator|<
name|TP_MIN_TPDUSIZE
operator|||
name|dusize
operator|>
name|TP_MAX_TPDUSIZE
condition|)
name|dusize
operator|=
name|TP_DFL_TPDUSIZE
expr_stmt|;
break|break;
case|case
name|TPP_addl_opt
case|:
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_char
argument_list|,
name|addlopt
argument_list|)
expr_stmt|;
break|break;
case|case
name|TPP_calling_sufx
case|:
comment|/* could use vb_getval, but we want to save the loc& len 				 * for later use 				 */
name|fsufxloc
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_val
expr_stmt|;
name|fsufxlen
operator|=
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CR fsufx:"
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|fsufxlen
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" 0x%x. "
argument_list|,
operator|*
operator|(
call|(
name|caddr_t
call|)
argument_list|(
name|fsufxloc
operator|+
name|j
argument_list|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
break|break;
case|case
name|TPP_called_sufx
case|:
comment|/* could use vb_getval, but we want to save the loc& len 				 * for later use 				 */
name|lsufxloc
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_val
expr_stmt|;
name|lsufxlen
operator|=
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CR lsufx:"
argument_list|)
expr_stmt|;
block|{
specifier|register
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lsufxlen
condition|;
name|j
operator|++
control|)
block|{
name|printf
argument_list|(
literal|" 0x%x. "
argument_list|,
operator|*
operator|(
operator|(
name|u_char
operator|*
operator|)
operator|(
name|lsufxloc
operator|+
name|j
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|ENDDEBUG
break|break;
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
case|case
name|TPP_perf_meas
case|:
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_char
argument_list|,
name|perf_meas
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
endif|TP_PERF_MEAS
case|case
name|TPP_vers
case|:
comment|/* not in class 0; 1 octet; in CR_TPDU only */
comment|/* COS tests says if version wrong, use default version!?XXX */
name|CHECK
argument_list|(
operator|(
name|vbval
argument_list|(
name|P
argument_list|,
name|u_char
argument_list|)
operator|!=
name|TP_VERSION
operator|)
argument_list|,
name|E_TP_INV_PVAL
argument_list|,
name|ts_inv_pval
argument_list|,
name|setversion
argument_list|,
operator|(
literal|1
operator|+
operator|(
name|caddr_t
operator|)
operator|&
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_val
operator|-
operator|(
name|caddr_t
operator|)
name|hdr
operator|)
argument_list|)
expr_stmt|;
name|setversion
label|:
name|version
operator|=
name|vbval
argument_list|(
name|P
argument_list|,
name|u_char
argument_list|)
expr_stmt|;
break|break;
case|case
name|TPP_acktime
case|:
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_short
argument_list|,
name|acktime
argument_list|)
expr_stmt|;
name|acktime
operator|=
name|ntohs
argument_list|(
name|acktime
argument_list|)
expr_stmt|;
name|acktime
operator|=
name|acktime
operator|/
literal|500
expr_stmt|;
comment|/* convert to slowtimo ticks */
if|if
condition|(
operator|(
name|short
operator|)
name|acktime
operator|<=
literal|0
condition|)
name|acktime
operator|=
literal|2
expr_stmt|;
comment|/* don't allow a bad peer to screw us up */
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CR acktime 0x%x\n"
argument_list|,
name|acktime
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
case|case
name|TPP_alt_class
case|:
block|{
name|u_char
modifier|*
name|aclass
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|static
name|u_char
name|bad_alt_classes
index|[
literal|5
index|]
init|=
block|{
operator|~
literal|0
block|,
operator|~
literal|3
block|,
operator|~
literal|5
block|,
operator|~
literal|0xf
block|,
operator|~
literal|0x1f
block|}
decl_stmt|;
name|aclass
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
operator|(
operator|(
operator|(
expr|struct
name|tp_vbp
operator|*
operator|)
name|P
operator|)
operator|->
name|tpv_val
operator|)
expr_stmt|;
for|for
control|(
name|i
operator|=
operator|(
operator|(
expr|struct
name|tp_vbp
operator|*
operator|)
name|P
operator|)
operator|->
name|tpv_len
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|alt_classes
operator||=
operator|(
literal|1
operator|<<
operator|(
operator|(
operator|*
name|aclass
operator|++
operator|)
operator|>>
literal|4
operator|)
operator|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
operator|(
name|bad_alt_classes
index|[
name|hdr
operator|->
name|tpdu_CRclass
index|]
operator|&
name|alt_classes
operator|)
argument_list|,
name|E_TP_INV_PVAL
argument_list|,
name|ts_inv_aclass
argument_list|,
name|respond
argument_list|,
operator|(
operator|(
name|caddr_t
operator|)
name|aclass
operator|)
operator|-
operator|(
name|caddr_t
operator|)
name|hdr
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"alt_classes 0x%x\n"
argument_list|,
name|alt_classes
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
break|break;
case|case
name|TPP_security
case|:
case|case
name|TPP_residER
case|:
case|case
name|TPP_priority
case|:
case|case
name|TPP_transdelay
case|:
case|case
name|TPP_throughput
case|:
case|case
name|TPP_addl_info
case|:
case|case
name|TPP_subseq
case|:
default|default:
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"param ignored CR_TPDU code= 0x%x\n"
argument_list|,
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_code
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
parameter_list|(
name|ts_param_ignored
parameter_list|)
function_decl|;
break|break;
case|case
name|TPP_checksum
case|:
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CR before cksum\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|CHECK
argument_list|(
name|iso_check_csum
argument_list|(
name|m
argument_list|,
name|tpdu_len
argument_list|)
argument_list|,
name|E_TP_INV_PVAL
argument_list|,
name|ts_bad_csum
argument_list|,
name|discard
argument_list|,
literal|0
argument_list|)
name|IFDEBUG
argument_list|(
name|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CR before cksum\n"
argument_list|)
decl_stmt|;
name|ENDDEBUG
break|break;
block|}
comment|/* } */
name|END_WHILE_OPTIONS
argument_list|(
argument|P
argument_list|)
if|if
condition|(
name|lsufxlen
operator|==
literal|0
condition|)
block|{
comment|/* can't look for a tpcb w/o any called sufx */
name|error
operator|=
name|E_TP_LENGTH_INVAL
expr_stmt|;
name|IncStat
argument_list|(
name|ts_inv_sufx
argument_list|)
expr_stmt|;
goto|goto
name|respond
goto|;
block|}
else|else
block|{
specifier|register
name|struct
name|tp_pcb
modifier|*
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|tp_intercepts
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|tp_nextlisten
control|)
block|{
if|if
condition|(
name|laddr
operator|->
name|sa_family
operator|!=
name|t
operator|->
name|tp_nlproto
operator|->
name|nlp_afamily
condition|)
continue|continue;
if|if
condition|(
call|(
modifier|*
name|t
operator|->
name|tp_nlproto
operator|->
name|nlp_cmpnetaddr
call|)
argument_list|(
name|t
operator|->
name|tp_npcb
argument_list|,
name|laddr
argument_list|,
name|TP_LOCAL
argument_list|)
condition|)
block|{
name|intercepted
operator|=
literal|1
expr_stmt|;
goto|goto
name|check_duplicate_cr
goto|;
block|}
block|}
for|for
control|(
name|t
operator|=
name|tp_listeners
init|;
name|t
condition|;
name|t
operator|=
name|t
operator|->
name|tp_nextlisten
control|)
if|if
condition|(
name|bcmp
argument_list|(
name|lsufxloc
argument_list|,
name|t
operator|->
name|tp_lsuffix
argument_list|,
name|lsufxlen
argument_list|)
operator|==
literal|0
operator|&&
name|laddr
operator|->
name|sa_family
operator|==
name|t
operator|->
name|tp_nlproto
operator|->
name|nlp_afamily
condition|)
break|break;
name|CHECK
argument_list|(
argument|t ==
literal|0
argument_list|,
argument|E_TP_NO_SESSION
argument_list|,
argument|ts_inv_sufx
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+
literal|2
argument|+ (caddr_t)&hdr->_tpduf - (caddr_t)hdr)
argument_list|)
comment|/* _tpduf is the fixed part; add 2 to get the dref bits of  				 * the fixed part (can't take the address of a bit field)  				 */
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"checking if dup CR\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|check_duplicate_cr
range|:
name|tpcb
operator|=
name|t
decl_stmt|;
for|for
control|(
name|t
operator|=
name|tpcb
operator|->
name|tp_next
init|;
name|t
operator|!=
name|tpcb
condition|;
name|t
operator|=
name|t
operator|->
name|tp_next
control|)
block|{
if|if
condition|(
name|sref
operator|!=
name|t
operator|->
name|tp_fref
condition|)
continue|continue;
if|if
condition|(
call|(
modifier|*
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_cmpnetaddr
call|)
argument_list|(
name|t
operator|->
name|tp_npcb
argument_list|,
name|faddr
argument_list|,
name|TP_FOREIGN
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"duplicate CR discarded\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
goto|goto
name|discard
goto|;
block|}
block|}
name|IFTRACE
argument_list|(
argument|D_TPINPUT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_input: tpcb *lsufxloc tpstate"
argument_list|,
name|tpcb
argument_list|,
operator|*
name|lsufxloc
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
block|}
comment|/*  		 * WE HAVE A TPCB  		 * already know that the classes in the CR match at least 		 * one class implemented, but we don't know yet if they 		 * include any classes permitted by this server. 		 */
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"HAVE A TPCB 1: 0x%x\n"
argument_list|,
name|tpcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IFDEBUG
parameter_list|(
name|D_CONN
parameter_list|)
function_decl|printf
parameter_list|(
function_decl|"CR: bef CHKS: flags 0x%x class_to_use 0x%x alt 0x%x opt 0x%x tp_class 0x%x\n"
operator|,
function_decl|tpcb->tp_flags
operator|,
function_decl|class_to_use
operator|,
function_decl|alt_classes
operator|,
function_decl|opt
operator|,
function_decl|tpcb->tp_class
block|)
empty_stmt|;
end_if

begin_decl_stmt
name|ENDDEBUG
comment|/* tpcb->tp_class doesn't include any classes not implemented  */
name|class_to_use
init|=
operator|(
name|preferred_class
operator|&
name|tpcb
operator|->
name|tp_class
operator|)
decl_stmt|;
end_decl_stmt

begin_if
if|if
condition|(
operator|(
name|class_to_use
operator|=
name|preferred_class
operator|&
name|tpcb
operator|->
name|tp_class
operator|)
operator|==
literal|0
condition|)
name|class_to_use
operator|=
name|alt_classes
operator|&
name|tpcb
operator|->
name|tp_class
expr_stmt|;
end_if

begin_expr_stmt
name|class_to_use
operator|=
literal|1
operator|<<
name|tp_mask_to_num
argument_list|(
name|class_to_use
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|tpp
operator|=
name|tpcb
operator|->
name|_tp_param
expr_stmt|;
name|tpp
operator|.
name|p_class
operator|=
name|class_to_use
expr_stmt|;
name|tpp
operator|.
name|p_tpdusize
operator|=
name|dusize
expr_stmt|;
name|tpp
operator|.
name|p_xtd_format
operator|=
operator|(
name|opt
operator|&
name|TPO_XTD_FMT
operator|)
operator|==
name|TPO_XTD_FMT
expr_stmt|;
name|tpp
operator|.
name|p_xpd_service
operator|=
operator|(
name|addlopt
operator|&
name|TPAO_USE_TXPD
operator|)
operator|==
name|TPAO_USE_TXPD
expr_stmt|;
name|tpp
operator|.
name|p_use_checksum
operator|=
operator|(
name|tpp
operator|.
name|p_class
operator|==
name|TP_CLASS_0
operator|)
condition|?
literal|0
else|:
operator|(
name|addlopt
operator|&
name|TPAO_NO_CSUM
operator|)
operator|==
literal|0
expr_stmt|;
name|tpp
operator|.
name|p_version
operator|=
name|version
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|tpp
operator|.
name|p_use_efc
operator|=
operator|(
name|opt
operator|&
name|TPO_USE_EFC
operator|)
operator|==
name|TPO_USE_EFC
expr_stmt|;
name|tpp
operator|.
name|p_use_nxpd
operator|=
operator|(
name|addlopt
operator|&
name|TPAO_USE_NXPD
operator|)
operator|==
name|TPAO_USE_NXPD
expr_stmt|;
name|tpp
operator|.
name|p_use_rcc
operator|=
operator|(
name|addlopt
operator|&
name|TPAO_USE_RCC
operator|)
operator|==
name|TPAO_USE_RCC
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|CHECK
argument_list|(
argument|tp_consistency(tpcb,
literal|0
comment|/* not force or strict */
argument|,&tpp) !=
literal|0
argument_list|,
argument|E_TP_NEGOT_FAILED
argument_list|,
argument|ts_negotfailed
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+
literal|2
argument|+ (caddr_t)&hdr->_tpdufr.CRCC - (caddr_t)hdr)
comment|/* ^ more or less the location of class */
argument_list|)
block|}
end_block

begin_macro
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
end_macro

begin_expr_stmt
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"after 1 consist class_to_use class, out, tpconsout"
argument_list|,
name|class_to_use
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|dgout_routine
argument_list|,
name|tpcons_output
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDTRACE
name|CHECK
argument_list|(
operator|(
operator|(
name|class_to_use
operator|==
name|TP_CLASS_0
operator|)
operator|&&
operator|(
name|dgout_routine
operator|!=
name|tpcons_output
operator|)
operator|)
argument_list|,
name|E_TP_NEGOT_FAILED
argument_list|,
name|ts_negotfailed
argument_list|,
name|respond
argument_list|,
operator|(
literal|1
operator|+
literal|2
operator|+
operator|(
name|caddr_t
operator|)
operator|&
name|hdr
operator|->
name|_tpdufr
operator|.
name|CRCC
operator|-
operator|(
name|caddr_t
operator|)
name|hdr
operator|)
comment|/* ^ more or less the location of class */
argument_list|)
name|IFDEBUG
argument_list|(
name|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"CR: after CRCCCHECKS: tpcb 0x%x, flags 0x%x\n"
argument_list|,
name|tpcb
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|ENDDEBUG
name|takes_data
init|=
name|TRUE
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|e
operator|.
name|ATTR
argument_list|(
name|CR_TPDU
argument_list|)
operator|.
name|e_cdt
operator|=
name|hdr
operator|->
name|tpdu_CRcdt
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|e
operator|.
name|ev_number
operator|=
name|CR_TPDU
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|so
operator|=
name|tpcb
operator|->
name|tp_sock
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|so
operator|->
name|so_options
operator|&
name|SO_ACCEPTCONN
condition|)
block|{
name|struct
name|tp_pcb
modifier|*
name|parent_tpcb
init|=
name|tpcb
decl_stmt|;
comment|/*  			 * Create a socket, tpcb, ll pcb, etc.  			 * for this newborn connection, and fill in all the values.  			 */
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"abt to call tp_newsocket(0x%x, 0x%x, 0x%x, 0x%x)\n"
argument_list|,
name|so
argument_list|,
name|laddr
argument_list|,
name|faddr
argument_list|,
name|cons_channel
argument_list|)
expr_stmt|;
name|ENDDEBUG
if|if
condition|(
operator|(
name|so
operator|=
name|tp_newsocket
argument_list|(
name|so
argument_list|,
name|faddr
argument_list|,
name|cons_channel
argument_list|,
name|class_to_use
argument_list|,
operator|(
operator|(
name|tpcb
operator|->
name|tp_netservice
operator|==
name|IN_CLNS
operator|)
condition|?
name|IN_CLNS
else|:
operator|(
name|dgout_routine
operator|==
name|tpcons_output
operator|)
condition|?
name|ISO_CONS
else|:
name|ISO_CLNS
operator|)
argument_list|)
operator|)
operator|==
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
condition|)
block|{
comment|/* note - even if netservice is IN_CLNS, as far as 				 * the tp entity is concerned, the only differences 				 * are CO vs CL 				 */
name|IFDEBUG
argument_list|(
argument|D_CONN
argument_list|)
name|printf
argument_list|(
literal|"tp_newsocket returns 0\n"
argument_list|)
expr_stmt|;
name|ENDDEBUG
goto|goto
name|discard
goto|;
block|}
name|tpcb
operator|=
name|sototpcb
argument_list|(
name|so
argument_list|)
expr_stmt|;
name|insque
argument_list|(
name|tpcb
argument_list|,
name|parent_tpcb
argument_list|)
expr_stmt|;
comment|/* 			 * Stash the addresses in the net level pcb  			 * kind of like a pcbconnect() but don't need 			 * or want all those checks. 			 */
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_putnetaddr
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|faddr
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_putnetaddr
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|laddr
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
comment|/* stash the f suffix in the new tpcb */
name|bcopy
argument_list|(
name|fsufxloc
argument_list|,
name|tpcb
operator|->
name|tp_fsuffix
argument_list|,
name|fsufxlen
argument_list|)
expr_stmt|;
comment|/* l suffix is already there, unless this is an intercept case */
if|if
condition|(
name|intercepted
condition|)
name|bcopy
argument_list|(
name|lsufxloc
argument_list|,
name|tpcb
operator|->
name|tp_lsuffix
argument_list|,
name|lsufxlen
argument_list|)
expr_stmt|;
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_putsufx
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|fsufxloc
argument_list|,
name|fsufxlen
argument_list|,
name|TP_FOREIGN
argument_list|)
expr_stmt|;
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_putsufx
call|)
argument_list|(
name|so
operator|->
name|so_pcb
argument_list|,
name|lsufxloc
argument_list|,
name|lsufxlen
argument_list|,
name|TP_LOCAL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TP_PERF_MEAS
if|if
condition|(
name|tpcb
operator|->
name|tp_perf_on
operator|=
name|perf_meas
condition|)
block|{
comment|/* assignment */
comment|/* ok, let's create an mbuf for stashing the 				 * statistics if one doesn't already exist  				 */
operator|(
name|void
operator|)
name|tp_setup_perf
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|TP_PERF_MEAS
name|tpcb
operator|->
name|tp_fref
operator|=
name|sref
expr_stmt|;
comment|/* We've already checked for consistency with the options  			 * set in tpp,  but we couldn't set them earlier because  			 * we didn't want to change options in the LISTENING tpcb. 			 * Now we set the options in the new socket's tpcb. 			 */
operator|(
name|void
operator|)
name|tp_consistency
argument_list|(
name|tpcb
argument_list|,
name|TP_FORCE
argument_list|,
operator|&
name|tpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_use_checksum
condition|)
name|IncStat
argument_list|(
name|ts_csum_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_xpd_service
condition|)
name|IncStat
argument_list|(
name|ts_use_txpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
name|IncStat
argument_list|(
name|ts_xtd_fmt
argument_list|)
expr_stmt|;
comment|/* 			 * Get the maximum transmission unit from the lower layer(s) 			 * so we can negotiate a reasonable max TPDU size. 			 */
call|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_mtu
call|)
argument_list|(
name|so
argument_list|,
name|so
operator|->
name|so_pcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_tpdusize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tpcb
operator|->
name|tp_peer_acktime
operator|=
name|acktime
expr_stmt|;
comment|/*  			 * The following kludge is used to test retransmissions and  			 * timeout during connection establishment. 			 */
name|IFDEBUG
argument_list|(
argument|D_ZDREF
argument_list|)
name|IncStat
argument_list|(
name|ts_zdebug
argument_list|)
expr_stmt|;
comment|/*tpcb->tp_fref = 0;*/
name|ENDDEBUG
block|}
end_if

begin_expr_stmt
name|IncStat
argument_list|(
name|ts_CR_rcvd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_cebit_off
condition|)
block|{
name|tpcb
operator|->
name|tp_win_recv
operator|=
name|tp_start_win
operator|<<
literal|8
expr_stmt|;
name|tpcb
operator|->
name|tp_cong_sample
operator|.
name|cs_size
operator|=
literal|0
expr_stmt|;
name|LOCAL_CREDIT
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|CONG_INIT_SAMPLE
argument_list|(
name|tpcb
argument_list|)
expr_stmt|;
name|CONG_UPDATE_SAMPLE
argument_list|(
name|tpcb
argument_list|,
name|ce_bit
argument_list|)
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|tpcb
operator|->
name|tp_ackrcvd
operator|=
literal|0
expr_stmt|;
end_expr_stmt

begin_if
unit|} else
if|if
condition|(
name|dutype
operator|==
name|ER_TPDU_type
condition|)
block|{
comment|/*  		 * ER TPDUs have to be recognized separately 		 * because they don't necessarily have a tpcb 		 * with them and we don't want err out looking for such 		 * a beast. 		 * We could put a bunch of little kludges in the  		 * next section of code so it would avoid references to tpcb 		 * if dutype == ER_TPDU_type but we don't want code for ERs to 		 * mess up code for data transfer. 		 */
name|IncStat
argument_list|(
name|ts_ER_rcvd
argument_list|)
expr_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|ER_TPDU
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|ER_TPDU
argument_list|)
operator|.
name|e_reason
operator|=
operator|(
name|u_char
operator|)
name|hdr
operator|->
name|tpdu_ERreason
expr_stmt|;
name|takes_data
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* tpdu type is CC, XPD, XAK, GR, AK, DR, DC, or DT */
comment|/* In the next 4 checks, 		 * _tpduf is the fixed part; add 2 to get the dref bits of  		 * the fixed part (can't take the address of a bit field)  		 */
if|if
condition|(
name|cons_channel
condition|)
block|{
if|#
directive|if
name|NARGOXTWENTYFIVE
operator|>
literal|0
specifier|extern
name|struct
name|tp_pcb
modifier|*
name|cons_chan_to_tpcb
parameter_list|()
function_decl|;
name|tpcb
operator|=
name|cons_chan_to_tpcb
argument_list|(
name|cons_channel
argument_list|)
expr_stmt|;
comment|/* Problem:  We may have a legit 			 * error situation yet we may or may not have  			 * a correspondence between the tpcb and the vc, 			 * e.g., TP4cr--><no dice, respond w/ DR on vc> 			 *<---  DR 			 * Now it's up to TP to look at the tpdu and do one of: 			 * confirm(dgm)(cr),  confirm(circuit)(cr), reject(cr), or 			 * nothing, if the circuit is already open (any other tpdu).  			 * Sigh. 			 */
comment|/* I don't know about this error value */
name|CHECK
argument_list|(
argument|(tpcb == (struct tp_pcb *)
literal|0
argument|)
argument_list|,
argument|E_TP_NO_CR_ON_NC
argument_list|,
argument|ts_inv_dref
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+
literal|2
argument|+ (caddr_t)&hdr->_tpduf - (caddr_t)hdr)
argument_list|)
else|#
directive|else
name|printf
argument_list|(
literal|"tp_input(): X25 NOT CONFIGURED!!\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|NARGOXTWENTYFIVE> 0
block|}
else|else
block|{
name|CHECK
argument_list|(
argument|((int)dref<=
literal|0
argument||| dref>= N_TPREF)
argument_list|,
argument|E_TP_MISM_REFS
argument_list|,
argument|ts_inv_dref
argument_list|,
argument|nonx_dref
argument_list|,
argument|(
literal|1
argument|+
literal|2
argument|+ (caddr_t)&hdr->_tpduf - (caddr_t)hdr)
argument_list|)
name|CHECK
argument_list|(
argument|((tpcb = tp_ref[dref].tpr_pcb ) == (struct tp_pcb *)
literal|0
argument|)
argument_list|,
argument|E_TP_MISM_REFS
argument_list|,
argument|ts_inv_dref
argument_list|,
argument|nonx_dref
argument_list|,
argument|(
literal|1
argument|+
literal|2
argument|+ (caddr_t)&hdr->_tpduf - (caddr_t)hdr)
argument_list|)
name|CHECK
argument_list|(
argument|(tpcb->tp_refp->tpr_state == REF_FREE)
argument_list|,
argument|E_TP_MISM_REFS
argument_list|,
argument|ts_inv_dref
argument_list|,
argument|nonx_dref
argument_list|,
argument|(
literal|1
argument|+
literal|2
argument|+ (caddr_t)&hdr->_tpduf - (caddr_t)hdr)
argument_list|)
block|}
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"HAVE A TPCB 2: 0x%x\n"
argument_list|,
name|tpcb
argument_list|)
expr_stmt|;
name|ENDDEBUG
comment|/* causes a DR to be sent for CC; ER for all else */
name|CHECK
argument_list|(
operator|(
name|tpcb
operator|->
name|tp_refp
operator|->
name|tpr_state
operator|==
name|REF_FROZEN
operator|)
argument_list|,
operator|(
name|dutype
operator|==
name|CC_TPDU_type
condition|?
name|E_TP_NO_SESSION
else|:
name|E_TP_MISM_REFS
operator|)
argument_list|,
name|ts_inv_dref
argument_list|,
name|respond
argument_list|,
operator|(
literal|1
operator|+
literal|2
operator|+
operator|(
name|caddr_t
operator|)
operator|&
name|hdr
operator|->
name|_tpduf
operator|-
operator|(
name|caddr_t
operator|)
name|hdr
operator|)
argument_list|)
name|IFDEBUG
argument_list|(
name|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"state of dref %d ok, tpcb 0x%x\n"
argument_list|,
name|dref
argument_list|,
name|tpcb
argument_list|)
decl_stmt|;
name|ENDDEBUG
comment|/*  		 * At this point the state of the dref could be 		 * FROZEN: tpr_pcb == NULL,  has ( reference only) timers 		 *		   for example, DC may arrive after the close() has detached 		 *         the tpcb (e.g., if user turned off SO_LISTEN option) 		 * OPENING : a tpcb exists but no timers yet 		 * OPEN  : tpcb exists& timers are outstanding 		 */
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_cebit_off
condition|)
name|CONG_UPDATE_SAMPLE
argument_list|(
name|tpcb
argument_list|,
name|ce_bit
argument_list|)
expr_stmt|;
name|dusize
operator|=
name|tpcb
operator|->
name|tp_tpdusize
expr_stmt|;
name|dutype
operator|=
name|hdr
operator|->
name|tpdu_type
operator|<<
literal|8
expr_stmt|;
comment|/* for the switch below */
name|WHILE_OPTIONS
argument_list|(
argument|P
argument_list|,
argument|hdr
argument_list|,
argument|tpcb->tp_xtd_format
argument_list|)
comment|/* { */
define|#
directive|define
name|caseof
parameter_list|(
name|x
parameter_list|,
name|y
parameter_list|)
value|case (((x)<<8)+(y))
switch|switch
condition|(
name|dutype
operator||
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_code
condition|)
block|{
name|caseof
argument_list|(
name|CC_TPDU_type
argument_list|,
name|TPP_addl_opt
argument_list|)
operator|:
comment|/* not in class 0; 1 octet */
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_char
argument_list|,
name|addlopt
argument_list|)
expr_stmt|;
break|break;
name|caseof
argument_list|(
name|CC_TPDU_type
argument_list|,
name|TPP_tpdu_size
argument_list|)
operator|:
block|{
name|u_char
name|odusize
operator|=
name|dusize
block|;
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_char
argument_list|,
name|dusize
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
argument|(dusize< TP_MIN_TPDUSIZE || 							dusize> TP_MAX_TPDUSIZE || dusize> odusize)
argument_list|,
argument|E_TP_INV_PVAL
argument_list|,
argument|ts_inv_pval
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+ (caddr_t)&vbptr(P)->tpv_val - (caddr_t)hdr)
argument_list|)
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CC dusize 0x%x\n"
argument_list|,
name|dusize
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
break|break;
name|caseof
argument_list|(
name|CC_TPDU_type
argument_list|,
name|TPP_calling_sufx
argument_list|)
operator|:
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CC calling (local) sufxlen 0x%x\n"
argument_list|,
name|lsufxlen
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|lsufxloc
init|=
operator|(
name|caddr_t
operator|)
operator|&
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_val
decl_stmt|;
name|lsufxlen
operator|=
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_len
expr_stmt|;
break|break;
name|caseof
argument_list|(
name|CC_TPDU_type
argument_list|,
name|TPP_acktime
argument_list|)
operator|:
comment|/* class 4 only, 2 octets */
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_short
argument_list|,
name|acktime
argument_list|)
expr_stmt|;
name|acktime
operator|=
name|ntohs
argument_list|(
name|acktime
argument_list|)
expr_stmt|;
name|acktime
operator|=
name|acktime
operator|/
literal|500
expr_stmt|;
comment|/* convert to slowtimo ticks */
if|if
condition|(
operator|(
name|short
operator|)
name|acktime
operator|<=
literal|0
condition|)
name|acktime
operator|=
literal|2
expr_stmt|;
break|break;
name|caseof
argument_list|(
name|CC_TPDU_type
argument_list|,
name|TPP_called_sufx
argument_list|)
operator|:
name|fsufxloc
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_val
expr_stmt|;
name|fsufxlen
operator|=
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_len
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"CC called (foreign) sufx len %d\n"
argument_list|,
name|fsufxlen
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
name|caseof
argument_list|(
name|CC_TPDU_type
argument_list|,
name|TPP_checksum
argument_list|)
operator|:
name|caseof
argument_list|(
name|DR_TPDU_type
argument_list|,
name|TPP_checksum
argument_list|)
operator|:
name|caseof
argument_list|(
name|DT_TPDU_type
argument_list|,
name|TPP_checksum
argument_list|)
operator|:
name|caseof
argument_list|(
name|XPD_TPDU_type
argument_list|,
name|TPP_checksum
argument_list|)
operator|:
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
condition|)
block|{
name|CHECK
argument_list|(
argument|iso_check_csum(m, tpdu_len)
argument_list|,
argument|E_TP_INV_PVAL
argument_list|,
argument|ts_bad_csum
argument_list|,
argument|discard
argument_list|,
literal|0
argument_list|)
block|}
break|break;
comment|/*  this is different from the above because in the context 			 *  of concat/ sep tpdu_len might not be the same as hdr len  			 */
name|caseof
argument_list|(
name|AK_TPDU_type
argument_list|,
name|TPP_checksum
argument_list|)
operator|:
name|caseof
argument_list|(
name|XAK_TPDU_type
argument_list|,
name|TPP_checksum
argument_list|)
operator|:
name|caseof
argument_list|(
name|DC_TPDU_type
argument_list|,
name|TPP_checksum
argument_list|)
operator|:
if|if
condition|(
name|tpcb
operator|->
name|tp_use_checksum
condition|)
block|{
name|CHECK
argument_list|(
argument|iso_check_csum(m, (int)hdr->tpdu_li +
literal|1
argument|)
argument_list|,
argument|E_TP_INV_PVAL
argument_list|,
argument|ts_bad_csum
argument_list|,
argument|discard
argument_list|,
literal|0
argument_list|)
block|}
break|break;
ifdef|#
directive|ifdef
name|notdef
name|caseof
argument_list|(
name|DR_TPDU_type
argument_list|,
name|TPP_addl_info
argument_list|)
operator|:
comment|/* ignore - its length and meaning are 				 * user defined and there's no way 				 * to pass this info to the user anyway 				 */
break|break;
endif|#
directive|endif
endif|notdef
name|caseof
argument_list|(
name|AK_TPDU_type
argument_list|,
name|TPP_subseq
argument_list|)
operator|:
comment|/* used after reduction of window */
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_short
argument_list|,
name|subseq
argument_list|)
expr_stmt|;
name|subseq
operator|=
name|ntohs
argument_list|(
name|subseq
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"AK Subsequence # 0x%x\n"
argument_list|,
name|subseq
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
name|caseof
argument_list|(
name|AK_TPDU_type
argument_list|,
name|TPP_flow_cntl_conf
argument_list|)
operator|:
block|{
name|u_int
name|ylwe
block|;
name|u_short
name|ysubseq
operator|,
name|ycredit
expr_stmt|;
name|fcc_present
operator|=
name|TRUE
expr_stmt|;
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_int
argument_list|,
name|ylwe
argument_list|)
expr_stmt|;
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_short
argument_list|,
name|ysubseq
argument_list|)
expr_stmt|;
name|vb_getval
argument_list|(
name|P
argument_list|,
name|u_short
argument_list|,
name|ycredit
argument_list|)
expr_stmt|;
name|ylwe
operator|=
name|ntohl
argument_list|(
name|ylwe
argument_list|)
expr_stmt|;
name|ysubseq
operator|=
name|ntohs
argument_list|(
name|ysubseq
argument_list|)
expr_stmt|;
name|ycredit
operator|=
name|ntohs
argument_list|(
name|ycredit
argument_list|)
expr_stmt|;
name|IFDEBUG
argument_list|(
argument|D_ACKRECV
argument_list|)
name|printf
argument_list|(
literal|"AK FCC lwe 0x%x, subseq 0x%x, cdt 0x%x\n"
argument_list|,
name|ylwe
argument_list|,
name|ysubseq
argument_list|,
name|ycredit
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_if

begin_break
break|break;
end_break

begin_default
default|default:
end_default

begin_macro
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"param ignored dutype 0x%x, code  0x%x\n"
argument_list|,
name|dutype
argument_list|,
name|vbptr
argument_list|(
name|P
argument_list|)
operator|->
name|tpv_code
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_TPINPUT
parameter_list|)
function_decl|tptrace
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"param ignored dutype code "
operator|,
function_decl|dutype
operator|,
function_decl|vbptr
parameter_list|(
name|P
parameter_list|)
function_decl|->tpv_code
operator|,
function_decl|0
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDTRACE
name|IncStat
parameter_list|(
name|ts_param_ignored
parameter_list|)
function_decl|;
end_function_decl

begin_break
break|break;
end_break

begin_undef
undef|#
directive|undef
name|caseof
end_undef

begin_comment
unit|}
comment|/* } */
end_comment

begin_expr_stmt
unit|END_WHILE_OPTIONS
operator|(
name|P
operator|)
end_expr_stmt

begin_comment
comment|/* NOTE: the variable dutype has been shifted left! */
end_comment

begin_switch
switch|switch
condition|(
name|hdr
operator|->
name|tpdu_type
condition|)
block|{
case|case
name|CC_TPDU_type
case|:
comment|/* If CC comes back with an unacceptable class 			 * respond with a DR or ER 			 */
name|opt
operator|=
name|hdr
operator|->
name|tpdu_CCoptions
expr_stmt|;
comment|/* 1 byte */
block|{
name|tpp
operator|=
name|tpcb
operator|->
name|_tp_param
expr_stmt|;
name|tpp
operator|.
name|p_class
operator|=
operator|(
literal|1
operator|<<
name|hdr
operator|->
name|tpdu_CCclass
operator|)
expr_stmt|;
name|tpp
operator|.
name|p_tpdusize
operator|=
name|dusize
expr_stmt|;
name|tpp
operator|.
name|p_dont_change_params
operator|=
literal|0
expr_stmt|;
name|tpp
operator|.
name|p_xtd_format
operator|=
operator|(
name|opt
operator|&
name|TPO_XTD_FMT
operator|)
operator|==
name|TPO_XTD_FMT
expr_stmt|;
name|tpp
operator|.
name|p_xpd_service
operator|=
operator|(
name|addlopt
operator|&
name|TPAO_USE_TXPD
operator|)
operator|==
name|TPAO_USE_TXPD
expr_stmt|;
name|tpp
operator|.
name|p_use_checksum
operator|=
operator|(
name|addlopt
operator|&
name|TPAO_NO_CSUM
operator|)
operator|==
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|notdef
name|tpp
operator|.
name|p_use_efc
operator|=
operator|(
name|opt
operator|&
name|TPO_USE_EFC
operator|)
operator|==
name|TPO_USE_EFC
expr_stmt|;
name|tpp
operator|.
name|p_use_nxpd
operator|=
operator|(
name|addlopt
operator|&
name|TPAO_USE_NXPD
operator|)
operator|==
name|TPAO_USE_NXPD
expr_stmt|;
name|tpp
operator|.
name|p_use_rcc
operator|=
operator|(
name|addlopt
operator|&
name|TPAO_USE_RCC
operator|)
operator|==
name|TPAO_USE_RCC
expr_stmt|;
endif|#
directive|endif
endif|notdef
name|CHECK
argument_list|(
argument|tp_consistency(tpcb, TP_FORCE,&tpp) !=
literal|0
argument_list|,
argument|E_TP_NEGOT_FAILED
argument_list|,
argument|ts_negotfailed
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+
literal|2
argument|+ (caddr_t)&hdr->_tpdufr.CRCC - (caddr_t)hdr)
comment|/* ^ more or less the location of class */
argument_list|)
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"after 1 consist class, out, tpconsout"
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|dgout_routine
argument_list|,
name|tpcons_output
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|CHECK
argument_list|(
operator|(
operator|(
name|class_to_use
operator|==
name|TP_CLASS_0
operator|)
operator|&&
operator|(
name|dgout_routine
operator|!=
name|tpcons_output
operator|)
operator|)
argument_list|,
name|E_TP_NEGOT_FAILED
argument_list|,
name|ts_negotfailed
argument_list|,
name|respond
argument_list|,
operator|(
literal|1
operator|+
literal|2
operator|+
operator|(
name|caddr_t
operator|)
operator|&
name|hdr
operator|->
name|_tpdufr
operator|.
name|CRCC
operator|-
operator|(
name|caddr_t
operator|)
name|hdr
operator|)
comment|/* ^ more or less the location of class */
argument_list|)
block|}
if|if
condition|(
operator|!
name|tpcb
operator|->
name|tp_use_checksum
condition|)
name|IncStat
argument_list|(
name|ts_csum_off
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_xpd_service
condition|)
name|IncStat
argument_list|(
name|ts_use_txpd
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
name|IncStat
argument_list|(
name|ts_xtd_fmt
argument_list|)
expr_stmt|;
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"after CC class flags dusize CCclass"
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|tpcb
operator|->
name|tp_flags
argument_list|,
name|tpcb
operator|->
name|tp_tpdusize
argument_list|,
name|hdr
operator|->
name|tpdu_CCclass
argument_list|)
expr_stmt|;
name|ENDTRACE
comment|/*  			 * Get the maximum transmission unit from the lower layer(s) 			 * so we can decide how large a TPDU size to negotiate. 			 * It would be nice if the arguments to this 			 * were more reasonable. 			 */
argument_list|(
name|tpcb
operator|->
name|tp_nlproto
operator|->
name|nlp_mtu
argument_list|)
argument_list|(
name|tpcb
operator|->
name|tp_sock
argument_list|,
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_pcb
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_l_tpdusize
argument_list|,
operator|&
name|tpcb
operator|->
name|tp_tpdusize
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CONS
comment|/* Could be that this CC came in on a NEW vc, in which case 			 * we have to confirm it. 			 */
if|if
condition|(
name|cons_channel
condition|)
name|cons_netcmd
argument_list|(
name|CONN_CONFIRM
argument_list|,
name|tpcb
operator|->
name|tp_npcb
argument_list|,
name|cons_channel
argument_list|,
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|CONS
name|tpcb
operator|->
name|tp_peer_acktime
operator|=
name|acktime
expr_stmt|;
comment|/* if called or calling suffices appeared on the CC,  			 * they'd better jive with what's in the pcb 			 */
if|if
condition|(
name|fsufxlen
condition|)
block|{
name|CHECK
argument_list|(
argument|((tpcb->tp_fsuffixlen != fsufxlen) || 					bcmp(fsufxloc, tpcb->tp_fsuffix, fsufxlen))
argument_list|,
argument|E_TP_INV_PVAL
argument_list|,
argument|ts_inv_sufx
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+fsufxloc - (caddr_t)hdr)
argument_list|)
block|}
if|if
condition|(
name|lsufxlen
condition|)
block|{
name|CHECK
argument_list|(
argument|((tpcb->tp_lsuffixlen != lsufxlen) || 					bcmp(lsufxloc, tpcb->tp_lsuffix, lsufxlen))
argument_list|,
argument|E_TP_INV_PVAL
argument_list|,
argument|ts_inv_sufx
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+lsufxloc - (caddr_t)hdr)
argument_list|)
block|}
name|e
operator|.
name|ATTR
argument_list|(
name|CC_TPDU
argument_list|)
operator|.
name|e_sref
operator|=
name|sref
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|CC_TPDU
argument_list|)
operator|.
name|e_cdt
operator|=
name|hdr
operator|->
name|tpdu_CCcdt
expr_stmt|;
name|takes_data
operator|=
name|TRUE
expr_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|CC_TPDU
expr_stmt|;
name|IncStat
argument_list|(
name|ts_CC_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DC_TPDU_type
case|:
if|if
condition|(
name|sref
operator|!=
name|tpcb
operator|->
name|tp_fref
condition|)
name|printf
argument_list|(
literal|"INPUT: inv sufx DCsref 0x%x, tp_fref 0x%x\n"
argument_list|,
name|sref
argument_list|,
name|tpcb
operator|->
name|tp_fref
argument_list|)
expr_stmt|;
name|CHECK
argument_list|(
argument|(sref != tpcb->tp_fref)
argument_list|,
argument|E_TP_MISM_REFS
argument_list|,
argument|ts_inv_sufx
argument_list|,
argument|discard
argument_list|,
argument|(
literal|1
argument|+ (caddr_t)&hdr->tpdu_DCsref - (caddr_t)hdr)
argument_list|)
name|e
operator|.
name|ev_number
operator|=
name|DC_TPDU
expr_stmt|;
name|IncStat
argument_list|(
name|ts_DC_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DR_TPDU_type
case|:
name|IFTRACE
argument_list|(
argument|D_TPINPUT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"DR recvd"
argument_list|,
name|hdr
operator|->
name|tpdu_DRreason
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
name|sref
operator|!=
name|tpcb
operator|->
name|tp_fref
condition|)
block|{
name|printf
argument_list|(
literal|"INPUT: inv sufx DRsref 0x%x tp_fref 0x%x\n"
argument_list|,
name|sref
argument_list|,
name|tpcb
operator|->
name|tp_fref
argument_list|)
expr_stmt|;
block|}
name|CHECK
argument_list|(
argument|(sref !=
literal|0
argument|&& sref != tpcb->tp_fref&& 					tpcb->tp_state != TP_CRSENT)
argument_list|,
argument|(TP_ERROR_SNDC | E_TP_MISM_REFS)
argument_list|,
argument|ts_inv_sufx
argument_list|,
argument|respond
argument_list|,
argument|(
literal|1
argument|+ (caddr_t)&hdr->tpdu_DRsref - (caddr_t)hdr)
argument_list|)
name|e
operator|.
name|ATTR
argument_list|(
name|DR_TPDU
argument_list|)
operator|.
name|e_reason
operator|=
name|hdr
operator|->
name|tpdu_DRreason
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|DR_TPDU
argument_list|)
operator|.
name|e_sref
operator|=
operator|(
name|u_short
operator|)
name|sref
expr_stmt|;
name|takes_data
operator|=
name|TRUE
expr_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|DR_TPDU
expr_stmt|;
name|IncStat
argument_list|(
name|ts_DR_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|ER_TPDU_type
case|:
name|IFTRACE
argument_list|(
argument|D_TPINPUT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"ER recvd"
argument_list|,
name|hdr
operator|->
name|tpdu_ERreason
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
name|e
operator|.
name|ev_number
init|=
name|ER_TPDU
decl_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|ER_TPDU
argument_list|)
operator|.
name|e_reason
operator|=
name|hdr
operator|->
name|tpdu_ERreason
expr_stmt|;
name|IncStat
argument_list|(
name|ts_ER_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|AK_TPDU_type
case|:
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_subseq
operator|=
name|subseq
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_fcc_present
operator|=
name|fcc_present
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seqeot
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|tpdu_seqeotX
argument_list|)
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|seqeotX
operator|.
name|s_seq
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_cdt
operator|=
name|ntohs
argument_list|(
name|hdr
operator|->
name|tpdu_AKcdtX
argument_list|)
expr_stmt|;
else|#
directive|else
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_cdt
operator|=
name|hdr
operator|->
name|tpdu_AKcdtX
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_AKseqX
expr_stmt|;
endif|#
directive|endif
endif|BYTE_ORDER
block|}
else|else
block|{
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_cdt
operator|=
name|hdr
operator|->
name|tpdu_AKcdt
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_AKseq
expr_stmt|;
block|}
name|IFTRACE
argument_list|(
argument|D_TPINPUT
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"AK recvd seq cdt subseq fcc_pres"
argument_list|,
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_seq
argument_list|,
name|e
operator|.
name|ATTR
argument_list|(
name|AK_TPDU
argument_list|)
operator|.
name|e_cdt
argument_list|,
name|subseq
argument_list|,
name|fcc_present
argument_list|)
expr_stmt|;
name|ENDTRACE
name|e
operator|.
name|ev_number
init|=
name|AK_TPDU
decl_stmt|;
name|IncStat
argument_list|(
name|ts_AK_rcvd
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_AK_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|XAK_TPDU_type
case|:
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seqeot
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|tpdu_seqeotX
argument_list|)
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|XAK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|seqeotX
operator|.
name|s_seq
expr_stmt|;
else|#
directive|else
name|e
operator|.
name|ATTR
argument_list|(
name|XAK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_XAKseqX
expr_stmt|;
endif|#
directive|endif
endif|BYTE_ORDER
block|}
else|else
block|{
name|e
operator|.
name|ATTR
argument_list|(
name|XAK_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_XAKseq
expr_stmt|;
block|}
name|e
operator|.
name|ev_number
operator|=
name|XAK_TPDU
expr_stmt|;
name|IncStat
argument_list|(
name|ts_XAK_rcvd
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_XAK_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|XPD_TPDU_type
case|:
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seqeot
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|tpdu_seqeotX
argument_list|)
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|XPD_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|seqeotX
operator|.
name|s_seq
expr_stmt|;
else|#
directive|else
name|e
operator|.
name|ATTR
argument_list|(
name|XPD_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_XPDseqX
expr_stmt|;
endif|#
directive|endif
endif|BYTE_ORDER
block|}
else|else
block|{
name|e
operator|.
name|ATTR
argument_list|(
name|XPD_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_XPDseq
expr_stmt|;
block|}
name|takes_data
operator|=
name|TRUE
expr_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|XPD_TPDU
expr_stmt|;
name|IncStat
argument_list|(
name|ts_XPD_rcvd
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_XPD_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_TPDU_type
case|:
block|{
comment|/* the y option will cause occasional packets to be dropped. 			   * A little crude but it works. 			   */
name|IFDEBUG
argument_list|(
argument|D_DROP
argument_list|)
if|if
condition|(
name|time
operator|.
name|tv_usec
operator|&
literal|0x4
operator|&&
name|hdr
operator|->
name|tpdu_DTseq
operator|&
literal|0x1
condition|)
block|{
name|IncStat
argument_list|(
name|ts_ydebug
argument_list|)
expr_stmt|;
goto|goto
name|discard
goto|;
block|}
name|ENDDEBUG
block|}
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
literal|0
expr_stmt|;
comment|/* actually don't care */
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_eot
operator|=
operator|(
operator|(
operator|(
expr|struct
name|tp0du
operator|*
operator|)
name|hdr
operator|)
operator|->
name|tp0du_eot
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tpcb
operator|->
name|tp_xtd_format
condition|)
block|{
ifdef|#
directive|ifdef
name|BYTE_ORDER
name|union
name|seq_type
name|seqeotX
decl_stmt|;
name|seqeotX
operator|.
name|s_seqeot
operator|=
name|ntohl
argument_list|(
name|hdr
operator|->
name|tpdu_seqeotX
argument_list|)
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|seqeotX
operator|.
name|s_seq
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_eot
operator|=
name|seqeotX
operator|.
name|s_eot
expr_stmt|;
else|#
directive|else
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_DTseqX
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_eot
operator|=
name|hdr
operator|->
name|tpdu_DTeotX
expr_stmt|;
endif|#
directive|endif
endif|BYTE_ORDER
block|}
else|else
block|{
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_seq
operator|=
name|hdr
operator|->
name|tpdu_DTseq
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_eot
operator|=
name|hdr
operator|->
name|tpdu_DTeot
expr_stmt|;
block|}
if|if
condition|(
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_eot
condition|)
name|IncStat
argument_list|(
name|ts_eot_input
argument_list|)
expr_stmt|;
name|takes_data
operator|=
name|TRUE
expr_stmt|;
name|e
operator|.
name|ev_number
operator|=
name|DT_TPDU
expr_stmt|;
name|IncStat
argument_list|(
name|ts_DT_rcvd
argument_list|)
expr_stmt|;
name|IncPStat
argument_list|(
name|tpcb
argument_list|,
name|tps_DT_rcvd
argument_list|)
expr_stmt|;
break|break;
case|case
name|GR_TPDU_type
case|:
name|tp_indicate
argument_list|(
name|T_DISCONNECT
argument_list|,
name|tpcb
argument_list|,
name|ECONNABORTED
argument_list|)
expr_stmt|;
comment|/* drop through */
default|default:
comment|/* this should NEVER happen because there is a 			 * check for dutype well above here 			 */
name|error
operator|=
name|E_TP_INV_TPDU
expr_stmt|;
comment|/* causes an ER  */
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"INVALID dutype 0x%x\n"
argument_list|,
name|hdr
operator|->
name|tpdu_type
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
parameter_list|(
name|ts_inv_dutype
parameter_list|)
function_decl|;
goto|goto
name|respond
goto|;
block|}
end_switch

begin_comment
unit|}
comment|/* peel off the tp header;  	 * remember that the du_li doesn't count itself. 	 * This may leave us w/ an empty mbuf at the front of a chain. 	 * We can't just throw away the empty mbuf because hdr still points 	 * into the mbuf's data area and we're still using hdr (the tpdu header) 	 */
end_comment

begin_expr_stmt
unit|m
operator|->
name|m_len
operator|-=
operator|(
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
operator|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|m
operator|->
name|m_data
operator|+=
operator|(
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
operator|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|takes_data
condition|)
block|{
name|int
name|max
init|=
name|tpdu_info
index|[
name|hdr
operator|->
name|tpdu_type
index|]
index|[
name|TP_MAX_DATA_INDEX
index|]
decl_stmt|;
name|int
name|datalen
init|=
name|tpdu_len
operator|-
name|hdr
operator|->
name|tpdu_li
operator|-
literal|1
decl_stmt|,
name|mbtype
init|=
name|MT_DATA
decl_stmt|;
name|struct
name|cmsghdr
name|c_hdr
decl_stmt|;
name|struct
name|mbuf
modifier|*
name|n
decl_stmt|;
name|CHECK
argument_list|(
operator|(
name|max
operator|&&
name|datalen
operator|>
name|max
operator|)
argument_list|,
name|E_TP_LENGTH_INVAL
argument_list|,
name|ts_inv_length
argument_list|,
name|respond
argument_list|,
operator|(
name|max
operator|+
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|hdr
operator|->
name|tpdu_type
condition|)
block|{
case|case
name|CR_TPDU_type
case|:
name|c_hdr
operator|.
name|cmsg_type
operator|=
name|TPOPT_CONN_DATA
expr_stmt|;
goto|goto
name|make_control_msg
goto|;
case|case
name|CC_TPDU_type
case|:
name|c_hdr
operator|.
name|cmsg_type
operator|=
name|TPOPT_CFRM_DATA
expr_stmt|;
goto|goto
name|make_control_msg
goto|;
case|case
name|DR_TPDU_type
case|:
name|c_hdr
operator|.
name|cmsg_type
operator|=
name|TPOPT_DISC_DATA
expr_stmt|;
name|make_control_msg
label|:
name|c_hdr
operator|.
name|cmsg_level
operator|=
name|SOL_TRANSPORT
expr_stmt|;
name|mbtype
operator|=
name|MT_CONTROL
expr_stmt|;
name|MGET
argument_list|(
name|n
argument_list|,
name|M_DONTWAIT
argument_list|,
name|MT_DATA
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
condition|)
block|{
name|datalen
operator|+=
sizeof|sizeof
argument_list|(
name|c_hdr
argument_list|)
expr_stmt|;
name|n
operator|->
name|m_len
operator|=
sizeof|sizeof
argument_list|(
name|c_hdr
argument_list|)
expr_stmt|;
name|c_hdr
operator|.
name|cmsg_len
operator|=
name|datalen
expr_stmt|;
operator|*
name|mtod
argument_list|(
name|n
argument_list|,
expr|struct
name|cmsghdr
operator|*
argument_list|)
operator|=
name|c_hdr
expr_stmt|;
name|n
operator|->
name|m_next
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
block|}
else|else
block|{
name|m_freem
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|m
operator|=
literal|0
expr_stmt|;
goto|goto
name|invoke
goto|;
block|}
comment|/* FALLTHROUGH */
case|case
name|XPD_TPDU_type
case|:
if|if
condition|(
name|mbtype
operator|!=
name|MT_CONTROL
condition|)
name|mbtype
operator|=
name|MT_OOBDATA
expr_stmt|;
name|m
operator|->
name|m_flags
operator||=
name|M_EOR
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
name|DT_TPDU_type
case|:
for|for
control|(
name|n
operator|=
name|m
init|;
name|n
condition|;
name|n
operator|=
name|n
operator|->
name|m_next
control|)
block|{
name|MCHTYPE
argument_list|(
name|n
argument_list|,
name|mbtype
argument_list|)
expr_stmt|;
block|}
name|invoke
label|:
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_datalen
operator|=
name|datalen
expr_stmt|;
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_data
operator|=
name|m
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"ERROR in tp_input! hdr->tpdu_type 0x%x takes_data 0x%x m 0x%x\n"
argument_list|,
name|hdr
operator|->
name|tpdu_type
argument_list|,
name|takes_data
argument_list|,
name|m
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* prevent m_freem() after tp_driver() from throwing it all away */
name|m
operator|=
name|MNULL
expr_stmt|;
block|}
end_if

begin_expr_stmt
name|IncStat
argument_list|(
name|ts_tpdu_rcvd
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"tp_input: before driver, state 0x%x event 0x%x m 0x%x"
argument_list|,
name|tpcb
operator|->
name|tp_state
argument_list|,
name|e
operator|.
name|ev_number
argument_list|,
name|m
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|" e.e_data 0x%x\n"
argument_list|,
name|e
operator|.
name|ATTR
argument_list|(
name|DT_TPDU
argument_list|)
operator|.
name|e_data
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|printf
argument_list|(
literal|"takes_data 0x%x m_len 0x%x, tpdu_len 0x%x\n"
argument_list|,
name|takes_data
argument_list|,
operator|(
name|m
operator|==
name|MNULL
operator|)
condition|?
literal|0
else|:
name|m
operator|->
name|m_len
argument_list|,
name|tpdu_len
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDDEBUG
name|error
init|=
name|tp_driver
argument_list|(
name|tpcb
argument_list|,
operator|&
name|e
argument_list|)
decl_stmt|;
end_decl_stmt

begin_expr_stmt
name|ASSERT
argument_list|(
name|tpcb
operator|!=
operator|(
expr|struct
name|tp_pcb
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|ASSERT
argument_list|(
name|tpcb
operator|->
name|tp_sock
operator|!=
operator|(
expr|struct
name|socket
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
end_expr_stmt

begin_if
if|if
condition|(
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
operator|==
literal|0
condition|)
name|tpcb
operator|->
name|tp_sock
operator|->
name|so_error
operator|=
name|error
expr_stmt|;
end_if

begin_comment
comment|/* Kludge to keep the state tables under control (adding 	 * data on connect& disconnect& freeing the mbuf containing 	 * the data would have exploded the tables and made a big mess ). 	 */
end_comment

begin_switch
switch|switch
condition|(
name|e
operator|.
name|ev_number
condition|)
block|{
case|case
name|CC_TPDU
case|:
case|case
name|DR_TPDU
case|:
case|case
name|CR_TPDU
case|:
name|m
operator|=
name|e
operator|.
name|ATTR
argument_list|(
name|CC_TPDU
argument_list|)
operator|.
name|e_data
expr_stmt|;
comment|/* same field for all three dutypes */
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"after driver, restoring m to 0x%x, takes_data 0x%x\n"
argument_list|,
name|m
argument_list|,
name|takes_data
argument_list|)
expr_stmt|;
name|ENDDEBUG
break|break;
default|default:
break|break;
block|}
end_switch

begin_comment
comment|/* Concatenated sequences are terminated by any tpdu that  	 * carries data: CR, CC, DT, XPD, DR. 	 * All other tpdu types may be concatenated: AK, XAK, DC, ER. 	 */
end_comment

begin_label
name|separate
label|:
end_label

begin_if
if|if
condition|(
name|takes_data
operator|==
literal|0
condition|)
block|{
name|ASSERT
argument_list|(
name|m
operator|!=
name|MNULL
argument_list|)
expr_stmt|;
comment|/*  		 * we already peeled off the prev. tp header so  		 * we can just pull up some more and repeat 		 */
if|if
condition|(
name|m
operator|=
name|tp_inputprep
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|hdr
operator|=
name|mtod
argument_list|(
name|m
argument_list|,
expr|struct
name|tpdu
operator|*
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"tp_input @ separate: hdr 0x%x size %d m 0x%x\n"
argument_list|,
name|hdr
argument_list|,
operator|(
name|int
operator|)
name|hdr
operator|->
name|tpdu_li
operator|+
literal|1
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|dump_mbuf
argument_list|(
name|m
argument_list|,
literal|"tp_input after driver, at separate"
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|IncStat
parameter_list|(
name|ts_concat_rcvd
parameter_list|)
function_decl|;
goto|goto
name|again
goto|;
block|}
block|}
end_if

begin_if
if|if
condition|(
name|m
operator|!=
name|MNULL
condition|)
block|{
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_input : m_freem(0x%x)\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
name|m_freem
parameter_list|(
name|m
parameter_list|)
function_decl|;
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
name|printf
argument_list|(
literal|"tp_input : after m_freem 0x%x\n"
argument_list|,
name|m
argument_list|)
expr_stmt|;
name|ENDDEBUG
block|}
end_if

begin_return
return|return
operator|(
name|ProtoHook
operator|)
name|tpcb
return|;
end_return

begin_label
name|discard
label|:
end_label

begin_comment
comment|/* class 4: drop the tpdu */
end_comment

begin_comment
comment|/* class 2,0: Should drop the net connection, if you can figure out 	 * to which connection it applies 	 */
end_comment

begin_macro
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"tp_input DISCARD\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_TPINPUT
parameter_list|)
function_decl|tptrace
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"tp_input DISCARD m"
operator|,
function_decl|m
operator|,
function_decl|0
operator|,
function_decl|0
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_function_decl
name|ENDTRACE
name|m_freem
parameter_list|(
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
name|IncStat
argument_list|(
name|ts_recv_drop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ProtoHook
operator|)
literal|0
return|;
end_return

begin_label
name|nonx_dref
label|:
end_label

begin_switch
switch|switch
condition|(
name|dutype
condition|)
block|{
default|default:
goto|goto
name|discard
goto|;
case|case
name|CC_TPDU_type
case|:
comment|/* error = E_TP_MISM_REFS; */
break|break;
case|case
name|DR_TPDU_type
case|:
name|error
operator||=
name|TP_ERROR_SNDC
expr_stmt|;
block|}
end_switch

begin_label
name|respond
label|:
end_label

begin_macro
name|IFDEBUG
argument_list|(
argument|D_TPINPUT
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"RESPOND: error 0x%x, errlen 0x%x\n"
argument_list|,
name|error
argument_list|,
name|errlen
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
name|ENDDEBUG
name|IFTRACE
parameter_list|(
name|D_TPINPUT
parameter_list|)
function_decl|tptrace
parameter_list|(
name|TPPTmisc
parameter_list|,
function_decl|"tp_input RESPOND m error sref"
operator|,
function_decl|m
operator|,
function_decl|error
operator|,
function_decl|sref
operator|,
function_decl|0
end_function_decl

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_macro
name|ENDTRACE
end_macro

begin_if
if|if
condition|(
name|sref
operator|==
literal|0
condition|)
goto|goto
name|discard
goto|;
end_if

begin_expr_stmt
operator|(
name|void
operator|)
name|tp_error_emit
argument_list|(
name|error
argument_list|,
operator|(
name|u_long
operator|)
name|sref
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|faddr
argument_list|,
operator|(
expr|struct
name|sockaddr_iso
operator|*
operator|)
name|laddr
argument_list|,
name|m
argument_list|,
name|errlen
argument_list|,
name|tpcb
argument_list|,
operator|(
name|int
operator|)
name|cons_channel
argument_list|,
name|dgout_routine
argument_list|)
expr_stmt|;
end_expr_stmt

begin_macro
name|IFDEBUG
argument_list|(
argument|D_ERROR_EMIT
argument_list|)
end_macro

begin_expr_stmt
name|printf
argument_list|(
literal|"tp_input after error_emit\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|ENDDEBUG
ifdef|#
directive|ifdef
name|lint
name|printf
argument_list|(
literal|""
argument_list|,
name|sref
argument_list|,
name|opt
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|lint
end_endif

begin_expr_stmt
name|IncStat
argument_list|(
name|ts_recv_drop
argument_list|)
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
name|ProtoHook
operator|)
literal|0
return|;
end_return

begin_comment
unit|}
comment|/*  * NAME: tp_headersize()  *  * CALLED FROM:  *  tp_emit() and tp_sbsend()  *  TP needs to know the header size so it can figure out how  *  much data to put in each tpdu.  *  * FUNCTION, ARGUMENTS, and RETURN VALUE:  *  For a given connection, represented by (tpcb), and   *  tpdu type (dutype), return the size of a tp header.  *  * RETURNS:	  the expected size of the heade in bytesr  *  * SIDE EFFECTS:	  *  * NOTES:	 It would be nice if it got the network header size as well.  */
end_comment

begin_macro
unit|int
name|tp_headersize
argument_list|(
argument|dutype
argument_list|,
argument|tpcb
argument_list|)
end_macro

begin_decl_stmt
name|int
name|dutype
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|tp_pcb
modifier|*
name|tpcb
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|size
init|=
literal|0
decl_stmt|;
name|IFTRACE
argument_list|(
argument|D_CONN
argument_list|)
name|tptrace
argument_list|(
name|TPPTmisc
argument_list|,
literal|"tp_headersize dutype class xtd_format"
argument_list|,
name|dutype
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|,
name|tpcb
operator|->
name|tp_xtd_format
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|ENDTRACE
if|if
condition|(
operator|!
operator|(
operator|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
operator|)
operator|||
operator|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
operator|)
operator|||
operator|(
name|dutype
operator|==
name|DR_TPDU_type
operator|)
operator|||
operator|(
name|dutype
operator|==
name|CR_TPDU_type
operator|)
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"tp_headersize:dutype 0x%x, class 0x%x"
argument_list|,
name|dutype
argument_list|,
name|tpcb
operator|->
name|tp_class
argument_list|)
expr_stmt|;
comment|/* TODO: identify this and GET RID OF IT */
block|}
name|ASSERT
argument_list|(
operator|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
operator|)
operator|||
operator|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_4
operator|)
operator|||
operator|(
name|dutype
operator|==
name|DR_TPDU_type
operator|)
operator|||
operator|(
name|dutype
operator|==
name|CR_TPDU_type
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tpcb
operator|->
name|tp_class
operator|==
name|TP_CLASS_0
condition|)
block|{
name|size
operator|=
name|tpdu_info
index|[
name|dutype
index|]
index|[
name|TP_LEN_CLASS_0_INDEX
index|]
expr_stmt|;
block|}
else|else
block|{
name|size
operator|=
name|tpdu_info
index|[
name|dutype
index|]
index|[
name|tpcb
operator|->
name|tp_xtd_format
index|]
expr_stmt|;
block|}
return|return
name|size
return|;
comment|/* caller must get network level header size separately */
block|}
end_block

end_unit

