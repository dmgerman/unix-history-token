begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	Aoperand.c	1.1	86/07/20	*/
end_comment

begin_include
include|#
directive|include
file|"../tahoealign/align.h"
end_include

begin_define
define|#
directive|define
name|illegal
parameter_list|(
name|x
parameter_list|)
value|((look_at->add_modes& x)==0)
end_define

begin_define
define|#
directive|define
name|legal
parameter_list|(
name|x
parameter_list|)
value|!illegal(x)
end_define

begin_function
name|struct
name|oprnd
modifier|*
name|operand
parameter_list|(
name|infop
parameter_list|,
name|number
parameter_list|)
specifier|register
name|process_info
modifier|*
name|infop
decl_stmt|;
name|int
name|number
decl_stmt|;
comment|/*  *	Enter with pc pointing to an operand descriptor  *	in the 'text'. Decode the addressing mode, get  *	the effective address and some data from there.  *	Leave pc on the next oerand specifier or opcode.  *	Returns a pointer to a 'decoded operand' structure,  *	actually one of the 4 pre-allocated .  *  *	This routine should be called in such a sequence  *	that pc will not have to be backed up to get some  *	operand. For example, operand(0) and then operand(1)  *	and then operand(2) is OK. Even operand(0), operand(1),  *	operand(1) is OK. The rule is that operand(N) should not  *	be called before operand(N-1) was.  *	  ***********************************************************/
block|{
specifier|register
name|struct
name|oprnd
modifier|*
name|next
decl_stmt|;
specifier|register
name|struct
name|operand_des
modifier|*
name|look_at
decl_stmt|;
specifier|register
name|int
name|header
decl_stmt|,
name|reg_num
decl_stmt|,
name|shift_count
decl_stmt|,
name|displ
decl_stmt|;
specifier|register
name|int
name|keep_last
decl_stmt|;
name|next
operator|=
operator|&
name|decoded
index|[
name|number
index|]
expr_stmt|;
if|if
condition|(
name|number
operator|<=
name|last_operand
condition|)
return|return
operator|(
name|next
operator|)
return|;
if|if
condition|(
name|number
operator|==
name|last_operand
operator|+
literal|1
condition|)
name|last_operand
operator|=
name|number
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"Wrong sequence of OPERAND calls (alignment code)\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|&
name|decoded
index|[
name|number
index|]
operator|)
return|;
block|}
empty_stmt|;
name|look_at
operator|=
operator|&
name|Table
index|[
name|opCODE
index|]
operator|.
name|operand
index|[
name|number
index|]
expr_stmt|;
name|next
operator|->
name|data2
operator|=
literal|0
expr_stmt|;
comment|/* Prepare for quad fetch */
name|next
operator|->
name|length
operator|=
name|look_at
operator|->
name|length
expr_stmt|;
if|if
condition|(
name|look_at
operator|->
name|add_modes
operator|==
name|Brd
condition|)
block|{
name|next
operator|->
name|mode
operator|=
name|Add
expr_stmt|;
switch|switch
condition|(
name|look_at
operator|->
name|length
condition|)
block|{
case|case
literal|1
case|:
name|displ
operator|=
name|get_byte
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|displ
operator|=
name|get_word
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Wrong branch displacement(alignment code)\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|next
operator|->
name|address
operator|=
name|pc
operator|+
name|displ
expr_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
empty_stmt|;
comment|/* Not branch displacement, real operand */
name|header
operator|=
name|get_byte
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
operator|&
literal|0xff
expr_stmt|;
name|pc
operator|++
expr_stmt|;
name|reg_num
operator|=
name|header
operator|&
literal|0xf
expr_stmt|;
switch|switch
condition|(
name|header
operator|>>
literal|4
operator|&
literal|0xf
condition|)
block|{
case|case
literal|0
case|:
comment|/* Short literals */
case|case
literal|1
case|:
case|case
literal|2
case|:
case|case
literal|3
case|:
if|if
condition|(
name|illegal
argument_list|(
name|Lit
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Imm
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|header
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* Indexed register */
if|if
condition|(
name|illegal
argument_list|(
name|Add
argument_list|)
operator|||
name|reg_num
operator|==
name|PCOUNTER
operator|||
name|reg_num
operator|==
name|SPOINTER
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|keep_last
operator|=
name|last_operand
expr_stmt|;
name|last_operand
operator|=
name|number
operator|-
literal|1
expr_stmt|;
comment|/* To get real results */
name|next
operator|=
name|operand
argument_list|(
name|infop
argument_list|,
name|number
argument_list|)
expr_stmt|;
comment|/* Get base address (recursive) */
name|last_operand
operator|=
name|keep_last
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|next
operator|->
name|mode
operator|&
name|Indx
operator|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|look_at
operator|->
name|length
condition|)
block|{
case|case
literal|1
case|:
name|shift_count
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|shift_count
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|shift_count
operator|=
literal|2
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|shift_count
operator|=
literal|3
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Wrong data length in table(alignment code)\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|next
operator|->
name|address
operator|+=
operator|(
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|<<
name|shift_count
operator|)
expr_stmt|;
name|next
operator|->
name|mode
operator||=
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
expr_stmt|;
comment|/* Set R/W bits */
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* Direct register */
if|if
condition|(
name|illegal
argument_list|(
name|Dir
argument_list|)
operator|||
name|reg_num
operator|==
name|PCOUNTER
operator|||
name|reg_num
operator|==
name|SPOINTER
operator|&&
name|legal
argument_list|(
name|R
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Dir
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator||=
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
expr_stmt|;
comment|/* Set R/W bits */
name|next
operator|->
name|reg_number
operator|=
name|reg_num
expr_stmt|;
if|if
condition|(
name|look_at
operator|->
name|length
operator|==
literal|8
condition|)
block|{
if|if
condition|(
name|reg_num
operator|>=
name|SPOINTER
operator|-
literal|1
operator|||
operator|(
name|reg_num
operator|&
literal|1
operator|)
operator|==
literal|1
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
else|else
name|next
operator|->
name|data2
operator|=
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* Indirect register */
if|if
condition|(
name|illegal
argument_list|(
name|Add
argument_list|)
operator|||
name|reg_num
operator|==
name|PCOUNTER
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
expr_stmt|;
name|next
operator|->
name|mode
operator||=
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
expr_stmt|;
comment|/* Set R/W bits */
if|if
condition|(
name|reg_num
operator|!=
name|SPOINTER
condition|)
name|next
operator|->
name|mode
operator||=
name|Indx
expr_stmt|;
comment|/* (sp) not indexable*/
name|next
operator|->
name|reg_number
operator|=
name|reg_num
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* Autodecrement SP */
if|if
condition|(
name|illegal
argument_list|(
name|Add
argument_list|)
operator|||
name|reg_num
operator|!=
name|SPOINTER
operator|||
name|look_at
operator|->
name|length
operator|!=
literal|4
operator|||
name|legal
argument_list|(
name|R
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|SPmode
expr_stmt|;
comment|/* Implies Add */
name|next
operator|->
name|mode
operator||=
name|W
expr_stmt|;
comment|/* Set R/W bits */
name|next
operator|->
name|reg_number
operator|=
name|SPOINTER
expr_stmt|;
name|next
operator|->
name|length
operator|=
literal|4
expr_stmt|;
comment|/* Regardless of big table */
name|sp
operator|-=
literal|4
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|sp
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* Immediate or (sp)+ */
switch|switch
condition|(
name|reg_num
condition|)
block|{
case|case
literal|8
case|:
comment|/* Immediate byte */
if|if
condition|(
name|illegal
argument_list|(
name|Imm
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Imm
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|get_byte
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* Immediate word */
if|if
condition|(
name|illegal
argument_list|(
name|Imm
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Imm
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|get_word
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* Immediate longword */
if|if
condition|(
name|illegal
argument_list|(
name|Imm
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Imm
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/* Autoincrement sp */
if|if
condition|(
name|illegal
argument_list|(
name|Add
argument_list|)
operator|||
name|legal
argument_list|(
name|W
argument_list|)
operator|||
name|look_at
operator|->
name|length
operator|!=
literal|4
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|SPmode
expr_stmt|;
comment|/* Implies Add */
name|next
operator|->
name|reg_number
operator|=
name|SPOINTER
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|sp
expr_stmt|;
name|next
operator|->
name|data
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|sp
argument_list|)
expr_stmt|;
name|next
operator|->
name|length
operator|=
literal|4
expr_stmt|;
comment|/* Regardless of big table */
name|sp
operator|+=
literal|4
expr_stmt|;
break|break;
default|default:
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|look_at
operator|->
name|length
operator|==
literal|8
condition|)
comment|/* Quadword fetch,not (sp)+ */
block|{
name|next
operator|->
name|data2
operator|=
name|next
operator|->
name|data
expr_stmt|;
if|if
condition|(
name|next
operator|->
name|data2
operator|>=
literal|0
condition|)
name|next
operator|->
name|data
operator|=
literal|0
expr_stmt|;
else|else
name|next
operator|->
name|data
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
comment|/* Autoincrement deferred SP or PC */
if|if
condition|(
name|reg_num
operator|!=
name|PCOUNTER
operator|&&
name|reg_num
operator|!=
name|SPOINTER
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
if|if
condition|(
name|reg_num
operator|==
name|PCOUNTER
operator|&&
name|illegal
argument_list|(
name|Abs
argument_list|)
operator|||
name|reg_num
operator|==
name|SPOINTER
operator|&&
name|illegal
argument_list|(
name|Add
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
operator||
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
operator||
name|Indx
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
operator|(
name|reg_num
operator|==
name|PCOUNTER
operator|)
condition|?
name|pc
else|:
name|sp
argument_list|)
expr_stmt|;
name|Replace
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|,
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|+
literal|4
argument_list|)
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xa
case|:
comment|/* Register or PC + byte displacement */
if|if
condition|(
name|reg_num
operator|!=
name|PCOUNTER
operator|&&
name|illegal
argument_list|(
name|Add
argument_list|)
operator|||
name|reg_num
operator|==
name|PCOUNTER
operator|&&
name|illegal
argument_list|(
name|Pcrel
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
operator||
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
expr_stmt|;
if|if
condition|(
name|reg_num
operator|!=
name|SPOINTER
operator|&&
name|look_at
operator|->
name|add_modes
operator|!=
name|PR
condition|)
name|next
operator|->
name|mode
operator||=
name|Indx
expr_stmt|;
name|displ
operator|=
name|get_byte
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|+
name|displ
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xb
case|:
comment|/* Same, indirect */
if|if
condition|(
name|illegal
argument_list|(
name|Add
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
operator||
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
operator||
name|Indx
expr_stmt|;
name|displ
operator|=
name|get_byte
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|++
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|+
name|displ
argument_list|)
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xc
case|:
comment|/* Register or PC + word displacement */
if|if
condition|(
name|reg_num
operator|!=
name|PCOUNTER
operator|&&
name|illegal
argument_list|(
name|Add
argument_list|)
operator|||
name|reg_num
operator|==
name|PCOUNTER
operator|&&
name|illegal
argument_list|(
name|Pcrel
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
operator||
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
expr_stmt|;
if|if
condition|(
name|reg_num
operator|!=
name|SPOINTER
operator|&&
name|look_at
operator|->
name|add_modes
operator|!=
name|PR
condition|)
name|next
operator|->
name|mode
operator||=
name|Indx
expr_stmt|;
name|displ
operator|=
name|get_word
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|+
name|displ
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xd
case|:
comment|/* Same, indirect */
if|if
condition|(
name|illegal
argument_list|(
name|Add
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
operator||
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
operator||
name|Indx
expr_stmt|;
name|displ
operator|=
name|get_word
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|2
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|+
name|displ
argument_list|)
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xe
case|:
comment|/* Register or PC + longword displacement */
if|if
condition|(
name|reg_num
operator|!=
name|PCOUNTER
operator|&&
name|illegal
argument_list|(
name|Add
argument_list|)
operator|||
name|reg_num
operator|==
name|PCOUNTER
operator|&&
name|illegal
argument_list|(
name|Pcrel
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
operator||
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
expr_stmt|;
if|if
condition|(
name|reg_num
operator|!=
name|SPOINTER
operator|&&
name|look_at
operator|->
name|add_modes
operator|!=
name|PR
condition|)
name|next
operator|->
name|mode
operator||=
name|Indx
expr_stmt|;
name|displ
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|+
name|displ
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0xf
case|:
comment|/* Same, indirect */
if|if
condition|(
name|illegal
argument_list|(
name|Add
argument_list|)
condition|)
name|exception
argument_list|(
name|infop
argument_list|,
name|ILL_ADDRMOD
argument_list|)
expr_stmt|;
name|next
operator|->
name|mode
operator|=
name|Add
operator||
operator|(
name|look_at
operator|->
name|add_modes
operator|&
name|M
operator|)
operator||
name|Indx
expr_stmt|;
name|displ
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|pc
argument_list|)
expr_stmt|;
name|pc
operator|+=
literal|4
expr_stmt|;
name|next
operator|->
name|address
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|Register
argument_list|(
name|infop
argument_list|,
name|reg_num
argument_list|)
operator|+
name|displ
argument_list|)
expr_stmt|;
name|trytoread
argument_list|(
name|infop
argument_list|,
name|next
argument_list|,
name|number
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|next
operator|)
return|;
block|}
end_function

begin_macro
name|trytoread
argument_list|(
argument|infop
argument_list|,
argument|pointer
argument_list|,
argument|number
argument_list|)
end_macro

begin_decl_stmt
name|process_info
modifier|*
name|infop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|oprnd
modifier|*
name|pointer
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|number
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /*	Receives the opcode operand number and a pointer /*	to the 'decoded' operand structure. /*	If it's defined as readable data in the big table, /*	it returns the data, sign extended. /* /**********************************************************/
end_comment

begin_block
block|{
specifier|register
name|struct
name|operand_des
modifier|*
name|look_at
decl_stmt|;
name|look_at
operator|=
operator|&
name|Table
index|[
name|opCODE
index|]
operator|.
name|operand
index|[
name|number
index|]
expr_stmt|;
if|if
condition|(
name|legal
argument_list|(
name|R
argument_list|)
condition|)
switch|switch
condition|(
name|look_at
operator|->
name|length
condition|)
block|{
case|case
literal|1
case|:
name|pointer
operator|->
name|data
operator|=
name|get_byte
argument_list|(
name|infop
argument_list|,
name|pointer
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|pointer
operator|->
name|data
operator|=
name|get_word
argument_list|(
name|infop
argument_list|,
name|pointer
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|pointer
operator|->
name|data
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|pointer
operator|->
name|address
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|pointer
operator|->
name|data
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|pointer
operator|->
name|address
argument_list|)
expr_stmt|;
name|pointer
operator|->
name|data2
operator|=
name|get_longword
argument_list|(
name|infop
argument_list|,
name|pointer
operator|->
name|address
operator|+
literal|4
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Wrong data length in table (alignment code)\n"
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
block|}
end_block

end_unit

