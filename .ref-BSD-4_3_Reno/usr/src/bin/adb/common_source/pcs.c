begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pcs.c	5.5 (Berkeley) 4/9/89"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * adb - subprocess control  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"bkpt.h"
end_include

begin_include
include|#
directive|include
file|<machine/reg.h>
end_include

begin_comment
comment|/* for getpc() */
end_comment

begin_comment
comment|/* XXX */
end_comment

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/ptrace.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_decl_stmt
specifier|extern
name|char
name|NOBKPT
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|SZBKPT
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|EXBKPT
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|NOPCS
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|BADMOD
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|NOFORK
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ENDPCS
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|BADWAIT
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|bkpt
modifier|*
name|bkpthead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* head of breakpoint list */
end_comment

begin_decl_stmt
specifier|static
name|long
name|runcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of times to loop past breakpoints */
end_comment

begin_comment
comment|/* bpstate remembers whether we have installed the breakpoints */
end_comment

begin_enum
specifier|static
enum|enum
block|{
name|BPOUT
block|,
name|BPIN
block|}
name|bpstate
enum|;
end_enum

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* run modes */
end_comment

begin_define
define|#
directive|define
name|CONTINUOUS
value|0
end_define

begin_define
define|#
directive|define
name|SINGLESTEP
value|1
end_define

begin_comment
comment|/* sub process control */
end_comment

begin_macro
name|subpcs
argument_list|(
argument|modif
argument_list|)
end_macro

begin_decl_stmt
name|int
name|modif
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|check
decl_stmt|;
specifier|register
name|struct
name|bkpt
modifier|*
name|bp
decl_stmt|;
name|int
name|execsig
decl_stmt|,
name|runmode
decl_stmt|;
name|char
modifier|*
name|comptr
decl_stmt|;
switch|switch
condition|(
name|modif
condition|)
block|{
case|case
literal|'d'
case|:
comment|/* delete breakpoint */
if|if
condition|(
operator|(
name|bp
operator|=
name|scanbkpt
argument_list|(
name|dot
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|NOBKPT
argument_list|)
expr_stmt|;
name|bp
operator|->
name|state
operator|=
name|BKPT_FREE
expr_stmt|;
return|return;
case|case
literal|'D'
case|:
comment|/* delete all breapoints */
for|for
control|(
name|bp
operator|=
name|bkpthead
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
name|bp
operator|->
name|state
operator|=
name|BKPT_FREE
expr_stmt|;
return|return;
case|case
literal|'b'
case|:
case|case
literal|'B'
case|:
comment|/* set breakpoint */
if|if
condition|(
operator|(
name|bp
operator|=
name|scanbkpt
argument_list|(
name|dot
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
comment|/* find a free one, or make one */
for|for
control|(
name|bp
operator|=
name|bkpthead
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|state
operator|==
name|BKPT_FREE
condition|)
break|break;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
block|{
name|bp
operator|=
operator|(
expr|struct
name|bkpt
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
name|error
argument_list|(
name|EXBKPT
argument_list|)
expr_stmt|;
name|bp
operator|->
name|next
operator|=
name|bkpthead
expr_stmt|;
name|bkpthead
operator|=
name|bp
expr_stmt|;
block|}
block|}
name|bp
operator|->
name|loc
operator|=
name|dot
expr_stmt|;
name|bp
operator|->
name|initcnt
operator|=
name|bp
operator|->
name|count
operator|=
name|ecount
expr_stmt|;
name|bp
operator|->
name|state
operator|=
name|BKPT_SET
expr_stmt|;
name|check
operator|=
name|MAX_BKPTCOM
operator|-
literal|1
expr_stmt|;
name|comptr
operator|=
name|bp
operator|->
name|comm
expr_stmt|;
operator|(
name|void
operator|)
name|rdc
argument_list|()
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
do|do
block|{
operator|*
name|comptr
operator|++
operator|=
name|readchar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|check
operator|--
operator|&&
name|lastc
operator|!=
literal|'\n'
condition|)
do|;
operator|*
name|comptr
operator|=
literal|0
expr_stmt|;
name|unreadc
argument_list|()
expr_stmt|;
if|if
condition|(
name|check
operator|==
literal|0
condition|)
name|error
argument_list|(
name|SZBKPT
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'k'
case|:
case|case
literal|'K'
case|:
comment|/* kill process */
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|error
argument_list|(
name|NOPCS
argument_list|)
expr_stmt|;
name|adbprintf
argument_list|(
literal|"%d: killed"
argument_list|,
name|pid
argument_list|)
expr_stmt|;
name|endpcs
argument_list|()
expr_stmt|;
return|return;
case|case
literal|'r'
case|:
case|case
literal|'R'
case|:
comment|/* run program */
name|endpcs
argument_list|()
expr_stmt|;
name|setup
argument_list|()
expr_stmt|;
name|runcount
operator|=
name|ecount
expr_stmt|;
name|runmode
operator|=
name|CONTINUOUS
expr_stmt|;
name|execsig
operator|=
literal|0
expr_stmt|;
comment|/* if starting at a breakpoint, run over it */
if|if
condition|(
name|scanbkpt
argument_list|(
name|gavedot
condition|?
name|dot
else|:
name|entrypc
argument_list|()
argument_list|)
operator|!=
name|NULL
condition|)
name|runcount
operator|++
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
comment|/* single step, with optional signal */
name|runcount
operator|=
name|ecount
expr_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
name|runmode
operator|=
name|SINGLESTEP
expr_stmt|;
name|execsig
operator|=
name|oexpr
argument_list|()
condition|?
name|expv
else|:
name|signo
expr_stmt|;
block|}
else|else
block|{
name|setup
argument_list|()
expr_stmt|;
name|runmode
operator|=
name|SINGLESTEP
expr_stmt|;
name|execsig
operator|=
literal|0
expr_stmt|;
name|runcount
operator|--
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
case|case
literal|'C'
case|:
case|case
literal|0
case|:
comment|/* continue with optional signal */
name|runcount
operator|=
name|ecount
expr_stmt|;
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
name|error
argument_list|(
name|NOPCS
argument_list|)
expr_stmt|;
name|runmode
operator|=
name|CONTINUOUS
expr_stmt|;
name|execsig
operator|=
name|oexpr
argument_list|()
condition|?
name|expv
else|:
name|signo
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|BADMOD
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|runcount
operator|>
literal|0
operator|&&
name|runpcs
argument_list|(
name|runmode
argument_list|,
name|execsig
argument_list|)
condition|)
name|adbprintf
argument_list|(
literal|"breakpoint%16t"
argument_list|)
expr_stmt|;
else|else
name|adbprintf
argument_list|(
literal|"stopped at%16t"
argument_list|)
expr_stmt|;
name|delbp
argument_list|()
expr_stmt|;
name|printpc
argument_list|()
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Print all breakpoints.  */
end_comment

begin_macro
name|printbkpts
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|bkpt
modifier|*
name|b
decl_stmt|;
name|adbprintf
argument_list|(
literal|"breakpoints\ncount%8tbkpt%24tcommand\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|b
operator|=
name|bkpthead
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
block|{
if|if
condition|(
name|b
operator|->
name|state
operator|!=
name|BKPT_FREE
condition|)
block|{
name|adbprintf
argument_list|(
literal|"%-8.8D"
argument_list|,
name|b
operator|->
name|count
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
literal|"%R"
argument_list|,
name|b
operator|->
name|loc
argument_list|,
name|SP_INSTR
argument_list|,
name|maxoff
argument_list|,
literal|"%24t"
argument_list|)
expr_stmt|;
name|prints
argument_list|(
name|b
operator|->
name|comm
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * Remove (restore to original instruction(s)) all breakpoints.  */
end_comment

begin_macro
name|delbp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|bkpt
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|bpstate
operator|!=
name|BPOUT
condition|)
block|{
for|for
control|(
name|b
operator|=
name|bkpthead
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
if|if
condition|(
name|b
operator|->
name|state
operator|!=
name|BKPT_FREE
operator|&&
name|clr_bpt
argument_list|(
name|b
argument_list|)
condition|)
name|bperr
argument_list|(
name|b
argument_list|,
literal|"clear"
argument_list|)
expr_stmt|;
name|bpstate
operator|=
name|BPOUT
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*  * Insert all breakpoints.  */
end_comment

begin_macro
name|setbp
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|bkpt
modifier|*
name|b
decl_stmt|;
if|if
condition|(
name|bpstate
operator|!=
name|BPIN
condition|)
block|{
for|for
control|(
name|b
operator|=
name|bkpthead
init|;
name|b
operator|!=
name|NULL
condition|;
name|b
operator|=
name|b
operator|->
name|next
control|)
if|if
condition|(
name|b
operator|->
name|state
operator|!=
name|BKPT_FREE
operator|&&
name|set_bpt
argument_list|(
name|b
argument_list|)
condition|)
name|bperr
argument_list|(
name|b
argument_list|,
literal|"set"
argument_list|)
expr_stmt|;
name|bpstate
operator|=
name|BPIN
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|bperr
argument_list|(
argument|b
argument_list|,
argument|how
argument_list|)
expr|struct
name|bkpt
operator|*
name|b
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|how
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|adbprintf
argument_list|(
literal|"cannot %s breakpoint: "
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|psymoff
argument_list|(
literal|"%R"
argument_list|,
name|b
operator|->
name|loc
argument_list|,
name|SP_INSTR
argument_list|,
name|maxoff
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Run subprocess for a while.  * Return true iff stopped due to breakpoint.  */
end_comment

begin_function
name|int
name|runpcs
parameter_list|(
name|runmode
parameter_list|,
name|execsig
parameter_list|)
name|int
name|runmode
decl_stmt|,
name|execsig
decl_stmt|;
block|{
specifier|register
name|struct
name|bkpt
modifier|*
name|bkpt
decl_stmt|;
name|int
name|rc
decl_stmt|;
comment|/* always set pc, so that expr>pc works too */
name|setpc
argument_list|(
name|gavedot
condition|?
name|dot
else|:
name|getpc
argument_list|()
argument_list|)
expr_stmt|;
name|adbprintf
argument_list|(
literal|"%s: running\n"
argument_list|,
name|symfile
operator|.
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|runcount
operator|>=
literal|0
condition|)
block|{
comment|/* BEGIN XXX (machine dependent?, delete ptrace, etc) */
if|if
condition|(
name|runmode
operator|==
name|SINGLESTEP
condition|)
name|delbp
argument_list|()
expr_stmt|;
comment|/* hardware handles single-stepping */
else|else
block|{
comment|/* continuing from a breakpoint is hard */
if|if
condition|(
operator|(
name|bkpt
operator|=
name|scanbkpt
argument_list|(
name|getpc
argument_list|()
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|execbkpt
argument_list|(
name|bkpt
argument_list|,
name|execsig
argument_list|)
expr_stmt|;
name|execsig
operator|=
literal|0
expr_stmt|;
block|}
name|setbp
argument_list|()
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|ptrace
argument_list|(
name|runmode
operator|==
name|CONTINUOUS
condition|?
name|PT_CONTINUE
else|:
name|PT_STEP
argument_list|,
name|pid
argument_list|,
operator|(
name|int
operator|*
operator|)
name|getpc
argument_list|()
argument_list|,
name|execsig
argument_list|)
expr_stmt|;
comment|/* END XXX */
comment|/* paranoia, SP_DATA usually sufficient, but this is easy */
name|cacheinval
argument_list|(
name|SP_INSTR
operator||
name|SP_DATA
argument_list|)
expr_stmt|;
name|bpwait
argument_list|()
expr_stmt|;
name|checkerr
argument_list|()
expr_stmt|;
name|execsig
operator|=
literal|0
expr_stmt|;
name|delbp
argument_list|()
expr_stmt|;
name|readregs
argument_list|()
expr_stmt|;
if|if
condition|(
name|signo
operator|!=
literal|0
operator|||
operator|(
name|bkpt
operator|=
name|scanbkpt
argument_list|(
name|getpc
argument_list|()
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|execsig
operator|=
name|signo
expr_stmt|;
name|rc
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* stopped by BPT instruction */
ifdef|#
directive|ifdef
name|DEBUG
name|adbprintf
argument_list|(
literal|"\n BPT code: comm=%s%8tstate=%d"
argument_list|,
name|bkpt
operator|->
name|comm
argument_list|,
name|bkpt
operator|->
name|state
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|dot
operator|=
name|bkpt
operator|->
name|loc
expr_stmt|;
switch|switch
condition|(
name|bkpt
operator|->
name|state
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
case|case
name|BKPT_SET
case|:
name|bkpt
operator|->
name|state
operator|=
name|BKPT_TRIPPED
expr_stmt|;
if|if
condition|(
operator|*
name|bkpt
operator|->
name|comm
operator|==
literal|'\n'
condition|)
break|break;
name|p
operator|=
name|lp
expr_stmt|;
name|command
argument_list|(
name|bkpt
operator|->
name|comm
argument_list|,
literal|':'
argument_list|)
expr_stmt|;
name|lp
operator|=
name|p
expr_stmt|;
if|if
condition|(
name|gavedot
operator|&&
name|edot
operator|==
literal|0
condition|)
comment|/* maybe dot==0 ??? */
break|break;
if|if
condition|(
operator|--
name|bkpt
operator|->
name|count
operator|==
literal|0
condition|)
break|break;
comment|/* FALLTHROUGH */
case|case
name|BKPT_TRIPPED
case|:
name|execbkpt
argument_list|(
name|bkpt
argument_list|,
name|execsig
argument_list|)
expr_stmt|;
name|execsig
operator|=
literal|0
expr_stmt|;
name|runcount
operator|++
expr_stmt|;
continue|continue;
default|default:
name|panic
argument_list|(
literal|"runpcs"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|bkpt
operator|->
name|count
operator|=
name|bkpt
operator|->
name|initcnt
expr_stmt|;
name|rc
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|rc
operator|)
return|;
block|}
end_function

begin_macro
name|endpcs
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|bkpt
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|pid
condition|)
block|{
operator|(
name|void
operator|)
name|ptrace
argument_list|(
name|PT_KILL
argument_list|,
name|pid
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
name|pid
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|bp
operator|=
name|bkpthead
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|state
operator|!=
name|BKPT_FREE
condition|)
name|bp
operator|->
name|state
operator|=
name|BKPT_SET
expr_stmt|;
block|}
name|bpstate
operator|=
name|BPOUT
expr_stmt|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|VFORK
end_ifdef

begin_macro
name|nullsig
argument_list|()
end_macro

begin_block
block|{  }
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_macro
name|setup
argument_list|()
end_macro

begin_block
block|{
name|cacheinval
argument_list|(
name|SP_INSTR
operator||
name|SP_DATA
argument_list|)
expr_stmt|;
comment|/* paranoia */
operator|(
name|void
operator|)
name|close
argument_list|(
name|symfile
operator|.
name|fd
argument_list|)
expr_stmt|;
name|symfile
operator|.
name|fd
operator|=
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|VFORK
define|#
directive|define
name|vfork
value|fork
endif|#
directive|endif
if|if
condition|(
operator|(
name|pid
operator|=
name|vfork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|ptrace
argument_list|(
name|PT_TRACE_ME
argument_list|,
literal|0
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
ifdef|#
directive|ifdef
name|VFORK
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGTRAP
argument_list|,
name|nullsig
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|sigint
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|sigquit
argument_list|)
expr_stmt|;
name|doexec
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|pid
operator|=
literal|0
expr_stmt|;
name|error
argument_list|(
name|NOFORK
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|bpwait
argument_list|()
expr_stmt|;
name|readregs
argument_list|()
expr_stmt|;
name|symfile
operator|.
name|fd
operator|=
name|open
argument_list|(
name|symfile
operator|.
name|name
argument_list|,
name|wtflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|errflag
condition|)
block|{
name|adbprintf
argument_list|(
literal|"%s: cannot execute\n"
argument_list|,
name|symfile
operator|.
name|name
argument_list|)
expr_stmt|;
name|endpcs
argument_list|()
expr_stmt|;
name|error
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|bpstate
operator|=
name|BPOUT
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Single step over a location containing a breakpoint.  */
end_comment

begin_macro
name|execbkpt
argument_list|(
argument|bp
argument_list|,
argument|execsig
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|bkpt
modifier|*
name|bp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|execsig
decl_stmt|;
end_decl_stmt

begin_block
block|{
ifdef|#
directive|ifdef
name|DEBUG
name|adbprintf
argument_list|(
literal|"exbkpt: %d\n"
argument_list|,
name|bp
operator|->
name|count
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|delbp
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ptrace
argument_list|(
name|PT_STEP
argument_list|,
name|pid
argument_list|,
operator|(
name|int
operator|*
operator|)
name|bp
operator|->
name|loc
argument_list|,
name|execsig
argument_list|)
expr_stmt|;
comment|/* XXX */
name|bp
operator|->
name|state
operator|=
name|BKPT_SET
expr_stmt|;
name|bpwait
argument_list|()
expr_stmt|;
name|checkerr
argument_list|()
expr_stmt|;
name|readregs
argument_list|()
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|char
name|separators
index|[]
init|=
literal|"<> \t\n"
decl_stmt|;
end_decl_stmt

begin_macro
name|doexec
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
name|char
modifier|*
name|argl
index|[
name|LINELEN
operator|/
literal|2
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|args
index|[
name|LINELEN
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
modifier|*
name|environ
decl_stmt|;
name|char
modifier|*
name|index
parameter_list|()
function_decl|;
name|ap
operator|=
name|argl
expr_stmt|;
name|p
operator|=
name|args
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
name|symfile
operator|.
name|name
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|c
operator|=
name|rdc
argument_list|()
condition|)
block|{
case|case
literal|'\n'
case|:
break|break;
case|case
literal|'<'
case|:
name|setfile
argument_list|(
literal|0
argument_list|,
name|O_RDONLY
argument_list|,
literal|0
argument_list|,
name|p
argument_list|,
literal|"open"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|setfile
argument_list|(
literal|1
argument_list|,
name|O_CREAT
operator||
name|O_WRONLY
argument_list|,
literal|0666
argument_list|,
name|p
argument_list|,
literal|"create"
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|ap
operator|=
name|p
expr_stmt|;
while|while
condition|(
name|index
argument_list|(
name|separators
argument_list|,
name|c
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
block|}
operator|*
name|p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|ap
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|c
operator|!=
literal|'\n'
condition|)
do|;
name|unreadc
argument_list|()
expr_stmt|;
operator|*
name|ap
operator|++
operator|=
literal|0
expr_stmt|;
name|execve
argument_list|(
name|symfile
operator|.
name|name
argument_list|,
name|argl
argument_list|,
name|environ
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|symfile
operator|.
name|name
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
specifier|static
name|int
name|setfile
parameter_list|(
name|fd
parameter_list|,
name|flags
parameter_list|,
name|mode
parameter_list|,
name|namebuf
parameter_list|,
name|err
parameter_list|)
name|int
name|fd
decl_stmt|,
name|flags
decl_stmt|,
name|mode
decl_stmt|;
name|char
modifier|*
name|namebuf
decl_stmt|,
decl|*
name|err
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|namebuf
decl_stmt|;
specifier|register
name|int
name|c
init|=
name|rdc
argument_list|()
decl_stmt|;
while|while
condition|(
name|index
argument_list|(
name|separators
argument_list|,
name|c
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|*
name|p
operator|++
operator|=
name|c
expr_stmt|;
name|c
operator|=
name|readchar
argument_list|()
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|namebuf
argument_list|,
name|flags
argument_list|,
name|mode
argument_list|)
operator|<
literal|0
condition|)
block|{
name|adbprintf
argument_list|(
literal|"%s: cannot %s\n"
argument_list|,
name|namebuf
argument_list|,
name|err
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
end_block

begin_function
name|struct
name|bkpt
modifier|*
name|scanbkpt
parameter_list|(
name|a
parameter_list|)
specifier|register
name|addr_t
name|a
decl_stmt|;
block|{
specifier|register
name|struct
name|bkpt
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|bkpthead
init|;
name|bp
operator|!=
name|NULL
condition|;
name|bp
operator|=
name|bp
operator|->
name|next
control|)
if|if
condition|(
name|bp
operator|->
name|state
operator|!=
name|BKPT_FREE
operator|&&
name|bp
operator|->
name|loc
operator|==
name|a
condition|)
break|break;
return|return
operator|(
name|bp
operator|)
return|;
block|}
end_function

begin_macro
name|bpwait
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|w
decl_stmt|;
name|union
name|wait
name|status
decl_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|w
operator|=
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|)
operator|!=
name|pid
operator|&&
name|w
operator|!=
operator|-
literal|1
condition|)
comment|/* void */
empty_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|intcatch
argument_list|)
expr_stmt|;
if|if
condition|(
name|w
operator|==
operator|-
literal|1
condition|)
block|{
name|pid
operator|=
literal|0
expr_stmt|;
name|errflag
operator|=
name|BADWAIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|WIFSTOPPED
argument_list|(
name|status
argument_list|)
condition|)
block|{
name|sigcode
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|signo
operator|=
name|status
operator|.
name|w_termsig
operator|)
operator|!=
literal|0
condition|)
name|sigprint
argument_list|()
expr_stmt|;
if|if
condition|(
name|status
operator|.
name|w_coredump
condition|)
block|{
name|prints
argument_list|(
literal|" - core dumped"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|corefile
operator|.
name|fd
argument_list|)
expr_stmt|;
name|setcore
argument_list|()
expr_stmt|;
block|}
name|pid
operator|=
literal|0
expr_stmt|;
name|bpstate
operator|=
name|BPOUT
expr_stmt|;
name|errflag
operator|=
name|ENDPCS
expr_stmt|;
block|}
else|else
block|{
name|signo
operator|=
name|status
operator|.
name|w_stopsig
expr_stmt|;
name|sigcode
operator|=
name|ptrace
argument_list|(
name|PT_READ_U
argument_list|,
name|pid
argument_list|,
operator|&
operator|(
operator|(
expr|struct
name|user
operator|*
operator|)
literal|0
operator|)
operator|->
name|u_code
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* XXX */
if|if
condition|(
name|signo
operator|!=
name|SIGTRAP
condition|)
name|sigprint
argument_list|()
expr_stmt|;
else|else
name|signo
operator|=
literal|0
expr_stmt|;
name|flushbuf
argument_list|()
expr_stmt|;
block|}
block|}
end_block

end_unit

