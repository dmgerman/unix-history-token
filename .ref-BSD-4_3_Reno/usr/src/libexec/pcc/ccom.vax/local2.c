begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)local2.c	1.39 (Berkeley) 5/11/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_define
define|#
directive|define
name|putstr
parameter_list|(
name|s
parameter_list|)
value|fputs((s), stdout)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|FORT
end_ifdef

begin_decl_stmt
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* a lot of the machine dependent parts of the second pass */
end_comment

begin_define
define|#
directive|define
name|BITMASK
parameter_list|(
name|n
parameter_list|)
value|((1L<<n)-1)
end_define

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|where
argument_list|(
argument|c
argument_list|)
end_macro

begin_block
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|filename
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|lineid
argument_list|(
argument|l
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* identify line l and file fn */
name|printf
argument_list|(
literal|"#	line %d, file %s\n"
argument_list|,
name|l
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|eobl2
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|OFFSZ
name|spoff
decl_stmt|;
comment|/* offset from stack pointer */
ifndef|#
directive|ifndef
name|FORT
specifier|extern
name|int
name|ftlab1
decl_stmt|,
name|ftlab2
decl_stmt|;
endif|#
directive|endif
name|spoff
operator|=
name|maxoff
expr_stmt|;
if|if
condition|(
name|spoff
operator|>=
name|AUTOINIT
condition|)
name|spoff
operator|-=
name|AUTOINIT
expr_stmt|;
name|spoff
operator|/=
name|SZCHAR
expr_stmt|;
name|SETOFF
argument_list|(
name|spoff
argument_list|,
literal|4
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORT
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"	.set	.F%d,%ld\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* SHOULD BE L%d ... ftnno but must change pc/f77 */
name|printf
argument_list|(
literal|"	.set	LF%d,%ld\n"
argument_list|,
name|ftnno
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|printf
argument_list|(
literal|"L%d:\n"
argument_list|,
name|ftlab1
argument_list|)
expr_stmt|;
if|if
condition|(
name|spoff
operator|!=
literal|0
condition|)
if|if
condition|(
name|spoff
operator|<
literal|64
condition|)
name|printf
argument_list|(
literal|"	subl2	$%ld,sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"	movab	-%ld(sp),sp\n"
argument_list|,
name|spoff
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	jbr 	L%d\n"
argument_list|,
name|ftlab2
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|maxargs
operator|=
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_struct
struct|struct
name|hoptab
block|{
name|int
name|opmask
decl_stmt|;
name|char
modifier|*
name|opstring
decl_stmt|;
block|}
name|ioptab
index|[]
init|=
block|{
name|PLUS
block|,
literal|"add"
block|,
name|MINUS
block|,
literal|"sub"
block|,
name|MUL
block|,
literal|"mul"
block|,
name|DIV
block|,
literal|"div"
block|,
name|OR
block|,
literal|"bis"
block|,
name|ER
block|,
literal|"xor"
block|,
name|AND
block|,
literal|"bic"
block|,
operator|-
literal|1
block|,
literal|""
block|}
struct|;
end_struct

begin_macro
name|hopcode
argument_list|(
argument|f
argument_list|,
argument|o
argument_list|)
end_macro

begin_block
block|{
comment|/* output the appropriate string from the above table */
specifier|register
name|struct
name|hoptab
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
name|o
operator|=
name|NOASG
name|o
expr_stmt|;
for|for
control|(
name|q
operator|=
name|ioptab
init|;
name|q
operator|->
name|opmask
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
if|if
condition|(
name|q
operator|->
name|opmask
operator|==
name|o
condition|)
block|{
name|printf
argument_list|(
literal|"%s%c"
argument_list|,
name|q
operator|->
name|opstring
argument_list|,
name|tolower
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
name|cerror
argument_list|(
literal|"no hoptab for %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|char
modifier|*
name|rnames
index|[]
init|=
block|{
comment|/* keyed to register number tokens */
literal|"r0"
block|,
literal|"r1"
block|,
literal|"r2"
block|,
literal|"r3"
block|,
literal|"r4"
block|,
literal|"r5"
block|,
literal|"r6"
block|,
literal|"r7"
block|,
literal|"r8"
block|,
literal|"r9"
block|,
literal|"r10"
block|,
literal|"r11"
block|,
literal|"ap"
block|,
literal|"fp"
block|,
literal|"sp"
block|,
literal|"pc"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|rstatus
index|[]
init|=
block|{
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
operator||
name|STAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|,
name|SAREG
block|, 	}
decl_stmt|;
end_decl_stmt

begin_macro
name|tlen
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
return|return
operator|(
literal|1
operator|)
return|;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
return|return
operator|(
name|SZSHORT
operator|/
name|SZCHAR
operator|)
return|;
case|case
name|DOUBLE
case|:
return|return
operator|(
name|SZDOUBLE
operator|/
name|SZCHAR
operator|)
return|;
default|default:
return|return
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|mixtypes
argument_list|(
argument|p
argument_list|,
argument|q
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|TWORD
name|tp
decl_stmt|,
name|tq
decl_stmt|;
name|tp
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|tq
operator|=
name|q
operator|->
name|in
operator|.
name|type
expr_stmt|;
return|return
operator|(
operator|(
name|tp
operator|==
name|FLOAT
operator|||
name|tp
operator|==
name|DOUBLE
operator|)
operator|!=
operator|(
name|tq
operator|==
name|FLOAT
operator|||
name|tq
operator|==
name|DOUBLE
operator|)
operator|)
return|;
block|}
end_block

begin_macro
name|prtype
argument_list|(
argument|n
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|n
decl_stmt|;
end_decl_stmt

begin_block
block|{
switch|switch
condition|(
name|n
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|DOUBLE
case|:
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
return|return;
case|case
name|FLOAT
case|:
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
return|return;
case|case
name|LONG
case|:
case|case
name|ULONG
case|:
case|case
name|INT
case|:
case|case
name|UNSIGNED
case|:
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
case|case
name|SHORT
case|:
case|case
name|USHORT
case|:
name|putchar
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
return|return;
case|case
name|CHAR
case|:
case|case
name|UCHAR
case|:
name|putchar
argument_list|(
literal|'b'
argument_list|)
expr_stmt|;
return|return;
default|default:
if|if
condition|(
operator|!
name|ISPTR
argument_list|(
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"zzzcode- bad type"
argument_list|)
expr_stmt|;
else|else
block|{
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|zzzcode
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|m
decl_stmt|;
name|int
name|val
decl_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'N'
case|:
comment|/* logical ops, turned into 0-1 */
comment|/* use register given by register 1 */
name|cbgen
argument_list|(
literal|0
argument_list|,
name|m
operator|=
name|getlab
argument_list|()
argument_list|,
literal|'I'
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|p
operator|->
name|bn
operator|.
name|label
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	clrl	%s\n"
argument_list|,
name|rnames
index|[
name|getlr
argument_list|(
name|p
argument_list|,
literal|'1'
argument_list|)
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
name|deflab
argument_list|(
name|m
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'P'
case|:
name|cbgen
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|,
name|p
operator|->
name|bn
operator|.
name|label
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'A'
case|:
case|case
literal|'V'
case|:
name|sconv
argument_list|(
name|p
argument_list|,
name|c
operator|==
literal|'V'
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'G'
case|:
comment|/* i *= f; asgops with int lhs and float rhs */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|int
name|rt
decl_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|s
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|rt
operator|=
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|rt
expr_stmt|;
name|zzzcode
argument_list|(
name|s
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|hopcode
argument_list|(
name|rt
operator|==
name|FLOAT
condition|?
literal|'F'
else|:
literal|'D'
argument_list|,
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"2\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|right
operator|=
name|resc
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|type
operator|=
name|l
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|zzzcode
argument_list|(
name|s
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|s
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
case|case
literal|'J'
case|:
comment|/* unsigned DIV/MOD with constant divisors */
block|{
specifier|register
name|int
name|ck
init|=
name|INAREG
decl_stmt|;
name|int
name|label1
decl_stmt|,
name|label2
decl_stmt|;
comment|/* case constant<= 1 is handled by optim() in pass 1 */
comment|/* case constant< 0x80000000 is handled in table */
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
comment|/* case DIV: handled in optim2() */
case|case
name|MOD
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|==
name|resc
operator|->
name|tn
operator|.
name|rval
condition|)
goto|goto
name|asgmod
goto|;
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"movl\tAL,A1\n\tcmpl\tA1,AR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjlssu\tL%d\n"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tsubl2\tAR,A1\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASG
name|DIV
case|:
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|label2
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"cmpl\tAL,AR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjgequ\tL%d\n"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tmovl\t$1,AL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjbr\tL%d\nL%d:\n"
argument_list|,
name|label2
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tclrl\tAL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|label2
argument_list|)
expr_stmt|;
break|break;
case|case
name|ASG
name|MOD
case|:
name|asgmod
label|:
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"cmpl\tAL,AR\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\tjlssu\tL%d\n"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|expand
argument_list|(
name|p
argument_list|,
name|ck
argument_list|,
literal|"\tsubl2\tAR,AL\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"L%d:"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
break|break;
block|}
return|return;
block|}
case|case
literal|'B'
case|:
comment|/* get oreg value in temp register for left shift */
block|{
specifier|register
name|NODE
modifier|*
name|r
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|r
argument_list|)
operator|==
name|SZINT
operator|/
name|SZCHAR
operator|&&
name|r
operator|->
name|in
operator|.
name|type
operator|!=
name|FLOAT
condition|)
name|putstr
argument_list|(
literal|"movl"
argument_list|)
expr_stmt|;
else|else
block|{
name|putstr
argument_list|(
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
literal|"movz"
else|:
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
block|}
return|return;
block|}
case|case
literal|'C'
case|:
comment|/* num words pushed on arg stack */
block|{
specifier|extern
name|int
name|gc_numbytes
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|gc_numbytes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$%d"
argument_list|,
name|gc_numbytes
operator|/
operator|(
name|SZLONG
operator|/
name|SZCHAR
operator|)
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'D'
case|:
comment|/* INCR and DECR */
name|zzzcode
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|,
literal|'A'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
case|case
literal|'E'
case|:
comment|/* INCR and DECR, FOREFF */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
literal|1
condition|)
block|{
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"inc"
else|:
literal|"dec"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
block|}
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"add"
else|:
literal|"sub"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'2'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'F'
case|:
comment|/* register type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
specifier|register
name|int
name|ty
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|ty
operator|=
name|n
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|ty
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|==
name|DOUBLE
condition|)
name|putchar
argument_list|(
literal|'d'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ty
operator|==
name|FLOAT
condition|)
name|putchar
argument_list|(
literal|'f'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'L'
case|:
comment|/* type of left operand */
case|case
literal|'R'
case|:
comment|/* type of right operand */
block|{
specifier|register
name|NODE
modifier|*
name|n
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
name|n
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|printf
argument_list|(
literal|"->%d<-"
argument_list|,
name|n
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|n
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'Z'
case|:
comment|/* AND for CC with ICON -- lval is complemented */
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|r
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
literal|1
operator|<<
name|tlen
argument_list|(
name|l
argument_list|)
operator|*
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
operator|~
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
if|if
condition|(
operator|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|CHAR
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|SHORT
operator|)
operator|&&
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
operator|~
name|m
operator|)
condition|)
block|{
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|resc
operator|->
name|tn
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|l
operator|=
name|resc
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|UCHAR
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|USHORT
condition|)
comment|/* remove trash left over from complementing */
name|r
operator|->
name|tn
operator|.
name|lval
operator|&=
name|m
expr_stmt|;
name|putstr
argument_list|(
literal|"bit"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t$%ld"
argument_list|,
name|r
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'U'
case|:
comment|/* 32 - n, for unsigned right shifts */
name|printf
argument_list|(
literal|"$%d"
argument_list|,
literal|32
operator|-
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'T'
case|:
comment|/* rounded structure length for arguments */
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
name|SETOFF
argument_list|(
name|size
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"$%d"
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return;
block|}
case|case
literal|'S'
case|:
comment|/* structure assignment */
name|stasg
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal zzzcode"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|stasg
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
specifier|register
name|size
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STASG
condition|)
block|{
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
block|{
comment|/* store an arg into a temporary */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
else|else
name|cerror
argument_list|(
literal|"STASG bad"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|NAME
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
condition|)
name|cerror
argument_list|(
literal|"STASG-r"
argument_list|)
expr_stmt|;
name|size
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|>
literal|65535
condition|)
name|cerror
argument_list|(
literal|"structure size<0=0 or>65535"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|size
condition|)
block|{
case|case
literal|1
case|:
name|putstr
argument_list|(
literal|"	movb	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|putstr
argument_list|(
literal|"	movw	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
name|putstr
argument_list|(
literal|"	movl	"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|8
case|:
name|putstr
argument_list|(
literal|"	movq	"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"	movc3	$%d,"
argument_list|,
name|size
argument_list|)
expr_stmt|;
break|break;
block|}
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STASG
condition|)
block|{
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
literal|",(sp)\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|NAME
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
condition|)
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
block|}
end_block

begin_function
name|NODE
modifier|*
name|makearg
parameter_list|(
name|ty
parameter_list|)
name|int
name|ty
decl_stmt|;
block|{
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* build a -(sp) operand */
name|p
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|REG
expr_stmt|;
comment|/* the type needn't be right, just consistent */
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|SP
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ASG
name|MINUS
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|ty
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|name
operator|=
literal|""
expr_stmt|;
comment|/* size of floating argument is always 2 */
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
literal|1
operator|+
operator|(
name|ty
operator|==
name|FLOAT
operator|||
name|ty
operator|==
name|DOUBLE
operator|)
operator|)
operator|*
operator|(
name|SZINT
operator|/
name|SZCHAR
operator|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
expr_stmt|;
name|p
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|MUL
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
end_function

begin_expr_stmt
name|sconv
argument_list|(
name|p
argument_list|,
name|forarg
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|int
name|m
decl_stmt|,
name|val
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
name|r
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'R'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|ASSIGN
condition|)
name|l
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|m
operator|=
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
if|if
condition|(
name|forarg
condition|)
name|l
operator|=
name|makearg
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|l
operator|=
name|resc
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|m
expr_stmt|;
name|r
operator|=
name|getlr
argument_list|(
name|p
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* OPLTYPE */
name|m
operator|=
operator|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|?
name|r
operator|->
name|in
operator|.
name|type
else|:
name|INT
operator|)
expr_stmt|;
if|if
condition|(
name|forarg
condition|)
name|l
operator|=
name|makearg
argument_list|(
name|m
argument_list|)
expr_stmt|;
else|else
name|l
operator|=
name|resc
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|==
literal|0
operator|&&
operator|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
operator|!
name|forarg
operator|)
condition|)
block|{
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|DOUBLE
expr_stmt|;
name|putstr
argument_list|(
literal|"clr"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<
literal|0
operator|&&
name|r
operator|->
name|tn
operator|.
name|lval
operator|>=
operator|-
literal|63
condition|)
block|{
name|putstr
argument_list|(
literal|"mneg"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
goto|goto
name|ops
goto|;
block|}
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<
literal|0
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
operator|>=
operator|-
literal|128
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|>=
operator|-
literal|32768
condition|?
name|SHORT
else|:
name|INT
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|63
condition|?
name|INT
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|127
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|32767
condition|?
name|SHORT
else|:
name|INT
operator|)
operator|)
expr_stmt|;
else|else
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|63
condition|?
name|INT
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|127
condition|?
name|CHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|255
condition|?
name|UCHAR
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|32767
condition|?
name|SHORT
else|:
operator|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|<=
literal|65535
condition|?
name|USHORT
else|:
name|INT
operator|)
operator|)
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|forarg
operator|&&
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|INT
condition|)
block|{
name|putstr
argument_list|(
literal|"pushl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|forarg
operator|&&
name|tlen
argument_list|(
name|r
argument_list|)
operator|==
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
name|putstr
argument_list|(
literal|"pushl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|putstr
argument_list|(
literal|"moval\t"
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
operator|!
operator|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|)
operator|&&
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
comment|/* 		 * Because registers must always contain objects 		 * of the same width as INTs, we may have to 		 * perform two conversions to get an INT.  Can 		 * the conversions be collapsed into one? 		 */
if|if
condition|(
name|m
operator|=
name|collapsible
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|m
expr_stmt|;
else|else
block|{
comment|/* two steps are required */
name|NODE
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|forarg
condition|)
block|{
name|x
operator|=
name|resc
expr_stmt|;
name|x
operator|->
name|in
operator|.
name|type
operator|=
name|l
operator|->
name|in
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
operator|&
name|resc
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|x
operator|=
operator|*
name|l
expr_stmt|;
block|}
if|if
condition|(
name|tlen
argument_list|(
name|x
argument_list|)
operator|>
name|tlen
argument_list|(
name|r
argument_list|)
operator|&&
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|putstr
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|r
operator|=
name|x
expr_stmt|;
block|}
name|l
operator|->
name|in
operator|.
name|type
operator|=
operator|(
name|ISUNSIGNED
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
name|UNSIGNED
else|:
name|INT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|forarg
operator|||
name|l
operator|==
name|resc
operator|)
operator|&&
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
operator|&&
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
comment|/* two steps needed here too */
name|NODE
modifier|*
name|x
decl_stmt|;
if|if
condition|(
name|forarg
condition|)
block|{
name|x
operator|=
name|resc
expr_stmt|;
name|x
operator|->
name|in
operator|.
name|type
operator|=
name|l
operator|->
name|in
operator|.
name|type
expr_stmt|;
block|}
else|else
block|{
name|x
operator|=
operator|&
name|resc
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|x
operator|=
operator|*
name|l
expr_stmt|;
block|}
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
name|r
operator|=
name|x
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
operator|(
name|ISUNSIGNED
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
condition|?
name|UNSIGNED
else|:
name|INT
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|ULONG
operator|)
operator|&&
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
name|int
name|label1
decl_stmt|;
name|NODE
modifier|*
name|x
init|=
name|NULL
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
if|if
condition|(
name|forarg
condition|)
else|#
directive|else
if|if
condition|(
name|forarg
operator|||
name|l
operator|==
name|resc
condition|)
endif|#
directive|endif
block|{
comment|/* compute in register, convert to double when done */
name|x
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|resc
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|x
operator|->
name|in
operator|.
name|type
expr_stmt|;
block|}
name|label1
operator|=
name|getlab
argument_list|()
expr_stmt|;
name|putstr
argument_list|(
literal|"cvtl"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n\tjgeq\tL%d\n\tadd"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"2\t$0"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"4.294967296e9,"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\nL%d:"
argument_list|,
name|label1
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
if|if
condition|(
operator|!
name|forarg
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|forarg
operator|&&
operator|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|l
operator|!=
name|resc
operator|)
condition|)
endif|#
directive|endif
goto|goto
name|cleanup
goto|;
if|if
condition|(
name|x
operator|==
name|NULL
condition|)
name|cerror
argument_list|(
literal|"sconv botch"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|x
condition|)
block|{
name|r
operator|=
operator|&
name|resc
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|l
expr_stmt|;
block|}
else|else
block|{
name|r
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|x
expr_stmt|;
block|}
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|DOUBLE
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|)
operator|&&
operator|(
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|UCHAR
operator|||
name|r
operator|->
name|in
operator|.
name|type
operator|==
name|USHORT
operator|)
condition|)
block|{
comment|/* skip unnecessary unsigned to floating conversion */
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
if|if
condition|(
name|forarg
condition|)
else|#
directive|else
if|if
condition|(
name|forarg
operator|||
name|l
operator|==
name|resc
condition|)
endif|#
directive|endif
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|DOUBLE
expr_stmt|;
name|putstr
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"l\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|resc
condition|)
block|{
name|r
operator|=
operator|&
name|resc
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|l
expr_stmt|;
block|}
else|else
name|r
operator|=
name|resc
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
block|}
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
if|if
condition|(
name|forarg
operator|&&
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
else|#
directive|else
if|if
condition|(
operator|(
name|forarg
operator|||
name|l
operator|==
name|resc
operator|)
operator|&&
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
endif|#
directive|endif
block|{
comment|/* perform an implicit conversion to double */
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|DOUBLE
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|type
operator|!=
name|FLOAT
operator|&&
name|r
operator|->
name|in
operator|.
name|type
operator|!=
name|CHAR
operator|&&
name|r
operator|->
name|in
operator|.
name|type
operator|!=
name|SHORT
condition|)
block|{
comment|/* trim bits from the mantissa */
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"f\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|resc
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"\n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
name|resc
condition|)
block|{
name|r
operator|=
operator|&
name|resc
index|[
literal|1
index|]
expr_stmt|;
operator|*
name|r
operator|=
operator|*
name|l
expr_stmt|;
block|}
else|else
name|r
operator|=
name|resc
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|FLOAT
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|forarg
operator|&&
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
name|putstr
argument_list|(
literal|"pushl\t"
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
goto|goto
name|cleanup
goto|;
block|}
name|putstr
argument_list|(
literal|"mov"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FORT
if|if
condition|(
name|Oflag
condition|)
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
name|putchar
argument_list|(
literal|'q'
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
name|putchar
argument_list|(
literal|'l'
argument_list|)
expr_stmt|;
else|else
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|FORT
goto|goto
name|ops
goto|;
block|}
elseif|else
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|>
name|tlen
argument_list|(
name|r
argument_list|)
operator|&&
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
name|putstr
argument_list|(
literal|"movz"
argument_list|)
expr_stmt|;
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
block|}
else|else
name|putstr
argument_list|(
literal|"cvt"
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|prtype
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ops
label|:
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|','
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|cleanup
label|:
if|if
condition|(
name|forarg
condition|)
name|tfree
argument_list|(
name|l
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * collapsible(dest, src) -- if a conversion with a register destination  *	can be accomplished in one instruction, return the type of src  *	that will do the job correctly; otherwise return 0.  Note that  *	a register must always end up having type INT or UNSIGNED.  */
end_comment

begin_function
name|int
name|collapsible
parameter_list|(
name|dest
parameter_list|,
name|src
parameter_list|)
name|NODE
modifier|*
name|dest
decl_stmt|,
decl|*
name|src
decl_stmt|;
end_function

begin_block
block|{
name|int
name|st
init|=
name|src
operator|->
name|in
operator|.
name|type
decl_stmt|;
name|int
name|dt
init|=
name|dest
operator|->
name|in
operator|.
name|type
decl_stmt|;
name|int
name|newt
init|=
literal|0
decl_stmt|;
comment|/* 	 * Are there side effects of evaluating src? 	 * If the derived type will not be the same size as src, 	 * we may have to use two steps. 	 */
if|if
condition|(
name|tlen
argument_list|(
name|src
argument_list|)
operator|>
name|tlen
argument_list|(
name|dest
argument_list|)
condition|)
block|{
if|if
condition|(
name|tshape
argument_list|(
name|src
argument_list|,
name|STARREG
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|src
operator|->
name|in
operator|.
name|op
operator|==
name|OREG
operator|&&
name|R2TEST
argument_list|(
name|src
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * Can we get an object of dest's type by punning src? 	 * Praises be to great Cthulhu for little-endian machines... 	 */
if|if
condition|(
name|st
operator|==
name|CHAR
operator|&&
name|dt
operator|==
name|USHORT
condition|)
comment|/* 		 * Special case -- we must sign-extend to 16 bits. 		 */
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|tlen
argument_list|(
name|src
argument_list|)
operator|<
name|tlen
argument_list|(
name|dest
argument_list|)
condition|)
name|newt
operator|=
name|st
expr_stmt|;
else|else
name|newt
operator|=
name|dt
expr_stmt|;
return|return
operator|(
name|newt
operator|)
return|;
block|}
end_block

begin_macro
name|rmove
argument_list|(
argument|rt
argument_list|,
argument|rs
argument_list|,
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|printf
argument_list|(
literal|"	%s	%s,%s\n"
argument_list|,
ifdef|#
directive|ifdef
name|FORT
operator|!
name|Oflag
condition|?
operator|(
name|t
operator|==
name|DOUBLE
condition|?
literal|"movq"
else|:
literal|"movl"
operator|)
else|:
endif|#
directive|endif
operator|(
name|t
operator|==
name|FLOAT
condition|?
literal|"movf"
else|:
operator|(
name|t
operator|==
name|DOUBLE
condition|?
literal|"movd"
else|:
literal|"movl"
operator|)
operator|)
argument_list|,
name|rnames
index|[
name|rs
index|]
argument_list|,
name|rnames
index|[
name|rt
index|]
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|struct
name|respref
name|respref
index|[]
init|=
block|{
name|INTAREG
operator||
name|INTBREG
block|,
name|INTAREG
operator||
name|INTBREG
block|,
name|INAREG
operator||
name|INBREG
block|,
name|INAREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
operator||
name|SNAME
operator||
name|SCON
block|,
name|INTEMP
block|,
name|INTEMP
block|,
name|FORARG
block|,
name|FORARG
block|,
name|INTEMP
block|,
name|INTAREG
operator||
name|INAREG
operator||
name|INTBREG
operator||
name|INBREG
operator||
name|SOREG
operator||
name|STARREG
operator||
name|STARNM
block|,
literal|0
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_macro
name|setregs
argument_list|()
end_macro

begin_block
block|{
comment|/* set up temporary registers */
name|fregs
operator|=
literal|6
expr_stmt|;
comment|/* tbl- 6 free regs on VAX (0-5) */
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|rewfld
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|callreg
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|R0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|base
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|ICON
operator|&&
name|p
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
return|return
operator|(
literal|100
operator|)
return|;
comment|/* ie no base reg */
if|if
condition|(
name|o
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|PLUS
operator|||
name|o
operator|==
name|MINUS
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|1
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|INCR
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|2
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|ASG
name|MINUS
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
literal|4
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|||
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|+
literal|0200
operator|*
operator|(
literal|1
operator|+
literal|2
operator|)
operator|)
return|;
if|if
condition|(
name|o
operator|==
name|NAME
condition|)
return|return
operator|(
literal|100
operator|+
literal|0200
operator|*
literal|1
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|offset
argument_list|(
name|p
argument_list|,
name|tyl
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|tyl
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|tyl
operator|==
literal|1
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
condition|)
return|return
operator|(
name|p
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|LS
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
operator|(
literal|1
operator|<<
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|)
operator|==
name|tyl
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
if|if
condition|(
name|tyl
operator|==
literal|2
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|PLUS
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|INT
operator|||
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|UNSIGNED
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|==
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|rval
condition|)
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|makeor2
argument_list|(
name|p
argument_list|,
name|q
argument_list|,
name|b
argument_list|,
name|o
argument_list|)
specifier|register
name|NODE
operator|*
name|p
operator|,
operator|*
name|q
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|b
decl_stmt|,
name|o
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|NODE
modifier|*
name|t
decl_stmt|;
name|NODE
modifier|*
name|f
decl_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|f
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* have to free this subtree later */
comment|/* init base */
switch|switch
condition|(
name|q
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
case|case
name|REG
case|:
case|case
name|OREG
case|:
case|case
name|NAME
case|:
name|t
operator|=
name|q
expr_stmt|;
break|break;
case|case
name|MINUS
case|:
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|=
operator|-
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
case|case
name|PLUS
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|right
expr_stmt|;
break|break;
case|case
name|INCR
case|:
case|case
name|ASG
name|MINUS
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
case|case
name|UNARY
name|MUL
case|:
name|t
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"illegal makeor2"
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|t
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
block|{
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NCHNAM
condition|;
operator|++
name|i
control|)
name|p
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
operator|=
name|t
operator|->
name|in
operator|.
name|name
index|[
name|i
index|]
expr_stmt|;
block|}
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|name
operator|=
name|t
operator|->
name|in
operator|.
name|name
expr_stmt|;
endif|#
directive|endif
comment|/* init offset */
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|R2PACK
argument_list|(
operator|(
name|b
operator|&
literal|0177
operator|)
argument_list|,
name|o
argument_list|,
operator|(
name|b
operator|>>
literal|7
operator|)
argument_list|)
expr_stmt|;
name|tfree
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|canaddr
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|ICON
operator|||
name|o
operator|==
name|OREG
operator|||
operator|(
name|o
operator|==
name|UNARY
name|MUL
operator|&&
name|shumul
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|flshape
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
init|=
name|p
operator|->
name|in
operator|.
name|op
decl_stmt|;
return|return
operator|(
name|o
operator|==
name|REG
operator|||
name|o
operator|==
name|NAME
operator|||
name|o
operator|==
name|ICON
operator|||
operator|(
name|o
operator|==
name|OREG
operator|&&
operator|(
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|||
name|tlen
argument_list|(
name|p
argument_list|)
operator|==
literal|1
operator|)
operator|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* INTEMP shapes must not contain any temporary registers */
end_comment

begin_expr_stmt
name|shtemp
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|r
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STARG
condition|)
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|REG
case|:
return|return
operator|(
operator|!
name|istreg
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
return|;
case|case
name|OREG
case|:
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
if|if
condition|(
name|istreg
argument_list|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|r
operator|=
name|R2UPK2
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
operator|!
name|istreg
argument_list|(
name|r
argument_list|)
operator|)
return|;
case|case
name|UNARY
name|MUL
case|:
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|UNARY
name|MUL
operator|&&
name|shtemp
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
if|if
condition|(
name|optype
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
operator|!=
name|LTYPE
condition|)
return|return
operator|(
literal|0
operator|)
return|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|shumul
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|;
specifier|extern
name|int
name|xdebug
decl_stmt|;
if|if
condition|(
name|xdebug
condition|)
block|{
name|int
name|val
decl_stmt|;
name|printf
argument_list|(
literal|"shumul:\n"
argument_list|)
expr_stmt|;
name|eprint
argument_list|(
name|p
argument_list|,
literal|0
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|val
argument_list|)
expr_stmt|;
block|}
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|NAME
operator|||
operator|(
name|o
operator|==
name|OREG
operator|&&
operator|!
name|R2TEST
argument_list|(
name|p
operator|->
name|tn
operator|.
name|rval
argument_list|)
operator|)
operator|||
name|o
operator|==
name|ICON
condition|)
return|return
operator|(
name|STARNM
operator|)
return|;
if|if
condition|(
operator|(
name|o
operator|==
name|INCR
operator|||
name|o
operator|==
name|ASG
name|MINUS
operator|)
operator|&&
operator|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|REG
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|)
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
operator||
name|PTR
case|:
case|case
name|UCHAR
operator||
name|PTR
case|:
name|o
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|SHORT
operator||
name|PTR
case|:
case|case
name|USHORT
operator||
name|PTR
case|:
name|o
operator|=
literal|2
expr_stmt|;
break|break;
case|case
name|INT
operator||
name|PTR
case|:
case|case
name|UNSIGNED
operator||
name|PTR
case|:
case|case
name|LONG
operator||
name|PTR
case|:
case|case
name|ULONG
operator||
name|PTR
case|:
case|case
name|FLOAT
operator||
name|PTR
case|:
name|o
operator|=
literal|4
expr_stmt|;
break|break;
case|case
name|DOUBLE
operator||
name|PTR
case|:
name|o
operator|=
literal|8
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|ISPTR
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
name|ISPTR
argument_list|(
name|DECREF
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
argument_list|)
condition|)
block|{
name|o
operator|=
literal|4
expr_stmt|;
break|break;
block|}
else|else
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|==
name|o
condition|?
name|STARREG
else|:
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|adrcon
argument_list|(
argument|val
argument_list|)
end_macro

begin_decl_stmt
name|CONSZ
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|conput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ICON
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal conput"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|insput
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|cerror
argument_list|(
literal|"insput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|upput
argument_list|(
argument|p
argument_list|,
argument|size
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|size
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|size
operator|==
name|SZLONG
operator|&&
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|REG
condition|)
block|{
name|putstr
argument_list|(
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
name|cerror
argument_list|(
literal|"upput"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|adrput
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|int
name|r
decl_stmt|;
comment|/* output an address, with offsets, from p */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FLD
condition|)
block|{
name|p
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|NAME
case|:
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|ICON
case|:
comment|/* addressable value of the constant */
name|putchar
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
case|case
name|REG
case|:
name|putstr
argument_list|(
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|OREG
case|:
name|r
operator|=
name|p
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
if|if
condition|(
name|R2TEST
argument_list|(
name|r
argument_list|)
condition|)
block|{
comment|/* double indexing */
specifier|register
name|int
name|flags
decl_stmt|;
name|flags
operator|=
name|R2UPK3
argument_list|(
name|r
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|1
condition|)
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|4
condition|)
name|putchar
argument_list|(
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|R2UPK1
argument_list|(
name|r
argument_list|)
operator|!=
literal|100
condition|)
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|R2UPK1
argument_list|(
name|r
argument_list|)
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
literal|2
condition|)
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[%s]"
argument_list|,
name|rnames
index|[
name|R2UPK2
argument_list|(
name|r
argument_list|)
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|r
operator|==
name|AP
condition|)
block|{
comment|/* in the argument region */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|werror
argument_list|(
literal|"bad arg temp"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
name|putstr
argument_list|(
literal|"(ap)"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
operator|||
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|acon
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(%s)"
argument_list|,
name|rnames
index|[
name|p
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|)
expr_stmt|;
return|return;
case|case
name|UNARY
name|MUL
case|:
comment|/* STARNM or STARREG found */
if|if
condition|(
name|tshape
argument_list|(
name|p
argument_list|,
name|STARNM
argument_list|)
condition|)
block|{
name|putchar
argument_list|(
literal|'*'
argument_list|)
expr_stmt|;
name|adrput
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* STARREG - really auto inc or dec */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|!=
name|tlen
argument_list|(
name|p
argument_list|)
condition|)
name|cerror
argument_list|(
literal|"adrput: bad auto-increment/decrement"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s(%s)%s"
argument_list|,
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|""
else|:
literal|"-"
operator|)
argument_list|,
name|rnames
index|[
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
index|]
argument_list|,
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
literal|"+"
else|:
literal|""
operator|)
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|rval
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|tn
operator|.
name|rval
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
operator|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|INCR
condition|?
operator|-
name|q
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
else|:
literal|0
operator|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|#
directive|else
name|p
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
endif|#
directive|endif
name|tfree
argument_list|(
name|q
argument_list|)
expr_stmt|;
block|}
return|return;
default|default:
name|cerror
argument_list|(
literal|"illegal address"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
end_block

begin_expr_stmt
name|acon
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* print out a constant */
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
else|else
block|{
ifndef|#
directive|ifndef
name|FLEXNAMES
name|printf
argument_list|(
literal|"%.8s"
argument_list|,
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
else|#
directive|else
name|putstr
argument_list|(
name|p
operator|->
name|in
operator|.
name|name
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|tn
operator|.
name|lval
operator|!=
literal|0
condition|)
block|{
name|putchar
argument_list|(
literal|'+'
argument_list|)
expr_stmt|;
name|printf
argument_list|(
name|CONFMT
argument_list|,
name|p
operator|->
name|tn
operator|.
name|lval
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|genscall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* structure valued call */
return|return
operator|(
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|int
name|gc_numbytes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_expr_stmt
name|gencall
argument_list|(
name|p
argument_list|,
name|cookie
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* generate the call given by p */
specifier|register
name|NODE
modifier|*
name|p1
decl_stmt|;
specifier|register
name|int
name|temp
decl_stmt|,
name|temp1
decl_stmt|;
specifier|register
name|int
name|m
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
name|temp
operator|=
name|argsize
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
else|else
name|temp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|STCALL
operator|||
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|STCALL
condition|)
block|{
comment|/* set aside room for structure return */
if|if
condition|(
name|p
operator|->
name|stn
operator|.
name|stsize
operator|>
name|temp
condition|)
name|temp1
operator|=
name|p
operator|->
name|stn
operator|.
name|stsize
expr_stmt|;
else|else
name|temp1
operator|=
name|temp
expr_stmt|;
block|}
if|if
condition|(
name|temp
operator|>
name|maxargs
condition|)
name|maxargs
operator|=
name|temp
expr_stmt|;
name|SETOFF
argument_list|(
name|temp1
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
condition|)
block|{
comment|/* make temp node, put offset in, and generate args */
name|genargs
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
block|}
name|p1
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|REG
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|OREG
operator|||
name|R2TEST
argument_list|(
name|p1
operator|->
name|tn
operator|.
name|rval
argument_list|)
condition|)
block|{
if|if
condition|(
name|p1
operator|->
name|in
operator|.
name|op
operator|!=
name|NAME
condition|)
block|{
name|order
argument_list|(
name|p1
argument_list|,
name|INAREG
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* tbl 	setup gc_numbytes so reference to ZC works */
name|gc_numbytes
operator|=
name|temp
operator|&
operator|(
literal|0x3ff
operator|)
expr_stmt|;
comment|/* tbl */
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UNARY
name|CALL
expr_stmt|;
name|m
operator|=
name|match
argument_list|(
name|p
argument_list|,
name|INTAREG
operator||
name|INTBREG
argument_list|)
expr_stmt|;
comment|/* compensate for deficiency in 'ret' instruction ... wah,kre */
comment|/* (plus in assignment to gc_numbytes above, for neatness only) */
if|if
condition|(
name|temp
operator|>=
literal|1024
condition|)
name|printf
argument_list|(
literal|"	addl2	$%d,sp\n"
argument_list|,
operator|(
name|temp
operator|&
operator|(
operator|~
literal|0x3ff
operator|)
operator|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|m
operator|!=
name|MDONE
operator|)
return|;
block|}
end_block

begin_comment
comment|/* tbl */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ccbranches
index|[]
init|=
block|{
literal|"eql"
block|,
literal|"neq"
block|,
literal|"leq"
block|,
literal|"lss"
block|,
literal|"geq"
block|,
literal|"gtr"
block|,
literal|"lequ"
block|,
literal|"lssu"
block|,
literal|"gequ"
block|,
literal|"gtru"
block|, 	}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* tbl */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|cbgen
argument_list|(
argument|o
argument_list|,
argument|lab
argument_list|,
argument|mode
argument_list|)
end_macro

begin_block
block|{
comment|/*   printf conditional and unconditional branches */
if|if
condition|(
name|o
operator|!=
literal|0
operator|&&
operator|(
name|o
operator|<
name|EQ
operator|||
name|o
operator|>
name|UGT
operator|)
condition|)
name|cerror
argument_list|(
literal|"bad conditional branch: %s"
argument_list|,
name|opst
index|[
name|o
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	j%s	L%d\n"
argument_list|,
name|o
operator|==
literal|0
condition|?
literal|"br"
else|:
name|ccbranches
index|[
name|o
operator|-
name|EQ
index|]
argument_list|,
name|lab
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|nextcook
argument_list|(
argument|p
argument_list|,
argument|cookie
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* we have failed to match p with cookie; try another */
if|if
condition|(
name|cookie
operator|==
name|FORREW
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* hopeless! */
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
operator|)
condition|)
return|return
operator|(
name|INTAREG
operator||
name|INTBREG
operator|)
return|;
if|if
condition|(
operator|!
operator|(
name|cookie
operator|&
name|INTEMP
operator|)
operator|&&
name|asgop
argument_list|(
name|p
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
return|return
operator|(
name|INTEMP
operator||
name|INAREG
operator||
name|INTAREG
operator||
name|INTBREG
operator||
name|INBREG
operator|)
return|;
return|return
operator|(
name|FORREW
operator|)
return|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_macro
name|lastchance
argument_list|(
argument|p
argument_list|,
argument|cook
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* forget it! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|optim2
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* do local tree transformations and optimizations */
name|int
name|o
decl_stmt|;
name|int
name|i
decl_stmt|,
name|mask
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|ASG
name|PLUS
case|:
case|case
name|ASG
name|MINUS
case|:
case|case
name|ASG
name|MUL
case|:
case|case
name|ASG
name|OR
case|:
comment|/* simple ASG OPSIMP -- reduce range of constant rhs */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
operator|&&
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|mask
operator|=
operator|(
literal|1
operator|<<
name|tlen
argument_list|(
name|l
argument_list|)
operator|*
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
name|mask
operator|&
operator|~
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|)
condition|)
name|r
operator|->
name|tn
operator|.
name|lval
operator||=
operator|~
name|mask
expr_stmt|;
else|else
name|r
operator|->
name|tn
operator|.
name|lval
operator|&=
name|mask
expr_stmt|;
block|}
break|break;
case|case
name|AND
case|:
comment|/* commute L and R to eliminate complements and constants */
if|if
condition|(
operator|(
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|)
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|l
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
operator|||
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|COMPL
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|l
expr_stmt|;
block|}
comment|/* fall through */
case|case
name|ASG
name|AND
case|:
comment|/* change meaning of AND to ~R&L - bic on pdp11/vax */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
comment|/* check for degenerate operations */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|mask
operator|=
operator|(
literal|1
operator|<<
name|tlen
argument_list|(
name|l
argument_list|)
operator|*
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|o
operator|==
name|ASG
name|AND
operator|||
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
block|{
name|i
operator|=
operator|~
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
name|mask
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|0
condition|)
block|{
comment|/* redundant mask */
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|mask
condition|)
comment|/* all bits masked off */
goto|goto
name|zero
goto|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
comment|/* sign extend */
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|&
operator|(
name|mask
operator|&
operator|~
operator|(
name|mask
operator|>>
literal|1
operator|)
operator|)
condition|)
name|r
operator|->
name|tn
operator|.
name|lval
operator||=
operator|~
name|mask
expr_stmt|;
else|else
name|r
operator|->
name|tn
operator|.
name|lval
operator|&=
name|mask
expr_stmt|;
block|}
break|break;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|tn
operator|.
name|lval
operator|==
name|mask
operator|&&
name|tlen
argument_list|(
name|l
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
condition|)
block|{
comment|/* use movz instead of bic */
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|ENUNSIGN
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|su
operator|=
name|l
operator|->
name|in
operator|.
name|su
operator|>
literal|1
condition|?
name|l
operator|->
name|in
operator|.
name|su
else|:
literal|1
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|r
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
break|break;
block|}
comment|/* complement constant */
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
operator|~
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|COMPL
condition|)
block|{
comment|/* ~~A => A */
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
block|}
else|else
block|{
comment|/* insert complement node */
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|l
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|COMPL
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|r
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|left
operator|=
name|r
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|right
operator|=
name|NULL
expr_stmt|;
block|}
break|break;
case|case
name|SCONV
case|:
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|FORT
argument_list|)
operator|||
name|defined
argument_list|(
name|SPRECC
argument_list|)
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|p
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|||
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
condition|)
return|return;
else|#
directive|else
if|if
condition|(
name|mixtypes
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
condition|)
return|return;
endif|#
directive|endif
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|PCONV
condition|)
return|return;
if|if
condition|(
operator|(
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|CALL
operator|||
name|l
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|CALL
operator|)
operator|&&
name|l
operator|->
name|in
operator|.
name|type
operator|!=
name|INT
operator|&&
name|l
operator|->
name|in
operator|.
name|type
operator|!=
name|UNSIGNED
condition|)
return|return;
comment|/* Only trust it to get it right if the size is the same */
if|if
condition|(
name|tlen
argument_list|(
name|p
argument_list|)
operator|!=
name|tlen
argument_list|(
name|l
argument_list|)
condition|)
return|return;
comment|/* clobber conversion */
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|op
operator|!=
name|FLD
condition|)
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
case|case
name|ASSIGN
case|:
comment|/* 		 * Conversions are equivalent to assignments; 		 * when the two operations are combined, 		 * we can sometimes zap the conversion. 		 */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
operator|!
name|mixtypes
argument_list|(
name|l
argument_list|,
name|r
argument_list|)
operator|&&
name|l
operator|->
name|in
operator|.
name|op
operator|!=
name|FLD
operator|&&
name|tlen
argument_list|(
name|l
argument_list|)
operator|==
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
block|{
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
break|break;
case|case
name|ULE
case|:
case|case
name|ULT
case|:
case|case
name|UGE
case|:
case|case
name|UGT
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|-=
operator|(
name|UGE
operator|-
name|GE
operator|)
expr_stmt|;
if|if
condition|(
name|degenerate
argument_list|(
name|p
argument_list|)
condition|)
break|break;
name|p
operator|->
name|in
operator|.
name|op
operator|+=
operator|(
name|UGE
operator|-
name|GE
operator|)
expr_stmt|;
break|break;
case|case
name|EQ
case|:
case|case
name|NE
case|:
case|case
name|LE
case|:
case|case
name|LT
case|:
case|case
name|GE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|SCONV
condition|)
block|{
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
name|l
operator|->
name|in
operator|.
name|type
operator|==
name|DOUBLE
operator|&&
name|l
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
operator|&&
name|r
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
operator|==
name|FLOAT
condition|)
block|{
comment|/* nuke the conversions */
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|l
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
comment|/* more? */
block|}
operator|(
name|void
operator|)
name|degenerate
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|DIV
case|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|&&
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|&&
operator|(
name|unsigned
operator|)
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|lval
operator|>=
literal|0x80000000
condition|)
block|{
comment|/* easy to do here, harder to do in zzzcode() */
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|UGE
expr_stmt|;
break|break;
block|}
case|case
name|MOD
case|:
case|case
name|ASG
name|DIV
case|:
case|case
name|ASG
name|MOD
case|:
comment|/* 		 * optimize DIV and MOD 		 * 		 * basically we spot UCHAR and USHORT and try to do them 		 * as signed ints...  apparently div+mul+sub is always 		 * faster than ediv for finding MOD on the VAX, when 		 * full unsigned MOD isn't needed. 		 * 		 * a curious fact: for MOD, cmp+sub and cmp+sub+cmp+sub 		 * are faster for unsigned dividend and a constant divisor 		 * in the right range (.5 to 1 of dividend's range for the 		 * first, .333+ to .5 for the second).  full unsigned is 		 * already done cmp+sub in the appropriate case; the 		 * other cases are less common and require more ambition. 		 */
if|if
condition|(
name|degenerate
argument_list|(
name|p
argument_list|)
condition|)
break|break;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
name|ISUNSIGNED
argument_list|(
name|r
operator|->
name|in
operator|.
name|type
argument_list|)
operator|||
name|tlen
argument_list|(
name|l
argument_list|)
operator|>=
name|SZINT
operator|/
name|SZCHAR
operator|||
operator|!
operator|(
name|tlen
argument_list|(
name|r
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
operator|||
operator|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
operator|)
condition|)
break|break;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
condition|)
name|r
operator|->
name|tn
operator|.
name|type
operator|=
name|INT
expr_stmt|;
else|else
block|{
name|NODE
modifier|*
name|t
init|=
name|talloc
argument_list|()
decl_stmt|;
name|t
operator|->
name|in
operator|.
name|left
operator|=
name|r
expr_stmt|;
name|r
operator|=
name|t
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|r
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
name|DIV
operator|||
name|o
operator|==
name|MOD
condition|)
block|{
name|NODE
modifier|*
name|t
init|=
name|talloc
argument_list|()
decl_stmt|;
name|t
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
name|l
operator|=
name|t
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|SCONV
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|right
operator|=
literal|0
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|l
expr_stmt|;
block|}
comment|/* handle asgops in table */
break|break;
case|case
name|RS
case|:
case|case
name|ASG
name|RS
case|:
case|case
name|LS
case|:
case|case
name|ASG
name|LS
case|:
comment|/* pick up degenerate shifts */
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|r
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|r
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
operator|)
condition|)
break|break;
name|i
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
if|if
condition|(
name|i
operator|<
literal|0
condition|)
comment|/* front end 'fixes' this? */
if|if
condition|(
name|o
operator|==
name|LS
operator|||
name|o
operator|==
name|ASG
name|LS
condition|)
name|o
operator|+=
operator|(
name|RS
operator|-
name|LS
operator|)
expr_stmt|;
else|else
name|o
operator|+=
operator|(
name|LS
operator|-
name|RS
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|o
operator|==
name|RS
operator|||
name|o
operator|==
name|ASG
name|RS
operator|)
operator|&&
operator|!
name|ISUNSIGNED
argument_list|(
name|l
operator|->
name|in
operator|.
name|type
argument_list|)
condition|)
comment|/* can't optimize signed right shifts */
break|break;
if|if
condition|(
name|o
operator|==
name|LS
condition|)
block|{
if|if
condition|(
name|i
operator|<
name|SZINT
condition|)
break|break;
block|}
else|else
block|{
if|if
condition|(
name|i
operator|<
name|tlen
argument_list|(
name|l
argument_list|)
operator|*
name|SZCHAR
condition|)
break|break;
block|}
name|zero
label|:
if|if
condition|(
operator|!
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
if|if
condition|(
name|tshape
argument_list|(
name|l
argument_list|,
name|SAREG
operator||
name|SNAME
operator||
name|SCON
operator||
name|SOREG
operator||
name|STARNM
argument_list|)
condition|)
block|{
comment|/* no side effects */
name|tfree
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|COMOP
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
block|}
break|break;
block|}
block|}
end_block

begin_expr_stmt
name|degenerate
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|int
name|o
decl_stmt|;
name|int
name|result
decl_stmt|,
name|i
decl_stmt|;
name|int
name|lower
decl_stmt|,
name|upper
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|l
decl_stmt|,
modifier|*
name|r
decl_stmt|;
comment|/* 	 * try to keep degenerate comparisons with constants 	 * out of the table. 	 */
name|r
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|l
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|in
operator|.
name|op
operator|!=
name|ICON
operator|||
name|r
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|||
name|tlen
argument_list|(
name|l
argument_list|)
operator|>=
name|tlen
argument_list|(
name|r
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
switch|switch
condition|(
name|l
operator|->
name|in
operator|.
name|type
condition|)
block|{
case|case
name|CHAR
case|:
name|lower
operator|=
operator|-
operator|(
literal|1
operator|<<
name|SZCHAR
operator|-
literal|1
operator|)
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZCHAR
operator|-
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|UCHAR
case|:
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZCHAR
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|SHORT
case|:
name|lower
operator|=
operator|-
operator|(
literal|1
operator|<<
name|SZSHORT
operator|-
literal|1
operator|)
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZSHORT
operator|-
literal|1
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|USHORT
case|:
name|lower
operator|=
literal|0
expr_stmt|;
name|upper
operator|=
operator|(
literal|1
operator|<<
name|SZSHORT
operator|)
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"unsupported type in degenerate()"
argument_list|)
expr_stmt|;
block|}
name|i
operator|=
name|r
operator|->
name|tn
operator|.
name|lval
expr_stmt|;
switch|switch
condition|(
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|DIV
case|:
case|case
name|ASG
name|DIV
case|:
case|case
name|MOD
case|:
case|case
name|ASG
name|MOD
case|:
comment|/* DIV and MOD work like EQ */
case|case
name|EQ
case|:
case|case
name|NE
case|:
if|if
condition|(
name|lower
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|NE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|lower
operator|||
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|NE
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|LT
case|:
case|case
name|GE
case|:
if|if
condition|(
name|lower
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<=
name|lower
condition|)
name|result
operator|=
name|o
operator|!=
name|LT
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LT
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
name|LE
case|:
case|case
name|GT
case|:
if|if
condition|(
name|lower
operator|==
literal|0
operator|&&
operator|(
name|unsigned
operator|)
name|i
operator|>=
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|<
name|lower
condition|)
name|result
operator|=
name|o
operator|!=
name|LE
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>=
name|upper
condition|)
name|result
operator|=
name|o
operator|==
name|LE
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"unknown op in degenerate()"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|o
operator|==
name|MOD
operator|||
name|o
operator|==
name|ASG
name|MOD
condition|)
block|{
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|l
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|o
operator|!=
name|ASG
name|DIV
operator|&&
name|tshape
argument_list|(
name|l
argument_list|,
name|SAREG
operator||
name|SNAME
operator||
name|SCON
operator||
name|SOREG
operator||
name|STARNM
argument_list|)
condition|)
block|{
comment|/* no side effects */
name|tfree
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|r
argument_list|)
expr_stmt|;
name|r
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|p
operator|->
name|tn
operator|.
name|lval
operator|=
name|result
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|o
operator|==
name|ASG
name|DIV
condition|)
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
else|else
block|{
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|COMOP
expr_stmt|;
name|r
operator|->
name|tn
operator|.
name|type
operator|=
name|INT
expr_stmt|;
block|}
name|r
operator|->
name|tn
operator|.
name|lval
operator|=
name|result
expr_stmt|;
block|}
if|if
condition|(
name|logop
argument_list|(
name|o
argument_list|)
condition|)
name|p
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_block

begin_comment
comment|/* added by jwf */
end_comment

begin_struct
struct|struct
name|functbl
block|{
name|int
name|fop
decl_stmt|;
name|TWORD
name|ftype
decl_stmt|;
name|char
modifier|*
name|func
decl_stmt|;
block|}
name|opfunc
index|[]
init|=
block|{
name|DIV
block|,
name|TANY
block|,
literal|"udiv"
block|,
name|MOD
block|,
name|TANY
block|,
literal|"urem"
block|,
name|ASG
name|DIV
block|,
name|TANY
block|,
literal|"audiv"
block|,
name|ASG
name|MOD
block|,
name|TANY
block|,
literal|"aurem"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|}
struct|;
end_struct

begin_expr_stmt
name|hardops
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
comment|/* change hard to do operators into function calls.  */
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
specifier|register
name|struct
name|functbl
modifier|*
name|f
decl_stmt|;
specifier|register
name|o
expr_stmt|;
name|NODE
modifier|*
name|old
decl_stmt|,
modifier|*
name|temp
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|optype
argument_list|(
name|o
argument_list|)
operator|==
name|BITYPE
operator|&&
operator|(
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|type
argument_list|)
operator|||
name|ISUNSIGNED
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|type
argument_list|)
operator|)
operator|)
condition|)
return|return;
for|for
control|(
name|f
operator|=
name|opfunc
init|;
name|f
operator|->
name|fop
condition|;
name|f
operator|++
control|)
block|{
if|if
condition|(
name|o
operator|==
name|f
operator|->
name|fop
condition|)
goto|goto
name|convert
goto|;
block|}
return|return;
name|convert
label|:
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|==
name|ICON
operator|&&
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|tn
operator|.
name|name
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
comment|/* 'J', 'K' in zzzcode() -- assumes DIV or MOD operations */
comment|/* save a subroutine call -- use at most 5 instructions */
return|return;
if|if
condition|(
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
operator|&&
name|tlen
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
operator|<
name|SZINT
operator|/
name|SZCHAR
condition|)
comment|/* optim2() will modify the op into an ordinary int op */
return|return;
if|if
condition|(
name|asgop
argument_list|(
name|o
argument_list|)
condition|)
block|{
name|old
operator|=
name|NIL
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|FLD
case|:
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* 			 * rewrite (lval.fld /= rval); as 			 *  ((*temp).fld = udiv((*(temp =&lval)).fld,rval)); 			 * else the compiler will evaluate lval twice. 			 */
if|if
condition|(
name|q
operator|->
name|in
operator|.
name|op
operator|==
name|UNARY
name|MUL
condition|)
block|{
comment|/* first allocate a temp storage */
name|temp
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|temp
operator|->
name|in
operator|.
name|op
operator|=
name|OREG
expr_stmt|;
name|temp
operator|->
name|tn
operator|.
name|rval
operator|=
name|TMPREG
expr_stmt|;
name|temp
operator|->
name|tn
operator|.
name|lval
operator|=
name|BITOOR
argument_list|(
name|freetemp
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|temp
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|temp
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|temp
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|old
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|temp
expr_stmt|;
block|}
comment|/* fall thru ... */
case|case
name|REG
case|:
case|case
name|NAME
case|:
case|case
name|OREG
case|:
comment|/* change ASG OP to a simple OP */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|NOASG
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|p
operator|->
name|in
operator|.
name|type
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|tcopy
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
name|p
operator|=
name|q
expr_stmt|;
name|f
operator|-=
literal|2
expr_stmt|;
comment|/* Note: this depends on the table order */
comment|/* on the right side only - replace *temp with 			 *(temp =&lval), build the assignment node */
if|if
condition|(
name|old
condition|)
block|{
name|temp
operator|=
name|q
operator|->
name|in
operator|.
name|left
operator|->
name|in
operator|.
name|left
expr_stmt|;
comment|/* the "*" node */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ASSIGN
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|temp
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|old
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|old
operator|->
name|in
operator|.
name|type
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|q
operator|->
name|in
operator|.
name|name
operator|=
literal|""
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
name|temp
operator|->
name|in
operator|.
name|left
operator|=
name|q
expr_stmt|;
block|}
break|break;
case|case
name|UNARY
name|MUL
case|:
comment|/* avoid doing side effects twice */
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"hardops: can't compute& LHS"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* build comma op for args to function */
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|CM
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INT
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|left
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|right
operator|=
name|p
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|CALL
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|=
name|q
expr_stmt|;
comment|/* put function name in left node of call */
name|p
operator|->
name|in
operator|.
name|left
operator|=
name|q
operator|=
name|talloc
argument_list|()
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|ICON
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|rall
operator|=
name|NOPREF
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|type
operator|=
name|INCREF
argument_list|(
name|FTN
operator|+
name|p
operator|->
name|in
operator|.
name|type
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|FLEXNAMES
name|strcpy
argument_list|(
name|q
operator|->
name|in
operator|.
name|name
argument_list|,
name|f
operator|->
name|func
argument_list|)
expr_stmt|;
else|#
directive|else
name|q
operator|->
name|in
operator|.
name|name
operator|=
name|f
operator|->
name|func
expr_stmt|;
endif|#
directive|endif
name|q
operator|->
name|tn
operator|.
name|lval
operator|=
literal|0
expr_stmt|;
name|q
operator|->
name|tn
operator|.
name|rval
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_macro
name|zappost
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* look for ++ and -- operators and remove them */
specifier|register
name|int
name|o
decl_stmt|,
name|ty
decl_stmt|;
specifier|register
name|NODE
modifier|*
name|q
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|INCR
case|:
case|case
name|DECR
case|:
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|p
operator|->
name|in
operator|.
name|right
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
comment|/* zap constant */
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|zappost
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|fixpre
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|o
decl_stmt|,
name|ty
decl_stmt|;
name|o
operator|=
name|p
operator|->
name|in
operator|.
name|op
expr_stmt|;
name|ty
operator|=
name|optype
argument_list|(
name|o
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|o
condition|)
block|{
case|case
name|ASG
name|PLUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|PLUS
expr_stmt|;
break|break;
case|case
name|ASG
name|MINUS
case|:
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|MINUS
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ty
operator|==
name|BITYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|right
argument_list|)
expr_stmt|;
if|if
condition|(
name|ty
operator|!=
name|LTYPE
condition|)
name|fixpre
argument_list|(
name|p
operator|->
name|in
operator|.
name|left
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|NODE
modifier|*
name|addroreg
parameter_list|(
name|l
parameter_list|)
name|NODE
modifier|*
name|l
decl_stmt|;
comment|/* OREG was built in clocal() 				 * for an auto or formal parameter 				 * now its address is being taken 				 * local code must unwind it 				 * back to PLUS/MINUS REG ICON 				 * according to local conventions 				 */
block|{
name|cerror
argument_list|(
literal|"address of OREG taken"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
return|return
operator|(
name|mainp2
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_expr_stmt
name|strip
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|NODE
modifier|*
name|q
decl_stmt|;
comment|/* strip nodes off the top when no side effects occur */
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|p
operator|->
name|in
operator|.
name|op
condition|)
block|{
case|case
name|SCONV
case|:
comment|/* remove lint tidbits */
name|q
operator|=
name|p
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|ncopy
argument_list|(
name|p
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|q
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
break|break;
comment|/* could probably add a few more here */
default|default:
return|return;
block|}
block|}
block|}
end_block

begin_expr_stmt
name|myreader
argument_list|(
name|p
argument_list|)
specifier|register
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|strip
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* strip off operations with no side effects */
name|canon
argument_list|(
name|p
argument_list|)
expr_stmt|;
comment|/* expands r-vals for fields */
name|walkf
argument_list|(
name|p
argument_list|,
name|hardops
argument_list|)
expr_stmt|;
comment|/* convert ops to function calls */
name|walkf
argument_list|(
name|p
argument_list|,
name|optim2
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

