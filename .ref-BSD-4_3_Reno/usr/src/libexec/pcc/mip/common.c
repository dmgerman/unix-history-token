begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	common.c	4.5	88/05/11	*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASS1COMMON
end_ifdef

begin_include
include|#
directive|include
file|"pass1.h"
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|PASS2COMMON
end_ifdef

begin_include
include|#
directive|include
file|"pass2.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FORT
end_ifdef

begin_undef
undef|#
directive|undef
name|BUFSTDERR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|ONEPASS
end_ifndef

begin_undef
undef|#
directive|undef
name|BUFSTDERR
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|EXIT
end_ifndef

begin_define
define|#
directive|define
name|EXIT
value|exit
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|nerrors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of errors */
end_comment

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|offsz
decl_stmt|;
end_decl_stmt

begin_function
name|unsigned
name|caloff
parameter_list|()
block|{
specifier|register
name|i
expr_stmt|;
name|unsigned
name|int
name|temp
decl_stmt|;
name|unsigned
name|int
name|off
decl_stmt|;
name|temp
operator|=
literal|1
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|temp
operator|<<=
literal|1
expr_stmt|;
operator|++
name|i
expr_stmt|;
block|}
do|while
condition|(
name|temp
operator|!=
literal|0
condition|)
do|;
name|off
operator|=
literal|1
operator|<<
operator|(
name|i
operator|-
literal|1
operator|)
expr_stmt|;
return|return
operator|(
name|off
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|NODE
modifier|*
name|lastfree
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to last free node; (for allocator) */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|uerror
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* nonfatal error message */
comment|/* the routine where is different for pass 1 and pass 2; 	/*  it tells where the error took place */
operator|++
name|nerrors
expr_stmt|;
name|where
argument_list|(
literal|'u'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BUFSTDERR
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|nerrors
operator|>
literal|30
condition|)
name|cerror
argument_list|(
literal|"too many errors"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|cerror
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|,
argument|c
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* compiler error: die */
name|where
argument_list|(
literal|'c'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nerrors
operator|&&
name|nerrors
operator|<=
literal|30
condition|)
block|{
comment|/* give the compiler the benefit of the doubt */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot recover from earlier errors: goodbye!\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"compiler error: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|BUFSTDERR
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|EXIT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|Wflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Non-zero means do not print warnings */
end_comment

begin_comment
comment|/* VARARGS1 */
end_comment

begin_macro
name|werror
argument_list|(
argument|s
argument_list|,
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* warning */
if|if
condition|(
name|Wflag
condition|)
return|return;
name|where
argument_list|(
literal|'w'
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"warning: "
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|s
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BUFSTDERR
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|tinit
argument_list|()
end_macro

begin_block
block|{
comment|/* initialize expression tree search */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
name|node
init|;
name|p
operator|<=
operator|&
name|node
index|[
name|TREESZ
operator|-
literal|1
index|]
condition|;
operator|++
name|p
control|)
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
name|lastfree
operator|=
name|node
expr_stmt|;
block|}
end_block

begin_define
define|#
directive|define
name|TNEXT
parameter_list|(
name|p
parameter_list|)
value|(p==&node[TREESZ-1]?node:p+1)
end_define

begin_function
name|NODE
modifier|*
name|talloc
parameter_list|()
block|{
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|q
operator|=
name|lastfree
expr_stmt|;
for|for
control|(
name|p
operator|=
name|TNEXT
argument_list|(
name|q
argument_list|)
init|;
name|p
operator|!=
name|q
condition|;
name|p
operator|=
name|TNEXT
argument_list|(
name|p
argument_list|)
control|)
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|==
name|FREE
condition|)
return|return
operator|(
name|lastfree
operator|=
name|p
operator|)
return|;
name|cerror
argument_list|(
literal|"out of tree space; simplify expression"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_macro
name|tcheck
argument_list|()
end_macro

begin_block
block|{
comment|/* ensure that all nodes have been freed */
specifier|register
name|NODE
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|!
name|nerrors
condition|)
for|for
control|(
name|p
operator|=
name|node
init|;
name|p
operator|<=
operator|&
name|node
index|[
name|TREESZ
operator|-
literal|1
index|]
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|FREE
condition|)
name|cerror
argument_list|(
literal|"wasted space: %o"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|tinit
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|FLEXNAMES
name|freetstr
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_block

begin_macro
name|tfree
argument_list|(
argument|p
argument_list|)
end_macro

begin_decl_stmt
name|NODE
modifier|*
name|p
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* free the tree p */
extern|extern tfree1(
block|)
end_block

begin_empty_stmt
empty_stmt|;
end_empty_stmt

begin_if
if|if
condition|(
name|p
operator|->
name|in
operator|.
name|op
operator|!=
name|FREE
condition|)
name|walkf
argument_list|(
name|p
argument_list|,
name|tfree1
argument_list|)
expr_stmt|;
end_if

begin_expr_stmt
unit|}  tfree1
operator|(
name|p
operator|)
name|NODE
operator|*
name|p
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|p
operator|==
literal|0
condition|)
name|cerror
argument_list|(
literal|"freeing blank tree!"
argument_list|)
expr_stmt|;
else|else
name|p
operator|->
name|in
operator|.
name|op
operator|=
name|FREE
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|fwalk
argument_list|(
name|t
argument_list|,
name|f
argument_list|,
name|down
argument_list|)
specifier|register
name|NODE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|int
name|down1
decl_stmt|,
name|down2
decl_stmt|;
name|more
label|:
name|down1
operator|=
name|down2
operator|=
literal|0
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|t
argument_list|,
name|down
argument_list|,
operator|&
name|down1
argument_list|,
operator|&
name|down2
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|optype
argument_list|(
name|t
operator|->
name|in
operator|.
name|op
argument_list|)
condition|)
block|{
case|case
name|BITYPE
case|:
name|fwalk
argument_list|(
name|t
operator|->
name|in
operator|.
name|left
argument_list|,
name|f
argument_list|,
name|down1
argument_list|)
expr_stmt|;
name|t
operator|=
name|t
operator|->
name|in
operator|.
name|right
expr_stmt|;
name|down
operator|=
name|down2
expr_stmt|;
goto|goto
name|more
goto|;
case|case
name|UTYPE
case|:
name|t
operator|=
name|t
operator|->
name|in
operator|.
name|left
expr_stmt|;
name|down
operator|=
name|down1
expr_stmt|;
goto|goto
name|more
goto|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|vax
end_ifndef

begin_expr_stmt
name|walkf
argument_list|(
name|t
argument_list|,
name|f
argument_list|)
specifier|register
name|NODE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|opty
expr_stmt|;
name|opty
operator|=
name|optype
argument_list|(
name|t
operator|->
name|in
operator|.
name|op
argument_list|)
expr_stmt|;
if|if
condition|(
name|opty
operator|!=
name|LTYPE
condition|)
name|walkf
argument_list|(
name|t
operator|->
name|in
operator|.
name|left
argument_list|,
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|opty
operator|==
name|BITYPE
condition|)
name|walkf
argument_list|(
name|t
operator|->
name|in
operator|.
name|right
argument_list|,
name|f
argument_list|)
expr_stmt|;
call|(
modifier|*
name|f
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NR
value|32
end_define

begin_comment
comment|/*  * Deliberately avoids recursion -- use this version on machines with  * expensive procedure calls.  */
end_comment

begin_expr_stmt
name|walkf
argument_list|(
name|t
argument_list|,
name|f
argument_list|)
specifier|register
name|NODE
operator|*
name|t
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|register
name|int
function_decl|(
modifier|*
name|f
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|NODE
modifier|*
name|Aat
index|[
name|NR
index|]
decl_stmt|;
name|int
name|Aao
index|[
name|NR
index|]
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
specifier|register
name|int
name|opty
init|=
name|optype
argument_list|(
name|t
operator|->
name|in
operator|.
name|op
argument_list|)
decl_stmt|;
specifier|register
name|NODE
modifier|*
modifier|*
name|at
init|=
name|Aat
decl_stmt|;
specifier|register
name|int
modifier|*
name|ao
init|=
name|Aao
decl_stmt|;
define|#
directive|define
name|PUSH
parameter_list|(
name|dir
parameter_list|,
name|state
parameter_list|)
define|\
value|(ao[i] = state, at[i++] = t, t = t->in.dir, opty = optype(t->in.op))
define|#
directive|define
name|POP
parameter_list|()
define|\
value|(opty = ao[--i], t = at[i])
do|do
block|{
switch|switch
condition|(
name|opty
condition|)
block|{
case|case
name|LTYPE
case|:
call|(
modifier|*
name|f
call|)
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|POP
argument_list|()
expr_stmt|;
break|break;
case|case
name|UTYPE
case|:
name|PUSH
argument_list|(
name|left
argument_list|,
name|LTYPE
argument_list|)
expr_stmt|;
break|break;
case|case
name|BITYPE
case|:
name|PUSH
argument_list|(
name|left
argument_list|,
name|BITYPE
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|BITYPE
operator|+
literal|1
case|:
name|PUSH
argument_list|(
name|right
argument_list|,
name|LTYPE
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cerror
argument_list|(
literal|"bad op type in walkf"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|NR
condition|)
block|{
name|walkf
argument_list|(
name|t
argument_list|,
name|f
argument_list|)
expr_stmt|;
name|POP
argument_list|()
expr_stmt|;
block|}
block|}
do|while
condition|(
name|i
operator|>
literal|0
condition|)
do|;
block|}
end_block

begin_undef
undef|#
directive|undef
name|NR
end_undef

begin_undef
undef|#
directive|undef
name|PUSH
end_undef

begin_undef
undef|#
directive|undef
name|POP
end_undef

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|dope
index|[
name|DSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|opst
index|[
name|DSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|dopest
block|{
name|int
name|dopeop
decl_stmt|;
name|char
name|opst
index|[
literal|8
index|]
decl_stmt|;
name|int
name|dopeval
decl_stmt|;
block|}
name|indope
index|[]
init|=
block|{
name|NAME
block|,
literal|"NAME"
block|,
name|LTYPE
block|,
name|STRING
block|,
literal|"STRING"
block|,
name|LTYPE
block|,
name|REG
block|,
literal|"REG"
block|,
name|LTYPE
block|,
name|OREG
block|,
literal|"OREG"
block|,
name|LTYPE
block|,
name|ICON
block|,
literal|"ICON"
block|,
name|LTYPE
block|,
name|FCON
block|,
literal|"FCON"
block|,
name|LTYPE
block|,
name|DCON
block|,
literal|"DCON"
block|,
name|LTYPE
block|,
name|CCODES
block|,
literal|"CCODES"
block|,
name|LTYPE
block|,
name|UNARY
name|MINUS
block|,
literal|"U-"
block|,
name|UTYPE
block|,
name|UNARY
name|MUL
block|,
literal|"U*"
block|,
name|UTYPE
block|,
name|UNARY
name|AND
block|,
literal|"U&"
block|,
name|UTYPE
block|,
name|UNARY
name|CALL
block|,
literal|"UCALL"
block|,
name|UTYPE
operator||
name|CALLFLG
block|,
name|UNARY
name|FORTCALL
block|,
literal|"UFCALL"
block|,
name|UTYPE
operator||
name|CALLFLG
block|,
name|NOT
block|,
literal|"!"
block|,
name|UTYPE
operator||
name|LOGFLG
block|,
name|COMPL
block|,
literal|"~"
block|,
name|UTYPE
block|,
name|FORCE
block|,
literal|"FORCE"
block|,
name|UTYPE
block|,
name|INIT
block|,
literal|"INIT"
block|,
name|UTYPE
block|,
name|SCONV
block|,
literal|"SCONV"
block|,
name|UTYPE
block|,
name|PCONV
block|,
literal|"PCONV"
block|,
name|UTYPE
block|,
name|PLUS
block|,
literal|"+"
block|,
name|BITYPE
operator||
name|FLOFLG
operator||
name|SIMPFLG
operator||
name|COMMFLG
block|,
name|ASG
name|PLUS
block|,
literal|"+="
block|,
name|BITYPE
operator||
name|ASGFLG
operator||
name|ASGOPFLG
operator||
name|FLOFLG
operator||
name|SIMPFLG
operator||
name|COMMFLG
block|,
name|MINUS
block|,
literal|"-"
block|,
name|BITYPE
operator||
name|FLOFLG
operator||
name|SIMPFLG
block|,
name|ASG
name|MINUS
block|,
literal|"-="
block|,
name|BITYPE
operator||
name|FLOFLG
operator||
name|SIMPFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|MUL
block|,
literal|"*"
block|,
name|BITYPE
operator||
name|FLOFLG
operator||
name|MULFLG
block|,
name|ASG
name|MUL
block|,
literal|"*="
block|,
name|BITYPE
operator||
name|FLOFLG
operator||
name|MULFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|AND
block|,
literal|"&"
block|,
name|BITYPE
operator||
name|SIMPFLG
operator||
name|COMMFLG
block|,
name|ASG
name|AND
block|,
literal|"&="
block|,
name|BITYPE
operator||
name|SIMPFLG
operator||
name|COMMFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|QUEST
block|,
literal|"?"
block|,
name|BITYPE
block|,
name|COLON
block|,
literal|":"
block|,
name|BITYPE
block|,
name|ANDAND
block|,
literal|"&&"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|OROR
block|,
literal|"||"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|CM
block|,
literal|","
block|,
name|BITYPE
block|,
name|COMOP
block|,
literal|",OP"
block|,
name|BITYPE
block|,
name|ASSIGN
block|,
literal|"="
block|,
name|BITYPE
operator||
name|ASGFLG
block|,
name|DIV
block|,
literal|"/"
block|,
name|BITYPE
operator||
name|FLOFLG
operator||
name|MULFLG
operator||
name|DIVFLG
block|,
name|ASG
name|DIV
block|,
literal|"/="
block|,
name|BITYPE
operator||
name|FLOFLG
operator||
name|MULFLG
operator||
name|DIVFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|MOD
block|,
literal|"%"
block|,
name|BITYPE
operator||
name|DIVFLG
block|,
name|ASG
name|MOD
block|,
literal|"%="
block|,
name|BITYPE
operator||
name|DIVFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|LS
block|,
literal|"<<"
block|,
name|BITYPE
operator||
name|SHFFLG
block|,
name|ASG
name|LS
block|,
literal|"<<="
block|,
name|BITYPE
operator||
name|SHFFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|RS
block|,
literal|">>"
block|,
name|BITYPE
operator||
name|SHFFLG
block|,
name|ASG
name|RS
block|,
literal|">>="
block|,
name|BITYPE
operator||
name|SHFFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|OR
block|,
literal|"|"
block|,
name|BITYPE
operator||
name|COMMFLG
operator||
name|SIMPFLG
block|,
name|ASG
name|OR
block|,
literal|"|="
block|,
name|BITYPE
operator||
name|COMMFLG
operator||
name|SIMPFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|ER
block|,
literal|"^"
block|,
name|BITYPE
operator||
name|COMMFLG
operator||
name|SIMPFLG
block|,
name|ASG
name|ER
block|,
literal|"^="
block|,
name|BITYPE
operator||
name|COMMFLG
operator||
name|SIMPFLG
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|INCR
block|,
literal|"++"
block|,
name|BITYPE
operator||
name|ASGFLG
block|,
name|DECR
block|,
literal|"--"
block|,
name|BITYPE
operator||
name|ASGFLG
block|,
name|STREF
block|,
literal|"->"
block|,
name|BITYPE
block|,
name|CALL
block|,
literal|"CALL"
block|,
name|BITYPE
operator||
name|CALLFLG
block|,
name|FORTCALL
block|,
literal|"FCALL"
block|,
name|BITYPE
operator||
name|CALLFLG
block|,
name|EQ
block|,
literal|"=="
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|NE
block|,
literal|"!="
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|LE
block|,
literal|"<="
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|LT
block|,
literal|"<"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|GE
block|,
literal|">"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|GT
block|,
literal|">"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|UGT
block|,
literal|"UGT"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|UGE
block|,
literal|"UGE"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|ULT
block|,
literal|"ULT"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
name|ULE
block|,
literal|"ULE"
block|,
name|BITYPE
operator||
name|LOGFLG
block|,
ifdef|#
directive|ifdef
name|ARS
name|ARS
block|,
literal|"A>>"
block|,
name|BITYPE
block|,
endif|#
directive|endif
name|TYPE
block|,
literal|"TYPE"
block|,
name|LTYPE
block|,
name|LB
block|,
literal|"["
block|,
name|BITYPE
block|,
name|CBRANCH
block|,
literal|"CBRANCH"
block|,
name|BITYPE
block|,
name|FLD
block|,
literal|"FLD"
block|,
name|UTYPE
block|,
name|PMCONV
block|,
literal|"PMCONV"
block|,
name|BITYPE
block|,
name|PVCONV
block|,
literal|"PVCONV"
block|,
name|BITYPE
block|,
name|RETURN
block|,
literal|"RETURN"
block|,
name|BITYPE
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|CAST
block|,
literal|"CAST"
block|,
name|BITYPE
operator||
name|ASGFLG
operator||
name|ASGOPFLG
block|,
name|GOTO
block|,
literal|"GOTO"
block|,
name|UTYPE
block|,
name|STASG
block|,
literal|"STASG"
block|,
name|BITYPE
operator||
name|ASGFLG
block|,
name|STARG
block|,
literal|"STARG"
block|,
name|UTYPE
block|,
name|STCALL
block|,
literal|"STCALL"
block|,
name|BITYPE
operator||
name|CALLFLG
block|,
name|UNARY
name|STCALL
block|,
literal|"USTCALL"
block|,
name|UTYPE
operator||
name|CALLFLG
block|,
operator|-
literal|1
block|,
literal|""
block|,
literal|0
block|}
struct|;
end_struct

begin_macro
name|mkdope
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|dopest
modifier|*
name|q
decl_stmt|;
for|for
control|(
name|q
operator|=
name|indope
init|;
name|q
operator|->
name|dopeop
operator|>=
literal|0
condition|;
operator|++
name|q
control|)
block|{
name|dope
index|[
name|q
operator|->
name|dopeop
index|]
operator|=
name|q
operator|->
name|dopeval
expr_stmt|;
name|opst
index|[
name|q
operator|->
name|dopeop
index|]
operator|=
name|q
operator|->
name|opst
expr_stmt|;
block|}
block|}
end_block

begin_ifndef
ifndef|#
directive|ifndef
name|BUG4
end_ifndef

begin_macro
name|tprint
argument_list|(
argument|t
argument_list|)
end_macro

begin_decl_stmt
name|TWORD
name|t
decl_stmt|;
end_decl_stmt

begin_block
block|{
comment|/* output a nice description of the type of t */
specifier|static
name|char
modifier|*
name|tnames
index|[]
init|=
block|{
literal|"undef"
block|,
literal|"farg"
block|,
literal|"char"
block|,
literal|"short"
block|,
literal|"int"
block|,
literal|"long"
block|,
literal|"float"
block|,
literal|"double"
block|,
literal|"strty"
block|,
literal|"unionty"
block|,
literal|"enumty"
block|,
literal|"moety"
block|,
literal|"uchar"
block|,
literal|"ushort"
block|,
literal|"unsigned"
block|,
literal|"ulong"
block|,
literal|"?"
block|,
literal|"?"
block|}
decl_stmt|;
for|for
control|(
init|;
condition|;
name|t
operator|=
name|DECREF
argument_list|(
name|t
argument_list|)
control|)
block|{
if|if
condition|(
name|ISPTR
argument_list|(
name|t
argument_list|)
condition|)
name|printf
argument_list|(
literal|"PTR "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISFTN
argument_list|(
name|t
argument_list|)
condition|)
name|printf
argument_list|(
literal|"FTN "
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISARY
argument_list|(
name|t
argument_list|)
condition|)
name|printf
argument_list|(
literal|"ARY "
argument_list|)
expr_stmt|;
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|tnames
index|[
name|t
index|]
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|FLEXNAMES
end_ifdef

begin_define
define|#
directive|define
name|NTSTRBUF
value|40
end_define

begin_define
define|#
directive|define
name|TSTRSZ
value|2048
end_define

begin_decl_stmt
name|char
name|itstrbuf
index|[
name|TSTRSZ
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tstrbuf
index|[
name|NTSTRBUF
index|]
init|=
block|{
name|itstrbuf
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|curtstr
init|=
name|tstrbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tstrused
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|malloc
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|strcpy
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|char
modifier|*
name|tstr
parameter_list|(
name|cp
parameter_list|)
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
name|strlen
argument_list|(
name|cp
argument_list|)
decl_stmt|;
specifier|register
name|char
modifier|*
name|dp
decl_stmt|;
if|if
condition|(
name|tstrused
operator|+
name|i
operator|>=
name|TSTRSZ
condition|)
block|{
if|if
condition|(
operator|++
name|curtstr
operator|>=
operator|&
name|tstrbuf
index|[
name|NTSTRBUF
index|]
condition|)
name|cerror
argument_list|(
literal|"out of temporary string space"
argument_list|)
expr_stmt|;
name|tstrused
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|curtstr
operator|==
literal|0
condition|)
block|{
name|dp
operator|=
name|malloc
argument_list|(
name|TSTRSZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|dp
operator|==
literal|0
condition|)
name|cerror
argument_list|(
literal|"out of memory (tstr)"
argument_list|)
expr_stmt|;
operator|*
name|curtstr
operator|=
name|dp
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|dp
operator|=
operator|*
name|curtstr
operator|+
name|tstrused
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|tstrused
operator|+=
name|i
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|dp
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

