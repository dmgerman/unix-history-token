begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1988, 1990 The Regents of the University of California.  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * The original version of xfer by Kevin Dunlap.  * Completed and integrated with named by David Waitzman  *	(dwaitzman@bbn.com) 3/14/88.  * Modified by M. Karels and O. Kure 10-88.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1988, 1990 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)named-xfer.c	4.15 (Berkeley) 7/24/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/uio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_define
define|#
directive|define
name|XFER
end_define

begin_comment
comment|/* modifies the ns.h include file */
end_comment

begin_include
include|#
directive|include
file|"ns.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_function_decl
name|char
modifier|*
name|savestr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* max length of data in RR data field */
end_comment

begin_define
define|#
directive|define
name|MAXDATA
value|2048
end_define

begin_comment
comment|/* from db.h */
end_comment

begin_decl_stmt
name|int
name|debug
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|quiet
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|read_interrupted
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|zoneinfo
name|zones
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* zone information */
end_comment

begin_decl_stmt
name|struct
name|timeval
name|tt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ddtfile
init|=
name|_PATH_TMPXFER
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tmpname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fp
init|=
literal|0
decl_stmt|,
modifier|*
name|ddt
decl_stmt|,
modifier|*
name|dbfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|domain
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* domain being xfered */
end_comment

begin_decl_stmt
name|int
name|domain_len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* strlen(domain) */
end_comment

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
specifier|register
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
specifier|register
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|char
modifier|*
name|dbfile
init|=
name|NULL
decl_stmt|,
modifier|*
name|tracefile
init|=
name|NULL
decl_stmt|,
modifier|*
name|tm
init|=
name|NULL
decl_stmt|;
name|int
name|dbfd
decl_stmt|,
name|ddtd
decl_stmt|,
name|result
decl_stmt|,
name|c
decl_stmt|;
name|u_long
name|serial_no
init|=
literal|0
decl_stmt|;
specifier|extern
name|char
modifier|*
name|optarg
decl_stmt|;
specifier|extern
name|int
name|optind
decl_stmt|,
name|getopt
argument_list|()
decl_stmt|;
name|u_short
name|port
init|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|umask
argument_list|(
literal|022
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|LOG_DAEMON
name|openlog
argument_list|(
literal|"named-xfer"
argument_list|,
name|LOG_PID
operator||
name|LOG_CONS
argument_list|,
name|LOG_DAEMON
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"named-xfer"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"d:l:s:t:z:f:p:P:q"
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'d'
case|:
name|debug
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|ddtfile
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|ddtfile
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|ddtfile
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|serial_no
operator|=
operator|(
name|u_long
operator|)
name|atol
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tracefile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
comment|/* zone == domain */
name|domain
operator|=
name|optarg
expr_stmt|;
name|domain_len
operator|=
name|strlen
argument_list|(
name|domain
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|dbfile
operator|=
name|optarg
expr_stmt|;
name|tmpname
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|optarg
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
literal|".XXXXXX"
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmpname
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|port
operator|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|port
operator|=
operator|(
name|u_short
operator|)
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|++
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|!
name|domain
operator|||
operator|!
name|dbfile
operator|||
name|optind
operator|>=
name|argc
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|tracefile
operator|&&
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|tracefile
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|perror
argument_list|(
name|tracefile
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|tmpname
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
comment|/* tmpname is now something like "/etc/named/named.bu.db.XXXXXX" */
if|if
condition|(
operator|(
name|dbfd
operator|=
name|mkstemp
argument_list|(
name|tmpname
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't make tmpfile (%s): %m\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fchmod
argument_list|(
name|dbfd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't fchmod tmpfile (%s): %m\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|dbfp
operator|=
name|fdopen
argument_list|(
name|dbfd
argument_list|,
literal|"r+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"can't fdopen tmpfile (%s)"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
comment|/* ddtfile is now something like "/usr/tmp/xfer.ddt.XXXXXX" */
if|if
condition|(
operator|(
name|ddtd
operator|=
name|mkstemp
argument_list|(
name|ddtfile
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fchmod
argument_list|(
name|ddtd
argument_list|,
literal|0644
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ddt
operator|=
name|fdopen
argument_list|(
name|ddtd
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|ddtfile
argument_list|)
expr_stmt|;
name|debug
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|defined
argument_list|(
name|SYSV
argument_list|)
name|setvbuf
argument_list|(
name|ddt
argument_list|,
name|NULL
argument_list|,
name|_IOLBF
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
else|#
directive|else
name|setlinebuf
argument_list|(
name|ddt
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
endif|#
directive|endif
comment|/* 	 * Ignore many types of signals that named (assumed to be our parent) 	 * considers important- if not, the user controlling named with 	 * signals usually kills us. 	 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGHUP
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGIOT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|SIGUSR1
argument_list|)
operator|&&
name|defined
argument_list|(
name|SIGUSR2
argument_list|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR1
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGUSR2
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
else|#
directive|else
else|SIGUSR1&&SIGUSR2
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGEMT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGFPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|SIGUSR1&&SIGUSR2
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"domain `%s' file `%s' ser no %lu \n"
argument_list|,
name|domain
argument_list|,
name|dbfile
argument_list|,
name|serial_no
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|buildservicelist
argument_list|()
expr_stmt|;
name|buildprotolist
argument_list|()
expr_stmt|;
comment|/* init zone data */
name|zp
operator|=
operator|&
name|zones
expr_stmt|;
name|zp
operator|->
name|z_type
operator|=
name|Z_SECONDARY
expr_stmt|;
name|zp
operator|->
name|z_origin
operator|=
name|domain
expr_stmt|;
name|zp
operator|->
name|z_source
operator|=
name|dbfile
expr_stmt|;
name|zp
operator|->
name|z_addrcnt
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"zone found (%d): "
argument_list|,
name|zp
operator|->
name|z_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_origin
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"'.'"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"'%s'"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|", source = %s\n"
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
for|for
control|(
init|;
name|optind
operator|!=
name|argc
condition|;
name|optind
operator|++
operator|,
name|zp
operator|->
name|z_addrcnt
operator|++
control|)
block|{
name|tm
operator|=
name|argv
index|[
name|optind
index|]
expr_stmt|;
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
operator|.
name|s_addr
operator|==
operator|(
name|unsigned
operator|)
operator|-
literal|1
condition|)
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|tm
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"uninterpretable server %s\n"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bcopy
argument_list|(
name|hp
operator|->
name|h_addr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
operator|.
name|s_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|zp
operator|->
name|z_addr
index|[
name|zp
operator|->
name|z_addrcnt
index|]
operator|.
name|s_addr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|", %s"
argument_list|,
name|tm
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|zp
operator|->
name|z_addrcnt
operator|>=
name|NSMAX
condition|)
block|{
name|zp
operator|->
name|z_addrcnt
operator|=
name|NSMAX
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"\nns.h NSMAX reached\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|" (addrcnt) = %d\n"
argument_list|,
name|zp
operator|->
name|z_addrcnt
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEFNAMES
operator||
name|RES_DNSRCH
operator||
name|RES_RECURSE
operator|)
expr_stmt|;
name|result
operator|=
name|getzone
argument_list|(
name|zp
argument_list|,
name|serial_no
argument_list|,
name|port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|result
condition|)
block|{
case|case
name|XFER_SUCCESS
case|:
comment|/* ok exit */
if|if
condition|(
name|rename
argument_list|(
name|tmpname
argument_list|,
name|dbfile
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|perror
argument_list|(
literal|"rename"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"rename %s to %s: %m"
argument_list|,
name|tmpname
argument_list|,
name|dbfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|XFER_SUCCESS
argument_list|)
expr_stmt|;
case|case
name|XFER_UPTODATE
case|:
comment|/* the zone was already uptodate */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_UPTODATE
argument_list|)
expr_stmt|;
case|case
name|XFER_TIMEOUT
case|:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|debug
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_TIMEOUT
argument_list|)
expr_stmt|;
comment|/* servers not reachable exit */
case|case
name|XFER_FAIL
case|:
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|debug
condition|)
endif|#
directive|endif
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
comment|/* yuck exit */
block|}
block|}
end_function

begin_macro
name|usage
argument_list|()
end_macro

begin_block
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: xfer\n\ \t-z zone_to_transfer\n\ \t-f db_file\n\ \t-s serial_no\n\ \t[-d debug_level]\n\ \t[-l debug_log_file (default %s)]\n\ \t[-t trace_file]\n\ \t[-p port]\n\ \tservers...\n"
argument_list|,
name|ddtfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|int
name|minimum_ttl
init|=
literal|0
decl_stmt|,
name|got_soa
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|prev_origin
index|[
name|MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|prev_dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|getzone
argument_list|(
argument|zp
argument_list|,
argument|serial_no
argument_list|,
argument|port
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|zoneinfo
modifier|*
name|zp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_long
name|serial_no
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_short
name|port
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|HEADER
modifier|*
name|hp
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|u_long
name|serial
decl_stmt|;
name|int
name|s
decl_stmt|,
name|n
decl_stmt|,
name|l
decl_stmt|,
name|cnt
decl_stmt|,
name|soacnt
decl_stmt|,
name|error
init|=
literal|0
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|nmp
decl_stmt|,
modifier|*
name|eom
decl_stmt|,
modifier|*
name|tmp
decl_stmt|;
name|u_char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|int
name|bufsize
decl_stmt|;
name|u_char
name|name
index|[
name|MAXDNAME
index|]
decl_stmt|,
name|name2
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|struct
name|sockaddr_in
name|sin
decl_stmt|;
name|struct
name|zoneinfo
name|zp_start
decl_stmt|,
name|zp_finish
decl_stmt|;
name|struct
name|itimerval
name|ival
decl_stmt|,
name|zeroival
decl_stmt|;
specifier|extern
name|VOID
name|read_alarm
parameter_list|()
function_decl|;
name|struct
name|sigvec
name|sv
decl_stmt|,
name|osv
decl_stmt|;
name|int
name|ancount
decl_stmt|,
name|aucount
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"getzone() %s\n"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|zeroival
argument_list|,
sizeof|sizeof
argument_list|(
name|zeroival
argument_list|)
argument_list|)
expr_stmt|;
name|ival
operator|=
name|zeroival
expr_stmt|;
name|ival
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|120
expr_stmt|;
name|sv
operator|.
name|sv_handler
operator|=
name|read_alarm
expr_stmt|;
name|sv
operator|.
name|sv_onstack
operator|=
literal|0
expr_stmt|;
name|sv
operator|.
name|sv_mask
operator|=
operator|~
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|sv
argument_list|,
operator|&
name|osv
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|cnt
operator|<
name|zp
operator|->
name|z_addrcnt
condition|;
name|cnt
operator|++
control|)
block|{
name|error
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|malloc
argument_list|(
literal|2
operator|*
name|PACKETSZ
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc(%u) failed"
argument_list|,
literal|2
operator|*
name|PACKETSZ
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
name|bufsize
operator|=
literal|2
operator|*
name|PACKETSZ
expr_stmt|;
block|}
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
expr_stmt|;
name|sin
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|sin
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
name|sin
operator|.
name|sin_addr
operator|=
name|zp
operator|->
name|z_addr
index|[
name|cnt
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"socket: %m"
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
break|break;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"connecting to server #%d %s, %d\n"
argument_list|,
name|cnt
operator|+
literal|1
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|.
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|connect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"connect failed, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|C_IN
argument_list|,
name|T_SOA
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"zone %s: res_mkquery T_SOA failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFER_FAIL
return|;
block|}
comment|/* 		 * Send length& message for zone transfer 		 */
if|if
condition|(
name|writemsg
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"writemsg failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* 		 * Get out your butterfly net and catch the SOA 		 */
name|cp
operator|=
name|buf
expr_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|read_interrupted
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|10
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Before setitimer\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|10
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"Before recv(l = %d)\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|recv
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|l
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|l
operator|-=
name|n
expr_stmt|;
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|10
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"bad recv->%d, errno= %d, read_interrupt=%d\n"
argument_list|,
name|n
argument_list|,
name|errno
argument_list|,
name|read_interrupted
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|n
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|==
name|EINTR
operator|&&
operator|!
name|read_interrupted
condition|)
continue|continue;
name|error
operator|++
expr_stmt|;
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|zeroival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|htons
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|len
operator|>
name|bufsize
condition|)
block|{
if|if
condition|(
operator|(
name|buf
operator|=
operator|(
name|u_char
operator|*
operator|)
name|realloc
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malloc(%u) failed for SOA from server %s, zone %s\n"
argument_list|,
name|len
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|bufsize
operator|=
name|len
expr_stmt|;
block|}
name|l
operator|=
name|len
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|recv
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|l
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|l
operator|-=
name|n
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|&&
operator|!
name|read_interrupted
condition|)
continue|continue;
name|error
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|10
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"recv failed: n= %d, errno = %d\n"
argument_list|,
name|n
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|zeroival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"len = %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp_query
argument_list|(
name|buf
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|ancount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|ancount
argument_list|)
expr_stmt|;
name|aucount
operator|=
name|ntohs
argument_list|(
name|hp
operator|->
name|nscount
argument_list|)
expr_stmt|;
comment|/* 		 * close socket if: 		 *  1) rcode != NOERROR 		 *  2) not an authority response 		 *  3) both the number of answers and authority count< 1) 		 */
if|if
condition|(
name|hp
operator|->
name|rcode
operator|!=
name|NOERROR
operator|||
operator|!
operator|(
name|hp
operator|->
name|aa
operator|)
operator|||
operator|(
name|ancount
operator|<
literal|1
operator|&&
name|aucount
operator|<
literal|1
operator|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s from %s, zone %s: rcode %d, aa %d, ancount %d, aucount %d\n"
argument_list|,
literal|"bad response to SOA query"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|hp
operator|->
name|aa
argument_list|,
name|ancount
argument_list|,
name|aucount
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"%s from %s, zone %s: rcode %d, aa %d, ancount %d, aucount %d\n"
argument_list|,
literal|"bad response to SOA query"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|hp
operator|->
name|rcode
argument_list|,
name|hp
operator|->
name|aa
argument_list|,
name|ancount
argument_list|,
name|aucount
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|zp_start
operator|=
operator|*
name|zp
expr_stmt|;
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
operator|+
name|QFIXEDSZ
condition|)
block|{
name|badsoa
label|:
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"malformed SOA from %s, zone %s: too short\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"malformed SOA from %s: too short\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
continue|continue;
block|}
name|tmp
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tmp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
name|tmp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tmp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|soa_zinfo
argument_list|(
operator|&
name|zp_start
argument_list|,
name|tmp
argument_list|,
name|eom
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
if|if
condition|(
name|zp_start
operator|.
name|z_serial
operator|>
name|serial_no
operator|||
name|serial_no
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"need update, serial %d\n"
argument_list|,
name|zp_start
operator|.
name|z_serial
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
name|hp
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|buf
expr_stmt|;
name|soacnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|soacnt
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|,
name|C_IN
argument_list|,
name|T_AXFR
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|buf
argument_list|,
name|bufsize
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"zone %s: res_mkquery T_AXFR failed"
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFER_FAIL
return|;
block|}
comment|/* 			     * Send length& message for zone transfer 			     */
if|if
condition|(
name|writemsg
argument_list|(
name|s
argument_list|,
name|buf
argument_list|,
name|n
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|error
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"writemsg failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
comment|/* 			 * Receive length& response 			 */
name|cp
operator|=
name|buf
expr_stmt|;
name|l
operator|=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* allow extra time for the fork on first read */
if|if
condition|(
name|soacnt
operator|==
literal|0
condition|)
name|ival
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|300
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|recv
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|l
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|l
operator|-=
name|n
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|&&
operator|!
name|read_interrupted
condition|)
continue|continue;
name|error
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"recv failed: n= %d, errno = %d\n"
argument_list|,
name|n
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
if|if
condition|(
name|soacnt
operator|==
literal|0
condition|)
name|ival
operator|.
name|it_value
operator|.
name|tv_sec
operator|=
literal|120
expr_stmt|;
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|zeroival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
if|if
condition|(
operator|(
name|len
operator|=
name|htons
argument_list|(
operator|*
operator|(
name|u_short
operator|*
operator|)
name|buf
argument_list|)
operator|)
operator|==
literal|0
condition|)
break|break;
name|l
operator|=
name|len
expr_stmt|;
name|cp
operator|=
name|buf
expr_stmt|;
name|eom
operator|=
name|buf
operator|+
name|len
expr_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|ival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|recv
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
name|l
argument_list|,
literal|0
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|n
expr_stmt|;
name|l
operator|-=
name|n
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|errno
operator|==
name|EINTR
operator|&&
operator|!
name|read_interrupted
condition|)
continue|continue;
name|error
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"recv failed\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|setitimer
argument_list|(
name|ITIMER_REAL
argument_list|,
operator|&
name|zeroival
argument_list|,
operator|(
expr|struct
name|itimerval
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
break|break;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"len = %d\n"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|fp_query
argument_list|(
name|buf
argument_list|,
name|ddt
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fp
condition|)
name|fp_query
argument_list|(
name|buf
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|len
operator|<
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
condition|)
block|{
name|badrec
label|:
name|error
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"record too short from %s, zone %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|,
name|zp
operator|->
name|z_source
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"record too short from %s\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
break|break;
block|}
name|cp
operator|=
name|buf
operator|+
sizeof|sizeof
argument_list|(
name|HEADER
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|->
name|qdcount
condition|)
block|{
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
operator|||
name|n
operator|+
name|QFIXEDSZ
operator|>=
name|eom
operator|-
name|cp
condition|)
goto|goto
name|badrec
goto|;
name|cp
operator|+=
name|n
operator|+
name|QFIXEDSZ
expr_stmt|;
block|}
name|nmp
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badrec
goto|;
name|tmp
operator|=
name|cp
operator|+
name|n
expr_stmt|;
name|n
operator|=
name|print_output
argument_list|(
name|buf
argument_list|,
name|bufsize
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|+
name|n
operator|!=
name|eom
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"getzone: print_update failed (%d, %d)\n"
argument_list|,
name|cp
operator|-
name|buf
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|error
operator|++
expr_stmt|;
break|break;
block|}
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|T_SOA
condition|)
block|{
if|if
condition|(
name|soacnt
operator|==
literal|0
condition|)
block|{
name|soacnt
operator|++
expr_stmt|;
if|if
condition|(
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
literal|512
argument_list|,
name|nmp
argument_list|,
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|name
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
if|if
condition|(
name|eom
operator|-
name|tmp
operator|<=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
goto|goto
name|badsoa
goto|;
name|tmp
operator|+=
literal|2
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tmp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|tmp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
name|tmp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|eom
operator|-
name|tmp
operator|<=
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
goto|goto
name|badsoa
goto|;
name|GETLONG
argument_list|(
name|serial
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"first SOA for %s, serial %d\n"
argument_list|,
name|name
argument_list|,
name|serial
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
continue|continue;
block|}
if|if
condition|(
name|dn_expand
argument_list|(
name|buf
argument_list|,
name|buf
operator|+
literal|512
argument_list|,
name|nmp
argument_list|,
name|name2
argument_list|,
sizeof|sizeof
argument_list|(
name|name2
argument_list|)
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
if|if
condition|(
name|strcasecmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|name
argument_list|,
operator|(
name|char
operator|*
operator|)
name|name2
argument_list|)
operator|!=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"extraneous SOA for %s\n"
argument_list|,
name|name2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
continue|continue;
block|}
name|tmp
operator|-=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
if|if
condition|(
name|soa_zinfo
argument_list|(
operator|&
name|zp_finish
argument_list|,
name|tmp
argument_list|,
name|eom
argument_list|)
operator|==
operator|-
literal|1
condition|)
goto|goto
name|badsoa
goto|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"SOA, serial %d\n"
argument_list|,
name|zp_finish
operator|.
name|z_serial
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|serial
operator|!=
name|zp_finish
operator|.
name|z_serial
condition|)
block|{
name|soacnt
operator|=
literal|0
expr_stmt|;
name|got_soa
operator|=
literal|0
expr_stmt|;
name|minimum_ttl
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|zp
operator|->
name|z_origin
argument_list|)
expr_stmt|;
name|prev_dname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"serial changed, restart\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
comment|/* 					 * Flush buffer, truncate file 					 * and seek to beginning to restart. 					 */
name|fflush
argument_list|(
name|dbfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftruncate
argument_list|(
name|fileno
argument_list|(
name|dbfp
argument_list|)
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ftruncate %s: %m\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
return|return
operator|(
name|XFER_FAIL
operator|)
return|;
block|}
name|fseek
argument_list|(
name|dbfp
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
break|break;
block|}
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|XFER_SUCCESS
return|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"error receiving zone transfer\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"zone up-to-date, serial %d\n"
argument_list|,
name|zp_start
operator|.
name|z_serial
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|DEBUG
return|return
name|XFER_UPTODATE
return|;
block|}
block|}
operator|(
name|void
operator|)
name|sigvec
argument_list|(
name|SIGALRM
argument_list|,
operator|&
name|osv
argument_list|,
operator|(
expr|struct
name|sigvec
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
condition|)
return|return
name|XFER_TIMEOUT
return|;
return|return
name|XFER_FAIL
return|;
block|}
end_block

begin_comment
comment|/*  * Set flag saying to read was interrupted  * used for a read timer  */
end_comment

begin_function
name|VOID
name|read_alarm
parameter_list|()
block|{
specifier|extern
name|int
name|read_interrupted
decl_stmt|;
name|read_interrupted
operator|=
literal|1
expr_stmt|;
block|}
end_function

begin_macro
name|writemsg
argument_list|(
argument|rfd
argument_list|,
argument|msg
argument_list|,
argument|msglen
argument_list|)
end_macro

begin_decl_stmt
name|int
name|rfd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msglen
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|iovec
name|iov
index|[
literal|2
index|]
decl_stmt|;
name|u_short
name|len
init|=
name|htons
argument_list|(
operator|(
name|u_short
operator|)
name|msglen
argument_list|)
decl_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
operator|&
name|len
expr_stmt|;
name|iov
index|[
literal|0
index|]
operator|.
name|iov_len
operator|=
sizeof|sizeof
argument_list|(
name|len
argument_list|)
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_base
operator|=
operator|(
name|caddr_t
operator|)
name|msg
expr_stmt|;
name|iov
index|[
literal|1
index|]
operator|.
name|iov_len
operator|=
name|msglen
expr_stmt|;
if|if
condition|(
name|writev
argument_list|(
name|rfd
argument_list|,
name|iov
argument_list|,
literal|2
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|len
argument_list|)
operator|+
name|msglen
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"write failed %d\n"
argument_list|,
name|errno
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_expr_stmt
name|soa_zinfo
argument_list|(
name|zp
argument_list|,
name|cp
argument_list|,
name|eom
argument_list|)
specifier|register
expr|struct
name|zoneinfo
operator|*
name|zp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|eom
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|n
decl_stmt|;
if|if
condition|(
name|eom
operator|-
name|cp
operator|<
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
literal|3
operator|*
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
operator|+
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
if|if
condition|(
name|eom
operator|-
name|cp
operator|<
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_serial
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_refresh
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|gettime
argument_list|(
operator|&
name|tt
argument_list|)
expr_stmt|;
name|zp
operator|->
name|z_time
operator|=
name|tt
operator|.
name|tv_sec
operator|+
name|zp
operator|->
name|z_refresh
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_retry
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_expire
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|zp
operator|->
name|z_minimum
argument_list|,
name|cp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_macro
name|gettime
argument_list|(
argument|ttp
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|timeval
modifier|*
name|ttp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|gettimeofday
argument_list|(
name|ttp
argument_list|,
operator|(
expr|struct
name|timezone
operator|*
operator|)
literal|0
argument_list|)
operator|<
literal|0
condition|)
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"gettimeofday failed: %m"
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Parse the message, determine if it should be printed, and if so, print it  * in .db file form.  * Does minimal error checking on the message content.  */
end_comment

begin_macro
name|print_output
argument_list|(
argument|msg
argument_list|,
argument|msglen
argument_list|,
argument|rrp
argument_list|)
end_macro

begin_decl_stmt
name|u_char
modifier|*
name|msg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|msglen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|u_char
modifier|*
name|rrp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
specifier|register
name|HEADER
modifier|*
name|hp
init|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
decl_stmt|;
name|u_long
name|addr
decl_stmt|,
name|ttl
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|tab
decl_stmt|,
name|result
decl_stmt|,
name|class
decl_stmt|,
name|type
decl_stmt|,
name|dlen
decl_stmt|,
name|n1
decl_stmt|;
name|long
name|n
decl_stmt|;
name|u_char
modifier|*
name|cp1
decl_stmt|,
name|data
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|u_char
modifier|*
name|temp_ptr
decl_stmt|;
comment|/* used to get ttl for RR */
name|char
modifier|*
name|cdata
decl_stmt|,
modifier|*
name|origin
decl_stmt|,
modifier|*
name|proto
decl_stmt|,
name|dname
index|[
name|MAXDNAME
index|]
decl_stmt|;
specifier|extern
name|char
modifier|*
name|inet_ntoa
argument_list|()
decl_stmt|,
modifier|*
name|protocolname
argument_list|()
decl_stmt|,
modifier|*
name|servicename
argument_list|()
decl_stmt|;
name|cp
operator|=
name|rrp
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|dname
argument_list|,
sizeof|sizeof
argument_list|(
name|dname
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|GETSHORT
argument_list|(
name|type
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|class
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|ttl
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|GETSHORT
argument_list|(
name|dlen
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|origin
operator|=
name|index
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|origin
operator|==
name|NULL
condition|)
name|origin
operator|=
literal|""
expr_stmt|;
else|else
name|origin
operator|++
expr_stmt|;
comment|/* move past the '.' */
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>
literal|2
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"print_output: dname %s type %d class %d ttl %d\n"
argument_list|,
name|dname
argument_list|,
name|type
argument_list|,
name|class
argument_list|,
name|ttl
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* 	 * Convert the resource record data into the internal database format. 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
case|case
name|T_WKS
case|:
case|case
name|T_HINFO
case|:
case|case
name|T_UINFO
case|:
case|case
name|T_TXT
case|:
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
name|cp1
operator|=
name|cp
expr_stmt|;
name|n
operator|=
name|dlen
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_NS
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
case|case
name|T_SOA
case|:
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
operator|(
name|n
operator|=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|data
argument_list|)
operator|+
literal|1
operator|)
expr_stmt|;
name|n1
operator|=
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
name|n
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
name|n1
operator|-=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|cp1
argument_list|,
name|n1
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|hp
operator|->
name|rcode
operator|=
name|FORMERR
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
name|temp_ptr
operator|=
name|cp
operator|+
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|minimum_ttl
argument_list|,
name|temp_ptr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|,
name|n
operator|=
literal|5
operator|*
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
name|cp1
operator|+=
name|n
expr_stmt|;
block|}
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
comment|/* grab preference */
name|bcopy
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|char
operator|*
operator|)
name|data
argument_list|,
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|data
operator|+
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
expr_stmt|;
comment|/* get name */
if|if
condition|(
operator|(
name|n
operator|=
name|dn_expand
argument_list|(
name|msg
argument_list|,
name|msg
operator|+
name|msglen
argument_list|,
name|cp
argument_list|,
name|cp1
argument_list|,
sizeof|sizeof
argument_list|(
name|data
argument_list|)
operator|-
sizeof|sizeof
argument_list|(
name|u_short
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|cp
operator|+=
name|n
expr_stmt|;
comment|/* compute end of data */
name|cp1
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp1
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* compute size of data */
name|n
operator|=
name|cp1
operator|-
name|data
expr_stmt|;
name|cp1
operator|=
name|data
expr_stmt|;
break|break;
default|default:
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|>=
literal|3
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"unknown type %d\n"
argument_list|,
name|type
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
operator|(
operator|(
name|cp
operator|-
name|rrp
operator|)
operator|+
name|dlen
operator|)
return|;
block|}
if|if
condition|(
name|n
operator|>
name|MAXDATA
condition|)
block|{
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|ddt
argument_list|,
literal|"update type %d: %d bytes is too much data\n"
argument_list|,
name|type
argument_list|,
name|n
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|hp
operator|->
name|rcode
operator|=
name|NOCHANGE
expr_stmt|;
comment|/* XXX - FORMERR ??? */
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|cdata
operator|=
operator|(
name|char
operator|*
operator|)
name|cp1
expr_stmt|;
name|result
operator|=
name|cp
operator|-
name|rrp
expr_stmt|;
comment|/* 	 * Only print one SOA per db file 	 */
if|if
condition|(
name|type
operator|==
name|T_SOA
condition|)
block|{
if|if
condition|(
name|got_soa
condition|)
return|return
name|result
return|;
else|else
name|got_soa
operator|++
expr_stmt|;
block|}
comment|/* 	 * If the origin has changed, print the new origin 	 */
if|if
condition|(
name|strcasecmp
argument_list|(
name|prev_origin
argument_list|,
name|origin
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_origin
argument_list|,
name|origin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"$ORIGIN %s.\n"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
block|}
name|tab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcasecmp
argument_list|(
name|prev_dname
argument_list|,
name|dname
argument_list|)
condition|)
block|{
comment|/* 		 * set the prev_dname to be the current dname, then cut off all 		 * characters of dname after (and including) the first '.' 		 */
name|char
modifier|*
name|cutp
init|=
name|index
argument_list|(
name|dname
argument_list|,
literal|'.'
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prev_dname
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|cutp
condition|)
operator|*
name|cutp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|dname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|origin
index|[
literal|0
index|]
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".%s.\t"
argument_list|,
name|origin
argument_list|)
expr_stmt|;
comment|/* ??? */
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t"
argument_list|,
name|dname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|dname
argument_list|)
operator|<
literal|8
condition|)
name|tab
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
name|tab
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ttl
operator|!=
literal|0
operator|&&
name|ttl
operator|!=
name|minimum_ttl
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%d\t"
argument_list|,
operator|(
name|int
operator|)
name|ttl
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|tab
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\t'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s\t%s\t"
argument_list|,
name|p_class
argument_list|(
name|class
argument_list|)
argument_list|,
name|p_type
argument_list|(
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cdata
expr_stmt|;
comment|/* 	 * Print type specific data 	 */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|T_A
case|:
switch|switch
condition|(
name|class
condition|)
block|{
case|case
name|C_IN
case|:
case|case
name|C_HS
case|:
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|n
operator|=
name|htonl
argument_list|(
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s"
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|n
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_CNAME
case|:
case|case
name|T_MB
case|:
case|case
name|T_MG
case|:
case|case
name|T_MR
case|:
case|case
name|T_PTR
case|:
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".\n"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_NS
case|:
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|cdata
expr_stmt|;
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|".\t"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_HINFO
case|:
if|if
condition|(
name|n
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\"%.*s\""
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|n
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|=
operator|*
name|cp
operator|++
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" \"%.*s\""
argument_list|,
operator|(
name|int
operator|)
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\"\""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_SOA
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s. (\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\t\t%lu"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu"
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %lu )\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MX
case|:
name|GETSHORT
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%lu"
argument_list|,
name|n
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_TXT
case|:
name|cp1
operator|=
name|cp
operator|+
name|n
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'"'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp
operator|<
name|cp1
condition|)
block|{
if|if
condition|(
name|i
operator|=
operator|*
name|cp
operator|++
condition|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|>
literal|0
operator|&&
name|cp
operator|<
name|cp1
condition|;
name|j
operator|--
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\\'
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|putc
argument_list|(
operator|*
name|cp
operator|++
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"\"\n"
argument_list|,
name|dbfp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UINFO
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\"%s\"\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_UID
case|:
case|case
name|T_GID
case|:
if|if
condition|(
name|n
operator|==
sizeof|sizeof
argument_list|(
name|u_long
argument_list|)
condition|)
block|{
name|GETLONG
argument_list|(
name|n
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%lu\n"
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|T_WKS
case|:
name|GETLONG
argument_list|(
name|addr
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|addr
operator|=
name|htonl
argument_list|(
name|addr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s "
argument_list|,
name|inet_ntoa
argument_list|(
operator|*
operator|(
expr|struct
name|in_addr
operator|*
operator|)
operator|&
name|addr
argument_list|)
argument_list|)
expr_stmt|;
name|proto
operator|=
name|protocolname
argument_list|(
operator|*
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
sizeof|sizeof
argument_list|(
name|char
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s "
argument_list|,
name|proto
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|cp
operator|<
operator|(
name|u_char
operator|*
operator|)
name|cdata
operator|+
name|n
condition|)
block|{
name|j
operator|=
operator|*
name|cp
operator|++
expr_stmt|;
do|do
block|{
if|if
condition|(
name|j
operator|&
literal|0200
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s"
argument_list|,
name|servicename
argument_list|(
name|i
argument_list|,
name|proto
argument_list|)
argument_list|)
expr_stmt|;
name|j
operator|<<=
literal|1
expr_stmt|;
block|}
do|while
condition|(
operator|++
name|i
operator|&
literal|07
condition|)
do|;
block|}
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|T_MINFO
case|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"%s."
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|" %s.\n"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|dbfp
argument_list|,
literal|"???\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|dbfp
argument_list|)
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"%s: %m"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_block

begin_comment
comment|/*  * Make a copy of a string and return a pointer to it.  */
end_comment

begin_function
name|char
modifier|*
name|savestr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|cp
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"savestr: %m"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|XFER_FAIL
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

end_unit

