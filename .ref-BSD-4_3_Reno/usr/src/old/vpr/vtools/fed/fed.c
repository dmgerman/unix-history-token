begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fed.c	4.2 (Berkeley) 8/11/83"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  *	Font editor for the HP 2648.  *  *	Mark Horton, 1/80  */
end_comment

begin_include
include|#
directive|include
file|"fed.h"
end_include

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGBUS
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSEGV
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGSYS
argument_list|,
name|onsig
argument_list|)
expr_stmt|;
while|while
condition|(
name|argc
operator|>
literal|1
operator|&&
name|argv
index|[
literal|1
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|1
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'T'
case|:
name|trace
operator|=
name|fopen
argument_list|(
literal|"trace"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|setbuf
argument_list|(
name|trace
argument_list|,
name|tracebuf
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'v'
case|:
name|vidinv
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|QUIET
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|printf
argument_list|(
literal|"Bad flag: %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|argc
operator|--
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s filename\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|env
argument_list|)
operator|==
literal|0
condition|)
block|{
name|initialize
argument_list|()
expr_stmt|;
name|editfont
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|cmdloop
argument_list|()
expr_stmt|;
block|}
end_function

begin_macro
name|cmdloop
argument_list|()
end_macro

begin_block
block|{
name|char
name|cmd
decl_stmt|;
name|setjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cmd
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|ESC
condition|)
name|cmd
operator|=
name|esccmd
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
comment|/* ^L: redraw munged up screen */
case|case
literal|'\14'
case|:
name|redraw
argument_list|()
expr_stmt|;
break|break;
comment|/* b: move cursor to base point of window */
case|case
literal|'b'
case|:
name|cch
argument_list|()
expr_stmt|;
name|curs_r
operator|=
name|cht
index|[
name|curchar
index|]
operator|.
name|rcent
expr_stmt|;
name|curs_c
operator|=
name|cht
index|[
name|curchar
index|]
operator|.
name|ccent
expr_stmt|;
name|turnoncurs
argument_list|()
expr_stmt|;
break|break;
comment|/* c: toggle whether cursor is on */
case|case
literal|'c'
case|:
if|if
condition|(
name|curcurs
condition|)
name|turnofcurs
argument_list|()
expr_stmt|;
else|else
name|turnoncurs
argument_list|()
expr_stmt|;
break|break;
comment|/* d: draw line of current flavor from pen to cursor */
case|case
literal|'d'
case|:
name|cch
argument_list|()
expr_stmt|;
name|bufmod
argument_list|()
expr_stmt|;
name|drawline
argument_list|(
name|pen_r
argument_list|,
name|pen_c
argument_list|,
name|curs_r
argument_list|,
name|curs_c
argument_list|)
expr_stmt|;
name|turnofcurs
argument_list|()
expr_stmt|;
name|turnofrb
argument_list|()
expr_stmt|;
name|pen_r
operator|=
name|curs_r
expr_stmt|;
name|pen_c
operator|=
name|curs_c
expr_stmt|;
name|syncwind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
break|break;
comment|/* f: fill in the current hole around the cursor */
case|case
literal|'f'
case|:
name|cch
argument_list|()
expr_stmt|;
name|bufmod
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"fillin(%d, %d)\n"
argument_list|,
name|curs_r
argument_list|,
name|curs_c
argument_list|)
expr_stmt|;
if|if
condition|(
name|mat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|curs_r
argument_list|,
name|curs_c
argument_list|)
condition|)
name|error
argument_list|(
literal|"Not in a hole"
argument_list|)
expr_stmt|;
name|fillin
argument_list|(
name|curs_r
argument_list|,
name|curs_c
argument_list|)
expr_stmt|;
name|curoff
argument_list|()
expr_stmt|;
name|syncwind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
break|break;
comment|/* g<x>: get glyph "x" as current. */
case|case
literal|'g'
case|:
if|if
condition|(
name|fontdes
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"No current font file"
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"get glyph<char>"
argument_list|)
expr_stmt|;
name|curchar
operator|=
name|inchar
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"get glyph %s"
argument_list|,
name|rdchar
argument_list|(
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
name|getglyph
argument_list|(
name|curchar
argument_list|)
expr_stmt|;
break|break;
comment|/* h, left arrow: move cursor left */
case|case
literal|'h'
case|:
name|cch
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs_c
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Off edge"
argument_list|)
expr_stmt|;
else|else
name|curs_c
operator|--
expr_stmt|;
name|turnoncurs
argument_list|()
expr_stmt|;
break|break;
comment|/* j, down arrow: move cursor down */
case|case
literal|'j'
case|:
name|cch
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs_r
operator|>=
name|GLROW
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Off edge"
argument_list|)
expr_stmt|;
else|else
name|curs_r
operator|++
expr_stmt|;
name|turnoncurs
argument_list|()
expr_stmt|;
break|break;
comment|/* k, up arrow: move cursor up */
case|case
literal|'k'
case|:
name|cch
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs_r
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|"Off edge"
argument_list|)
expr_stmt|;
else|else
name|curs_r
operator|--
expr_stmt|;
name|turnoncurs
argument_list|()
expr_stmt|;
break|break;
comment|/* l, right arrow: move cursor down */
case|case
literal|'l'
case|:
name|cch
argument_list|()
expr_stmt|;
if|if
condition|(
name|curs_c
operator|>=
name|GLCOL
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Off edge"
argument_list|)
expr_stmt|;
else|else
name|curs_c
operator|++
expr_stmt|;
name|turnoncurs
argument_list|()
expr_stmt|;
break|break;
comment|/* m: move the pen to where the cursor is */
case|case
literal|'m'
case|:
name|cch
argument_list|()
expr_stmt|;
name|pen_r
operator|=
name|curs_r
expr_stmt|;
name|pen_c
operator|=
name|curs_c
expr_stmt|;
name|turnoncurs
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|base
index|[
name|curwind
index|]
operator|.
name|c
operator|+
name|curs_c
argument_list|,
name|base
index|[
name|curwind
index|]
operator|.
name|r
operator|+
name|GLROW
operator|-
literal|1
operator|-
name|curs_r
argument_list|)
expr_stmt|;
name|turnonrb
argument_list|()
expr_stmt|;
break|break;
comment|/* n<x>: make a new glyph with char x */
case|case
literal|'n'
case|:
name|newglyph
argument_list|()
expr_stmt|;
break|break;
comment|/* p: print a hard copy on the printer of the screen */
case|case
literal|'p'
case|:
name|printg
argument_list|()
expr_stmt|;
break|break;
comment|/* r: toggle rubber band line */
case|case
literal|'r'
case|:
if|if
condition|(
name|currb
condition|)
name|turnofrb
argument_list|()
expr_stmt|;
else|else
name|turnonrb
argument_list|()
expr_stmt|;
break|break;
comment|/* s<what><where>: set<what> to<where> */
case|case
literal|'s'
case|:
name|setcmd
argument_list|()
expr_stmt|;
break|break;
comment|/* u: undo previous buffer modifying command */
case|case
literal|'u'
case|:
name|cch
argument_list|()
expr_stmt|;
name|undo
argument_list|()
expr_stmt|;
break|break;
comment|/* z<n>: set zoom to n. */
case|case
literal|'z'
case|:
name|message
argument_list|(
literal|"zoom to<level>"
argument_list|)
expr_stmt|;
name|curzoom
operator|=
name|inchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|curzoom
operator|==
literal|'\r'
operator|||
name|curzoom
operator|==
literal|'\n'
condition|)
name|curzoom
operator|=
name|oldzoom
expr_stmt|;
else|else
block|{
name|curzoom
operator|-=
literal|'0'
expr_stmt|;
name|oldzoom
operator|=
name|curzoom
expr_stmt|;
block|}
name|zoomn
argument_list|(
name|curzoom
argument_list|)
expr_stmt|;
break|break;
comment|/* space: reset zoom to last thing user asked for */
case|case
literal|' '
case|:
name|zoomn
argument_list|(
name|curzoom
operator|=
name|oldzoom
argument_list|)
expr_stmt|;
break|break;
comment|/* A: artificially embolden/italicize<range> by heavy pen size */
case|case
literal|'A'
case|:
name|bufmod
argument_list|()
expr_stmt|;
name|artificial
argument_list|()
expr_stmt|;
break|break;
comment|/* B: move base point of window to cursor */
case|case
literal|'B'
case|:
name|cch
argument_list|()
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|rcent
operator|=
name|curs_r
expr_stmt|;
name|cht
index|[
name|curchar
index|]
operator|.
name|ccent
operator|=
name|curs_c
expr_stmt|;
name|turnoncurs
argument_list|()
expr_stmt|;
break|break;
comment|/* 		 * C<from><to>: copy glyph<from> to<to>. 		 * M<from><to>: move glyph<from> to<to>. 		 */
case|case
literal|'C'
case|:
case|case
literal|'M'
case|:
name|copymove
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
comment|/* D<char1><char2>: delete range from font */
case|case
literal|'D'
case|:
name|delchar
argument_list|()
expr_stmt|;
break|break;
comment|/* F: display the entire font on the screen. */
case|case
literal|'F'
case|:
name|showfont
argument_list|()
expr_stmt|;
break|break;
comment|/* I: invert the current glyph */
case|case
literal|'I'
case|:
name|cch
argument_list|()
expr_stmt|;
name|bufmod
argument_list|()
expr_stmt|;
name|invert
argument_list|()
expr_stmt|;
break|break;
comment|/* K: kill (wipe clean) current glyph. */
case|case
literal|'K'
case|:
name|cch
argument_list|()
expr_stmt|;
name|bufmod
argument_list|()
expr_stmt|;
name|zermat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|)
expr_stmt|;
name|syncwind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"kill: curs_r = %d, curs_c = %d\n"
argument_list|,
name|curs_r
argument_list|,
name|curs_c
argument_list|)
expr_stmt|;
break|break;
comment|/* P<first><last><file>: read partial font */
case|case
literal|'P'
case|:
name|readchars
argument_list|()
expr_stmt|;
break|break;
comment|/* Q: quit the editor, not saving work. */
case|case
literal|'Q'
case|:
name|confirm
argument_list|()
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* T: typeset a line of input text */
case|case
literal|'T'
case|:
name|typein
argument_list|()
expr_stmt|;
break|break;
comment|/* V: toggle video between inverse and normal */
case|case
literal|'V'
case|:
name|togvid
argument_list|()
expr_stmt|;
break|break;
comment|/* 		 * E<file>: edit new font file<file>. 		 * N<file>: write, then edit<file> 		 * R<file>: read<file> on top of buffer. 		 * W<file>: write out on<file> without quitting 		 */
case|case
literal|'E'
case|:
case|case
literal|'N'
case|:
case|case
literal|'R'
case|:
case|case
literal|'W'
case|:
name|fileiocmd
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
break|break;
comment|/* Z: exit, writing out work */
case|case
literal|'Z'
case|:
name|message
argument_list|(
literal|"Z"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inchar
argument_list|()
operator|!=
literal|'Z'
condition|)
block|{
name|error
argument_list|(
literal|"No second Z"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|changes
condition|)
name|writeback
argument_list|()
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* 		 * ".", ">".  Set and clear the bit under the cursor. 		 */
case|case
literal|'.'
case|:
case|case
literal|'>'
case|:
name|bufmod
argument_list|()
expr_stmt|;
name|setmat
argument_list|(
name|wind
index|[
name|curwind
index|]
operator|.
name|val
argument_list|,
name|GLROW
argument_list|,
name|GLCOL
argument_list|,
name|curs_r
argument_list|,
name|curs_c
argument_list|,
name|cmd
operator|==
literal|'.'
condition|?
literal|1
else|:
literal|0
argument_list|)
expr_stmt|;
name|turnofcurs
argument_list|()
expr_stmt|;
name|syncwind
argument_list|(
name|curwind
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * "#": edit the numerical parameters 		 */
case|case
literal|'#'
case|:
name|numedit
argument_list|()
expr_stmt|;
break|break;
default|default:
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"No such command as %s"
argument_list|,
name|rdchar
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_comment
comment|/*  * esccmd: a command beginning with an escape.  * Map it into the corresponding regular command.  */
end_comment

begin_function
name|char
name|esccmd
parameter_list|()
block|{
name|char
name|cmd
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|char
name|escseqbuf
index|[
literal|20
index|]
decl_stmt|;
name|cmd
operator|=
name|inchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|cmd
condition|)
block|{
case|case
literal|'A'
case|:
return|return
operator|(
literal|'k'
operator|)
return|;
comment|/* up arrow */
case|case
literal|'B'
case|:
return|return
operator|(
literal|'j'
operator|)
return|;
comment|/* down arrow */
case|case
literal|'C'
case|:
return|return
operator|(
literal|'l'
operator|)
return|;
comment|/* right arrow */
case|case
literal|'D'
case|:
return|return
operator|(
literal|'h'
operator|)
return|;
comment|/* left arrow */
case|case
literal|'h'
case|:
return|return
operator|(
literal|'b'
operator|)
return|;
comment|/* home */
case|case
literal|'2'
case|:
return|return
operator|(
literal|'u'
operator|)
return|;
comment|/* clear tab = undo */
case|case
literal|'1'
case|:
return|return
operator|(
literal|' '
operator|)
return|;
comment|/* set tab = rezoom */
case|case
literal|'J'
case|:
return|return
operator|(
literal|'f'
operator|)
return|;
comment|/* clear display = fill area */
case|case
literal|'S'
case|:
return|return
operator|(
literal|'m'
operator|)
return|;
comment|/* roll up = move */
case|case
literal|'U'
case|:
return|return
operator|(
literal|'d'
operator|)
return|;
comment|/* next page = draw */
case|case
literal|'T'
case|:
return|return
operator|(
literal|'.'
operator|)
return|;
comment|/* roll down = set bit */
case|case
literal|'V'
case|:
return|return
operator|(
literal|'>'
operator|)
return|;
comment|/* prev page = clear bit */
default|default:
comment|/* 		 * Eat up rest of (possibly long) escape sequence. 		 * They all end in an upper case letter, with 		 * a few exceptions. 		 */
name|p
operator|=
name|escseqbuf
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|'$'
expr_stmt|;
operator|*
name|p
operator|++
operator|=
name|cmd
expr_stmt|;
while|while
condition|(
operator|!
name|isupper
argument_list|(
name|cmd
argument_list|)
operator|&&
name|cmd
operator|!=
literal|'h'
operator|&&
name|cmd
operator|!=
literal|'\n'
condition|)
operator|*
name|p
operator|++
operator|=
name|cmd
operator|=
name|inchar
argument_list|()
expr_stmt|;
operator|*
name|p
operator|++
operator|=
literal|0
expr_stmt|;
name|sprintf
argument_list|(
name|msgbuf
argument_list|,
literal|"Bad escape sequence: %s\n"
argument_list|,
name|escseqbuf
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|msgbuf
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_macro
name|onsig
argument_list|(
argument|signo
argument_list|)
end_macro

begin_decl_stmt
name|int
name|signo
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|mes
decl_stmt|;
switch|switch
condition|(
name|signo
condition|)
block|{
case|case
name|SIGQUIT
case|:
name|mes
operator|=
literal|"quit"
expr_stmt|;
break|break;
case|case
name|SIGILL
case|:
name|mes
operator|=
literal|"illegal instruction"
expr_stmt|;
break|break;
case|case
name|SIGBUS
case|:
name|mes
operator|=
literal|"bus error"
expr_stmt|;
break|break;
case|case
name|SIGSEGV
case|:
name|mes
operator|=
literal|"segmentation violation"
expr_stmt|;
break|break;
case|case
name|SIGSYS
case|:
name|mes
operator|=
literal|"bad system call"
expr_stmt|;
break|break;
default|default:
name|mes
operator|=
literal|"random signal"
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|trace
argument_list|,
literal|"%s: core dumped\n"
argument_list|,
name|mes
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|trace
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGILL
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|done
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"fed: %s: core dumped\n"
argument_list|,
name|mes
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|onintr
argument_list|()
end_macro

begin_block
block|{
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|onintr
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Interrupted"
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|env
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

