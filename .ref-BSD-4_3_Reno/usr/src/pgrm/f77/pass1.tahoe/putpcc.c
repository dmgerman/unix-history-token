begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)putpcc.c	5.1 (Berkeley) 6/7/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * putpcc.c  *  * Intermediate code generation for S. C. Johnson C compilers  * New version using binary polish postfix intermediate  *  * University of Utah CS Dept modification history:  *  * $Header: putpcc.c,v 3.2 85/03/25 09:35:57 root Exp $  * $Log:	putpcc.c,v $  * Revision 3.2  85/03/25  09:35:57  root  * fseek return -1 on error.  *   * Revision 3.1  85/02/27  19:06:55  donn  * Changed to use pcc.h instead of pccdefs.h.  *   * Revision 2.12  85/02/22  01:05:54  donn  * putaddr() didn't know about intrinsic functions...  *   * Revision 2.11  84/11/28  21:28:49  donn  * Hacked putop() to handle any character expression being converted to int,  * not just function calls.  Previously it bombed on concatenations.  *   * Revision 2.10  84/11/01  22:07:07  donn  * Yet another try at getting putop() to work right.  It appears that the  * second pass can't abide certain explicit conversions (e.g. short to long)  * so the conversion code in putop() tries to remove them.  I think this  * version (finally) works.  *   * Revision 2.9  84/10/29  02:30:57  donn  * Earlier fix to putop() for conversions was insufficient -- we NEVER want to  * see the type of the left operand of the thing left over from stripping off  * conversions...  *   * Revision 2.8  84/09/18  03:09:21  donn  * Fixed bug in putop() where the left operand of an addrblock was being  * extracted...  This caused an extremely obscure conversion error when  * an array of longs was subscripted by a short.  *   * Revision 2.7  84/08/19  20:10:19  donn  * Removed stuff in putbranch that treats STGARG parameters specially -- the  * bug in the code generation pass that motivated it has been fixed.  *   * Revision 2.6  84/08/07  21:32:23  donn  * Bumped the size of the buffer for the intermediate code file from 0.5K  * to 4K on a VAX.  *   * Revision 2.5  84/08/04  20:26:43  donn  * Fixed a goof in the new putbranch() -- it now calls mkaltemp instead of  * mktemp().  Correction due to Jerry Berkman.  *   * Revision 2.4  84/07/24  19:07:15  donn  * Fixed bug reported by Craig Leres in which putmnmx() mistakenly assumed  * that mkaltemp() returns tempblocks, and tried to free them with frtemp().  *   * Revision 2.3  84/07/19  17:22:09  donn  * Changed putch1() so that OPPAREN expressions of type CHARACTER are legal.  *   * Revision 2.2  84/07/19  12:30:38  donn  * Fixed a type clash in Bob Corbett's new putbranch().  *   * Revision 2.1  84/07/19  12:04:27  donn  * Changed comment headers for UofU.  *   * Revision 1.8  84/07/19  11:38:23  donn  * Replaced putbranch() routine so that you can ASSIGN into argument variables.  * The code is from Bob Corbett, donated by Jerry Berkman.  *   * Revision 1.7  84/05/31  00:48:32  donn  * Fixed an extremely obscure bug dealing with the comparison of CHARACTER*1  * expressions -- a foulup in the order of COMOP and the comparison caused  * one operand of the comparison to be garbage.  *   * Revision 1.6  84/04/16  09:54:19  donn  * Backed out earlier fix for bug where items in the argtemplist were  * (incorrectly) being given away; this is now fixed in mkargtemp().  *   * Revision 1.5  84/03/23  22:49:48  donn  * Took out the initialization of the subroutine argument temporary list in  * putcall() -- it needs to be done once per statement instead of once per call.  *   * Revision 1.4  84/03/01  06:48:05  donn  * Fixed bug in Bob Corbett's code for argument temporaries that caused an  * addrblock to get thrown out inadvertently when it was needed for recycling  * purposes later on.  *   * Revision 1.3  84/02/26  06:32:38  donn  * Added Berkeley changes to move data definitions around and reduce offsets.  *   * Revision 1.2  84/02/26  06:27:45  donn  * Added code to catch TTEMP values passed to putx().  *   */
end_comment

begin_if
if|#
directive|if
name|FAMILY
operator|!=
name|PCC
end_if

begin_expr_stmt
name|WRONG
name|put
name|FILE
operator|!
operator|!
operator|!
operator|!
endif|#
directive|endif
include|#
directive|include
file|"defs.h"
include|#
directive|include
file|<pcc.h>
name|Addrp
name|putcall
argument_list|()
operator|,
name|putcxeq
argument_list|()
operator|,
name|putcx1
argument_list|()
operator|,
name|realpart
argument_list|()
expr_stmt|;
end_expr_stmt

begin_function_decl
name|expptr
name|imagpart
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|ftnint
name|lencat
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|FOUR
value|4
end_define

begin_decl_stmt
specifier|extern
name|int
name|ops2
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|types2
index|[]
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|HERE
operator|==
name|VAX
operator|||
name|HERE
operator|==
name|TAHOE
end_if

begin_define
define|#
directive|define
name|PCC_BUFFMAX
value|1024
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|PCC_BUFFMAX
value|128
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|long
name|int
name|p2buff
index|[
name|PCC_BUFFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|p2bufp
init|=
operator|&
name|p2buff
index|[
literal|0
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|int
modifier|*
name|p2bufend
init|=
operator|&
name|p2buff
index|[
name|PCC_BUFFMAX
index|]
decl_stmt|;
end_decl_stmt

begin_macro
name|puthead
argument_list|(
argument|s
argument_list|,
argument|class
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|class
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|VAX
operator|||
name|TARGET
operator|==
name|TAHOE
if|if
condition|(
name|s
condition|)
name|p2ps
argument_list|(
literal|"\t.globl\t_%s"
argument_list|,
name|s
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* put out fake copy of left bracket line, to be redone later */
if|if
condition|(
operator|!
name|headerdone
condition|)
block|{
if|#
directive|if
name|FAMILY
operator|==
name|PCC
name|p2flush
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|headoffset
operator|=
name|ftell
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|prhead
argument_list|(
name|textfile
argument_list|)
expr_stmt|;
name|headerdone
operator|=
name|YES
expr_stmt|;
name|p2triple
argument_list|(
name|PCCF_FEXPR
argument_list|,
operator|(
name|strlen
argument_list|(
name|infname
argument_list|)
operator|+
name|ALILONG
operator|-
literal|1
operator|)
operator|/
name|ALILONG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|infname
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|PDP11
comment|/* fake jump to start the optimizer */
if|if
condition|(
name|class
operator|!=
name|CLBLOCK
condition|)
name|putgoto
argument_list|(
name|fudgelabel
operator|=
name|newlabel
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
operator|||
name|TARGET
operator|==
name|TAHOE
comment|/* jump from top to bottom */
if|if
condition|(
name|s
operator|!=
name|CNULL
operator|&&
name|class
operator|!=
name|CLBLOCK
condition|)
block|{
name|int
name|proflab
init|=
name|newlabel
argument_list|()
decl_stmt|;
name|p2pass
argument_list|(
literal|"\t.align\t1"
argument_list|)
expr_stmt|;
name|p2ps
argument_list|(
literal|"_%s:"
argument_list|,
name|s
argument_list|)
expr_stmt|;
name|p2pi
argument_list|(
literal|"\t.word\tLWM%d"
argument_list|,
name|procno
argument_list|)
expr_stmt|;
name|prsave
argument_list|(
name|proflab
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|VAX
name|p2pi
argument_list|(
literal|"\tjbr\tL%d"
argument_list|,
else|#
directive|else
argument|putgoto(
endif|#
directive|endif
argument|fudgelabel = newlabel()); 		}
endif|#
directive|endif
argument|} }
comment|/* It is necessary to precede each procedure with a "left bracket"  * line that tells pass 2 how many register variables and how  * much automatic space is required for the function.  This compiler  * does not know how much automatic space is needed until the  * entire procedure has been processed.  Therefore, "puthead"  * is called at the begining to record the current location in textfile,  * then to put out a placeholder left bracket line.  This procedure  * repositions the file and rewrites that line, then puts the  * file pointer back to the end of the file.  */
argument|putbracket() { long int hereoffset;
if|#
directive|if
name|FAMILY
operator|==
name|PCC
argument|p2flush();
endif|#
directive|endif
argument|hereoffset = ftell(textfile); if(fseek(textfile, headoffset,
literal|0
argument|) == -
literal|1
argument|) 	fatal(
literal|"fseek failed"
argument|); prhead(textfile); if(fseek(textfile, hereoffset,
literal|0
argument|) == -
literal|1
argument|) 	fatal(
literal|"fseek failed 2"
argument|); }     putrbrack(k) int k; { p2op(PCCF_FRBRAC, k); }    putnreg() { }       puteof() { p2op(PCCF_FEOF,
literal|0
argument|); p2flush(); }    putstmt() { p2triple(PCCF_FEXPR,
literal|0
argument|, lineno); }
comment|/* put out code for if( ! p) goto l  */
argument|putif(p,l) register expptr p; int l; { register int k;  if( ( k = (p = fixtype(p))->headblock.vtype) != TYLOGICAL) 	{ 	if(k != TYERROR) 		err(
literal|"non-logical expression in IF statement"
argument|); 	frexpr(p); 	} else 	{ 	putex1(p); 	p2icon( (long int) l , PCCT_INT); 	p2op(PCC_CBRANCH,
literal|0
argument|); 	putstmt(); 	} }
comment|/* put out code for  goto l   */
argument|putgoto(label) int label; { p2triple(PCC_GOTO,
literal|1
argument|, label); putstmt(); }
comment|/* branch to address constant or integer variable */
argument|putbranch(p) register Addrp p; {   putex1((expptr) p);   p2op(PCC_GOTO, PCCT_INT);   putstmt(); }
comment|/* put out label  l:     */
argument|putlabel(label) int label; { p2op(PCCF_FLABEL, label); }     putexpr(p) expptr p; { putex1(p); putstmt(); }     putcmgo(index, nlab, labs) expptr index; int nlab; struct Labelblock *labs[]; { int i
argument_list|,
argument|labarray
argument_list|,
argument|skiplabel;  if(! ISINT(index->headblock.vtype) ) 	{ 	execerr(
literal|"computed goto index must be integer"
argument|, CNULL); 	return; 	}
if|#
directive|if
name|TARGET
operator|==
name|VAX
operator|||
name|TARGET
operator|==
name|TAHOE
comment|/* use special case instruction */
argument|casegoto(index, nlab, labs);
else|#
directive|else
argument|labarray = newlabel(); 	preven(ALIADDR); 	prlabel(asmfile, labarray); 	prcona(asmfile, (ftnint) (skiplabel = newlabel()) ); 	for(i =
literal|0
argument|; i< nlab ; ++i) 		if( labs[i] ) 			prcona(asmfile, (ftnint)(labs[i]->labelno) ); 	prcmgoto(index, nlab, skiplabel, labarray); 	putlabel(skiplabel);
endif|#
directive|endif
argument|}
argument|putx(p) expptr p; { char *memname(); int opc; int ncomma; int type
argument_list|,
argument|k;  if (!p) 	return;  switch(p->tag) 	{ 	case TERROR: 		free( (charptr) p ); 		break;  	case TCONST: 		switch(type = p->constblock.vtype) 			{ 			case TYLOGICAL: 				type = tyint; 			case TYLONG: 			case TYSHORT: 				p2icon(p->constblock.const.ci, types2[type]); 				free( (charptr) p ); 				break;  			case TYADDR: 				p2triple(PCC_ICON,
literal|1
argument|, PCCT_INT|PCCTM_PTR); 				p2word(
literal|0L
argument|); 				p2name(memname(STGCONST, 					(int) p->constblock.const.ci) ); 				free( (charptr) p ); 				break;  			default: 				putx( putconst(p) ); 				break; 			} 		break;  	case TEXPR: 		switch(opc = p->exprblock.opcode) 			{ 			case OPCALL: 			case OPCCALL: 				if( ISCOMPLEX(p->exprblock.vtype) ) 					putcxop(p); 				else	putcall(p); 				break;  			case OPMIN: 			case OPMAX: 				putmnmx(p); 				break;   			case OPASSIGN: 				if(ISCOMPLEX(p->exprblock.leftp->headblock.vtype) 				|| ISCOMPLEX(p->exprblock.rightp->headblock.vtype) ) 					frexpr( putcxeq(p) ); 				else if( ISCHAR(p) ) 					putcheq(p); 				else 					goto putopp; 				break;  			case OPEQ: 			case OPNE: 				if( ISCOMPLEX(p->exprblock.leftp->headblock.vtype) || 				    ISCOMPLEX(p->exprblock.rightp->headblock.vtype) ) 					{ 					putcxcmp(p); 					break; 					} 			case OPLT: 			case OPLE: 			case OPGT: 			case OPGE: 				if(ISCHAR(p->exprblock.leftp)) 					{ 					putchcmp(p); 					break; 					} 				goto putopp;  			case OPPOWER: 				putpower(p); 				break;  			case OPSTAR:
if|#
directive|if
name|FAMILY
operator|==
name|PCC
comment|/*   m * (2**k) -> m<<k   */
argument|if(INT(p->exprblock.leftp->headblock.vtype)&& 				   ISICON(p->exprblock.rightp)&& 				   ( (k = log2(p->exprblock.rightp->constblock.const.ci))>
literal|0
argument|) ) 					{ 					p->exprblock.opcode = OPLSHIFT; 					frexpr(p->exprblock.rightp); 					p->exprblock.rightp = ICON(k); 					goto putopp; 					}
endif|#
directive|endif
argument|case OPMOD: 				goto putopp; 			case OPPLUS: 			case OPMINUS: 			case OPSLASH: 			case OPNEG: 				if( ISCOMPLEX(p->exprblock.vtype) ) 					putcxop(p); 				else	goto putopp; 				break;  			case OPCONV: 				if( ISCOMPLEX(p->exprblock.vtype) ) 					putcxop(p); 				else if( ISCOMPLEX(p->exprblock.leftp->headblock.vtype) ) 					{ 					ncomma =
literal|0
argument|; 					putx( mkconv(p->exprblock.vtype, 						realpart(putcx1(p->exprblock.leftp,&ncomma)))); 					putcomma(ncomma, p->exprblock.vtype, NO); 					free( (charptr) p ); 					} 				else	goto putopp; 				break;  			case OPNOT: 			case OPOR: 			case OPAND: 			case OPEQV: 			case OPNEQV: 			case OPADDR: 			case OPPLUSEQ: 			case OPSTAREQ: 			case OPCOMMA: 			case OPQUEST: 			case OPCOLON: 			case OPBITOR: 			case OPBITAND: 			case OPBITXOR: 			case OPBITNOT: 			case OPLSHIFT: 			case OPRSHIFT: 		putopp: 				putop(p); 				break;  			case OPPAREN: 				putx (p->exprblock.leftp); 				break; 			default: 				badop(
literal|"putx"
argument|, opc); 			} 		break;  	case TADDR: 		putaddr(p, YES); 		break;  	case TTEMP:
comment|/* 		 * This type is sometimes passed to putx when errors occur 		 *	upstream, I don't know why. 		 */
argument|frexpr(p); 		break;  	default: 		badtag(
literal|"putx"
argument|, p->tag); 	} }    LOCAL putop(p) expptr p; { int k; expptr lp
argument_list|,
argument|tp; int pt
argument_list|,
argument|lt
argument_list|,
argument|tt; int comma; Addrp putch1();  switch(p->exprblock.opcode)
comment|/* check for special cases and rewrite */
argument|{ 	case OPCONV: 		tt = pt = p->exprblock.vtype; 		lp = p->exprblock.leftp; 		lt = lp->headblock.vtype;
if|#
directive|if
name|TARGET
operator|==
name|VAX
argument|if (pt == TYREAL&& lt == TYDREAL) 			{ 			putx(lp); 			p2op(PCC_SCONV, PCCT_FLOAT); 			return; 			}
endif|#
directive|endif
argument|while(p->tag==TEXPR&& p->exprblock.opcode==OPCONV&& (
if|#
directive|if
name|TARGET
operator|!=
name|TAHOE
argument|(ISREAL(pt)&&ISREAL(lt)) ||
endif|#
directive|endif
argument|(INT(pt)&&(ONEOF(lt,MSKINT|MSKADDR|MSKCHAR|M(TYSUBR)))) )) 			{
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
argument|if(lp->tag != TEXPR) 				{ 				if(pt==TYINT&& lt==TYLONG) 					break; 				if(lt==TYINT&& pt==TYLONG) 					break; 				}
endif|#
directive|endif
if|#
directive|if
name|TARGET
operator|==
name|VAX
argument|if(pt==TYDREAL&& lt==TYREAL) 				{ 				if(lp->tag==TEXPR&& 				   lp->exprblock.opcode==OPCONV&& 				   lp->exprblock.leftp->headblock.vtype==TYDREAL) 					{ 					putx(lp->exprblock.leftp); 					p2op(PCC_SCONV, PCCT_FLOAT); 					p2op(PCC_SCONV, PCCT_DOUBLE); 					free( (charptr) p ); 					return; 					} 				else break; 				}
endif|#
directive|endif
argument|if(lt==TYCHAR&& lp->tag==TEXPR) 				{ 				int ncomma =
literal|0
argument|; 				p->exprblock.leftp = (expptr) putch1(lp,&ncomma); 				putop(p); 				putcomma(ncomma, pt, NO); 				free( (charptr) p ); 				return; 				} 			free( (charptr) p ); 			p = lp; 			pt = lt; 			if (p->tag == TEXPR) 				{ 				lp = p->exprblock.leftp; 				lt = lp->headblock.vtype; 				} 			} 		if(p->tag==TEXPR&& p->exprblock.opcode==OPCONV) 			break; 		putx(p); 		if (types2[tt] != types2[pt]&& 		    ! ( (ISREAL(tt)&&ISREAL(pt)) || 			(INT(tt)&&(ONEOF(pt,MSKINT|MSKADDR|MSKCHAR|M(TYSUBR)))) )) 			p2op(PCC_SCONV,types2[tt]); 		return;  	case OPADDR: 		comma = NO; 		lp = p->exprblock.leftp; 		if(lp->tag != TADDR) 			{ 			tp = (expptr) mkaltemp 				(lp->headblock.vtype,lp->headblock.vleng); 			putx( mkexpr(OPASSIGN, cpexpr(tp), lp) ); 			lp = tp; 			comma = YES; 			} 		putaddr(lp, NO); 		if(comma) 			putcomma(
literal|1
argument|, TYINT, NO); 		free( (charptr) p ); 		return;
if|#
directive|if
name|TARGET
operator|==
name|VAX
operator|||
name|TARGET
operator|==
name|TAHOE
comment|/* take advantage of a glitch in the code generator that does not check    the type clash in an assignment or comparison of an integer zero and    a floating left operand, and generates optimal code for the correct    type.  (The PCC has no floating-constant node to encode this correctly.) */
argument|case OPASSIGN: 	case OPLT: 	case OPLE: 	case OPGT: 	case OPGE: 	case OPEQ: 	case OPNE: 		if(ISREAL(p->exprblock.leftp->headblock.vtype)&& 		   ISREAL(p->exprblock.rightp->headblock.vtype)&& 		   ISCONST(p->exprblock.rightp)&& 		   p->exprblock.rightp->constblock.const.cd[
literal|0
argument|]==
literal|0
argument|) 			{ 			p->exprblock.rightp->constblock.vtype = TYINT; 			p->exprblock.rightp->constblock.const.ci =
literal|0
argument|; 			}
endif|#
directive|endif
argument|}  if( (k = ops2[p->exprblock.opcode])<=
literal|0
argument|) 	badop(
literal|"putop"
argument|, p->exprblock.opcode); putx(p->exprblock.leftp); if(p->exprblock.rightp) 	putx(p->exprblock.rightp); p2op(k, types2[p->exprblock.vtype]);  if(p->exprblock.vleng) 	frexpr(p->exprblock.vleng); free( (charptr) p ); }
argument|putforce(t, p) int t; expptr p; { p = mkconv(t, fixtype(p)); putx(p); p2op(PCC_FORCE,
if|#
directive|if
name|TARGET
operator|==
name|TAHOE
argument|(t==TYLONG ? PCCT_LONG : (t==TYREAL ? PCCT_FLOAT : PCCT_DOUBLE)) );
else|#
directive|else
argument|(t==TYSHORT ? PCCT_SHORT : (t==TYLONG ? PCCT_LONG : PCCT_DOUBLE))
argument_list|)
empty_stmt|;
endif|#
directive|endif
name|putstmt
argument_list|()
expr_stmt|;
block|}
name|LOCAL
name|putpower
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|expptr
name|base
decl_stmt|;
name|Addrp
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|ftnint
name|k
decl_stmt|;
name|int
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
operator|||
operator|(
name|k
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|)
operator|<
literal|2
condition|)
name|fatal
argument_list|(
literal|"putpower: bad call"
argument_list|)
expr_stmt|;
name|base
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|type
operator|=
name|base
operator|->
name|headblock
operator|.
name|vtype
expr_stmt|;
if|if
condition|(
operator|(
name|k
operator|==
literal|2
operator|)
operator|&&
name|base
operator|->
name|tag
operator|==
name|TADDR
operator|&&
name|ISCONST
argument_list|(
name|base
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
condition|)
block|{
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
name|t1
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|t2
operator|=
name|NULL
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|base
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
init|;
operator|(
name|k
operator|&
literal|1
operator|)
operator|==
literal|0
operator|&&
name|k
operator|>
literal|2
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|2
condition|)
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|t2
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|>>=
literal|1
init|;
name|k
operator|>
literal|1
condition|;
name|k
operator|>>=
literal|1
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t1
argument_list|,
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|&
literal|1
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putsteq
argument_list|(
name|t2
argument_list|,
name|t1
argument_list|)
expr_stmt|;
block|}
block|}
name|putx
argument_list|(
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t2
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|t1
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|t1
argument_list|)
expr_stmt|;
if|if
condition|(
name|t2
condition|)
name|frexpr
argument_list|(
name|t2
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|Addrp
name|intdouble
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
name|Addrp
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|Addrp
name|t
decl_stmt|;
name|t
operator|=
name|mkaltemp
argument_list|(
name|TYDREAL
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|t
operator|)
return|;
block|}
name|LOCAL
name|Addrp
name|putcxeq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcxeq"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|lp
operator|)
return|;
block|}
name|LOCAL
name|putcxop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|Addrp
name|putcx1
parameter_list|()
function_decl|;
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putcx1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|Addrp
name|putcx1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
name|expptr
name|q
decl_stmt|;
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
specifier|register
name|Addrp
name|resp
decl_stmt|;
name|int
name|opcode
decl_stmt|;
name|int
name|ltype
decl_stmt|,
name|rtype
decl_stmt|;
name|expptr
name|mkrealcon
parameter_list|()
function_decl|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|constblock
operator|.
name|vtype
argument_list|)
condition|)
name|p
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TADDR
case|:
if|if
condition|(
operator|!
name|addressable
argument_list|(
name|p
argument_list|)
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mkaltemp
argument_list|(
name|tyint
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memoffset
argument_list|)
expr_stmt|;
name|p
operator|->
name|addrblock
operator|.
name|memoffset
operator|=
operator|(
name|expptr
operator|)
name|resp
expr_stmt|;
block|}
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|)
condition|)
break|break;
operator|++
operator|*
name|ncommap
expr_stmt|;
name|resp
operator|=
name|mkaltemp
argument_list|(
name|TYDREAL
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|resp
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
default|default:
name|badtag
argument_list|(
literal|"putcx1"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
name|opcode
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
if|if
condition|(
name|opcode
operator|==
name|OPCALL
operator|||
name|opcode
operator|==
name|OPCCALL
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcall
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|opcode
operator|==
name|OPASSIGN
condition|)
block|{
operator|++
operator|*
name|ncommap
expr_stmt|;
return|return
operator|(
name|putcxeq
argument_list|(
name|p
argument_list|)
operator|)
return|;
block|}
name|resp
operator|=
name|mkaltemp
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vtype
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|ltype
operator|=
name|lp
operator|->
name|vtype
expr_stmt|;
if|if
condition|(
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|ncommap
argument_list|)
condition|)
name|rtype
operator|=
name|rp
operator|->
name|vtype
expr_stmt|;
switch|switch
condition|(
name|opcode
condition|)
block|{
case|case
name|OPPAREN
case|:
name|frexpr
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|lp
expr_stmt|;
name|lp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPCOMMA
case|:
name|frexpr
argument_list|(
name|resp
argument_list|)
expr_stmt|;
name|resp
operator|=
name|rp
expr_stmt|;
name|rp
operator|=
name|NULL
expr_stmt|;
break|break;
case|case
name|OPNEG
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPPLUS
case|:
case|case
name|OPMINUS
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|opcode
operator|==
name|OPPLUS
condition|)
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPNEG
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|,
name|ENULL
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSTAR
case|:
if|if
condition|(
name|ltype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|ltype
argument_list|)
condition|)
name|lp
operator|=
name|intdouble
argument_list|(
name|lp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|rtype
operator|<
name|TYCOMPLEX
condition|)
block|{
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPMINUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPSLASH
case|:
comment|/* fixexpr has already replaced all divisions 		 * by a complex by a function call 		 */
if|if
condition|(
name|ISINT
argument_list|(
name|rtype
argument_list|)
condition|)
name|rp
operator|=
name|intdouble
argument_list|(
name|rp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|OPSLASH
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
name|putassign
argument_list|(
name|realpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|lp
operator|->
name|vtype
argument_list|)
condition|)
name|q
operator|=
name|imagpart
argument_list|(
name|lp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|rp
operator|!=
name|NULL
condition|)
name|q
operator|=
operator|(
name|expptr
operator|)
name|realpart
argument_list|(
name|rp
argument_list|)
expr_stmt|;
else|else
name|q
operator|=
name|mkrealcon
argument_list|(
name|TYDREAL
argument_list|,
literal|0.0
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|imagpart
argument_list|(
name|resp
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putcx1"
argument_list|,
name|opcode
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|resp
operator|)
return|;
block|}
name|LOCAL
name|putcxcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|opcode
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|expptr
name|q
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcxcmp"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|opcode
operator|=
name|p
operator|->
name|exprblock
operator|.
name|opcode
expr_stmt|;
name|lp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|rp
operator|=
name|putcx1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|q
operator|=
name|mkexpr
argument_list|(
name|opcode
operator|==
name|OPEQ
condition|?
name|OPAND
else|:
name|OPOR
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|realpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|realpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|,
name|mkexpr
argument_list|(
name|opcode
argument_list|,
name|imagpart
argument_list|(
name|lp
argument_list|)
argument_list|,
name|imagpart
argument_list|(
name|rp
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|fixexpr
argument_list|(
name|q
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|lp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|Addrp
name|putch1
parameter_list|(
name|p
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
name|int
modifier|*
name|ncommap
decl_stmt|;
block|{
specifier|register
name|Addrp
name|t
decl_stmt|;
switch|switch
condition|(
name|p
operator|->
name|tag
condition|)
block|{
case|case
name|TCONST
case|:
return|return
operator|(
name|putconst
argument_list|(
name|p
argument_list|)
operator|)
return|;
case|case
name|TADDR
case|:
return|return
operator|(
operator|(
name|Addrp
operator|)
name|p
operator|)
return|;
case|case
name|TEXPR
case|:
operator|++
operator|*
name|ncommap
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
condition|)
block|{
name|expptr
name|q
decl_stmt|;
case|case
name|OPCALL
case|:
case|case
name|OPCCALL
case|:
name|t
operator|=
name|putcall
argument_list|(
name|p
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPPAREN
case|:
operator|--
operator|*
name|ncommap
expr_stmt|;
name|t
operator|=
name|putch1
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
break|break;
case|case
name|OPCONCAT
case|:
name|t
operator|=
name|mkaltemp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
name|lencat
argument_list|(
name|p
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|q
operator|=
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|putcat
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* put the correct length on the block */
name|frexpr
argument_list|(
name|t
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|t
operator|->
name|vleng
operator|=
name|q
expr_stmt|;
break|break;
case|case
name|OPCONV
case|:
if|if
condition|(
operator|!
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
operator|||
name|p
operator|->
name|exprblock
operator|.
name|vleng
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|!=
literal|1
operator|||
operator|!
name|INT
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|fatal
argument_list|(
literal|"putch1: bad character conversion"
argument_list|)
expr_stmt|;
name|t
operator|=
name|mkaltemp
argument_list|(
name|TYCHAR
argument_list|,
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|mkexpr
argument_list|(
name|OPASSIGN
argument_list|,
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|p
argument_list|)
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badop
argument_list|(
literal|"putch1"
argument_list|,
name|p
operator|->
name|exprblock
operator|.
name|opcode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|t
operator|)
return|;
default|default:
name|badtag
argument_list|(
literal|"putch1"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
block|}
comment|/* NOTREACHED */
block|}
name|LOCAL
name|putchop
parameter_list|(
name|p
parameter_list|)
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|p
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYCHAR
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|putcheq
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putcheq"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|rp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|rp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
name|putcat
argument_list|(
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISONE
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|rp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|lp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|rp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_ASSIGN
argument_list|,
name|PCCT_CHAR
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putx
argument_list|(
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_copy"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|putchcmp
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|ncomma
decl_stmt|;
name|expptr
name|lp
decl_stmt|,
name|rp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putchcmp"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|ISONE
argument_list|(
name|lp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
operator|&&
name|ISONE
argument_list|(
name|rp
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
condition|)
block|{
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|lp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|putaddr
argument_list|(
name|putch1
argument_list|(
name|rp
argument_list|,
operator|&
name|ncomma
argument_list|)
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|ops2
index|[
name|p
operator|->
name|exprblock
operator|.
name|opcode
index|]
argument_list|,
name|PCCT_CHAR
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|=
name|call2
argument_list|(
name|TYINT
argument_list|,
literal|"s_cmp"
argument_list|,
name|lp
argument_list|,
name|rp
argument_list|)
expr_stmt|;
name|p
operator|->
name|exprblock
operator|.
name|rightp
operator|=
name|ICON
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|putop
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
name|LOCAL
name|putcat
parameter_list|(
name|lhs
parameter_list|,
name|rhs
parameter_list|)
specifier|register
name|Addrp
name|lhs
decl_stmt|;
specifier|register
name|expptr
name|rhs
decl_stmt|;
block|{
name|int
name|n
decl_stmt|,
name|ncomma
decl_stmt|;
name|Addrp
name|lp
decl_stmt|,
name|cp
decl_stmt|;
name|ncomma
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|ncat
argument_list|(
name|rhs
argument_list|)
expr_stmt|;
name|lp
operator|=
name|mkaltmpn
argument_list|(
name|n
argument_list|,
name|TYLENG
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|cp
operator|=
name|mkaltmpn
argument_list|(
name|n
argument_list|,
name|TYADDR
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|putct1
argument_list|(
name|rhs
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
operator|&
name|n
argument_list|,
operator|&
name|ncomma
argument_list|)
expr_stmt|;
name|putx
argument_list|(
name|call4
argument_list|(
name|TYSUBR
argument_list|,
literal|"s_cat"
argument_list|,
name|lhs
argument_list|,
name|cp
argument_list|,
name|lp
argument_list|,
name|mkconv
argument_list|(
name|TYLONG
argument_list|,
name|ICON
argument_list|(
name|n
argument_list|)
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|TYINT
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|putct1
parameter_list|(
name|q
parameter_list|,
name|lp
parameter_list|,
name|cp
parameter_list|,
name|ip
parameter_list|,
name|ncommap
parameter_list|)
specifier|register
name|expptr
name|q
decl_stmt|;
specifier|register
name|Addrp
name|lp
decl_stmt|,
name|cp
decl_stmt|;
name|int
modifier|*
name|ip
decl_stmt|,
decl|*
name|ncommap
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
name|Addrp
name|lp1
decl_stmt|,
name|cp1
decl_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|q
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPCONCAT
condition|)
block|{
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|leftp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|putct1
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|rightp
argument_list|,
name|lp
argument_list|,
name|cp
argument_list|,
name|ip
argument_list|,
name|ncommap
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|q
operator|->
name|exprblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|i
operator|=
operator|(
operator|*
name|ip
operator|)
operator|++
expr_stmt|;
name|lp1
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|lp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|lp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZLENG
argument_list|)
argument_list|)
expr_stmt|;
name|cp1
operator|=
operator|(
name|Addrp
operator|)
name|cpexpr
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp1
operator|->
name|memoffset
operator|=
name|mkexpr
argument_list|(
name|OPPLUS
argument_list|,
name|cp1
operator|->
name|memoffset
argument_list|,
name|ICON
argument_list|(
name|i
operator|*
name|SZADDR
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|lp1
argument_list|,
name|cpexpr
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cp1
argument_list|,
name|addrof
argument_list|(
name|putch1
argument_list|(
name|q
argument_list|,
name|ncommap
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|ncommap
operator|+=
literal|2
expr_stmt|;
block|}
block|}
name|LOCAL
name|putaddr
parameter_list|(
name|p
parameter_list|,
name|indir
parameter_list|)
specifier|register
name|Addrp
name|p
decl_stmt|;
name|int
name|indir
decl_stmt|;
block|{
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|funct
decl_stmt|;
name|ftnint
name|offset
decl_stmt|,
name|simoffset
argument_list|()
decl_stmt|;
name|expptr
name|offp
decl_stmt|,
name|shorten
argument_list|()
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TERROR
operator|||
operator|(
name|p
operator|->
name|memoffset
operator|!=
name|NULL
operator|&&
name|ISERROR
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
operator|)
condition|)
block|{
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TADDR
condition|)
name|badtag
argument_list|(
literal|"putaddr"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|vtype
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
name|funct
operator|=
operator|(
name|p
operator|->
name|vclass
operator|==
name|CLPROC
condition|?
name|PCCTM_FTN
operator|<<
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|offp
operator|=
operator|(
name|p
operator|->
name|memoffset
condition|?
operator|(
name|expptr
operator|)
name|cpexpr
argument_list|(
name|p
operator|->
name|memoffset
argument_list|)
else|:
operator|(
name|expptr
operator|)
name|NULL
operator|)
expr_stmt|;
if|#
directive|if
operator|(
name|FUDGEOFFSET
operator|!=
literal|1
operator|)
if|if
condition|(
name|offp
condition|)
name|offp
operator|=
name|mkexpr
argument_list|(
name|OPSTAR
argument_list|,
name|ICON
argument_list|(
name|FUDGEOFFSET
argument_list|)
argument_list|,
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|offset
operator|=
name|simoffset
argument_list|(
operator|&
name|offp
argument_list|)
expr_stmt|;
if|#
directive|if
name|SZINT
operator|<
name|SZLONG
if|if
condition|(
name|offp
condition|)
if|if
condition|(
name|shortsubs
condition|)
name|offp
operator|=
name|shorten
argument_list|(
name|offp
argument_list|)
expr_stmt|;
else|else
name|offp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|offp
argument_list|)
expr_stmt|;
else|#
directive|else
if|if
condition|(
name|offp
condition|)
name|offp
operator|=
name|mkconv
argument_list|(
name|TYINT
argument_list|,
name|offp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|p
operator|->
name|vclass
operator|==
name|CLVAR
operator|&&
operator|(
name|p
operator|->
name|vstg
operator|==
name|STGBSS
operator|||
name|p
operator|->
name|vstg
operator|==
name|STGEQUIV
operator|)
operator|&&
name|SMALLVAR
argument_list|(
name|p
operator|->
name|varsize
argument_list|)
operator|&&
name|offset
operator|>=
operator|-
literal|32768
operator|&&
name|offset
operator|<=
literal|32767
condition|)
block|{
name|anylocals
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|indir
operator|&&
operator|!
name|offp
condition|)
name|p2ldisp
argument_list|(
name|offset
argument_list|,
name|memname
argument_list|(
name|p
operator|->
name|vstg
argument_list|,
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|type2
argument_list|)
expr_stmt|;
else|else
block|{
name|p2reg
argument_list|(
name|LVARREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2triple
argument_list|(
name|PCC_ICON
argument_list|,
literal|1
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2ndisp
argument_list|(
name|memname
argument_list|(
name|p
operator|->
name|vstg
argument_list|,
name|p
operator|->
name|memno
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
operator|(
name|tagptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
switch|switch
condition|(
name|p
operator|->
name|vstg
condition|)
block|{
case|case
name|STGAUTO
case|:
if|if
condition|(
name|indir
operator|&&
operator|!
name|offp
condition|)
block|{
name|p2oreg
argument_list|(
name|offset
argument_list|,
name|AUTOREG
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
name|indir
operator|&&
operator|!
name|offp
operator|&&
operator|!
name|offset
condition|)
block|{
name|p2reg
argument_list|(
name|AUTOREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
break|break;
block|}
name|p2reg
argument_list|(
name|AUTOREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
condition|)
name|p2icon
argument_list|(
name|offset
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
block|}
else|else
name|p2icon
argument_list|(
name|offset
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
if|if
condition|(
name|offp
operator|&&
name|offset
condition|)
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGARG
case|:
name|p2oreg
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|ARGREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
operator||
name|funct
argument_list|)
expr_stmt|;
name|based
label|:
if|if
condition|(
name|offset
condition|)
block|{
name|p2icon
argument_list|(
name|offset
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGLENG
case|:
if|if
condition|(
name|indir
condition|)
block|{
name|p2oreg
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|ARGREG
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2reg
argument_list|(
name|ARGREG
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2icon
argument_list|(
ifdef|#
directive|ifdef
name|ARGOFFSET
name|ARGOFFSET
operator|+
endif|#
directive|endif
call|(
name|ftnint
call|)
argument_list|(
name|FUDGEOFFSET
operator|*
name|p
operator|->
name|memno
argument_list|)
argument_list|,
name|PCCT_INT
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STGBSS
case|:
case|case
name|STGINIT
case|:
case|case
name|STGEXT
case|:
case|case
name|STGINTR
case|:
case|case
name|STGCOMMON
case|:
case|case
name|STGEQUIV
case|:
case|case
name|STGCONST
case|:
if|if
condition|(
name|offp
condition|)
block|{
name|putx
argument_list|(
name|offp
argument_list|)
expr_stmt|;
name|putmem
argument_list|(
name|p
argument_list|,
name|PCC_ICON
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_PLUS
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|p2op
argument_list|(
name|PCC_DEREF
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
else|else
name|putmem
argument_list|(
name|p
argument_list|,
operator|(
name|indir
condition|?
name|PCC_NAME
else|:
name|PCC_ICON
operator|)
argument_list|,
name|offset
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGREG
case|:
if|if
condition|(
name|indir
condition|)
name|p2reg
argument_list|(
name|p
operator|->
name|memno
argument_list|,
name|type2
argument_list|)
expr_stmt|;
else|else
name|fatal
argument_list|(
literal|"attempt to take address of a register"
argument_list|)
expr_stmt|;
break|break;
case|case
name|STGPREG
case|:
if|if
condition|(
name|indir
operator|&&
operator|!
name|offp
condition|)
name|p2oreg
argument_list|(
name|offset
argument_list|,
name|p
operator|->
name|memno
argument_list|,
name|type2
argument_list|)
expr_stmt|;
else|else
block|{
name|p2reg
argument_list|(
name|p
operator|->
name|memno
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
goto|goto
name|based
goto|;
block|}
break|break;
default|default:
name|badstg
argument_list|(
literal|"putaddr"
argument_list|,
name|p
operator|->
name|vstg
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|putmem
parameter_list|(
name|p
parameter_list|,
name|class
parameter_list|,
name|offset
parameter_list|)
name|expptr
name|p
decl_stmt|;
name|int
name|class
decl_stmt|;
name|ftnint
name|offset
decl_stmt|;
block|{
name|int
name|type2
decl_stmt|;
name|int
name|funct
decl_stmt|;
name|char
modifier|*
name|name
decl_stmt|,
modifier|*
name|memname
argument_list|()
decl_stmt|;
name|funct
operator|=
operator|(
name|p
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPROC
condition|?
name|PCCTM_FTN
operator|<<
literal|2
else|:
literal|0
operator|)
expr_stmt|;
name|type2
operator|=
name|types2
index|[
name|p
operator|->
name|headblock
operator|.
name|vtype
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|headblock
operator|.
name|vclass
operator|==
name|CLPROC
condition|)
name|type2
operator||=
operator|(
name|PCCTM_FTN
operator|<<
literal|2
operator|)
expr_stmt|;
name|name
operator|=
name|memname
argument_list|(
name|p
operator|->
name|addrblock
operator|.
name|vstg
argument_list|,
name|p
operator|->
name|addrblock
operator|.
name|memno
argument_list|)
expr_stmt|;
if|if
condition|(
name|class
operator|==
name|PCC_ICON
condition|)
block|{
name|p2triple
argument_list|(
name|PCC_ICON
argument_list|,
name|name
index|[
literal|0
index|]
operator|!=
literal|'\0'
argument_list|,
name|type2
operator||
name|PCCTM_PTR
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
if|if
condition|(
name|name
index|[
literal|0
index|]
condition|)
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p2triple
argument_list|(
name|PCC_NAME
argument_list|,
name|offset
operator|!=
literal|0
argument_list|,
name|type2
argument_list|)
expr_stmt|;
if|if
condition|(
name|offset
operator|!=
literal|0
condition|)
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|name
argument_list|)
expr_stmt|;
block|}
block|}
name|LOCAL
name|Addrp
name|putcall
parameter_list|(
name|p
parameter_list|)
specifier|register
name|Exprp
name|p
decl_stmt|;
block|{
name|chainp
name|arglist
decl_stmt|,
name|charsp
decl_stmt|,
name|cp
decl_stmt|;
name|int
name|n
decl_stmt|,
name|first
decl_stmt|;
name|Addrp
name|t
decl_stmt|;
specifier|register
name|expptr
name|q
decl_stmt|;
name|Addrp
name|fval
decl_stmt|,
name|mkargtemp
argument_list|()
decl_stmt|;
name|int
name|type
decl_stmt|,
name|type2
decl_stmt|,
name|ctype
decl_stmt|,
name|qtype
decl_stmt|,
name|indir
decl_stmt|;
name|type2
operator|=
name|types2
index|[
name|type
operator|=
name|p
operator|->
name|vtype
index|]
expr_stmt|;
name|charsp
operator|=
name|NULL
expr_stmt|;
name|indir
operator|=
operator|(
name|p
operator|->
name|opcode
operator|==
name|OPCCALL
operator|)
expr_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
name|first
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|rightp
condition|)
block|{
name|arglist
operator|=
name|p
operator|->
name|rightp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|p
operator|->
name|rightp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|arglist
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|cp
operator|->
name|datap
expr_stmt|;
if|if
condition|(
name|indir
condition|)
operator|++
name|n
expr_stmt|;
else|else
block|{
name|q
operator|=
call|(
name|expptr
call|)
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISCONST
argument_list|(
name|q
argument_list|)
condition|)
block|{
name|q
operator|=
operator|(
name|expptr
operator|)
name|putconst
argument_list|(
name|q
argument_list|)
expr_stmt|;
name|cp
operator|->
name|datap
operator|=
operator|(
name|tagptr
operator|)
name|q
expr_stmt|;
block|}
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
operator|&&
name|q
operator|->
name|headblock
operator|.
name|vclass
operator|!=
name|CLPROC
condition|)
block|{
name|charsp
operator|=
name|hookup
argument_list|(
name|charsp
argument_list|,
name|mkchain
argument_list|(
name|cpexpr
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
argument_list|,
name|CHNULL
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|n
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
if|if
condition|(
name|ISICON
argument_list|(
name|p
operator|->
name|vleng
argument_list|)
condition|)
block|{
name|fval
operator|=
name|mkargtemp
argument_list|(
name|TYCHAR
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|err
argument_list|(
literal|"adjustable character function"
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|type
argument_list|)
condition|)
block|{
name|fval
operator|=
name|mkargtemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|n
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|fval
operator|=
name|NULL
expr_stmt|;
name|ctype
operator|=
operator|(
name|fval
condition|?
name|PCCT_INT
else|:
name|type2
operator|)
expr_stmt|;
name|putaddr
argument_list|(
name|p
operator|->
name|leftp
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fval
condition|)
block|{
name|first
operator|=
name|NO
expr_stmt|;
name|putaddr
argument_list|(
name|cpexpr
argument_list|(
name|fval
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|type
operator|==
name|TYCHAR
condition|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|p
operator|->
name|vleng
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_CM
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
block|}
for|for
control|(
name|cp
operator|=
name|arglist
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|q
operator|=
call|(
name|expptr
call|)
argument_list|(
name|cp
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|->
name|tag
operator|==
name|TADDR
operator|&&
operator|(
name|indir
operator|||
name|q
operator|->
name|addrblock
operator|.
name|vstg
operator|!=
name|STGREG
operator|)
condition|)
name|putaddr
argument_list|(
name|q
argument_list|,
name|indir
operator|&&
name|q
operator|->
name|addrblock
operator|.
name|vtype
operator|!=
name|TYCHAR
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCOMPLEX
argument_list|(
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
name|putcxop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ISCHAR
argument_list|(
name|q
argument_list|)
condition|)
name|putchop
argument_list|(
name|q
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ISERROR
argument_list|(
name|q
argument_list|)
condition|)
block|{
if|if
condition|(
name|indir
condition|)
name|putx
argument_list|(
name|q
argument_list|)
expr_stmt|;
else|else
block|{
name|t
operator|=
name|mkargtemp
argument_list|(
name|qtype
operator|=
name|q
operator|->
name|headblock
operator|.
name|vtype
argument_list|,
name|q
operator|->
name|headblock
operator|.
name|vleng
argument_list|)
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|t
argument_list|)
argument_list|,
name|q
argument_list|)
expr_stmt|;
name|putaddr
argument_list|(
name|t
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putcomma
argument_list|(
literal|1
argument_list|,
name|qtype
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|first
condition|)
name|first
operator|=
name|NO
expr_stmt|;
else|else
name|p2op
argument_list|(
name|PCC_CM
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|arglist
condition|)
name|frchain
argument_list|(
operator|&
name|arglist
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|charsp
init|;
name|cp
condition|;
name|cp
operator|=
name|cp
operator|->
name|nextp
control|)
block|{
name|putx
argument_list|(
name|mkconv
argument_list|(
name|TYLENG
argument_list|,
name|cp
operator|->
name|datap
argument_list|)
argument_list|)
expr_stmt|;
name|p2op
argument_list|(
name|PCC_CM
argument_list|,
name|type2
argument_list|)
expr_stmt|;
block|}
name|frchain
argument_list|(
operator|&
name|charsp
argument_list|)
expr_stmt|;
if|#
directive|if
name|TARGET
operator|==
name|TAHOE
if|if
condition|(
name|indir
operator|&&
name|ctype
operator|==
name|PCCT_FLOAT
condition|)
comment|/* function opcodes */
name|p2op
argument_list|(
name|PCC_FORTCALL
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|p2op
argument_list|(
name|n
operator|>
literal|0
condition|?
name|PCC_CALL
else|:
name|PCC_UCALL
argument_list|,
name|ctype
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
return|return
operator|(
name|fval
operator|)
return|;
block|}
name|LOCAL
name|putmnmx
parameter_list|(
name|p
parameter_list|)
specifier|register
name|expptr
name|p
decl_stmt|;
block|{
name|int
name|op
decl_stmt|,
name|type
decl_stmt|;
name|int
name|ncomma
decl_stmt|;
name|expptr
name|qp
decl_stmt|;
name|chainp
name|p0
decl_stmt|,
name|p1
decl_stmt|;
name|Addrp
name|sp
decl_stmt|,
name|tp
decl_stmt|;
if|if
condition|(
name|p
operator|->
name|tag
operator|!=
name|TEXPR
condition|)
name|badtag
argument_list|(
literal|"putmnmx"
argument_list|,
name|p
operator|->
name|tag
argument_list|)
expr_stmt|;
name|type
operator|=
name|p
operator|->
name|exprblock
operator|.
name|vtype
expr_stmt|;
name|op
operator|=
operator|(
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPMIN
condition|?
name|OPLT
else|:
name|OPGT
operator|)
expr_stmt|;
name|p0
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
operator|->
name|listblock
operator|.
name|listp
expr_stmt|;
name|free
argument_list|(
call|(
name|charptr
call|)
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|leftp
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
name|sp
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|tp
operator|=
name|mkaltemp
argument_list|(
name|type
argument_list|,
name|PNULL
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPCOLON
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
expr_stmt|;
name|qp
operator|=
name|mkexpr
argument_list|(
name|OPQUEST
argument_list|,
name|mkexpr
argument_list|(
name|op
argument_list|,
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|)
argument_list|,
name|qp
argument_list|)
expr_stmt|;
name|qp
operator|=
name|fixexpr
argument_list|(
name|qp
argument_list|)
expr_stmt|;
name|ncomma
operator|=
literal|1
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|p0
operator|->
name|datap
argument_list|)
expr_stmt|;
for|for
control|(
name|p1
operator|=
name|p0
operator|->
name|nextp
init|;
name|p1
condition|;
name|p1
operator|=
name|p1
operator|->
name|nextp
control|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|tp
argument_list|)
argument_list|,
name|p1
operator|->
name|datap
argument_list|)
expr_stmt|;
if|if
condition|(
name|p1
operator|->
name|nextp
condition|)
block|{
operator|++
name|ncomma
expr_stmt|;
name|putassign
argument_list|(
name|cpexpr
argument_list|(
name|sp
argument_list|)
argument_list|,
name|cpexpr
argument_list|(
name|qp
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|putx
argument_list|(
name|qp
argument_list|)
expr_stmt|;
block|}
name|putcomma
argument_list|(
name|ncomma
argument_list|,
name|type
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|sp
argument_list|)
expr_stmt|;
name|frexpr
argument_list|(
name|tp
argument_list|)
expr_stmt|;
name|frchain
argument_list|(
operator|&
name|p0
argument_list|)
expr_stmt|;
block|}
name|LOCAL
name|putcomma
parameter_list|(
name|n
parameter_list|,
name|type
parameter_list|,
name|indir
parameter_list|)
name|int
name|n
decl_stmt|,
name|type
decl_stmt|,
name|indir
decl_stmt|;
block|{
name|type
operator|=
name|types2
index|[
name|type
index|]
expr_stmt|;
if|if
condition|(
name|indir
condition|)
name|type
operator||=
name|PCCTM_PTR
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
name|p2op
argument_list|(
name|PCC_COMOP
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|ftnint
name|simoffset
parameter_list|(
name|p0
parameter_list|)
name|expptr
modifier|*
name|p0
decl_stmt|;
block|{
name|ftnint
name|offset
decl_stmt|,
name|prod
decl_stmt|;
specifier|register
name|expptr
name|p
decl_stmt|,
name|lp
decl_stmt|,
name|rp
decl_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|p
operator|=
operator|*
name|p0
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|!
name|ISINT
argument_list|(
name|p
operator|->
name|headblock
operator|.
name|vtype
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPSTAR
condition|)
block|{
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|rp
argument_list|)
operator|&&
name|lp
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|ISICON
argument_list|(
name|lp
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPPLUS
expr_stmt|;
name|lp
operator|->
name|exprblock
operator|.
name|opcode
operator|=
name|OPSTAR
expr_stmt|;
name|prod
operator|=
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|*
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|lp
operator|->
name|exprblock
operator|.
name|rightp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|=
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
operator|=
name|prod
expr_stmt|;
block|}
block|}
if|if
condition|(
name|p
operator|->
name|tag
operator|==
name|TEXPR
operator|&&
name|p
operator|->
name|exprblock
operator|.
name|opcode
operator|==
name|OPPLUS
operator|&&
name|ISICON
argument_list|(
name|p
operator|->
name|exprblock
operator|.
name|rightp
argument_list|)
condition|)
block|{
name|rp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|rightp
expr_stmt|;
name|lp
operator|=
name|p
operator|->
name|exprblock
operator|.
name|leftp
expr_stmt|;
name|offset
operator|+=
name|rp
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|rp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|p
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
name|lp
expr_stmt|;
block|}
if|if
condition|(
name|ISCONST
argument_list|(
name|p
argument_list|)
condition|)
block|{
name|offset
operator|+=
name|p
operator|->
name|constblock
operator|.
expr|const
operator|.
name|ci
expr_stmt|;
name|frexpr
argument_list|(
name|p
argument_list|)
expr_stmt|;
operator|*
name|p0
operator|=
name|NULL
expr_stmt|;
block|}
return|return
operator|(
name|offset
operator|)
return|;
block|}
name|p2op
argument_list|(
argument|op
argument_list|,
argument|type
argument_list|)
name|int
name|op
decl_stmt|,
name|type
decl_stmt|;
block|{
name|p2triple
argument_list|(
name|op
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|p2icon
argument_list|(
argument|offset
argument_list|,
argument|type
argument_list|)
name|ftnint
name|offset
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|p2triple
argument_list|(
name|PCC_ICON
argument_list|,
literal|0
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
block|}
name|p2oreg
argument_list|(
argument|offset
argument_list|,
argument|reg
argument_list|,
argument|type
argument_list|)
name|ftnint
name|offset
decl_stmt|;
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
block|{
name|p2triple
argument_list|(
name|PCC_OREG
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
name|p2reg
argument_list|(
argument|reg
argument_list|,
argument|type
argument_list|)
name|int
name|reg
decl_stmt|,
name|type
decl_stmt|;
block|{
name|p2triple
argument_list|(
name|PCC_REG
argument_list|,
name|reg
argument_list|,
name|type
argument_list|)
expr_stmt|;
block|}
name|p2pi
argument_list|(
argument|s
argument_list|,
argument|i
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|;
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
name|p2pij
argument_list|(
argument|s
argument_list|,
argument|i
argument_list|,
argument|j
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|i
argument_list|,
name|j
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
name|p2ps
argument_list|(
argument|s
argument_list|,
argument|t
argument_list|)
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|p2pass
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
name|p2pass
argument_list|(
argument|s
argument_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|p2triple
argument_list|(
name|PCCF_FTEXT
argument_list|,
operator|(
name|strlen
argument_list|(
name|s
argument_list|)
operator|+
name|ALILONG
operator|-
literal|1
operator|)
operator|/
name|ALILONG
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|p2str
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
name|p2str
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
block|{
union|union
block|{
name|long
name|int
name|word
decl_stmt|;
name|char
name|str
index|[
name|SZLONG
index|]
decl_stmt|;
block|}
name|u
union|;
specifier|register
name|int
name|i
decl_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
name|u
operator|.
name|word
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|s
condition|)
block|{
name|u
operator|.
name|str
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|SZLONG
condition|)
block|{
name|p2word
argument_list|(
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
name|u
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|p2word
argument_list|(
name|u
operator|.
name|word
argument_list|)
expr_stmt|;
block|}
name|p2triple
argument_list|(
argument|op
argument_list|,
argument|var
argument_list|,
argument|type
argument_list|)
name|int
name|op
decl_stmt|,
name|var
decl_stmt|,
name|type
decl_stmt|;
block|{
specifier|register
name|long
name|word
decl_stmt|;
name|word
operator|=
name|PCCM_TRIPLE
argument_list|(
name|op
argument_list|,
name|var
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|word
argument_list|)
expr_stmt|;
block|}
name|p2name
argument_list|(
name|s
argument_list|)
specifier|register
name|char
operator|*
name|s
expr_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|UCBPASS2
comment|/* arbitrary length names, terminated by a null, 	   padded to a full word */
define|#
directive|define
name|WL
value|sizeof(long int)
union|union
block|{
name|long
name|int
name|word
decl_stmt|;
name|char
name|str
index|[
name|WL
index|]
decl_stmt|;
block|}
name|w
union|;
name|w
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|w
operator|.
name|str
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
operator|++
condition|)
if|if
condition|(
name|i
operator|==
name|WL
condition|)
block|{
name|p2word
argument_list|(
name|w
operator|.
name|word
argument_list|)
expr_stmt|;
name|w
operator|.
name|word
operator|=
literal|0
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|p2word
argument_list|(
name|w
operator|.
name|word
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* standard intermediate, names are 8 characters long */
union|union
block|{
name|long
name|int
name|word
index|[
literal|2
index|]
decl_stmt|;
name|char
name|str
index|[
literal|8
index|]
decl_stmt|;
block|}
name|u
union|;
name|u
operator|.
name|word
index|[
literal|0
index|]
operator|=
name|u
operator|.
name|word
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|8
operator|&&
operator|*
name|s
condition|;
operator|++
name|i
control|)
name|u
operator|.
name|str
index|[
name|i
index|]
operator|=
operator|*
name|s
operator|++
expr_stmt|;
name|p2word
argument_list|(
name|u
operator|.
name|word
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|u
operator|.
name|word
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
name|p2word
argument_list|(
argument|w
argument_list|)
name|long
name|int
name|w
decl_stmt|;
block|{
operator|*
name|p2bufp
operator|++
operator|=
name|w
expr_stmt|;
if|if
condition|(
name|p2bufp
operator|>=
name|p2bufend
condition|)
name|p2flush
argument_list|()
expr_stmt|;
block|}
name|p2flush
argument_list|()
block|{
if|if
condition|(
name|p2bufp
operator|>
name|p2buff
condition|)
name|write
argument_list|(
name|fileno
argument_list|(
name|textfile
argument_list|)
argument_list|,
name|p2buff
argument_list|,
operator|(
name|p2bufp
operator|-
name|p2buff
operator|)
operator|*
expr|sizeof
operator|(
name|long
name|int
operator|)
argument_list|)
expr_stmt|;
name|p2bufp
operator|=
name|p2buff
expr_stmt|;
block|}
name|LOCAL
name|p2ldisp
parameter_list|(
name|offset
parameter_list|,
name|vname
parameter_list|,
name|type
parameter_list|)
name|ftnint
name|offset
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
name|int
name|type
decl_stmt|;
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s-v.%d"
argument_list|,
name|vname
argument_list|,
name|bsslabel
argument_list|)
expr_stmt|;
name|p2triple
argument_list|(
name|PCC_OREG
argument_list|,
name|LVARREG
argument_list|,
name|type
argument_list|)
expr_stmt|;
name|p2word
argument_list|(
name|offset
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
name|p2ndisp
argument_list|(
argument|vname
argument_list|)
name|char
modifier|*
name|vname
decl_stmt|;
block|{
name|char
name|buff
index|[
literal|100
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buff
argument_list|,
literal|"%s-v.%d"
argument_list|,
name|vname
argument_list|,
name|bsslabel
argument_list|)
expr_stmt|;
name|p2name
argument_list|(
name|buff
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

