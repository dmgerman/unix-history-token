begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
index|[]
init|=
literal|"@(#)equiv.c	5.2 (Berkeley) 1/3/88"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * equiv.c  *  * Routines related to equivalence class processing, f77 compiler, 4.2 BSD.  *  * University of Utah CS Dept modification history:  *   * Revision 3.2  85/01/14  00:14:12  donn  * Fixed bug in eqvcommon that was causing the calculations of multilevel  * equivalences to be screwed up.  *   * Revision 3.1  84/10/13  01:16:08  donn  * Installed Jerry Berkman's version; added UofU comment header.  *   */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SDB
end_ifdef

begin_include
include|#
directive|include
file|<a.out.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|N_SO
end_ifndef

begin_include
include|#
directive|include
file|<stab.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* called at end of declarations section to process chains    created by EQUIVALENCE statements  */
end_comment

begin_macro
name|doequiv
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|inequiv
decl_stmt|,
name|comno
decl_stmt|,
name|ovarno
decl_stmt|;
name|ftnint
name|comoffset
decl_stmt|,
name|offset
decl_stmt|,
name|leng
decl_stmt|;
specifier|register
name|struct
name|Equivblock
modifier|*
name|p
decl_stmt|;
specifier|register
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|;
name|struct
name|Primblock
modifier|*
name|itemp
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|expptr
name|offp
decl_stmt|,
name|suboffset
argument_list|()
decl_stmt|;
name|int
name|ns
decl_stmt|,
name|nsubs
argument_list|()
decl_stmt|;
name|chainp
name|cp
decl_stmt|;
name|char
modifier|*
name|memname
parameter_list|()
function_decl|;
name|int
name|doeqverr
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nequiv
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|eqvclass
index|[
name|i
index|]
expr_stmt|;
name|p
operator|->
name|eqvbottom
operator|=
name|p
operator|->
name|eqvtop
operator|=
literal|0
expr_stmt|;
name|comno
operator|=
operator|-
literal|1
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
block|{
name|offset
operator|=
literal|0
expr_stmt|;
name|itemp
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvlhs
expr_stmt|;
if|if
condition|(
name|itemp
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"error processing equivalence"
argument_list|)
expr_stmt|;
name|equivdcl
operator|=
name|YES
expr_stmt|;
name|vardcl
argument_list|(
name|np
operator|=
name|itemp
operator|->
name|namep
argument_list|)
expr_stmt|;
name|equivdcl
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|itemp
operator|->
name|argsp
operator|||
name|itemp
operator|->
name|fcharp
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|vdim
operator|!=
name|NULL
operator|&&
name|np
operator|->
name|vdim
operator|->
name|ndim
operator|>
literal|1
operator|&&
name|nsubs
argument_list|(
name|itemp
operator|->
name|argsp
argument_list|)
operator|==
literal|1
condition|)
block|{
if|if
condition|(
operator|!
name|ftn66flag
condition|)
name|warn
argument_list|(
literal|"1-dim subscript in EQUIVALENCE"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|NULL
expr_stmt|;
name|ns
operator|=
name|np
operator|->
name|vdim
operator|->
name|ndim
expr_stmt|;
while|while
condition|(
operator|--
name|ns
operator|>
literal|0
condition|)
name|cp
operator|=
name|mkchain
argument_list|(
name|ICON
argument_list|(
literal|1
argument_list|)
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|itemp
operator|->
name|argsp
operator|->
name|listp
operator|->
name|nextp
operator|=
name|cp
expr_stmt|;
block|}
name|offp
operator|=
name|suboffset
argument_list|(
name|itemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISICON
argument_list|(
name|offp
argument_list|)
condition|)
name|offset
operator|=
name|offp
operator|->
name|constblock
operator|.
name|constant
operator|.
name|ci
expr_stmt|;
else|else
block|{
name|dclerr
argument_list|(
literal|"illegal subscript in equivalence "
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
name|doeqverr
operator|=
literal|1
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|offp
argument_list|)
expr_stmt|;
block|}
name|frexpr
argument_list|(
name|itemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|&&
operator|(
name|leng
operator|=
name|iarrlen
argument_list|(
name|np
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|dclerr
argument_list|(
literal|"argument in equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
name|doeqverr
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|np
condition|)
switch|switch
condition|(
name|np
operator|->
name|vstg
condition|)
block|{
case|case
name|STGUNKNOWN
case|:
case|case
name|STGBSS
case|:
case|case
name|STGEQUIV
case|:
break|break;
case|case
name|STGCOMMON
case|:
name|comno
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
name|comoffset
operator|=
name|np
operator|->
name|voffset
operator|+
name|offset
expr_stmt|;
break|break;
default|default:
name|dclerr
argument_list|(
literal|"bad storage class in equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|np
operator|=
name|NULL
expr_stmt|;
name|doeqverr
operator|=
literal|1
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|np
condition|)
block|{
name|q
operator|->
name|eqvoffset
operator|=
name|offset
expr_stmt|;
name|p
operator|->
name|eqvbottom
operator|=
name|lmin
argument_list|(
name|p
operator|->
name|eqvbottom
argument_list|,
operator|-
name|offset
argument_list|)
expr_stmt|;
name|p
operator|->
name|eqvtop
operator|=
name|lmax
argument_list|(
name|p
operator|->
name|eqvtop
argument_list|,
name|leng
operator|-
name|offset
argument_list|)
expr_stmt|;
block|}
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
operator|=
name|np
expr_stmt|;
block|}
if|if
condition|(
name|comno
operator|>=
literal|0
condition|)
name|eqvcommon
argument_list|(
name|p
argument_list|,
name|comno
argument_list|,
name|comoffset
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
block|{
if|if
condition|(
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
condition|)
block|{
name|inequiv
operator|=
name|NO
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|vstg
operator|==
name|STGEQUIV
condition|)
if|if
condition|(
operator|(
name|ovarno
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|)
operator|==
name|i
condition|)
block|{
if|if
condition|(
name|np
operator|->
name|voffset
operator|+
name|q
operator|->
name|eqvoffset
operator|!=
literal|0
condition|)
name|dclerr
argument_list|(
literal|"inconsistent equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|doeqverr
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|offset
operator|=
name|np
operator|->
name|voffset
expr_stmt|;
name|inequiv
operator|=
name|YES
expr_stmt|;
block|}
name|np
operator|->
name|vstg
operator|=
name|STGEQUIV
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|i
expr_stmt|;
name|np
operator|->
name|voffset
operator|=
operator|-
name|q
operator|->
name|eqvoffset
expr_stmt|;
if|if
condition|(
name|inequiv
condition|)
name|eqveqv
argument_list|(
name|i
argument_list|,
name|ovarno
argument_list|,
name|q
operator|->
name|eqvoffset
operator|+
name|offset
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
operator|!
name|doeqverr
condition|)
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nequiv
condition|;
operator|++
name|i
control|)
block|{
name|p
operator|=
operator|&
name|eqvclass
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|eqvbottom
operator|!=
literal|0
operator|||
name|p
operator|->
name|eqvtop
operator|!=
literal|0
condition|)
comment|/* a live chain */
block|{
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
block|{
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
expr_stmt|;
name|np
operator|->
name|voffset
operator|-=
name|p
operator|->
name|eqvbottom
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|voffset
operator|%
name|typealign
index|[
name|np
operator|->
name|vtype
index|]
operator|!=
literal|0
condition|)
name|dclerr
argument_list|(
literal|"bad alignment forced by equivalence"
argument_list|,
name|np
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|eqvtop
operator|-=
name|p
operator|->
name|eqvbottom
expr_stmt|;
name|p
operator|->
name|eqvbottom
operator|=
literal|0
expr_stmt|;
block|}
name|freqchain
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* put equivalence chain p at common block comno + comoffset */
end_comment

begin_function
name|LOCAL
name|eqvcommon
parameter_list|(
name|p
parameter_list|,
name|comno
parameter_list|,
name|comoffset
parameter_list|)
name|struct
name|Equivblock
modifier|*
name|p
decl_stmt|;
name|int
name|comno
decl_stmt|;
name|ftnint
name|comoffset
decl_stmt|;
block|{
name|int
name|ovarno
decl_stmt|;
name|ftnint
name|k
decl_stmt|,
name|offq
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
specifier|register
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|comoffset
operator|+
name|p
operator|->
name|eqvbottom
operator|<
literal|0
condition|)
block|{
name|errstr
argument_list|(
literal|"attempt to extend common %s backward"
argument_list|,
name|nounder
argument_list|(
name|XL
argument_list|,
name|extsymtab
index|[
name|comno
index|]
operator|.
name|extname
argument_list|)
argument_list|)
expr_stmt|;
name|freqchain
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|(
name|k
operator|=
name|comoffset
operator|+
name|p
operator|->
name|eqvtop
operator|)
operator|>
name|extsymtab
index|[
name|comno
index|]
operator|.
name|extleng
condition|)
name|extsymtab
index|[
name|comno
index|]
operator|.
name|extleng
operator|=
name|k
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
name|prstab
argument_list|(
name|varstr
argument_list|(
name|XL
argument_list|,
name|extsymtab
index|[
name|comno
index|]
operator|.
name|extname
argument_list|)
argument_list|,
name|N_BCOMM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|eqvnextp
control|)
if|if
condition|(
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
condition|)
block|{
switch|switch
condition|(
name|np
operator|->
name|vstg
condition|)
block|{
case|case
name|STGUNKNOWN
case|:
case|case
name|STGBSS
case|:
name|np
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|comno
expr_stmt|;
name|np
operator|->
name|voffset
operator|=
name|comoffset
operator|-
name|q
operator|->
name|eqvoffset
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
name|namestab
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|STGEQUIV
case|:
name|ovarno
operator|=
name|np
operator|->
name|vardesc
operator|.
name|varno
expr_stmt|;
name|offq
operator|=
name|comoffset
operator|-
name|q
operator|->
name|eqvoffset
operator|-
name|np
operator|->
name|voffset
expr_stmt|;
name|np
operator|->
name|vstg
operator|=
name|STGCOMMON
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|comno
expr_stmt|;
name|np
operator|->
name|voffset
operator|=
name|comoffset
operator|+
name|q
operator|->
name|eqvoffset
expr_stmt|;
if|if
condition|(
name|ovarno
operator|!=
operator|(
name|p
operator|-
name|eqvclass
operator|)
condition|)
name|eqvcommon
argument_list|(
operator|&
name|eqvclass
index|[
name|ovarno
index|]
argument_list|,
name|comno
argument_list|,
name|offq
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
block|{
name|namestab
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
break|break;
case|case
name|STGCOMMON
case|:
if|if
condition|(
name|comno
operator|!=
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|||
name|comoffset
operator|!=
name|np
operator|->
name|voffset
operator|+
name|q
operator|->
name|eqvoffset
condition|)
name|dclerr
argument_list|(
literal|"inconsistent common usage"
argument_list|,
name|np
argument_list|)
expr_stmt|;
break|break;
default|default:
name|badstg
argument_list|(
literal|"eqvcommon"
argument_list|,
name|np
operator|->
name|vstg
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|SDB
if|if
condition|(
name|sdbflag
condition|)
name|prstab
argument_list|(
name|varstr
argument_list|(
name|XL
argument_list|,
name|extsymtab
index|[
name|comno
index|]
operator|.
name|extname
argument_list|)
argument_list|,
name|N_ECOMM
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|freqchain
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|p
operator|->
name|eqvbottom
operator|=
name|p
operator|->
name|eqvtop
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put all items on ovarno chain on front of nvarno chain  * adjust offsets of ovarno elements and top and bottom of nvarno chain  */
end_comment

begin_function
name|LOCAL
name|eqveqv
parameter_list|(
name|nvarno
parameter_list|,
name|ovarno
parameter_list|,
name|delta
parameter_list|)
name|int
name|ovarno
decl_stmt|,
name|nvarno
decl_stmt|;
name|ftnint
name|delta
decl_stmt|;
block|{
specifier|register
name|struct
name|Equivblock
modifier|*
name|p0
decl_stmt|,
modifier|*
name|p
decl_stmt|;
specifier|register
name|Namep
name|np
decl_stmt|;
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|,
modifier|*
name|q1
decl_stmt|;
name|p0
operator|=
name|eqvclass
operator|+
name|nvarno
expr_stmt|;
name|p
operator|=
name|eqvclass
operator|+
name|ovarno
expr_stmt|;
name|p0
operator|->
name|eqvbottom
operator|=
name|lmin
argument_list|(
name|p0
operator|->
name|eqvbottom
argument_list|,
name|p
operator|->
name|eqvbottom
operator|-
name|delta
argument_list|)
expr_stmt|;
name|p0
operator|->
name|eqvtop
operator|=
name|lmax
argument_list|(
name|p0
operator|->
name|eqvtop
argument_list|,
name|p
operator|->
name|eqvtop
operator|-
name|delta
argument_list|)
expr_stmt|;
name|p
operator|->
name|eqvbottom
operator|=
name|p
operator|->
name|eqvtop
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|q1
control|)
block|{
name|q1
operator|=
name|q
operator|->
name|eqvnextp
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|=
name|q
operator|->
name|eqvitem
operator|.
name|eqvname
operator|)
operator|&&
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|==
name|ovarno
condition|)
block|{
name|q
operator|->
name|eqvnextp
operator|=
name|p0
operator|->
name|equivs
expr_stmt|;
name|p0
operator|->
name|equivs
operator|=
name|q
expr_stmt|;
name|q
operator|->
name|eqvoffset
operator|-=
name|delta
expr_stmt|;
name|np
operator|->
name|vardesc
operator|.
name|varno
operator|=
name|nvarno
expr_stmt|;
name|np
operator|->
name|voffset
operator|-=
name|delta
expr_stmt|;
block|}
else|else
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|equivs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|freqchain
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Equivblock
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|struct
name|Eqvchain
modifier|*
name|q
decl_stmt|,
modifier|*
name|oq
decl_stmt|;
for|for
control|(
name|q
operator|=
name|p
operator|->
name|equivs
init|;
name|q
condition|;
name|q
operator|=
name|oq
control|)
block|{
name|oq
operator|=
name|q
operator|->
name|eqvnextp
expr_stmt|;
name|free
argument_list|(
operator|(
name|charptr
operator|)
name|q
argument_list|)
expr_stmt|;
block|}
name|p
operator|->
name|equivs
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|LOCAL
name|nsubs
parameter_list|(
name|p
parameter_list|)
specifier|register
name|struct
name|Listblock
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|int
name|n
decl_stmt|;
specifier|register
name|chainp
name|q
decl_stmt|;
name|n
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
condition|)
for|for
control|(
name|q
operator|=
name|p
operator|->
name|listp
init|;
name|q
condition|;
name|q
operator|=
name|q
operator|->
name|nextp
control|)
operator|++
name|n
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

