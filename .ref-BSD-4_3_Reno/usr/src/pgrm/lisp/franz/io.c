begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: io.c,v 1.12 87/12/14 18:36:58 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Tue Nov 22 10:01:14 1983 by jkf]-  * 	io.c				$Locker:  $  * input output functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"chkrtab.h"
end_include

begin_struct
struct|struct
name|readtable
block|{
name|unsigned
name|char
name|ctable
index|[
literal|132
index|]
decl_stmt|;
block|}
name|initread
init|=
block|{
comment|/*	^@ nul	^A soh	^B stx	^C etx	^D eot	^E eng	^F ack	^G bel  */
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	^H bs	^I ht	^J nl	^K vt	^L np	^M cr	^N so	^O si	*/
name|VCHAR
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VSEP
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	^P dle	^Q dc1	^R dc2	^S dc3	^T dc4	^U nak	^V syn	^W etb	*/
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	^X can	^Y em	^Z sub	^[ esc	^\ fs	^] gs	^^ rs	^_ us	*/
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VSEP
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
name|VERR
block|,
comment|/*	sp	!	"	#	$	%&	'	*/
name|VSEP
block|,
name|VCHAR
block|,
name|VSD
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VSQ
block|,
comment|/*	(	)	*	+	,	-	.	/	*/
name|VLPARA
block|,
name|VRPARA
block|,
name|VCHAR
block|,
name|VSIGN
block|,
name|VCHAR
block|,
name|VSIGN
block|,
name|VPERD
block|,
name|VCHAR
block|,
comment|/*	0	1	2	3	4	5	6	7	*/
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
name|VNUM
block|,
comment|/*	8	9	:	;<	=>	?	*/
name|VNUM
block|,
name|VNUM
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	@	A	B	C	D	E	F	G	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	H	I	J	K	L	M	N	O	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	P	Q	R	S	T	U	V	W	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	X	Y	Z	[	\	]	^	_	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VLBRCK
block|,
name|VESC
block|,
name|VRBRCK
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	`	a	b	c	d	e	f	g	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	h	i	j	k	l	m	n	o	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	p	q	r	s	t	u	v	w	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
comment|/*	x	y	z	{	|	}	~	del	*/
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VDQ
block|,
name|VCHAR
block|,
name|VCHAR
block|,
name|VERR
block|,
comment|/*	unused	Xsdc	Xesc	Xdqc					*/
literal|0
block|,
literal|'"'
block|,
literal|'\\'
block|,
literal|'|'
block|}
struct|;
end_struct

begin_decl_stmt
specifier|extern
name|unsigned
name|char
modifier|*
name|ctable
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|lispval
name|atomval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external varaible containing atom returned 			   from internal atom reading routine */
end_comment

begin_function_decl
name|lispval
name|readrx
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|lispval
name|readr
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|lispval
name|readry
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|atomtoolong
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|int
name|keywait
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|plevel
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contains maximum list recursion count	*/
end_comment

begin_decl_stmt
name|int
name|plength
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum number of list elements printed	*/
end_comment

begin_decl_stmt
specifier|static
name|int
name|dbqflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|mantisfl
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|uctolc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|lispval
name|lastrtab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* external variable designating current reader 			   table */
end_comment

begin_decl_stmt
specifier|static
name|char
name|baddot1
index|[]
init|=
literal|"Bad reader construction: (.<something>)\nShould be (nil .<something>)\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|baddot2
index|[]
init|=
literal|"Bad reader construction: (<something> .<something> not followed by )"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* readr ****************************************************************/
end_comment

begin_comment
comment|/* returns a s-expression read in from the port specified as the first	*/
end_comment

begin_comment
comment|/* argument.  Handles superbrackets, reader macros.			*/
end_comment

begin_function
name|lispval
name|readr
parameter_list|(
name|useport
parameter_list|)
name|FILE
modifier|*
name|useport
decl_stmt|;
block|{
specifier|register
name|lispval
name|handy
init|=
name|Vreadtable
operator|->
name|a
operator|.
name|clb
decl_stmt|;
name|chkrtab
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|rbktf
operator|=
name|FALSE
expr_stmt|;
name|rdrport
operator|=
operator|(
name|FILE
operator|*
operator|)
name|useport
expr_stmt|;
if|if
condition|(
name|useport
operator|==
name|stdin
condition|)
name|keywait
operator|=
name|TRUE
expr_stmt|;
name|handy
operator|=
name|readrx
argument_list|(
name|Iratom
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|useport
operator|==
name|stdin
condition|)
name|keywait
operator|=
name|FALSE
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
end_function

begin_comment
comment|/* readrx **************************************************************/
end_comment

begin_comment
comment|/* returns a s-expression beginning with the syntax code of an atom	*/
end_comment

begin_comment
comment|/* passed in the first	*/
end_comment

begin_comment
comment|/* argument.  Does the actual work for readr, including list, dotted	*/
end_comment

begin_comment
comment|/* pair, and quoted atom detection					*/
end_comment

begin_function
name|lispval
name|readrx
parameter_list|(
name|code
parameter_list|)
specifier|register
name|int
name|code
decl_stmt|;
block|{
specifier|register
name|lispval
name|work
decl_stmt|;
specifier|register
name|lispval
modifier|*
name|current
decl_stmt|;
specifier|register
name|struct
name|argent
modifier|*
name|result
decl_stmt|;
name|int
name|inlbkt
init|=
name|FALSE
decl_stmt|;
name|lispval
name|errorh
parameter_list|()
function_decl|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
comment|/* ???not necessary because np explicitly restored if 	  changed */
name|top
label|:
switch|switch
condition|(
name|code
condition|)
block|{
case|case
name|TLBKT
case|:
name|inlbkt
operator|=
name|TRUE
expr_stmt|;
case|case
name|TLPARA
case|:
name|result
operator|=
name|np
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|nil
expr_stmt|;
comment|/*protect(nil);*/
for|for
control|(
name|EVER
control|)
block|{
switch|switch
condition|(
name|code
operator|=
name|Iratom
argument_list|()
condition|)
block|{
case|case
name|TRPARA
case|:
if|if
condition|(
name|rbktf
operator|&&
name|inlbkt
condition|)
name|rbktf
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
default|default:
name|atomval
operator|=
name|readrx
argument_list|(
name|code
argument_list|)
expr_stmt|;
case|case
name|TSCA
case|:
name|np
operator|++
operator|->
name|val
operator|=
name|atomval
expr_stmt|;
operator|*
name|current
operator|=
name|work
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|d
operator|.
name|car
operator|=
name|atomval
expr_stmt|;
name|np
operator|--
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|&
operator|(
name|work
operator|->
name|d
operator|.
name|cdr
operator|)
expr_stmt|;
break|break;
case|case
name|TINF
case|:
name|imacrox
argument_list|(
name|result
operator|->
name|val
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|work
operator|=
name|atomval
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|work
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|&
operator|(
name|result
operator|->
name|val
operator|)
expr_stmt|;
goto|goto
name|mcom
goto|;
case|case
name|TSPL
case|:
name|macrox
argument_list|()
expr_stmt|;
comment|/* input and output in atomval */
operator|*
name|current
operator|=
name|atomval
expr_stmt|;
name|mcom
label|:
while|while
condition|(
operator|*
name|current
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
operator|*
name|current
argument_list|)
operator|!=
name|DTPR
condition|)
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Non-list returned from splicing macro"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|7
argument_list|,
operator|*
name|current
argument_list|)
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|&
operator|(
operator|(
operator|*
name|current
operator|)
operator|->
name|d
operator|.
name|cdr
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|TPERD
case|:
if|if
condition|(
name|result
operator|->
name|val
operator|==
name|nil
condition|)
block|{
name|work
operator|=
name|result
operator|->
name|val
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|current
operator|=
operator|(
name|lispval
operator|*
operator|)
operator|&
operator|(
name|work
operator|->
name|d
operator|.
name|cdr
operator|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|baddot1
argument_list|)
expr_stmt|;
block|}
name|work
operator|=
name|readrx
argument_list|(
name|TLPARA
argument_list|)
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|d
operator|.
name|cdr
operator|!=
name|nil
condition|)
block|{
operator|*
name|current
operator|=
name|work
expr_stmt|;
name|work
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|d
operator|.
name|cdr
operator|=
operator|*
name|current
expr_stmt|;
operator|*
name|current
operator|=
name|nil
expr_stmt|;
name|work
operator|->
name|d
operator|.
name|car
operator|=
name|result
operator|->
name|val
expr_stmt|;
name|result
operator|->
name|val
operator|=
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
name|baddot2
argument_list|,
name|nil
argument_list|,
name|TRUE
argument_list|,
literal|58
argument_list|,
name|work
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
operator|*
name|current
operator|=
name|work
operator|->
name|d
operator|.
name|car
expr_stmt|;
comment|/* there is the possibility that the expression 				   following the dot is terminated with a "]" 				   and thus needs no closing lparens to follow 				*/
if|if
condition|(
name|rbktf
operator|&&
name|inlbkt
condition|)
name|rbktf
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TEOF
case|:
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Premature end of file after "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|result
operator|->
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|rbktf
condition|)
block|{
if|if
condition|(
name|inlbkt
condition|)
name|rbktf
operator|=
name|FALSE
expr_stmt|;
goto|goto
name|out
goto|;
block|}
block|}
case|case
name|TSCA
case|:
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|atomval
operator|)
return|;
case|case
name|TEOF
case|:
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|eofa
operator|)
return|;
case|case
name|TMAC
case|:
name|macrox
argument_list|()
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|atomval
operator|)
return|;
case|case
name|TINF
case|:
name|imacrox
argument_list|(
name|nil
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|work
operator|=
name|atomval
expr_stmt|;
if|if
condition|(
name|work
operator|==
name|nil
condition|)
block|{
name|code
operator|=
name|Iratom
argument_list|()
expr_stmt|;
goto|goto
name|top
goto|;
block|}
name|work
operator|=
name|work
operator|->
name|d
operator|.
name|car
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
if|if
condition|(
name|work
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|)
return|return
operator|(
name|work
operator|->
name|d
operator|.
name|car
operator|)
return|;
else|else
return|return
operator|(
name|work
operator|)
return|;
case|case
name|TSPL
case|:
name|macrox
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|work
operator|=
name|atomval
operator|)
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|TYPE
argument_list|(
name|work
argument_list|)
operator|==
name|DTPR
operator|&&
name|work
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|)
block|{
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|->
name|d
operator|.
name|car
operator|)
return|;
block|}
else|else
block|{
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Improper value returned from splicing macro at top-level"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|9
argument_list|,
name|work
argument_list|)
expr_stmt|;
block|}
block|}
name|code
operator|=
name|Iratom
argument_list|()
expr_stmt|;
goto|goto
name|top
goto|;
comment|/* return(readrx(Iratom())); */
case|case
name|TSQ
case|:
name|result
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
operator|(
name|work
operator|=
name|result
operator|->
name|val
operator|)
operator|->
name|d
operator|.
name|car
operator|=
name|quota
expr_stmt|;
name|work
operator|=
name|work
operator|->
name|d
operator|.
name|cdr
operator|=
name|newdot
argument_list|()
expr_stmt|;
name|work
operator|->
name|d
operator|.
name|car
operator|=
name|readrx
argument_list|(
name|Iratom
argument_list|()
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
case|case
name|TRPARA
case|:
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"read: read a right paren when expecting an s-expression"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
case|case
name|TPERD
case|:
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|errorh
argument_list|(
name|Vermisc
argument_list|,
literal|"read: read a period when expecting an s-expression"
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|)
operator|)
return|;
comment|/* should never get here, we should have covered all cases above */
default|default:
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"Readlist error,  code "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|inewint
argument_list|(
operator|(
name|long
operator|)
name|code
argument_list|)
argument_list|)
operator|)
return|;
block|}
name|out
label|:
name|work
operator|=
name|result
operator|->
name|val
expr_stmt|;
name|np
operator|=
name|result
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_macro
name|macrox
argument_list|()
end_macro

begin_block
block|{
name|FILE
modifier|*
name|svport
decl_stmt|;
name|lispval
name|handy
decl_stmt|,
name|Lapply
argument_list|()
decl_stmt|;
name|Savestack
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|svport
operator|=
name|rdrport
expr_stmt|;
comment|/* save from possible changing */
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|handy
operator|=
name|Iget
argument_list|(
name|atomval
argument_list|,
name|lastrtab
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|handy
operator|==
name|nil
condition|)
block|{
name|errorh1
argument_list|(
name|Vermisc
argument_list|,
literal|"read: can't find the character macro for "
argument_list|,
name|nil
argument_list|,
name|FALSE
argument_list|,
literal|0
argument_list|,
name|atomval
argument_list|)
expr_stmt|;
block|}
name|protect
argument_list|(
name|nil
argument_list|)
expr_stmt|;
name|atomval
operator|=
name|Lapply
argument_list|()
expr_stmt|;
name|chkrtab
argument_list|(
name|Vreadtable
operator|->
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
comment|/* the macro could have changed 					   the readtable 					 */
name|rdrport
operator|=
name|svport
expr_stmt|;
comment|/* restore old value */
name|Restorestack
argument_list|()
expr_stmt|;
return|return;
block|}
end_block

begin_expr_stmt
name|imacrox
argument_list|(
name|current
argument_list|,
name|inlist
argument_list|)
specifier|register
name|lispval
name|current
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|FILE
modifier|*
name|svport
decl_stmt|;
specifier|register
name|lispval
name|work
decl_stmt|;
name|lispval
name|Lapply
argument_list|()
decl_stmt|,
name|handy
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|svport
operator|=
name|rdrport
expr_stmt|;
comment|/* save from possible changing */
if|if
condition|(
name|inlist
condition|)
block|{
name|protect
argument_list|(
name|handy
operator|=
name|newdot
argument_list|()
argument_list|)
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|car
operator|=
name|current
expr_stmt|;
for|for
control|(
name|work
operator|=
name|handy
operator|->
name|d
operator|.
name|car
init|;
operator|(
name|TYPE
argument_list|(
name|work
operator|->
name|d
operator|.
name|cdr
argument_list|)
operator|)
operator|==
name|DTPR
condition|;
control|)
name|work
operator|=
name|work
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
name|handy
operator|->
name|d
operator|.
name|cdr
operator|=
name|work
expr_stmt|;
block|}
else|else
name|handy
operator|=
name|current
expr_stmt|;
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|Iget
argument_list|(
name|atomval
argument_list|,
name|lastrtab
argument_list|)
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|atomval
operator|=
name|Lfuncal
argument_list|()
expr_stmt|;
name|chkrtab
argument_list|(
name|Vreadtable
operator|->
name|a
operator|.
name|clb
argument_list|)
expr_stmt|;
comment|/* the macro could have changed 					   the readtable 					 */
name|rdrport
operator|=
name|svport
expr_stmt|;
comment|/* restore old value */
name|Restorestack
argument_list|()
expr_stmt|;
return|return;
block|}
end_block

begin_comment
comment|/* ratomr ***************************************************************/
end_comment

begin_comment
comment|/* this routine returns a pointer to an atom read in from the port given*/
end_comment

begin_comment
comment|/* by the first argument						*/
end_comment

begin_function
name|lispval
name|ratomr
parameter_list|(
name|useport
parameter_list|)
specifier|register
name|FILE
modifier|*
name|useport
decl_stmt|;
block|{
name|rdrport
operator|=
name|useport
expr_stmt|;
switch|switch
condition|(
name|Iratom
argument_list|()
condition|)
block|{
case|case
name|TEOF
case|:
return|return
operator|(
name|eofa
operator|)
return|;
case|case
name|TSQ
case|:
case|case
name|TRPARA
case|:
case|case
name|TLPARA
case|:
case|case
name|TLBKT
case|:
case|case
name|TPERD
case|:
name|strbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|(
name|TRUE
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|atomval
operator|)
return|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|push
parameter_list|()
value|; *name++ = c; if(name>=endstrb) name = atomtoolong(name);
end_define

begin_define
define|#
directive|define
name|next
parameter_list|()
value|(((cc=getc(useport))!=EOF)?(stats = ctable[c = cc&0177]):\ 					((c=0),(saweof = 1),(stats = SEPMASK)))
end_define

begin_macro
name|Iratom
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
specifier|register
name|char
name|c
decl_stmt|,
name|marker
decl_stmt|,
modifier|*
name|name
decl_stmt|;
specifier|extern
name|lispval
name|finatom
argument_list|()
decl_stmt|,
name|calcnum
argument_list|()
decl_stmt|,
name|getnum
argument_list|()
decl_stmt|;
name|int
name|code
decl_stmt|,
name|cc
decl_stmt|;
name|int
name|strflag
init|=
name|FALSE
decl_stmt|;
name|name
operator|=
name|strbuf
expr_stmt|;
name|again
label|:
name|cc
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
expr_stmt|;
if|if
condition|(
name|cc
operator|==
name|EOF
condition|)
block|{
name|clearerr
argument_list|(
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|TEOF
operator|)
return|;
block|}
name|c
operator|=
name|cc
operator|&
literal|0177
expr_stmt|;
operator|*
name|name
operator|=
name|c
expr_stmt|;
switch|switch
condition|(
name|synclass
argument_list|(
name|ctable
index|[
name|c
index|]
argument_list|)
condition|)
block|{
default|default:
goto|goto
name|again
goto|;
case|case
name|synclass
argument_list|(
name|VNUM
argument_list|)
case|:
case|case
name|synclass
argument_list|(
name|VSIGN
argument_list|)
case|:
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
name|atomval
operator|=
operator|(
name|getnum
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VESC
argument_list|)
case|:
name|dbqflag
operator|=
name|TRUE
expr_stmt|;
operator|*
name|name
operator|++
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
name|atomval
operator|=
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VCHAR
argument_list|)
case|:
if|if
condition|(
name|uctolc
operator|&&
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
name|atomval
operator|=
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VLPARA
argument_list|)
case|:
return|return
operator|(
name|TLPARA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VRPARA
argument_list|)
case|:
return|return
operator|(
name|TRPARA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VPERD
argument_list|)
case|:
name|marker
operator|=
name|peekc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
if|if
condition|(
name|synclass
argument_list|(
name|VNUM
argument_list|)
operator|!=
name|synclass
argument_list|(
name|ctable
index|[
name|marker
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|SEPMASK
operator|&
name|ctable
index|[
name|marker
index|]
condition|)
return|return
operator|(
name|TPERD
operator|)
return|;
else|else
block|{
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
comment|/* this period begins an atm */
name|atomval
operator|=
name|finatom
argument_list|(
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
block|}
block|}
operator|*
name|name
operator|++
operator|=
literal|'.'
expr_stmt|;
name|mantisfl
operator|=
literal|1
expr_stmt|;
name|atomval
operator|=
operator|(
name|getnum
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VLBRCK
argument_list|)
case|:
return|return
operator|(
name|TLBKT
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VRBRCK
argument_list|)
case|:
name|rbktf
operator|=
name|TRUE
expr_stmt|;
return|return
operator|(
name|TRPARA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VSQ
argument_list|)
case|:
return|return
operator|(
name|TSQ
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VSD
argument_list|)
case|:
name|strflag
operator|=
name|TRUE
expr_stmt|;
case|case
name|synclass
argument_list|(
name|VDQ
argument_list|)
case|:
name|name
operator|=
name|strbuf
expr_stmt|;
name|marker
operator|=
name|c
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|)
operator|!=
name|marker
condition|)
block|{
if|if
condition|(
name|synclass
argument_list|(
name|VESC
argument_list|)
operator|==
name|synclass
argument_list|(
name|ctable
index|[
name|c
index|]
argument_list|)
condition|)
name|c
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
name|push
argument_list|()
expr_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|useport
argument_list|)
condition|)
block|{
name|clearerr
argument_list|(
name|useport
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"EOF encountered while reading atom"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|name
operator|=
name|NULL_CHAR
expr_stmt|;
if|if
condition|(
name|strflag
condition|)
name|atomval
operator|=
operator|(
name|lispval
operator|)
name|newstr
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
else|else
name|atomval
operator|=
operator|(
name|getatom
argument_list|(
name|TRUE
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
case|case
name|synclass
argument_list|(
name|VERR
argument_list|)
case|:
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[read: null read and ignored]\n"
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
comment|/* null pname */
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%c (%o): "
argument_list|,
name|c
argument_list|,
operator|(
name|int
operator|)
name|c
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"ILLEGAL CHARACTER IN ATOM"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
case|case
name|synclass
argument_list|(
name|VSINF
argument_list|)
case|:
name|code
operator|=
name|TINF
expr_stmt|;
goto|goto
name|same
goto|;
case|case
name|synclass
argument_list|(
name|VSSPL
argument_list|)
case|:
name|code
operator|=
name|TSPL
expr_stmt|;
goto|goto
name|same
goto|;
case|case
name|synclass
argument_list|(
name|VSMAC
argument_list|)
case|:
name|code
operator|=
name|TMAC
expr_stmt|;
name|same
label|:
name|marker
operator|=
name|peekc
argument_list|(
name|rdrport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|SEPMASK
operator|&
name|ctable
index|[
name|marker
index|]
operator|)
condition|)
block|{
operator|*
name|name
operator|++
operator|=
name|c
expr_stmt|;
comment|/* this is not a macro */
name|atomval
operator|=
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|TSCA
operator|)
return|;
block|}
goto|goto
name|simple
goto|;
case|case
name|synclass
argument_list|(
name|VINF
argument_list|)
case|:
name|code
operator|=
name|TINF
expr_stmt|;
goto|goto
name|simple
goto|;
case|case
name|synclass
argument_list|(
name|VSCA
argument_list|)
case|:
name|code
operator|=
name|TSCA
expr_stmt|;
goto|goto
name|simple
goto|;
case|case
name|synclass
argument_list|(
name|VSPL
argument_list|)
case|:
name|code
operator|=
name|TSPL
expr_stmt|;
goto|goto
name|simple
goto|;
case|case
name|synclass
argument_list|(
name|VMAC
argument_list|)
case|:
name|code
operator|=
name|TMAC
expr_stmt|;
name|simple
label|:
name|strbuf
index|[
literal|0
index|]
operator|=
name|c
expr_stmt|;
name|strbuf
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|atomval
operator|=
operator|(
name|getatom
argument_list|(
name|TRUE
argument_list|)
operator|)
expr_stmt|;
return|return
operator|(
name|code
operator|)
return|;
block|}
block|}
end_block

begin_function
name|lispval
name|getnum
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
name|unsigned
name|char
name|c
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
name|unsigned
name|char
name|stats
decl_stmt|;
name|int
name|sawdigit
init|=
literal|0
decl_stmt|,
name|saweof
init|=
literal|0
decl_stmt|,
name|cc
decl_stmt|;
name|char
modifier|*
name|exploc
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
name|double
name|realno
decl_stmt|;
specifier|extern
name|lispval
name|finatom
argument_list|()
decl_stmt|,
name|calcnum
argument_list|()
decl_stmt|,
name|newdoub
argument_list|()
decl_stmt|,
name|dopow
argument_list|()
decl_stmt|;
if|if
condition|(
name|mantisfl
condition|)
block|{
name|mantisfl
operator|=
literal|0
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
goto|goto
name|mantissa
goto|;
block|}
if|if
condition|(
name|VNUM
operator|==
name|ctable
index|[
operator|*
operator|(
name|unsigned
name|char
operator|*
operator|)
operator|(
name|name
operator|-
literal|1
operator|)
index|]
condition|)
name|sawdigit
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|VNUM
operator|==
name|next
argument_list|()
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
comment|/* recognize [0-9]*, in "ex" parlance */
name|sawdigit
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
comment|/* continue */
block|}
elseif|else
if|if
condition|(
name|stats
operator|&
name|SEPMASK
condition|)
block|{
if|if
condition|(
operator|!
name|saweof
condition|)
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
operator|(
name|int
operator|)
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
if|if
condition|(
name|sawdigit
condition|)
comment|/* _ must be preceeded by a digit */
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
else|else
goto|goto
name|backout
goto|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'d'
operator|||
name|c
operator|==
literal|'D'
condition|)
block|{
if|if
condition|(
name|sawdigit
condition|)
goto|goto
name|expt
goto|;
else|else
goto|goto
name|backout
goto|;
block|}
else|else
block|{
name|backout
label|:
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
comment|/* at this point we have [0-9]*\. , which might 				   be a decimal int or the leading part of a 				   float				*/
if|if
condition|(
name|next
argument_list|()
operator|!=
name|VNUM
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'e'
operator|||
name|c
operator|==
literal|'E'
operator|||
name|c
operator|==
literal|'d'
operator|||
name|c
operator|==
literal|'D'
condition|)
goto|goto
name|expt
goto|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'^'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
operator|(
name|int
operator|)
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
literal|'_'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
return|return
operator|(
name|dopow
argument_list|(
name|name
argument_list|,
literal|2
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|stats
operator|&
name|SEPMASK
condition|)
block|{
comment|/* Here we have 1.x where x is not number 				 * but is a separator  				 * Here we have decimal int. NOT FORTRAN! 				 */
if|if
condition|(
operator|!
name|saweof
condition|)
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|name
operator|-
literal|1
argument_list|,
literal|10
argument_list|)
operator|)
return|;
block|}
else|else
goto|goto
name|last
goto|;
comment|/* return a symbol */
block|}
name|mantissa
label|:
do|do
block|{
name|push
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|VNUM
operator|==
name|next
argument_list|()
condition|)
do|;
comment|/* Here we have [0-9]*\.[0-9]* 	 * three possibilities: 	 *   next character is e,E,d or D in which case we examine 	 *	the exponent [then we are faced with a similar 	 *	situation to this one: is the character after the 	 *	exponent a separator or not] 	 *   next character is a separator, in which case we have a 	 *      number (without an exponent) 	 *   next character is not a separator in which case we have 	 *      an atom (whose prefix just happens to look like a 	 *	number) 	 */
if|if
condition|(
operator|(
name|c
operator|==
literal|'e'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'E'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'d'
operator|)
operator|||
operator|(
name|c
operator|==
literal|'D'
operator|)
condition|)
goto|goto
name|expt
goto|;
if|if
condition|(
name|stats
operator|&
name|SEPMASK
condition|)
goto|goto
name|verylast
goto|;
comment|/* a real number */
else|else
goto|goto
name|last
goto|;
comment|/* prefix makes it look like a number, but it isn't */
name|expt
label|:
name|exploc
operator|=
name|name
expr_stmt|;
comment|/* remember location of exponent character */
name|push
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'+'
operator|||
name|c
operator|==
literal|'-'
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
name|VNUM
operator|==
name|stats
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
name|next
argument_list|()
expr_stmt|;
block|}
comment|/* if a separator follows then we have a number, else just 	 * an atom 	 */
if|if
condition|(
name|stats
operator|&
name|SEPMASK
condition|)
goto|goto
name|verylast
goto|;
name|last
label|:
comment|/* get here when what looks like a number turns out to be an atom */
if|if
condition|(
operator|!
name|saweof
condition|)
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
return|;
name|verylast
label|:
if|if
condition|(
operator|!
name|saweof
condition|)
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
comment|/* scanf requires that the exponent be 'e' */
if|if
condition|(
name|exploc
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
operator|*
name|exploc
operator|=
literal|'e'
expr_stmt|;
operator|*
name|name
operator|=
literal|0
expr_stmt|;
name|sscanf
argument_list|(
name|strbuf
argument_list|,
literal|"%F"
argument_list|,
operator|&
name|realno
argument_list|)
expr_stmt|;
operator|(
name|result
operator|=
name|newdoub
argument_list|()
operator|)
operator|->
name|r
operator|=
name|realno
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|dopow
parameter_list|(
name|part2
parameter_list|,
name|base
parameter_list|)
specifier|register
name|char
modifier|*
name|part2
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|name
init|=
name|part2
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
specifier|register
name|int
name|power
decl_stmt|;
name|lispval
name|work
decl_stmt|;
name|unsigned
name|char
name|stats
decl_stmt|,
name|c
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|saweof
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|end1
init|=
name|part2
operator|-
literal|1
decl_stmt|;
name|lispval
name|Ltimes
parameter_list|()
function_decl|;
name|Savestack
argument_list|(
literal|4
argument_list|)
expr_stmt|;
while|while
condition|(
name|VNUM
operator|==
name|next
argument_list|()
condition|)
block|{
name|push
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
operator|!
name|saweof
condition|)
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'.'
operator|&&
operator|!
operator|(
name|stats
operator|&
name|SEPMASK
operator|)
condition|)
block|{
return|return
operator|(
name|finatom
argument_list|(
name|name
argument_list|)
operator|)
return|;
block|}
name|lbot
operator|=
name|np
expr_stmt|;
name|np
operator|++
operator|->
name|val
operator|=
name|inewint
argument_list|(
name|base
argument_list|)
expr_stmt|;
comment|/* calculate "mantissa"*/
if|if
condition|(
operator|*
name|end1
operator|==
literal|'.'
condition|)
name|np
operator|++
operator|->
name|val
operator|=
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|end1
operator|-
literal|1
argument_list|,
literal|10
argument_list|)
expr_stmt|;
else|else
name|np
operator|++
operator|->
name|val
operator|=
name|calcnum
argument_list|(
name|strbuf
argument_list|,
name|end1
argument_list|,
operator|(
name|int
operator|)
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
expr_stmt|;
comment|/* calculate exponent */
if|if
condition|(
name|c
operator|==
literal|'.'
condition|)
name|power
operator|=
name|calcnum
argument_list|(
name|part2
argument_list|,
name|name
argument_list|,
literal|10
argument_list|)
operator|->
name|i
expr_stmt|;
else|else
name|power
operator|=
name|calcnum
argument_list|(
name|part2
argument_list|,
name|name
argument_list|,
operator|(
name|int
operator|)
name|ibase
operator|->
name|a
operator|.
name|clb
operator|->
name|i
argument_list|)
operator|->
name|i
expr_stmt|;
while|while
condition|(
name|power
operator|--
operator|>
literal|0
condition|)
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|=
name|Ltimes
argument_list|()
expr_stmt|;
name|work
operator|=
name|lbot
index|[
literal|1
index|]
operator|.
name|val
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|work
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|calcnum
parameter_list|(
name|strbuf
parameter_list|,
name|name
parameter_list|,
name|base
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
name|char
modifier|*
name|strbuf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
specifier|register
name|lispval
name|result
decl_stmt|,
name|temp
decl_stmt|;
name|int
name|negflag
init|=
literal|0
decl_stmt|;
name|result
operator|=
name|temp
operator|=
name|newsdot
argument_list|()
expr_stmt|;
comment|/* initialize sdot cell */
name|protect
argument_list|(
name|temp
argument_list|)
expr_stmt|;
name|p
operator|=
name|strbuf
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'+'
condition|)
name|p
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'-'
condition|)
block|{
name|negflag
operator|=
literal|1
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
operator|*
name|name
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|name
condition|)
return|return
operator|(
name|getatom
argument_list|(
name|TRUE
argument_list|)
operator|)
return|;
for|for
control|(
init|;
name|p
operator|<
name|name
condition|;
name|p
operator|++
control|)
name|dmlad
argument_list|(
name|temp
argument_list|,
operator|(
name|long
operator|)
name|base
argument_list|,
operator|(
name|long
operator|)
operator|*
name|p
operator|-
literal|'0'
argument_list|)
expr_stmt|;
if|if
condition|(
name|negflag
condition|)
name|dmlad
argument_list|(
name|temp
argument_list|,
operator|-
literal|1L
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|temp
operator|->
name|s
operator|.
name|CDR
operator|==
literal|0
condition|)
block|{
name|result
operator|=
name|inewint
argument_list|(
name|temp
operator|->
name|i
argument_list|)
expr_stmt|;
name|pruneb
argument_list|(
name|np
index|[
operator|-
literal|1
index|]
operator|.
name|val
argument_list|)
expr_stmt|;
block|}
name|np
operator|--
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_function
name|lispval
name|finatom
parameter_list|(
name|name
parameter_list|)
specifier|register
name|char
modifier|*
name|name
decl_stmt|;
block|{
specifier|register
name|FILE
modifier|*
name|useport
init|=
name|rdrport
decl_stmt|;
name|unsigned
name|char
name|c
decl_stmt|,
name|stats
decl_stmt|;
name|int
name|cc
decl_stmt|,
name|saweof
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
operator|(
name|next
argument_list|()
operator|&
name|SEPMASK
operator|)
condition|)
block|{
if|if
condition|(
name|synclass
argument_list|(
name|stats
argument_list|)
operator|==
name|synclass
argument_list|(
name|VESC
argument_list|)
condition|)
block|{
name|c
operator|=
name|getc
argument_list|(
name|useport
argument_list|)
operator|&
literal|0177
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|uctolc
operator|&&
name|isupper
argument_list|(
name|c
argument_list|)
condition|)
name|c
operator|=
name|tolower
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
name|push
argument_list|()
expr_stmt|;
block|}
operator|*
name|name
operator|=
name|NULL_CHAR
expr_stmt|;
if|if
condition|(
operator|!
name|saweof
condition|)
name|ungetc
argument_list|(
operator|(
name|int
operator|)
name|c
argument_list|,
name|useport
argument_list|)
expr_stmt|;
return|return
operator|(
name|getatom
argument_list|(
name|TRUE
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|atomtoolong
parameter_list|(
name|copyto
parameter_list|)
name|char
modifier|*
name|copyto
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
specifier|register
name|char
modifier|*
name|oldp
init|=
name|strbuf
decl_stmt|;
specifier|register
name|char
modifier|*
name|newp
decl_stmt|;
name|lispval
name|nveci
parameter_list|()
function_decl|;
comment|/*      * the string buffer contains an string which is too long       * so we get a bigger buffer.      */
name|size
operator|=
operator|(
name|endstrb
operator|-
name|strbuf
operator|)
operator|*
literal|4
operator|+
literal|28
expr_stmt|;
name|newp
operator|=
operator|(
name|char
operator|*
operator|)
name|nveci
argument_list|(
name|size
argument_list|)
expr_stmt|;
name|atom_buffer
operator|=
operator|(
name|lispval
operator|)
name|newp
expr_stmt|;
name|strbuf
operator|=
name|newp
expr_stmt|;
name|endstrb
operator|=
name|newp
operator|+
name|size
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|oldp
operator|<
name|copyto
condition|)
operator|*
name|newp
operator|++
operator|=
operator|*
name|oldp
operator|++
expr_stmt|;
return|return
operator|(
name|newp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* printr ***************************************************************/
end_comment

begin_comment
comment|/* prints the first argument onto the port specified by the second 	*/
end_comment

begin_comment
comment|/*  * Last modified Mar 21, 1980 for hunks  */
end_comment

begin_expr_stmt
name|printr
argument_list|(
name|a
argument_list|,
name|useport
argument_list|)
specifier|register
name|lispval
name|a
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|useport
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|hsize
operator|,
name|i
expr_stmt|;
name|char
name|strflag
init|=
literal|0
decl_stmt|;
name|char
name|Idqc
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|chstr
decl_stmt|;
name|int
name|curplength
init|=
name|plength
decl_stmt|;
name|int
name|quot
decl_stmt|;
name|lispval
name|Istsrch
parameter_list|()
function_decl|;
name|lispval
name|debugmode
decl_stmt|;
name|val_loop
label|:
if|if
condition|(
operator|!
name|VALID
argument_list|(
name|a
argument_list|)
condition|)
block|{
name|debugmode
operator|=
name|Istsrch
argument_list|(
name|matom
argument_list|(
literal|"debugging"
argument_list|)
argument_list|)
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
expr_stmt|;
if|if
condition|(
name|debugmode
operator|!=
name|nil
condition|)
block|{
name|printf
argument_list|(
literal|"<printr:bad lisp data: 0x%x>\n"
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"Bad lisp data encountered by printr"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|a
operator|=
name|badst
expr_stmt|;
name|printf
argument_list|(
literal|"<printr:bad lisp data: 0x%x>"
argument_list|,
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
block|}
switch|switch
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
condition|)
block|{
case|case
name|UNBO
case|:
name|fputs
argument_list|(
literal|"<UNBOUND>"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|VALUE
case|:
name|fputs
argument_list|(
literal|"(ptr to)"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|l
expr_stmt|;
goto|goto
name|val_loop
goto|;
case|case
name|INT
case|:
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"%d"
argument_list|,
name|a
operator|->
name|i
argument_list|)
expr_stmt|;
break|break;
case|case
name|DOUB
case|:
block|{
name|char
name|buf
index|[
literal|64
index|]
decl_stmt|;
name|lfltpr
argument_list|(
name|buf
argument_list|,
name|a
operator|->
name|r
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|PORT
case|:
block|{
name|lispval
name|cp
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|ioname
index|[
name|PN
argument_list|(
name|a
operator|->
name|p
argument_list|)
index|]
operator|)
operator|==
name|nil
condition|)
name|fputs
argument_list|(
literal|"%$unopenedport"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"%%%s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|HUNK2
case|:
case|case
name|HUNK4
case|:
case|case
name|HUNK8
case|:
case|case
name|HUNK16
case|:
case|case
name|HUNK32
case|:
case|case
name|HUNK64
case|:
case|case
name|HUNK128
case|:
if|if
condition|(
name|plevel
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"%"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
block|}
name|hsize
operator|=
literal|2
operator|<<
name|HUNKSIZE
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"{"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|plevel
operator|--
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|h
operator|.
name|hunk
index|[
literal|0
index|]
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|curplength
operator|--
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|hsize
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|a
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
operator|==
name|hunkfree
condition|)
break|break;
if|if
condition|(
name|curplength
operator|--
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|" ..."
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
block|}
else|else
block|{
name|fputs
argument_list|(
literal|" "
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|h
operator|.
name|hunk
index|[
name|i
index|]
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
block|}
name|fputs
argument_list|(
literal|"}"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|plevel
operator|++
expr_stmt|;
break|break;
case|case
name|VECTOR
case|:
name|chstr
operator|=
literal|"vector"
expr_stmt|;
name|quot
operator|=
literal|4
expr_stmt|;
comment|/* print out # of longwords */
goto|goto
name|veccommon
goto|;
case|case
name|VECTORI
case|:
name|chstr
operator|=
literal|"vectori"
expr_stmt|;
name|quot
operator|=
literal|1
expr_stmt|;
name|veccommon
label|:
comment|/* print out 'vector' or 'vectori' except in 			 * these circumstances: 			 * property is a symbol, in which case print 			 *  the symbol's pname 			 * property is a list with a 'print' property, 			 *  in which case it is funcalled to print the 			 *  vector 			 */
if|if
condition|(
name|a
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
operator|(
name|i
operator|=
name|TYPE
argument_list|(
name|a
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
argument_list|)
operator|)
operator|==
name|ATOM
condition|)
block|{
name|chstr
operator|=
name|a
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|->
name|a
operator|.
name|pname
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|==
name|DTPR
operator|)
operator|&&
name|vectorpr
argument_list|(
name|a
argument_list|,
name|useport
argument_list|)
condition|)
block|{
break|break;
comment|/* printed by vectorpr */
block|}
elseif|else
if|if
condition|(
operator|(
name|i
operator|==
name|DTPR
operator|)
operator|&&
operator|(
name|a
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|->
name|d
operator|.
name|car
operator|!=
name|nil
operator|)
operator|&&
name|TYPE
argument_list|(
name|a
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|->
name|d
operator|.
name|car
argument_list|)
operator|==
name|ATOM
condition|)
block|{
name|chstr
operator|=
name|a
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|->
name|d
operator|.
name|car
operator|->
name|a
operator|.
name|pname
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"%s[%d]"
argument_list|,
name|chstr
argument_list|,
name|a
operator|->
name|vl
operator|.
name|vectorl
index|[
name|VSizeOff
index|]
operator|/
name|quot
argument_list|)
expr_stmt|;
break|break;
case|case
name|ARRAY
case|:
name|fputs
argument_list|(
literal|"array["
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|ar
operator|.
name|length
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"]"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCD
case|:
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"#%X-"
argument_list|,
name|a
operator|->
name|bcd
operator|.
name|start
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|bcd
operator|.
name|discipline
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|OTHER
case|:
name|fprintf
argument_list|(
name|useport
argument_list|,
literal|"#Other-%X"
argument_list|,
name|a
argument_list|)
expr_stmt|;
break|break;
case|case
name|SDOT
case|:
name|pbignum
argument_list|(
name|a
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|DTPR
case|:
if|if
condition|(
name|plevel
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|"&"
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
block|}
name|plevel
operator|--
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|d
operator|.
name|car
operator|==
name|quota
operator|&&
name|a
operator|->
name|d
operator|.
name|cdr
operator|!=
name|nil
operator|&&
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
operator|==
name|nil
condition|)
block|{
name|putc
argument_list|(
literal|'\''
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|plevel
operator|++
expr_stmt|;
break|break;
block|}
name|putc
argument_list|(
literal|'('
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|curplength
operator|--
expr_stmt|;
name|morelist
label|:
name|printr
argument_list|(
name|a
operator|->
name|d
operator|.
name|car
argument_list|,
name|useport
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|a
operator|=
name|a
operator|->
name|d
operator|.
name|cdr
operator|)
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|curplength
operator|--
operator|==
literal|0
condition|)
block|{
name|fputs
argument_list|(
literal|" ..."
argument_list|,
name|useport
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|putc
argument_list|(
literal|' '
argument_list|,
name|useport
argument_list|)
expr_stmt|;
if|if
condition|(
name|TYPE
argument_list|(
name|a
argument_list|)
operator|==
name|DTPR
condition|)
goto|goto
name|morelist
goto|;
name|fputs
argument_list|(
literal|". "
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|printr
argument_list|(
name|a
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
name|out
label|:
name|fputc
argument_list|(
literal|')'
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|plevel
operator|++
expr_stmt|;
break|break;
case|case
name|STRNG
case|:
name|strflag
operator|=
name|TRUE
expr_stmt|;
name|Idqc
operator|=
name|Xsdc
expr_stmt|;
case|case
name|ATOM
case|:
block|{
name|char
modifier|*
name|front
decl_stmt|,
modifier|*
name|temp
decl_stmt|,
name|first
decl_stmt|;
name|int
name|clean
decl_stmt|;
name|temp
operator|=
name|front
operator|=
operator|(
name|strflag
condition|?
operator|(
operator|(
name|char
operator|*
operator|)
name|a
operator|)
else|:
name|a
operator|->
name|a
operator|.
name|pname
operator|)
expr_stmt|;
if|if
condition|(
name|Idqc
operator|==
literal|0
condition|)
name|Idqc
operator|=
name|Xdqc
expr_stmt|;
if|if
condition|(
name|Idqc
condition|)
block|{
name|clean
operator|=
name|first
operator|=
operator|*
name|temp
expr_stmt|;
name|first
operator|&=
literal|0177
expr_stmt|;
switch|switch
condition|(
name|QUTMASK
operator|&
name|ctable
index|[
name|first
index|]
condition|)
block|{
case|case
name|QWNFRST
case|:
case|case
name|QALWAYS
case|:
name|clean
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|QWNUNIQ
case|:
if|if
condition|(
name|temp
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|first
operator|==
literal|'-'
operator|||
name|first
operator|==
literal|'+'
condition|)
name|temp
operator|++
expr_stmt|;
if|if
condition|(
name|synclass
argument_list|(
name|ctable
index|[
operator|*
name|temp
index|]
argument_list|)
operator|==
name|VNUM
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|clean
operator|&&
operator|*
name|temp
condition|)
block|{
if|if
condition|(
operator|(
name|ctable
index|[
operator|*
name|temp
index|]
operator|&
name|QUTMASK
operator|)
operator|==
name|QALWAYS
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|uctolc
operator|&&
operator|(
name|isupper
argument_list|(
operator|*
name|temp
argument_list|)
operator|)
condition|)
name|clean
operator|=
literal|0
expr_stmt|;
name|temp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|clean
operator|&&
operator|!
name|strflag
condition|)
name|fputs
argument_list|(
name|front
argument_list|,
name|useport
argument_list|)
expr_stmt|;
else|else
block|{
name|putc
argument_list|(
name|Idqc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
for|for
control|(
name|temp
operator|=
name|front
init|;
operator|*
name|temp
condition|;
name|temp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|temp
operator|==
name|Idqc
operator|||
operator|(
name|synclass
argument_list|(
name|ctable
index|[
operator|*
name|temp
index|]
argument_list|)
operator|)
operator|==
name|CESC
condition|)
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|temp
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
name|Idqc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
specifier|register
name|char
modifier|*
name|cp
init|=
name|front
decl_stmt|;
name|int
name|handy
init|=
name|ctable
index|[
operator|*
name|cp
operator|&
literal|0177
index|]
decl_stmt|;
if|if
condition|(
name|synclass
argument_list|(
name|handy
argument_list|)
operator|==
name|CNUM
condition|)
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
else|else
switch|switch
condition|(
name|handy
operator|&
name|QUTMASK
condition|)
block|{
case|case
name|QWNUNIQ
case|:
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
break|break;
case|case
name|QWNFRST
case|:
case|case
name|QALWAYS
case|:
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ctable
index|[
operator|*
name|cp
index|]
operator|&
name|QUTMASK
operator|)
operator|==
name|QALWAYS
condition|)
name|putc
argument_list|(
name|Xesc
argument_list|,
name|useport
argument_list|)
expr_stmt|;
name|putc
argument_list|(
operator|*
name|cp
argument_list|,
name|useport
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_block

begin_comment
comment|/* -- vectorpr  * (perhaps) print out vector specially  * this is called with a vector whose property list begins with  * a list.  We search for the 'print' property and if it exists,  * funcall the print function with two args: the vector and the port.  * We return TRUE iff we funcalled the function, else we return FALSE  * to have the standard printing done  */
end_comment

begin_expr_stmt
name|vectorpr
argument_list|(
name|vec
argument_list|,
name|port
argument_list|)
specifier|register
name|lispval
name|vec
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|FILE
modifier|*
name|port
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
name|int
name|svplevel
init|=
name|plevel
decl_stmt|;
comment|/* save these global values */
name|int
name|svplength
init|=
name|plength
decl_stmt|;
name|Savestack
argument_list|(
literal|2
argument_list|)
expr_stmt|;
for|for
control|(
name|handy
operator|=
name|vec
operator|->
name|v
operator|.
name|vector
index|[
name|VPropOff
index|]
operator|->
name|d
operator|.
name|cdr
init|;
name|handy
operator|!=
name|nil
condition|;
name|handy
operator|=
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|cdr
control|)
block|{
if|if
condition|(
name|handy
operator|->
name|d
operator|.
name|car
operator|==
name|Vprintsym
condition|)
block|{
name|lbot
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|handy
operator|->
name|d
operator|.
name|cdr
operator|->
name|d
operator|.
name|car
argument_list|)
expr_stmt|;
comment|/* function to call */
name|protect
argument_list|(
name|vec
argument_list|)
expr_stmt|;
name|protect
argument_list|(
name|P
argument_list|(
name|port
argument_list|)
argument_list|)
expr_stmt|;
name|Lfuncal
argument_list|()
expr_stmt|;
name|plevel
operator|=
name|svplevel
expr_stmt|;
comment|/* restore globals */
name|plength
operator|=
name|svplength
expr_stmt|;
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|TRUE
operator|)
return|;
comment|/* did the call */
block|}
block|}
name|Restorestack
argument_list|()
expr_stmt|;
return|return
operator|(
name|FALSE
operator|)
return|;
comment|/* nothing printed */
block|}
end_block

begin_macro
name|lfltpr
argument_list|(
argument|buf
argument_list|,
argument|val
argument_list|)
end_macro

begin_comment
comment|/* lisp floating point printer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|double
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
operator|(
name|char
operator|*
operator|)
name|Vfloatformat
operator|->
name|a
operator|.
name|clb
argument_list|,
name|val
argument_list|)
expr_stmt|;
for|for
control|(
name|cp1
operator|=
name|buf
init|;
operator|*
name|cp1
condition|;
name|cp1
operator|++
control|)
if|if
condition|(
operator|*
name|cp1
operator|==
literal|'.'
operator|||
operator|*
name|cp1
operator|==
literal|'E'
operator|||
operator|*
name|cp1
operator|==
literal|'e'
condition|)
return|return;
comment|/* if we are here, there was no dot, so the number was 	   an integer.  Furthermore, cp1 already points to the  	   end of the string. */
operator|*
name|cp1
operator|++
operator|=
literal|'.'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|'0'
expr_stmt|;
operator|*
name|cp1
operator|++
operator|=
literal|0
expr_stmt|;
block|}
end_block

begin_comment
comment|/* dmpport ****************************************************************/
end_comment

begin_comment
comment|/* outputs buffer indicated by first argument whether full or not	*/
end_comment

begin_macro
name|dmpport
argument_list|(
argument|useport
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|useport
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|fflush
argument_list|(
name|useport
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  protect and unprot moved to eval.c  (whr)  */
end_comment

end_unit

