begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|rcsid
init|=
literal|"$Header: lam9.c,v 1.7 85/03/13 17:19:15 sklower Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*					-[Sat Oct  1 19:44:47 1983 by jkf]-  * 	lam9.c				$Locker:  $  * lambda functions  *  * (c) copyright 1982, Regents of the University of California  */
end_comment

begin_include
include|#
directive|include
file|"global.h"
end_include

begin_comment
comment|/*  * These routines writen in C will allow use of the termcap file  * by any lisp program. They are very basic routines which initialize  * termcap and allow the lisp to execute any of the termcap functions.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/*add definations for I/O and bandrate */
end_comment

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_undef
undef|#
directive|undef
name|putchar
end_undef

begin_function_decl
name|int
name|putchar
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* functions used from the termlib */
end_comment

begin_function_decl
name|int
name|tgetflag
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|getenv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgoto
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|char
modifier|*
name|tgetstr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|char
name|bpbuf
index|[
literal|1024
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|tstrbuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* /*	This routine will initialize the termcap for the lisp programs. /*	If the termcap file is not found, or terminal type is undefined, /*	it will print out an error mesg.				*/
end_comment

begin_function
name|lispval
name|Ltci
parameter_list|()
block|{
name|char
modifier|*
name|cp
init|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
decl_stmt|;
name|char
modifier|*
name|pc
decl_stmt|;
name|int
name|found
decl_stmt|;
name|struct
name|sgttyb
name|tty
decl_stmt|;
name|found
operator|=
name|tgetent
argument_list|(
name|bpbuf
argument_list|,
name|cp
argument_list|)
expr_stmt|;
comment|/* open ther termcap file */
switch|switch
condition|(
name|found
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|printf
argument_list|(
literal|"\nError Termcap File not found \n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"\nError No Termcap Entry for this terminal \n"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|1
case|:
block|{
comment|/* everything was ok	*/
name|gtty
argument_list|(
literal|1
argument_list|,
operator|&
name|tty
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|tty
operator|.
name|sg_ospeed
expr_stmt|;
block|}
break|break;
block|}
name|cp
operator|=
name|tstrbuf
expr_stmt|;
name|BC
operator|=
name|tgetstr
argument_list|(
literal|"bc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|UP
operator|=
name|tgetstr
argument_list|(
literal|"up"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|pc
operator|=
name|tgetstr
argument_list|(
literal|"pc"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pc
condition|)
name|PC
operator|=
operator|*
name|pc
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
end_function

begin_comment
comment|/* This routine will execute any of the termcap functions used by the lisp /* program. If the feature is not include in the terminal defined it will /* ignore the call. /*		option	: feature to execute /*		line	: line if is nessery /*		colum	: colum if is nessaery /*									*/
end_comment

begin_function
name|lispval
name|Ltcx
parameter_list|()
block|{
specifier|register
name|struct
name|argent
modifier|*
name|mylbot
init|=
name|lbot
decl_stmt|;
name|int
name|line
decl_stmt|,
name|column
decl_stmt|;
switch|switch
condition|(
name|np
operator|-
name|lbot
condition|)
block|{
case|case
literal|1
case|:
name|line
operator|=
name|column
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|2
case|:
name|error
argument_list|(
literal|"Wrong number of Arguments to Termcapexecute"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
name|line
operator|=
name|mylbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
name|column
operator|=
name|mylbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|i
expr_stmt|;
block|}
return|return
operator|(
name|inewint
argument_list|(
name|show
argument_list|(
operator|(
name|char
operator|*
operator|)
name|mylbot
operator|->
name|val
argument_list|,
operator|&
name|line
argument_list|,
operator|&
name|column
argument_list|)
argument_list|)
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|show
argument_list|(
argument|option
argument_list|,
argument|line
argument_list|,
argument|colum
argument_list|)
name|char
operator|*
name|option
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|line
decl_stmt|,
modifier|*
name|colum
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|found
decl_stmt|;
name|char
name|clbuf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|clbp
init|=
name|clbuf
decl_stmt|;
name|char
modifier|*
name|clear
decl_stmt|;
comment|/* the tegetflag doesnot work ? */
name|clear
operator|=
name|tgetstr
argument_list|(
name|option
argument_list|,
operator|&
name|clbp
argument_list|)
expr_stmt|;
comment|/*printf("option = %d , %s \n",clear,option);*/
if|if
condition|(
operator|!
name|clear
condition|)
block|{
name|found
operator|=
name|tgetnum
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|found
condition|)
return|return
operator|(
name|found
operator|)
return|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|PC
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|option
argument_list|,
literal|"cm"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* if cursor motion, do it */
name|clear
operator|=
name|tgoto
argument_list|(
name|clear
argument_list|,
operator|*
name|colum
argument_list|,
operator|*
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|clear
operator|==
literal|'O'
condition|)
name|clear
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|clear
condition|)
comment|/* execute the feature */
name|tputs
argument_list|(
name|clear
argument_list|,
literal|0
argument_list|,
name|putchar
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * LIfranzcall :: lisp function int:franz-call  *   this function serves many purposes.  It provides access to  *   those things that are best done in C or which required a  *   C access to unix system calls.  *  *   Calls to this routine are not error checked, for the most part  *   because this is only called from trusted lisp code.  *  *   The functions in this file may or may not be documented in the manual.  *   See the lisp interface to this function for more details. (common2.l)  *  *  the first argument is always a fixnum index, the other arguments  *   depend on the function.  */
end_comment

begin_define
define|#
directive|define
name|fc_getpwnam
value|1
end_define

begin_define
define|#
directive|define
name|fc_access
value|2
end_define

begin_define
define|#
directive|define
name|fc_chdir
value|3
end_define

begin_define
define|#
directive|define
name|fc_unlink
value|4
end_define

begin_define
define|#
directive|define
name|fc_time
value|5
end_define

begin_define
define|#
directive|define
name|fc_chmod
value|6
end_define

begin_define
define|#
directive|define
name|fc_getpid
value|7
end_define

begin_define
define|#
directive|define
name|fc_stat
value|8
end_define

begin_define
define|#
directive|define
name|fc_gethostname
value|9
end_define

begin_define
define|#
directive|define
name|fc_link
value|10
end_define

begin_define
define|#
directive|define
name|fc_sleep
value|11
end_define

begin_define
define|#
directive|define
name|fc_nice
value|12
end_define

begin_function
name|lispval
name|LIfranzcall
parameter_list|()
block|{
specifier|register
name|lispval
name|handy
decl_stmt|;
if|if
condition|(
operator|(
name|np
operator|-
name|lbot
operator|)
operator|<=
literal|0
condition|)
name|argerr
argument_list|(
literal|"int:franz-call"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|lbot
index|[
literal|0
index|]
operator|.
name|val
operator|->
name|i
condition|)
block|{
case|case
name|fc_getpwnam
case|:
comment|/* arg 1 = user name 	 * return vector of name, uid, gid, dir 	 * or nil if doesn't exist. 	 */
block|{
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|,
modifier|*
name|getpwnam
argument_list|()
decl_stmt|;
name|lispval
name|newvec
argument_list|()
decl_stmt|,
name|inewint
argument_list|()
decl_stmt|;
name|struct
name|argent
modifier|*
name|oldnp
decl_stmt|;
name|pw
operator|=
name|getpwnam
argument_list|(
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"int:franz-call: invalid name"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
condition|)
block|{
name|handy
operator|=
name|newvec
argument_list|(
literal|4
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|oldnp
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
operator|=
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|=
name|inewint
argument_list|(
name|pw
operator|->
name|pw_uid
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|2
index|]
operator|=
name|inewint
argument_list|(
name|pw
operator|->
name|pw_gid
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|3
index|]
operator|=
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|np
operator|=
name|oldnp
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
return|return
operator|(
name|nil
operator|)
return|;
block|}
case|case
name|fc_access
case|:
return|return
operator|(
name|inewint
argument_list|(
name|access
argument_list|(
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"i:fc,access: non string"
argument_list|)
argument_list|,
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|i
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|fc_chdir
case|:
return|return
operator|(
name|inewint
argument_list|(
name|chdir
argument_list|(
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"i:fc,chdir: non string"
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|fc_unlink
case|:
return|return
operator|(
name|inewint
argument_list|(
name|unlink
argument_list|(
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"i:fc,unlink: non string"
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|fc_time
case|:
return|return
operator|(
name|inewint
argument_list|(
name|time
argument_list|(
literal|0
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|fc_chmod
case|:
return|return
operator|(
name|inewint
argument_list|(
name|chmod
argument_list|(
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"i:fc,chmod: non string"
argument_list|)
argument_list|,
name|lbot
index|[
literal|2
index|]
operator|.
name|val
operator|->
name|i
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|fc_getpid
case|:
return|return
operator|(
name|inewint
argument_list|(
name|getpid
argument_list|()
argument_list|)
operator|)
return|;
case|case
name|fc_stat
case|:
block|{
name|struct
name|argent
modifier|*
name|oldnp
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"ifc:stat bad file name "
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|!=
literal|0
condition|)
return|return
operator|(
name|nil
operator|)
return|;
comment|/* nil on error */
name|handy
operator|=
name|newvec
argument_list|(
literal|12
operator|*
sizeof|sizeof
argument_list|(
name|long
argument_list|)
argument_list|)
expr_stmt|;
name|oldnp
operator|=
name|np
expr_stmt|;
name|protect
argument_list|(
name|handy
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|0
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_mode
operator|&
literal|07777
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|1
index|]
operator|=
name|inewint
argument_list|(
operator|(
name|statbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|>>
literal|12
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|2
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_nlink
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|3
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_uid
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|4
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_gid
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|5
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_size
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|6
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_atime
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|7
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|8
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_ctime
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|9
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_dev
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|10
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_rdev
argument_list|)
expr_stmt|;
name|handy
operator|->
name|v
operator|.
name|vector
index|[
literal|11
index|]
operator|=
name|inewint
argument_list|(
name|statbuf
operator|.
name|st_ino
argument_list|)
expr_stmt|;
name|np
operator|=
name|oldnp
expr_stmt|;
return|return
operator|(
name|handy
operator|)
return|;
block|}
case|case
name|fc_gethostname
case|:
block|{
if|#
directive|if
name|os_4_1a
operator|||
name|os_4_1c
operator|||
name|os_4_2
operator|||
name|os_4_3
name|char
name|hostname
index|[
literal|32
index|]
decl_stmt|;
name|gethostname
argument_list|(
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|hostname
argument_list|)
operator|)
return|;
else|#
directive|else
return|return
operator|(
operator|(
name|lispval
operator|)
name|inewstr
argument_list|(
name|SITE
argument_list|)
operator|)
return|;
endif|#
directive|endif
block|}
case|case
name|fc_link
case|:
return|return
operator|(
name|inewint
argument_list|(
name|link
argument_list|(
name|verify
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
argument_list|,
literal|"i:fc,link: non string"
argument_list|)
argument_list|,
name|verify
argument_list|(
name|lbot
index|[
literal|2
index|]
operator|.
name|val
argument_list|,
literal|"i:fc,link: non string"
argument_list|)
argument_list|)
argument_list|)
operator|)
return|;
comment|/* sleep for the given number of seconds */
case|case
name|fc_sleep
case|:
return|return
operator|(
name|inewint
argument_list|(
name|sleep
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
argument_list|)
argument_list|)
operator|)
return|;
case|case
name|fc_nice
case|:
return|return
operator|(
name|inewint
argument_list|(
name|nice
argument_list|(
name|lbot
index|[
literal|1
index|]
operator|.
name|val
operator|->
name|i
argument_list|)
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|inewint
argument_list|(
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
comment|/* end of switch */
block|}
end_function

end_unit

