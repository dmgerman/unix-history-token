begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)status.c	5.1 (Berkeley) 6/5/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Print out what's currently being traced by looking at  * the currently active breakpoints.  *  * The list is in LIFO order, we print it FIFO by going recursive.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"bp.rep"
end_include

begin_define
define|#
directive|define
name|printnum
parameter_list|(
name|id
parameter_list|)
value|if (!isredirected()) printf("(%d) ", id)
end_define

begin_macro
name|status
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|bphead
operator|==
name|NIL
condition|)
block|{
if|if
condition|(
operator|!
name|isredirected
argument_list|()
condition|)
block|{
name|printf
argument_list|(
literal|"no trace's or stop's active\n"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|bpstatus
argument_list|(
name|bphead
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_function
name|LOCAL
name|bpstatus
parameter_list|(
name|bp
parameter_list|)
name|BPINFO
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|BPINFO
modifier|*
name|p
decl_stmt|;
name|LINENO
name|n
decl_stmt|;
name|SYM
modifier|*
name|s
decl_stmt|;
name|NODE
modifier|*
name|t
decl_stmt|;
name|char
modifier|*
name|trname
decl_stmt|,
modifier|*
name|stname
decl_stmt|;
name|p
operator|=
name|bp
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bpnext
operator|!=
name|NIL
condition|)
block|{
name|bpstatus
argument_list|(
name|p
operator|->
name|bpnext
argument_list|)
expr_stmt|;
block|}
name|t
operator|=
name|p
operator|->
name|bpnode
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bpline
operator|>=
literal|0
condition|)
block|{
name|n
operator|=
name|linelookup
argument_list|(
name|p
operator|->
name|bpaddr
argument_list|)
expr_stmt|;
name|trname
operator|=
literal|"trace"
expr_stmt|;
name|stname
operator|=
literal|"stop"
expr_stmt|;
block|}
else|else
block|{
name|n
operator|=
name|p
operator|->
name|bpaddr
expr_stmt|;
name|trname
operator|=
literal|"tracei"
expr_stmt|;
name|stname
operator|=
literal|"stopi"
expr_stmt|;
block|}
switch|switch
condition|(
name|p
operator|->
name|bptype
condition|)
block|{
case|case
name|INST
case|:
name|printnum
argument_list|(
name|p
operator|->
name|bpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s %d"
argument_list|,
name|trname
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALL_ON
case|:
name|printnum
argument_list|(
name|p
operator|->
name|bpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|trname
argument_list|)
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|program
condition|)
block|{
name|printf
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STOP_ON
case|:
name|printnum
argument_list|(
name|p
operator|->
name|bpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|stname
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|program
condition|)
block|{
name|printf
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|BLOCK_ON
case|:
case|case
name|TERM_ON
case|:
name|s
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
name|printnum
argument_list|(
name|p
operator|->
name|bpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|trname
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|t
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|program
condition|)
block|{
name|printf
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|AT_BP
case|:
name|printnum
argument_list|(
name|p
operator|->
name|bpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s "
argument_list|,
name|trname
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|t
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" at %d"
argument_list|,
name|p
operator|->
name|bpline
argument_list|)
expr_stmt|;
break|break;
case|case
name|STOP_BP
case|:
name|printnum
argument_list|(
name|p
operator|->
name|bpid
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|stname
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|!=
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|t
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|s
operator|=
name|p
operator|->
name|bpblock
operator|)
operator|!=
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|" in "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|bpline
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" at %d"
argument_list|,
name|p
operator|->
name|bpline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" at %d"
argument_list|,
name|p
operator|->
name|bpaddr
argument_list|)
expr_stmt|;
block|}
break|break;
comment|/* 		 * Temporary breakpoints; 		 * return rather than break to avoid printing newline. 		 */
case|case
name|ALL_OFF
case|:
case|case
name|CALL
case|:
case|case
name|RETURN
case|:
case|case
name|CALLPROC
case|:
case|case
name|STOP_OFF
case|:
case|case
name|BLOCK_OFF
case|:
case|case
name|TERM_OFF
case|:
case|case
name|END_BP
case|:
return|return;
default|default:
name|panic
argument_list|(
literal|"bptype %d in bplist"
argument_list|,
name|p
operator|->
name|bptype
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p
operator|->
name|bpcond
operator|!=
name|NIL
condition|)
block|{
name|printf
argument_list|(
literal|" if "
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Print the name of a symbol unambigously.  */
end_comment

begin_function
name|LOCAL
name|printname
parameter_list|(
name|s
parameter_list|)
name|SYM
modifier|*
name|s
decl_stmt|;
block|{
if|if
condition|(
name|isambiguous
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|printwhich
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|name
argument_list|(
name|s
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

