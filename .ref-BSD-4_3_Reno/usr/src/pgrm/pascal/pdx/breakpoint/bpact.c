begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)bpact.c	5.1 (Berkeley) 6/5/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Routines for doing the right thing when a breakpoint is reached.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"breakpoint.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"tree.h"
end_include

begin_include
include|#
directive|include
file|"source.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"bp.rep"
end_include

begin_include
include|#
directive|include
file|"tree/tree.rep"
end_include

begin_typedef
typedef|typedef
enum|enum
block|{
name|SAVE
block|,
name|NOSAVE
block|}
name|SAVEBP
typedef|;
end_typedef

begin_function_decl
name|LOCAL
name|SAVEBP
name|handlebp
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * A "delayed" breakpoint is one that has an action involving execution  * of code, e.g. at a CALL we want to step from the beginning of the  * procedure to the first line before printing parameters.  */
end_comment

begin_decl_stmt
name|LOCAL
name|short
name|delayed
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|NONE
value|0
end_define

begin_define
define|#
directive|define
name|DELAY_CALL
value|1
end_define

begin_define
define|#
directive|define
name|DELAY_STOP
value|2
end_define

begin_comment
comment|/*  * Take action at a breakpoint; if it's not a breakpoint return FALSE.  *  * As we go through the list of breakpoints, we have to remember  * the previous one so that "handlebp" can delete breakpoints on  * the fly if necessary.  *  * If the breakpoint is a STOP_BP, handlebp will set "isstopped".  After  * going through the loop, bpact checks if "isstopped" is set and calls  * printstatus if it is.  This is so multiple breakpoints at the same  * address, one of which is a STOP_BP, still work.  */
end_comment

begin_define
define|#
directive|define
name|isswitch
parameter_list|(
name|bptype
parameter_list|)
value|( \ 	bptype == ALL_ON || bptype == ALL_OFF || \ 	bptype == TERM_ON || bptype == TERM_OFF || \ 	bptype == BLOCK_ON || bptype == BLOCK_OFF || \ 	bptype == STOP_ON || bptype == STOP_OFF \ )
end_define

begin_function
name|BOOLEAN
name|bpact
parameter_list|()
block|{
specifier|register
name|BPINFO
modifier|*
name|p
decl_stmt|;
name|BPINFO
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
name|BOOLEAN
name|found
decl_stmt|;
name|ADDRESS
name|oldpc
decl_stmt|;
name|delayed
operator|=
name|NONE
expr_stmt|;
name|found
operator|=
name|FALSE
expr_stmt|;
name|prev
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|p
operator|=
name|bphead
init|;
name|p
operator|!=
name|NIL
condition|;
name|p
operator|=
name|next
control|)
block|{
name|next
operator|=
name|p
operator|->
name|bpnext
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bpaddr
operator|==
name|pc
condition|)
block|{
name|prbpfound
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|found
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bpcond
operator|==
name|NIL
operator|||
name|isswitch
argument_list|(
name|p
operator|->
name|bptype
argument_list|)
operator|||
name|cond
argument_list|(
name|p
operator|->
name|bpcond
argument_list|)
condition|)
block|{
name|prbphandled
argument_list|()
expr_stmt|;
if|if
condition|(
name|handlebp
argument_list|(
name|p
argument_list|)
operator|==
name|NOSAVE
condition|)
block|{
name|prbpnosave
argument_list|()
expr_stmt|;
if|if
condition|(
name|prev
operator|==
name|NIL
condition|)
block|{
name|bphead
operator|=
name|next
expr_stmt|;
block|}
else|else
block|{
name|prev
operator|->
name|bpnext
operator|=
name|next
expr_stmt|;
block|}
name|dispose
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|prbpsave
argument_list|()
expr_stmt|;
name|prev
operator|=
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|p
expr_stmt|;
block|}
block|}
else|else
block|{
name|prev
operator|=
name|p
expr_stmt|;
block|}
block|}
if|if
condition|(
name|delayed
operator|!=
name|NONE
condition|)
block|{
name|oldpc
operator|=
name|pc
expr_stmt|;
name|runtofirst
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|delayed
operator|&
name|DELAY_CALL
operator|)
operator|==
name|DELAY_CALL
condition|)
block|{
name|SYM
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|s
operator|=
name|curfunc
expr_stmt|;
name|t
operator|=
name|whatblock
argument_list|(
name|return_addr
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|t
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"can't find block for caller addr %d"
argument_list|,
name|caller_addr
argument_list|()
argument_list|)
expr_stmt|;
block|}
name|printcall
argument_list|(
name|s
argument_list|,
name|t
argument_list|)
expr_stmt|;
name|addbp
argument_list|(
name|return_addr
argument_list|()
argument_list|,
name|RETURN
argument_list|,
name|s
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pc
operator|!=
name|oldpc
condition|)
block|{
name|bpact
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|isstopped
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|isstopped
condition|)
block|{
name|printstatus
argument_list|()
expr_stmt|;
block|}
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
name|found
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Handle an expected breakpoint appropriately, return whether  * or not to save the breakpoint.  */
end_comment

begin_function
name|LOCAL
name|SAVEBP
name|handlebp
parameter_list|(
name|p
parameter_list|)
name|BPINFO
modifier|*
name|p
decl_stmt|;
block|{
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|SAVEBP
name|r
decl_stmt|;
name|r
operator|=
name|SAVE
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|bptype
condition|)
block|{
case|case
name|ALL_ON
case|:
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
name|addcond
argument_list|(
name|TRPRINT
argument_list|,
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bpline
operator|>=
literal|0
condition|)
block|{
name|tracing
operator|++
expr_stmt|;
block|}
else|else
block|{
name|inst_tracing
operator|++
expr_stmt|;
block|}
name|addbp
argument_list|(
name|return_addr
argument_list|()
argument_list|,
name|ALL_OFF
argument_list|,
name|curfunc
argument_list|,
name|p
operator|->
name|bpcond
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|ALL_OFF
case|:
name|r
operator|=
name|NOSAVE
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bpline
operator|>=
literal|0
condition|)
block|{
name|tracing
operator|--
expr_stmt|;
block|}
else|else
block|{
name|inst_tracing
operator|--
expr_stmt|;
block|}
name|delcond
argument_list|(
name|TRPRINT
argument_list|,
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
break|break;
case|case
name|STOP_ON
case|:
name|var_tracing
operator|++
expr_stmt|;
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
if|if
condition|(
name|p
operator|->
name|bpnode
operator|!=
name|NIL
condition|)
block|{
name|addvar
argument_list|(
name|TRSTOP
argument_list|,
name|p
operator|->
name|bpnode
argument_list|,
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p
operator|->
name|bpcond
operator|!=
name|NIL
condition|)
block|{
name|addcond
argument_list|(
name|TRSTOP
argument_list|,
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
block|}
name|addbp
argument_list|(
name|return_addr
argument_list|()
argument_list|,
name|STOP_OFF
argument_list|,
name|curfunc
argument_list|,
name|p
operator|->
name|bpcond
argument_list|,
name|p
operator|->
name|bpnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
name|STOP_OFF
case|:
name|r
operator|=
name|NOSAVE
expr_stmt|;
name|delcond
argument_list|(
name|TRSTOP
argument_list|,
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
name|var_tracing
operator|--
expr_stmt|;
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
break|break;
case|case
name|INST
case|:
name|curline
operator|=
name|p
operator|->
name|bpline
expr_stmt|;
if|if
condition|(
name|curline
operator|>
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"trace:  "
argument_list|)
expr_stmt|;
name|printlines
argument_list|(
name|curline
argument_list|,
name|curline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"inst trace:	"
argument_list|)
expr_stmt|;
name|printinst
argument_list|(
name|pc
argument_list|,
name|pc
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|STOP_BP
case|:
if|if
condition|(
name|p
operator|->
name|bpblock
operator|!=
name|NIL
condition|)
block|{
name|delayed
operator||=
name|DELAY_STOP
expr_stmt|;
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
block|}
name|curline
operator|=
name|p
operator|->
name|bpline
expr_stmt|;
name|isstopped
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|BLOCK_ON
case|:
block|{
name|BPINFO
modifier|*
name|nbp
decl_stmt|;
name|s
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
name|t
operator|=
name|p
operator|->
name|bpnode
operator|->
name|nameval
expr_stmt|;
name|nbp
operator|=
name|newbp
argument_list|(
name|codeloc
argument_list|(
name|t
argument_list|)
argument_list|,
name|CALL
argument_list|,
name|t
argument_list|,
name|p
operator|->
name|bpcond
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addbp
argument_list|(
name|return_addr
argument_list|()
argument_list|,
name|BLOCK_OFF
argument_list|,
operator|(
name|SYM
operator|*
operator|)
name|nbp
argument_list|,
name|NIL
argument_list|,
name|NIL
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|BLOCK_OFF
case|:
block|{
name|BPINFO
modifier|*
name|oldbp
decl_stmt|;
name|r
operator|=
name|NOSAVE
expr_stmt|;
name|oldbp
operator|=
operator|(
name|BPINFO
operator|*
operator|)
name|p
operator|->
name|bpblock
expr_stmt|;
name|delbp
argument_list|(
name|oldbp
operator|->
name|bpid
argument_list|)
expr_stmt|;
break|break;
block|}
case|case
name|CALL
case|:
name|delayed
operator||=
name|DELAY_CALL
expr_stmt|;
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
break|break;
case|case
name|RETURN
case|:
name|r
operator|=
name|NOSAVE
expr_stmt|;
name|s
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
name|printrtn
argument_list|(
name|s
argument_list|)
expr_stmt|;
break|break;
case|case
name|TERM_ON
case|:
block|{
name|ADDRESS
name|addr
decl_stmt|;
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
name|addvar
argument_list|(
name|TRPRINT
argument_list|,
name|p
operator|->
name|bpnode
argument_list|,
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
name|addr
operator|=
name|return_addr
argument_list|()
expr_stmt|;
name|addbp
argument_list|(
name|addr
argument_list|,
name|TERM_OFF
argument_list|,
name|curfunc
argument_list|,
name|p
operator|->
name|bpcond
argument_list|,
name|p
operator|->
name|bpnode
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|var_tracing
operator|++
expr_stmt|;
break|break;
block|}
case|case
name|TERM_OFF
case|:
name|r
operator|=
name|NOSAVE
expr_stmt|;
name|var_tracing
operator|--
expr_stmt|;
name|delvar
argument_list|(
name|TRPRINT
argument_list|,
name|p
operator|->
name|bpnode
argument_list|,
name|p
operator|->
name|bpcond
argument_list|)
expr_stmt|;
name|curfunc
operator|=
name|p
operator|->
name|bpblock
expr_stmt|;
break|break;
case|case
name|AT_BP
case|:
name|printf
argument_list|(
literal|"at line %d: "
argument_list|,
name|p
operator|->
name|bpline
argument_list|)
expr_stmt|;
name|eval
argument_list|(
name|p
operator|->
name|bpnode
argument_list|)
expr_stmt|;
name|prtree
argument_list|(
name|p
operator|->
name|bpnode
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" = "
argument_list|)
expr_stmt|;
name|printval
argument_list|(
name|p
operator|->
name|bpnode
operator|->
name|nodetype
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
break|break;
comment|/* 		 * Returning from a called procedure. 		 * Further breakpoint processing is not done, since if 		 * there were any it wouldn't be associated with the call. 		 */
case|case
name|CALLPROC
case|:
name|procreturn
argument_list|(
name|p
operator|->
name|bpblock
argument_list|)
expr_stmt|;
name|delbp
argument_list|(
name|p
operator|->
name|bpid
argument_list|)
expr_stmt|;
name|erecover
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
case|case
name|END_BP
case|:
name|r
operator|=
name|NOSAVE
expr_stmt|;
name|endprogram
argument_list|()
expr_stmt|;
default|default:
name|panic
argument_list|(
literal|"unknown bptype %d in cont"
argument_list|,
name|p
operator|->
name|bptype
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
return|return
operator|(
name|r
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Internal trace routines.  */
end_comment

begin_decl_stmt
name|LOCAL
name|char
modifier|*
name|prbptype
index|[]
init|=
block|{
literal|"ALL_ON"
block|,
literal|"ALL_OFF"
block|,
literal|"INST"
block|,
literal|"CALL"
block|,
literal|"RETURN"
block|,
literal|"BLOCK_ON"
block|,
literal|"BLOCK_OFF"
block|,
literal|"TERM_ON"
block|,
literal|"TERM_OFF"
block|,
literal|"AT_BP"
block|,
literal|"STOP_BP"
block|,
literal|"CALLPROC"
block|,
literal|"END_BP"
block|,
literal|"STOP_ON"
block|,
literal|"STOP_OFF"
block|, }
decl_stmt|;
end_decl_stmt

begin_function
name|LOCAL
name|prbpfound
parameter_list|(
name|p
parameter_list|)
name|BPINFO
modifier|*
name|p
decl_stmt|;
block|{
if|if
condition|(
name|option
argument_list|(
literal|'b'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s breakpoint found at pc %d, line %d -- "
argument_list|,
name|prbptype
index|[
operator|(
name|int
operator|)
name|p
operator|->
name|bptype
index|]
argument_list|,
name|p
operator|->
name|bpaddr
argument_list|,
name|p
operator|->
name|bpline
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|prbphandled
parameter_list|()
block|{
if|if
condition|(
name|option
argument_list|(
literal|'b'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"handled, "
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|prbpnosave
parameter_list|()
block|{
if|if
condition|(
name|option
argument_list|(
literal|'b'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"not saved\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|LOCAL
name|prbpsave
parameter_list|()
block|{
if|if
condition|(
name|option
argument_list|(
literal|'b'
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"saved\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

