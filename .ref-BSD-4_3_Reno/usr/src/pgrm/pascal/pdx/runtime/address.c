begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980 Regents of the University of California.  * All rights reserved.  The Berkeley software License Agreement  * specifies the terms and conditions for redistribution.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)address.c	5.1 (Berkeley) 6/6/85"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|not lint
end_endif

begin_comment
comment|/*  * Some machine and runtime dependent manipulation of a symbol.  */
end_comment

begin_include
include|#
directive|include
file|"defs.h"
end_include

begin_include
include|#
directive|include
file|"runtime.h"
end_include

begin_include
include|#
directive|include
file|"sym.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"process.h"
end_include

begin_include
include|#
directive|include
file|"object.h"
end_include

begin_include
include|#
directive|include
file|"mappings.h"
end_include

begin_include
include|#
directive|include
file|"sym/classes.h"
end_include

begin_include
include|#
directive|include
file|"frame.rep"
end_include

begin_include
include|#
directive|include
file|"sym/sym.rep"
end_include

begin_comment
comment|/*  * Calculate the address of a symbol.  * If frame is not NIL, then it is the frame associated with the  * activation in which the symbol we're interested in is defined.  */
end_comment

begin_function
name|ADDRESS
name|address
parameter_list|(
name|s
parameter_list|,
name|frame
parameter_list|)
specifier|register
name|SYM
modifier|*
name|s
decl_stmt|;
name|FRAME
modifier|*
name|frame
decl_stmt|;
block|{
name|SYM
modifier|*
name|f
decl_stmt|;
name|FRAME
modifier|*
name|frp
decl_stmt|;
name|ADDRESS
name|r
decl_stmt|,
modifier|*
name|dp
decl_stmt|,
modifier|*
name|disp
decl_stmt|;
name|short
name|offs
decl_stmt|;
name|f
operator|=
name|s
operator|->
name|func
expr_stmt|;
if|if
condition|(
name|s
operator|->
name|class
operator|==
name|FVAR
condition|)
block|{
name|offs
operator|=
name|f
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
else|else
block|{
name|offs
operator|=
name|s
operator|->
name|symvalue
operator|.
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|f
operator|==
name|program
condition|)
block|{
name|r
operator|=
operator|(
name|ADDRESS
operator|)
name|dispval
argument_list|(
name|MAINBLK
argument_list|)
operator|+
name|offs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|f
operator|==
name|curfunc
operator|&&
name|frame
operator|==
name|NIL
condition|)
block|{
name|dp
operator|=
name|curdp
argument_list|()
expr_stmt|;
name|disp
operator|=
name|contents
argument_list|(
name|dp
argument_list|)
expr_stmt|;
name|r
operator|=
operator|(
name|ADDRESS
operator|)
name|disp
operator|+
name|offs
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|frame
operator|==
name|NIL
condition|)
block|{
name|frp
operator|=
name|findframe
argument_list|(
name|s
operator|->
name|func
argument_list|)
expr_stmt|;
if|if
condition|(
name|frp
operator|==
name|NIL
condition|)
block|{
name|panic
argument_list|(
literal|"address: findframe returned NIL"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|frp
operator|=
name|frame
expr_stmt|;
block|}
name|r
operator|=
name|stkaddr
argument_list|(
name|frp
argument_list|,
name|s
operator|->
name|blkno
argument_list|)
operator|+
name|offs
expr_stmt|;
block|}
return|return
name|r
return|;
block|}
end_function

begin_comment
comment|/*  * The next three routines assume the procedure entry code is  *  *      f:  tra4    A  *          ...  *      A:  beg  *      B:<code for first line>  *  * Pi gives f, we compute and store A with "findbeginning(f)",  * (retrieved by "codeloc(f)"), B is computed by "firstline(f)".  *  * The procedure "runtofirst" assumes you're at A and want to step to B.  * It should be changed to a nop if A is equal to B.  */
end_comment

begin_comment
comment|/*  * Find the beginning of a procedure or function.  This is a destructive  * routine, it changes the value associated with the procedure symbol.  * Should only be called once per symbol.  */
end_comment

begin_macro
name|findbeginning
argument_list|(
argument|f
argument_list|)
end_macro

begin_decl_stmt
name|SYM
modifier|*
name|f
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|codeloc
operator|=
name|nextaddr
argument_list|(
name|f
operator|->
name|symvalue
operator|.
name|funcv
operator|.
name|codeloc
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Find the object code associated with the first line of a block.  */
end_comment

begin_function
name|ADDRESS
name|firstline
parameter_list|(
name|f
parameter_list|)
name|SYM
modifier|*
name|f
decl_stmt|;
block|{
name|ADDRESS
name|addr
decl_stmt|;
name|addr
operator|=
name|codeloc
argument_list|(
name|f
argument_list|)
expr_stmt|;
while|while
condition|(
name|linelookup
argument_list|(
name|addr
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|isendofproc
argument_list|(
name|addr
argument_list|)
condition|)
block|{
return|return
operator|-
literal|1
return|;
block|}
name|addr
operator|=
name|nextaddr
argument_list|(
name|addr
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|addr
return|;
block|}
end_function

begin_comment
comment|/*  * Catcher drops strike three ...  */
end_comment

begin_macro
name|runtofirst
argument_list|()
end_macro

begin_block
block|{
name|stepto
argument_list|(
name|firstline
argument_list|(
name|curfunc
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * Calculate the address of the last line in the program.  * This is assumed to be at the physical end.  */
end_comment

begin_function
name|ADDRESS
name|lastaddr
parameter_list|()
block|{
if|if
condition|(
name|objsize
operator|==
literal|0
condition|)
block|{
name|panic
argument_list|(
literal|"lastaddr: objsize = 0!"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|objsize
operator|-
sizeof|sizeof
argument_list|(
name|short
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

