begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)fio.c	5.6	(Berkeley) 6/29/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * flow control protocol.  *  * This protocol relies on flow control of the data stream.  * It is meant for working over links that can (almost) be  * guaranteed to be errorfree, specifically X.25/PAD links.  * A sumcheck is carried out over a whole file only. If a  * transport fails the receiver can request retransmission(s).  * This protocol uses a 7-bit datapath only, so it can be  * used on links that are not 8-bit transparent.  *  * When using this protocol with an X.25 PAD:  * Although this protocol uses no control chars except CR,  * control chars NULL and ^P are used before this protocol  * is started; since ^P is the default char for accessing  * PAD X.28 command mode, be sure to disable that access  * (PAD par 1). Also make sure both flow control pars  * (5 and 12) are set. The CR used in this proto is meant  * to trigger packet transmission, hence par 3 should be   * set to 2; a good value for the Idle Timer (par 4) is 10.  * All other pars should be set to 0.  *  * Normally a calling site will take care of setting the  * local PAD pars via an X.28 command and those of the remote  * PAD via an X.29 command, unless the remote site has a  * special channel assigned for this protocol with the proper  * par settings.  *  * Additional comments for hosts with direct X.25 access:  * - the global variable IsTcpIp, when set, excludes the ioctl's,  *   so the same binary can run on X.25 and non-X.25 hosts;  * - reads are done in small chunks, which can be smaller than  *   the packet size; your X.25 driver must support that.  *  *  * Author:  *	Piet Beertema, CWI, Amsterdam, Sep 1984  * Modified for X.25 hosts:  *	Robert Elz, Melbourne Univ, Mar 1985  */
end_comment

begin_include
include|#
directive|include
file|"uucp.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|USG
end_ifdef

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_else
else|#
directive|else
else|!USG
end_else

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
endif|!USG
end_endif

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_define
define|#
directive|define
name|FIBUFSIZ
value|4096
end_define

begin_comment
comment|/* for X.25 interfaces: set equal to packet size, 				 * but see comment above 				 */
end_comment

begin_define
define|#
directive|define
name|FOBUFSIZ
value|4096
end_define

begin_comment
comment|/* for X.25 interfaces: set equal to packet size; 				 * otherwise make as large as feasible to reduce 				 * number of write system calls  				 */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|MAXMSGLEN
end_ifndef

begin_define
define|#
directive|define
name|MAXMSGLEN
value|BUFSIZ
end_define

begin_endif
endif|#
directive|endif
endif|MAXMSGLEN
end_endif

begin_decl_stmt
specifier|static
name|int
name|fchksum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|jmp_buf
name|Ffailbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|Bytes_Sent
decl_stmt|,
name|Bytes_Received
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|falarm
argument_list|()
block|{
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|falarm
argument_list|)
block|;
name|longjmp
argument_list|(
name|Ffailbuf
argument_list|,
literal|1
argument_list|)
block|; }
specifier|static
name|void
argument_list|(
operator|*
name|fsig
argument_list|)
argument_list|()
expr_stmt|;
end_expr_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|USG
end_ifndef

begin_define
define|#
directive|define
name|TCGETA
value|TIOCGETP
end_define

begin_define
define|#
directive|define
name|TCSETAF
value|TIOCSETP
end_define

begin_define
define|#
directive|define
name|termio
value|sgttyb
end_define

begin_endif
endif|#
directive|endif
endif|USG
end_endif

begin_decl_stmt
specifier|static
name|struct
name|termio
name|ttbuf
decl_stmt|;
end_decl_stmt

begin_macro
name|fturnon
argument_list|()
end_macro

begin_block
block|{
name|int
name|ttbuf_flags
decl_stmt|;
if|if
condition|(
operator|!
name|IsTcpIp
condition|)
block|{
name|ioctl
argument_list|(
name|Ifn
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|ttbuf_flags
operator|=
name|ttbuf
operator|.
name|c_iflag
expr_stmt|;
name|ttbuf
operator|.
name|c_iflag
operator|=
name|IXOFF
operator||
name|IXON
operator||
name|ISTRIP
expr_stmt|;
name|ttbuf
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
name|FIBUFSIZ
operator|>
literal|64
condition|?
literal|64
else|:
name|FIBUFSIZ
expr_stmt|;
name|ttbuf
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|5
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Ifn
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|ttbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TCSETAF) failed: %m"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
name|ttbuf
operator|.
name|c_iflag
operator|=
name|ttbuf_flags
expr_stmt|;
else|#
directive|else
else|!USG
name|ttbuf_flags
operator|=
name|ttbuf
operator|.
name|sg_flags
expr_stmt|;
name|ttbuf
operator|.
name|sg_flags
operator|=
name|ANYP
operator||
name|CBREAK
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Ifn
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|ttbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TCSETAF) failed: %m"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
comment|/* this is two seperate ioctls to set the x.29 params */
name|ttbuf
operator|.
name|sg_flags
operator||=
name|TANDEM
expr_stmt|;
if|if
condition|(
name|ioctl
argument_list|(
name|Ifn
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|ttbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|syslog
argument_list|(
name|LOG_ERR
argument_list|,
literal|"ioctl(TCSETAF) failed: %m"
argument_list|)
expr_stmt|;
name|cleanup
argument_list|(
name|FAIL
argument_list|)
expr_stmt|;
block|}
name|ttbuf
operator|.
name|sg_flags
operator|=
name|ttbuf_flags
expr_stmt|;
endif|#
directive|endif
endif|USG
block|}
name|fsig
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|falarm
argument_list|)
expr_stmt|;
comment|/* give the other side time to perform its ioctl; 	 * otherwise it may flush out the first data this 	 * side is about to send. 	 */
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_block

begin_macro
name|fturnoff
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
operator|!
name|IsTcpIp
condition|)
name|ioctl
argument_list|(
name|Ifn
argument_list|,
name|TCSETAF
argument_list|,
operator|&
name|ttbuf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|fsig
argument_list|)
expr_stmt|;
name|sleep
argument_list|(
literal|2
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_block

begin_expr_stmt
name|fwrmsg
argument_list|(
name|type
argument_list|,
name|str
argument_list|,
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
name|char
name|bufr
index|[
name|MAXMSGLEN
index|]
decl_stmt|;
name|s
operator|=
name|bufr
expr_stmt|;
operator|*
name|s
operator|++
operator|=
name|type
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
operator|*
name|s
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'\n'
condition|)
name|s
operator|--
expr_stmt|;
operator|*
name|s
operator|++
operator|=
literal|'\r'
expr_stmt|;
operator|*
name|s
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
name|fn
argument_list|,
name|bufr
argument_list|,
name|s
operator|-
name|bufr
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
block|}
end_block

begin_expr_stmt
name|frdmsg
argument_list|(
name|str
argument_list|,
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|smax
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Ffailbuf
argument_list|)
condition|)
return|return
name|FAIL
return|;
name|smax
operator|=
name|str
operator|+
name|MAXMSGLEN
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|2
operator|*
name|MAXMSGTIME
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|fn
argument_list|,
name|str
argument_list|,
literal|1
argument_list|)
operator|<=
literal|0
condition|)
goto|goto
name|msgerr
goto|;
operator|*
name|str
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\r'
condition|)
break|break;
if|if
condition|(
operator|*
name|str
operator|<
literal|' '
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|str
operator|++
operator|>=
name|smax
condition|)
goto|goto
name|msgerr
goto|;
block|}
operator|*
name|str
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|SUCCESS
return|;
name|msgerr
label|:
operator|(
name|void
operator|)
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
end_block

begin_macro
name|fwrdata
argument_list|(
argument|fp1
argument_list|,
argument|fn
argument_list|)
end_macro

begin_decl_stmt
name|FILE
modifier|*
name|fp1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|alen
decl_stmt|,
name|ret
decl_stmt|;
name|char
name|ack
decl_stmt|,
name|ibuf
index|[
name|MAXMSGLEN
index|]
decl_stmt|;
name|int
name|flen
decl_stmt|,
name|mil
decl_stmt|,
name|retries
init|=
literal|0
decl_stmt|;
name|long
name|abytes
decl_stmt|,
name|fbytes
decl_stmt|;
name|struct
name|timeb
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|float
name|ft
decl_stmt|;
name|ret
operator|=
name|FAIL
expr_stmt|;
name|retry
label|:
name|fchksum
operator|=
literal|0xffff
expr_stmt|;
name|abytes
operator|=
name|fbytes
operator|=
literal|0L
expr_stmt|;
name|ack
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|time
argument_list|(
operator|&
name|t1
operator|.
name|time
argument_list|)
expr_stmt|;
name|t1
operator|.
name|millitm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|!USG
name|ftime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!USG
do|do
block|{
name|alen
operator|=
name|fwrblk
argument_list|(
name|fn
argument_list|,
name|fp1
argument_list|,
operator|&
name|flen
argument_list|)
expr_stmt|;
name|fbytes
operator|+=
name|flen
expr_stmt|;
if|if
condition|(
name|alen
operator|<=
literal|0
condition|)
block|{
name|abytes
operator|-=
name|alen
expr_stmt|;
goto|goto
name|acct
goto|;
block|}
name|abytes
operator|+=
name|alen
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|feof
argument_list|(
name|fp1
argument_list|)
operator|&&
operator|!
name|ferror
argument_list|(
name|fp1
argument_list|)
condition|)
do|;
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"\nchecksum: %04x\n"
argument_list|,
name|fchksum
argument_list|)
expr_stmt|;
if|if
condition|(
name|frdmsg
argument_list|(
name|ibuf
argument_list|,
name|fn
argument_list|)
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
operator|(
name|ack
operator|=
name|ibuf
index|[
literal|0
index|]
operator|)
operator|==
literal|'G'
condition|)
name|ret
operator|=
name|SUCCESS
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"ack - '%c'\n"
argument_list|,
name|ack
argument_list|)
expr_stmt|;
block|}
name|acct
label|:
ifdef|#
directive|ifdef
name|USG
name|time
argument_list|(
operator|&
name|t2
operator|.
name|time
argument_list|)
expr_stmt|;
name|t2
operator|.
name|millitm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|!USG
name|ftime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!USG
name|Now
operator|=
name|t2
expr_stmt|;
name|t2
operator|.
name|time
operator|-=
name|t1
operator|.
name|time
expr_stmt|;
name|mil
operator|=
name|t2
operator|.
name|millitm
operator|-
name|t1
operator|.
name|millitm
expr_stmt|;
if|if
condition|(
name|mil
operator|<
literal|0
condition|)
block|{
operator|--
name|t2
operator|.
name|time
expr_stmt|;
name|mil
operator|+=
literal|1000
expr_stmt|;
block|}
name|ft
operator|=
operator|(
name|float
operator|)
name|t2
operator|.
name|time
operator|+
operator|(
name|float
operator|)
name|mil
operator|/
literal|1000.
expr_stmt|;
name|sprintf
argument_list|(
name|ibuf
argument_list|,
literal|"sent data %ld bytes %.2f secs %ld bps"
argument_list|,
name|fbytes
argument_list|,
name|ft
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|float
operator|)
name|fbytes
operator|*
literal|8.
operator|/
name|ft
argument_list|)
argument_list|)
expr_stmt|;
name|sysacct
argument_list|(
name|abytes
argument_list|,
name|t2
operator|.
name|time
argument_list|)
expr_stmt|;
name|Bytes_Sent
operator|+=
name|fbytes
expr_stmt|;
if|if
condition|(
name|retries
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
operator|&
name|ibuf
index|[
name|strlen
argument_list|(
name|ibuf
argument_list|)
index|]
argument_list|,
literal|", %d retries"
argument_list|,
name|retries
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|ibuf
argument_list|)
expr_stmt|;
name|log_xferstats
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ack
operator|==
literal|'R'
condition|)
block|{
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"RETRY:\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp1
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|retries
operator|++
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
ifdef|#
directive|ifdef
name|SYSACCT
if|if
condition|(
name|ret
operator|==
name|FAIL
condition|)
name|sysaccf
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* force accounting */
endif|#
directive|endif
endif|SYSACCT
return|return
name|ret
return|;
block|}
end_block

begin_comment
comment|/* max. attempts to retransmit a file: */
end_comment

begin_define
define|#
directive|define
name|MAXRETRIES
value|(fbytes< 10000L ? 2 : 1)
end_define

begin_expr_stmt
name|frddata
argument_list|(
name|fn
argument_list|,
name|fp2
argument_list|)
specifier|register
name|int
name|fn
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|flen
decl_stmt|;
specifier|register
name|char
name|eof
decl_stmt|;
name|char
name|ibuf
index|[
name|FIBUFSIZ
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|,
name|mil
decl_stmt|,
name|retries
init|=
literal|0
decl_stmt|;
name|long
name|alen
decl_stmt|,
name|abytes
decl_stmt|,
name|fbytes
decl_stmt|;
name|struct
name|timeb
name|t1
decl_stmt|,
name|t2
decl_stmt|;
name|float
name|ft
decl_stmt|;
name|ret
operator|=
name|FAIL
expr_stmt|;
name|retry
label|:
name|fchksum
operator|=
literal|0xffff
expr_stmt|;
name|abytes
operator|=
name|fbytes
operator|=
literal|0L
expr_stmt|;
ifdef|#
directive|ifdef
name|USG
name|time
argument_list|(
operator|&
name|t1
operator|.
name|time
argument_list|)
expr_stmt|;
name|t1
operator|.
name|millitm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|!USG
name|ftime
argument_list|(
operator|&
name|t1
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!USG
do|do
block|{
name|flen
operator|=
name|frdblk
argument_list|(
name|ibuf
argument_list|,
name|fn
argument_list|,
operator|&
name|alen
argument_list|)
expr_stmt|;
name|abytes
operator|+=
name|alen
expr_stmt|;
if|if
condition|(
name|flen
operator|<
literal|0
condition|)
goto|goto
name|acct
goto|;
if|if
condition|(
name|eof
operator|=
name|flen
operator|>
name|FIBUFSIZ
condition|)
name|flen
operator|-=
name|FIBUFSIZ
operator|+
literal|1
expr_stmt|;
name|fbytes
operator|+=
name|flen
expr_stmt|;
if|if
condition|(
name|fwrite
argument_list|(
name|ibuf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|flen
argument_list|,
name|fp2
argument_list|)
operator|!=
name|flen
condition|)
goto|goto
name|acct
goto|;
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
name|ret
operator|=
name|SUCCESS
expr_stmt|;
name|acct
label|:
ifdef|#
directive|ifdef
name|USG
name|time
argument_list|(
operator|&
name|t2
operator|.
name|time
argument_list|)
expr_stmt|;
name|t2
operator|.
name|millitm
operator|=
literal|0
expr_stmt|;
else|#
directive|else
else|!USG
name|ftime
argument_list|(
operator|&
name|t2
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|!USG
name|Now
operator|=
name|t2
expr_stmt|;
name|t2
operator|.
name|time
operator|-=
name|t1
operator|.
name|time
expr_stmt|;
name|mil
operator|=
name|t2
operator|.
name|millitm
operator|-
name|t1
operator|.
name|millitm
expr_stmt|;
if|if
condition|(
name|mil
operator|<
literal|0
condition|)
block|{
operator|--
name|t2
operator|.
name|time
expr_stmt|;
name|mil
operator|+=
literal|1000
expr_stmt|;
block|}
name|ft
operator|=
operator|(
name|float
operator|)
name|t2
operator|.
name|time
operator|+
operator|(
name|float
operator|)
name|mil
operator|/
literal|1000.
expr_stmt|;
name|sprintf
argument_list|(
name|ibuf
argument_list|,
literal|"received data %ld bytes %.2f secs %ld bps"
argument_list|,
name|fbytes
argument_list|,
name|ft
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|float
operator|)
name|fbytes
operator|*
literal|8.
operator|/
name|ft
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|retries
operator|>
literal|0
condition|)
name|sprintf
argument_list|(
operator|&
name|ibuf
index|[
name|strlen
argument_list|(
name|ibuf
argument_list|)
index|]
argument_list|,
literal|" %d retries"
argument_list|,
name|retries
argument_list|)
expr_stmt|;
name|sysacct
argument_list|(
name|abytes
argument_list|,
name|t2
operator|.
name|time
argument_list|)
expr_stmt|;
name|Bytes_Received
operator|+=
name|fbytes
expr_stmt|;
name|DEBUG
argument_list|(
literal|1
argument_list|,
literal|"%s\n"
argument_list|,
name|ibuf
argument_list|)
expr_stmt|;
name|log_xferstats
argument_list|(
name|ibuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|==
name|FAIL
condition|)
block|{
if|if
condition|(
name|retries
operator|++
operator|<
name|MAXRETRIES
condition|)
block|{
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"send ack: 'R'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrmsg
argument_list|(
literal|'R'
argument_list|,
literal|""
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|fseek
argument_list|(
name|fp2
argument_list|,
literal|0L
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"RETRY:\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|retry
goto|;
block|}
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"send ack: 'Q'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrmsg
argument_list|(
literal|'Q'
argument_list|,
literal|""
argument_list|,
name|fn
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSACCT
name|sysaccf
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* force accounting */
endif|#
directive|endif
endif|SYSACCT
block|}
else|else
block|{
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"send ack: 'G'\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fwrmsg
argument_list|(
literal|'G'
argument_list|,
literal|""
argument_list|,
name|fn
argument_list|)
expr_stmt|;
block|}
return|return
name|ret
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|frdbuf
argument_list|(
name|blk
argument_list|,
name|len
argument_list|,
name|fn
argument_list|)
specifier|register
name|char
operator|*
name|blk
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|static
name|int
name|ret
init|=
name|FIBUFSIZ
operator|/
literal|2
decl_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|Ffailbuf
argument_list|)
condition|)
return|return
name|FAIL
return|;
operator|(
name|void
operator|)
name|alarm
argument_list|(
name|MAXMSGTIME
argument_list|)
expr_stmt|;
name|ret
operator|=
name|read
argument_list|(
name|fn
argument_list|,
name|blk
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|ret
operator|<=
literal|0
condition|?
name|FAIL
else|:
name|ret
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
end_if

begin_comment
comment|/* call ultouch every TC calls to either frdblk or fwrblk  */
end_comment

begin_define
define|#
directive|define
name|TC
value|20
end_define

begin_decl_stmt
specifier|static
name|int
name|tc
init|=
name|TC
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
endif|!defined(BSD4_2)&& !defined(USG)
end_endif

begin_comment
comment|/* Byte conversion:  *  *   from	 pre	   to  * 000-037	 172	 100-137  * 040-171		 040-171  * 172-177	 173	 072-077  * 200-237	 174	 100-137  * 240-371	 175	 040-171  * 372-377	 176	 072-077  */
end_comment

begin_expr_stmt
specifier|static
name|fwrblk
argument_list|(
argument|fn
argument_list|,
argument|fp
argument_list|,
argument|lenp
argument_list|)
name|int
name|fn
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|lenp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|op
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|sum
decl_stmt|,
name|nl
decl_stmt|,
name|len
decl_stmt|;
name|char
name|obuf
index|[
name|FOBUFSIZ
operator|+
literal|8
index|]
decl_stmt|;
name|int
name|ret
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
comment|/* call ultouch occasionally */
if|if
condition|(
operator|--
name|tc
operator|<
literal|0
condition|)
block|{
name|tc
operator|=
name|TC
expr_stmt|;
name|ultouch
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|!defined(BSD4_2)&& !defined(USG)
name|op
operator|=
name|obuf
expr_stmt|;
name|nl
operator|=
literal|0
expr_stmt|;
name|len
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
name|fchksum
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|len
operator|++
expr_stmt|;
if|if
condition|(
name|sum
operator|&
literal|0x8000
condition|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator|++
expr_stmt|;
block|}
else|else
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator|+=
name|c
expr_stmt|;
name|sum
operator|&=
literal|0xffff
expr_stmt|;
if|if
condition|(
name|c
operator|&
literal|0200
condition|)
block|{
name|c
operator|&=
literal|0177
expr_stmt|;
if|if
condition|(
name|c
operator|<
literal|040
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'\174'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
operator|+
literal|0100
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
literal|0171
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'\175'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op
operator|++
operator|=
literal|'\176'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
operator|-
literal|0100
expr_stmt|;
block|}
name|nl
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|c
operator|<
literal|040
condition|)
block|{
operator|*
name|op
operator|++
operator|=
literal|'\172'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
operator|+
literal|0100
expr_stmt|;
name|nl
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|<=
literal|0171
condition|)
block|{
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
name|nl
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|op
operator|++
operator|=
literal|'\173'
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|c
operator|-
literal|0100
expr_stmt|;
name|nl
operator|+=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nl
operator|>=
name|FOBUFSIZ
operator|-
literal|1
condition|)
block|{
comment|/* 			 * peek at next char, see if it will fit 			 */
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
break|break;
operator|(
name|void
operator|)
name|ungetc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nl
operator|>=
name|FOBUFSIZ
operator|||
name|c
operator|<
literal|040
operator|||
name|c
operator|>
literal|0171
condition|)
goto|goto
name|writeit
goto|;
block|}
block|}
comment|/* 	 * At EOF - append checksum, there is space for it... 	 */
name|sprintf
argument_list|(
name|op
argument_list|,
literal|"\176\176%04x\r"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
name|nl
operator|+=
name|strlen
argument_list|(
name|op
argument_list|)
expr_stmt|;
name|writeit
label|:
operator|*
name|lenp
operator|=
name|len
expr_stmt|;
name|fchksum
operator|=
name|sum
expr_stmt|;
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"%d/"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"%d,"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|ret
operator|=
name|write
argument_list|(
name|fn
argument_list|,
name|obuf
argument_list|,
name|nl
argument_list|)
expr_stmt|;
return|return
name|ret
operator|==
name|nl
condition|?
name|nl
else|:
name|ret
operator|<
literal|0
condition|?
literal|0
else|:
operator|-
name|ret
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|frdblk
argument_list|(
name|ip
argument_list|,
name|fn
argument_list|,
name|rlen
argument_list|)
specifier|register
name|char
operator|*
name|ip
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
name|fn
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
modifier|*
name|rlen
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|op
decl_stmt|,
name|c
decl_stmt|;
specifier|register
name|int
name|sum
decl_stmt|,
name|len
decl_stmt|,
name|nl
decl_stmt|;
name|char
name|buf
index|[
literal|5
index|]
decl_stmt|,
modifier|*
name|erbp
init|=
name|ip
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|static
name|char
name|special
init|=
literal|0
decl_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|USG
argument_list|)
comment|/* call ultouch occasionally */
if|if
condition|(
operator|--
name|tc
operator|<
literal|0
condition|)
block|{
name|tc
operator|=
name|TC
expr_stmt|;
name|ultouch
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
endif|!defined(BSD4_2)&& !defined(USG)
if|if
condition|(
operator|(
name|len
operator|=
name|frdbuf
argument_list|(
name|ip
argument_list|,
name|FIBUFSIZ
argument_list|,
name|fn
argument_list|)
operator|)
operator|==
name|FAIL
condition|)
block|{
operator|*
name|rlen
operator|=
literal|0
expr_stmt|;
goto|goto
name|dcorr
goto|;
block|}
operator|*
name|rlen
operator|=
name|len
expr_stmt|;
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"%d/"
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|op
operator|=
name|ip
expr_stmt|;
name|nl
operator|=
literal|0
expr_stmt|;
name|sum
operator|=
name|fchksum
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
operator|*
name|ip
operator|&=
literal|0177
operator|)
operator|>=
literal|'\172'
condition|)
block|{
if|if
condition|(
name|special
condition|)
block|{
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"%d"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
name|special
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|buf
expr_stmt|;
if|if
condition|(
operator|*
name|ip
operator|++
operator|!=
literal|'\176'
operator|||
operator|(
name|i
operator|=
operator|--
name|len
operator|)
operator|>
literal|5
condition|)
goto|goto
name|dcorr
goto|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|op
operator|++
operator|=
operator|*
name|ip
operator|++
operator|&
literal|0177
expr_stmt|;
while|while
condition|(
name|len
operator|<
literal|5
condition|)
block|{
name|i
operator|=
name|frdbuf
argument_list|(
operator|&
name|buf
index|[
name|len
index|]
argument_list|,
literal|5
operator|-
name|len
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|FAIL
condition|)
block|{
name|len
operator|=
name|FAIL
expr_stmt|;
goto|goto
name|dcorr
goto|;
block|}
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|",%d"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|len
operator|+=
name|i
expr_stmt|;
operator|*
name|rlen
operator|+=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
condition|)
operator|*
name|op
operator|++
operator|&=
literal|0177
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|4
index|]
operator|!=
literal|'\r'
condition|)
goto|goto
name|dcorr
goto|;
name|sscanf
argument_list|(
name|buf
argument_list|,
literal|"%4x"
argument_list|,
operator|&
name|fchksum
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"\nchecksum: %04x\n"
argument_list|,
name|sum
argument_list|)
expr_stmt|;
if|if
condition|(
name|fchksum
operator|==
name|sum
condition|)
return|return
name|FIBUFSIZ
operator|+
literal|1
operator|+
name|nl
return|;
else|else
block|{
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Bad checksum\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
name|FAIL
return|;
block|}
block|}
name|special
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|ip
operator|<
literal|'\040'
condition|)
block|{
comment|/* error: shouldn't get control chars */
goto|goto
name|dcorr
goto|;
block|}
switch|switch
condition|(
name|special
condition|)
block|{
case|case
literal|0
case|:
name|c
operator|=
operator|*
name|ip
operator|++
expr_stmt|;
break|break;
case|case
literal|'\172'
case|:
name|c
operator|=
operator|*
name|ip
operator|++
operator|-
literal|0100
expr_stmt|;
break|break;
case|case
literal|'\173'
case|:
name|c
operator|=
operator|*
name|ip
operator|++
operator|+
literal|0100
expr_stmt|;
break|break;
case|case
literal|'\174'
case|:
name|c
operator|=
operator|*
name|ip
operator|++
operator|+
literal|0100
expr_stmt|;
break|break;
case|case
literal|'\175'
case|:
name|c
operator|=
operator|*
name|ip
operator|++
operator|+
literal|0200
expr_stmt|;
break|break;
case|case
literal|'\176'
case|:
name|c
operator|=
operator|*
name|ip
operator|++
operator|+
literal|0300
expr_stmt|;
break|break;
block|}
operator|*
name|op
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|sum
operator|&
literal|0x8000
condition|)
block|{
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator|++
expr_stmt|;
block|}
else|else
name|sum
operator|<<=
literal|1
expr_stmt|;
name|sum
operator|+=
name|c
operator|&
literal|0377
expr_stmt|;
name|sum
operator|&=
literal|0xffff
expr_stmt|;
name|special
operator|=
literal|0
expr_stmt|;
name|nl
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
name|fchksum
operator|=
name|sum
expr_stmt|;
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"%d,"
argument_list|,
name|nl
argument_list|)
expr_stmt|;
return|return
name|nl
return|;
name|dcorr
label|:
name|DEBUG
argument_list|(
literal|8
argument_list|,
literal|"\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|DEBUG
argument_list|(
literal|4
argument_list|,
literal|"Data corrupted\n"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|len
operator|!=
name|FAIL
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|frdbuf
argument_list|(
name|erbp
argument_list|,
name|FIBUFSIZ
argument_list|,
name|fn
argument_list|)
operator|)
operator|!=
name|FAIL
condition|)
operator|*
name|rlen
operator|+=
name|len
expr_stmt|;
block|}
return|return
name|FAIL
return|;
block|}
end_block

end_unit

