begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|sccsid
init|=
literal|"@(#)addbib.c	4.2 (Berkeley) 11/2/84"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_define
define|#
directive|define
name|MAXENT
value|50
end_define

begin_struct
struct|struct
name|skeleton
block|{
name|char
name|prompt
index|[
literal|20
index|]
decl_stmt|;
comment|/* prompt user for entry */
name|char
name|keylet
index|[
literal|5
index|]
decl_stmt|;
comment|/* key letter for database */
block|}
name|bibskel
index|[
name|MAXENT
index|]
init|=
block|{
literal|"   Author:"
block|,
literal|"%A"
block|,
literal|"    Title:"
block|,
literal|"%T"
block|,
literal|"  Journal:"
block|,
literal|"%J"
block|,
literal|"   Volume:"
block|,
literal|"%V"
block|,
literal|"    Pages:"
block|,
literal|"%P"
block|,
literal|"Publisher:"
block|,
literal|"%I"
block|,
literal|"     City:"
block|,
literal|"%C"
block|,
literal|"     Date:"
block|,
literal|"%D"
block|,
literal|"    Other:"
block|,
literal|"%O"
block|,
literal|" Keywords:"
block|,
literal|"%K"
block|,	}
struct|;
end_struct

begin_decl_stmt
name|int
name|entries
init|=
literal|10
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of entries in bibskel */
end_comment

begin_decl_stmt
name|int
name|abstract
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* asking for abstracts is the default */
end_comment

begin_macro
name|usage
argument_list|()
end_macro

begin_comment
comment|/* print proper usage and exit */
end_comment

begin_block
block|{
name|puts
argument_list|(
literal|"Usage:  addbib [-p promptfile] [-a] database"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\t-p: the promptfile defines alternate fields"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\t-a: don't include prompting for the abstract"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
comment|/* addbib: bibliography entry program */
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|FILE
modifier|*
name|fp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|puts
argument_list|(
literal|"You must specify a bibliography file (database)."
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'p'
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|argc
operator|-
literal|2
condition|)
block|{
name|puts
argument_list|(
literal|"Not enough arguments for -p option."
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|rd_skel
argument_list|(
name|argv
index|[
operator|++
name|i
index|]
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
operator|==
literal|'a'
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|argc
operator|-
literal|1
condition|)
block|{
name|puts
argument_list|(
literal|"No bibliofile specified after -a."
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|abstract
operator|=
literal|0
expr_stmt|;
block|}
else|else
comment|/* neither -p nor -a */
block|{
name|printf
argument_list|(
literal|"Invalid command line flag: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|i
operator|<
name|argc
operator|-
literal|1
condition|)
block|{
name|puts
argument_list|(
literal|"Too many arguments with no options."
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addbib
argument_list|(
name|fp
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* loop for input */
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_macro
name|addbib
argument_list|(
argument|fp
argument_list|,
argument|argv
argument_list|)
end_macro

begin_comment
comment|/* add entries to a bibliographic database */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|line
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|i
init|=
literal|0
decl_stmt|,
name|firstln
decl_stmt|,
name|repeat
init|=
literal|0
decl_stmt|,
name|escape
init|=
literal|0
decl_stmt|;
name|printf
argument_list|(
literal|"Instructions? "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'y'
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'Y'
condition|)
name|instruct
argument_list|()
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|entries
condition|;
name|i
operator|++
control|)
block|{
name|printf
argument_list|(
literal|"%s\t"
argument_list|,
name|bibskel
index|[
name|i
index|]
operator|.
name|prompt
argument_list|)
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
block|{
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|line
index|[
literal|1
index|]
operator|==
literal|'\n'
condition|)
block|{
name|i
operator|-=
literal|2
expr_stmt|;
if|if
condition|(
name|i
operator|<
operator|-
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"Too far back.\n"
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
continue|continue;
block|}
elseif|else
if|if
condition|(
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'\\'
condition|)
block|{
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|trim
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s"
argument_list|,
name|bibskel
index|[
name|i
index|]
operator|.
name|keylet
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
name|again
label|:
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
operator|==
literal|'\\'
condition|)
block|{
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|2
index|]
operator|=
literal|'\n'
expr_stmt|;
name|line
index|[
name|strlen
argument_list|(
name|line
argument_list|)
operator|-
literal|1
index|]
operator|=
name|NULL
expr_stmt|;
name|trim
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
goto|goto
name|again
goto|;
block|}
name|trim
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|!=
literal|'\n'
condition|)
block|{
name|trim
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s %s"
argument_list|,
name|bibskel
index|[
name|i
index|]
operator|.
name|keylet
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|abstract
condition|)
block|{
name|puts
argument_list|(
literal|" Abstract: (ctrl-d to end)"
argument_list|)
expr_stmt|;
name|firstln
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
if|if
condition|(
name|firstln
operator|&&
name|line
index|[
literal|0
index|]
operator|!=
literal|'%'
condition|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%%X "
argument_list|)
expr_stmt|;
name|firstln
operator|=
literal|0
expr_stmt|;
block|}
name|fputs
argument_list|(
name|line
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
comment|/* write to file at end of each cycle */
if|if
condition|(
name|ferror
argument_list|(
name|fp
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|argv
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|editloop
label|:
name|printf
argument_list|(
literal|"\nContinue? "
argument_list|)
expr_stmt|;
name|fgets
argument_list|(
name|line
argument_list|,
name|BUFSIZ
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'e'
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'v'
condition|)
block|{
name|bibedit
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
name|argv
argument_list|)
expr_stmt|;
goto|goto
name|editloop
goto|;
block|}
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'q'
operator|||
name|line
index|[
literal|0
index|]
operator|==
literal|'n'
condition|)
return|return;
block|}
block|}
end_block

begin_macro
name|trim
argument_list|(
argument|line
argument_list|)
end_macro

begin_comment
comment|/* trim line of trailing white space */
end_comment

begin_decl_stmt
name|char
name|line
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|n
decl_stmt|;
name|n
operator|=
name|strlen
argument_list|(
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|n
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isspace
argument_list|(
name|line
index|[
name|n
index|]
argument_list|)
condition|)
break|break;
block|}
name|line
index|[
operator|++
name|n
index|]
operator|=
literal|'\n'
expr_stmt|;
name|line
index|[
operator|++
name|n
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_macro
name|bibedit
argument_list|(
argument|fp
argument_list|,
argument|cmd
argument_list|,
argument|arg
argument_list|)
end_macro

begin_comment
comment|/* edit database with edit, ex, or vi */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cmd
decl_stmt|,
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|i
init|=
literal|0
decl_stmt|,
name|status
decl_stmt|;
name|fclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
name|cmd
index|[
name|i
index|]
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
name|cmd
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|fork
argument_list|()
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmd
index|[
literal|0
index|]
operator|==
literal|'v'
operator|&&
name|cmd
index|[
literal|1
index|]
operator|==
literal|'i'
condition|)
name|execlp
argument_list|(
name|cmd
argument_list|,
name|cmd
argument_list|,
literal|"+$"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
comment|/* either ed, ex, or edit */
name|execlp
argument_list|(
name|cmd
argument_list|,
name|cmd
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|wait
argument_list|(
operator|&
name|status
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp
operator|=
name|fopen
argument_list|(
name|arg
argument_list|,
literal|"a"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|instruct
argument_list|()
end_macro

begin_comment
comment|/* give user elementary directions */
end_comment

begin_block
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Addbib will prompt you for various bibliographic fields."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"If you don't need a particular field, just hit RETURN,"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\tand that field will not appear in the output file."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"If you want to return to previous fields in the skeleton,"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ta single minus sign will go back a field at a time."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\t(This is the best way to input multiple authors.)"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"If you have to continue a field or add an unusual field,"
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"\ta trailing backslash will allow a temporary escape."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Finally, (without -a) you will be prompted for an abstract."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"Type in as many lines as you need, and end with a ctrl-d."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"To quit, type `q' or `n' when asked if you want to continue."
argument_list|)
expr_stmt|;
name|puts
argument_list|(
literal|"To edit the database, type `edit', `vi', or `ex' instead."
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|rd_skel
argument_list|(
argument|arg
argument_list|)
end_macro

begin_comment
comment|/* redo bibskel from user-supplied file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|arg
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|pfp
decl_stmt|,
modifier|*
name|fopen
argument_list|()
decl_stmt|;
name|char
name|str
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|int
name|entry
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
if|if
condition|(
operator|(
name|pfp
operator|=
name|fopen
argument_list|(
name|arg
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Promptfile "
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|arg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|entry
operator|=
literal|0
init|;
name|fgets
argument_list|(
name|str
argument_list|,
name|BUFSIZ
argument_list|,
name|pfp
argument_list|)
condition|;
name|entry
operator|++
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
operator|!=
literal|'\t'
operator|&&
name|str
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
control|)
name|bibskel
index|[
name|entry
index|]
operator|.
name|prompt
index|[
name|i
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|bibskel
index|[
name|entry
index|]
operator|.
name|prompt
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|str
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No tabs between promptfile fields.\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Format: prompt-string<TAB> %%key\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|++
operator|,
name|j
operator|=
literal|0
init|;
name|str
index|[
name|i
index|]
operator|!=
literal|'\n'
condition|;
name|i
operator|++
operator|,
name|j
operator|++
control|)
name|bibskel
index|[
name|entry
index|]
operator|.
name|keylet
index|[
name|j
index|]
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|bibskel
index|[
name|entry
index|]
operator|.
name|keylet
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|entry
operator|>=
name|MAXENT
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too many entries in promptfile.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|entries
operator|=
name|entry
expr_stmt|;
name|fclose
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

