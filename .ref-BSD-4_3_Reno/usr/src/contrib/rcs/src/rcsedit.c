begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS stream editor  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: rcsedit.c,v 3.11 89/08/15 21:37:31 bostic Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/**********************************************************************************  *                       edits the input file according to a  *                       script from stdin, generated by diff -n  *                       performs keyword expansion  **********************************************************************************  */
end_comment

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Walter Tichy.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Report all problems and direct all questions to:  *   rcs-bugs@cs.purdue.edu  *         */
end_comment

begin_comment
comment|/* $Log:	rcsedit.c,v $  * Revision 3.11  89/08/15  21:37:31  bostic  * Version 4 from Tom Narten at Purdue  *   * Revision 4.8  89/05/01  15:12:35  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.7  88/11/08  13:54:14  narten  * misplaced semicolon caused infinite loop  *   * Revision 4.6  88/11/08  12:01:41  narten  * changes from  eggert@sm.unisys.com (Paul Eggert)  *   * Revision 4.6  88/08/09  19:12:45  eggert  * Shrink stdio code size; allow cc -R.  *   * Revision 4.5  87/12/18  11:38:46  narten  * Changes from the 43. version. Don't know the significance of the  * first change involving "rewind". Also, additional "lint" cleanup.  * (Guy Harris)  *   * Revision 4.4  87/10/18  10:32:21  narten  * Updating version numbers. Changes relative to version 1.1 actually  * relative to 4.1  *   * Revision 1.4  87/09/24  13:59:29  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.3  87/09/15  16:39:39  shepler  * added an initializatin of the variables editline and linecorr  * this will be done each time a file is processed.  * (there was an obscure bug where if co was used to retrieve multiple files  *  it would dump)  * fix attributed to  Roy Morris @FileNet Corp ...!felix!roy  *   * Revision 1.2  87/03/27  14:22:17  jenkins  * Port to suns  *   * Revision 1.1  84/01/23  14:50:20  kcs  * Initial revision  *   * Revision 4.1  83/05/12  13:10:30  wft  * Added new markers Id and RCSfile; added locker to Header and Id.  * Overhauled expandline completely() (problem with $01234567890123456789@).  * Moved trymatch() and marker table to rcskeys.c.  *   * Revision 3.7  83/05/12  13:04:39  wft  * Added retry to expandline to resume after failed match which ended in $.  * Fixed truncation problem for $19chars followed by@@.  * Log no longer expands full path of RCS file.  *   * Revision 3.6  83/05/11  16:06:30  wft  * added retry to expandline to resume after failed match which ended in $.  * Fixed truncation problem for $19chars followed by@@.  *   * Revision 3.5  82/12/04  13:20:56  wft  * Added expansion of keyword Locker.  *  * Revision 3.4  82/12/03  12:26:54  wft  * Added line number correction in case editing does not start at the  * beginning of the file.  * Changed keyword expansion to always print a space before closing KDELIM;  * Expansion for Header shortened.  *  * Revision 3.3  82/11/14  14:49:30  wft  * removed Suffix from keyword expansion. Replaced fclose with ffclose.  * keyreplace() gets log message from delta, not from curlogmsg.  * fixed expression overflow in while(c=putc(GETC....  * checked nil printing.  *  * Revision 3.2  82/10/18  21:13:39  wft  * I added checks for write errors during the co process, and renamed  * expandstring() to xpandstring().  *  * Revision 3.1  82/10/13  15:52:55  wft  * changed type of result of getc() from char to int.  * made keyword expansion loop in expandline() portable to machines  * without sign-extension.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_function_decl
specifier|extern
name|FILE
modifier|*
name|fopen
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|mktempfile
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|bindex
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|,
modifier|*
name|frewrite
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|rewriteflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|nextc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|RCSfilename
decl_stmt|,
modifier|*
name|workfilename
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|bindex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getfullRCSname
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|enum
name|markers
name|trymatch
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
name|FILE
modifier|*
name|fcopy
decl_stmt|,
modifier|*
name|fedit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result and edit file descriptors                */
end_comment

begin_decl_stmt
name|char
modifier|*
name|resultfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* result file name                                */
end_comment

begin_decl_stmt
name|char
modifier|*
name|editfile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* edit   file name                                */
end_comment

begin_decl_stmt
name|int
name|editline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*line counter in fedit; starts with 1, is always #lines+1   */
end_comment

begin_decl_stmt
name|int
name|linecorr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*contains #adds - #deletes in each edit run.                */
end_comment

begin_comment
comment|/*used to correct editline in case file is not rewound after */
end_comment

begin_comment
comment|/* applying one delta                                        */
end_comment

begin_macro
name|initeditfiles
argument_list|(
argument|dir
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|dir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Initializes resultfile and editfile with temporary filenames  * in directory dir. Opens resultfile for reading and writing, with fcopy  * as file descriptor. fedit is set to nil.  */
end_comment

begin_block
block|{
name|editline
operator|=
name|linecorr
operator|=
literal|0
expr_stmt|;
comment|/* make sure we start from the beginning*/
name|resultfile
operator|=
name|mktempfile
argument_list|(
name|dir
argument_list|,
name|TMPFILE1
argument_list|)
expr_stmt|;
name|editfile
operator|=
name|mktempfile
argument_list|(
name|dir
argument_list|,
name|TMPFILE2
argument_list|)
expr_stmt|;
name|fedit
operator|=
name|nil
expr_stmt|;
if|if
condition|(
operator|(
name|fcopy
operator|=
name|fopen
argument_list|(
name|resultfile
argument_list|,
literal|"w+"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open working file %s"
argument_list|,
name|resultfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|swapeditfiles
argument_list|(
argument|tostdout
argument_list|)
end_macro

begin_comment
comment|/* Function: swaps resultfile and editfile, assigns fedit=fcopy,  * rewinds fedit for reading, and opens resultfile for reading and  * writing, using fcopy. If tostdout, fcopy is set to stdout.  */
end_comment

begin_block
block|{
name|char
modifier|*
name|tmpptr
decl_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|fcopy
argument_list|)
condition|)
name|faterror
argument_list|(
literal|"write failed on %s -- file system full?"
argument_list|,
name|resultfile
argument_list|)
expr_stmt|;
name|fedit
operator|=
name|fcopy
expr_stmt|;
name|rewind
argument_list|(
name|fedit
argument_list|)
expr_stmt|;
name|editline
operator|=
literal|1
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
name|tmpptr
operator|=
name|editfile
expr_stmt|;
name|editfile
operator|=
name|resultfile
expr_stmt|;
name|resultfile
operator|=
name|tmpptr
expr_stmt|;
if|if
condition|(
name|tostdout
condition|)
name|fcopy
operator|=
name|stdout
expr_stmt|;
name|elsif
argument_list|(
argument|(fcopy=fopen(resultfile,
literal|"w+"
argument|))==NULL
argument_list|)
block|{
name|faterror
argument_list|(
literal|"Can't open working file %s"
argument_list|,
name|resultfile
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|finishedit
argument_list|(
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* copy the rest of the edit file and close it (if it exists).  * if delta!=nil, perform keyword substitution at the same time.  */
end_comment

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
if|if
condition|(
name|fedit
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|delta
operator|!=
name|nil
condition|)
block|{
while|while
condition|(
name|expandline
argument_list|(
name|fedit
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|false
argument_list|,
name|false
argument_list|)
condition|)
name|editline
operator|++
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fedit
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|fcopy
parameter_list|)
function_decl|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|editline
operator|++
expr_stmt|;
block|}
block|}
name|ffclose
argument_list|(
name|fedit
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|copylines
argument_list|(
name|line
argument_list|,
name|delta
argument_list|)
specifier|register
name|int
name|line
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: copies input lines editline..line-1 from fedit to fcopy.  * If delta != nil, keyword expansion is done simultaneously.  * editline is updated. Rewinds a file only if necessary.  */
end_comment

begin_block
block|{
if|if
condition|(
name|editline
operator|>
name|line
condition|)
block|{
comment|/* swap files */
name|finishedit
argument_list|(
operator|(
expr|struct
name|hshentry
operator|*
operator|)
name|nil
argument_list|)
expr_stmt|;
name|swapeditfiles
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* assumes edit only during last pass, from the beginning*/
block|}
while|while
condition|(
name|editline
operator|<
name|line
condition|)
block|{
comment|/*copy another line*/
if|if
condition|(
name|delta
condition|)
name|VOID
name|expandline
parameter_list|(
name|fedit
parameter_list|,
name|fcopy
parameter_list|,
name|delta
parameter_list|,
name|false
parameter_list|,
name|false
parameter_list|)
function_decl|;
else|else
while|while
condition|(
name|putc
argument_list|(
name|getc
argument_list|(
name|fedit
argument_list|)
argument_list|,
name|fcopy
argument_list|)
operator|!=
literal|'\n'
condition|)
empty_stmt|;
name|editline
operator|++
expr_stmt|;
block|}
block|}
end_block

begin_macro
name|xpandstring
argument_list|(
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Reads a string terminated by SDELIM from finptr and writes it  * to fcopy. Double SDELIM is replaced with single SDELIM.  * Keyword expansion is performed with data from delta.  * If rewriteflag==true, the string is also copied unchanged to frewrite.  * editline is updated.  */
end_comment

begin_block
block|{
name|editline
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|expandline
argument_list|(
name|finptr
argument_list|,
name|fcopy
argument_list|,
name|delta
argument_list|,
name|true
argument_list|,
name|rewriteflag
argument_list|)
condition|)
name|editline
operator|++
expr_stmt|;
name|nextc
operator|=
literal|'\n'
expr_stmt|;
block|}
end_block

begin_macro
name|copystring
argument_list|()
end_macro

begin_comment
comment|/* Function: copies a string terminated with a single SDELIM from finptr to  * fcopy, replacing all double SDELIM with a single SDELIM.  * If rewriteflag==true, the string also copied unchanged to frewrite.  * editline is set to (number of lines copied)+1.  * Assumption: next character read is first string character.  */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|fin
decl_stmt|,
modifier|*
name|frew
decl_stmt|,
modifier|*
name|fcop
decl_stmt|;
specifier|register
name|write
expr_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|frewrite
expr_stmt|;
name|fcop
operator|=
name|fcopy
expr_stmt|;
name|write
operator|=
name|rewriteflag
expr_stmt|;
name|editline
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
name|SDELIM
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|SDELIM
operator|)
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return;
block|}
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|fcop
parameter_list|)
function_decl|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
name|editline
operator|++
expr_stmt|;
block|}
name|nextc
operator|=
name|c
expr_stmt|;
name|serror
argument_list|(
literal|"Unterminated string"
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_macro
name|editstring
argument_list|(
argument|delta
argument_list|)
end_macro

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: reads an edit script from finptr and applies it to  * file fedit; the result is written to fcopy.  * If delta!=nil, keyword expansion is performed simultaneously.  * If frewrite==true, the edit script is also copied verbatim to frewrite.  * Assumes that all these files are open.  * If running out of lines in fedit, fedit and fcopy are swapped.  * resultfile and editfile are the names of the files that go with fcopy  * and fedit, respectively.  * Assumes the next input character from finptr is the first character of  * the edit script. Resets nextc on exit.  */
end_comment

begin_block
block|{
name|int
name|ed
decl_stmt|;
comment|/* editor command */
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|FILE
modifier|*
name|fin
decl_stmt|,
modifier|*
name|frew
decl_stmt|;
specifier|register
name|int
name|write
decl_stmt|,
name|i
decl_stmt|;
name|int
name|line
decl_stmt|,
name|length
decl_stmt|;
name|fin
operator|=
name|finptr
expr_stmt|;
name|frew
operator|=
name|frewrite
expr_stmt|;
name|editline
operator|+=
name|linecorr
expr_stmt|;
name|linecorr
operator|=
literal|0
expr_stmt|;
comment|/*correct line number*/
name|write
operator|=
name|rewriteflag
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* read next command and decode */
comment|/* assume next non-white character is command name*/
while|while
condition|(
operator|(
name|ed
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
operator|)
operator|==
literal|'\n'
operator|||
name|ed
operator|==
literal|' '
operator|||
name|ed
operator|==
literal|'\t'
condition|)
empty_stmt|;
if|if
condition|(
name|ed
operator|==
name|SDELIM
condition|)
break|break;
comment|/* now attempt to read numbers. */
comment|/* fscanf causes trouble because of the required echoing */
while|while
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
operator|)
operator|==
literal|' '
condition|)
empty_stmt|;
comment|/*skip spaces*/
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"missing line number in edit script"
argument_list|)
expr_stmt|;
break|break;
block|}
name|line
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
operator|)
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|line
operator|=
name|line
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|==
literal|' '
condition|)
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
literal|'0'
operator|<=
name|c
operator|&&
name|c
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|faterror
argument_list|(
literal|"incorrect range in edit script"
argument_list|)
expr_stmt|;
break|break;
block|}
name|length
operator|=
name|c
operator|-
literal|'0'
expr_stmt|;
while|while
condition|(
literal|'0'
operator|<=
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
operator|)
operator|&&
name|c
operator|<=
literal|'9'
condition|)
block|{
name|length
operator|=
name|length
operator|*
literal|10
operator|+
name|c
operator|-
literal|'0'
expr_stmt|;
block|}
while|while
condition|(
name|c
operator|!=
literal|'\n'
operator|&&
name|c
operator|!=
name|EOF
condition|)
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
expr_stmt|;
comment|/* skip to end of line */
switch|switch
condition|(
name|ed
condition|)
block|{
case|case
literal|'d'
case|:
name|copylines
argument_list|(
name|line
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/* skip over unwanted lines */
for|for
control|(
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/*skip next line*/
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fedit
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
name|faterror
argument_list|(
literal|"EOF during edit"
argument_list|)
expr_stmt|;
name|editline
operator|++
expr_stmt|;
block|}
name|linecorr
operator|-=
name|length
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|copylines
argument_list|(
name|line
operator|+
literal|1
argument_list|,
name|delta
argument_list|)
expr_stmt|;
comment|/*copy only; no delete*/
for|for
control|(
name|i
operator|=
name|length
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
comment|/*copy next line from script*/
if|if
condition|(
name|delta
operator|!=
name|nil
condition|)
name|VOID
name|expandline
parameter_list|(
name|fin
parameter_list|,
name|fcopy
parameter_list|,
name|delta
parameter_list|,
name|true
parameter_list|,
name|write
parameter_list|)
function_decl|;
else|else
block|{
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
expr_stmt|;
while|while
condition|(
name|putc
argument_list|(
name|c
argument_list|,
name|fcopy
argument_list|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
name|SDELIM
operator|)
operator|&&
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
operator|)
operator|!=
name|SDELIM
operator|)
condition|)
block|{
name|serror
argument_list|(
literal|"Missing string delimiter in edit script"
argument_list|)
expr_stmt|;
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|fcopy
parameter_list|)
function_decl|;
block|}
name|c
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|linecorr
operator|+=
name|length
expr_stmt|;
break|break;
default|default:
name|faterror
argument_list|(
literal|"unknown command in edit script: %c"
argument_list|,
name|ed
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|nextc
operator|=
name|GETC
argument_list|(
name|fin
argument_list|,
name|frew
argument_list|,
name|write
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* The rest is for keyword expansion */
end_comment

begin_expr_stmt
name|expandline
argument_list|(
name|in
argument_list|,
name|out
argument_list|,
name|delta
argument_list|,
name|delimstuffed
argument_list|,
name|write
argument_list|)
specifier|register
name|FILE
operator|*
name|in
operator|,
operator|*
name|out
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|delimstuffed
decl_stmt|,
name|write
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Reads a line from in and writes it to out.  * If delimstuffed==true, double SDELIM is replaced with single SDELIM.  * Keyword expansion is performed with data from delta.  * If write==true, the string is also copied unchanged to frewrite.  * Returns false if end-of-string or end-of-line is detected, true otherwise.  */
end_comment

begin_block
block|{
specifier|register
name|c
expr_stmt|;
specifier|register
name|FILE
modifier|*
name|frew
decl_stmt|;
specifier|register
name|w
operator|,
name|ds
expr_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|;
name|char
name|keystring
index|[
name|keylength
operator|+
literal|2
index|]
decl_stmt|;
name|char
name|keyval
index|[
name|keyvallength
operator|+
literal|2
index|]
decl_stmt|;
name|enum
name|markers
name|matchresult
decl_stmt|;
name|frew
operator|=
name|frewrite
expr_stmt|;
name|w
operator|=
name|write
expr_stmt|;
name|ds
operator|=
name|delimstuffed
expr_stmt|;
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frew
argument_list|,
name|w
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|ds
condition|)
block|{
name|error
argument_list|(
literal|"unterminated string"
argument_list|)
expr_stmt|;
name|nextc
operator|=
name|c
expr_stmt|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|ds
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frew
argument_list|,
name|w
argument_list|)
operator|)
operator|!=
name|SDELIM
condition|)
block|{
comment|/* end of string */
name|nextc
operator|=
name|c
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|out
parameter_list|)
function_decl|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
return|return
name|true
return|;
comment|/* end of line */
if|if
condition|(
name|c
operator|==
name|KDELIM
condition|)
block|{
comment|/* check for keyword */
comment|/* first, copy a long enough string into keystring */
name|tp
operator|=
name|keystring
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frew
argument_list|,
name|w
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|tp
operator|<
name|keystring
operator|+
name|keylength
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|SDELIM
operator|)
operator|&&
operator|(
name|c
operator|!=
name|KDELIM
operator|)
operator|&&
operator|(
name|c
operator|!=
name|VDELIM
operator|)
condition|)
block|{
name|VOID
name|putc
parameter_list|(
name|c
parameter_list|,
name|out
parameter_list|)
function_decl|;
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|matchresult
operator|=
name|trymatch
argument_list|(
name|keystring
argument_list|,
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|matchresult
operator|==
name|Nomatch
condition|)
continue|continue;
comment|/* last c will be dealt with properly by continue*/
comment|/* Now we have a keyword terminated with a K/VDELIM */
if|if
condition|(
name|c
operator|==
name|VDELIM
condition|)
block|{
comment|/* try to find closing KDELIM, and replace value */
name|tp
operator|=
name|keyval
expr_stmt|;
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frew
argument_list|,
name|w
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
operator|&&
operator|(
name|c
operator|!=
literal|'\n'
operator|)
operator|&&
operator|(
name|c
operator|!=
name|KDELIM
operator|)
operator|&&
operator|(
name|tp
operator|<
name|keyval
operator|+
name|keyvallength
operator|)
condition|)
block|{
operator|*
name|tp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SDELIM
operator|&&
name|ds
condition|)
block|{
comment|/*skip next SDELIM */
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frew
argument_list|,
name|w
argument_list|)
expr_stmt|;
comment|/* Can't be at end of string. 						/* always a \n before closing SDELIM */
block|}
block|}
if|if
condition|(
name|c
operator|!=
name|KDELIM
condition|)
block|{
comment|/* couldn't find closing KDELIM -- give up */
name|VOID
name|putc
parameter_list|(
name|VDELIM
parameter_list|,
name|out
parameter_list|)
function_decl|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
name|VOID
name|fputs
parameter_list|(
name|keyval
parameter_list|,
name|out
parameter_list|)
function_decl|;
continue|continue;
comment|/* last c handled properly */
block|}
block|}
comment|/* now put out the new keyword value */
name|keyreplace
argument_list|(
name|matchresult
argument_list|,
name|delta
argument_list|,
name|out
argument_list|)
expr_stmt|;
block|}
name|c
operator|=
name|GETC
argument_list|(
name|in
argument_list|,
name|frew
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
comment|/* end for */
block|}
end_block

begin_expr_stmt
name|keyreplace
argument_list|(
name|marker
argument_list|,
name|delta
argument_list|,
name|out
argument_list|)
expr|enum
name|markers
name|marker
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|struct
name|hshentry
modifier|*
name|delta
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* function: ouputs the keyword value(s) corresponding to marker.  * Attributes are derived from delta.  */
end_comment

begin_block
block|{
name|char
modifier|*
name|date
decl_stmt|;
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
name|date
operator|=
name|delta
operator|->
name|date
expr_stmt|;
switch|switch
condition|(
name|marker
condition|)
block|{
case|case
name|Author
case|:
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|KDELIM
argument_list|)
decl_stmt|;
break|break;
case|case
name|Date
case|:
name|VOID
name|putc
parameter_list|(
name|VDELIM
parameter_list|,
name|out
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|VOID
name|PRINTDATE
parameter_list|(
name|out
parameter_list|,
name|date
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|VOID
name|PRINTTIME
parameter_list|(
name|out
parameter_list|,
name|date
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|VOID
name|putc
parameter_list|(
name|KDELIM
parameter_list|,
name|out
parameter_list|)
function_decl|;
break|break;
case|case
name|Id
case|:
case|case
name|Header
case|:
name|VOID
name|putc
parameter_list|(
name|VDELIM
parameter_list|,
name|out
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
decl_stmt|;
if|if
condition|(
name|marker
operator|==
name|Id
condition|)
name|VOID
name|fputs
argument_list|(
name|bindex
argument_list|(
name|RCSfilename
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|out
argument_list|)
decl_stmt|;
else|else
name|VOID
name|fputs
argument_list|(
name|getfullRCSname
argument_list|()
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s "
argument_list|,
name|delta
operator|->
name|num
argument_list|)
decl_stmt|;
name|VOID
name|PRINTDATE
parameter_list|(
name|out
parameter_list|,
name|date
parameter_list|)
function_decl|;
name|VOID
name|putc
argument_list|(
literal|' '
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|VOID
name|PRINTTIME
parameter_list|(
name|out
parameter_list|,
name|date
parameter_list|)
function_decl|;
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|" %s %s "
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|delta
operator|->
name|state
argument_list|)
decl_stmt|;
if|if
condition|(
name|delta
operator|->
name|lockedby
operator|!=
name|nil
condition|)
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"Locker: %s "
argument_list|,
name|delta
operator|->
name|lockedby
argument_list|)
decl_stmt|;
name|VOID
name|putc
parameter_list|(
name|KDELIM
parameter_list|,
name|out
parameter_list|)
function_decl|;
break|break;
case|case
name|Locker
case|:
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|lockedby
operator|==
name|nil
condition|?
literal|""
else|:
name|delta
operator|->
name|lockedby
argument_list|,
name|KDELIM
argument_list|)
decl_stmt|;
break|break;
case|case
name|Log
case|:
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c\t%s %c\n%sRevision %s  "
argument_list|,
name|VDELIM
argument_list|,
name|bindex
argument_list|(
name|RCSfilename
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|KDELIM
argument_list|,
name|Comment
argument_list|,
name|delta
operator|->
name|num
argument_list|)
decl_stmt|;
name|VOID
name|PRINTDATE
parameter_list|(
name|out
parameter_list|,
name|date
parameter_list|)
function_decl|;
name|VOID
name|fputs
argument_list|(
literal|"  "
argument_list|,
name|out
argument_list|)
decl_stmt|;
name|VOID
name|PRINTTIME
parameter_list|(
name|out
parameter_list|,
name|date
parameter_list|)
function_decl|;
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"  %s\n%s"
argument_list|,
name|delta
operator|->
name|author
argument_list|,
name|Comment
argument_list|)
decl_stmt|;
comment|/* do not include state here because it may change and is not updated*/
name|sp
operator|=
name|delta
operator|->
name|log
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
if|if
condition|(
name|putc
argument_list|(
operator|*
name|sp
operator|++
argument_list|,
name|out
argument_list|)
operator|==
literal|'\n'
condition|)
name|VOID
name|fputs
parameter_list|(
name|Comment
parameter_list|,
name|out
parameter_list|)
function_decl|;
comment|/* Comment is the comment leader */
break|break;
case|case
name|RCSfile
case|:
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|bindex
argument_list|(
name|RCSfilename
argument_list|,
literal|'/'
argument_list|)
argument_list|,
name|KDELIM
argument_list|)
decl_stmt|;
break|break;
case|case
name|Revision
case|:
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|num
argument_list|,
name|KDELIM
argument_list|)
decl_stmt|;
break|break;
case|case
name|Source
case|:
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|getfullRCSname
argument_list|()
argument_list|,
name|KDELIM
argument_list|)
decl_stmt|;
break|break;
case|case
name|State
case|:
name|VOID
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"%c %s %c"
argument_list|,
name|VDELIM
argument_list|,
name|delta
operator|->
name|state
argument_list|,
name|KDELIM
argument_list|)
decl_stmt|;
break|break;
case|case
name|Nomatch
case|:
name|VOID
name|putc
parameter_list|(
name|KDELIM
parameter_list|,
name|out
parameter_list|)
function_decl|;
break|break;
block|}
block|}
end_block

end_unit

