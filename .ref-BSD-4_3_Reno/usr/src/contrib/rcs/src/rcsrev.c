begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  *                     RCS revision number handling  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: rcsrev.c,v 4.5 89/05/01 15:13:22 narten Exp $ Purdue CS"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Copyright (C) 1982, 1988, 1989 Walter Tichy  * All rights reserved.  *  * Redistribution and use in source and binary forms are permitted  * provided that the above copyright notice and this paragraph are  * duplicated in all such forms and that any documentation,  * advertising materials, and other materials related to such  * distribution and use acknowledge that the software was developed  * by Walter Tichy.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR  * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  *  * Report all problems and direct all questions to:  *   rcs-bugs@cs.purdue.edu  *         */
end_comment

begin_comment
comment|/* $Log:	rcsrev.c,v $  * Revision 4.5  89/05/01  15:13:22  narten  * changed copyright header to reflect current distribution rules  *   * Revision 4.4  87/12/18  11:45:22  narten  * more lint cleanups. Also, the NOTREACHED comment is no longer necessary,   * since there's now a return value there with a value. (Guy Harris)  *   * Revision 4.3  87/10/18  10:38:42  narten  * Updating version numbers. Changes relative to version 1.1 actually   * relative to 4.1  *   * Revision 1.3  87/09/24  14:00:37  narten  * Sources now pass through lint (if you ignore printf/sprintf/fprintf   * warnings)  *   * Revision 1.2  87/03/27  14:22:37  jenkins  * Port to suns  *   * Revision 1.1  84/01/23  14:50:37  kcs  * Initial revision  *   * Revision 4.1  83/03/25  21:10:45  wft  * Only changed $Header to $Id.  *   * Revision 3.4  82/12/04  13:24:08  wft  * Replaced getdelta() with gettree().  *  * Revision 3.3  82/11/28  21:33:15  wft  * fixed compartial() and compnum() for nil-parameters; fixed nils  * in error messages. Testprogram output shortenend.  *  * Revision 3.2  82/10/18  21:19:47  wft  * renamed compnum->cmpnum, compnumfld->cmpnumfld,  * numericrevno->numricrevno.  *  * Revision 3.1  82/10/11  19:46:09  wft  * changed expandsym() to check for source==nil; returns zero length string  * in that case.  */
end_comment

begin_comment
comment|/* #define REVTEST /* version REVTEST is for testing the routines that generate a sequence  * of delta numbers needed to regenerate a given delta.  */
end_comment

begin_include
include|#
directive|include
file|"rcsbase.h"
end_include

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|finptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* RCS input file */
end_comment

begin_function_decl
specifier|extern
name|char
modifier|*
name|getid
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|struct
name|hshentry
modifier|*
name|getnum
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|getkey
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|int
name|getlex
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|extern
name|char
modifier|*
name|getkeyval
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
name|struct
name|hshentry
modifier|*
name|genbranch
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* forward */
end_comment

begin_function
name|int
name|countnumflds
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
comment|/* Given a pointer s to a dotted number (date or revision number),  * countnumflds returns the number of digitfields in s.  */
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|;
specifier|register
name|int
name|count
decl_stmt|;
if|if
condition|(
operator|(
name|sp
operator|=
name|s
operator|)
operator|==
name|nil
condition|)
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|count
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|sp
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|++
operator|==
literal|'.'
condition|)
name|count
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
operator|(
operator|--
name|sp
operator|)
operator|==
literal|'.'
condition|)
name|count
operator|--
expr_stmt|;
comment|/*trailing periods don't count*/
return|return
operator|(
name|count
operator|)
return|;
block|}
end_function

begin_macro
name|getbranchno
argument_list|(
argument|revno
argument_list|,
argument|branchno
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|revno
decl_stmt|,
modifier|*
name|branchno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a non-nil revision number revno, getbranchno copies the number of the branch  * on which revno is into branchnumber. If revno itself is a branch number,  * it is copied unchanged.  */
end_comment

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|numflds
decl_stmt|;
specifier|register
name|char
modifier|*
name|tp
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|numflds
operator|=
name|countnumflds
argument_list|(
name|revno
argument_list|)
expr_stmt|;
if|if
condition|(
name|numflds
operator|%
literal|2
operator|==
literal|1
condition|)
name|VOID
name|strcpy
parameter_list|(
name|branchno
parameter_list|,
name|revno
parameter_list|)
function_decl|;
else|else
block|{
name|sp
operator|=
name|revno
expr_stmt|;
name|tp
operator|=
name|branchno
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|numflds
condition|;
name|i
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'.'
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_block

begin_function
name|int
name|cmpnum
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|)
name|char
modifier|*
name|num1
decl_stmt|,
decl|*
name|num2
decl_stmt|;
end_function

begin_comment
comment|/* compares the two dotted numbers num1 and num2 lexicographically  * by field. Individual fields are compared numerically.  * returns<0, 0,>0 if num1<num2, num1==num2, and num1>num2, resp.  * omitted fields are assumed to be higher than the existing ones. */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|s1
operator|=
name|num1
operator|==
name|nil
condition|?
literal|""
else|:
name|num1
expr_stmt|;
name|s2
operator|=
name|num2
operator|==
name|nil
condition|?
literal|""
else|:
name|num2
expr_stmt|;
do|do
block|{
name|n1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
literal|'0'
operator|<=
operator|*
name|s1
operator|)
operator|&&
operator|(
operator|*
name|s1
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|n1
operator|=
name|n1
operator|*
literal|10
operator|+
operator|(
operator|*
name|s1
operator|-
literal|'0'
operator|)
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
comment|/* skip '.' */
if|if
condition|(
operator|*
name|s1
operator|==
literal|'.'
condition|)
name|s1
operator|++
expr_stmt|;
name|n2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
literal|'0'
operator|<=
operator|*
name|s2
operator|)
operator|&&
operator|(
operator|*
name|s2
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|n2
operator|=
name|n2
operator|*
literal|10
operator|+
operator|(
operator|*
name|s2
operator|-
literal|'0'
operator|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
comment|/* skip '.' */
if|if
condition|(
operator|*
name|s2
operator|==
literal|'.'
condition|)
name|s2
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|n1
operator|==
name|n2
operator|)
operator|&&
operator|(
operator|*
name|s1
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|s2
operator|!=
literal|'\0'
operator|)
condition|)
do|;
if|if
condition|(
operator|(
operator|(
operator|*
name|s1
operator|==
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|s2
operator|==
literal|'\0'
operator|)
operator|)
operator|||
operator|(
name|n1
operator|!=
name|n2
operator|)
condition|)
return|return
operator|(
name|n1
operator|-
name|n2
operator|)
return|;
comment|/*now n1==n2 and one of s1 or s2 is shorter*/
comment|/*give precedence to shorter one*/
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
else|else
return|return
operator|-
literal|1
return|;
block|}
end_block

begin_function
name|int
name|cmpnumfld
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|,
name|fld
parameter_list|)
name|char
modifier|*
name|num1
decl_stmt|,
decl|*
name|num2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|fld
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* compares the two dotted numbers at field fld and returns  * num1[fld]-num2[fld]. Assumes that num1 and num2 have at least fld fields. */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|s1
operator|=
name|num1
expr_stmt|;
name|n1
operator|=
name|fld
operator|-
literal|1
expr_stmt|;
comment|/* skip fld-1 fields */
while|while
condition|(
name|n1
condition|)
block|{
while|while
condition|(
operator|*
name|s1
operator|!=
literal|'.'
condition|)
name|s1
operator|++
expr_stmt|;
name|n1
operator|--
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
name|s2
operator|=
name|num2
expr_stmt|;
name|n2
operator|=
name|fld
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|n2
condition|)
block|{
while|while
condition|(
operator|*
name|s2
operator|!=
literal|'.'
condition|)
name|s2
operator|++
expr_stmt|;
name|n2
operator|--
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
comment|/* Don't put the above into a single loop! */
comment|/* Now s1 and s2 point to the beginning of the respective fields */
comment|/* compute numerical value and compare */
name|n1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
literal|'0'
operator|<=
operator|*
name|s1
operator|)
operator|&&
operator|(
operator|*
name|s1
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|n1
operator|=
name|n1
operator|*
literal|10
operator|+
operator|(
operator|*
name|s1
operator|-
literal|'0'
operator|)
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
name|n2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
literal|'0'
operator|<=
operator|*
name|s2
operator|)
operator|&&
operator|(
operator|*
name|s2
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|n2
operator|=
name|n2
operator|*
literal|10
operator|+
operator|(
operator|*
name|s2
operator|-
literal|'0'
operator|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|n1
operator|-
name|n2
operator|)
return|;
block|}
end_block

begin_function
name|int
name|compartial
parameter_list|(
name|num1
parameter_list|,
name|num2
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|num1
decl_stmt|;
name|char
modifier|*
name|num2
decl_stmt|;
name|int
name|length
decl_stmt|;
comment|/*   compare the first "length" fields of two dot numbers;      the omitted field is considered to be larger than any number  */
comment|/*   restriction:  at least one number has length or more fields   */
block|{
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
modifier|*
name|s2
decl_stmt|;
specifier|register
name|int
name|n1
decl_stmt|,
name|n2
decl_stmt|;
name|s1
operator|=
name|num1
expr_stmt|;
name|s2
operator|=
name|num2
expr_stmt|;
if|if
condition|(
name|s1
operator|==
name|nil
operator|||
operator|*
name|s1
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|s2
operator|==
name|nil
operator|||
operator|*
name|s2
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
do|do
block|{
name|n1
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
literal|'0'
operator|<=
operator|*
name|s1
operator|)
operator|&&
operator|(
operator|*
name|s1
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|n1
operator|=
name|n1
operator|*
literal|10
operator|+
operator|(
operator|*
name|s1
operator|-
literal|'0'
operator|)
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s1
operator|==
literal|'.'
condition|)
name|s1
operator|++
expr_stmt|;
comment|/*  skip .   */
name|n2
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
literal|'0'
operator|<=
operator|*
name|s2
operator|)
operator|&&
operator|(
operator|*
name|s2
operator|<=
literal|'9'
operator|)
condition|)
block|{
name|n2
operator|=
name|n2
operator|*
literal|10
operator|+
operator|(
operator|*
name|s2
operator|-
literal|'0'
operator|)
expr_stmt|;
name|s2
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|s2
operator|==
literal|'.'
condition|)
name|s2
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|n1
operator|==
name|n2
operator|)
operator|&&
operator|(
operator|(
operator|--
name|length
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|s1
operator|!=
literal|'\0'
operator|)
operator|&&
operator|(
operator|*
name|s2
operator|!=
literal|'\0'
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|n1
operator|!=
name|n2
operator|)
operator|||
operator|(
name|length
operator|==
literal|0
operator|)
condition|)
block|{
return|return
operator|(
name|n1
operator|-
name|n2
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\0'
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|s2
operator|==
literal|'\0'
condition|)
return|return
operator|-
literal|1
return|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"RCS Internal error, routine: compartial\n"
argument_list|)
decl_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_macro
name|incnum
argument_list|(
argument|onum
argument_list|,
argument|nnum
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|onum
decl_stmt|,
modifier|*
name|nnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* increments the last field of revision number onum by one and  * places the result into nnum  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|sp
operator|=
name|onum
expr_stmt|;
name|tp
operator|=
name|nnum
expr_stmt|;
for|for
control|(
name|i
operator|=
name|countnumflds
argument_list|(
name|onum
argument_list|)
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'.'
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
comment|/* copy dot also */
block|}
name|VOID
name|sprintf
argument_list|(
name|tp
argument_list|,
literal|"%d"
argument_list|,
name|atoi
argument_list|(
name|sp
argument_list|)
operator|+
literal|1
argument_list|)
decl_stmt|;
block|}
end_block

begin_function
name|char
modifier|*
name|partialno
parameter_list|(
name|rev1
parameter_list|,
name|rev2
parameter_list|,
name|length
parameter_list|)
name|char
modifier|*
name|rev1
decl_stmt|,
decl|*
name|rev2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|length
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: Copies length fields of revision number rev2 into rev1.  * returns rev1.  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|r1
decl_stmt|,
modifier|*
name|r2
decl_stmt|;
name|r1
operator|=
name|rev1
expr_stmt|;
name|r2
operator|=
name|rev2
expr_stmt|;
while|while
condition|(
name|length
condition|)
block|{
while|while
condition|(
operator|*
name|r2
operator|!=
literal|'.'
operator|&&
operator|*
name|r2
operator|!=
literal|'\0'
condition|)
operator|*
name|r1
operator|++
operator|=
operator|*
name|r2
operator|++
expr_stmt|;
operator|*
name|r1
operator|++
operator|=
operator|*
name|r2
operator|++
expr_stmt|;
name|length
operator|--
expr_stmt|;
block|}
comment|/* eliminate last '.'*/
operator|*
operator|(
name|r1
operator|-
literal|1
operator|)
operator|=
literal|'\0'
expr_stmt|;
return|return
name|rev1
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|getancestor
parameter_list|(
name|r1
parameter_list|,
name|r2
parameter_list|,
name|r3
parameter_list|)
name|char
modifier|*
name|r1
decl_stmt|,
decl|*
name|r2
decl_stmt|,
modifier|*
name|r3
decl_stmt|;
end_function

begin_comment
comment|/* function: finds the common ancestor of r1 and r2 and  * places it into r3.  * returns r3 if successful, false otherwise.  * works reliably only if r1 and r2 are not branch numbers.  */
end_comment

begin_block
block|{
name|int
name|l1
decl_stmt|,
name|l2
decl_stmt|,
name|l3
decl_stmt|;
name|char
name|t1
index|[
name|revlength
index|]
decl_stmt|,
name|t2
index|[
name|revlength
index|]
decl_stmt|;
name|l1
operator|=
name|countnumflds
argument_list|(
name|r1
argument_list|)
expr_stmt|;
name|l2
operator|=
name|countnumflds
argument_list|(
name|r2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|l1
operator|<=
literal|2
operator|&&
name|l2
operator|<=
literal|2
operator|)
operator|||
operator|(
name|cmpnum
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* on main trunk or identical */
name|error
argument_list|(
literal|"Common ancestor of %s and %s undefined."
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|l3
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|l3
operator|=
name|l3
operator|+
literal|2
expr_stmt|;
block|}
comment|/* This will terminate since r1 and r2 are not the same; see above*/
if|if
condition|(
name|l3
operator|==
literal|0
condition|)
block|{
comment|/* no common prefix. Common ancestor on main trunk. */
name|VOID
name|partialno
argument_list|(
name|t1
argument_list|,
name|r1
argument_list|,
name|l1
operator|>
literal|2
condition|?
literal|2
else|:
name|l1
argument_list|)
decl_stmt|;
name|VOID
name|partialno
argument_list|(
name|t2
argument_list|,
name|r2
argument_list|,
name|l2
operator|>
literal|2
condition|?
literal|2
else|:
name|l2
argument_list|)
decl_stmt|;
if|if
condition|(
name|cmpnum
argument_list|(
name|t1
argument_list|,
name|t2
argument_list|)
operator|<
literal|0
condition|)
name|VOID
name|strcpy
parameter_list|(
name|r3
parameter_list|,
name|t1
parameter_list|)
function_decl|;
else|else
name|VOID
name|strcpy
parameter_list|(
name|r3
parameter_list|,
name|t2
parameter_list|)
function_decl|;
if|if
condition|(
operator|(
name|cmpnum
argument_list|(
name|r3
argument_list|,
name|r1
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|cmpnum
argument_list|(
name|r3
argument_list|,
name|r2
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Ancestor for %s and %s undefined."
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
name|r3
return|;
block|}
else|else
block|{
if|if
condition|(
name|cmpnumfld
argument_list|(
name|r1
argument_list|,
name|r2
argument_list|,
name|l3
operator|+
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Ancestor for %s and %s undefined."
argument_list|,
name|r1
argument_list|,
name|r2
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
return|return
operator|(
name|partialno
argument_list|(
name|r3
argument_list|,
name|r1
argument_list|,
name|l3
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_function
name|struct
name|hshentry
modifier|*
name|genrevs
parameter_list|(
name|revno
parameter_list|,
name|date
parameter_list|,
name|author
parameter_list|,
name|state
parameter_list|,
name|store
parameter_list|)
name|char
modifier|*
name|revno
decl_stmt|,
decl|*
name|date
decl_stmt|,
modifier|*
name|author
decl_stmt|,
modifier|*
name|state
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentry
modifier|*
modifier|*
name|store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: finds the deltas needed for reconstructing the  * revision given by revno, date, author, and state, and stores pointers  * to these deltas into an array whose starting address is given by store.  * The last pointer stored is nil. The last delta (target delta) is returned.  * If the proper delta could not be found, nil is returned.  */
end_comment

begin_block
block|{
name|int
name|length
decl_stmt|;
specifier|register
name|struct
name|hshentry
modifier|*
name|next
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
modifier|*
name|branchnum
decl_stmt|;
name|char
name|t
index|[
name|revlength
index|]
decl_stmt|;
if|if
condition|(
name|Head
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"RCSfile empty."
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
name|length
operator|=
name|countnumflds
argument_list|(
name|revno
argument_list|)
expr_stmt|;
name|next
operator|=
name|Head
expr_stmt|;
if|if
condition|(
name|length
operator|>=
literal|1
condition|)
block|{
comment|/* at least one field; find branch exactly */
while|while
condition|(
operator|(
name|next
operator|!=
name|nil
operator|)
operator|&&
operator|(
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|)
operator|<
literal|0
operator|)
condition|)
block|{
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|next
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"Branch number %s too low."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
name|result
operator|>
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Branch number %s not present."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
block|}
if|if
condition|(
name|length
operator|<=
literal|1
condition|)
block|{
comment|/* pick latest one on given branch */
name|branchnum
operator|=
name|next
operator|->
name|num
expr_stmt|;
comment|/* works even for empty revno*/
while|while
condition|(
operator|(
name|next
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|cmpnumfld
argument_list|(
name|branchnum
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|!
operator|(
operator|(
name|date
operator|==
name|nil
condition|?
literal|1
else|:
operator|(
name|cmpnum
argument_list|(
name|date
argument_list|,
name|next
operator|->
name|date
argument_list|)
operator|>=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|author
operator|==
name|nil
condition|?
literal|1
else|:
operator|(
name|strcmp
argument_list|(
name|author
argument_list|,
name|next
operator|->
name|author
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|state
operator|==
name|nil
condition|?
literal|1
else|:
operator|(
name|strcmp
argument_list|(
name|state
argument_list|,
name|next
operator|->
name|state
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|)
condition|)
block|{
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|next
operator|==
name|nil
operator|)
operator|||
operator|(
name|cmpnumfld
argument_list|(
name|branchnum
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
comment|/*overshot*/
block|{
name|error
argument_list|(
literal|"Cannot find revision on branch %s with a date before %s, author %s, and state %s."
argument_list|,
name|length
operator|==
literal|0
condition|?
name|partialno
argument_list|(
name|t
argument_list|,
name|branchnum
argument_list|,
literal|1
argument_list|)
else|:
name|revno
argument_list|,
name|date
operator|==
name|nil
condition|?
literal|"<now>"
else|:
name|date
argument_list|,
name|author
operator|==
name|nil
condition|?
literal|"<any>"
else|:
name|author
argument_list|,
name|state
operator|==
name|nil
condition|?
literal|"<any>"
else|:
name|state
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
else|else
block|{
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|store
operator|=
name|nil
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/* length>=2 */
comment|/* find revision; may go low if length==2*/
while|while
condition|(
operator|(
name|next
operator|!=
name|nil
operator|)
operator|&&
operator|(
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|2
argument_list|)
operator|)
operator|<
literal|0
operator|)
operator|&&
operator|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|next
operator|==
name|nil
operator|)
operator|||
operator|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision number %s too low."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
operator|(
name|length
operator|>
literal|2
operator|)
operator|&&
operator|(
name|result
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s not present."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
literal|2
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
comment|/* print last one */
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
if|if
condition|(
name|length
operator|>
literal|2
condition|)
return|return
name|genbranch
argument_list|(
name|next
argument_list|,
name|revno
argument_list|,
name|length
argument_list|,
name|date
argument_list|,
name|author
argument_list|,
name|state
argument_list|,
name|store
argument_list|)
return|;
else|else
block|{
comment|/* length == 2*/
if|if
condition|(
operator|(
name|date
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|cmpnum
argument_list|(
name|date
argument_list|,
name|next
operator|->
name|date
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s has date %s."
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|next
operator|->
name|date
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
operator|(
name|author
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|author
argument_list|,
name|next
operator|->
name|author
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s has author %s."
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|next
operator|->
name|author
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
operator|(
name|state
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|state
argument_list|,
name|next
operator|->
name|state
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s has state %s."
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|next
operator|->
name|state
operator|==
name|nil
condition|?
literal|"<empty>"
else|:
name|next
operator|->
name|state
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
operator|*
name|store
operator|=
name|nil
expr_stmt|;
return|return
name|next
return|;
block|}
block|}
end_block

begin_function
name|struct
name|hshentry
modifier|*
name|genbranch
parameter_list|(
name|bpoint
parameter_list|,
name|revno
parameter_list|,
name|length
parameter_list|,
name|date
parameter_list|,
name|author
parameter_list|,
name|state
parameter_list|,
name|store
parameter_list|)
name|struct
name|hshentry
modifier|*
name|bpoint
decl_stmt|;
name|char
modifier|*
name|revno
decl_stmt|;
name|int
name|length
decl_stmt|;
name|char
modifier|*
name|date
decl_stmt|,
decl|*
name|author
decl_stmt|,
modifier|*
name|state
decl_stmt|;
end_function

begin_decl_stmt
name|struct
name|hshentry
modifier|*
modifier|*
name|store
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Function: given a branchpoint, a revision number, date, author, and state,  * genbranch finds the deltas necessary to reconstruct the given revision  * from the branch point on.  * Pointers to the found deltas are stored in an array beginning with store.  * revno must be on a side branch.  * return nil on error  */
end_comment

begin_block
block|{
name|int
name|field
decl_stmt|;
specifier|register
name|struct
name|hshentry
modifier|*
name|next
decl_stmt|,
modifier|*
name|trail
decl_stmt|;
specifier|register
name|struct
name|branchhead
modifier|*
name|bhead
decl_stmt|;
name|int
name|result
decl_stmt|;
name|char
name|t
index|[
name|revlength
index|]
decl_stmt|;
name|bhead
operator|=
name|bpoint
operator|->
name|branches
expr_stmt|;
for|for
control|(
name|field
operator|=
literal|3
init|;
name|field
operator|<=
name|length
condition|;
name|field
operator|=
name|field
operator|+
literal|2
control|)
block|{
if|if
condition|(
name|bhead
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"No side branches present for %s."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
name|field
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
comment|/*find branch head*/
comment|/*branches are arranged in increasing order*/
while|while
condition|(
operator|(
name|bhead
operator|!=
name|nil
operator|)
operator|&&
operator|(
operator|(
name|result
operator|=
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|bhead
operator|->
name|hsh
operator|->
name|num
argument_list|,
name|field
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|bhead
operator|=
name|bhead
operator|->
name|nextbranch
expr_stmt|;
block|}
if|if
condition|(
name|bhead
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"Branch number %s too high."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Branch number %s not present."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
name|field
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
name|next
operator|=
name|bhead
operator|->
name|hsh
expr_stmt|;
if|if
condition|(
name|length
operator|==
name|field
condition|)
block|{
comment|/* pick latest one on that branch */
name|trail
operator|=
name|nil
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|(
name|date
operator|==
name|nil
condition|?
literal|1
else|:
operator|(
name|cmpnum
argument_list|(
name|date
argument_list|,
name|next
operator|->
name|date
argument_list|)
operator|>=
literal|0
operator|)
operator|)
operator|&&
operator|(
name|author
operator|==
name|nil
condition|?
literal|1
else|:
operator|(
name|strcmp
argument_list|(
name|author
argument_list|,
name|next
operator|->
name|author
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
name|state
operator|==
name|nil
condition|?
literal|1
else|:
operator|(
name|strcmp
argument_list|(
name|state
argument_list|,
name|next
operator|->
name|state
argument_list|)
operator|==
literal|0
operator|)
operator|)
condition|)
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|next
operator|!=
name|nil
condition|)
do|;
if|if
condition|(
name|trail
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"Cannot find revision on branch %s with a date before %s, author %s, and state %s."
argument_list|,
name|revno
argument_list|,
name|date
operator|==
name|nil
condition|?
literal|"<now>"
else|:
name|date
argument_list|,
name|author
operator|==
name|nil
condition|?
literal|"<any>"
else|:
name|author
argument_list|,
name|state
operator|==
name|nil
condition|?
literal|"<any>"
else|:
name|state
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
else|else
block|{
comment|/* print up to last one suitable */
name|next
operator|=
name|bhead
operator|->
name|hsh
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|trail
condition|)
block|{
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
block|}
operator|*
name|store
operator|=
name|nil
expr_stmt|;
return|return
name|next
return|;
block|}
comment|/* length> field */
comment|/* find revision */
comment|/* check low */
if|if
condition|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|field
operator|+
literal|1
argument_list|)
operator|<
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"Revision number %s too low."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
name|field
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
do|do
block|{
comment|/*puts(next->num);*/
operator|*
name|store
operator|++
operator|=
name|next
expr_stmt|;
name|trail
operator|=
name|next
expr_stmt|;
name|next
operator|=
name|next
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
operator|(
name|next
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|next
operator|->
name|num
argument_list|,
name|field
operator|+
literal|1
argument_list|)
operator|>=
literal|0
operator|)
condition|)
do|;
if|if
condition|(
operator|(
name|length
operator|>
name|field
operator|+
literal|1
operator|)
operator|&&
comment|/*need exact hit */
operator|(
name|cmpnumfld
argument_list|(
name|revno
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|field
operator|+
literal|1
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s not present."
argument_list|,
name|partialno
argument_list|(
name|t
argument_list|,
name|revno
argument_list|,
name|field
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|nil
operator|)
return|;
block|}
if|if
condition|(
name|length
operator|==
name|field
operator|+
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|date
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|cmpnum
argument_list|(
name|date
argument_list|,
name|trail
operator|->
name|date
argument_list|)
operator|<
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s has date %s."
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|trail
operator|->
name|date
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
operator|(
name|author
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|author
argument_list|,
name|trail
operator|->
name|author
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s has author %s."
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|trail
operator|->
name|author
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
if|if
condition|(
operator|(
name|state
operator|!=
name|nil
operator|)
operator|&&
operator|(
name|strcmp
argument_list|(
name|state
argument_list|,
name|trail
operator|->
name|state
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|error
argument_list|(
literal|"Revision %s has state %s."
argument_list|,
name|trail
operator|->
name|num
argument_list|,
name|trail
operator|->
name|state
operator|==
name|nil
condition|?
literal|"<empty>"
else|:
name|trail
operator|->
name|state
argument_list|)
expr_stmt|;
return|return
name|nil
return|;
block|}
block|}
name|bhead
operator|=
name|trail
operator|->
name|branches
expr_stmt|;
block|}
operator|*
name|store
operator|=
name|nil
expr_stmt|;
return|return
name|trail
return|;
block|}
end_block

begin_function
name|char
modifier|*
name|lookupsym
parameter_list|(
name|id
parameter_list|)
name|char
modifier|*
name|id
decl_stmt|;
comment|/* Function: looks up id in the list of symbolic names starting  * with pointer SYMBOLS, and returns a pointer to the corresponding  * revision number. Returns nil if not present.  */
block|{
specifier|register
name|struct
name|assoc
modifier|*
name|next
decl_stmt|;
name|next
operator|=
name|Symbols
expr_stmt|;
while|while
condition|(
name|next
operator|!=
name|nil
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|id
argument_list|,
name|next
operator|->
name|symbol
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|next
operator|->
name|delta
operator|->
name|num
operator|)
return|;
else|else
name|next
operator|=
name|next
operator|->
name|nextassoc
expr_stmt|;
block|}
return|return
name|nil
return|;
block|}
end_function

begin_function
name|int
name|expandsym
parameter_list|(
name|source
parameter_list|,
name|target
parameter_list|)
name|char
modifier|*
name|source
decl_stmt|,
decl|*
name|target
decl_stmt|;
end_function

begin_comment
comment|/* Function: Source points to a revision number. Expandsym copies  * the number to target, but replaces all symbolic fields in the  * source number with their numeric values.  * A trailing '.' is omitted; leading zeroes are compressed.  * returns false on error;  */
end_comment

begin_block
block|{
specifier|register
name|char
modifier|*
name|sp
decl_stmt|,
modifier|*
name|tp
decl_stmt|,
modifier|*
name|bp
decl_stmt|;
name|char
name|symbuf
index|[
literal|30
index|]
decl_stmt|;
specifier|register
name|enum
name|tokens
name|d
decl_stmt|;
name|sp
operator|=
name|source
expr_stmt|;
name|tp
operator|=
name|target
expr_stmt|;
if|if
condition|(
name|sp
operator|==
name|nil
condition|)
block|{
comment|/*accept nil pointer as a legal value*/
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|true
return|;
block|}
while|while
condition|(
operator|*
name|sp
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|ctab
index|[
operator|*
name|sp
index|]
operator|==
name|DIGIT
condition|)
block|{
if|if
condition|(
operator|*
name|sp
operator|==
literal|'0'
condition|)
block|{
comment|/* skip leading zeroes */
name|sp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|sp
operator|==
literal|'0'
condition|)
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'\0'
operator|||
operator|*
name|sp
operator|==
literal|'.'
condition|)
operator|*
name|tp
operator|++
operator|=
literal|'0'
expr_stmt|;
comment|/*single zero*/
block|}
while|while
condition|(
name|ctab
index|[
operator|*
name|sp
index|]
operator|==
name|DIGIT
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|sp
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
operator|*
name|sp
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|==
literal|'\0'
operator|)
operator|)
condition|)
block|{
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|true
return|;
block|}
if|if
condition|(
operator|*
name|sp
operator|==
literal|'.'
condition|)
operator|*
name|tp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
else|else
block|{
name|error
argument_list|(
literal|"Improper revision number: %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
name|elsif
argument_list|(
argument|ctab[*sp] == LETTER
argument_list|)
block|{
name|bp
operator|=
name|symbuf
expr_stmt|;
do|do
block|{
operator|*
name|bp
operator|++
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|(
operator|(
name|d
operator|=
name|ctab
index|[
operator|*
name|sp
index|]
operator|)
operator|==
name|LETTER
operator|)
operator|||
operator|(
name|d
operator|==
name|DIGIT
operator|)
operator|||
operator|(
name|d
operator|==
name|IDCHAR
operator|)
condition|)
do|;
operator|*
name|bp
operator|=
literal|'\0'
expr_stmt|;
name|bp
operator|=
name|lookupsym
argument_list|(
name|symbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|nil
condition|)
block|{
name|error
argument_list|(
literal|"Symbolic number %s is undefined."
argument_list|,
name|symbuf
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|false
return|;
block|}
else|else
block|{
comment|/* copy number */
while|while
condition|(
operator|*
name|tp
operator|++
operator|=
operator|*
name|bp
operator|++
condition|)
empty_stmt|;
comment|/* copies the trailing \0*/
block|}
if|if
condition|(
operator|(
operator|*
name|sp
operator|==
literal|'\0'
operator|)
operator|||
operator|(
operator|(
operator|*
name|sp
operator|==
literal|'.'
operator|)
operator|&&
operator|(
operator|*
operator|(
name|sp
operator|+
literal|1
operator|)
operator|==
literal|'\0'
operator|)
operator|)
condition|)
return|return
name|true
return|;
if|if
condition|(
operator|*
name|sp
operator|==
literal|'.'
condition|)
block|{
operator|*
operator|(
name|tp
operator|-
literal|1
operator|)
operator|=
operator|*
name|sp
operator|++
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"Improper revision number: %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
else|else
block|{
name|error
argument_list|(
literal|"Improper revision number: %s"
argument_list|,
name|source
argument_list|)
expr_stmt|;
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|false
return|;
block|}
block|}
operator|*
name|tp
operator|=
literal|'\0'
expr_stmt|;
return|return
name|true
return|;
block|}
end_block

begin_ifdef
ifdef|#
directive|ifdef
name|REVTEST
end_ifdef

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
name|symrevno
index|[
name|revlength
index|]
decl_stmt|;
comment|/* used for input of revision numbers */
name|char
name|numricrevno
index|[
name|revlength
index|]
decl_stmt|;
name|char
name|author
index|[
literal|20
index|]
decl_stmt|;
name|char
name|state
index|[
literal|20
index|]
decl_stmt|;
name|char
name|date
index|[
literal|20
index|]
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|gendeltas
index|[
name|hshsize
operator|/
literal|2
index|]
decl_stmt|;
name|struct
name|hshentry
modifier|*
name|target
decl_stmt|;
name|int
name|i
decl_stmt|;
name|cmdid
operator|=
literal|"revtest"
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|VOID
name|fputs
argument_list|(
literal|"No input file\n"
argument_list|,
name|stderr
argument_list|)
decl_stmt|;
name|exit
argument_list|(
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|finptr
operator|=
name|fopen
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|faterror
argument_list|(
literal|"Can't open input file %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
name|Lexinit
argument_list|()
expr_stmt|;
name|getadmin
argument_list|()
expr_stmt|;
name|gettree
argument_list|()
expr_stmt|;
name|getdesc
argument_list|(
name|false
argument_list|)
expr_stmt|;
do|do
block|{
comment|/* all output goes to stderr, to have diagnostics and       */
comment|/* errors in sequence.                                      */
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nEnter revision number or<return> or '.': "
argument_list|)
decl_stmt|;
if|if
condition|(
name|gets
argument_list|(
name|symrevno
argument_list|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
operator|*
name|symrevno
operator|==
literal|'.'
condition|)
break|break;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s;\n"
argument_list|,
name|symrevno
argument_list|)
decl_stmt|;
name|expandsym
argument_list|(
name|symrevno
argument_list|,
name|numricrevno
argument_list|)
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"expanded number: %s; "
argument_list|,
name|numricrevno
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Date: "
argument_list|)
decl_stmt|;
name|gets
argument_list|(
name|date
argument_list|)
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s; "
argument_list|,
name|date
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Author: "
argument_list|)
decl_stmt|;
name|gets
argument_list|(
name|author
argument_list|)
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s; "
argument_list|,
name|author
argument_list|)
decl_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"State: "
argument_list|)
decl_stmt|;
name|gets
argument_list|(
name|state
argument_list|)
expr_stmt|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s;\n"
argument_list|,
name|state
argument_list|)
decl_stmt|;
name|target
operator|=
name|genrevs
argument_list|(
name|numricrevno
argument_list|,
operator|*
name|date
operator|==
literal|'\0'
condition|?
operator|(
name|char
operator|*
operator|)
name|nil
else|:
name|date
argument_list|,
operator|*
name|author
operator|==
literal|'\0'
condition|?
operator|(
name|char
operator|*
operator|)
name|nil
else|:
name|author
argument_list|,
operator|*
name|state
operator|==
literal|'\0'
condition|?
operator|(
name|char
operator|*
operator|)
name|nil
else|:
name|state
argument_list|,
name|gendeltas
argument_list|)
expr_stmt|;
if|if
condition|(
name|target
operator|!=
name|nil
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|gendeltas
index|[
name|i
index|]
operator|!=
name|nil
condition|)
block|{
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|gendeltas
index|[
name|i
operator|++
index|]
operator|->
name|num
argument_list|)
decl_stmt|;
block|}
block|}
block|}
do|while
condition|(
name|true
condition|)
do|;
name|VOID
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"done\n"
argument_list|)
decl_stmt|;
block|}
end_function

begin_macro
name|cleanup
argument_list|()
end_macro

begin_block
block|{}
end_block

begin_comment
comment|/*dummy*/
end_comment

begin_endif
endif|#
directive|endif
endif|REVTEST
end_endif

end_unit

