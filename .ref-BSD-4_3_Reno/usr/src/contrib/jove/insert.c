begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_decl_stmt
name|private
name|int
name|newchunk
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|DoNewline
name|proto
argument_list|(
operator|(
name|int
name|indentp
operator|)
argument_list|)
decl_stmt|,
name|init_specials
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a newline after AFTER in buffer BUF, UNLESS after is 0,    in which case we insert the newline before after. */
end_comment

begin_function
name|Line
modifier|*
name|listput
parameter_list|(
name|buf
parameter_list|,
name|after
parameter_list|)
specifier|register
name|Buffer
modifier|*
name|buf
decl_stmt|;
specifier|register
name|Line
modifier|*
name|after
decl_stmt|;
block|{
specifier|register
name|Line
modifier|*
name|newline
init|=
name|nbufline
argument_list|()
decl_stmt|;
if|if
condition|(
name|after
operator|==
literal|0
condition|)
block|{
comment|/* Before the first line */
name|newline
operator|->
name|l_next
operator|=
name|buf
operator|->
name|b_first
expr_stmt|;
name|newline
operator|->
name|l_prev
operator|=
literal|0
expr_stmt|;
name|buf
operator|->
name|b_first
operator|=
name|newline
expr_stmt|;
block|}
else|else
block|{
name|newline
operator|->
name|l_prev
operator|=
name|after
expr_stmt|;
name|newline
operator|->
name|l_next
operator|=
name|after
operator|->
name|l_next
expr_stmt|;
name|after
operator|->
name|l_next
operator|=
name|newline
expr_stmt|;
block|}
if|if
condition|(
name|newline
operator|->
name|l_next
condition|)
name|newline
operator|->
name|l_next
operator|->
name|l_prev
operator|=
name|newline
expr_stmt|;
elseif|else
if|if
condition|(
name|buf
condition|)
name|buf
operator|->
name|b_last
operator|=
name|newline
expr_stmt|;
if|if
condition|(
name|buf
operator|&&
name|buf
operator|->
name|b_dot
operator|==
literal|0
condition|)
name|buf
operator|->
name|b_dot
operator|=
name|newline
expr_stmt|;
return|return
name|newline
return|;
block|}
end_function

begin_comment
comment|/* Divide the current line and move the current line to the next one */
end_comment

begin_function
name|void
name|LineInsert
parameter_list|(
name|num
parameter_list|)
specifier|register
name|int
name|num
decl_stmt|;
block|{
name|char
name|newline
index|[
name|LBSIZE
index|]
decl_stmt|;
specifier|register
name|Line
modifier|*
name|newdot
decl_stmt|,
modifier|*
name|olddot
decl_stmt|;
name|int
name|oldchar
decl_stmt|;
name|olddot
operator|=
name|curline
expr_stmt|;
name|oldchar
operator|=
name|curchar
expr_stmt|;
name|newdot
operator|=
name|curline
expr_stmt|;
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
block|{
name|newdot
operator|=
name|listput
argument_list|(
name|curbuf
argument_list|,
name|newdot
argument_list|)
expr_stmt|;
name|SavLine
argument_list|(
name|newdot
argument_list|,
name|NullStr
argument_list|)
expr_stmt|;
block|}
name|modify
argument_list|()
expr_stmt|;
if|if
condition|(
name|curchar
operator|!=
literal|0
condition|)
block|{
name|strcpy
argument_list|(
name|newline
argument_list|,
operator|&
name|linebuf
index|[
name|curchar
index|]
argument_list|)
expr_stmt|;
name|linebuf
index|[
name|curchar
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Shorten this line */
name|SavLine
argument_list|(
name|curline
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|linebuf
argument_list|,
name|newline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Redisplay optimization */
name|newdot
operator|->
name|l_dline
operator|=
name|curline
operator|->
name|l_dline
expr_stmt|;
name|SavLine
argument_list|(
name|curline
argument_list|,
name|NullStr
argument_list|)
expr_stmt|;
block|}
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|curline
operator|=
name|newdot
expr_stmt|;
name|curchar
operator|=
literal|0
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|IFixMarks
argument_list|(
name|olddot
argument_list|,
name|oldchar
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Inserts tabs and spaces to move the cursor to column GOAL.  It    Uses the most optimal number of tabs and spaces no matter what    was there before hand. */
end_comment

begin_function
name|void
name|n_indent
parameter_list|(
name|goal
parameter_list|)
specifier|register
name|int
name|goal
decl_stmt|;
block|{
name|int
name|dotcol
decl_stmt|,
name|incrmt
decl_stmt|;
name|DelWtSpace
argument_list|()
expr_stmt|;
name|dotcol
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|incrmt
operator|=
operator|(
name|tabstop
operator|-
operator|(
name|dotcol
operator|%
name|tabstop
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|dotcol
operator|+
name|incrmt
operator|>
name|goal
condition|)
break|break;
name|insert_c
argument_list|(
literal|'\t'
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|dotcol
operator|+=
name|incrmt
expr_stmt|;
block|}
if|if
condition|(
name|dotcol
operator|!=
name|goal
condition|)
name|insert_c
argument_list|(
literal|' '
argument_list|,
operator|(
name|goal
operator|-
name|dotcol
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ABBREV
end_ifdef

begin_function
name|void
name|MaybeAbbrevExpand
parameter_list|()
block|{
if|if
condition|(
name|MinorMode
argument_list|(
name|Abbrev
argument_list|)
operator|&&
operator|!
name|ismword
argument_list|(
name|LastKeyStruck
argument_list|)
operator|&&
operator|!
name|bolp
argument_list|()
operator|&&
name|ismword
argument_list|(
name|linebuf
index|[
name|curchar
operator|-
literal|1
index|]
argument_list|)
condition|)
name|AbbrevExpand
argument_list|()
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|SelfInsert
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|ABBREV
name|MaybeAbbrevExpand
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|LastKeyStruck
operator|!=
name|CTL
argument_list|(
literal|'J'
argument_list|)
operator|&&
name|MinorMode
argument_list|(
name|OverWrite
argument_list|)
condition|)
block|{
specifier|register
name|int
name|num
decl_stmt|,
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|num
operator|=
name|arg_value
argument_list|()
init|;
name|i
operator|<
name|num
condition|;
name|i
operator|++
control|)
block|{
name|int
name|pos
init|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|eolp
argument_list|()
condition|)
block|{
if|if
condition|(
name|linebuf
index|[
name|curchar
index|]
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
operator|(
name|pos
operator|+
literal|1
operator|)
operator|==
operator|(
operator|(
name|pos
operator|+
name|tabstop
operator|)
operator|-
operator|(
name|pos
operator|%
name|tabstop
operator|)
operator|)
condition|)
name|del_char
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
else|else
name|del_char
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|insert_c
argument_list|(
name|LastKeyStruck
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|Insert
argument_list|(
name|LastKeyStruck
argument_list|)
expr_stmt|;
if|if
condition|(
name|MinorMode
argument_list|(
name|Fill
argument_list|)
operator|&&
operator|(
name|curchar
operator|>=
name|RMargin
operator|||
operator|(
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|>=
name|RMargin
operator|)
operator|)
condition|)
block|{
name|int
name|margin
decl_stmt|;
name|Bufpos
name|save
decl_stmt|;
if|if
condition|(
name|MinorMode
argument_list|(
name|Indent
argument_list|)
condition|)
block|{
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|ToIndent
argument_list|()
expr_stmt|;
name|margin
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
block|}
else|else
name|margin
operator|=
name|LMargin
expr_stmt|;
name|DoJustify
argument_list|(
name|curline
argument_list|,
literal|0
argument_list|,
name|curline
argument_list|,
name|curchar
operator|+
operator|(
name|int
operator|)
name|strlen
argument_list|(
operator|&
name|linebuf
index|[
name|curchar
index|]
argument_list|)
argument_list|,
literal|1
argument_list|,
name|margin
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|Insert
parameter_list|(
name|c
parameter_list|)
name|int
name|c
decl_stmt|;
block|{
if|if
condition|(
name|c
operator|==
name|CTL
argument_list|(
literal|'J'
argument_list|)
condition|)
name|LineInsert
argument_list|(
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
else|else
name|insert_c
argument_list|(
name|c
argument_list|,
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* insert character C N times at point */
end_comment

begin_function
name|void
name|insert_c
parameter_list|(
name|c
parameter_list|,
name|n
parameter_list|)
name|int
name|c
decl_stmt|,
name|n
decl_stmt|;
block|{
if|if
condition|(
name|n
operator|<=
literal|0
condition|)
return|return;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|ins_c
argument_list|(
name|c
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|,
name|n
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
name|IFixMarks
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|curline
argument_list|,
name|curchar
operator|+
name|n
argument_list|)
expr_stmt|;
name|curchar
operator|+=
name|n
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Tab in to the right place for C mode */
end_comment

begin_function
name|void
name|Tab
parameter_list|()
block|{
ifdef|#
directive|ifdef
name|LISP
if|if
condition|(
name|MajorMode
argument_list|(
name|LISPMODE
argument_list|)
operator|&&
operator|(
name|bolp
argument_list|()
operator|||
operator|!
name|eolp
argument_list|()
operator|)
condition|)
block|{
name|int
name|dotchar
init|=
name|curchar
decl_stmt|;
name|Mark
modifier|*
name|m
init|=
literal|0
decl_stmt|;
name|ToIndent
argument_list|()
expr_stmt|;
if|if
condition|(
name|dotchar
operator|>
name|curchar
condition|)
name|m
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|dotchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|lisp_indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|m
condition|)
block|{
name|ToMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|DelMark
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
else|else
name|ToIndent
argument_list|()
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
if|if
condition|(
name|MajorMode
argument_list|(
name|CMODE
argument_list|)
condition|)
block|{
if|if
condition|(
name|within_indent
argument_list|()
condition|)
operator|(
name|void
operator|)
name|c_indent
argument_list|(
name|NO
argument_list|)
expr_stmt|;
else|else
block|{
name|int
name|curpos
decl_stmt|,
name|tabbed_pos
decl_stmt|;
name|skip_wht_space
argument_list|()
expr_stmt|;
name|curpos
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|tabbed_pos
operator|=
name|curpos
operator|+
operator|(
name|CIndIncrmt
operator|-
operator|(
name|curpos
operator|%
name|CIndIncrmt
operator|)
operator|)
expr_stmt|;
name|n_indent
argument_list|(
name|tabbed_pos
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|SelfInsert
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|QuotChar
parameter_list|()
block|{
name|int
name|c
decl_stmt|,
name|slow
init|=
name|NO
decl_stmt|;
name|c
operator|=
name|waitchar
argument_list|(
operator|&
name|slow
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|CTL
argument_list|(
literal|'@'
argument_list|)
condition|)
name|Insert
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Insert the paren.  If in C mode and c is a '}' then insert the    '}' in the "right" place for C indentation; that is indented    the same amount as the matching '{' is indented. */
end_comment

begin_decl_stmt
name|int
name|PDelay
init|=
literal|5
decl_stmt|,
comment|/* 1/2 a second */
name|CIndIncrmt
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|DoParen
parameter_list|()
block|{
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|int
name|tried
init|=
name|NO
decl_stmt|,
name|nx
decl_stmt|,
name|c
init|=
name|LastKeyStruck
decl_stmt|;
if|if
condition|(
operator|!
name|isclosep
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|SelfInsert
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|MajorMode
argument_list|(
name|CMODE
argument_list|)
operator|&&
name|c
operator|==
literal|'}'
operator|&&
name|within_indent
argument_list|()
condition|)
block|{
name|bp
operator|=
name|c_indent
argument_list|(
name|YES
argument_list|)
expr_stmt|;
name|tried
operator|=
name|TRUE
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|LISP
if|if
condition|(
name|MajorMode
argument_list|(
name|LISPMODE
argument_list|)
operator|&&
name|c
operator|==
literal|')'
operator|&&
name|blnkp
argument_list|(
name|linebuf
argument_list|)
condition|)
block|{
name|bp
operator|=
name|lisp_indent
argument_list|()
expr_stmt|;
name|tried
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
name|SelfInsert
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|MinorMode
argument_list|(
name|ShowMatch
argument_list|)
operator|&&
operator|!
name|in_macro
argument_list|()
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|MinorMode
argument_list|(
name|ShowMatch
argument_list|)
operator|&&
operator|!
name|charp
argument_list|()
operator|&&
operator|!
name|in_macro
argument_list|()
condition|)
block|{
endif|#
directive|endif
name|b_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Back onto the ')' */
if|if
condition|(
operator|!
name|tried
condition|)
name|bp
operator|=
name|m_paren
argument_list|(
name|c
argument_list|,
name|BACKWARD
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|f_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|0
condition|)
block|{
name|nx
operator|=
name|in_window
argument_list|(
name|curwind
argument_list|,
name|bp
operator|->
name|p_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|nx
operator|!=
operator|-
literal|1
condition|)
block|{
comment|/* is visible */
name|Bufpos
name|b
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
name|PDelay
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
else|else
name|s_mess
argument_list|(
literal|"%s"
argument_list|,
name|lcontents
argument_list|(
name|bp
operator|->
name|p_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mp_error
argument_list|()
expr_stmt|;
comment|/* display error message */
block|}
block|}
name|void
name|LineAI
parameter_list|()
block|{
name|DoNewline
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|void
name|Newline
parameter_list|()
block|{
name|DoNewline
argument_list|(
name|MinorMode
argument_list|(
name|Indent
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|private
name|void
name|DoNewline
parameter_list|(
name|indentp
parameter_list|)
name|int
name|indentp
decl_stmt|;
block|{
name|Bufpos
name|save
decl_stmt|;
name|int
name|indent
decl_stmt|;
comment|/* first we calculate the indent of the current line */
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|ToIndent
argument_list|()
expr_stmt|;
name|indent
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|ABBREV
name|MaybeAbbrevExpand
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|LISP
if|if
condition|(
name|MajorMode
argument_list|(
name|LISPMODE
argument_list|)
condition|)
name|DelWtSpace
argument_list|()
expr_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|indentp
operator|||
name|blnkp
argument_list|(
name|linebuf
argument_list|)
condition|)
name|DelWtSpace
argument_list|()
expr_stmt|;
comment|/* If there is more than 2 blank lines in a row then don't make 	   a newline, just move down one. */
if|if
condition|(
name|arg_value
argument_list|()
operator|==
literal|1
operator|&&
name|eolp
argument_list|()
operator|&&
name|TwoBlank
argument_list|()
condition|)
name|SetLine
argument_list|(
name|curline
operator|->
name|l_next
argument_list|)
expr_stmt|;
else|else
name|LineInsert
argument_list|(
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|indentp
condition|)
ifdef|#
directive|ifdef
name|LISP
if|if
condition|(
name|MajorMode
argument_list|(
name|LISPMODE
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lisp_indent
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
block|{
name|Bol
argument_list|()
expr_stmt|;
name|n_indent
argument_list|(
operator|(
name|LMargin
operator|==
literal|0
operator|)
condition|?
name|indent
else|:
name|LMargin
argument_list|)
expr_stmt|;
block|}
block|}
name|void
name|ins_str
parameter_list|(
name|str
parameter_list|,
name|ok_nl
parameter_list|)
specifier|register
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|ok_nl
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|;
name|Bufpos
name|save
decl_stmt|;
name|int
name|llen
decl_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|0
condition|)
return|return;
comment|/* ain't nothing to insert! */
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|llen
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|||
operator|(
name|ok_nl
operator|&&
name|llen
operator|>=
name|LBSIZE
operator|-
literal|2
operator|)
condition|)
block|{
name|IFixMarks
argument_list|(
name|save
operator|.
name|p_line
argument_list|,
name|save
operator|.
name|p_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|llen
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|!=
literal|'\n'
condition|)
block|{
name|ins_c
argument_list|(
name|c
argument_list|,
name|linebuf
argument_list|,
name|curchar
operator|++
argument_list|,
literal|1
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
name|llen
operator|+=
literal|1
expr_stmt|;
block|}
block|}
name|IFixMarks
argument_list|(
name|save
operator|.
name|p_line
argument_list|,
name|save
operator|.
name|p_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
name|void
name|open_lines
parameter_list|(
name|n
parameter_list|)
name|int
name|n
decl_stmt|;
block|{
name|Bufpos
name|dot
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|dot
argument_list|)
expr_stmt|;
name|LineInsert
argument_list|(
name|n
argument_list|)
expr_stmt|;
comment|/* Open the lines... */
name|SetDot
argument_list|(
operator|&
name|dot
argument_list|)
expr_stmt|;
block|}
name|void
name|OpenLine
parameter_list|()
block|{
name|open_lines
argument_list|(
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
block|}
comment|/* Take the region FLINE/FCHAR to TLINE/TCHAR and insert it at    ATLINE/ATCHAR in WHATBUF. */
name|Bufpos
modifier|*
name|DoYank
parameter_list|(
name|fline
parameter_list|,
name|fchar
parameter_list|,
name|tline
parameter_list|,
name|tchar
parameter_list|,
name|atline
parameter_list|,
name|atchar
parameter_list|,
name|whatbuf
parameter_list|)
name|Line
modifier|*
name|fline
decl_stmt|,
decl|*
name|tline
decl_stmt|,
modifier|*
name|atline
decl_stmt|;
name|int
name|fchar
decl_stmt|,
name|tchar
decl_stmt|,
name|atchar
decl_stmt|;
name|Buffer
modifier|*
name|whatbuf
decl_stmt|;
block|{
specifier|register
name|Line
modifier|*
name|newline
decl_stmt|;
specifier|static
name|Bufpos
name|bp
decl_stmt|;
name|char
name|save
index|[
name|LBSIZE
index|]
decl_stmt|,
name|buf
index|[
name|LBSIZE
index|]
decl_stmt|;
name|Line
modifier|*
name|startline
init|=
name|atline
decl_stmt|;
name|int
name|startchar
init|=
name|atchar
decl_stmt|;
name|lsave
argument_list|()
expr_stmt|;
if|if
condition|(
name|whatbuf
condition|)
name|modify
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|ltobuf
argument_list|(
name|atline
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|save
argument_list|,
operator|&
name|genbuf
index|[
name|atchar
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|ltobuf
argument_list|(
name|fline
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fline
operator|==
name|tline
condition|)
name|buf
index|[
name|tchar
index|]
operator|=
literal|'\0'
expr_stmt|;
name|linecopy
argument_list|(
name|genbuf
argument_list|,
name|atchar
argument_list|,
operator|&
name|buf
index|[
name|fchar
index|]
argument_list|)
expr_stmt|;
name|atline
operator|->
name|l_dline
operator|=
name|putline
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|makedirty
argument_list|(
name|atline
argument_list|)
expr_stmt|;
name|fline
operator|=
name|fline
operator|->
name|l_next
expr_stmt|;
while|while
condition|(
name|fline
operator|!=
name|tline
operator|->
name|l_next
condition|)
block|{
name|newline
operator|=
name|listput
argument_list|(
name|whatbuf
argument_list|,
name|atline
argument_list|)
expr_stmt|;
name|newline
operator|->
name|l_dline
operator|=
name|fline
operator|->
name|l_dline
expr_stmt|;
name|makedirty
argument_list|(
name|newline
argument_list|)
expr_stmt|;
name|fline
operator|=
name|fline
operator|->
name|l_next
expr_stmt|;
name|atline
operator|=
name|newline
expr_stmt|;
name|atchar
operator|=
literal|0
expr_stmt|;
block|}
name|getline
argument_list|(
name|atline
operator|->
name|l_dline
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
name|atchar
operator|+=
name|tchar
expr_stmt|;
name|linecopy
argument_list|(
name|genbuf
argument_list|,
name|atchar
argument_list|,
name|save
argument_list|)
expr_stmt|;
name|atline
operator|->
name|l_dline
operator|=
name|putline
argument_list|(
name|genbuf
argument_list|)
expr_stmt|;
name|makedirty
argument_list|(
name|atline
argument_list|)
expr_stmt|;
name|IFixMarks
argument_list|(
name|startline
argument_list|,
name|startchar
argument_list|,
name|atline
argument_list|,
name|atchar
argument_list|)
expr_stmt|;
name|bp
operator|.
name|p_line
operator|=
name|atline
expr_stmt|;
name|bp
operator|.
name|p_char
operator|=
name|atchar
expr_stmt|;
name|this_cmd
operator|=
name|YANKCMD
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
comment|/* Whatever used to be in linebuf */
return|return
operator|&
name|bp
return|;
block|}
name|void
name|YankPop
parameter_list|()
block|{
name|Line
modifier|*
name|line
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|Mark
modifier|*
name|mp
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|Bufpos
modifier|*
name|dot
decl_stmt|;
name|int
name|dir
init|=
operator|-
literal|1
decl_stmt|;
comment|/* Direction to rotate the ring */
if|if
condition|(
name|last_cmd
operator|!=
name|YANKCMD
condition|)
name|complain
argument_list|(
literal|"Yank something first!"
argument_list|)
expr_stmt|;
name|lfreelist
argument_list|(
name|reg_delete
argument_list|(
name|mp
operator|->
name|m_line
argument_list|,
name|mp
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now must find a recently killed region. */
if|if
condition|(
name|arg_value
argument_list|()
operator|<
literal|0
condition|)
name|dir
operator|=
literal|1
expr_stmt|;
name|killptr
operator|+=
name|dir
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|killptr
operator|<
literal|0
condition|)
name|killptr
operator|=
name|NUMKILLS
operator|-
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|killptr
operator|>=
name|NUMKILLS
condition|)
name|killptr
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|killbuf
index|[
name|killptr
index|]
condition|)
break|break;
name|killptr
operator|+=
name|dir
expr_stmt|;
block|}
name|this_cmd
operator|=
name|YANKCMD
expr_stmt|;
name|line
operator|=
name|killbuf
index|[
name|killptr
index|]
expr_stmt|;
name|last
operator|=
name|lastline
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|dot
operator|=
name|DoYank
argument_list|(
name|line
argument_list|,
literal|0
argument_list|,
name|last
argument_list|,
name|length
argument_list|(
name|last
argument_list|)
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|,
name|curbuf
argument_list|)
expr_stmt|;
name|MarkSet
argument_list|(
name|CurMark
argument_list|()
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|dot
argument_list|)
expr_stmt|;
block|}
comment|/* This is an attempt to reduce the amount of memory taken up by each line.    Without this each malloc of a line uses sizeof (line) + sizeof(HEADER)    where line is 3 words and HEADER is 1 word.    This is going to allocate memory in chucks of CHUNKSIZE * sizeof (line)    and divide each chuck into lineS.  A line is free in a chunk when its    line->l_dline == 0, so freeline sets dline to 0. */
define|#
directive|define
name|CHUNKSIZE
value|300
struct|struct
name|chunk
block|{
name|int
name|c_nlines
decl_stmt|;
comment|/* Number of lines in this chunk (so they 				   don't all have to be CHUNKSIZE long). */
name|Line
modifier|*
name|c_block
decl_stmt|;
comment|/* Chunk of memory */
name|struct
name|chunk
modifier|*
name|c_nextfree
decl_stmt|;
comment|/* Next chunk of lines */
block|}
struct|;
name|private
name|struct
name|chunk
modifier|*
name|fchunk
init|=
literal|0
decl_stmt|;
name|private
name|Line
modifier|*
name|ffline
init|=
literal|0
decl_stmt|;
comment|/* First free line */
name|void
name|freeline
parameter_list|(
name|line
parameter_list|)
specifier|register
name|Line
modifier|*
name|line
decl_stmt|;
block|{
name|line
operator|->
name|l_dline
operator|=
literal|0
expr_stmt|;
name|line
operator|->
name|l_next
operator|=
name|ffline
expr_stmt|;
if|if
condition|(
name|ffline
condition|)
name|ffline
operator|->
name|l_prev
operator|=
name|line
expr_stmt|;
name|line
operator|->
name|l_prev
operator|=
literal|0
expr_stmt|;
name|ffline
operator|=
name|line
expr_stmt|;
block|}
name|void
name|lfreelist
parameter_list|(
name|first
parameter_list|)
specifier|register
name|Line
modifier|*
name|first
decl_stmt|;
block|{
if|if
condition|(
name|first
condition|)
name|lfreereg
argument_list|(
name|first
argument_list|,
name|lastline
argument_list|(
name|first
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Append region from line1 to line2 onto the free list of lines */
name|void
name|lfreereg
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
specifier|register
name|Line
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
block|{
specifier|register
name|Line
modifier|*
name|next
decl_stmt|,
modifier|*
name|last
init|=
name|line2
operator|->
name|l_next
decl_stmt|;
while|while
condition|(
name|line1
operator|!=
name|last
condition|)
block|{
name|next
operator|=
name|line1
operator|->
name|l_next
expr_stmt|;
name|freeline
argument_list|(
name|line1
argument_list|)
expr_stmt|;
name|line1
operator|=
name|next
expr_stmt|;
block|}
block|}
name|private
name|int
name|newchunk
parameter_list|()
block|{
specifier|register
name|Line
modifier|*
name|newline
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|struct
name|chunk
modifier|*
name|f
decl_stmt|;
name|int
name|nlines
init|=
name|CHUNKSIZE
decl_stmt|;
name|f
operator|=
operator|(
expr|struct
name|chunk
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|chunk
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|==
literal|0
condition|)
return|return
literal|0
return|;
if|if
condition|(
operator|(
name|f
operator|->
name|c_block
operator|=
operator|(
name|Line
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|Line
argument_list|)
operator|*
name|nlines
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
while|while
condition|(
name|nlines
operator|>
literal|0
condition|)
block|{
name|f
operator|->
name|c_block
operator|=
operator|(
name|Line
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
sizeof|sizeof
argument_list|(
name|Line
argument_list|)
operator|*
name|nlines
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|->
name|c_block
operator|!=
literal|0
condition|)
break|break;
name|nlines
operator|/=
literal|2
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nlines
operator|<=
literal|0
condition|)
return|return
literal|0
return|;
name|f
operator|->
name|c_nlines
operator|=
name|nlines
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|newline
operator|=
name|f
operator|->
name|c_block
init|;
name|i
operator|<
name|nlines
condition|;
name|newline
operator|++
operator|,
name|i
operator|++
control|)
name|freeline
argument_list|(
name|newline
argument_list|)
expr_stmt|;
name|f
operator|->
name|c_nextfree
operator|=
name|fchunk
expr_stmt|;
name|fchunk
operator|=
name|f
expr_stmt|;
return|return
literal|1
return|;
block|}
comment|/* New BUFfer LINE */
name|Line
modifier|*
name|nbufline
parameter_list|()
block|{
specifier|register
name|Line
modifier|*
name|newline
decl_stmt|;
if|if
condition|(
name|ffline
operator|==
literal|0
condition|)
comment|/* No free list */
if|if
condition|(
name|newchunk
argument_list|()
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"[Out of lines] "
argument_list|)
expr_stmt|;
name|newline
operator|=
name|ffline
expr_stmt|;
name|ffline
operator|=
name|ffline
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|ffline
condition|)
name|ffline
operator|->
name|l_prev
operator|=
literal|0
expr_stmt|;
return|return
name|newline
return|;
block|}
comment|/* Remove the free lines, in chunk c, from the free list because they are    no longer free. */
name|private
name|void
name|remfreelines
parameter_list|(
name|c
parameter_list|)
specifier|register
name|struct
name|chunk
modifier|*
name|c
decl_stmt|;
block|{
specifier|register
name|Line
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
for|for
control|(
name|lp
operator|=
name|c
operator|->
name|c_block
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|c
operator|->
name|c_nlines
condition|;
name|i
operator|++
operator|,
name|lp
operator|++
control|)
block|{
if|if
condition|(
name|lp
operator|->
name|l_prev
condition|)
name|lp
operator|->
name|l_prev
operator|->
name|l_next
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
else|else
name|ffline
operator|=
name|lp
operator|->
name|l_next
expr_stmt|;
if|if
condition|(
name|lp
operator|->
name|l_next
condition|)
name|lp
operator|->
name|l_next
operator|->
name|l_prev
operator|=
name|lp
operator|->
name|l_prev
expr_stmt|;
block|}
block|}
comment|/* This is used to garbage collect the chunks of lines when malloc fails    and we are NOT looking for a new buffer line.  This goes through each    chunk, and if every line in a given chunk is not allocated, the entire    chunk is `free'd by "free()". */
name|void
name|GCchunks
parameter_list|()
block|{
specifier|register
name|struct
name|chunk
modifier|*
name|cp
decl_stmt|;
name|struct
name|chunk
modifier|*
name|prev
init|=
literal|0
decl_stmt|,
modifier|*
name|next
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|Line
modifier|*
name|newline
decl_stmt|;
for|for
control|(
name|cp
operator|=
name|fchunk
init|;
name|cp
operator|!=
literal|0
condition|;
name|cp
operator|=
name|next
control|)
block|{
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|newline
operator|=
name|cp
operator|->
name|c_block
init|;
name|i
operator|<
name|cp
operator|->
name|c_nlines
condition|;
name|newline
operator|++
operator|,
name|i
operator|++
control|)
if|if
condition|(
name|newline
operator|->
name|l_dline
operator|!=
literal|0
condition|)
break|break;
name|next
operator|=
name|cp
operator|->
name|c_nextfree
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|cp
operator|->
name|c_nlines
condition|)
block|{
comment|/* Unlink it!!! */
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|c_nextfree
operator|=
name|cp
operator|->
name|c_nextfree
expr_stmt|;
else|else
name|fchunk
operator|=
name|cp
operator|->
name|c_nextfree
expr_stmt|;
name|remfreelines
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
operator|->
name|c_block
argument_list|)
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
name|prev
operator|=
name|cp
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|LISP
include|#
directive|include
file|"re.h"
comment|/* Grind S-Expr */
name|void
name|GSexpr
parameter_list|()
block|{
name|Bufpos
name|dot
decl_stmt|,
name|end
decl_stmt|;
if|if
condition|(
name|linebuf
index|[
name|curchar
index|]
operator|!=
literal|'('
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|dot
argument_list|)
expr_stmt|;
name|FSexpr
argument_list|()
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|end
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|dot
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|curline
operator|==
name|end
operator|.
name|p_line
condition|)
break|break;
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|blnkp
argument_list|(
name|linebuf
argument_list|)
condition|)
operator|(
name|void
operator|)
name|lisp_indent
argument_list|()
expr_stmt|;
block|}
name|SetDot
argument_list|(
operator|&
name|dot
argument_list|)
expr_stmt|;
block|}
comment|/* lisp_indent() indents a new line in Lisp Mode, according to where    the matching close-paren would go if we typed that (sort of). */
name|private
name|List
modifier|*
name|specials
init|=
name|NIL
decl_stmt|;
name|private
name|void
name|init_specials
parameter_list|()
block|{
specifier|static
name|char
modifier|*
specifier|const
name|words
index|[]
init|=
block|{
literal|"case"
block|,
literal|"def"
block|,
literal|"dolist"
block|,
literal|"fluid-let"
block|,
literal|"lambda"
block|,
literal|"let"
block|,
literal|"lexpr"
block|,
literal|"macro"
block|,
literal|"named-l"
block|,
comment|/* named-let and named-lambda */
literal|"nlambda"
block|,
literal|"prog"
block|,
literal|"selectq"
block|,
literal|0
block|}
decl_stmt|;
name|char
modifier|*
specifier|const
modifier|*
name|wordp
init|=
name|words
decl_stmt|;
while|while
condition|(
operator|*
name|wordp
condition|)
name|list_push
argument_list|(
operator|&
name|specials
argument_list|,
operator|(
name|Element
operator|*
operator|)
operator|*
name|wordp
operator|++
argument_list|)
expr_stmt|;
block|}
name|void
name|AddSpecial
parameter_list|()
block|{
name|char
modifier|*
name|word
decl_stmt|;
specifier|register
name|List
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|specials
operator|==
name|NIL
condition|)
name|init_specials
argument_list|()
expr_stmt|;
name|word
operator|=
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|specials
init|;
name|lp
operator|!=
name|NIL
condition|;
name|lp
operator|=
name|list_next
argument_list|(
name|lp
argument_list|)
control|)
if|if
condition|(
name|strcmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list_data
argument_list|(
name|lp
argument_list|)
argument_list|,
name|word
argument_list|)
operator|==
literal|0
condition|)
return|return;
comment|/* already in list */
operator|(
name|void
operator|)
name|list_push
argument_list|(
operator|&
name|specials
argument_list|,
operator|(
name|Element
operator|*
operator|)
name|copystr
argument_list|(
name|word
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|Bufpos
modifier|*
name|lisp_indent
parameter_list|()
block|{
name|Bufpos
modifier|*
name|bp
decl_stmt|,
name|savedot
decl_stmt|;
name|int
name|goal
decl_stmt|;
name|bp
operator|=
name|m_paren
argument_list|(
literal|')'
argument_list|,
name|BACKWARD
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|==
name|NULL
condition|)
return|return
name|NULL
return|;
comment|/* We want to end up  		(atom atom atom ... 		      ^ here. 	 */
name|DOTsave
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|f_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
name|curchar
index|]
operator|!=
literal|'('
condition|)
block|{
specifier|register
name|List
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|specials
operator|==
name|NIL
condition|)
name|init_specials
argument_list|()
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|specials
init|;
name|lp
operator|!=
name|NIL
condition|;
name|lp
operator|=
name|list_next
argument_list|(
name|lp
argument_list|)
control|)
if|if
condition|(
name|casencmp
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list_data
argument_list|(
name|lp
argument_list|)
argument_list|,
operator|&
name|linebuf
index|[
name|curchar
index|]
argument_list|,
name|strlen
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list_data
argument_list|(
name|lp
argument_list|)
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|lp
operator|==
name|NIL
condition|)
block|{
comment|/* not special */
name|int
name|c_char
init|=
name|curchar
decl_stmt|;
name|WITH_TABLE
argument_list|(
argument|curbuf->b_major
argument_list|)
name|f_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|END_TABLE
argument_list|()
expr_stmt|;
if|if
condition|(
name|LookingAt
argument_list|(
literal|"[ \t]*;\\|[ \t]*$"
argument_list|,
name|linebuf
argument_list|,
name|curchar
argument_list|)
condition|)
name|curchar
operator|=
name|c_char
expr_stmt|;
else|else
while|while
condition|(
name|linebuf
index|[
name|curchar
index|]
operator|==
literal|' '
condition|)
name|curchar
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|curchar
operator|+=
literal|1
expr_stmt|;
block|}
name|goal
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
name|Bol
argument_list|()
expr_stmt|;
name|n_indent
argument_list|(
name|goal
argument_list|)
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LISP */
end_comment

end_unit

