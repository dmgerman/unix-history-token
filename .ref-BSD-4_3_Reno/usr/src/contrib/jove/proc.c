begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<varargs.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|void
name|DoShell
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|com_finish
name|proto
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|toerror
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
name|private
name|void
name|closepipe
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|int
name|okay_error
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_decl_stmt
name|private
name|int
name|openforpipe
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|,
name|reopenforpipe
name|proto
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|struct
name|error
modifier|*
name|AddError
name|proto
argument_list|(
operator|(
expr|struct
name|error
operator|*
operator|,
name|Line
operator|*
operator|,
name|Buffer
operator|*
operator|,
name|Line
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|SigMask
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This disgusting RE search string parses output from the GREP    family, from the pdp11 compiler, pcc, and lint.  Jay (HACK)    Fenlasen changed this to work for the lint errors. */
end_comment

begin_decl_stmt
name|char
name|ErrFmtStr
index|[
literal|256
index|]
init|=
literal|"^\\{\",\\}\\([^:\"( \t]*\\)\\{\"\\, line ,:,(\\} *\\([0-9][0-9]*\\)[:)]\ \\|::  *\\([^(]*\\)(\\([0-9]*\\))$\ \\|( \\([^(]*\\)(\\([0-9]*\\)) ),"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|error
block|{
name|Buffer
modifier|*
name|er_buf
decl_stmt|;
comment|/* Buffer error is in */
name|Line
modifier|*
name|er_mess
decl_stmt|,
comment|/* Actual error message */
modifier|*
name|er_text
decl_stmt|;
comment|/* Actual error */
name|int
name|er_char
decl_stmt|;
comment|/* char pos of error */
name|struct
name|error
modifier|*
name|er_prev
decl_stmt|,
comment|/* List of errors */
modifier|*
name|er_next
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|private
name|struct
name|error
modifier|*
name|cur_error
init|=
name|NULL
decl_stmt|,
modifier|*
name|errorlist
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|perr_buf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Buffer with error messages */
end_comment

begin_decl_stmt
name|int
name|WtOnMk
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Write the modified files when we make */
end_comment

begin_comment
comment|/* Add an error to the end of the list of errors.  This is used for    parse-{C,LINT}-errors and for the spell-buffer command */
end_comment

begin_decl_stmt
name|private
name|struct
name|error
modifier|*
name|AddError
argument_list|(
name|laste
argument_list|,
name|errline
argument_list|,
name|buf
argument_list|,
name|line
argument_list|,
name|charpos
argument_list|)
decl|struct
name|error
modifier|*
name|laste
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Line
modifier|*
name|errline
decl_stmt|,
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Buffer
modifier|*
name|buf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|charpos
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|struct
name|error
modifier|*
name|new
init|=
operator|(
expr|struct
name|error
operator|*
operator|)
name|emalloc
argument_list|(
sizeof|sizeof
expr|*
name|new
argument_list|)
decl_stmt|;
name|new
operator|->
name|er_prev
operator|=
name|laste
expr_stmt|;
if|if
condition|(
name|laste
condition|)
name|laste
operator|->
name|er_next
operator|=
name|new
expr_stmt|;
else|else
block|{
if|if
condition|(
name|errorlist
condition|)
comment|/* Free up old errors */
name|ErrFree
argument_list|()
expr_stmt|;
name|cur_error
operator|=
name|errorlist
operator|=
name|new
expr_stmt|;
block|}
name|laste
operator|=
name|new
expr_stmt|;
name|new
operator|->
name|er_next
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|er_buf
operator|=
name|buf
expr_stmt|;
name|new
operator|->
name|er_text
operator|=
name|line
expr_stmt|;
name|new
operator|->
name|er_char
operator|=
name|charpos
expr_stmt|;
name|new
operator|->
name|er_mess
operator|=
name|errline
expr_stmt|;
return|return
name|new
return|;
block|}
end_block

begin_function
name|void
name|get_FL_info
parameter_list|(
name|fname
parameter_list|,
name|lineno
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|,
decl|*
name|lineno
decl_stmt|;
end_function

begin_block
block|{
name|putmatch
argument_list|(
literal|1
argument_list|,
name|fname
argument_list|,
operator|(
name|size_t
operator|)
name|FILESIZE
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|2
argument_list|,
name|lineno
argument_list|,
operator|(
name|size_t
operator|)
name|FILESIZE
argument_list|)
expr_stmt|;
comment|/* error had lineno followed fname, so switch the two */
if|if
condition|(
operator|!
name|isdigit
argument_list|(
name|lineno
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|char
name|tmp
index|[
name|FILESIZE
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|lineno
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|fname
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/* Free up all the errors */
end_comment

begin_function
name|void
name|ErrFree
parameter_list|()
block|{
specifier|register
name|struct
name|error
modifier|*
name|ep
decl_stmt|;
for|for
control|(
name|ep
operator|=
name|errorlist
init|;
name|ep
operator|!=
literal|0
condition|;
name|ep
operator|=
name|ep
operator|->
name|er_next
control|)
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|ep
argument_list|)
expr_stmt|;
name|errorlist
operator|=
name|cur_error
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Parse errors of the form specified in ErrFmtStr in the current    buffer.  Do a show error of the first error.  This is neat because this    will work for any kind of output that prints a file name and a line    number on the same line. */
end_comment

begin_function
name|void
name|ErrParse
parameter_list|()
block|{
name|struct
name|RE_block
name|re_blk
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|char
name|fname
index|[
name|FILESIZE
index|]
decl_stmt|,
name|lineno
index|[
name|FILESIZE
index|]
decl_stmt|;
name|int
name|lnum
decl_stmt|,
name|last_lnum
init|=
operator|-
literal|1
decl_stmt|;
name|struct
name|error
modifier|*
name|ep
init|=
literal|0
decl_stmt|;
name|Buffer
modifier|*
name|buf
decl_stmt|,
modifier|*
name|lastb
init|=
literal|0
decl_stmt|;
name|Line
modifier|*
name|err_line
decl_stmt|;
name|ErrFree
argument_list|()
expr_stmt|;
comment|/* This is important! */
name|ToFirst
argument_list|()
expr_stmt|;
name|perr_buf
operator|=
name|curbuf
expr_stmt|;
name|REcompile
argument_list|(
name|ErrFmtStr
argument_list|,
name|YES
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
comment|/* Find a line with a number on it. */
while|while
condition|(
operator|(
name|bp
operator|=
name|docompiled
argument_list|(
name|FORWARD
argument_list|,
operator|&
name|re_blk
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|get_FL_info
argument_list|(
name|fname
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|buf
operator|=
name|do_find
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
name|fname
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|lastb
condition|)
block|{
name|lastb
operator|=
name|buf
expr_stmt|;
name|last_lnum
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* signals new file */
name|err_line
operator|=
name|buf
operator|->
name|b_first
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|chr_to_int
argument_list|(
name|lineno
argument_list|,
literal|10
argument_list|,
name|NO
argument_list|,
operator|&
name|lnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|lnum
operator|==
name|last_lnum
condition|)
comment|/* one error per line is nicer */
continue|continue;
if|if
condition|(
name|last_lnum
operator|==
operator|-
literal|1
condition|)
name|last_lnum
operator|=
literal|1
expr_stmt|;
comment|/* that's where we really are */
name|err_line
operator|=
name|next_line
argument_list|(
name|err_line
argument_list|,
name|lnum
operator|-
name|last_lnum
argument_list|)
expr_stmt|;
name|ep
operator|=
name|AddError
argument_list|(
name|ep
argument_list|,
name|curline
argument_list|,
name|buf
argument_list|,
name|err_line
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|last_lnum
operator|=
name|lnum
expr_stmt|;
block|}
if|if
condition|(
name|cur_error
operator|!=
literal|0
condition|)
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Internal next error sets cur_error to the next error, taking the    argument count, supplied by the user, into consideration. */
end_comment

begin_decl_stmt
name|private
name|char
name|errbounds
index|[]
init|=
literal|"You're at the %s error."
decl_stmt|,
name|noerrs
index|[]
init|=
literal|"No errors!"
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|toerror
parameter_list|(
name|forward
parameter_list|,
name|num
parameter_list|)
name|int
name|forward
decl_stmt|,
name|num
decl_stmt|;
block|{
specifier|register
name|struct
name|error
modifier|*
name|e
init|=
name|cur_error
decl_stmt|;
if|if
condition|(
name|e
operator|==
literal|0
condition|)
name|complain
argument_list|(
name|noerrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|forward
operator|&&
operator|(
name|e
operator|->
name|er_next
operator|==
literal|0
operator|)
operator|)
operator|||
operator|(
operator|!
name|forward
operator|&&
operator|(
name|e
operator|->
name|er_prev
operator|==
literal|0
operator|)
operator|)
condition|)
name|complain
argument_list|(
name|errbounds
argument_list|,
name|forward
condition|?
literal|"last"
else|:
literal|"first"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|e
operator|=
name|forward
condition|?
name|e
operator|->
name|er_next
else|:
name|e
operator|->
name|er_prev
operator|)
operator|==
literal|0
condition|)
break|break;
name|cur_error
operator|=
name|e
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|NextError
parameter_list|()
block|{
name|ToError
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|PrevError
parameter_list|()
block|{
name|ToError
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|int
name|okay_error
parameter_list|()
block|{
return|return
operator|(
operator|(
name|inlist
argument_list|(
name|perr_buf
operator|->
name|b_first
argument_list|,
name|cur_error
operator|->
name|er_mess
argument_list|)
operator|)
operator|&&
operator|(
name|inlist
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_first
argument_list|,
name|cur_error
operator|->
name|er_text
argument_list|)
operator|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Go the the next error, if there is one.  Put the error buffer in    one window and the buffer with the error in another window.    It checks to make sure that the error actually exists. */
end_comment

begin_function
name|void
name|ToError
parameter_list|(
name|forward
parameter_list|)
name|int
name|forward
decl_stmt|;
block|{
do|do
block|{
name|toerror
argument_list|(
name|forward
argument_list|,
name|arg_value
argument_list|()
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|okay_error
argument_list|()
condition|)
do|;
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|EWSize
init|=
literal|20
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* percentage of screen the error window 			   should be */
end_comment

begin_function
name|private
name|void
name|set_wsize
parameter_list|(
name|wsize
parameter_list|)
name|int
name|wsize
decl_stmt|;
block|{
name|wsize
operator|=
operator|(
name|LI
operator|*
name|wsize
operator|)
operator|/
literal|100
expr_stmt|;
if|if
condition|(
name|wsize
operator|>=
literal|1
operator|&&
operator|!
name|one_windp
argument_list|()
condition|)
name|WindSize
argument_list|(
name|curwind
argument_list|,
name|wsize
operator|-
operator|(
name|curwind
operator|->
name|w_height
operator|-
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Show the current error, i.e. put the line containing the error message    in one window, and the buffer containing the actual error in another    window. */
end_comment

begin_function
name|void
name|ShowErr
parameter_list|()
block|{
name|Window
modifier|*
name|err_wind
decl_stmt|,
modifier|*
name|buf_wind
decl_stmt|;
if|if
condition|(
name|cur_error
operator|==
literal|0
condition|)
name|complain
argument_list|(
name|noerrs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|okay_error
argument_list|()
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
return|return;
block|}
name|err_wind
operator|=
name|windbp
argument_list|(
name|perr_buf
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|windbp
argument_list|(
name|cur_error
operator|->
name|er_buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|err_wind
operator|&&
operator|!
name|buf_wind
condition|)
block|{
name|SetWind
argument_list|(
name|err_wind
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|curwind
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|err_wind
operator|&&
name|buf_wind
condition|)
block|{
name|SetWind
argument_list|(
name|buf_wind
argument_list|)
expr_stmt|;
name|pop_wind
argument_list|(
name|perr_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err_wind
operator|=
name|curwind
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|err_wind
operator|&&
operator|!
name|buf_wind
condition|)
block|{
name|pop_wind
argument_list|(
name|perr_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|err_wind
operator|=
name|curwind
expr_stmt|;
name|pop_wind
argument_list|(
name|cur_error
operator|->
name|er_buf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
name|buf_wind
operator|=
name|curwind
expr_stmt|;
block|}
comment|/* Put the current error message at the top of its Window */
name|SetWind
argument_list|(
name|err_wind
argument_list|)
expr_stmt|;
name|SetLine
argument_list|(
name|cur_error
operator|->
name|er_mess
argument_list|)
expr_stmt|;
name|SetTop
argument_list|(
name|curwind
argument_list|,
operator|(
name|curwind
operator|->
name|w_line
operator|=
name|cur_error
operator|->
name|er_mess
operator|)
argument_list|)
expr_stmt|;
name|set_wsize
argument_list|(
name|EWSize
argument_list|)
expr_stmt|;
comment|/* now go to the the line with the error in the other window */
name|SetWind
argument_list|(
name|buf_wind
argument_list|)
expr_stmt|;
name|DotTo
argument_list|(
name|cur_error
operator|->
name|er_text
argument_list|,
name|cur_error
operator|->
name|er_char
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
name|ShcomBuf
index|[
name|LBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make a buffer name given the command `command', i.e. "fgrep -n foo *.c"    will return the buffer name "fgrep".  */
end_comment

begin_function
name|char
modifier|*
name|MakeName
parameter_list|(
name|command
parameter_list|)
name|char
modifier|*
name|command
decl_stmt|;
block|{
specifier|static
name|char
name|bnm
index|[
literal|50
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|bnm
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|command
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|)
condition|)
empty_stmt|;
do|do
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
do|while
condition|(
operator|(
name|c
operator|=
operator|*
name|command
operator|++
operator|)
operator|!=
literal|'\0'
operator|&&
operator|(
name|c
operator|!=
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
condition|)
do|;
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
name|strcpy
argument_list|(
name|bnm
argument_list|,
name|basename
argument_list|(
name|bnm
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|bnm
return|;
block|}
end_function

begin_comment
comment|/* Run make, first writing all the modified buffers (if the WtOnMk flag is    non-zero), parse the errors, and go the first error. */
end_comment

begin_decl_stmt
name|private
name|char
name|make_cmd
index|[
name|LBSIZE
index|]
init|=
literal|"make"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|MakeErrors
parameter_list|()
block|{
name|Window
modifier|*
name|old
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|,
name|compilation
decl_stmt|;
if|if
condition|(
name|WtOnMk
condition|)
name|put_bufs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* When we're not doing make or cc (i.e., the last command 	   was probably a grep or something) and the user just types 	   C-X C-E, he probably (possibly, hopefully, usually (in my 	   case)) doesn't want to do the grep again but rather wants 	   to do a make again; so we ring the bell and insert the 	   default command and let the person decide. */
name|compilation
operator|=
operator|(
name|sindex
argument_list|(
literal|"make"
argument_list|,
name|make_cmd
argument_list|)
operator|||
name|sindex
argument_list|(
literal|"cc"
argument_list|,
name|make_cmd
argument_list|)
operator|)
expr_stmt|;
if|if
condition|(
name|is_an_arg
argument_list|()
operator|||
operator|!
name|compilation
condition|)
block|{
if|if
condition|(
operator|!
name|compilation
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|Inputp
operator|=
name|make_cmd
expr_stmt|;
comment|/* insert the default for the user */
block|}
name|null_ncpy
argument_list|(
name|make_cmd
argument_list|,
name|ask
argument_list|(
name|make_cmd
argument_list|,
literal|"Compilation command: "
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|make_cmd
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
block|}
name|status
operator|=
name|UnixToBuf
argument_list|(
name|MakeName
argument_list|(
name|make_cmd
argument_list|)
argument_list|,
name|YES
argument_list|,
name|EWSize
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|make_cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|make_cmd
argument_list|)
expr_stmt|;
name|ErrParse
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|cur_error
condition|)
name|SetWind
argument_list|(
name|old
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|SPELL
end_ifdef

begin_function
name|private
name|void
name|SpelParse
parameter_list|(
name|bname
parameter_list|)
name|char
modifier|*
name|bname
decl_stmt|;
block|{
name|Buffer
modifier|*
name|buftospel
decl_stmt|,
modifier|*
name|wordsb
decl_stmt|;
name|char
name|wordspel
index|[
literal|100
index|]
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|struct
name|error
modifier|*
name|ep
init|=
literal|0
decl_stmt|;
name|ErrFree
argument_list|()
expr_stmt|;
comment|/* This is important! */
name|buftospel
operator|=
name|curbuf
expr_stmt|;
name|wordsb
operator|=
name|buf_exists
argument_list|(
name|bname
argument_list|)
expr_stmt|;
name|perr_buf
operator|=
name|wordsb
expr_stmt|;
comment|/* This is important (buffer containing 				   error messages) */
name|SetBuf
argument_list|(
name|wordsb
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
name|f_mess
argument_list|(
literal|"Finding misspelled words ... "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|lastp
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|swritef
argument_list|(
name|wordspel
argument_list|,
literal|"\\<%s\\>"
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|buftospel
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|wordspel
argument_list|,
literal|1
argument_list|,
literal|1
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|ep
operator|=
name|AddError
argument_list|(
name|ep
argument_list|,
name|wordsb
operator|->
name|b_dot
argument_list|,
name|buftospel
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
name|SetBuf
argument_list|(
name|wordsb
argument_list|)
expr_stmt|;
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|add_mess
argument_list|(
literal|"Done."
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|buftospel
argument_list|)
expr_stmt|;
name|ShowErr
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SpelBuffer
parameter_list|()
block|{
name|char
modifier|*
name|Spell
init|=
literal|"Spell"
decl_stmt|,
name|com
index|[
literal|100
index|]
decl_stmt|;
name|Window
modifier|*
name|savewp
init|=
name|curwind
decl_stmt|;
name|put_bufs
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|swritef
argument_list|(
name|com
argument_list|,
literal|"spell %s"
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|UnixToBuf
argument_list|(
name|Spell
argument_list|,
name|YES
argument_list|,
name|EWSize
argument_list|,
name|YES
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|com
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|message
argument_list|(
literal|"[Delete the irrelevant words and then type C-X C-C]"
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
name|Recur
argument_list|()
expr_stmt|;
name|SetWind
argument_list|(
name|savewp
argument_list|)
expr_stmt|;
name|SpelParse
argument_list|(
name|Spell
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SpelWords
parameter_list|()
block|{
name|char
modifier|*
name|buftospel
decl_stmt|;
name|Buffer
modifier|*
name|wordsb
init|=
name|curbuf
decl_stmt|;
if|if
condition|(
operator|(
name|buftospel
operator|=
name|ask_buf
argument_list|(
operator|(
name|Buffer
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
return|return;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
name|curwind
argument_list|,
name|buftospel
argument_list|)
argument_list|)
expr_stmt|;
name|SpelParse
argument_list|(
name|wordsb
operator|->
name|b_name
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* SPELL */
end_comment

begin_function
name|void
name|ShToBuf
parameter_list|()
block|{
name|char
name|bnm
index|[
literal|128
index|]
decl_stmt|,
name|cmd
index|[
literal|128
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|bnm
argument_list|,
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
literal|"Buffer: "
argument_list|)
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|cmd
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
literal|"Command: "
argument_list|)
argument_list|)
expr_stmt|;
name|DoShell
argument_list|(
name|bnm
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ShellCom
parameter_list|()
block|{
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|DoShell
argument_list|(
name|MakeName
argument_list|(
name|ShcomBuf
argument_list|)
argument_list|,
name|ShcomBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ShNoBuf
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|NO
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|ShcomBuf
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|ShcomBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Shtypeout
parameter_list|()
block|{
name|int
name|status
decl_stmt|;
name|null_ncpy
argument_list|(
name|ShcomBuf
argument_list|,
name|ask
argument_list|(
name|ShcomBuf
argument_list|,
name|ProcFmt
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|ShcomBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|YES
argument_list|,
literal|0
argument_list|,
name|NO
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|ShcomBuf
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|Typeout
argument_list|(
literal|"[%s: completed successfully]"
argument_list|,
name|ShcomBuf
argument_list|)
expr_stmt|;
else|else
name|Typeout
argument_list|(
literal|"[%s: exited (%d)]"
argument_list|,
name|ShcomBuf
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|TOstop
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Run the shell command into `bnm'.  Empty the buffer except when we    give a numeric argument, in which case it inserts the output at the    current position in the buffer.  */
end_comment

begin_function
name|private
name|void
name|DoShell
parameter_list|(
name|bnm
parameter_list|,
name|command
parameter_list|)
name|char
modifier|*
name|bnm
decl_stmt|,
decl|*
name|command
decl_stmt|;
end_function

begin_block
block|{
name|Window
modifier|*
name|savewp
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|;
name|status
operator|=
name|UnixToBuf
argument_list|(
name|bnm
argument_list|,
name|YES
argument_list|,
literal|0
argument_list|,
operator|!
name|is_an_arg
argument_list|()
argument_list|,
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|command
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|com_finish
argument_list|(
name|status
argument_list|,
name|command
argument_list|)
expr_stmt|;
name|SetWind
argument_list|(
name|savewp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|void
name|com_finish
parameter_list|(
name|status
parameter_list|,
name|cmd
parameter_list|)
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|s_mess
argument_list|(
literal|"[%s: "
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
operator|==
literal|0
condition|)
name|add_mess
argument_list|(
literal|"completed successfully"
argument_list|)
expr_stmt|;
else|else
name|add_mess
argument_list|(
literal|"exited (%d)"
argument_list|,
name|status
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|"]"
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_function
name|void
name|dowait
parameter_list|(
name|pid
parameter_list|,
name|status
parameter_list|)
name|int
name|pid
decl_stmt|,
decl|*
name|status
decl_stmt|;
end_function

begin_block
block|{
ifndef|#
directive|ifndef
name|IPROCS
name|int
name|rpid
decl_stmt|;
while|while
condition|(
operator|(
name|rpid
operator|=
name|wait
argument_list|(
name|status
argument_list|)
operator|)
operator|!=
name|pid
condition|)
empty_stmt|;
else|#
directive|else
include|#
directive|include
file|"wait.h"
name|union
name|wait
name|w
decl_stmt|;
name|int
name|rpid
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|WAIT3
name|rpid
operator|=
name|wait2
argument_list|(
operator|&
name|w
operator|.
name|w_status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|#
directive|else
name|rpid
operator|=
name|wait3
argument_list|(
operator|&
name|w
argument_list|,
literal|0
argument_list|,
operator|(
expr|struct
name|rusage
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|rpid
operator|==
operator|-
literal|1
condition|)
break|break;
elseif|else
if|if
condition|(
name|rpid
operator|==
name|pid
condition|)
block|{
if|if
condition|(
name|status
condition|)
operator|*
name|status
operator|=
name|w
operator|.
name|w_status
expr_stmt|;
break|break;
block|}
else|else
name|kill_off
argument_list|(
name|rpid
argument_list|,
name|w
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* IPROCS */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_comment
comment|/* Run the command to bnm, erase the buffer if clobber is non-zero,    and redisplay if disp is non-zero.  Leaves current buffer in `bnm'    and leaves any windows it creates lying around.  It's up to the caller    to fix everything up after we're done.  (Usually there's nothing to    fix up.) */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|STDARGS
end_ifdef

begin_function
name|int
name|UnixToBuf
parameter_list|(
name|char
modifier|*
name|bnm
parameter_list|,
name|int
name|disp
parameter_list|,
name|int
name|wsize
parameter_list|,
name|int
name|clobber
parameter_list|,
modifier|...
parameter_list|)
else|#
directive|else
comment|/*VARARGS4*/
function|int UnixToBuf
parameter_list|(
name|bnm
parameter_list|,
name|disp
parameter_list|,
name|wsize
parameter_list|,
name|clobber
parameter_list|,
name|va_alist
parameter_list|)
name|char
modifier|*
name|bnm
decl_stmt|;
name|int
name|disp
decl_stmt|;
name|int
name|wsize
decl_stmt|;
name|int
name|clobber
decl_stmt|;
function|va_dcl
endif|#
directive|endif
block|{
ifndef|#
directive|ifndef
name|MSDOS
name|int
name|p
index|[
literal|2
index|]
decl_stmt|,
name|pid
decl_stmt|,
name|status
decl_stmt|,
else|#
directive|else
comment|/* MSDOS */
name|int
name|p0
decl_stmt|,
name|oldo
decl_stmt|,
name|olde
decl_stmt|,
name|retcode
decl_stmt|,
endif|#
directive|endif
comment|/* MSDOS */
name|eof
decl_stmt|;
name|va_list
name|ap
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|32
index|]
decl_stmt|,
modifier|*
name|mess
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|SIGRESULT
argument_list|(
argument|*old_int
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
expr_stmt|;
name|va_init
argument_list|(
name|ap
argument_list|,
name|clobber
argument_list|)
expr_stmt|;
name|make_argv
argument_list|(
name|argv
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
if|if
condition|(
name|bnm
operator|!=
literal|0
operator|&&
name|clobber
operator|==
name|YES
condition|)
name|isprocbuf
argument_list|(
name|bnm
argument_list|)
expr_stmt|;
if|if
condition|(
name|disp
condition|)
block|{
if|if
condition|(
name|bnm
operator|!=
literal|0
condition|)
name|message
argument_list|(
literal|"Starting up..."
argument_list|)
expr_stmt|;
else|else
block|{
name|TOstart
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Starting up..."
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|bnm
operator|!=
literal|0
condition|)
block|{
name|pop_wind
argument_list|(
name|bnm
argument_list|,
name|clobber
argument_list|,
name|clobber
condition|?
name|B_PROCESS
else|:
name|B_FILE
argument_list|)
expr_stmt|;
name|set_wsize
argument_list|(
name|wsize
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* Now I will attempt to describe how I deal with signals during 	   the execution of the shell command.  My desire was to be able 	   to interrupt the shell command AS SOON AS the window pops up. 	   So, if we have JOB_CONTROL (i.e., the new signal mechanism) I 	   hold SIGINT, meaning if we interrupt now, we will eventually 	   see the interrupt, but not before we are ready for it.  We 	   fork, the child releases the interrupt, it then sees the 	   interrupt, and so exits.  Meanwhile the parent ignores the 	   signal, so if there was a pending one, it's now lost.  	   With no JOB_CONTROL, the best behavior you can expect is, when 	   you type ^] too very quickly after the window pops up, it may 	   be ignored.  The behavior BEFORE was that it would interrupt 	   JOVE and then you would have to continue JOVE and wait a 	   little while longer before trying again.  Now that is fixed, 	   in that you just have to type it twice. */
ifndef|#
directive|ifndef
name|MSDOS
ifdef|#
directive|ifdef
name|IPROCS
name|SigHold
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|JOB_CONTROL
name|SigHold
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
else|#
directive|else
name|old_int
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|,
endif|#
directive|endif
name|dopipe
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|pid
operator|=
name|vfork
argument_list|()
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|complain
argument_list|(
literal|"[Fork failed]"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|==
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|BSD_SIGS
comment|/* 		 * We want to release SIGCHLD and SIGINT in the child, but 		 * we can't use SigRelse because that would change Jove's 		 * copy of the SigMask variable (because we're in a 		 * vfork).  So we simply set set the mask directly.  There 		 * are several other forks in Jove, but this is the only 		 * one we execute often enough to make it worth using a 		 * vfork. 		 */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sigsetmask
argument_list|(
name|SigMask
operator|&
operator|~
operator|(
name|sigmask
argument_list|(
name|SIGCHLD
argument_list|)
operator||
name|sigmask
argument_list|(
name|SIGINT
argument_list|)
operator|)
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* BSD_SIGS */
ifdef|#
directive|ifdef
name|IPROCS
name|SigRelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
comment|/* don't know if this matters */
endif|#
directive|endif
comment|/* IPROCS */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOB_CONTROL
name|SigRelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* BSD_SIGS */
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|open
argument_list|(
literal|"/dev/null"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
literal|"Execl failed.\n"
argument_list|,
operator|(
name|size_t
operator|)
literal|14
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|JOB_CONTROL
name|old_int
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fd_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|F_READ
argument_list|,
name|p
index|[
literal|0
index|]
argument_list|,
name|iobuff
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
if|if
condition|(
operator|(
name|p0
operator|=
name|openforpipe
argument_list|()
operator|)
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"cannot make pipe for filter"
argument_list|)
expr_stmt|;
name|oldo
operator|=
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|olde
operator|=
name|dup
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|retcode
operator|=
name|spawnv
argument_list|(
literal|0
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
operator|&
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|p0
operator|=
name|reopenforpipe
argument_list|()
expr_stmt|;
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|oldo
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|olde
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|oldo
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|olde
argument_list|)
expr_stmt|;
if|if
condition|(
name|retcode
operator|<
literal|0
condition|)
name|complain
argument_list|(
literal|"[Spawn failed]"
argument_list|)
expr_stmt|;
name|fp
operator|=
name|fd_open
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|F_READ
argument_list|,
name|p0
argument_list|,
name|iobuff
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
do|do
block|{
ifndef|#
directive|ifndef
name|MSDOS
name|inIOread
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
name|eof
operator|=
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
operator|(
name|size_t
operator|)
name|LBSIZE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|inIOread
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|bnm
operator|!=
literal|0
condition|)
block|{
name|ins_str
argument_list|(
name|genbuf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof
condition|)
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|disp
operator|==
name|YES
condition|)
name|Typeout
argument_list|(
literal|"%s"
argument_list|,
name|genbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|bnm
operator|!=
literal|0
operator|&&
name|disp
operator|!=
literal|0
operator|&&
name|fp
operator|->
name|f_cnt
operator|<=
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|LOAD_AV
block|{
name|double
name|theavg
decl_stmt|;
name|get_la
argument_list|(
operator|&
name|theavg
argument_list|)
expr_stmt|;
if|if
condition|(
name|theavg
operator|<
literal|2.0
condition|)
name|mess
operator|=
literal|"Screaming along..."
expr_stmt|;
elseif|else
if|if
condition|(
name|theavg
operator|<
literal|5.0
condition|)
name|mess
operator|=
literal|"Chugging along..."
expr_stmt|;
else|else
name|mess
operator|=
literal|"Crawling along..."
expr_stmt|;
block|}
else|#
directive|else
name|mess
operator|=
literal|"Chugging along..."
expr_stmt|;
endif|#
directive|endif
comment|/* LOAD_AV */
if|if
condition|(
name|bnm
operator|!=
literal|0
condition|)
block|{
name|message
argument_list|(
name|mess
argument_list|)
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
block|}
block|}
block|}
do|while
condition|(
operator|!
name|eof
condition|)
do|;
if|if
condition|(
name|disp
condition|)
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|dowait
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|JOB_CONTROL
operator|(
name|void
operator|)
name|SigRelse
argument_list|(
name|SIGINT
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* MSDOS */
name|closepipe
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|old_int
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
ifdef|#
directive|ifdef
name|IPROCS
name|SigRelse
argument_list|(
name|SIGCHLD
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return
name|status
return|;
else|#
directive|else
comment|/* MSDOS */
name|getCWD
argument_list|()
expr_stmt|;
return|return
name|retcode
return|;
endif|#
directive|endif
comment|/* MSDOS */
block|}
end_function

begin_comment
comment|/* Send the current region to CMD and insert the output from the    command into OUT_BUF. */
end_comment

begin_function
name|void
name|RegToUnix
parameter_list|(
name|outbuf
parameter_list|,
name|cmd
parameter_list|)
name|Buffer
modifier|*
name|outbuf
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
block|{
name|Mark
modifier|*
name|m
init|=
name|CurMark
argument_list|()
decl_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
specifier|static
name|char
name|tnambuf
index|[
literal|20
index|]
decl_stmt|;
name|char
modifier|*
name|tname
decl_stmt|,
name|combuf
index|[
literal|128
index|]
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|Window
modifier|*
name|save_wind
init|=
name|curwind
decl_stmt|;
name|int
name|status
decl_stmt|,
name|err
init|=
name|NO
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|int
name|p0
decl_stmt|,
name|oldi
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|File
modifier|*
name|fp
decl_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|strcpy
argument_list|(
name|tnambuf
argument_list|,
literal|"/tmp/jfilterXXXXXX"
argument_list|)
expr_stmt|;
name|tname
operator|=
name|mktemp
argument_list|(
name|tnambuf
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|tname
argument_list|,
name|iobuff
argument_list|,
name|F_WRITE
argument_list|,
name|YES
argument_list|,
name|YES
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|p0
operator|=
name|openforpipe
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|CATCH
ifdef|#
directive|ifdef
name|MSDOS
name|fp
init|=
name|fd_open
argument_list|(
name|cmd
argument_list|,
name|F_WRITE
argument_list|,
name|p0
argument_list|,
name|iobuff
argument_list|,
name|LBSIZE
argument_list|)
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|putreg
argument_list|(
name|fp
argument_list|,
name|m
operator|->
name|m_line
argument_list|,
name|m
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|DelReg
argument_list|()
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|swritef
argument_list|(
name|combuf
argument_list|,
literal|"%s< %s"
argument_list|,
name|cmd
argument_list|,
name|tname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|p0
operator|=
name|reopenforpipe
argument_list|()
expr_stmt|;
name|oldi
operator|=
name|dup
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|dup
argument_list|(
name|p0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|p0
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|status
operator|=
name|UnixToBuf
argument_list|(
name|outbuf
operator|->
name|b_name
argument_list|,
name|NO
argument_list|,
literal|0
argument_list|,
name|outbuf
operator|->
name|b_type
operator|==
name|B_SCRATCH
argument_list|,
ifndef|#
directive|ifndef
name|MSDOS
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|combuf
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
else|#
directive|else
comment|/* MSDOS */
name|Shell
argument_list|,
name|ShFlags
argument_list|,
name|cmd
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
endif|#
directive|endif
comment|/* MSDOS */
argument_list|)
expr_stmt|;
name|ONERROR
name|err
init|=
name|YES
decl_stmt|;
name|ENDCATCH
ifndef|#
directive|ifndef
name|MSDOS
name|f_close
argument_list|(
name|fp
argument_list|)
decl_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|open
argument_list|(
literal|"con"
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* dup(oldi);	*/
name|close
argument_list|(
name|oldi
argument_list|)
expr_stmt|;
name|closepipe
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|SetWind
argument_list|(
name|save_wind
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|NO
condition|)
ifndef|#
directive|ifndef
name|MSDOS
name|com_finish
argument_list|(
name|status
argument_list|,
name|combuf
argument_list|)
expr_stmt|;
else|#
directive|else
name|com_finish
argument_list|(
name|status
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|FilterRegion
parameter_list|()
block|{
specifier|static
name|char
name|FltComBuf
index|[
name|LBSIZE
index|]
decl_stmt|;
name|null_ncpy
argument_list|(
name|FltComBuf
argument_list|,
name|ask
argument_list|(
name|FltComBuf
argument_list|,
literal|": %f (through command) "
argument_list|)
argument_list|,
operator|(
sizeof|sizeof
name|FltComBuf
operator|)
operator|-
literal|1
argument_list|)
expr_stmt|;
name|RegToUnix
argument_list|(
name|curbuf
argument_list|,
name|FltComBuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|isprocbuf
parameter_list|(
name|bnm
parameter_list|)
name|char
modifier|*
name|bnm
decl_stmt|;
block|{
name|Buffer
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|buf_exists
argument_list|(
name|bnm
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|bp
operator|->
name|b_type
operator|!=
name|B_PROCESS
condition|)
name|confirm
argument_list|(
literal|"Over-write buffer %s?"
argument_list|,
name|bnm
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_comment
comment|/*	msdos specific hacks to allow for pipes */
end_comment

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_decl_stmt
specifier|static
name|char
name|pipeiname
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pipeoname
index|[
literal|64
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pipehandle
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|openforpipe
parameter_list|()
block|{
name|swritef
argument_list|(
name|pipeiname
argument_list|,
literal|"%s/%s"
argument_list|,
name|TmpFilePath
argument_list|,
literal|"Jove-I"
argument_list|)
expr_stmt|;
name|swritef
argument_list|(
name|pipeoname
argument_list|,
literal|"%s/%s"
argument_list|,
name|TmpFilePath
argument_list|,
literal|"Jove-O"
argument_list|)
expr_stmt|;
return|return
operator|(
name|pipehandle
operator|=
name|creat
argument_list|(
name|pipeoname
argument_list|,
name|S_IWRITE
operator||
name|S_IREAD
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|private
name|int
name|reopenforpipe
parameter_list|()
block|{
name|close
argument_list|(
name|pipehandle
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pipeiname
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|pipeoname
argument_list|,
name|pipeiname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|pipehandle
operator|=
name|open
argument_list|(
name|pipeiname
argument_list|,
literal|0
argument_list|)
operator|)
operator|>=
literal|0
condition|)
return|return
operator|(
name|pipehandle
operator|)
return|;
name|closepipe
argument_list|()
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|closepipe
parameter_list|()
block|{
name|unlink
argument_list|(
name|pipeoname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|pipeiname
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
name|switchar
parameter_list|()
block|{
name|union
name|REGS
name|regs
decl_stmt|;
name|regs
operator|.
name|h
operator|.
name|ah
operator|=
literal|0x37
expr_stmt|;
name|regs
operator|.
name|h
operator|.
name|al
operator|=
literal|0
expr_stmt|;
name|intdos
argument_list|(
operator|&
name|regs
argument_list|,
operator|&
name|regs
argument_list|)
expr_stmt|;
return|return
operator|(
name|regs
operator|.
name|h
operator|.
name|dl
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

end_unit

