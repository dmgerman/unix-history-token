begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* Contains commands for C mode.  Paren matching routines are in here. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_decl_stmt
name|private
name|int
name|backslashed
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
if|#
directive|if
name|defined
argument_list|(
name|CMT_FMT
argument_list|)
name|FillComment
name|proto
argument_list|(
operator|(
name|char
operator|*
name|format
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|do_expr
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
name|FindMatch
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|parse_cmt_fmt
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|strip_c
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|FSexpr
argument_list|()
decl_stmt|,
name|FList
argument_list|()
decl_stmt|,
name|BSexpr
argument_list|()
decl_stmt|,
name|BList
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|backslashed
parameter_list|(
name|lp
parameter_list|,
name|cpos
parameter_list|)
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|cpos
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|cpos
operator|>
literal|0
operator|&&
name|lp
index|[
operator|--
name|cpos
index|]
operator|==
literal|'\\'
condition|)
name|cnt
operator|+=
literal|1
expr_stmt|;
return|return
operator|(
name|cnt
operator|%
literal|2
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|private
name|char
modifier|*
name|p_types
init|=
literal|"(){}[]"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|mp_kind
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|MP_OKAY
value|0
end_define

begin_define
define|#
directive|define
name|MP_MISMATCH
value|1
end_define

begin_define
define|#
directive|define
name|MP_UNBALANCED
value|2
end_define

begin_define
define|#
directive|define
name|MP_INCOMMENT
value|3
end_define

begin_function
name|void
name|mp_error
parameter_list|()
block|{
switch|switch
condition|(
name|mp_kind
condition|)
block|{
case|case
name|MP_MISMATCH
case|:
name|message
argument_list|(
literal|"[Mismatched parentheses]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MP_UNBALANCED
case|:
name|message
argument_list|(
literal|"[Unbalanced parenthesis]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MP_INCOMMENT
case|:
name|message
argument_list|(
literal|"[Inside a comment]"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MP_OKAY
case|:
default|default:
return|return;
block|}
name|rbell
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Search from the current position for the paren that matches p_type.    Search in the direction dir.  If can_mismatch is YES then it is okay    to have mismatched parens.  If stop_early is YES then when an open    paren is found at the beginning of a line, it is assumed that there    is no point in backing up further.  This is so when you hit tab or    LineFeed outside, in-between procedure/function definitions, it won't    sit there searching all the way to the beginning of the file for a    match that doesn't exist.  {forward,backward}-s-expression are the    only ones that insist on getting the "true" story. */
end_comment

begin_function
name|Bufpos
modifier|*
name|m_paren
parameter_list|(
name|p_type
parameter_list|,
name|dir
parameter_list|,
name|can_mismatch
parameter_list|,
name|can_stop
parameter_list|)
name|int
name|p_type
decl_stmt|;
specifier|register
name|int
name|dir
decl_stmt|;
name|int
name|can_mismatch
decl_stmt|;
name|int
name|can_stop
decl_stmt|;
block|{
specifier|static
name|Bufpos
name|ret
decl_stmt|;
name|Bufpos
name|savedot
decl_stmt|,
modifier|*
name|sp
decl_stmt|;
name|struct
name|RE_block
name|re_blk
decl_stmt|;
name|int
name|count
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|,
name|c
decl_stmt|;
name|char
name|p_match
decl_stmt|,
name|re_str
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|cp
decl_stmt|,
name|quote_c
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|c_char
decl_stmt|;
name|int
name|in_comment
init|=
operator|-
literal|1
decl_stmt|,
name|stopped
init|=
name|NO
decl_stmt|;
name|swritef
argument_list|(
name|re_str
argument_list|,
literal|"[(){}[\\]%s]"
argument_list|,
operator|(
name|MajorMode
argument_list|(
name|CMODE
argument_list|)
operator|)
condition|?
literal|"/\"'"
else|:
literal|"\""
argument_list|)
expr_stmt|;
name|REcompile
argument_list|(
name|re_str
argument_list|,
literal|1
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|p_types
argument_list|,
name|p_type
argument_list|)
operator|)
operator|!=
name|NIL
condition|)
name|p_match
operator|=
name|cp
index|[
name|dir
index|]
expr_stmt|;
else|else
name|complain
argument_list|(
literal|"[Cannot match %c's]"
argument_list|,
name|p_type
argument_list|)
expr_stmt|;
name|DOTsave
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
comment|/* To make things a little faster I avoid copying lines into 	   linebuf by setting curline and curchar by hand.  Warning: 	   this is slightly to very risky.  When I did this there were 	   lots of problems with procedures that expect the contents of 	   curline to be in linebuf. */
while|while
condition|(
name|count
operator|>=
literal|0
condition|)
block|{
name|sp
operator|=
name|docompiled
argument_list|(
name|dir
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
condition|)
break|break;
name|lp
operator|=
name|lbptr
argument_list|(
name|sp
operator|->
name|p_line
argument_list|)
expr_stmt|;
name|curline
operator|=
name|sp
operator|->
name|p_line
expr_stmt|;
name|curchar
operator|=
name|sp
operator|->
name|p_char
expr_stmt|;
comment|/* here's where I cheat */
name|c_char
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
name|c_char
operator|-=
literal|1
expr_stmt|;
if|if
condition|(
name|backslashed
argument_list|(
name|lp
argument_list|,
name|c_char
argument_list|)
condition|)
continue|continue;
name|c
operator|=
name|lp
index|[
name|c_char
index|]
expr_stmt|;
comment|/* check if this is a comment (if we're not inside quotes) */
if|if
condition|(
name|quote_c
operator|==
literal|0
operator|&&
name|c
operator|==
literal|'/'
condition|)
block|{
name|int
name|new_ic
init|=
name|in_comment
decl_stmt|;
comment|/* close comment */
if|if
condition|(
operator|(
name|c_char
operator|!=
literal|0
operator|)
operator|&&
name|lp
index|[
name|c_char
operator|-
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|new_ic
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|NO
else|:
name|YES
expr_stmt|;
if|if
condition|(
name|new_ic
operator|==
name|NO
operator|&&
name|in_comment
operator|==
operator|-
literal|1
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|quote_c
operator|=
literal|0
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|lp
index|[
name|c_char
operator|+
literal|1
index|]
operator|==
literal|'*'
condition|)
block|{
name|new_ic
operator|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|YES
else|:
name|NO
expr_stmt|;
if|if
condition|(
name|new_ic
operator|==
name|NO
operator|&&
name|in_comment
operator|==
operator|-
literal|1
condition|)
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|quote_c
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|in_comment
operator|=
name|new_ic
expr_stmt|;
block|}
if|if
condition|(
name|in_comment
operator|==
name|YES
condition|)
continue|continue;
if|if
condition|(
name|c
operator|==
literal|'"'
operator|||
name|c
operator|==
literal|'\''
condition|)
block|{
if|if
condition|(
name|quote_c
operator|==
name|c
condition|)
name|quote_c
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|quote_c
operator|==
literal|0
condition|)
name|quote_c
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|quote_c
operator|!=
literal|0
condition|)
continue|continue;
if|if
condition|(
name|isopenp
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|count
operator|+=
name|dir
expr_stmt|;
if|if
condition|(
name|c_char
operator|==
literal|0
operator|&&
name|can_stop
operator|==
name|YES
operator|&&
name|count
operator|>=
literal|0
condition|)
block|{
name|stopped
operator|=
name|YES
expr_stmt|;
break|break;
block|}
block|}
elseif|else
if|if
condition|(
name|isclosep
argument_list|(
name|c
argument_list|)
condition|)
name|count
operator|-=
name|dir
expr_stmt|;
block|}
name|ret
operator|.
name|p_line
operator|=
name|curline
expr_stmt|;
name|ret
operator|.
name|p_char
operator|=
name|curchar
expr_stmt|;
name|curline
operator|=
name|savedot
operator|.
name|p_line
expr_stmt|;
name|curchar
operator|=
name|savedot
operator|.
name|p_char
expr_stmt|;
comment|/* here's where I undo it */
if|if
condition|(
name|count
operator|>=
literal|0
condition|)
name|mp_kind
operator|=
name|MP_UNBALANCED
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|!=
name|p_match
condition|)
name|mp_kind
operator|=
name|MP_MISMATCH
expr_stmt|;
else|else
name|mp_kind
operator|=
name|MP_OKAY
expr_stmt|;
comment|/* If we stopped (which means we were allowed to stop) and there 	   was an error, we clear the error so no error message is printed. 	   An error should be printed ONLY when we are sure about the fact, 	   namely we didn't stop prematurely HOPING that it was the right 	   answer. */
if|if
condition|(
name|stopped
operator|&&
name|mp_kind
operator|!=
name|MP_OKAY
condition|)
block|{
name|mp_kind
operator|=
name|MP_OKAY
expr_stmt|;
return|return
literal|0
return|;
block|}
if|if
condition|(
name|mp_kind
operator|==
name|MP_OKAY
operator|||
operator|(
name|mp_kind
operator|==
name|MP_MISMATCH
operator|&&
name|can_mismatch
operator|==
name|YES
operator|)
condition|)
return|return
operator|&
name|ret
return|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|private
name|void
name|do_expr
parameter_list|(
name|dir
parameter_list|,
name|skip_words
parameter_list|)
specifier|register
name|int
name|dir
decl_stmt|;
name|int
name|skip_words
decl_stmt|;
block|{
specifier|register
name|char
name|c
decl_stmt|,
name|syntax
init|=
operator|(
name|dir
operator|==
name|FORWARD
operator|)
condition|?
name|_Op
else|:
name|_Cl
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|BACKWARD
condition|)
name|b_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|c
operator|=
name|linebuf
index|[
name|curchar
index|]
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|skip_words
operator|&&
name|ismword
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|WITH_TABLE
argument_list|(
argument|curbuf->b_major
argument_list|)
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
name|f_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|b_word
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|END_TABLE
argument_list|()
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|has_syntax
argument_list|(
name|c
argument_list|,
name|syntax
argument_list|)
condition|)
block|{
name|FindMatch
argument_list|(
name|dir
argument_list|)
expr_stmt|;
break|break;
block|}
name|f_char
argument_list|(
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|eobp
argument_list|()
operator|||
name|bobp
argument_list|()
condition|)
return|return;
name|c
operator|=
name|linebuf
index|[
name|curchar
index|]
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|FSexpr
parameter_list|()
block|{
specifier|register
name|int
name|num
init|=
name|arg_value
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|set_arg_value
argument_list|(
operator|-
name|num
argument_list|)
expr_stmt|;
name|BSexpr
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
name|do_expr
argument_list|(
name|FORWARD
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FList
parameter_list|()
block|{
specifier|register
name|int
name|num
init|=
name|arg_value
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|set_arg_value
argument_list|(
operator|-
name|num
argument_list|)
expr_stmt|;
name|BList
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
name|do_expr
argument_list|(
name|FORWARD
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BSexpr
parameter_list|()
block|{
specifier|register
name|int
name|num
init|=
name|arg_value
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|negate_arg_value
argument_list|()
expr_stmt|;
name|FSexpr
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
name|do_expr
argument_list|(
name|BACKWARD
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BList
parameter_list|()
block|{
specifier|register
name|int
name|num
init|=
name|arg_value
argument_list|()
decl_stmt|;
if|if
condition|(
name|num
operator|<
literal|0
condition|)
block|{
name|negate_arg_value
argument_list|()
expr_stmt|;
name|FList
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|num
operator|>=
literal|0
condition|)
name|do_expr
argument_list|(
name|BACKWARD
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|BUpList
parameter_list|()
block|{
name|Bufpos
modifier|*
name|mp
decl_stmt|;
name|char
name|c
init|=
operator|(
name|MajorMode
argument_list|(
name|CMODE
argument_list|)
condition|?
literal|'}'
else|:
literal|')'
operator|)
decl_stmt|;
name|mp
operator|=
name|m_paren
argument_list|(
name|c
argument_list|,
name|BACKWARD
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|mp
operator|==
literal|0
condition|)
name|mp_error
argument_list|()
expr_stmt|;
else|else
name|SetDot
argument_list|(
name|mp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FDownList
parameter_list|()
block|{
name|Bufpos
modifier|*
name|sp
decl_stmt|;
name|char
modifier|*
name|sstr
init|=
operator|(
name|MajorMode
argument_list|(
name|CMODE
argument_list|)
condition|?
literal|"[{([\\])}]"
else|:
literal|"[()]"
operator|)
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|sp
operator|=
name|dosearch
argument_list|(
name|sstr
argument_list|,
name|FORWARD
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|!=
literal|0
condition|)
name|lp
operator|=
name|lcontents
argument_list|(
name|sp
operator|->
name|p_line
argument_list|)
expr_stmt|;
if|if
condition|(
name|sp
operator|==
literal|0
operator|||
name|has_syntax
argument_list|(
name|lp
index|[
name|sp
operator|->
name|p_char
operator|-
literal|1
index|]
argument_list|,
name|_Cl
argument_list|)
condition|)
name|complain
argument_list|(
literal|"[No contained expression]"
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|sp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Move to the matching brace or paren depending on the current position    in the buffer. */
end_comment

begin_function
name|private
name|void
name|FindMatch
parameter_list|(
name|dir
parameter_list|)
name|int
name|dir
decl_stmt|;
block|{
specifier|register
name|Bufpos
modifier|*
name|bp
decl_stmt|;
specifier|register
name|char
name|c
init|=
name|linebuf
index|[
name|curchar
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|strchr
argument_list|(
name|p_types
argument_list|,
name|c
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|backslashed
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|)
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
name|f_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|bp
operator|=
name|m_paren
argument_list|(
name|c
argument_list|,
name|dir
argument_list|,
name|YES
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
name|b_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|0
condition|)
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|mp_error
argument_list|()
expr_stmt|;
comment|/* if there is an error the user wants to 			   know about it */
block|}
end_function

begin_define
define|#
directive|define
name|ALIGN_ARGS
value|(-1)
end_define

begin_comment
comment|/* If CArgIndent == ALIGN_ARGS then the indentation routine will    indent a continued line by lining it up with the first argument.    Otherwise, it will indent CArgIndent characters past the indent    of the first line of the procedure call. */
end_comment

begin_decl_stmt
name|int
name|CArgIndent
init|=
name|ALIGN_ARGS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indent for C code */
end_comment

begin_function
name|Bufpos
modifier|*
name|c_indent
parameter_list|(
name|brace
parameter_list|)
name|int
name|brace
decl_stmt|;
block|{
name|Bufpos
modifier|*
name|bp
decl_stmt|;
name|int
name|new_indent
init|=
literal|0
decl_stmt|,
name|current_indent
decl_stmt|,
name|increment
decl_stmt|;
if|if
condition|(
name|brace
operator|==
name|NO
condition|)
name|increment
operator|=
name|CIndIncrmt
expr_stmt|;
else|else
name|increment
operator|=
literal|0
expr_stmt|;
comment|/* Find matching paren, which may be a mismatch now.  If it 	   is not a matching curly brace then it is a paren (most likely). 	   In that case we try to line up the arguments to a procedure 	   or inside an of statement. */
if|if
condition|(
operator|(
name|bp
operator|=
name|m_paren
argument_list|(
literal|'}'
argument_list|,
name|BACKWARD
argument_list|,
name|YES
argument_list|,
name|YES
argument_list|)
operator|)
operator|!=
name|NIL
condition|)
block|{
name|Bufpos
name|save
decl_stmt|;
name|int
name|matching_indent
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* go to matching paren */
name|ToIndent
argument_list|()
expr_stmt|;
name|matching_indent
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|linebuf
index|[
name|curchar
index|]
condition|)
block|{
case|case
literal|'{'
case|:
name|new_indent
operator|=
name|matching_indent
expr_stmt|;
if|if
condition|(
operator|!
name|bolp
argument_list|()
condition|)
block|{
name|b_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* If we're not within the indent then we 				   can assume that there is either a C keyword 				   line DO on the line before the brace, or 				   there is a parenthesized expression.  If 				   that's the case we want to go backward 				   over that to the beginning of the expression 				   so that we can get the correct indent for 				   this matching brace.  This handles wrapped 				   if statements, etc. */
if|if
condition|(
operator|!
name|within_indent
argument_list|()
condition|)
block|{
name|Bufpos
name|savematch
decl_stmt|;
name|savematch
operator|=
operator|*
name|bp
expr_stmt|;
name|do_expr
argument_list|(
name|BACKWARD
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|ToIndent
argument_list|()
expr_stmt|;
name|new_indent
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
comment|/* do_expr() calls b_paren, which 					   returns a pointer to a structure, 					   and that pointer is in BP so we 					   have to save away the matching 					   paren and restore it in the 					   following line ... sigh */
operator|*
name|bp
operator|=
name|savematch
expr_stmt|;
block|}
block|}
if|if
condition|(
name|brace
operator|==
name|NO
condition|)
name|new_indent
operator|+=
operator|(
name|increment
operator|-
operator|(
name|new_indent
operator|%
name|increment
operator|)
operator|)
expr_stmt|;
break|break;
case|case
literal|'('
case|:
if|if
condition|(
name|CArgIndent
operator|==
name|ALIGN_ARGS
condition|)
block|{
name|f_char
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|new_indent
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
else|else
name|new_indent
operator|=
name|matching_indent
operator|+
name|CArgIndent
expr_stmt|;
break|break;
block|}
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
block|}
comment|/* new_indent is the "correct" place to indent.  Now we check to 	   see if what we consider as the correct place to indent is to 	   the LEFT of where we already are.  If it is, and we are NOT 	   handling a brace, then we assume that the person wants to tab 	   in further than what we think is right (for some reason) and 	   so we allow that. */
name|ToIndent
argument_list|()
expr_stmt|;
name|current_indent
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|brace
operator|==
name|NO
operator|&&
name|new_indent
operator|<=
name|current_indent
condition|)
name|new_indent
operator|=
name|current_indent
operator|+
operator|(
name|increment
operator|-
operator|(
name|current_indent
operator|%
name|increment
operator|)
operator|)
expr_stmt|;
name|Bol
argument_list|()
expr_stmt|;
name|DelWtSpace
argument_list|()
expr_stmt|;
comment|/* nice uniform Tabs*Space* */
name|n_indent
argument_list|(
name|new_indent
argument_list|)
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|re_indent
parameter_list|(
name|incr
parameter_list|)
name|int
name|incr
decl_stmt|;
block|{
name|Line
modifier|*
name|l1
decl_stmt|,
modifier|*
name|l2
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|int
name|c1
decl_stmt|,
name|c2
decl_stmt|;
name|Mark
modifier|*
name|m
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|Bufpos
name|savedot
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
name|l1
operator|=
name|curline
expr_stmt|;
name|c1
operator|=
name|curchar
expr_stmt|;
name|l2
operator|=
name|m
operator|->
name|m_line
expr_stmt|;
name|c2
operator|=
name|m
operator|->
name|m_char
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|l1
argument_list|,
operator|&
name|c1
argument_list|,
operator|&
name|l2
argument_list|,
operator|&
name|c2
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|l1
init|;
name|lp
operator|!=
name|l2
operator|->
name|l_next
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
name|int
name|indent
decl_stmt|;
name|SetLine
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|ToIndent
argument_list|()
expr_stmt|;
name|indent
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|!=
literal|0
operator|||
name|linebuf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|n_indent
argument_list|(
name|indent
operator|+
name|incr
argument_list|)
expr_stmt|;
block|}
name|SetDot
argument_list|(
operator|&
name|savedot
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|LRShift
parameter_list|()
block|{
name|int
name|amnt
decl_stmt|;
if|if
condition|(
name|is_an_arg
argument_list|()
condition|)
name|amnt
operator|=
name|arg_value
argument_list|()
expr_stmt|;
else|else
name|amnt
operator|=
name|CIndIncrmt
expr_stmt|;
name|re_indent
argument_list|(
operator|-
name|amnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RRShift
parameter_list|()
block|{
name|int
name|amnt
decl_stmt|;
if|if
condition|(
name|is_an_arg
argument_list|()
condition|)
name|amnt
operator|=
name|arg_value
argument_list|()
expr_stmt|;
else|else
name|amnt
operator|=
name|CIndIncrmt
expr_stmt|;
name|re_indent
argument_list|(
name|amnt
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CMT_FMT
argument_list|)
end_if

begin_decl_stmt
name|char
name|CmtFmt
index|[
literal|80
index|]
init|=
literal|"/*%n%! * %c%!%n */"
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|Comment
parameter_list|()
block|{
name|FillComment
argument_list|(
name|CmtFmt
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Strip leading and trailing white space.  Skip over any imbedded '\r's. */
end_comment

begin_function
name|private
name|void
name|strip_c
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|char
modifier|*
name|from
decl_stmt|,
decl|*
name|to
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|char
modifier|*
name|fr_p
init|=
name|from
decl_stmt|,
modifier|*
name|to_p
init|=
name|to
decl_stmt|,
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fr_p
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|' '
operator|||
name|c
operator|==
literal|'\t'
operator|||
name|c
operator|==
literal|'\r'
condition|)
name|fr_p
operator|+=
literal|1
expr_stmt|;
else|else
break|break;
block|}
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fr_p
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'\r'
condition|)
operator|*
name|to_p
operator|++
operator|=
name|c
expr_stmt|;
name|fr_p
operator|+=
literal|1
expr_stmt|;
block|}
while|while
condition|(
operator|--
name|to_p
operator|>=
name|to
condition|)
if|if
condition|(
operator|*
name|to_p
operator|!=
literal|' '
operator|&&
operator|*
name|to_p
operator|!=
literal|'\t'
condition|)
break|break;
operator|*
operator|++
name|to_p
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|private
name|char
name|open_c
index|[
literal|20
index|]
decl_stmt|,
comment|/* the open comment format string */
name|open_pat
index|[
literal|20
index|]
decl_stmt|,
comment|/* the search pattern for open comment */
name|l_header
index|[
literal|20
index|]
decl_stmt|,
comment|/* the prefix for each comment line */
name|l_trailer
index|[
literal|20
index|]
decl_stmt|,
comment|/* the suffix ... */
name|close_c
index|[
literal|20
index|]
decl_stmt|,
name|close_pat
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
specifier|const
name|comment_body
index|[]
init|=
block|{
name|open_c
block|,
name|l_header
block|,
name|l_trailer
block|,
name|close_c
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|nlflags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fill in the data structures above from the format string.  Don't return    if there's trouble. */
end_comment

begin_function
name|private
name|void
name|parse_cmt_fmt
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|fmtp
init|=
name|str
decl_stmt|;
specifier|register
name|char
modifier|*
specifier|const
modifier|*
name|c_body
init|=
name|comment_body
decl_stmt|,
modifier|*
name|body_p
init|=
operator|*
name|c_body
decl_stmt|;
name|int
name|c
decl_stmt|,
name|newlines
init|=
literal|1
decl_stmt|;
comment|/* pick apart the comment string */
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|fmtp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
name|c
operator|!=
literal|'%'
condition|)
block|{
operator|*
name|body_p
operator|++
operator|=
name|c
expr_stmt|;
continue|continue;
block|}
switch|switch
condition|(
name|c
operator|=
operator|*
name|fmtp
operator|++
condition|)
block|{
case|case
literal|'n'
case|:
if|if
condition|(
name|newlines
operator|==
literal|2
operator|||
name|newlines
operator|==
literal|3
condition|)
name|complain
argument_list|(
literal|"%n not allowed in line header or trailer: %s"
argument_list|,
name|fmtp
operator|-
literal|2
argument_list|)
expr_stmt|;
name|nlflags
operator|+=
name|newlines
expr_stmt|;
operator|*
name|body_p
operator|++
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
operator|*
name|body_p
operator|++
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'%'
case|:
operator|*
name|body_p
operator|++
operator|=
literal|'%'
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
case|case
literal|'c'
case|:
name|newlines
operator|+=
literal|1
expr_stmt|;
operator|*
name|body_p
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|body_p
operator|=
operator|*
operator|++
name|c_body
expr_stmt|;
break|break;
default|default:
name|complain
argument_list|(
literal|"[Unknown comment escape: %%%c]"
argument_list|,
name|c
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
operator|*
name|body_p
operator|=
literal|'\0'
expr_stmt|;
comment|/* make search patterns */
name|strip_c
argument_list|(
name|open_c
argument_list|,
name|open_pat
argument_list|)
expr_stmt|;
name|strip_c
argument_list|(
name|close_c
argument_list|,
name|close_pat
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|NL_IN_OPEN_C
value|((nlflags % 4) == 1)
end_define

begin_define
define|#
directive|define
name|NL_IN_CLOSE_C
value|(nlflags>= 4)
end_define

begin_function
name|private
name|void
name|FillComment
parameter_list|(
name|format
parameter_list|)
name|char
modifier|*
name|format
decl_stmt|;
block|{
name|int
name|saveRMargin
decl_stmt|,
name|indent_pos
decl_stmt|,
name|close_at_dot
init|=
name|NO
decl_stmt|;
name|size_t
name|header_len
decl_stmt|,
name|trailer_len
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
specifier|static
name|char
name|inside_err
index|[]
init|=
literal|"[Must be between %s and %s to re-format]"
decl_stmt|;
name|Bufpos
name|open_c_pt
decl_stmt|,
name|close_c_pt
decl_stmt|,
name|tmp_bp
decl_stmt|,
modifier|*
name|match_o
decl_stmt|,
modifier|*
name|match_c
decl_stmt|;
name|Mark
modifier|*
name|entry_mark
decl_stmt|,
modifier|*
name|open_c_mark
decl_stmt|,
modifier|*
name|savedot
decl_stmt|;
name|parse_cmt_fmt
argument_list|(
name|format
argument_list|)
expr_stmt|;
comment|/* figure out if we're "inside" a comment */
if|if
condition|(
operator|(
name|match_o
operator|=
name|dosearch
argument_list|(
name|open_pat
argument_list|,
name|BACKWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|complain
argument_list|(
literal|"No opening %s to match to."
argument_list|,
name|open_pat
argument_list|)
expr_stmt|;
name|open_c_pt
operator|=
operator|*
name|match_o
expr_stmt|;
if|if
condition|(
operator|(
name|match_c
operator|=
name|dosearch
argument_list|(
name|close_pat
argument_list|,
name|BACKWARD
argument_list|,
name|NO
argument_list|)
operator|)
operator|!=
literal|0
operator|&&
name|inorder
argument_list|(
name|open_c_pt
operator|.
name|p_line
argument_list|,
name|open_c_pt
operator|.
name|p_char
argument_list|,
name|match_c
operator|->
name|p_line
argument_list|,
name|match_c
operator|->
name|p_char
argument_list|)
condition|)
name|complain
argument_list|(
name|inside_err
argument_list|,
name|open_pat
argument_list|,
name|close_pat
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|match_o
operator|=
name|dosearch
argument_list|(
name|open_pat
argument_list|,
name|FORWARD
argument_list|,
name|NO
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|tmp_bp
operator|=
operator|*
name|match_o
expr_stmt|;
name|match_o
operator|=
operator|&
name|tmp_bp
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|match_c
operator|=
name|dosearch
argument_list|(
name|close_pat
argument_list|,
name|FORWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
operator|(
name|Bufpos
operator|*
operator|)
literal|0
condition|)
name|close_c_pt
operator|=
operator|*
name|match_c
expr_stmt|;
comment|/* Here's where we figure out whether to format from dot or from 	   the close comment.  Note that we've already searched backwards to 	   find the open comment symbol for the comment we are formatting. 	   The open symbol mentioned below refers to the possible existence 	   of the next comment.  There are 5 cases: 		1) no open or close symbol		==> dot 		2) open, but no close symbol		==> dot 		3) close, but no open			==> close 		4) open, close are inorder		==> dot 		5) open, close are not inorder		==> close */
if|if
condition|(
name|match_o
operator|==
operator|(
name|Bufpos
operator|*
operator|)
literal|0
condition|)
block|{
if|if
condition|(
name|match_c
operator|==
operator|(
name|Bufpos
operator|*
operator|)
literal|0
condition|)
name|close_at_dot
operator|=
name|YES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|match_c
operator|==
operator|(
name|Bufpos
operator|*
operator|)
literal|0
condition|)
name|close_at_dot
operator|=
name|YES
expr_stmt|;
elseif|else
if|if
condition|(
name|inorder
argument_list|(
name|match_o
operator|->
name|p_line
argument_list|,
name|match_o
operator|->
name|p_char
argument_list|,
name|match_c
operator|->
name|p_line
argument_list|,
name|match_c
operator|->
name|p_char
argument_list|)
condition|)
name|close_at_dot
operator|=
name|YES
expr_stmt|;
if|if
condition|(
name|close_at_dot
condition|)
block|{
name|close_c_pt
operator|.
name|p_line
operator|=
name|curline
expr_stmt|;
name|close_c_pt
operator|.
name|p_char
operator|=
name|curchar
expr_stmt|;
block|}
else|else
block|{
name|SetDot
argument_list|(
name|match_c
argument_list|)
expr_stmt|;
block|}
name|SetDot
argument_list|(
operator|&
name|open_c_pt
argument_list|)
expr_stmt|;
name|open_c_mark
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|indent_pos
operator|=
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
comment|/* search for a close comment; delete it if it exits */
name|SetDot
argument_list|(
operator|&
name|close_c_pt
argument_list|)
expr_stmt|;
if|if
condition|(
name|close_at_dot
operator|==
literal|0
condition|)
name|del_char
argument_list|(
name|BACKWARD
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|close_pat
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|entry_mark
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
name|ToMark
argument_list|(
name|open_c_mark
argument_list|)
expr_stmt|;
comment|/* always separate the comment body from anything preceeding it */
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|DelWtSpace
argument_list|()
expr_stmt|;
name|Bol
argument_list|()
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|open_c
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
if|if
condition|(
operator|!
name|eolp
argument_list|()
condition|)
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
else|else
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|linebuf
index|[
name|curchar
index|]
operator|!=
operator|*
name|cp
condition|)
name|insert_c
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Since we matched the open comment string on this 			   line, we don't need to worry about crossing line 			   boundaries. */
name|curchar
operator|+=
literal|1
expr_stmt|;
block|}
name|savedot
operator|=
name|MakeMark
argument_list|(
name|curline
argument_list|,
name|curchar
argument_list|,
name|M_FLOATER
argument_list|)
expr_stmt|;
comment|/* We need to strip the line header pattern of leading white space 	   since we need to match the line after all of its leading 	   whitespace is gone. */
for|for
control|(
name|cp
operator|=
name|l_header
init|;
operator|*
name|cp
operator|&&
operator|(
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
operator|)
condition|;
name|cp
operator|++
control|)
empty_stmt|;
name|header_len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|trailer_len
operator|=
name|strlen
argument_list|(
name|l_trailer
argument_list|)
expr_stmt|;
comment|/* Strip each comment line of the open and close comment strings 	   before reformatting it. */
do|do
block|{
name|Bol
argument_list|()
expr_stmt|;
name|DelWtSpace
argument_list|()
expr_stmt|;
if|if
condition|(
name|header_len
operator|&&
name|strncmp
argument_list|(
name|linebuf
argument_list|,
name|cp
argument_list|,
name|header_len
argument_list|)
operator|==
literal|0
condition|)
name|del_char
argument_list|(
name|FORWARD
argument_list|,
operator|(
name|int
operator|)
name|header_len
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|trailer_len
condition|)
block|{
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|size_t
operator|)
name|curchar
operator|>
name|trailer_len
operator|)
operator|&&
operator|(
name|strncmp
argument_list|(
operator|&
name|linebuf
index|[
name|curchar
operator|-
name|trailer_len
index|]
argument_list|,
name|l_trailer
argument_list|,
name|trailer_len
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|del_char
argument_list|(
name|BACKWARD
argument_list|,
operator|(
name|int
operator|)
name|trailer_len
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|curline
operator|->
name|l_next
operator|!=
literal|0
condition|)
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
name|curline
operator|!=
name|entry_mark
operator|->
name|m_line
operator|->
name|l_next
condition|)
do|;
name|do_set_mark
argument_list|(
name|savedot
operator|->
name|m_line
argument_list|,
name|savedot
operator|->
name|m_char
argument_list|)
expr_stmt|;
name|ToMark
argument_list|(
name|entry_mark
argument_list|)
expr_stmt|;
name|saveRMargin
operator|=
name|RMargin
expr_stmt|;
name|RMargin
operator|=
name|saveRMargin
operator|-
name|strlen
argument_list|(
name|l_header
argument_list|)
operator|-
name|strlen
argument_list|(
name|l_trailer
argument_list|)
operator|-
name|indent_pos
operator|+
literal|2
expr_stmt|;
name|do_rfill
argument_list|(
name|NO
argument_list|)
expr_stmt|;
name|RMargin
operator|=
name|saveRMargin
expr_stmt|;
comment|/* get back to the start of the comment */
name|PopMark
argument_list|()
expr_stmt|;
do|do
block|{
if|if
condition|(
name|curline
operator|==
name|open_c_mark
operator|->
name|m_line
operator|->
name|l_next
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|Bol
argument_list|()
expr_stmt|;
name|n_indent
argument_list|(
name|indent_pos
argument_list|)
expr_stmt|;
name|ins_str
argument_list|(
name|l_header
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
name|Eol
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|NL_IN_CLOSE_C
operator|&&
operator|(
name|curline
operator|==
name|entry_mark
operator|->
name|m_line
operator|)
condition|)
empty_stmt|;
else|else
name|ins_str
argument_list|(
name|l_trailer
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|curline
operator|->
name|l_next
operator|!=
literal|0
condition|)
name|line_move
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
else|else
break|break;
block|}
do|while
condition|(
name|curline
operator|!=
name|entry_mark
operator|->
name|m_line
operator|->
name|l_next
condition|)
do|;
comment|/* handle the close comment symbol */
if|if
condition|(
name|curline
operator|==
name|entry_mark
operator|->
name|m_line
operator|->
name|l_next
condition|)
block|{
name|line_move
argument_list|(
name|BACKWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
block|}
name|DelWtSpace
argument_list|()
expr_stmt|;
comment|/* if the addition of the close symbol would cause the line to be 	   too long, put the close symbol on the next line. */
if|if
condition|(
operator|!
operator|(
name|NL_IN_CLOSE_C
operator|)
operator|&&
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|close_c
argument_list|)
operator|+
name|calc_pos
argument_list|(
name|linebuf
argument_list|,
name|curchar
argument_list|)
operator|>
name|RMargin
condition|)
block|{
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|n_indent
argument_list|(
name|indent_pos
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|cp
operator|=
name|close_c
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\r'
condition|)
block|{
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|n_indent
argument_list|(
name|indent_pos
argument_list|)
expr_stmt|;
block|}
else|else
name|insert_c
argument_list|(
operator|*
name|cp
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
name|ToMark
argument_list|(
name|open_c_mark
argument_list|)
expr_stmt|;
name|Eol
argument_list|()
expr_stmt|;
name|del_char
argument_list|(
name|FORWARD
argument_list|,
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CMT_FMT */
end_comment

end_unit

