begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"re.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"chars.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|private
name|Bufpos
modifier|*
name|doisearch
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|IncSearch
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|,
name|replace
name|proto
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|isearch
name|proto
argument_list|(
operator|(
name|int
operator|,
name|Bufpos
operator|*
operator|)
argument_list|)
decl_stmt|,
name|lookup
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
name|substitute
name|proto
argument_list|(
operator|(
expr|struct
name|RE_block
operator|*
operator|,
name|int
operator|,
name|Line
operator|*
operator|,
name|int
operator|,
name|Line
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|int
name|substitute
parameter_list|(
name|re_blk
parameter_list|,
name|query
parameter_list|,
name|l1
parameter_list|,
name|char1
parameter_list|,
name|l2
parameter_list|,
name|char2
parameter_list|)
name|struct
name|RE_block
modifier|*
name|re_blk
decl_stmt|;
name|Line
modifier|*
name|l1
decl_stmt|,
decl|*
name|l2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|query
decl_stmt|,
name|char1
decl_stmt|,
name|char2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|Line
modifier|*
name|lp
decl_stmt|;
name|int
name|numdone
init|=
literal|0
decl_stmt|,
name|UNDO_nd
init|=
literal|0
decl_stmt|,
name|offset
init|=
name|char1
decl_stmt|,
name|stop
init|=
name|NO
decl_stmt|;
name|daddr
name|UNDO_da
init|=
literal|0
decl_stmt|;
name|Line
modifier|*
name|UNDO_lp
init|=
name|NULL
decl_stmt|;
name|lsave
argument_list|()
expr_stmt|;
name|REdirection
operator|=
name|FORWARD
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|l1
init|;
name|lp
operator|!=
name|l2
operator|->
name|l_next
condition|;
name|lp
operator|=
name|lp
operator|->
name|l_next
control|)
block|{
name|int
name|crater
init|=
operator|-
literal|1
decl_stmt|;
comment|/* end of last substitution on this line */
name|int
name|LineDone
init|=
name|NO
decl_stmt|;
comment|/* already replaced last empty string on line? */
while|while
condition|(
operator|!
name|LineDone
operator|&&
name|re_lindex
argument_list|(
name|lp
argument_list|,
name|offset
argument_list|,
name|re_blk
argument_list|,
name|NO
argument_list|,
name|crater
argument_list|)
operator|&&
operator|(
name|lp
operator|!=
name|l2
operator|||
name|REeom
operator|<=
name|char2
operator|)
condition|)
block|{
name|DotTo
argument_list|(
name|lp
argument_list|,
name|REeom
argument_list|)
expr_stmt|;
name|offset
operator|=
name|curchar
expr_stmt|;
if|if
condition|(
name|query
condition|)
block|{
name|int
name|c
decl_stmt|;
name|message
argument_list|(
literal|"Replace (Type '?' for help)? "
argument_list|)
expr_stmt|;
name|reswitch
label|:
name|redisplay
argument_list|()
expr_stmt|;
name|c
operator|=
name|jgetchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
return|return
name|numdone
return|;
switch|switch
condition|(
name|CharUpcase
argument_list|(
name|c
argument_list|)
condition|)
block|{
case|case
literal|'.'
case|:
name|stop
operator|=
name|YES
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|' '
case|:
case|case
literal|'Y'
case|:
break|break;
case|case
name|BS
case|:
case|case
name|RUBOUT
case|:
case|case
literal|'N'
case|:
if|if
condition|(
name|REbom
operator|==
name|REeom
condition|)
block|{
name|offset
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|linebuf
index|[
name|REeom
index|]
operator|==
literal|'\0'
condition|)
name|LineDone
operator|=
name|YES
expr_stmt|;
block|}
continue|continue;
case|case
name|CTL
argument_list|(
literal|'W'
argument_list|)
case|:
name|re_dosub
argument_list|(
name|re_blk
argument_list|,
name|linebuf
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|l2
condition|)
name|char2
operator|+=
name|REdelta
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|numdone
operator|+=
literal|1
expr_stmt|;
name|curchar
operator|=
name|REbom
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
name|UNDO_da
operator|=
name|curline
operator|->
name|l_dline
expr_stmt|;
name|UNDO_lp
operator|=
name|curline
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|CTL
argument_list|(
literal|'R'
argument_list|)
case|:
case|case
literal|'R'
case|:
name|RErecur
argument_list|()
expr_stmt|;
name|UNDO_lp
operator|=
name|NULL
expr_stmt|;
comment|/* can't reliably undo this */
name|offset
operator|=
name|curchar
expr_stmt|;
name|lp
operator|=
name|curline
expr_stmt|;
continue|continue;
case|case
name|CTL
argument_list|(
literal|'U'
argument_list|)
case|:
case|case
literal|'U'
case|:
if|if
condition|(
name|UNDO_lp
operator|==
name|NULL
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
if|if
condition|(
name|UNDO_lp
operator|==
name|NULL
condition|)
name|getline
argument_list|(
name|UNDO_da
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
comment|/* someone ought to */
name|lp
operator|=
name|UNDO_lp
expr_stmt|;
name|lp
operator|->
name|l_dline
operator|=
name|UNDO_da
expr_stmt|;
name|makedirty
argument_list|(
name|lp
argument_list|)
expr_stmt|;
name|offset
operator|=
literal|0
expr_stmt|;
name|numdone
operator|=
name|UNDO_nd
expr_stmt|;
name|UNDO_lp
operator|=
name|NULL
expr_stmt|;
continue|continue;
case|case
literal|'P'
case|:
case|case
literal|'!'
case|:
name|query
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|CR
case|:
case|case
name|LF
case|:
case|case
literal|'Q'
case|:
return|return
name|numdone
return|;
case|case
name|CTL
argument_list|(
literal|'L'
argument_list|)
case|:
name|RedrawDisplay
argument_list|()
expr_stmt|;
goto|goto
name|reswitch
goto|;
default|default:
name|rbell
argument_list|()
expr_stmt|;
name|message
argument_list|(
literal|"Space or Y, Period, Rubout or N, C-R or R, C-W, C-U or U, P or !, Return."
argument_list|)
expr_stmt|;
goto|goto
name|reswitch
goto|;
block|}
block|}
if|if
condition|(
name|UNDO_lp
operator|!=
name|curline
condition|)
block|{
name|UNDO_da
operator|=
name|curline
operator|->
name|l_dline
expr_stmt|;
name|UNDO_lp
operator|=
name|curline
expr_stmt|;
name|UNDO_nd
operator|=
name|numdone
expr_stmt|;
block|}
if|if
condition|(
name|REbom
operator|==
name|REeom
operator|&&
name|linebuf
index|[
name|REeom
index|]
operator|==
literal|'\0'
condition|)
name|LineDone
operator|=
name|YES
expr_stmt|;
name|re_dosub
argument_list|(
name|re_blk
argument_list|,
name|linebuf
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|lp
operator|==
name|l2
condition|)
name|char2
operator|+=
name|REdelta
expr_stmt|;
name|numdone
operator|+=
literal|1
expr_stmt|;
name|modify
argument_list|()
expr_stmt|;
name|crater
operator|=
name|offset
operator|=
name|curchar
operator|=
name|REeom
expr_stmt|;
name|makedirty
argument_list|(
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|query
condition|)
block|{
name|message
argument_list|(
name|mesgbuf
argument_list|)
expr_stmt|;
comment|/* no blinking */
name|redisplay
argument_list|()
expr_stmt|;
comment|/* show the change */
block|}
if|if
condition|(
name|stop
condition|)
return|return
name|numdone
return|;
block|}
name|offset
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|numdone
return|;
block|}
end_block

begin_comment
comment|/* prompt for search and replacement strings and do the substitution */
end_comment

begin_function
name|private
name|void
name|replace
parameter_list|(
name|query
parameter_list|,
name|inreg
parameter_list|)
name|int
name|query
decl_stmt|,
name|inreg
decl_stmt|;
block|{
name|Mark
modifier|*
name|m
decl_stmt|;
name|char
modifier|*
name|rep_ptr
decl_stmt|;
name|Line
modifier|*
name|l1
init|=
name|curline
decl_stmt|,
modifier|*
name|l2
init|=
name|curbuf
operator|->
name|b_last
decl_stmt|;
name|int
name|char1
init|=
name|curchar
decl_stmt|,
name|char2
init|=
name|length
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
decl_stmt|,
name|numdone
decl_stmt|;
name|struct
name|RE_block
name|re_blk
decl_stmt|;
if|if
condition|(
name|inreg
condition|)
block|{
name|m
operator|=
name|CurMark
argument_list|()
expr_stmt|;
name|l2
operator|=
name|m
operator|->
name|m_line
expr_stmt|;
name|char2
operator|=
name|m
operator|->
name|m_char
expr_stmt|;
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|l1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|l2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
block|}
comment|/* get search string */
name|strcpy
argument_list|(
name|rep_search
argument_list|,
name|ask
argument_list|(
name|rep_search
index|[
literal|0
index|]
condition|?
name|rep_search
else|:
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
expr_stmt|;
name|REcompile
argument_list|(
name|rep_search
argument_list|,
name|UseRE
argument_list|,
operator|&
name|re_blk
argument_list|)
expr_stmt|;
comment|/* Now the replacement string.  Do_ask() so the user can play with 	   the default (previous) replacement string by typing C-R in ask(), 	   OR, he can just hit Return to replace with nothing. */
name|rep_ptr
operator|=
name|do_ask
argument_list|(
literal|"\r\n"
argument_list|,
operator|(
name|int
argument_list|(
argument|*
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|)
argument_list|)
operator|)
literal|0
argument_list|,
name|rep_str
argument_list|,
literal|": %f %s with "
argument_list|,
name|rep_search
argument_list|)
expr_stmt|;
if|if
condition|(
name|rep_ptr
operator|==
literal|0
condition|)
name|rep_ptr
operator|=
name|NullStr
expr_stmt|;
name|strcpy
argument_list|(
name|rep_str
argument_list|,
name|rep_ptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|numdone
operator|=
name|substitute
argument_list|(
operator|&
name|re_blk
argument_list|,
name|query
argument_list|,
name|l1
argument_list|,
name|char1
argument_list|,
name|l2
argument_list|,
name|char2
argument_list|)
operator|)
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|inreg
operator|==
name|NO
operator|)
condition|)
block|{
name|do_set_mark
argument_list|(
name|l1
argument_list|,
name|char1
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
comment|/* just making things pretty */
block|}
else|else
name|message
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|"(%d substitution%n)"
argument_list|,
name|numdone
argument_list|,
name|numdone
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RegReplace
parameter_list|()
block|{
name|replace
argument_list|(
literal|0
argument_list|,
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|QRepSearch
parameter_list|()
block|{
name|replace
argument_list|(
literal|1
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|RepSearch
parameter_list|()
block|{
name|replace
argument_list|(
literal|0
argument_list|,
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Lookup a tag in tag file FILE.  FILE is assumed to be sorted    alphabetically.  The FASTTAGS code, which is implemented with    a binary search, depends on this assumption.  If it's not true    it is possible to comment out the fast tag code (which is clearly    labeled), delete the marked test in the sequential loop, and    everything else will just work. */
end_comment

begin_function
name|private
name|int
name|lookup
parameter_list|(
name|searchbuf
parameter_list|,
name|filebuf
parameter_list|,
name|tag
parameter_list|,
name|file
parameter_list|)
name|char
modifier|*
name|searchbuf
decl_stmt|,
decl|*
name|filebuf
decl_stmt|,
modifier|*
name|tag
decl_stmt|,
modifier|*
name|file
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|size_t
name|taglen
init|=
name|strlen
argument_list|(
name|tag
argument_list|)
decl_stmt|;
name|char
name|line
index|[
name|JBUFSIZ
index|]
decl_stmt|,
name|pattern
index|[
literal|128
index|]
decl_stmt|;
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|int
name|success
init|=
name|NO
decl_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_READ
argument_list|,
name|NO
argument_list|,
name|YES
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
return|return
name|NO
return|;
name|swritef
argument_list|(
name|pattern
argument_list|,
literal|"^%s[^\t]*\t*\\([^\t]*\\)\t*\\([?/]\\)\\(.*\\)\\2$"
argument_list|,
name|tag
argument_list|)
expr_stmt|;
comment|/* ********BEGIN FAST TAG CODE******** */
if|if
condition|(
name|stat
argument_list|(
name|file
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* Invariant: if there is a line matching the tag, it 		 * begins somewhere after position lower, and begins 		 * at or before upper.  There is one possible 		 * exception: if lower is 0, the line with the tag 		 * might be the very first line. 		 * 		 * When this loop is done, we seek to lower, advance 		 * past the next newline (unless lower is 0), and fall 		 * into the sequential search. 		 */
specifier|register
name|off_t
name|lower
init|=
literal|0
decl_stmt|;
specifier|register
name|off_t
name|upper
init|=
name|stbuf
operator|.
name|st_size
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|off_t
name|mid
decl_stmt|;
name|int
name|chars_eq
decl_stmt|;
if|if
condition|(
name|upper
operator|-
name|lower
operator|<
name|JBUFSIZ
condition|)
break|break;
comment|/* small range: search sequentially */
name|mid
operator|=
operator|(
name|lower
operator|+
name|upper
operator|)
operator|/
literal|2
expr_stmt|;
name|f_seek
argument_list|(
name|fp
argument_list|,
name|mid
argument_list|)
expr_stmt|;
comment|/* mid will not be 0 */
name|f_toNL
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|)
operator|==
name|EOF
condition|)
break|break;
comment|/* unexpected: bail out */
name|chars_eq
operator|=
name|numcomp
argument_list|(
name|line
argument_list|,
name|tag
argument_list|)
expr_stmt|;
if|if
condition|(
name|chars_eq
operator|==
name|taglen
operator|&&
name|iswhite
argument_list|(
name|line
index|[
name|chars_eq
index|]
argument_list|)
condition|)
block|{
comment|/* we hit the exact line: get out */
name|lower
operator|=
name|mid
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|line
index|[
name|chars_eq
index|]
operator|<
name|tag
index|[
name|chars_eq
index|]
condition|)
name|lower
operator|=
name|mid
expr_stmt|;
comment|/* line is BEFORE tag */
else|else
name|upper
operator|=
name|mid
expr_stmt|;
comment|/* line is AFTER tag */
block|}
comment|/* sequentially search from lower */
name|f_seek
argument_list|(
name|fp
argument_list|,
name|lower
argument_list|)
expr_stmt|;
if|if
condition|(
name|lower
operator|>
literal|0
condition|)
name|f_toNL
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
comment|/* END FAST TAG CODE */
while|while
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|line
argument_list|,
sizeof|sizeof
name|line
argument_list|)
operator|!=
name|EOF
condition|)
block|{
name|int
name|cmp
init|=
name|line
index|[
literal|0
index|]
operator|-
operator|*
name|tag
decl_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
name|cmp
operator|=
name|strncmp
argument_list|(
name|line
argument_list|,
name|tag
argument_list|,
name|taglen
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmp
operator|==
literal|0
condition|)
block|{
comment|/* we've found the match */
if|if
condition|(
operator|!
name|LookingAt
argument_list|(
name|pattern
argument_list|,
name|line
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|complain
argument_list|(
literal|"I thought I saw it!"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|putmatch
argument_list|(
literal|1
argument_list|,
name|filebuf
argument_list|,
operator|(
name|size_t
operator|)
name|FILESIZE
argument_list|)
expr_stmt|;
name|putmatch
argument_list|(
literal|3
argument_list|,
name|searchbuf
argument_list|,
operator|(
name|size_t
operator|)
literal|100
argument_list|)
expr_stmt|;
name|success
operator|=
name|YES
expr_stmt|;
block|}
break|break;
block|}
block|}
if|if
condition|(
name|cmp
operator|>
literal|0
condition|)
break|break;
comment|/* failure: gone too far.  PRESUMES ALPHABETIC ORDER */
block|}
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|success
operator|==
name|NO
condition|)
name|s_mess
argument_list|(
literal|"Can't find tag \"%s\"."
argument_list|,
name|tag
argument_list|)
expr_stmt|;
return|return
name|success
return|;
block|}
end_block

begin_if
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
end_if

begin_decl_stmt
name|char
name|TagFile
index|[
name|FILESIZE
index|]
init|=
literal|"./tags"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* MSDOS */
end_comment

begin_decl_stmt
name|char
name|TagFile
index|[
name|FILESIZE
index|]
init|=
literal|"tags"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_function
name|void
name|find_tag
parameter_list|(
name|tag
parameter_list|,
name|localp
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
name|int
name|localp
decl_stmt|;
block|{
name|char
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|,
name|sstr
index|[
literal|100
index|]
decl_stmt|,
name|tfbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
specifier|register
name|Bufpos
modifier|*
name|bp
decl_stmt|;
specifier|register
name|Buffer
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|tagfname
decl_stmt|;
if|if
condition|(
operator|!
name|localp
condition|)
name|tagfname
operator|=
name|ask_file
argument_list|(
literal|"With tag file: "
argument_list|,
name|TagFile
argument_list|,
name|tfbuf
argument_list|)
expr_stmt|;
else|else
name|tagfname
operator|=
name|TagFile
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|sstr
argument_list|,
name|filebuf
argument_list|,
name|tag
argument_list|,
name|tagfname
argument_list|)
operator|==
literal|0
condition|)
return|return;
name|set_mark
argument_list|()
expr_stmt|;
name|b
operator|=
name|do_find
argument_list|(
name|curwind
argument_list|,
name|filebuf
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|curbuf
operator|!=
name|b
condition|)
name|SetABuf
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|sstr
argument_list|,
name|BACKWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|&&
operator|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|sstr
argument_list|,
name|FORWARD
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
operator|)
condition|)
name|message
argument_list|(
literal|"Well, I found the file, but the tag is missing."
argument_list|)
expr_stmt|;
else|else
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|FindTag
parameter_list|()
block|{
name|int
name|localp
init|=
operator|!
name|is_an_arg
argument_list|()
decl_stmt|;
name|char
name|tag
index|[
literal|128
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tag
argument_list|,
name|ask
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|ProcFmt
argument_list|)
argument_list|)
expr_stmt|;
name|find_tag
argument_list|(
name|tag
argument_list|,
name|localp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Find Tag at Dot. */
end_comment

begin_function
name|void
name|FDotTag
parameter_list|()
block|{
name|int
name|c1
init|=
name|curchar
decl_stmt|,
name|c2
init|=
name|c1
decl_stmt|;
name|char
name|tagname
index|[
literal|50
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|ismword
argument_list|(
name|linebuf
index|[
name|curchar
index|]
argument_list|)
condition|)
name|complain
argument_list|(
literal|"Not a tag!"
argument_list|)
expr_stmt|;
while|while
condition|(
name|c1
operator|>
literal|0
operator|&&
name|ismword
argument_list|(
name|linebuf
index|[
name|c1
operator|-
literal|1
index|]
argument_list|)
condition|)
name|c1
operator|-=
literal|1
expr_stmt|;
while|while
condition|(
name|ismword
argument_list|(
name|linebuf
index|[
name|c2
index|]
argument_list|)
condition|)
name|c2
operator|+=
literal|1
expr_stmt|;
name|null_ncpy
argument_list|(
name|tagname
argument_list|,
name|linebuf
operator|+
name|c1
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|c2
operator|-
name|c1
argument_list|)
argument_list|)
expr_stmt|;
name|find_tag
argument_list|(
name|tagname
argument_list|,
operator|!
name|is_an_arg
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* I-search returns a code saying what to do:    STOP:	We found the match, so unwind the stack and leave 		where it is.    DELETE:	Rubout the last command.    BACKUP:	Back up to where the isearch was last NOT failing.     When a character is typed it is appended to the search string, and    then, isearch is called recursively.  When C-S or C-R is typed, isearch    is again called recursively. */
end_comment

begin_define
define|#
directive|define
name|STOP
value|1
end_define

begin_define
define|#
directive|define
name|DELETE
value|2
end_define

begin_define
define|#
directive|define
name|BACKUP
value|3
end_define

begin_define
define|#
directive|define
name|TOSTART
value|4
end_define

begin_decl_stmt
specifier|static
name|char
name|ISbuf
index|[
literal|128
index|]
decl_stmt|,
modifier|*
name|incp
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|SExitChar
init|=
name|CR
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|cmp_char
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|((a) == (b) || (CaseIgnore&& (CharUpcase(a) == CharUpcase(b))))
end_define

begin_function
specifier|static
name|Bufpos
modifier|*
name|doisearch
parameter_list|(
name|dir
parameter_list|,
name|c
parameter_list|,
name|failing
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|,
name|dir
decl_stmt|,
name|failing
decl_stmt|;
block|{
specifier|static
name|Bufpos
name|buf
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
if|if
condition|(
name|c
operator|==
name|CTL
argument_list|(
literal|'S'
argument_list|)
operator|||
name|c
operator|==
name|CTL
argument_list|(
literal|'R'
argument_list|)
condition|)
goto|goto
name|dosrch
goto|;
if|if
condition|(
name|failing
condition|)
return|return
literal|0
return|;
name|DOTsave
argument_list|(
operator|&
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|FORWARD
condition|)
block|{
if|if
condition|(
name|cmp_char
argument_list|(
name|linebuf
index|[
name|curchar
index|]
argument_list|,
name|c
argument_list|)
condition|)
block|{
name|buf
operator|.
name|p_char
operator|=
name|curchar
operator|+
literal|1
expr_stmt|;
return|return
operator|&
name|buf
return|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|look_at
argument_list|(
name|ISbuf
argument_list|)
condition|)
return|return
operator|&
name|buf
return|;
block|}
name|dosrch
label|:
name|okay_wrap
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|(
name|bp
operator|=
name|dosearch
argument_list|(
name|ISbuf
argument_list|,
name|dir
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|rbell
argument_list|()
expr_stmt|;
comment|/* ring the first time there's no match */
name|okay_wrap
operator|=
name|NO
expr_stmt|;
return|return
name|bp
return|;
block|}
end_function

begin_function
name|void
name|IncFSearch
parameter_list|()
block|{
name|IncSearch
argument_list|(
name|FORWARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|IncRSearch
parameter_list|()
block|{
name|IncSearch
argument_list|(
name|BACKWARD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|IncSearch
parameter_list|(
name|dir
parameter_list|)
name|int
name|dir
decl_stmt|;
block|{
name|Bufpos
name|save_env
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|save_env
argument_list|)
expr_stmt|;
name|ISbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|incp
operator|=
name|ISbuf
expr_stmt|;
if|if
condition|(
name|isearch
argument_list|(
name|dir
argument_list|,
operator|&
name|save_env
argument_list|)
operator|==
name|TOSTART
condition|)
name|SetDot
argument_list|(
operator|&
name|save_env
argument_list|)
expr_stmt|;
else|else
block|{
if|if
condition|(
name|LineDist
argument_list|(
name|curline
argument_list|,
name|save_env
operator|.
name|p_line
argument_list|)
operator|>=
name|MarkThresh
condition|)
name|do_set_mark
argument_list|(
name|save_env
operator|.
name|p_line
argument_list|,
name|save_env
operator|.
name|p_char
argument_list|)
expr_stmt|;
block|}
name|setsearch
argument_list|(
name|ISbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Nicely recursive. */
end_comment

begin_function
name|private
name|int
name|isearch
parameter_list|(
name|dir
parameter_list|,
name|bp
parameter_list|)
name|int
name|dir
decl_stmt|;
name|Bufpos
modifier|*
name|bp
decl_stmt|;
block|{
name|Bufpos
name|pushbp
decl_stmt|;
name|int
name|c
decl_stmt|,
name|ndir
decl_stmt|,
name|failing
decl_stmt|;
name|char
modifier|*
name|orig_incp
decl_stmt|;
if|if
condition|(
name|bp
operator|!=
literal|0
condition|)
block|{
comment|/* Move to the new position. */
name|pushbp
operator|.
name|p_line
operator|=
name|bp
operator|->
name|p_line
expr_stmt|;
name|pushbp
operator|.
name|p_char
operator|=
name|bp
operator|->
name|p_char
expr_stmt|;
name|SetDot
argument_list|(
name|bp
argument_list|)
expr_stmt|;
name|failing
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|DOTsave
argument_list|(
operator|&
name|pushbp
argument_list|)
expr_stmt|;
name|failing
operator|=
literal|1
expr_stmt|;
block|}
name|orig_incp
operator|=
name|incp
expr_stmt|;
name|ndir
operator|=
name|dir
expr_stmt|;
comment|/* Same direction as when we got here, unless 				   we change it with C-S or C-R. */
for|for
control|(
init|;
condition|;
control|)
block|{
name|SetDot
argument_list|(
operator|&
name|pushbp
argument_list|)
expr_stmt|;
name|message
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
if|if
condition|(
name|failing
condition|)
name|add_mess
argument_list|(
literal|"Failing "
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|BACKWARD
condition|)
name|add_mess
argument_list|(
literal|"reverse-"
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|"I-search: %s"
argument_list|,
name|ISbuf
argument_list|)
expr_stmt|;
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
name|NullStr
argument_list|)
expr_stmt|;
comment|/* tell me this is disgusting ... */
name|c
operator|=
name|getch
argument_list|()
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|SExitChar
condition|)
return|return
name|STOP
return|;
if|if
condition|(
name|c
operator|==
name|AbortChar
condition|)
block|{
comment|/* If we're failing, we backup until we're no longer 			   failing or we've reached the beginning; else, we 			   just about the search and go back to the start. */
if|if
condition|(
name|failing
condition|)
return|return
name|BACKUP
return|;
return|return
name|TOSTART
return|;
block|}
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|RUBOUT
case|:
case|case
name|BS
case|:
return|return
name|DELETE
return|;
case|case
name|CTL
argument_list|(
literal|'\\'
argument_list|)
case|:
name|c
operator|=
name|CTL
argument_list|(
literal|'S'
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|CTL
argument_list|(
literal|'S'
argument_list|)
case|:
case|case
name|CTL
argument_list|(
literal|'R'
argument_list|)
case|:
comment|/* If this is the first time through and we have a 			   search string left over from last time, use that 			   one now. */
if|if
condition|(
name|incp
operator|==
name|ISbuf
condition|)
block|{
name|strcpy
argument_list|(
name|ISbuf
argument_list|,
name|getsearch
argument_list|()
argument_list|)
expr_stmt|;
name|incp
operator|=
operator|&
name|ISbuf
index|[
name|strlen
argument_list|(
name|ISbuf
argument_list|)
index|]
expr_stmt|;
block|}
name|ndir
operator|=
operator|(
name|c
operator|==
name|CTL
argument_list|(
literal|'S'
argument_list|)
operator|)
condition|?
name|FORWARD
else|:
name|BACKWARD
expr_stmt|;
comment|/* If we're failing and we're not changing our 			   direction, don't recur since there's no way 			   the search can work. */
if|if
condition|(
name|failing
operator|&&
name|ndir
operator|==
name|dir
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
break|break;
case|case
literal|'\\'
case|:
if|if
condition|(
name|incp
operator|>
operator|&
name|ISbuf
index|[
operator|(
sizeof|sizeof
name|ISbuf
operator|)
operator|-
literal|1
index|]
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|*
name|incp
operator|++
operator|=
literal|'\\'
expr_stmt|;
name|add_mess
argument_list|(
literal|"\\"
argument_list|)
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
name|CTL
argument_list|(
literal|'Q'
argument_list|)
case|:
case|case
name|CTL
argument_list|(
literal|'^'
argument_list|)
case|:
name|add_mess
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|c
operator|=
name|getch
argument_list|()
operator||
literal|0400
expr_stmt|;
comment|/*FALLTHROUGH*/
default|default:
if|if
condition|(
name|c
operator|&
literal|0400
condition|)
name|c
operator|&=
name|CHARMASK
expr_stmt|;
else|else
block|{
ifdef|#
directive|ifdef
name|IBMPC
if|if
condition|(
name|c
operator|==
name|RUBOUT
operator|||
name|c
operator|==
literal|0xff
operator|||
operator|(
name|c
operator|<
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
else|#
directive|else
if|if
condition|(
name|c
operator|>
name|RUBOUT
operator|||
operator|(
name|c
operator|<
literal|' '
operator|&&
name|c
operator|!=
literal|'\t'
operator|)
endif|#
directive|endif
operator|||
name|PrefChar
argument_list|(
name|c
argument_list|)
condition|)
block|{
name|Ungetc
argument_list|(
name|c
argument_list|)
expr_stmt|;
return|return
name|STOP
return|;
block|}
block|}
if|if
condition|(
name|incp
operator|>
operator|&
name|ISbuf
index|[
operator|(
sizeof|sizeof
name|ISbuf
operator|)
operator|-
literal|1
index|]
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
continue|continue;
block|}
operator|*
name|incp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|incp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|add_mess
argument_list|(
literal|"%s"
argument_list|,
name|orig_incp
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" ..."
argument_list|)
expr_stmt|;
comment|/* so we know what's going on */
name|DrawMesg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
comment|/* do it now */
switch|switch
condition|(
name|isearch
argument_list|(
name|ndir
argument_list|,
name|doisearch
argument_list|(
name|ndir
argument_list|,
name|c
argument_list|,
name|failing
argument_list|)
argument_list|)
condition|)
block|{
case|case
name|TOSTART
case|:
return|return
name|TOSTART
return|;
case|case
name|STOP
case|:
return|return
name|STOP
return|;
case|case
name|BACKUP
case|:
comment|/* If we're not failing, we just continue to to the 			   for loop; otherwise we keep returning to the 			   previous levels until we find one that isn't 			   failing OR we reach the beginning. */
if|if
condition|(
name|failing
condition|)
return|return
name|BACKUP
return|;
comment|/*FALLTHROUGH*/
case|case
name|DELETE
case|:
name|incp
operator|=
name|orig_incp
expr_stmt|;
operator|*
name|incp
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
block|}
block|}
end_function

end_unit

