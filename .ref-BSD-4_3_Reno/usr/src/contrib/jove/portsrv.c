begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_comment
comment|/* This is a server for jove sub processes.  By the time we get here, our    standard output goes to jove's process input. */
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_if
if|#
directive|if
name|defined
argument_list|(
name|IPROCS
argument_list|)
operator|&&
name|defined
argument_list|(
name|PIPEPROCS
argument_list|)
end_if

begin_comment
comment|/* the whole file! */
end_comment

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/ioctl.h>
end_include

begin_include
include|#
directive|include
file|"wait.h"
end_include

begin_macro
name|private
end_macro

begin_struct
struct|struct
name|header
block|{
name|int
name|pid
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
name|char
name|buf
index|[
literal|512
index|]
decl_stmt|;
block|}
name|header
struct|;
end_struct

begin_decl_stmt
name|private
name|int
name|tty_fd
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|HEADSIZE
value|((sizeof header.pid) + sizeof (header.nbytes))
end_define

begin_function
name|private
name|void
name|proc_write
parameter_list|(
name|ptr
parameter_list|,
name|n
parameter_list|)
name|UnivConstPtr
name|ptr
decl_stmt|;
name|size_t
name|n
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
name|ptr
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|private
name|void
name|read_pipe
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
specifier|register
name|size_t
name|n
decl_stmt|;
while|while
condition|(
operator|(
name|header
operator|.
name|nbytes
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|header
operator|.
name|buf
argument_list|,
sizeof|sizeof
name|header
operator|.
name|buf
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|n
operator|=
name|HEADSIZE
operator|+
name|header
operator|.
name|nbytes
expr_stmt|;
name|proc_write
argument_list|(
operator|(
name|UnivConstPtr
operator|)
operator|&
name|header
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|private
name|void
name|proc_error
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|header
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|header
operator|.
name|nbytes
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|header
operator|.
name|buf
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|proc_write
argument_list|(
operator|(
name|UnivConstPtr
operator|)
operator|&
name|header
argument_list|,
name|header
operator|.
name|nbytes
operator|+
name|HEADSIZE
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|tty_fd
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
operator|-
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ARGSUSED */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|int
name|p
index|[
literal|2
index|]
decl_stmt|;
name|int
name|pid
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|p
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|proc_error
argument_list|(
literal|"Cannot pipe jove portsrv.\n"
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|proc_error
argument_list|(
literal|"portsrv: cannot fork.\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
literal|0
case|:
comment|/* We'll intercept childs output in p[0] */
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|,
literal|2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setpgrp
argument_list|(
name|getpid
argument_list|()
argument_list|,
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
name|execv
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
operator|&
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
operator|-
literal|4
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|tty_fd
operator|=
name|open
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|NEVER
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
name|write
argument_list|(
name|tty_fd
argument_list|,
literal|"*argv++ = "
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|tty_fd
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|strlen
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|tty_fd
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* NEVER */
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* tell jove the pid of the real child as opposed to us */
name|header
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|header
operator|.
name|nbytes
operator|=
sizeof|sizeof
argument_list|(
name|int
argument_list|)
expr_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|header
operator|.
name|buf
operator|=
name|pid
expr_stmt|;
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|header
argument_list|,
sizeof|sizeof
name|pid
operator|+
name|HEADSIZE
argument_list|)
expr_stmt|;
comment|/* read proc's output and send it to jove */
name|read_pipe
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* received EOF - wait for child to die and then exit 		   ourself in the same way so that JOVE knows how the 		   child died.  This is sort of a kludge, but the alternative 		   is to write the childs status to JOVE, which seems sorta 		   yucky, too.  		   Actually, 4 or 5 years later I like that idea much better, 		   so remind me to implement it that way when I get a chance.  		   7-23-89  Gee thanks, whoever implemented this for me! */
operator|(
name|void
operator|)
name|close
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|header
operator|.
name|pid
operator|=
name|getpid
argument_list|()
expr_stmt|;
name|header
operator|.
name|nbytes
operator|=
name|EOF
expr_stmt|;
comment|/* tell jove we are finished */
comment|/* try to exit like our child did ... */
block|{
name|union
name|wait
name|status
decl_stmt|;
while|while
condition|(
name|wait
argument_list|(
operator|&
name|status
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
operator|*
operator|(
name|int
operator|*
operator|)
name|header
operator|.
name|buf
operator|=
name|status
operator|.
name|w_status
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|write
argument_list|(
literal|1
argument_list|,
operator|(
name|UnivConstPtr
operator|)
operator|&
name|header
argument_list|,
name|HEADSIZE
operator|+
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* IPROCS&& PIPEPROCS */
end_comment

begin_function
name|int
name|main
parameter_list|()
block|{
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

