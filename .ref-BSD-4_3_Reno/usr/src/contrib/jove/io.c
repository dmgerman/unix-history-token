begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/***************************************************************************  * This program is Copyright (C) 1986, 1987, 1988 by Jonathan Payne.  JOVE *  * is provided to you without charge, and with no warranty.  You may give  *  * away copies of JOVE, including sources, provided that this notice is    *  * included in all the files.                                              *  ***************************************************************************/
end_comment

begin_include
include|#
directive|include
file|"jove.h"
end_include

begin_include
include|#
directive|include
file|"list.h"
end_include

begin_include
include|#
directive|include
file|"fp.h"
end_include

begin_include
include|#
directive|include
file|"termcap.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"disp.h"
end_include

begin_include
include|#
directive|include
file|"scandir.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|IPROCS
end_ifdef

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_include
include|#
directive|include
file|"mac.h"
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|UNIX
end_ifdef

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<io.h>
end_include

begin_include
include|#
directive|include
file|<direct.h>
end_include

begin_include
include|#
directive|include
file|<dos.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_decl_stmt
name|private
name|struct
name|block
modifier|*
name|b_unlink
name|proto
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|,
modifier|*
name|lookup
name|proto
argument_list|(
operator|(
comment|/*int*/
name|short
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|char
modifier|*
name|dbackup
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|int
operator|)
argument_list|)
decl_stmt|,
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
modifier|*
name|fixpath
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
modifier|*
name|getblock
name|proto
argument_list|(
operator|(
name|daddr
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|abspath
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|,
endif|#
directive|endif
name|fake_blkio
name|proto
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|,
name|DoWriteReg
name|proto
argument_list|(
operator|(
name|int
name|app
operator|)
argument_list|)
decl_stmt|,
name|LRUunlink
name|proto
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|)
argument_list|)
decl_stmt|,
name|file_backup
name|proto
argument_list|(
operator|(
name|char
operator|*
name|fname
operator|)
argument_list|)
decl_stmt|,
name|real_blkio
name|proto
argument_list|(
operator|(
expr|struct
name|block
operator|*
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|,
name|dfollow
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_decl_stmt
name|private
name|int
name|Dchdir
name|proto
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|W_OK
end_ifndef

begin_define
define|#
directive|define
name|W_OK
value|2
end_define

begin_define
define|#
directive|define
name|F_OK
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|READ
value|0
end_define

begin_define
define|#
directive|define
name|WRITE
value|1
end_define

begin_comment
comment|/* block operation read or write */
end_comment

begin_decl_stmt
name|long
name|io_chars
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of chars in this open_file */
end_comment

begin_decl_stmt
name|int
name|io_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines in this open_file */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|VMUNIX
argument_list|)
operator|||
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_decl_stmt
name|char
name|iobuff
index|[
name|LBSIZE
index|]
decl_stmt|,
name|genbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|linebuf
index|[
name|LBSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|iobuff
decl_stmt|,
modifier|*
name|genbuf
decl_stmt|,
modifier|*
name|linebuf
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BACKUPFILES
end_ifdef

begin_decl_stmt
name|int
name|BkupOnWrite
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|close_file
parameter_list|(
name|fp
parameter_list|)
name|File
modifier|*
name|fp
decl_stmt|;
block|{
if|if
condition|(
name|fp
condition|)
block|{
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_TELLALL
condition|)
name|add_mess
argument_list|(
literal|" %d lines, %D characters."
argument_list|,
name|io_lines
argument_list|,
name|io_chars
argument_list|)
expr_stmt|;
name|f_close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write the region from line1/char1 to line2/char2 to FP.  This    never CLOSES the file since we don't know if we want to. */
end_comment

begin_decl_stmt
name|int
name|EndWNewline
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|putreg
parameter_list|(
name|fp
parameter_list|,
name|line1
parameter_list|,
name|char1
parameter_list|,
name|line2
parameter_list|,
name|char2
parameter_list|,
name|makesure
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|Line
modifier|*
name|line1
decl_stmt|,
decl|*
name|line2
decl_stmt|;
end_function

begin_decl_stmt
name|int
name|char1
decl_stmt|,
name|char2
decl_stmt|,
name|makesure
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
name|c
decl_stmt|;
specifier|register
name|char
modifier|*
name|lp
decl_stmt|;
if|if
condition|(
name|makesure
condition|)
operator|(
name|void
operator|)
name|fixorder
argument_list|(
operator|&
name|line1
argument_list|,
operator|&
name|char1
argument_list|,
operator|&
name|line2
argument_list|,
operator|&
name|char2
argument_list|)
expr_stmt|;
while|while
condition|(
name|line1
operator|!=
name|line2
operator|->
name|l_next
condition|)
block|{
name|lp
operator|=
name|lcontents
argument_list|(
name|line1
argument_list|)
operator|+
name|char1
expr_stmt|;
if|if
condition|(
name|line1
operator|==
name|line2
condition|)
block|{
name|fputnchar
argument_list|(
name|lp
argument_list|,
operator|(
name|char2
operator|-
name|char1
operator|)
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|io_chars
operator|+=
operator|(
name|char2
operator|-
name|char1
operator|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
name|jputc
argument_list|(
name|c
argument_list|,
name|fp
argument_list|)
expr_stmt|;
name|io_chars
operator|+=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|line1
operator|!=
name|line2
condition|)
block|{
name|io_lines
operator|+=
literal|1
expr_stmt|;
name|io_chars
operator|+=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|jputc
argument_list|(
literal|'\r'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|jputc
argument_list|(
literal|'\n'
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
name|line1
operator|=
name|line1
operator|->
name|l_next
expr_stmt|;
name|char1
operator|=
literal|0
expr_stmt|;
block|}
name|flush
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|private
name|void
name|dofread
parameter_list|(
name|fp
parameter_list|)
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
name|char
name|end
index|[
name|LBSIZE
index|]
decl_stmt|;
name|int
name|xeof
init|=
literal|0
decl_stmt|;
name|Line
modifier|*
name|savel
init|=
name|curline
decl_stmt|;
name|int
name|savec
init|=
name|curchar
decl_stmt|;
name|strcpy
argument_list|(
name|end
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|)
expr_stmt|;
name|xeof
operator|=
name|f_gets
argument_list|(
name|fp
argument_list|,
name|linebuf
operator|+
name|curchar
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|LBSIZE
operator|-
name|curchar
argument_list|)
argument_list|)
expr_stmt|;
name|SavLine
argument_list|(
name|curline
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|xeof
condition|)
do|do
block|{
name|curline
operator|=
name|listput
argument_list|(
name|curbuf
argument_list|,
name|curline
argument_list|)
expr_stmt|;
name|xeof
operator|=
name|f_getputl
argument_list|(
name|curline
argument_list|,
name|fp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|xeof
condition|)
do|;
name|getDOT
argument_list|()
expr_stmt|;
name|linecopy
argument_list|(
name|linebuf
argument_list|,
operator|(
name|curchar
operator|=
name|strlen
argument_list|(
name|linebuf
argument_list|)
operator|)
argument_list|,
name|end
argument_list|)
expr_stmt|;
name|SavLine
argument_list|(
name|curline
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|IFixMarks
argument_list|(
name|savel
argument_list|,
name|savec
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|read_file
parameter_list|(
name|file
parameter_list|,
name|is_insert
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|is_insert
decl_stmt|;
block|{
name|Bufpos
name|save
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
if|if
condition|(
name|is_insert
operator|==
name|NO
condition|)
name|curbuf
operator|->
name|b_ntbf
operator|=
name|NO
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
name|file
argument_list|,
name|iobuff
argument_list|,
name|F_READ
argument_list|,
name|NO
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
block|{
if|if
condition|(
operator|!
name|is_insert
operator|&&
name|errno
operator|==
name|ENOENT
condition|)
name|s_mess
argument_list|(
literal|"(new file)"
argument_list|)
expr_stmt|;
else|else
name|s_mess
argument_list|(
name|IOerr
argument_list|(
literal|"open"
argument_list|,
name|file
argument_list|)
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|is_insert
operator|==
name|NO
condition|)
block|{
name|set_ino
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|->
name|f_flags
operator|&
name|F_READONLY
condition|)
block|{
name|set_arg_value
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|set_arg_value
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
name|TogMinor
argument_list|(
name|ReadOnly
argument_list|)
expr_stmt|;
block|}
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|dofread
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_insert
operator|&&
name|io_chars
operator|>
literal|0
condition|)
block|{
name|modify
argument_list|()
expr_stmt|;
name|set_mark
argument_list|()
expr_stmt|;
block|}
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|getDOT
argument_list|()
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SaveFile
parameter_list|()
block|{
if|if
condition|(
name|IsModified
argument_list|(
name|curbuf
argument_list|)
condition|)
block|{
if|if
condition|(
name|curbuf
operator|->
name|b_fname
operator|==
literal|0
condition|)
name|WriteFile
argument_list|()
expr_stmt|;
else|else
block|{
name|filemunge
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|chk_mtime
argument_list|(
name|curbuf
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
literal|"save"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|file_write
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|message
argument_list|(
literal|"No changes need to be written."
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|char
modifier|*
name|HomeDir
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* home directory */
end_comment

begin_decl_stmt
name|size_t
name|HomeLen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of home directory string */
end_comment

begin_decl_stmt
name|private
name|List
modifier|*
name|DirStack
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|dir_name
parameter_list|(
name|dp
parameter_list|)
value|((char *) list_data(dp))
end_define

begin_define
define|#
directive|define
name|PWD_PTR
value|(list_data(DirStack))
end_define

begin_define
define|#
directive|define
name|PWD
value|((char *) PWD_PTR)
end_define

begin_function
name|char
modifier|*
name|pwd
parameter_list|()
block|{
return|return
operator|(
name|char
operator|*
operator|)
name|PWD_PTR
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|pr_name
parameter_list|(
name|fname
parameter_list|,
name|okay_home
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|okay_home
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
if|if
condition|(
name|fname
operator|==
literal|0
condition|)
return|return
literal|0
return|;
name|n
operator|=
name|numcomp
argument_list|(
name|fname
argument_list|,
name|PWD
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|PWD
index|[
name|n
index|]
operator|==
literal|0
operator|)
operator|&&
comment|/* Matched to end of PWD */
operator|(
name|fname
index|[
name|n
index|]
operator|==
literal|'/'
operator|)
condition|)
return|return
name|fname
operator|+
name|n
operator|+
literal|1
return|;
if|if
condition|(
name|okay_home
operator|&&
name|strcmp
argument_list|(
name|HomeDir
argument_list|,
literal|"/"
argument_list|)
operator|!=
literal|0
operator|&&
name|strncmp
argument_list|(
name|fname
argument_list|,
name|HomeDir
argument_list|,
name|HomeLen
argument_list|)
operator|==
literal|0
operator|&&
name|fname
index|[
name|HomeLen
index|]
operator|==
literal|'/'
condition|)
block|{
specifier|static
name|char
name|name_buf
index|[
literal|100
index|]
decl_stmt|;
name|swritef
argument_list|(
name|name_buf
argument_list|,
literal|"~%s"
argument_list|,
name|fname
operator|+
name|HomeLen
argument_list|)
expr_stmt|;
return|return
name|name_buf
return|;
block|}
return|return
name|fname
return|;
comment|/* return entire path name */
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_decl_stmt
specifier|extern
name|unsigned
name|int
name|fmask
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_function
name|void
name|Chdir
parameter_list|()
block|{
name|char
name|dirbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|fmask
operator|=
literal|0x10
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|PWD
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|fmask
operator|=
literal|0x13
expr_stmt|;
if|if
condition|(
name|Dchdir
argument_list|(
name|dirbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|chdir
argument_list|(
name|dirbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|s_mess
argument_list|(
literal|"cd: cannot change into %s."
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
return|return;
block|}
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|setCWD
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
name|prCWD
argument_list|()
expr_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|Bufchange
operator|++
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UNIX
argument_list|)
end_if

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|BSD4_2
argument_list|)
end_if

begin_function
name|char
modifier|*
name|getwd
parameter_list|(
name|buffer
parameter_list|)
name|char
modifier|*
name|buffer
decl_stmt|;
block|{
name|Buffer
modifier|*
name|old
init|=
name|curbuf
decl_stmt|;
name|char
modifier|*
name|ret_val
decl_stmt|;
name|SetBuf
argument_list|(
name|do_select
argument_list|(
operator|(
name|Window
operator|*
operator|)
literal|0
argument_list|,
literal|"pwd-output"
argument_list|)
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_type
operator|=
name|B_PROCESS
expr_stmt|;
operator|(
name|void
operator|)
name|UnixToBuf
argument_list|(
literal|"pwd-output"
argument_list|,
name|NO
argument_list|,
literal|0
argument_list|,
name|YES
argument_list|,
literal|"/bin/pwd"
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|ToFirst
argument_list|()
expr_stmt|;
name|strcpy
argument_list|(
name|buffer
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
name|SetBuf
argument_list|(
name|old
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not BSD4_2 */
end_comment

begin_comment
comment|/* Check if dn is the name of the current working directory    and that it is in cannonical form */
end_comment

begin_function
name|int
name|chkCWD
parameter_list|(
name|dn
parameter_list|)
name|char
modifier|*
name|dn
decl_stmt|;
block|{
name|char
name|filebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|struct
name|stat
name|dnstat
decl_stmt|,
name|dotstat
decl_stmt|;
if|if
condition|(
name|dn
index|[
literal|0
index|]
operator|!=
literal|'/'
condition|)
return|return
name|FALSE
return|;
comment|/* need absolute pathname */
name|PathParse
argument_list|(
name|dn
argument_list|,
name|filebuf
argument_list|)
expr_stmt|;
return|return
name|stat
argument_list|(
name|filebuf
argument_list|,
operator|&
name|dnstat
argument_list|)
operator|==
literal|0
operator|&&
name|stat
argument_list|(
literal|"."
argument_list|,
operator|&
name|dotstat
argument_list|)
operator|==
literal|0
operator|&&
name|dnstat
operator|.
name|st_dev
operator|==
name|dotstat
operator|.
name|st_dev
operator|&&
name|dnstat
operator|.
name|st_ino
operator|==
name|dotstat
operator|.
name|st_ino
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_function
name|void
name|setCWD
parameter_list|(
name|d
parameter_list|)
name|char
modifier|*
name|d
decl_stmt|;
block|{
if|if
condition|(
name|DirStack
operator|==
name|NIL
condition|)
name|list_push
argument_list|(
operator|&
name|DirStack
argument_list|,
operator|(
name|Element
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|PWD
operator|==
literal|0
condition|)
name|PWD_PTR
operator|=
operator|(
name|Element
operator|*
operator|)
name|emalloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|strlen
argument_list|(
name|d
argument_list|)
operator|+
literal|1
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|PWD_PTR
operator|=
operator|(
name|Element
operator|*
operator|)
name|ralloc
argument_list|(
name|PWD
argument_list|,
name|strlen
argument_list|(
name|d
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|PWD
argument_list|,
name|d
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|getCWD
parameter_list|()
block|{
name|char
modifier|*
name|cwd
decl_stmt|;
name|char
name|pathname
index|[
name|FILESIZE
index|]
decl_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|UNIX
argument_list|)
operator|&&
name|defined
argument_list|(
name|JOB_CONTROL
argument_list|)
specifier|extern
name|char
modifier|*
name|getwd
parameter_list|()
function_decl|;
endif|#
directive|endif
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
specifier|extern
name|char
modifier|*
name|getcwd
parameter_list|()
function_decl|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|MSDOS
name|cwd
operator|=
name|getenv
argument_list|(
literal|"CWD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwd
operator|==
literal|0
operator|||
operator|!
name|chkCWD
argument_list|(
name|cwd
argument_list|)
condition|)
block|{
name|cwd
operator|=
name|getenv
argument_list|(
literal|"PWD"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwd
operator|==
literal|0
operator|||
operator|!
name|chkCWD
argument_list|(
name|cwd
argument_list|)
condition|)
name|cwd
operator|=
name|getwd
argument_list|(
name|pathname
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* MSDOS */
name|cwd
operator|=
name|fixpath
argument_list|(
name|getcwd
argument_list|(
name|pathname
argument_list|,
name|FILESIZE
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|setCWD
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prDIRS
parameter_list|()
block|{
specifier|register
name|List
modifier|*
name|lp
decl_stmt|;
name|s_mess
argument_list|(
literal|": %f "
argument_list|)
expr_stmt|;
for|for
control|(
name|lp
operator|=
name|DirStack
init|;
name|lp
operator|!=
name|NIL
condition|;
name|lp
operator|=
name|list_next
argument_list|(
name|lp
argument_list|)
control|)
name|add_mess
argument_list|(
literal|"%s "
argument_list|,
name|pr_name
argument_list|(
name|dir_name
argument_list|(
name|lp
argument_list|)
argument_list|,
name|YES
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|prCWD
parameter_list|()
block|{
name|s_mess
argument_list|(
literal|": %f => \"%s\""
argument_list|,
name|PWD
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Pushd
parameter_list|()
block|{
name|char
modifier|*
name|newdir
decl_stmt|,
name|dirbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|fmask
operator|=
literal|0x10
expr_stmt|;
endif|#
directive|endif
name|newdir
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|NullStr
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|fmask
operator|=
literal|0x13
expr_stmt|;
endif|#
directive|endif
name|UpdModLine
operator|=
name|YES
expr_stmt|;
if|if
condition|(
operator|*
name|newdir
operator|==
literal|0
condition|)
block|{
comment|/* Wants to swap top two entries */
name|char
modifier|*
name|old_top
decl_stmt|;
if|if
condition|(
name|list_next
argument_list|(
name|DirStack
argument_list|)
operator|==
name|NIL
condition|)
name|complain
argument_list|(
literal|"pushd: no other directory."
argument_list|)
expr_stmt|;
name|old_top
operator|=
name|PWD
expr_stmt|;
name|list_data
argument_list|(
name|DirStack
argument_list|)
operator|=
operator|(
name|Element
operator|*
operator|)
name|dir_name
argument_list|(
name|list_next
argument_list|(
name|DirStack
argument_list|)
argument_list|)
expr_stmt|;
name|list_data
argument_list|(
name|list_next
argument_list|(
name|DirStack
argument_list|)
argument_list|)
operator|=
operator|(
name|Element
operator|*
operator|)
name|old_top
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
operator|(
name|void
operator|)
name|Dchdir
argument_list|(
name|PWD
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|PWD
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|Dchdir
argument_list|(
name|dirbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
else|#
directive|else
if|if
condition|(
name|chdir
argument_list|(
name|dirbuf
argument_list|)
operator|==
operator|-
literal|1
condition|)
endif|#
directive|endif
block|{
name|s_mess
argument_list|(
literal|"pushd: cannot change into %s."
argument_list|,
name|dirbuf
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|list_push
argument_list|(
operator|&
name|DirStack
argument_list|,
operator|(
name|Element
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|setCWD
argument_list|(
name|dirbuf
argument_list|)
expr_stmt|;
block|}
name|prDIRS
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|Popd
parameter_list|()
block|{
if|if
condition|(
name|list_next
argument_list|(
name|DirStack
argument_list|)
operator|==
name|NIL
condition|)
name|complain
argument_list|(
literal|"popd: directory stack is empty."
argument_list|)
expr_stmt|;
name|UpdModLine
operator|=
name|YES
expr_stmt|;
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|list_pop
argument_list|(
operator|&
name|DirStack
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
operator|(
name|void
operator|)
name|Dchdir
argument_list|(
name|PWD
argument_list|)
expr_stmt|;
comment|/* If this doesn't work, we's in deep shit. */
else|#
directive|else
operator|(
name|void
operator|)
name|chdir
argument_list|(
name|PWD
argument_list|)
expr_stmt|;
comment|/* If this doesn't work, we's in deep shit. */
endif|#
directive|endif
name|prDIRS
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|private
name|char
modifier|*
name|dbackup
parameter_list|(
name|base
parameter_list|,
name|offset
parameter_list|,
name|c
parameter_list|)
specifier|register
name|char
modifier|*
name|base
decl_stmt|,
decl|*
name|offset
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|c
decl_stmt|;
end_decl_stmt

begin_block
block|{
while|while
condition|(
name|offset
operator|>
name|base
operator|&&
operator|*
operator|--
name|offset
operator|!=
name|c
condition|)
empty_stmt|;
return|return
name|offset
return|;
block|}
end_block

begin_function
name|private
name|void
name|dfollow
parameter_list|(
name|file
parameter_list|,
name|into
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|,
decl|*
name|into
decl_stmt|;
end_function

begin_block
block|{
name|char
modifier|*
name|dp
decl_stmt|,
ifdef|#
directive|ifdef
name|MSDOS
name|filefix
index|[
name|FILESIZE
index|]
decl_stmt|,
endif|#
directive|endif
modifier|*
name|sp
decl_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
operator|*
name|file
operator|==
literal|'/'
condition|)
block|{
comment|/* Absolute pathname */
name|strcpy
argument_list|(
name|into
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|file
operator|+=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|apollo
comment|/* handle apollo "//..." */
if|if
condition|(
operator|*
name|file
operator|==
literal|'/'
condition|)
block|{
name|strcpy
argument_list|(
name|into
operator|+
literal|1
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
name|file
operator|+=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
name|strcpy
argument_list|(
name|into
argument_list|,
name|PWD
argument_list|)
expr_stmt|;
else|#
directive|else
name|abspath
argument_list|(
name|file
argument_list|,
name|filefix
argument_list|)
expr_stmt|;
comment|/* convert to absolute pathname */
name|strcpy
argument_list|(
name|into
argument_list|,
name|filefix
argument_list|)
expr_stmt|;
comment|/* and forget about drives	*/
name|into
index|[
literal|3
index|]
operator|=
literal|0
expr_stmt|;
name|into
operator|=
operator|&
operator|(
name|into
index|[
literal|2
index|]
operator|)
expr_stmt|;
name|file
operator|=
operator|&
operator|(
name|filefix
index|[
literal|3
index|]
operator|)
expr_stmt|;
endif|#
directive|endif
name|dp
operator|=
name|into
operator|+
name|strlen
argument_list|(
name|into
argument_list|)
expr_stmt|;
name|sp
operator|=
name|file
expr_stmt|;
do|do
block|{
if|if
condition|(
operator|*
name|file
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
operator|(
name|sp
operator|=
name|strchr
argument_list|(
name|file
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
literal|'\0'
condition|)
operator|*
name|sp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
condition|)
empty_stmt|;
comment|/* So it will get to the end of the loop */
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|file
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|*
operator|(
name|dp
operator|=
name|dbackup
argument_list|(
name|into
argument_list|,
name|dp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|dp
operator|==
name|into
condition|)
name|strcpy
argument_list|(
name|into
argument_list|,
literal|"/"
argument_list|)
operator|,
name|dp
operator|=
name|into
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|into
index|[
name|strlen
argument_list|(
name|into
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|into
argument_list|,
literal|"/"
argument_list|)
operator|,
name|dp
operator|+=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|into
argument_list|,
name|file
argument_list|)
expr_stmt|;
name|dp
operator|+=
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
comment|/* stay at the end */
block|}
name|file
operator|=
name|sp
operator|+
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|sp
operator|!=
literal|0
condition|)
do|;
block|}
end_block

begin_if
if|#
directive|if
name|defined
argument_list|(
name|UNIX
argument_list|)
end_if

begin_if
if|#
directive|if
name|defined
argument_list|(
name|YP_PASSWD
argument_list|)
end_if

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_function
name|private
name|void
name|get_hdir
parameter_list|(
name|user
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|char
modifier|*
name|user
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|getpwnam
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|endpwent
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|add_mess
argument_list|(
literal|" [unknown user: %s]"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
name|p
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
block|}
end_block

begin_else
else|#
directive|else
end_else

begin_function
name|private
name|get_hdir
parameter_list|(
name|user
parameter_list|,
name|buf
parameter_list|)
specifier|register
name|char
modifier|*
name|user
decl_stmt|,
decl|*
name|buf
decl_stmt|;
end_function

begin_block
block|{
name|char
name|fbuf
index|[
name|LBSIZE
index|]
decl_stmt|,
name|pattern
index|[
literal|100
index|]
decl_stmt|;
specifier|register
name|int
name|u_len
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
name|u_len
operator|=
name|strlen
argument_list|(
name|user
argument_list|)
expr_stmt|;
name|fp
operator|=
name|open_file
argument_list|(
literal|"/etc/passwd"
argument_list|,
name|fbuf
argument_list|,
name|F_READ
argument_list|,
name|YES
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|swritef
argument_list|(
name|pattern
argument_list|,
literal|"%s:[^:]*:[^:]*:[^:]*:[^:]*:\\([^:]*\\):"
argument_list|,
name|user
argument_list|)
expr_stmt|;
while|while
condition|(
name|f_gets
argument_list|(
name|fp
argument_list|,
name|genbuf
argument_list|,
name|LBSIZE
argument_list|)
operator|!=
name|EOF
condition|)
if|if
condition|(
operator|(
name|strncmp
argument_list|(
name|genbuf
argument_list|,
name|user
argument_list|,
name|u_len
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|LookingAt
argument_list|(
name|pattern
argument_list|,
name|genbuf
argument_list|,
literal|0
argument_list|)
operator|)
condition|)
block|{
name|putmatch
argument_list|(
literal|1
argument_list|,
name|buf
argument_list|,
name|FILESIZE
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
return|return;
block|}
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|add_mess
argument_list|(
literal|" [unknown user: %s]"
argument_list|,
name|user
argument_list|)
expr_stmt|;
name|SitFor
argument_list|(
literal|7
argument_list|)
expr_stmt|;
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* YP_PASSWD */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* UNIX */
end_comment

begin_function
name|void
name|PathParse
parameter_list|(
name|name
parameter_list|,
name|intobuf
parameter_list|)
name|char
modifier|*
name|name
decl_stmt|,
decl|*
name|intobuf
decl_stmt|;
end_function

begin_block
block|{
name|char
name|localbuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|intobuf
index|[
literal|0
index|]
operator|=
name|localbuf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|name
operator|==
literal|'\0'
condition|)
return|return;
if|if
condition|(
operator|*
name|name
operator|==
literal|'~'
condition|)
block|{
if|if
condition|(
name|name
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|name
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
block|{
name|strcpy
argument_list|(
name|localbuf
argument_list|,
name|HomeDir
argument_list|)
expr_stmt|;
name|name
operator|+=
literal|1
expr_stmt|;
block|}
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
comment|/* may add for mac in future */
else|else
block|{
name|char
modifier|*
name|uendp
init|=
name|strchr
argument_list|(
name|name
argument_list|,
literal|'/'
argument_list|)
decl_stmt|,
name|unamebuf
index|[
literal|30
index|]
decl_stmt|;
if|if
condition|(
name|uendp
operator|==
literal|0
condition|)
name|uendp
operator|=
name|name
operator|+
name|strlen
argument_list|(
name|name
argument_list|)
expr_stmt|;
name|name
operator|+=
literal|1
expr_stmt|;
name|null_ncpy
argument_list|(
name|unamebuf
argument_list|,
name|name
argument_list|,
call|(
name|size_t
call|)
argument_list|(
name|uendp
operator|-
name|name
argument_list|)
argument_list|)
expr_stmt|;
name|get_hdir
argument_list|(
name|unamebuf
argument_list|,
name|localbuf
argument_list|)
expr_stmt|;
name|name
operator|=
name|uendp
expr_stmt|;
block|}
endif|#
directive|endif
block|}
ifndef|#
directive|ifndef
name|MSDOS
elseif|else
if|if
condition|(
operator|*
name|name
operator|==
literal|'\\'
condition|)
name|name
operator|+=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|localbuf
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|dfollow
argument_list|(
name|localbuf
argument_list|,
name|intobuf
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|filemunge
parameter_list|(
name|newname
parameter_list|)
name|char
modifier|*
name|newname
decl_stmt|;
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
name|newname
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|stat
argument_list|(
name|newname
argument_list|,
operator|&
name|stbuf
argument_list|)
condition|)
return|return;
ifndef|#
directive|ifndef
name|MSDOS
if|if
condition|(
operator|(
operator|(
name|stbuf
operator|.
name|st_dev
operator|!=
name|curbuf
operator|->
name|b_dev
operator|)
operator|||
operator|(
name|stbuf
operator|.
name|st_ino
operator|!=
name|curbuf
operator|->
name|b_ino
operator|)
operator|)
operator|&&
else|#
directive|else
comment|/* MSDOS */
if|if
condition|(
comment|/* (stbuf.st_ino != curbuf->b_ino)&& */
endif|#
directive|endif
comment|/* MSDOS */
ifndef|#
directive|ifndef
name|MAC
operator|(
operator|(
name|stbuf
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFCHR
operator|)
operator|&&
endif|#
directive|endif
operator|(
name|curbuf
operator|->
name|b_fname
operator|==
name|NIL
operator|||
name|strcmp
argument_list|(
name|newname
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|confirm
argument_list|(
literal|"\"%s\" already exists; overwrite it? "
argument_list|,
name|newname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|WrtReg
parameter_list|()
block|{
name|DoWriteReg
argument_list|(
name|NO
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|AppReg
parameter_list|()
block|{
name|DoWriteReg
argument_list|(
name|YES
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|CreatMode
init|=
name|DFLT_MODE
decl_stmt|;
end_decl_stmt

begin_function
name|private
name|void
name|DoWriteReg
parameter_list|(
name|app
parameter_list|)
name|int
name|app
decl_stmt|;
block|{
name|char
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|,
modifier|*
name|fname
decl_stmt|;
name|Mark
modifier|*
name|mp
init|=
name|CurMark
argument_list|()
decl_stmt|;
name|File
modifier|*
name|fp
decl_stmt|;
comment|/* Won't get here if there isn't a Mark */
name|fname
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BACKUPFILES
if|if
condition|(
name|app
operator|==
name|NO
condition|)
block|{
name|filemunge
argument_list|(
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
name|BkupOnWrite
condition|)
name|file_backup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|!
name|app
condition|)
name|filemunge
argument_list|(
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
name|iobuff
argument_list|,
name|app
condition|?
name|F_APPEND
else|:
name|F_WRITE
argument_list|,
name|YES
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|putreg
argument_list|(
name|fp
argument_list|,
name|mp
operator|->
name|m_line
argument_list|,
name|mp
operator|->
name|m_char
argument_list|,
name|curline
argument_list|,
name|curchar
argument_list|,
name|YES
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|int
name|OkayBadChars
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|WriteFile
parameter_list|()
block|{
name|char
modifier|*
name|fname
decl_stmt|,
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|Macmode
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fname
operator|=
name|pfile
argument_list|(
name|fnamebuf
argument_list|)
operator|)
condition|)
return|return;
block|}
else|else
endif|#
directive|endif
comment|/* MAC */
name|fname
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
comment|/* Don't allow bad characters when creating new files. */
if|if
condition|(
operator|!
name|OkayBadChars
operator|&&
operator|(
name|curbuf
operator|->
name|b_fname
operator|==
name|NIL
operator|||
name|strcmp
argument_list|(
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
operator|!=
literal|0
operator|)
condition|)
block|{
ifdef|#
directive|ifdef
name|UNIX
specifier|static
name|char
modifier|*
name|badchars
init|=
literal|"!$^&*()~`{}\"'\\|<>? "
decl_stmt|;
endif|#
directive|endif
comment|/* UNIX */
ifdef|#
directive|ifdef
name|MSDOS
specifier|static
name|char
modifier|*
name|badchars
init|=
literal|"*|<>? "
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
ifdef|#
directive|ifdef
name|MAC
specifier|static
name|char
modifier|*
name|badchars
init|=
literal|":"
decl_stmt|;
endif|#
directive|endif
comment|/* MAC */
specifier|register
name|char
modifier|*
name|cp
init|=
name|fnamebuf
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|cp
operator|++
operator|&
name|CHARMASK
operator|)
operator|!=
literal|'\0'
condition|)
comment|/* avoid sign extension... */
if|if
condition|(
name|c
operator|<
literal|' '
operator|||
name|c
operator|==
literal|'\177'
operator|||
name|strchr
argument_list|(
name|badchars
argument_list|,
name|c
argument_list|)
condition|)
name|complain
argument_list|(
literal|"'%p': bad character in filename."
argument_list|,
name|c
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
operator|!
name|defined
argument_list|(
name|MAC
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|MSDOS
argument_list|)
name|chk_mtime
argument_list|(
name|curbuf
argument_list|,
name|fname
argument_list|,
literal|"write"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filemunge
argument_list|(
name|fname
argument_list|)
expr_stmt|;
name|curbuf
operator|->
name|b_type
operator|=
name|B_FILE
expr_stmt|;
comment|/* in case it wasn't before */
name|setfname
argument_list|(
name|curbuf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|file_write
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Open file FNAME supplying the buffer IO routine with buffer BUF.    HOW is F_READ, F_WRITE or F_APPEND.  IFBAD == COMPLAIN means that    if we fail at opening the file, call complain.  LOUDNESS says    whether or not to print the "reading ..." message on the message    line.     NOTE:  This opens the pr_name(fname, NO) of fname.  That is, FNAME 	  is usually an entire pathname, which can be slow when the 	  pathname is long and there are lots of symbolic links along 	  the way (which has become very common in my experience).  So, 	  this speeds up opens file names in the local directory.  It 	  will not speed up things like "../scm/foo.scm" simple because 	  by the time we get here that's already been expanded to an 	  absolute pathname.  But this is a start.    */
end_comment

begin_function
name|File
modifier|*
name|open_file
parameter_list|(
name|fname
parameter_list|,
name|buf
parameter_list|,
name|how
parameter_list|,
name|complainifbad
parameter_list|,
name|quiet
parameter_list|)
specifier|register
name|char
modifier|*
name|fname
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
specifier|register
name|int
name|how
decl_stmt|;
name|int
name|complainifbad
decl_stmt|,
name|quiet
decl_stmt|;
block|{
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
name|io_chars
operator|=
literal|0
expr_stmt|;
name|io_lines
operator|=
literal|0
expr_stmt|;
name|fp
operator|=
name|f_open
argument_list|(
name|pr_name
argument_list|(
name|fname
argument_list|,
name|NO
argument_list|)
argument_list|,
name|how
argument_list|,
name|buf
argument_list|,
name|LBSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp
operator|==
name|NIL
condition|)
block|{
name|message
argument_list|(
name|IOerr
argument_list|(
operator|(
name|how
operator|==
name|F_READ
operator|)
condition|?
literal|"open"
else|:
literal|"create"
argument_list|,
name|fname
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|complainifbad
condition|)
name|complain
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|rd_only
init|=
name|FALSE
decl_stmt|;
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|access
argument_list|(
name|pr_name
argument_list|(
name|fname
argument_list|,
name|NO
argument_list|)
argument_list|,
name|W_OK
argument_list|)
operator|==
operator|-
literal|1
operator|&&
name|errno
operator|!=
name|ENOENT
condition|)
block|{
name|rd_only
operator|=
name|TRUE
expr_stmt|;
name|fp
operator|->
name|f_flags
operator||=
name|F_READONLY
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|quiet
condition|)
block|{
name|fp
operator|->
name|f_flags
operator||=
name|F_TELLALL
expr_stmt|;
name|f_mess
argument_list|(
literal|"\"%s\"%s"
argument_list|,
name|pr_name
argument_list|(
name|fname
argument_list|,
name|YES
argument_list|)
argument_list|,
name|rd_only
condition|?
literal|" [Read only]"
else|:
name|NullStr
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|fp
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|MSDOS
end_ifndef

begin_comment
comment|/* Check to see if the file has been modified since it was    last written.  If so, make sure they know what they're    doing.     I hate to use another stat(), but to use confirm we gotta    do this before we open the file.     NOTE: This stats FNAME after converting it to a path-relative 	 name.  I can't see why this would cause a problem ...    */
end_comment

begin_function
name|void
name|chk_mtime
parameter_list|(
name|thisbuf
parameter_list|,
name|fname
parameter_list|,
name|how
parameter_list|)
name|Buffer
modifier|*
name|thisbuf
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|,
decl|*
name|how
decl_stmt|;
end_function

begin_block
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
name|Buffer
modifier|*
name|b
decl_stmt|;
name|char
modifier|*
name|mesg
init|=
literal|"Shall I go ahead and %s anyway? "
decl_stmt|;
if|if
condition|(
operator|(
name|thisbuf
operator|->
name|b_mtime
operator|!=
literal|0
operator|)
operator|&&
comment|/* if we care ... */
operator|(
operator|(
name|b
operator|=
name|file_exists
argument_list|(
name|fname
argument_list|)
operator|)
operator|!=
name|NIL
operator|)
operator|&&
comment|/* we already have this file */
operator|(
name|b
operator|==
name|thisbuf
operator|)
operator|&&
comment|/* and it's the current buffer */
operator|(
name|stat
argument_list|(
name|pr_name
argument_list|(
name|fname
argument_list|,
name|NO
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|!=
operator|-
literal|1
operator|)
operator|&&
comment|/* and we can stat it */
operator|(
name|stbuf
operator|.
name|st_mtime
operator|!=
name|b
operator|->
name|b_mtime
operator|)
condition|)
block|{
comment|/* and there's trouble. */
name|rbell
argument_list|()
expr_stmt|;
name|redisplay
argument_list|()
expr_stmt|;
comment|/* Ring that bell! */
name|TOstart
argument_list|(
literal|"Warning"
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"\"%s\" now saved on disk is not what you last"
argument_list|,
name|pr_name
argument_list|(
name|fname
argument_list|,
name|YES
argument_list|)
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"visited or saved.  Probably someone else is editing"
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"your file at the same time."
argument_list|)
expr_stmt|;
if|if
condition|(
name|how
condition|)
block|{
name|Typeout
argument_list|(
literal|""
argument_list|)
expr_stmt|;
name|Typeout
argument_list|(
literal|"Type \"y\" if I should %s, anyway."
argument_list|,
name|how
argument_list|)
expr_stmt|;
name|f_mess
argument_list|(
name|mesg
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
name|TOstop
argument_list|()
expr_stmt|;
if|if
condition|(
name|how
condition|)
name|confirm
argument_list|(
name|mesg
argument_list|,
name|how
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MSDOS */
end_comment

begin_function
name|void
name|file_write
parameter_list|(
name|fname
parameter_list|,
name|app
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|app
decl_stmt|;
block|{
name|File
modifier|*
name|fp
decl_stmt|;
ifdef|#
directive|ifdef
name|BACKUPFILES
if|if
condition|(
operator|!
name|app
operator|&&
name|BkupOnWrite
condition|)
name|file_backup
argument_list|(
name|fname
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fp
operator|=
name|open_file
argument_list|(
name|fname
argument_list|,
name|iobuff
argument_list|,
name|app
condition|?
name|F_APPEND
else|:
name|F_WRITE
argument_list|,
name|YES
argument_list|,
name|NO
argument_list|)
expr_stmt|;
if|if
condition|(
name|EndWNewline
condition|)
block|{
comment|/* Make sure file ends with a newLine */
name|Bufpos
name|save
decl_stmt|;
name|DOTsave
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
name|ToLast
argument_list|()
expr_stmt|;
if|if
condition|(
name|length
argument_list|(
name|curline
argument_list|)
condition|)
comment|/* Not a blank Line */
name|LineInsert
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|SetDot
argument_list|(
operator|&
name|save
argument_list|)
expr_stmt|;
block|}
name|putreg
argument_list|(
name|fp
argument_list|,
name|curbuf
operator|->
name|b_first
argument_list|,
literal|0
argument_list|,
name|curbuf
operator|->
name|b_last
argument_list|,
name|length
argument_list|(
name|curbuf
operator|->
name|b_last
argument_list|)
argument_list|,
name|NO
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|set_ino
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|unmodify
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|ReadFile
parameter_list|()
block|{
name|Buffer
modifier|*
name|bp
decl_stmt|;
name|char
modifier|*
name|fname
decl_stmt|,
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
name|int
name|lineno
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|Macmode
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fname
operator|=
name|gfile
argument_list|(
name|fnamebuf
argument_list|)
operator|)
condition|)
return|return;
block|}
else|else
endif|#
directive|endif
comment|/* MAC */
name|fname
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
if|#
directive|if
operator|!
operator|(
name|defined
argument_list|(
name|MSDOS
argument_list|)
operator|||
name|defined
argument_list|(
name|MAC
argument_list|)
operator|)
name|chk_mtime
argument_list|(
name|curbuf
argument_list|,
name|fname
argument_list|,
literal|"read"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS || MAC */
if|if
condition|(
name|IsModified
argument_list|(
name|curbuf
argument_list|)
condition|)
block|{
name|char
modifier|*
name|y_or_n
decl_stmt|;
name|int
name|c
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|rbell
argument_list|()
expr_stmt|;
name|y_or_n
operator|=
name|ask
argument_list|(
name|NullStr
argument_list|,
literal|"Shall I make your changes to \"%s\" permanent? "
argument_list|,
name|curbuf
operator|->
name|b_name
argument_list|)
expr_stmt|;
name|c
operator|=
name|CharUpcase
argument_list|(
operator|*
name|y_or_n
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'Y'
operator|||
name|c
operator|==
literal|'N'
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
literal|'Y'
condition|)
name|SaveFile
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|bp
operator|=
name|file_exists
argument_list|(
name|fnamebuf
argument_list|)
operator|)
operator|!=
name|NIL
operator|&&
operator|(
name|bp
operator|==
name|curbuf
operator|)
condition|)
name|lineno
operator|=
name|pnt_line
argument_list|()
operator|-
literal|1
expr_stmt|;
else|else
name|lineno
operator|=
literal|0
expr_stmt|;
name|unmodify
argument_list|()
expr_stmt|;
name|initlist
argument_list|(
name|curbuf
argument_list|)
expr_stmt|;
name|setfname
argument_list|(
name|curbuf
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|read_file
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|SetLine
argument_list|(
name|next_line
argument_list|(
name|curbuf
operator|->
name|b_first
argument_list|,
name|lineno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|InsFile
parameter_list|()
block|{
name|char
modifier|*
name|fname
decl_stmt|,
name|fnamebuf
index|[
name|FILESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
if|if
condition|(
name|Macmode
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|fname
operator|=
name|gfile
argument_list|(
name|fnamebuf
argument_list|)
operator|)
condition|)
return|return;
block|}
else|else
endif|#
directive|endif
comment|/* MAC */
name|fname
operator|=
name|ask_file
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|,
name|curbuf
operator|->
name|b_fname
argument_list|,
name|fnamebuf
argument_list|)
expr_stmt|;
name|read_file
argument_list|(
name|fname
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_include
include|#
directive|include
file|"temp.h"
end_include

begin_decl_stmt
name|int
name|DOLsave
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Do Lsave flag.  If lines aren't being saved 			   when you think they should have been, this 			   flag is probably not being set, or is being 			   cleared before lsave() was called. */
end_comment

begin_decl_stmt
name|private
name|int
name|nleft
decl_stmt|,
comment|/* number of good characters left in current block */
name|tmpfd
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|daddr
name|DFree
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to end of tmp file */
end_comment

begin_decl_stmt
name|private
name|char
modifier|*
name|tfname
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|tmpinit
parameter_list|()
block|{
name|char
name|buf
index|[
name|FILESIZE
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|MAC
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|HomeDir
argument_list|,
name|d_tempfile
argument_list|)
expr_stmt|;
else|#
directive|else
name|swritef
argument_list|(
name|buf
argument_list|,
literal|"%s/%s"
argument_list|,
name|TmpFilePath
argument_list|,
name|d_tempfile
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|tfname
operator|=
name|copystr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|tfname
operator|=
name|mktemp
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|creat
argument_list|(
name|tfname
argument_list|,
literal|0600
argument_list|)
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|MSDOS
name|tmpfd
operator|=
name|open
argument_list|(
name|tfname
argument_list|,
literal|2
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|tmpfd
operator|=
name|open
argument_list|(
name|tfname
argument_list|,
literal|0x8002
argument_list|)
expr_stmt|;
comment|/* MSDOS fix	*/
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
name|tmpfd
operator|==
operator|-
literal|1
condition|)
name|complain
argument_list|(
literal|"Warning: cannot create tmp file!"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tmpclose
parameter_list|()
block|{
if|if
condition|(
name|tmpfd
operator|==
operator|-
literal|1
condition|)
return|return;
operator|(
name|void
operator|)
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
operator|-
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tfname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* get a line at `tl' in the tmp file into `buf' which should be LBSIZE    long */
end_comment

begin_decl_stmt
name|int
name|Jr_Len
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of Just Read Line */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_comment
comment|/* The Lighspeed compiler can't copy with static here */
end_comment

begin_function_decl
name|char
modifier|*
name|getblock
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_function_decl
name|private
name|char
modifier|*
name|getblock
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|getline
parameter_list|(
name|addr
parameter_list|,
name|buf
parameter_list|)
name|daddr
name|addr
decl_stmt|;
specifier|register
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|addr
operator|>>
literal|1
argument_list|,
name|READ
argument_list|)
expr_stmt|;
do|do
empty_stmt|;
do|while
condition|(
operator|(
operator|*
name|lp
operator|++
operator|=
operator|*
name|bp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
do|;
name|Jr_Len
operator|=
operator|(
name|lp
operator|-
name|buf
operator|)
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Put `buf' and return the disk address */
end_comment

begin_function
name|daddr
name|putline
parameter_list|(
name|buf
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|,
modifier|*
name|lp
decl_stmt|;
specifier|register
name|int
name|nl
decl_stmt|;
name|daddr
name|free_ptr
decl_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
name|free_ptr
operator|=
name|DFree
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|free_ptr
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|free_ptr
operator|=
name|blk_round
argument_list|(
name|free_ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|bp
operator|=
operator|*
name|lp
operator|++
operator|)
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|bp
operator|++
operator|==
literal|'\n'
condition|)
block|{
operator|*
operator|--
name|bp
operator|=
literal|0
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
name|free_ptr
operator|=
name|forward_block
argument_list|(
name|free_ptr
argument_list|)
expr_stmt|;
name|DFree
operator|=
name|free_ptr
expr_stmt|;
name|bp
operator|=
name|getblock
argument_list|(
name|free_ptr
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|lp
operator|=
name|buf
expr_stmt|;
comment|/* start over ... */
name|nl
operator|=
name|nleft
expr_stmt|;
block|}
block|}
name|free_ptr
operator|=
name|DFree
expr_stmt|;
name|DFree
operator|+=
operator|(
operator|(
operator|(
name|lp
operator|-
name|buf
operator|)
operator|+
name|CH_SIZE
operator|-
literal|1
operator|)
operator|/
name|CH_SIZE
operator|)
expr_stmt|;
comment|/* (lp - buf) includes the null */
return|return
operator|(
name|free_ptr
operator|<<
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* The theory is that critical section of code inside this procedure    will never cause a problem to occur.  Basically, we need to ensure    that two blocks are in memory at the same time, but I think that    this can never screw up. */
end_comment

begin_define
define|#
directive|define
name|lockblock
parameter_list|(
name|addr
parameter_list|)
end_define

begin_define
define|#
directive|define
name|unlockblock
parameter_list|(
name|addr
parameter_list|)
end_define

begin_function
name|daddr
name|f_getputl
parameter_list|(
name|line
parameter_list|,
name|fp
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
specifier|register
name|File
modifier|*
name|fp
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|bp
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|nl
decl_stmt|,
name|room
init|=
name|LBSIZE
decl_stmt|;
name|daddr
name|free_ptr
decl_stmt|;
name|char
modifier|*
name|base
decl_stmt|;
ifdef|#
directive|ifdef
name|MSDOS
name|char
name|crleft
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
name|free_ptr
operator|=
name|DFree
expr_stmt|;
name|base
operator|=
name|bp
operator|=
name|getblock
argument_list|(
name|free_ptr
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|free_ptr
operator|=
name|blk_round
argument_list|(
name|free_ptr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|room
operator|>
literal|0
condition|)
block|{
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|crleft
condition|)
block|{
name|c
operator|=
name|crleft
expr_stmt|;
name|crleft
operator|=
literal|0
expr_stmt|;
block|}
else|else
endif|#
directive|endif
comment|/* MSDOS */
name|c
operator|=
name|jgetc
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
operator|||
name|c
operator|==
literal|'\n'
condition|)
break|break;
ifdef|#
directive|ifdef
name|MSDOS
if|if
condition|(
name|c
operator|==
literal|'\r'
condition|)
if|if
condition|(
operator|(
name|crleft
operator|=
name|jgetc
argument_list|(
name|fp
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|crleft
operator|=
literal|0
expr_stmt|;
break|break;
block|}
endif|#
directive|endif
comment|/* MSDOS */
if|if
condition|(
operator|--
name|nl
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|newbp
decl_stmt|;
name|size_t
name|nbytes
decl_stmt|;
name|lockblock
argument_list|(
name|free_ptr
argument_list|)
expr_stmt|;
name|DFree
operator|=
name|free_ptr
operator|=
name|forward_block
argument_list|(
name|free_ptr
argument_list|)
expr_stmt|;
name|nbytes
operator|=
name|bp
operator|-
name|base
expr_stmt|;
name|newbp
operator|=
name|getblock
argument_list|(
name|free_ptr
argument_list|,
name|WRITE
argument_list|)
expr_stmt|;
name|nl
operator|=
name|nleft
expr_stmt|;
name|byte_copy
argument_list|(
name|base
argument_list|,
name|newbp
argument_list|,
name|nbytes
argument_list|)
expr_stmt|;
name|bp
operator|=
name|newbp
operator|+
name|nbytes
expr_stmt|;
name|base
operator|=
name|newbp
expr_stmt|;
name|unlockblock
argument_list|(
name|free_ptr
argument_list|)
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
name|c
expr_stmt|;
block|}
operator|*
name|bp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|free_ptr
operator|=
name|DFree
expr_stmt|;
name|DFree
operator|+=
operator|(
operator|(
operator|(
name|bp
operator|-
name|base
operator|)
operator|+
name|CH_SIZE
operator|-
literal|1
operator|)
operator|/
name|CH_SIZE
operator|)
expr_stmt|;
name|line
operator|->
name|l_dline
operator|=
operator|(
name|free_ptr
operator|<<
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|room
operator|==
literal|0
condition|)
block|{
name|add_mess
argument_list|(
literal|" [Line too long]"
argument_list|)
expr_stmt|;
name|rbell
argument_list|()
expr_stmt|;
return|return
name|EOF
return|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
operator|--
name|bp
operator|!=
name|base
condition|)
name|add_mess
argument_list|(
literal|" [Incomplete last line]"
argument_list|)
expr_stmt|;
return|return
name|EOF
return|;
block|}
name|io_lines
operator|+=
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_typedef
typedef|typedef
struct|struct
name|block
block|{
name|short
name|b_dirty
decl_stmt|,
name|b_bno
decl_stmt|;
name|char
name|b_buf
index|[
name|JBUFSIZ
index|]
decl_stmt|;
name|struct
name|block
modifier|*
name|b_LRUnext
decl_stmt|,
modifier|*
name|b_LRUprev
decl_stmt|,
modifier|*
name|b_HASHnext
decl_stmt|;
block|}
name|Block
typedef|;
end_typedef

begin_define
define|#
directive|define
name|HASHSIZE
value|7
end_define

begin_comment
comment|/* Primes work best (so I'm told) */
end_comment

begin_define
define|#
directive|define
name|B_HASH
parameter_list|(
name|bno
parameter_list|)
value|((bno) % HASHSIZE)
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_decl_stmt
name|private
name|Block
modifier|*
name|b_cache
decl_stmt|,
else|#
directive|else
name|private
name|Block
name|b_cache
index|[
name|NBUF
index|]
decl_stmt|,
endif|#
directive|endif
modifier|*
name|bht
index|[
name|HASHSIZE
index|]
decl_stmt|,
comment|/* Block hash table. Must be zero initially */
modifier|*
name|f_block
init|=
literal|0
decl_stmt|,
modifier|*
name|l_block
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|int
name|max_bno
init|=
operator|-
literal|1
decl_stmt|,
name|NBlocks
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_function_decl
name|void
function_decl|(
modifier|*
name|blkio
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|private
name|void
argument_list|(
operator|*
name|blkio
argument_list|)
name|proto
argument_list|(
operator|(
name|Block
operator|*
operator|,
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|MAC
end_ifdef

begin_macro
name|make_cache
argument_list|()
end_macro

begin_comment
comment|/* Only 32K of static space on Mac, so... */
end_comment

begin_block
block|{
return|return
operator|(
operator|(
name|b_cache
operator|=
operator|(
name|Block
operator|*
operator|)
name|calloc
argument_list|(
name|NBUF
argument_list|,
sizeof|sizeof
argument_list|(
name|Block
argument_list|)
argument_list|)
operator|)
operator|==
literal|0
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|read
argument_list|()
decl_stmt|,
name|write
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|private
name|void
name|real_blkio
argument_list|(
name|b
argument_list|,
name|iofcn
argument_list|)
decl|register
name|Block
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MAC
argument_list|)
operator|||
name|defined
argument_list|(
name|IBMPC
argument_list|)
end_if

begin_function_decl
specifier|register
name|int
function_decl|(
modifier|*
name|iofcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_else
else|#
directive|else
end_else

begin_expr_stmt
specifier|register
name|int
argument_list|(
argument|*iofcn
argument_list|)
name|proto
argument_list|(
operator|(
name|int
operator|,
name|UnivPtr
operator|,
name|size_t
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MAC */
end_comment

begin_block
block|{
operator|(
name|void
operator|)
name|lseek
argument_list|(
name|tmpfd
argument_list|,
call|(
name|long
call|)
argument_list|(
operator|(
name|unsigned
operator|)
name|b
operator|->
name|b_bno
argument_list|)
operator|*
name|JBUFSIZ
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|iofcn
call|)
argument_list|(
name|tmpfd
argument_list|,
name|b
operator|->
name|b_buf
argument_list|,
operator|(
name|size_t
operator|)
name|JBUFSIZ
argument_list|)
operator|!=
name|JBUFSIZ
condition|)
name|error
argument_list|(
literal|"[Tmp file %s error; to continue editing would be dangerous]"
argument_list|,
operator|(
name|iofcn
operator|==
name|read
operator|)
condition|?
literal|"READ"
else|:
literal|"WRITE"
argument_list|)
expr_stmt|;
block|}
end_block

begin_decl_stmt
name|private
name|void
name|fake_blkio
argument_list|(
name|b
argument_list|,
name|iofcn
argument_list|)
decl|register
name|Block
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|register
name|int
function_decl|(
modifier|*
name|iofcn
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
name|tmpinit
argument_list|()
expr_stmt|;
name|blkio
operator|=
name|real_blkio
expr_stmt|;
name|real_blkio
argument_list|(
name|b
argument_list|,
name|iofcn
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|d_cache_init
parameter_list|()
block|{
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|,
comment|/* Block pointer */
modifier|*
modifier|*
name|hp
decl_stmt|;
comment|/* Hash pointer */
specifier|register
name|short
name|bno
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|b_cache
operator|,
name|bno
operator|=
name|NBUF
init|;
operator|--
name|bno
operator|>=
literal|0
condition|;
name|bp
operator|++
control|)
block|{
name|NBlocks
operator|+=
literal|1
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_bno
operator|=
name|bno
expr_stmt|;
if|if
condition|(
name|l_block
operator|==
literal|0
condition|)
name|l_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUprev
operator|=
literal|0
expr_stmt|;
name|bp
operator|->
name|b_LRUnext
operator|=
name|f_block
expr_stmt|;
if|if
condition|(
name|f_block
operator|!=
literal|0
condition|)
name|f_block
operator|->
name|b_LRUprev
operator|=
name|bp
expr_stmt|;
name|f_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_HASHnext
operator|=
operator|*
operator|(
name|hp
operator|=
operator|&
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
operator|)
expr_stmt|;
operator|*
name|hp
operator|=
name|bp
expr_stmt|;
block|}
name|blkio
operator|=
name|fake_blkio
expr_stmt|;
block|}
end_function

begin_function
name|void
name|SyncTmp
parameter_list|()
block|{
specifier|register
name|Block
modifier|*
name|b
decl_stmt|;
ifdef|#
directive|ifdef
name|IBMPC
specifier|register
name|int
name|bno
init|=
literal|0
decl_stmt|;
comment|/* sync the blocks in order, for file systems that don't allow 	   holes (MSDOS).  Perhaps this benefits floppy-based file systems. */
for|for
control|(
name|bno
operator|=
literal|0
init|;
name|bno
operator|<=
name|max_bno
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|b
operator|=
name|lookup
argument_list|(
name|bno
operator|++
argument_list|)
operator|)
operator|&&
name|b
operator|->
name|b_dirty
condition|)
block|{
call|(
modifier|*
name|blkio
call|)
argument_list|(
name|b
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|#
directive|else
for|for
control|(
name|b
operator|=
name|f_block
init|;
name|b
operator|!=
literal|0
condition|;
name|b
operator|=
name|b
operator|->
name|b_LRUnext
control|)
if|if
condition|(
name|b
operator|->
name|b_dirty
condition|)
block|{
call|(
modifier|*
name|blkio
call|)
argument_list|(
name|b
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|b
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_function
name|private
name|Block
modifier|*
name|lookup
parameter_list|(
name|bno
parameter_list|)
specifier|register
name|short
name|bno
decl_stmt|;
block|{
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|;
for|for
control|(
name|bp
operator|=
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
init|;
name|bp
operator|!=
literal|0
condition|;
name|bp
operator|=
name|bp
operator|->
name|b_HASHnext
control|)
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|==
name|bno
condition|)
break|break;
return|return
name|bp
return|;
block|}
end_function

begin_function
name|private
name|void
name|LRUunlink
parameter_list|(
name|b
parameter_list|)
specifier|register
name|Block
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
name|b
operator|->
name|b_LRUprev
operator|==
literal|0
condition|)
name|f_block
operator|=
name|b
operator|->
name|b_LRUnext
expr_stmt|;
else|else
name|b
operator|->
name|b_LRUprev
operator|->
name|b_LRUnext
operator|=
name|b
operator|->
name|b_LRUnext
expr_stmt|;
if|if
condition|(
name|b
operator|->
name|b_LRUnext
operator|==
literal|0
condition|)
name|l_block
operator|=
name|b
operator|->
name|b_LRUprev
expr_stmt|;
else|else
name|b
operator|->
name|b_LRUnext
operator|->
name|b_LRUprev
operator|=
name|b
operator|->
name|b_LRUprev
expr_stmt|;
block|}
end_function

begin_function
name|private
name|Block
modifier|*
name|b_unlink
parameter_list|(
name|bp
parameter_list|)
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|;
block|{
specifier|register
name|Block
modifier|*
name|hp
decl_stmt|,
modifier|*
name|prev
init|=
literal|0
decl_stmt|;
name|LRUunlink
argument_list|(
name|bp
argument_list|)
expr_stmt|;
comment|/* Now that we have the block, we remove it from its position 	   in the hash table, so we can THEN put it somewhere else with 	   it's new block assignment. */
for|for
control|(
name|hp
operator|=
name|bht
index|[
name|B_HASH
argument_list|(
name|bp
operator|->
name|b_bno
argument_list|)
index|]
init|;
name|hp
operator|!=
literal|0
condition|;
name|prev
operator|=
name|hp
operator|,
name|hp
operator|=
name|hp
operator|->
name|b_HASHnext
control|)
if|if
condition|(
name|hp
operator|==
name|bp
condition|)
break|break;
if|if
condition|(
name|hp
operator|==
literal|0
condition|)
block|{
name|writef
argument_list|(
literal|"\rBlock %d missing!"
argument_list|,
name|bp
operator|->
name|b_bno
argument_list|)
expr_stmt|;
name|finish
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|b_HASHnext
operator|=
name|hp
operator|->
name|b_HASHnext
expr_stmt|;
else|else
name|bht
index|[
name|B_HASH
argument_list|(
name|bp
operator|->
name|b_bno
argument_list|)
index|]
operator|=
name|hp
operator|->
name|b_HASHnext
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dirty
condition|)
block|{
comment|/* do, now, the delayed write */
call|(
modifier|*
name|blkio
call|)
argument_list|(
name|bp
argument_list|,
name|write
argument_list|)
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|bp
return|;
block|}
end_function

begin_comment
comment|/* Get a block which contains at least part of the line with the address    atl.  Returns a pointer to the block and sets the global variable    nleft (number of good characters left in the buffer). */
end_comment

begin_function
name|private
name|char
modifier|*
name|getblock
parameter_list|(
name|atl
parameter_list|,
name|iof
parameter_list|)
name|daddr
name|atl
decl_stmt|;
name|int
name|iof
decl_stmt|;
block|{
specifier|register
name|int
name|bno
decl_stmt|,
name|off
decl_stmt|;
specifier|register
name|Block
modifier|*
name|bp
decl_stmt|;
specifier|static
name|Block
modifier|*
name|lastb
init|=
literal|0
decl_stmt|;
name|bno
operator|=
name|da_to_bno
argument_list|(
name|atl
argument_list|)
expr_stmt|;
name|off
operator|=
name|da_to_off
argument_list|(
name|atl
argument_list|)
expr_stmt|;
if|if
condition|(
name|da_too_huge
argument_list|(
name|atl
argument_list|)
condition|)
name|error
argument_list|(
literal|"Tmp file too large.  Get help!"
argument_list|)
expr_stmt|;
name|nleft
operator|=
name|JBUFSIZ
operator|-
name|off
expr_stmt|;
if|if
condition|(
name|lastb
operator|!=
literal|0
operator|&&
name|lastb
operator|->
name|b_bno
operator|==
name|bno
condition|)
block|{
name|lastb
operator|->
name|b_dirty
operator||=
name|iof
expr_stmt|;
return|return
name|lastb
operator|->
name|b_buf
operator|+
name|off
return|;
block|}
comment|/* The requested block already lives in memory, so we move 	   it to the end of the LRU list (making it Most Recently Used) 	   and then return a pointer to it. */
if|if
condition|(
operator|(
name|bp
operator|=
name|lookup
argument_list|(
name|bno
argument_list|)
operator|)
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|bp
operator|!=
name|l_block
condition|)
block|{
name|LRUunlink
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_block
operator|==
literal|0
condition|)
name|f_block
operator|=
name|l_block
operator|=
name|bp
expr_stmt|;
else|else
name|l_block
operator|->
name|b_LRUnext
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUprev
operator|=
name|l_block
expr_stmt|;
name|l_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUnext
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|>
name|max_bno
condition|)
name|max_bno
operator|=
name|bp
operator|->
name|b_bno
expr_stmt|;
name|bp
operator|->
name|b_dirty
operator||=
name|iof
expr_stmt|;
name|lastb
operator|=
name|bp
expr_stmt|;
return|return
name|bp
operator|->
name|b_buf
operator|+
name|off
return|;
block|}
comment|/* The block we want doesn't reside in memory so we take the 	   least recently used clean block (if there is one) and use 	   it.  */
name|bp
operator|=
name|f_block
expr_stmt|;
if|if
condition|(
name|bp
operator|->
name|b_dirty
condition|)
comment|/* The best block is dirty ... */
name|SyncTmp
argument_list|()
expr_stmt|;
name|bp
operator|=
name|b_unlink
argument_list|(
name|bp
argument_list|)
expr_stmt|;
if|if
condition|(
name|l_block
operator|==
literal|0
condition|)
name|l_block
operator|=
name|f_block
operator|=
name|bp
expr_stmt|;
else|else
name|l_block
operator|->
name|b_LRUnext
operator|=
name|bp
expr_stmt|;
comment|/* Place it at the end ... */
name|bp
operator|->
name|b_LRUprev
operator|=
name|l_block
expr_stmt|;
name|l_block
operator|=
name|bp
expr_stmt|;
name|bp
operator|->
name|b_LRUnext
operator|=
literal|0
expr_stmt|;
comment|/* so it's Most Recently Used */
name|bp
operator|->
name|b_dirty
operator|=
name|iof
expr_stmt|;
name|bp
operator|->
name|b_bno
operator|=
name|bno
expr_stmt|;
name|bp
operator|->
name|b_HASHnext
operator|=
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
expr_stmt|;
name|bht
index|[
name|B_HASH
argument_list|(
name|bno
argument_list|)
index|]
operator|=
name|bp
expr_stmt|;
comment|/* Get the current contents of the block UNLESS this is a new 	   block that's never been looked at before, i.e., it's past 	   the end of the tmp file. */
if|if
condition|(
name|bp
operator|->
name|b_bno
operator|<=
name|max_bno
condition|)
call|(
modifier|*
name|blkio
call|)
argument_list|(
name|bp
argument_list|,
name|read
argument_list|)
expr_stmt|;
else|else
name|max_bno
operator|=
name|bno
expr_stmt|;
name|lastb
operator|=
name|bp
expr_stmt|;
return|return
name|bp
operator|->
name|b_buf
operator|+
name|off
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|lbptr
parameter_list|(
name|line
parameter_list|)
name|Line
modifier|*
name|line
decl_stmt|;
block|{
return|return
name|getblock
argument_list|(
name|line
operator|->
name|l_dline
operator|>>
literal|1
argument_list|,
name|READ
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* save the current contents of linebuf, if it has changed */
end_comment

begin_function
name|void
name|lsave
parameter_list|()
block|{
if|if
condition|(
name|curbuf
operator|==
literal|0
operator|||
operator|!
name|DOLsave
condition|)
comment|/* Nothing modified recently */
return|return;
if|if
condition|(
name|strcmp
argument_list|(
name|lbptr
argument_list|(
name|curline
argument_list|)
argument_list|,
name|linebuf
argument_list|)
operator|!=
literal|0
condition|)
name|SavLine
argument_list|(
name|curline
argument_list|,
name|linebuf
argument_list|)
expr_stmt|;
comment|/* Put linebuf on the disk. */
name|DOLsave
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|BACKUPFILES
end_ifdef

begin_function
name|private
name|void
name|file_backup
parameter_list|(
name|fname
parameter_list|)
name|char
modifier|*
name|fname
decl_stmt|;
block|{
ifndef|#
directive|ifndef
name|MSDOS
name|char
modifier|*
name|s
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|fd1
decl_stmt|,
name|fd2
decl_stmt|;
name|char
name|tmp1
index|[
name|JBUFSIZ
index|]
decl_stmt|,
name|tmp2
index|[
name|JBUFSIZ
index|]
decl_stmt|;
name|struct
name|stat
name|buf
decl_stmt|;
name|int
name|mode
decl_stmt|;
name|strcpy
argument_list|(
name|tmp1
argument_list|,
name|fname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|s
operator|=
name|strrchr
argument_list|(
name|tmp1
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|swritef
argument_list|(
name|tmp2
argument_list|,
literal|"#%s~"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|s
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|swritef
argument_list|(
name|tmp2
argument_list|,
literal|"%s/#%s~"
argument_list|,
name|tmp1
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|fd1
operator|=
name|open
argument_list|(
name|fname
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
return|return;
comment|/* create backup file with same mode as input file */
ifndef|#
directive|ifndef
name|MAC
if|if
condition|(
name|fstat
argument_list|(
name|fd1
argument_list|,
operator|&
name|buf
argument_list|)
operator|!=
literal|0
condition|)
name|mode
operator|=
name|CreatMode
expr_stmt|;
else|else
endif|#
directive|endif
name|mode
operator|=
name|buf
operator|.
name|st_mode
expr_stmt|;
if|if
condition|(
operator|(
name|fd2
operator|=
name|creat
argument_list|(
name|tmp2
argument_list|,
name|mode
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|i
operator|=
name|read
argument_list|(
name|fd1
argument_list|,
name|tmp1
argument_list|,
sizeof|sizeof
argument_list|(
name|tmp1
argument_list|)
argument_list|)
operator|)
operator|>
literal|0
condition|)
name|write
argument_list|(
name|fd2
argument_list|,
name|tmp1
argument_list|,
operator|(
name|size_t
operator|)
name|i
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BSD4_2
operator|(
name|void
operator|)
name|fsync
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fd1
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* MSDOS */
name|char
modifier|*
name|dot
decl_stmt|,
modifier|*
name|slash
decl_stmt|,
name|tmp
index|[
name|FILESIZE
index|]
decl_stmt|;
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|slash
operator|=
name|basename
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dot
operator|=
name|strrchr
argument_list|(
name|slash
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|stricmp
argument_list|(
name|dot
argument_list|,
literal|".bak"
argument_list|)
condition|)
return|return;
else|else
operator|*
name|dot
operator|=
literal|0
expr_stmt|;
block|}
name|strcat
argument_list|(
name|tmp
argument_list|,
literal|".bak"
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|rename
argument_list|(
name|fname
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* MSDOS */
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|MSDOS
argument_list|)
end_if

begin_function
name|private
name|int
comment|/* chdir + drive */
name|Dchdir
parameter_list|(
name|to
parameter_list|)
name|char
modifier|*
name|to
decl_stmt|;
block|{
name|unsigned
name|d
decl_stmt|,
name|dd
decl_stmt|,
name|n
decl_stmt|;
if|if
condition|(
name|to
index|[
literal|1
index|]
operator|==
literal|':'
condition|)
block|{
name|d
operator|=
name|to
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|'a'
condition|)
name|d
operator|=
name|d
operator|-
literal|'a'
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|d
operator|>=
literal|'A'
condition|)
name|d
operator|=
name|d
operator|-
literal|'A'
operator|+
literal|1
expr_stmt|;
name|_dos_getdrive
argument_list|(
operator|&
name|dd
argument_list|)
expr_stmt|;
if|if
condition|(
name|dd
operator|!=
name|d
condition|)
name|_dos_setdrive
argument_list|(
name|d
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|to
index|[
literal|2
index|]
operator|==
literal|0
condition|)
return|return
literal|0
return|;
block|}
return|return
name|chdir
argument_list|(
name|to
argument_list|)
return|;
block|}
end_function

begin_function
name|private
name|char
modifier|*
name|fixpath
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|char
modifier|*
name|pp
init|=
name|p
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'\\'
condition|)
operator|*
name|p
operator|=
literal|'/'
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|strlwr
argument_list|(
name|pp
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|private
name|void
name|abspath
parameter_list|(
name|so
parameter_list|,
name|dest
parameter_list|)
name|char
modifier|*
name|so
decl_stmt|,
decl|*
name|dest
decl_stmt|;
end_function

begin_block
block|{
name|char
name|cwd
index|[
name|FILESIZE
index|]
decl_stmt|,
name|cwdD
index|[
literal|3
index|]
decl_stmt|,
name|cwdDIR
index|[
name|FILESIZE
index|]
decl_stmt|,
name|cwdF
index|[
literal|9
index|]
decl_stmt|,
name|cwdEXT
index|[
literal|5
index|]
decl_stmt|,
name|soD
index|[
literal|3
index|]
decl_stmt|,
name|soDIR
index|[
name|FILESIZE
index|]
decl_stmt|,
name|soF
index|[
literal|9
index|]
decl_stmt|,
name|soEXT
index|[
literal|5
index|]
decl_stmt|;
name|char
modifier|*
name|drive
decl_stmt|,
modifier|*
name|path
decl_stmt|;
name|_splitpath
argument_list|(
name|fixpath
argument_list|(
name|so
argument_list|)
argument_list|,
name|soD
argument_list|,
name|soDIR
argument_list|,
name|soF
argument_list|,
name|soEXT
argument_list|)
expr_stmt|;
name|getcwd
argument_list|(
name|cwd
argument_list|,
name|FILESIZE
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|soD
operator|!=
literal|0
condition|)
block|{
name|Dchdir
argument_list|(
name|soD
argument_list|)
expr_stmt|;
comment|/* this is kinda messy	*/
name|getcwd
argument_list|(
name|cwdDIR
argument_list|,
name|FILESIZE
argument_list|)
expr_stmt|;
comment|/* should probably just	*/
name|Dchdir
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
comment|/* call DOS to do it	*/
name|strcpy
argument_list|(
name|cwd
argument_list|,
name|cwdDIR
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|fixpath
argument_list|(
name|cwd
argument_list|)
expr_stmt|;
if|if
condition|(
name|cwd
index|[
name|strlen
argument_list|(
name|cwd
argument_list|)
operator|-
literal|1
index|]
operator|!=
literal|'/'
condition|)
name|strcat
argument_list|(
name|cwd
argument_list|,
literal|"/x.x"
argument_list|)
expr_stmt|;
comment|/* need dummy filename */
name|_splitpath
argument_list|(
name|fixpath
argument_list|(
name|cwd
argument_list|)
argument_list|,
name|cwdD
argument_list|,
name|cwdDIR
argument_list|,
name|cwdF
argument_list|,
name|cwdEXT
argument_list|)
expr_stmt|;
name|drive
operator|=
operator|(
operator|*
name|soD
operator|==
literal|0
operator|)
condition|?
name|cwdD
else|:
name|soD
expr_stmt|;
if|if
condition|(
operator|*
name|soDIR
operator|!=
literal|'/'
condition|)
name|path
operator|=
name|strcat
argument_list|(
name|cwdDIR
argument_list|,
name|soDIR
argument_list|)
expr_stmt|;
else|else
name|path
operator|=
name|soDIR
expr_stmt|;
name|_makepath
argument_list|(
name|dest
argument_list|,
name|drive
argument_list|,
name|path
argument_list|,
name|soF
argument_list|,
name|soEXT
argument_list|)
expr_stmt|;
name|fixpath
argument_list|(
name|dest
argument_list|)
expr_stmt|;
comment|/* can't do it often enough */
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

