begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_decl_stmt
name|char
modifier|*
name|loginv
init|=
literal|"Script Command, V2.0(007) 5 Jul 85"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  C K U S C R  --  Login script for logging onto remote system */
end_comment

begin_comment
comment|/*  This module should work under all versions of Unix.  It calls externally  defined system-depended functions for i/o.   The module expects a login string of the expect send [expect send] ...  format.  It is intended to operate similarly to the way the common  uucp "L.sys" login entries work.  Conditional responses are supported  expect[-send-expect[...]] as with uucp.  The send keyword EOT sends a  control-d, and the keyword BREAK sends a break.  Letters prefixed  by '~' are '~b' backspace, '~s' space, '~n' linefeed, '~r' return, '~x' xon,  '~t' tab, '~q' ? (not allowed on kermit command lines), '~' ~, '~'',   '~"', '~c' don't append return, '~o[o[o]]' octal character.  As with  some uucp systems, sent strings are followed by ~r (not ~n) unless they  end with ~c. Null expect strings (e.g., ~0 or --) cause a short  delay, and are useful for sending sequences requiring slight pauses.   Author: Herm Fischer (HFISCHER@USC-ECLB)  Contributed to Columbia University for inclusion in C-Kermit.  Copyright (C) 1985, Herman Fischer, 16400 Ventura Blvd, Encino CA 91436  Permission is granted to any individual or institution to use, copy, or  redistribute this software so long as it is not sold for profit, provided this  copyright notice is retained.  */
end_comment

begin_include
include|#
directive|include
file|"ckcdeb.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|"ckcker.h"
end_include

begin_decl_stmt
specifier|extern
name|int
name|local
decl_stmt|,
name|speed
decl_stmt|,
name|flow
decl_stmt|,
name|seslog
decl_stmt|,
name|mdmtyp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
name|ttname
index|[]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|CHAR
name|dopar
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|chstr
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|EXP_ALRM
init|=
literal|15
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Time to wait for expect string */
end_comment

begin_define
define|#
directive|define
name|SND_ALRM
value|15
end_define

begin_comment
comment|/* Time to allow for sending string */
end_comment

begin_define
define|#
directive|define
name|NULL_EXP
value|2
end_define

begin_comment
comment|/* Time to pause on null expect strg*/
end_comment

begin_define
define|#
directive|define
name|DEL_MSEC
value|300
end_define

begin_comment
comment|/* milliseconds to pause on ~d */
end_comment

begin_define
define|#
directive|define
name|SBUFL
value|300
end_define

begin_comment
comment|/* Login Sequence buffer */
end_comment

begin_decl_stmt
specifier|static
name|char
name|seq_buf
index|[
name|SBUFL
index|]
decl_stmt|,
modifier|*
name|s
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|got_it
decl_stmt|,
name|no_cr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  connect state parent/child communication signal handlers */
end_comment

begin_decl_stmt
specifier|static
name|jmp_buf
name|alrmRng
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Envir ptr for connect errors */
end_comment

begin_macro
name|scrtime
argument_list|()
end_macro

begin_block
block|{
comment|/* modem read failure handler, */
name|longjmp
argument_list|(
name|alrmRng
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* notifies parent process to stop */
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  Sequence interpreter -- pick up next sequence from command string,  decode escapes and place into seq_buf   If string contains a ~d (delay) then sequenc returns a 1 expecting  to be called again after the ~d executes. */
end_comment

begin_expr_stmt
specifier|static
name|sequenc
argument_list|()
block|{
name|int
name|i
block|;
name|char
name|c
block|,
name|oct_char
block|;
name|no_cr
operator|=
literal|0
block|;
comment|/* output needs cr appended */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|SBUFL
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|||
operator|*
name|s
operator|==
literal|'-'
operator|||
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
block|{
comment|/* done */
name|seq_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_expr_stmt

begin_if
if|if
condition|(
operator|*
name|s
operator|==
literal|'~'
condition|)
block|{
comment|/* escape character */
switch|switch
condition|(
name|c
operator|=
operator|*
operator|(
operator|++
name|s
operator|)
condition|)
block|{
case|case
literal|'n'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\n'
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\r'
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\t'
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\b'
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'?'
expr_stmt|;
break|break;
case|case
literal|'~'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'~'
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\''
expr_stmt|;
break|break;
case|case
literal|'\"'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\"'
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
literal|'\021'
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|no_cr
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
block|{
comment|/* send what we have and then */
name|seq_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* expect to send rest after */
name|no_cr
operator|=
literal|1
expr_stmt|;
comment|/* sender delays a little */
name|s
operator|++
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
case|case
literal|'w'
case|:
block|{
comment|/* wait count */
name|EXP_ALRM
operator|=
literal|15
expr_stmt|;
comment|/* default to 15 sec */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|EXP_ALRM
operator|=
operator|(
operator|*
operator|(
operator|++
name|s
operator|)
operator|)
operator|&
literal|15
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|EXP_ALRM
operator|=
name|EXP_ALRM
operator|*
literal|10
operator|+
operator|(
operator|(
operator|*
operator|(
operator|++
name|s
operator|)
operator|)
operator|&
literal|15
operator|)
expr_stmt|;
block|}
block|}
break|break;
block|}
default|default:
if|if
condition|(
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
block|{
comment|/* octal character */
name|oct_char
operator|=
operator|(
name|c
operator|&
literal|7
operator|)
expr_stmt|;
comment|/* most significant digit */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|oct_char
operator|=
operator|(
name|oct_char
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
operator|++
name|s
operator|)
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|s
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|oct_char
operator|=
operator|(
name|oct_char
operator|<<
literal|3
operator|)
operator||
operator|(
operator|(
operator|*
operator|(
operator|++
name|s
operator|)
operator|)
operator|&
literal|7
operator|)
expr_stmt|;
block|}
block|}
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
name|oct_char
expr_stmt|;
break|break;
block|}
block|}
block|}
else|else
name|seq_buf
index|[
name|i
operator|++
index|]
operator|=
operator|*
name|s
expr_stmt|;
end_if

begin_comment
comment|/* plain old character */
end_comment

begin_expr_stmt
name|s
operator|++
expr_stmt|;
end_expr_stmt

begin_expr_stmt
unit|}     seq_buf
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
end_expr_stmt

begin_return
return|return
operator|(
literal|0
operator|)
return|;
end_return

begin_comment
comment|/* end of space, return anyway */
end_comment

begin_escape
unit|}
end_escape

begin_comment
comment|/*  Receive sequence -- see if expected response comes return success  (or failure) in got_it */
end_comment

begin_macro
unit|static
name|recvSeq
argument_list|()
end_macro

begin_block
block|{
name|char
modifier|*
name|e
decl_stmt|,
name|got
index|[
literal|7
index|]
decl_stmt|,
name|trace
index|[
literal|300
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|l
decl_stmt|;
name|sequenc
argument_list|()
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|e
operator|=
name|seq_buf
argument_list|)
expr_stmt|;
comment|/* no more than 7 chars allowed */
if|if
condition|(
name|l
operator|>
literal|7
condition|)
block|{
name|e
operator|+=
name|l
operator|-
literal|7
expr_stmt|;
name|l
operator|=
literal|7
expr_stmt|;
block|}
name|tlog
argument_list|(
name|F111
argument_list|,
literal|"expecting sequence"
argument_list|,
name|e
argument_list|,
operator|(
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
if|if
condition|(
name|l
operator|==
literal|0
condition|)
block|{
comment|/* null sequence, just delay a little */
name|sleep
argument_list|(
name|NULL_EXP
argument_list|)
expr_stmt|;
name|got_it
operator|=
literal|1
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"got it (null sequence)"
argument_list|,
literal|""
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
return|return;
block|}
operator|*
name|trace
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|7
condition|;
name|i
operator|++
control|)
name|got
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|scrtime
argument_list|)
expr_stmt|;
comment|/* did we get it? */
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|alrmRng
argument_list|)
condition|)
block|{
comment|/* not timed out yet */
name|alarm
argument_list|(
name|EXP_ALRM
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|got_it
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|l
operator|-
literal|1
operator|)
condition|;
name|i
operator|++
control|)
name|got
index|[
name|i
index|]
operator|=
name|got
index|[
name|i
operator|+
literal|1
index|]
expr_stmt|;
comment|/* shift over one */
name|got
index|[
name|l
operator|-
literal|1
index|]
operator|=
name|ttinc
argument_list|(
literal|0
argument_list|)
operator|&
literal|0177
expr_stmt|;
comment|/* next char */
if|if
condition|(
name|strlen
argument_list|(
name|trace
argument_list|)
operator|<
sizeof|sizeof
argument_list|(
name|trace
argument_list|)
operator|-
literal|2
condition|)
name|strcat
argument_list|(
name|trace
argument_list|,
name|chstr
argument_list|(
name|got
index|[
name|l
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|got_it
operator|=
operator|(
operator|!
name|strncmp
argument_list|(
name|seq_buf
argument_list|,
name|got
argument_list|,
name|l
argument_list|)
operator|)
expr_stmt|;
block|}
block|}
else|else
name|got_it
operator|=
literal|0
expr_stmt|;
comment|/* timed out here */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"received sequence: "
argument_list|,
name|trace
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F101
argument_list|,
literal|"returning with got-it code"
argument_list|,
literal|""
argument_list|,
operator|(
name|long
operator|)
name|got_it
argument_list|)
expr_stmt|;
return|return;
block|}
end_block

begin_escape
end_escape

begin_comment
comment|/*  Output A Sequence starting at pointer s,  return 0 if okay,  1 if failed to read (modem hangup or whatever) */
end_comment

begin_function
specifier|static
name|int
name|outSeq
parameter_list|()
block|{
name|char
modifier|*
name|sb
decl_stmt|;
name|int
name|l
decl_stmt|;
name|int
name|delay
decl_stmt|;
name|int
name|retCode
init|=
literal|0
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|delay
operator|=
name|sequenc
argument_list|()
expr_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|seq_buf
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F111
argument_list|,
literal|"sending sequence "
argument_list|,
name|seq_buf
argument_list|,
operator|(
name|long
operator|)
name|l
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|scrtime
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|setjmp
argument_list|(
name|alrmRng
argument_list|)
condition|)
block|{
name|alarm
argument_list|(
name|SND_ALRM
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|seq_buf
argument_list|,
literal|"EOT"
argument_list|)
condition|)
name|ttoc
argument_list|(
name|dopar
argument_list|(
literal|'\004'
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|seq_buf
argument_list|,
literal|"BREAK"
argument_list|)
condition|)
name|ttsndb
argument_list|()
expr_stmt|;
else|else
block|{
if|if
condition|(
name|l
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|sb
operator|=
name|seq_buf
init|;
operator|*
name|sb
condition|;
name|sb
operator|++
control|)
operator|*
name|sb
operator|=
name|dopar
argument_list|(
operator|*
name|sb
argument_list|)
expr_stmt|;
name|ttol
argument_list|(
name|seq_buf
argument_list|,
name|l
argument_list|)
expr_stmt|;
comment|/* with parity */
block|}
if|if
condition|(
operator|!
name|no_cr
condition|)
name|ttoc
argument_list|(
name|dopar
argument_list|(
literal|'\r'
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
name|retCode
operator||=
operator|-
literal|1
expr_stmt|;
comment|/* else -- alarm rang */
name|alarm
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|delay
condition|)
return|return
operator|(
name|retCode
operator|)
return|;
name|msleep
argument_list|(
name|DEL_MSEC
argument_list|)
expr_stmt|;
comment|/* delay, and loop to next stuff to send */
block|}
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*  L O G I N  --  Login to remote system */
end_comment

begin_macro
name|login
argument_list|(
argument|cmdstr
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cmdstr
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
function_decl|(
modifier|*
name|saveAlm
function_decl|)
parameter_list|()
function_decl|;
comment|/* save incomming alarm function */
name|char
modifier|*
name|e
decl_stmt|;
name|s
operator|=
name|cmdstr
expr_stmt|;
comment|/* make global to ckuscr.c */
name|tlog
argument_list|(
name|F100
argument_list|,
name|loginv
argument_list|,
literal|""
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|local
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, you must 'set line' first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|speed
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, you must 'set speed' first\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
if|if
condition|(
name|ttopen
argument_list|(
name|ttname
argument_list|,
operator|&
name|local
argument_list|,
name|mdmtyp
argument_list|)
operator|<
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|seq_buf
argument_list|,
literal|"Sorry, can't open %s"
argument_list|,
name|ttname
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|seq_buf
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
name|printf
argument_list|(
literal|"Executing script thru %s, speed %d.\r\n"
argument_list|,
name|ttname
argument_list|,
name|speed
argument_list|)
expr_stmt|;
operator|*
name|seq_buf
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|e
operator|=
name|s
init|;
operator|*
name|e
condition|;
name|e
operator|++
control|)
name|strcat
argument_list|(
name|seq_buf
argument_list|,
name|chstr
argument_list|(
operator|*
name|e
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"The logon string is: %s\r\n"
argument_list|,
name|seq_buf
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F110
argument_list|,
literal|"Logon command string: "
argument_list|,
name|seq_buf
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
comment|/* Condition console terminal and communication line */
if|if
condition|(
name|ttvt
argument_list|(
name|speed
argument_list|,
name|flow
argument_list|)
operator|<
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"Sorry, Can't condition communication line\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
comment|/* save initial timer interrupt value */
name|saveAlm
operator|=
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|ttflui
argument_list|()
expr_stmt|;
comment|/* flush stale input */
comment|/* cont'd... */
comment|/* ...login, cont'd */
comment|/* start expect - send sequence */
while|while
condition|(
operator|*
name|s
condition|)
block|{
comment|/* while not done with buffer */
while|while
condition|(
operator|*
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip over separating whitespaces */
comment|/* gather up expect sequence */
name|got_it
operator|=
literal|0
expr_stmt|;
name|recvSeq
argument_list|()
expr_stmt|;
while|while
condition|(
operator|!
name|got_it
condition|)
block|{
comment|/* no, is there a conditional send */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'-'
condition|)
goto|goto
name|failRet
goto|;
comment|/* no -- return failure */
comment|/* start of conditional send */
name|ttflui
argument_list|()
expr_stmt|;
comment|/* flush out input buffer */
if|if
condition|(
name|outSeq
argument_list|()
condition|)
goto|goto
name|failRet
goto|;
comment|/* if unable to send! */
if|if
condition|(
operator|*
name|s
operator|++
operator|!=
literal|'-'
condition|)
goto|goto
name|failRet
goto|;
comment|/* must have condit respon.*/
name|recvSeq
argument_list|()
expr_stmt|;
block|}
comment|/* loop back and check got_it */
while|while
condition|(
operator|*
name|s
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|s
operator|++
argument_list|)
condition|)
empty_stmt|;
comment|/* skip over conditionals */
while|while
condition|(
operator|*
name|s
operator|&&
name|isspace
argument_list|(
operator|*
name|s
argument_list|)
condition|)
name|s
operator|++
expr_stmt|;
comment|/* skip over separating whitespaces */
name|ttflui
argument_list|()
expr_stmt|;
comment|/* Flush */
if|if
condition|(
operator|*
name|s
condition|)
if|if
condition|(
name|outSeq
argument_list|()
condition|)
goto|goto
name|failRet
goto|;
comment|/* if any */
block|}
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|saveAlm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Logged on!\r\n"
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Logged on!"
argument_list|,
literal|""
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|failRet
label|:
name|signal
argument_list|(
name|SIGALRM
argument_list|,
name|saveAlm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Sorry, logon failed\r\n"
argument_list|)
expr_stmt|;
name|tlog
argument_list|(
name|F100
argument_list|,
literal|"Logon failed"
argument_list|,
literal|""
argument_list|,
literal|0l
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|2
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  C H S T R  --  Make printable string from a character */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|chstr
parameter_list|(
name|c
parameter_list|)
name|char
name|c
decl_stmt|;
block|{
specifier|static
name|char
name|sc
index|[
literal|4
index|]
decl_stmt|;
if|if
condition|(
name|c
operator|<
name|SP
condition|)
name|sprintf
argument_list|(
name|sc
argument_list|,
literal|"^%c"
argument_list|,
name|ctl
argument_list|(
name|c
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|sc
argument_list|,
literal|"%c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
return|return
operator|(
name|sc
operator|)
return|;
block|}
end_function

end_unit

