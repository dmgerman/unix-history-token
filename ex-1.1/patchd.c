begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * patchd symbol value [ file ]  *  * Like a db ! but works separate i/d.  */
end_comment

begin_decl_stmt
name|long
name|geto
argument_list|()
decl_stmt|,
name|getsym
argument_list|()
decl_stmt|,
name|itol
argument_list|()
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|file
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
name|header
block|{
name|int
name|magic
decl_stmt|;
name|int
name|txt_size
decl_stmt|;
name|int
name|data_size
decl_stmt|;
name|int
name|bss_size
decl_stmt|;
name|int
name|sym_size
decl_stmt|;
name|int
name|entry_loc
decl_stmt|;
name|int
name|unused
decl_stmt|;
name|int
name|no_reloc
decl_stmt|;
block|}
name|header
struct|;
end_struct

begin_struct
struct|struct
name|nl
block|{
name|char
name|name
index|[
literal|8
index|]
decl_stmt|;
name|int
name|typ
decl_stmt|;
name|int
modifier|*
name|val
decl_stmt|;
block|}
modifier|*
name|nlp
struct|;
end_struct

begin_decl_stmt
name|int
modifier|*
name|initbrk
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|long
name|iaddr
decl_stmt|,
name|addr
decl_stmt|;
name|int
name|value
decl_stmt|,
name|word
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|3
operator|&&
name|argc
operator|!=
literal|4
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Usage: patchd symbol value [ file ]\n"
argument_list|,
literal|36
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|file
operator|=
name|argc
operator|==
literal|4
condition|?
name|argv
index|[
literal|3
index|]
else|:
literal|"a.out"
expr_stmt|;
if|if
condition|(
name|open
argument_list|(
name|file
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|value
operator|=
name|geto
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|seek
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|header
argument_list|,
sizeof|sizeof
name|header
argument_list|)
operator|!=
sizeof|sizeof
name|header
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|header
operator|.
name|magic
operator|<
literal|0407
operator|||
name|header
operator|.
name|magic
operator|>
literal|0411
condition|)
block|{
name|perror
argument_list|(
name|file
argument_list|,
literal|"Not object file"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|addr
operator|=
name|iaddr
operator|=
name|getsym
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|+
literal|16
expr_stmt|;
switch|switch
condition|(
name|header
operator|.
name|magic
condition|)
block|{
case|case
literal|0407
case|:
comment|/* Non-shared */
comment|/* Just skip past header */
break|break;
case|case
literal|0410
case|:
comment|/* Shared */
comment|/* Round to 4kW boundary */
name|addr
operator|-=
operator|(
operator|(
name|header
operator|.
name|txt_size
operator|+
literal|8191
operator|)
operator|&
operator|~
literal|8191
operator|)
operator|-
name|header
operator|.
name|txt_size
expr_stmt|;
break|break;
case|case
literal|0411
case|:
comment|/* Separate i/d */
name|addr
operator|+=
name|header
operator|.
name|txt_size
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|lseek
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|seekerr
label|:
name|Perror
argument_list|(
name|file
argument_list|,
literal|"Seek failed"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|word
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
goto|goto
name|oops
goto|;
if|if
condition|(
name|lseek
argument_list|(
literal|0
argument_list|,
name|addr
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|seekerr
goto|;
if|if
condition|(
name|write
argument_list|(
literal|0
argument_list|,
operator|&
name|value
argument_list|,
literal|2
argument_list|)
operator|!=
literal|2
condition|)
goto|goto
name|oops
goto|;
name|printf
argument_list|(
literal|"Was %o now %o\n"
argument_list|,
name|word
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|oops
label|:
name|perror
argument_list|(
name|file
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|long
name|geto
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
name|long
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|*
name|cp
operator|>=
literal|'0'
operator|&&
operator|*
name|cp
operator|<=
literal|'7'
condition|;
name|i
operator|=
operator|(
name|i
operator|<<
literal|3
operator|)
operator||
operator|*
name|cp
operator|++
operator|-
literal|'0'
control|)
continue|continue;
if|if
condition|(
operator|*
name|cp
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Bad number.\n"
argument_list|,
literal|12
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_macro
name|Perror
argument_list|(
argument|cp
argument_list|,
argument|dp
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|extern
name|int
name|errno
decl_stmt|;
specifier|extern
name|char
modifier|*
name|sys_errlist
index|[]
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|sys_errlist
index|[
literal|0
index|]
operator|=
name|dp
expr_stmt|;
name|perror
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|long
name|getsym
parameter_list|(
name|cp
parameter_list|)
name|char
modifier|*
name|cp
decl_stmt|;
block|{
specifier|static
name|char
name|symbol
index|[
literal|8
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|n
decl_stmt|;
name|seek
argument_list|(
literal|0
argument_list|,
sizeof|sizeof
name|header
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|header
operator|.
name|txt_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|,
name|header
operator|.
name|data_size
argument_list|,
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|j
operator|=
literal|0
init|;
name|i
operator|<
literal|8
condition|;
name|i
operator|++
control|)
block|{
name|symbol
index|[
name|i
index|]
operator|=
name|cp
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|cp
index|[
name|j
index|]
condition|)
name|j
operator|++
expr_stmt|;
block|}
name|initbrk
operator|=
name|sbrk
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|n
operator|=
name|ldiv
argument_list|(
literal|0
argument_list|,
name|header
operator|.
name|sym_size
argument_list|,
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|0
condition|)
block|{
name|Perror
argument_list|(
name|file
argument_list|,
literal|"No name list"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|nlp
operator|=
name|sbrk
argument_list|(
name|n
operator|*
literal|12
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
literal|0
argument_list|,
name|nlp
argument_list|,
name|n
operator|*
literal|12
argument_list|)
operator|!=
name|n
operator|*
literal|12
condition|)
block|{
name|Perror
argument_list|(
name|file
argument_list|,
literal|"Error reading"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
literal|8
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|nlp
operator|->
name|name
index|[
name|j
index|]
operator|!=
name|symbol
index|[
name|j
index|]
condition|)
break|break;
if|if
condition|(
name|j
operator|==
literal|8
condition|)
break|break;
name|nlp
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|==
name|n
condition|)
block|{
name|Perror
argument_list|(
name|cp
argument_list|,
literal|"Symbol not found"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|j
operator|=
name|nlp
operator|->
name|typ
operator|&
literal|037
expr_stmt|;
if|if
condition|(
name|j
operator|>
literal|4
condition|)
name|j
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
name|nlp
operator|->
name|val
condition|)
name|j
operator|=
literal|5
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|nlp
operator|->
name|typ
operator|&
literal|040
operator|)
operator|||
name|j
operator|!=
literal|3
condition|)
block|{
name|Perror
argument_list|(
name|cp
argument_list|,
literal|"Inappropriate symbol"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|itol
argument_list|(
literal|0
argument_list|,
name|nlp
operator|->
name|val
argument_list|)
operator|)
return|;
block|}
end_function

end_unit

