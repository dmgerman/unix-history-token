begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_include
include|#
directive|include
file|"ex_re.h"
end_include

begin_comment
comment|/*  * Ex - a text editor  * Bill Joy UCB June 1977  *  * Should get a< n square algorithm here.  */
end_comment

begin_define
define|#
directive|define
name|GBSIZE
value|256
end_define

begin_macro
name|global
argument_list|(
argument|k
argument_list|)
end_macro

begin_decl_stmt
name|int
name|k
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|gp
decl_stmt|;
specifier|register
name|c
expr_stmt|;
specifier|register
name|int
modifier|*
name|a1
decl_stmt|;
name|char
name|globuf
index|[
name|GBSIZE
index|]
decl_stmt|,
modifier|*
name|Cwas
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|dol
operator|-
name|zero
expr_stmt|;
name|Cwas
operator|=
name|Command
expr_stmt|;
if|if
condition|(
name|inglobal
condition|)
name|error
argument_list|(
literal|"Global within global@not allowed"
argument_list|)
expr_stmt|;
name|markDOT
argument_list|()
expr_stmt|;
name|setall
argument_list|()
expr_stmt|;
name|nonzero
argument_list|()
expr_stmt|;
name|skipwh
argument_list|()
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
if|if
condition|(
name|endcmd
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"Global needs re|Missing regular expression for global"
argument_list|)
expr_stmt|;
name|compile
argument_list|(
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|savere
argument_list|(
operator|&
name|scanre
argument_list|)
expr_stmt|;
name|gp
operator|=
name|globuf
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getchar
argument_list|()
operator|)
operator|!=
literal|'\n'
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
name|EOF
case|:
name|error
argument_list|(
literal|"EOF reading global"
argument_list|)
expr_stmt|;
case|case
literal|'\\'
case|:
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'\\'
case|:
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\n'
case|:
break|break;
default|default:
operator|*
name|gp
operator|++
operator|=
literal|'\\'
expr_stmt|;
break|break;
block|}
break|break;
block|}
operator|*
name|gp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|gp
operator|>=
operator|&
name|globuf
index|[
name|GBSIZE
operator|-
literal|2
index|]
condition|)
name|error
argument_list|(
literal|"Global command too long@- limit 254 characters"
argument_list|)
expr_stmt|;
block|}
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|newline
argument_list|()
expr_stmt|;
operator|*
name|gp
operator|++
operator|=
name|c
expr_stmt|;
operator|*
name|gp
operator|++
operator|=
literal|0
expr_stmt|;
name|inglobal
operator|=
literal|1
expr_stmt|;
for|for
control|(
name|a1
operator|=
name|one
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
block|{
operator|*
name|a1
operator|=
operator|&
operator|~
literal|01
expr_stmt|;
if|if
condition|(
name|a1
operator|>=
name|addr1
operator|&&
name|a1
operator|<=
name|addr2
operator|&&
name|execute
argument_list|(
literal|0
argument_list|,
name|a1
argument_list|)
operator|==
name|k
condition|)
operator|*
name|a1
operator|=
operator||
literal|01
expr_stmt|;
block|}
name|saveall
argument_list|()
expr_stmt|;
for|for
control|(
name|a1
operator|=
name|one
init|;
name|a1
operator|<=
name|dol
condition|;
name|a1
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|a1
operator|&
literal|01
condition|)
block|{
operator|*
name|a1
operator|=
operator|&
operator|~
literal|01
expr_stmt|;
name|dot
operator|=
name|a1
expr_stmt|;
name|globp
operator|=
name|globuf
expr_stmt|;
name|commands
argument_list|(
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|a1
operator|=
name|zero
expr_stmt|;
block|}
block|}
name|inglobal
operator|=
literal|0
expr_stmt|;
name|endline
operator|=
literal|1
expr_stmt|;
name|Command
operator|=
name|Cwas
expr_stmt|;
name|netchHAD
argument_list|(
name|i
argument_list|)
expr_stmt|;
name|setlastchar
argument_list|(
name|EOF
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|save
argument_list|(
argument|a1
argument_list|,
argument|a2
argument_list|)
end_macro

begin_decl_stmt
name|int
modifier|*
name|a1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|register
name|int
modifier|*
name|a2
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|int
modifier|*
name|addr
decl_stmt|,
modifier|*
name|dest
decl_stmt|;
struct|struct
block|{
name|int
name|integer
decl_stmt|;
block|}
struct|;
name|undkind
operator|=
name|UNDNONE
expr_stmt|;
name|undadot
operator|=
name|dot
expr_stmt|;
for|for
control|(
name|dest
operator|=
name|dol
operator|+
literal|1
operator|,
name|addr
operator|=
name|a1
init|;
name|addr
operator|<=
name|a2
condition|;
operator|*
name|dest
operator|++
operator|=
operator|*
name|addr
operator|++
control|)
if|if
condition|(
name|dest
operator|>=
name|endcore
condition|)
block|{
if|if
condition|(
name|sbrk
argument_list|(
literal|1024
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Out of memory@saving lines for undo - try using ed or re)"
argument_list|)
expr_stmt|;
name|endcore
operator|.
name|integer
operator|=
operator|+
literal|1024
expr_stmt|;
block|}
name|undkind
operator|=
name|UNDALL
expr_stmt|;
name|unddel
operator|=
name|a1
operator|-
literal|1
expr_stmt|;
name|undap1
operator|=
name|a1
expr_stmt|;
name|undap2
operator|=
name|a2
operator|+
literal|1
expr_stmt|;
name|unddol
operator|=
name|dest
operator|-
literal|1
expr_stmt|;
block|}
end_block

begin_macro
name|save12
argument_list|()
end_macro

begin_block
block|{
name|save
argument_list|(
name|addr1
argument_list|,
name|addr2
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|saveall
argument_list|()
end_macro

begin_block
block|{
name|save
argument_list|(
name|one
argument_list|,
name|dol
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

