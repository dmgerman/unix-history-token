begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_include
include|#
directive|include
file|"ex.h"
end_include

begin_comment
comment|/*  * Ex - a text editor  * Bill Joy UCB September 1977  */
end_comment

begin_expr_stmt
name|char
name|shellname
index|[
literal|30
index|]
literal|"/bin/sh"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|direct
index|[
literal|30
index|]
literal|"/tmp"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|ttytype
index|[
literal|30
index|]
literal|"unknown"
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|char
name|NONAME
index|[]
literal|"@"
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|ONOFF
value|0
end_define

begin_define
define|#
directive|define
name|NUMERIC
value|1
end_define

begin_define
define|#
directive|define
name|STRING
value|2
end_define

begin_define
define|#
directive|define
name|TERM
value|3
end_define

begin_expr_stmt
name|char
name|NOTify
index|[]
literal|"notify"
expr_stmt|;
end_expr_stmt

begin_struct
struct|struct
name|varbl
name|varbls
index|[]
block|{
literal|"autoindent"
operator|,
literal|"ai"
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"autoprint"
operator|,
literal|"ap"
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|"beautify"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"directory"
operator|,
literal|"dir"
operator|,
name|STRING
operator|,
literal|0
operator|,
name|direct
operator|,
literal|"editany"
operator|,
literal|"ea"
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"edited"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|0
operator|,
literal|"errorbells"
operator|,
literal|"eb"
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|"fork"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|"home"
operator|,
name|NONAME
operator|,
name|STRING
operator|,
literal|0
operator|,
name|home
operator|,
literal|"hush"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"ignorecase"
operator|,
literal|"ic"
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"indicateul"
operator|,
literal|"iu"
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"list"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"magic"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|"mode"
operator|,
name|NONAME
operator|,
name|NUMERIC
operator|,
literal|0644
operator|,
literal|0644
operator|,
name|NOTify
operator|,
name|NONAME
operator|,
name|NUMERIC
operator|,
literal|5
operator|,
literal|5
operator|,
literal|"number"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"open"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|"optimize"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|"printall"
operator|,
literal|"pa"
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"prompt"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|"scroll"
operator|,
name|NONAME
operator|,
name|NUMERIC
operator|,
literal|12
operator|,
literal|12
operator|,
literal|"shell"
operator|,
literal|"sh"
operator|,
name|STRING
operator|,
literal|0
operator|,
name|shellname
operator|,
literal|"shiftwidth"
operator|,
literal|"sw"
operator|,
name|NUMERIC
operator|,
literal|8
operator|,
literal|8
operator|,
literal|"sticky"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"ttytype"
operator|,
literal|"tty"
operator|,
name|TERM
operator|,
literal|0
operator|,
name|ttytype
operator|,
literal|"terse"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"visualmessage"
operator|,
literal|"vm"
operator|,
name|ONOFF
operator|,
literal|0
operator|,
literal|0
operator|,
literal|"window"
operator|,
name|NONAME
operator|,
name|NUMERIC
operator|,
literal|23
operator|,
literal|23
operator|,
literal|"wrap"
operator|,
name|NONAME
operator|,
name|ONOFF
operator|,
literal|1
operator|,
literal|1
operator|,
literal|0
block|}
struct|;
end_struct

begin_define
define|#
directive|define
name|ONMSZ
value|30
end_define

begin_expr_stmt
name|set
argument_list|(
name|c
argument_list|)
specifier|register
name|c
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|char
modifier|*
name|op
decl_stmt|;
specifier|register
name|struct
name|varbl
modifier|*
name|vp
decl_stmt|;
name|char
name|no
decl_stmt|,
name|optname
index|[
name|ONMSZ
index|]
decl_stmt|;
name|int
name|column
decl_stmt|,
name|base
decl_stmt|;
specifier|extern
name|char
name|uxb
index|[]
decl_stmt|;
name|setnoaddr
argument_list|()
expr_stmt|;
if|if
condition|(
name|endcmd
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
block|{
name|getchar
argument_list|()
expr_stmt|;
name|propts
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"Blank required@before options in set"
argument_list|)
expr_stmt|;
do|do
block|{
switch|switch
condition|(
name|c
operator|=
name|getchar
argument_list|()
condition|)
block|{
case|case
literal|'!'
case|:
name|op
operator|=
name|uxb
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|op
condition|)
name|error
argument_list|(
literal|"No previous command"
argument_list|)
expr_stmt|;
goto|goto
name|pfile
goto|;
case|case
literal|'`'
case|:
name|op
operator|=
name|altfile
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|op
condition|)
name|error
argument_list|(
literal|"No alternate filename"
argument_list|)
expr_stmt|;
goto|goto
name|pfile
goto|;
case|case
literal|'%'
case|:
name|op
operator|=
name|savedfile
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|op
condition|)
name|error
argument_list|(
literal|"No current filename"
argument_list|)
expr_stmt|;
name|pfile
label|:
if|if
condition|(
operator|!
name|setend
argument_list|()
condition|)
name|error
argument_list|(
literal|"Can't assign@to %c with set"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|lprintf
argument_list|(
literal|"%c=%s\n"
argument_list|,
name|c
argument_list|,
name|op
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|!
name|letter
argument_list|(
name|c
argument_list|)
condition|)
name|error
argument_list|(
literal|"Unexpected %c|Expected option name, found %c"
argument_list|,
name|c
argument_list|)
expr_stmt|;
name|op
operator|=
name|optname
expr_stmt|;
do|do
block|{
if|if
condition|(
name|op
operator|>=
operator|&
name|optname
index|[
name|ONMSZ
index|]
condition|)
name|error
argument_list|(
literal|"No such option|Ridiculously long option name"
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|letter
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|c
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
name|letter
argument_list|(
name|c
argument_list|)
condition|)
do|;
name|ungetchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|*
name|op
operator|=
literal|0
expr_stmt|;
name|no
operator|=
literal|0
expr_stmt|;
name|op
operator|=
name|optname
expr_stmt|;
if|if
condition|(
name|eq
argument_list|(
literal|"all"
argument_list|,
name|op
argument_list|)
condition|)
block|{
name|propts
argument_list|(
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
operator|!
name|eq
argument_list|(
name|op
argument_list|,
name|NOTify
argument_list|)
operator|&&
name|op
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|op
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
block|{
name|op
operator|=
operator|+
literal|2
expr_stmt|;
name|no
operator|++
expr_stmt|;
block|}
for|for
control|(
name|vp
operator|=
name|varbls
init|;
name|vp
operator|->
name|vname
index|[
literal|0
index|]
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|eq
argument_list|(
name|vp
operator|->
name|vname
index|[
literal|0
index|]
argument_list|,
name|op
argument_list|)
operator|||
name|eq
argument_list|(
name|vp
operator|->
name|vname
index|[
literal|1
index|]
argument_list|,
name|op
argument_list|)
condition|)
break|break;
if|if
condition|(
name|vp
operator|->
name|vname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|"%s: No such option@- 'set all' gives all option values"
argument_list|,
name|op
argument_list|)
expr_stmt|;
name|c
operator|=
name|skipwh
argument_list|()
expr_stmt|;
if|if
condition|(
name|peekchar
argument_list|()
operator|==
literal|'?'
condition|)
block|{
name|getchar
argument_list|()
expr_stmt|;
name|printone
label|:
name|propt
argument_list|(
name|vp
argument_list|)
expr_stmt|;
goto|goto
name|next
goto|;
block|}
if|if
condition|(
name|no
operator|&&
name|vp
operator|->
name|vtype
operator|!=
name|ONOFF
condition|)
name|error
argument_list|(
literal|"Option %s is not a toggle"
argument_list|,
name|vp
operator|->
name|vname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vp
operator|->
name|vtype
condition|)
block|{
case|case
name|ONOFF
case|:
name|vp
operator|->
name|vvalue
operator|=
literal|1
operator|-
name|no
expr_stmt|;
break|break;
case|case
name|NUMERIC
case|:
if|if
condition|(
name|c
operator|!=
literal|0
operator|||
name|setend
argument_list|()
condition|)
goto|goto
name|printone
goto|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'='
condition|)
name|error
argument_list|(
literal|"= expected@before number for numeric option %s"
argument_list|,
name|vp
operator|->
name|vname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|digit
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
name|error
argument_list|(
literal|"Digits required@after = when assigning numeric option"
argument_list|)
expr_stmt|;
name|c
operator|=
literal|0
expr_stmt|;
name|base
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|peekchar
argument_list|()
operator|==
literal|'0'
operator|||
name|vp
operator|==
operator|&
name|varbls
index|[
name|MODE
index|]
condition|)
name|base
operator|=
literal|8
expr_stmt|;
do|do
name|c
operator|=
name|c
operator|*
name|base
operator|+
name|getchar
argument_list|()
operator|-
literal|'0'
expr_stmt|;
do|while
condition|(
name|digit
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
do|;
name|vp
operator|->
name|vvalue
operator|=
name|c
expr_stmt|;
break|break;
case|case
name|STRING
case|:
case|case
name|TERM
case|:
if|if
condition|(
name|c
operator|!=
literal|0
operator|||
name|setend
argument_list|()
condition|)
goto|goto
name|printone
goto|;
if|if
condition|(
name|getchar
argument_list|()
operator|!=
literal|'='
condition|)
name|error
argument_list|(
literal|"Missing =@in assignment to option %s"
argument_list|,
name|vp
operator|->
name|vname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|op
operator|=
name|optname
expr_stmt|;
while|while
condition|(
operator|!
name|setend
argument_list|()
condition|)
block|{
if|if
condition|(
name|op
operator|>=
operator|&
name|optname
index|[
name|ONMSZ
index|]
condition|)
name|error
argument_list|(
literal|"String too long@in option assignment"
argument_list|)
expr_stmt|;
operator|*
name|op
operator|++
operator|=
name|getchar
argument_list|()
expr_stmt|;
block|}
operator|*
name|op
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|vp
operator|->
name|vtype
operator|==
name|TERM
condition|)
name|setterm
argument_list|(
name|optname
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|vp
operator|->
name|vvalue
argument_list|,
name|optname
argument_list|)
expr_stmt|;
name|vp
operator|->
name|vdefault
operator|=
literal|1
expr_stmt|;
block|}
break|break;
block|}
name|next
label|:
name|flush
argument_list|()
expr_stmt|;
name|skipwh
argument_list|()
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|endcmd
argument_list|(
name|peekchar
argument_list|()
argument_list|)
condition|)
do|;
name|eol
argument_list|()
expr_stmt|;
block|}
end_block

begin_macro
name|setend
argument_list|()
end_macro

begin_block
block|{
return|return
operator|(
name|white
argument_list|(
name|peekchar
argument_list|()
argument_list|)
operator|||
name|endcmd
argument_list|(
name|peekchar
argument_list|()
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|propts
argument_list|(
argument|all
argument_list|)
end_macro

begin_decl_stmt
name|char
name|all
decl_stmt|;
end_decl_stmt

begin_block
block|{
specifier|register
name|struct
name|varbl
modifier|*
name|vp
decl_stmt|;
for|for
control|(
name|vp
operator|=
name|varbls
init|;
name|vp
operator|->
name|vname
index|[
literal|0
index|]
operator|!=
name|NIL
condition|;
name|vp
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|all
condition|)
switch|switch
condition|(
name|vp
operator|->
name|vtype
condition|)
block|{
case|case
name|ONOFF
case|:
case|case
name|NUMERIC
case|:
if|if
condition|(
name|vp
operator|->
name|vvalue
operator|==
name|vp
operator|->
name|vdefault
condition|)
continue|continue;
break|break;
case|case
name|STRING
case|:
if|if
condition|(
name|vp
operator|->
name|vdefault
operator|==
literal|0
condition|)
continue|continue;
break|break;
comment|/* 			case TERM: 				break; */
block|}
name|propt
argument_list|(
name|vp
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
name|propt
argument_list|(
name|vp
argument_list|)
specifier|register
expr|struct
name|varbl
operator|*
name|vp
expr_stmt|;
end_expr_stmt

begin_block
block|{
switch|switch
condition|(
name|vp
operator|->
name|vtype
condition|)
block|{
case|case
name|ONOFF
case|:
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
name|vp
operator|->
name|vvalue
condition|?
literal|""
else|:
literal|"no"
argument_list|,
name|vp
operator|->
name|vname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUMERIC
case|:
if|if
condition|(
name|vp
operator|==
operator|&
name|varbls
index|[
name|MODE
index|]
condition|)
block|{
name|printf
argument_list|(
literal|"mode="
argument_list|)
expr_stmt|;
name|pro
argument_list|(
name|value
argument_list|(
name|MODE
argument_list|)
argument_list|)
expr_stmt|;
name|putnl
argument_list|()
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"%s=%d\n"
argument_list|,
name|vp
operator|->
name|vname
index|[
literal|0
index|]
argument_list|,
name|vp
operator|->
name|vvalue
argument_list|)
expr_stmt|;
break|break;
case|case
name|STRING
case|:
case|case
name|TERM
case|:
name|printf
argument_list|(
literal|"%s=%s\n"
argument_list|,
name|vp
operator|->
name|vname
index|[
literal|0
index|]
argument_list|,
name|vp
operator|->
name|vvalue
argument_list|)
expr_stmt|;
break|break;
block|}
name|flush
argument_list|()
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|pro
argument_list|(
name|i
argument_list|)
specifier|register
name|int
name|i
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|pro
argument_list|(
operator|(
name|i
operator|>>
literal|3
operator|)
operator|&
literal|017777
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
operator|(
name|i
operator|&
literal|7
operator|)
operator||
literal|'0'
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|REset
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|struct
name|varbl
modifier|*
name|vp
decl_stmt|;
for|for
control|(
name|vp
operator|=
name|varbls
init|;
name|vp
operator|->
name|vname
index|[
literal|0
index|]
condition|;
name|vp
operator|++
control|)
if|if
condition|(
name|vp
operator|->
name|vtype
operator|==
name|NUMERIC
operator|||
name|vp
operator|->
name|vtype
operator|==
name|ONOFF
condition|)
name|vp
operator|->
name|vvalue
operator|=
name|vp
operator|->
name|vdefault
expr_stmt|;
block|}
end_block

end_unit

