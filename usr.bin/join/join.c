begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* join - join lines of two files on a common field    Copyright (C) 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.     Written by Mike Haertel, mike@gnu.ai.mit.edu. */
end_comment

begin_define
define|#
directive|define
name|_GNU_SOURCE
end_define

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|isblank
end_ifndef

begin_define
define|#
directive|define
name|isblank
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"getopt.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_comment
comment|/*#include<stdlib.h>*/
end_comment

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|isascii
end_ifdef

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|(isascii(c)&& isspace(c))
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|(isascii(c)&& isdigit(c))
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|ISSPACE
parameter_list|(
name|c
parameter_list|)
value|isspace(c)
end_define

begin_define
define|#
directive|define
name|ISDIGIT
parameter_list|(
name|c
parameter_list|)
value|isdigit(c)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
name|void
name|error
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|min
parameter_list|(
name|A
parameter_list|,
name|B
parameter_list|)
value|((A)< (B) ? (A) : (B))
end_define

begin_comment
comment|/* An element of the list describing the format of each    output line. */
end_comment

begin_struct
struct|struct
name|outlist
block|{
name|int
name|file
decl_stmt|;
comment|/* File to take field from (1 or 2). */
name|int
name|field
decl_stmt|;
comment|/* Field number to print. */
name|struct
name|outlist
modifier|*
name|next
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* A field of a line. */
end_comment

begin_struct
struct|struct
name|field
block|{
name|char
modifier|*
name|beg
decl_stmt|;
comment|/* First character in field. */
name|char
modifier|*
name|lim
decl_stmt|;
comment|/* Character after last character in field. */
block|}
struct|;
end_struct

begin_comment
comment|/* A line read from an input file.  Newlines are not stored. */
end_comment

begin_struct
struct|struct
name|line
block|{
name|char
modifier|*
name|beg
decl_stmt|;
comment|/* First character in line. */
name|char
modifier|*
name|lim
decl_stmt|;
comment|/* Character after last character in line. */
name|int
name|nfields
decl_stmt|;
comment|/* Number of elements in `fields'. */
name|struct
name|field
modifier|*
name|fields
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* One or more consecutive lines read from a file that all have the    same join field value. */
end_comment

begin_struct
struct|struct
name|seq
block|{
name|int
name|count
decl_stmt|;
comment|/* Elements used in `lines'. */
name|int
name|alloc
decl_stmt|;
comment|/* Elements allocated in `lines'. */
name|struct
name|line
modifier|*
name|lines
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* If nonzero, print unpairable lines in file 1 or 2. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_unpairables_1
decl_stmt|,
name|print_unpairables_2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If nonzero, print pairable lines. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|print_pairables
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Empty output field filler. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|empty_filler
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Field to join on. */
end_comment

begin_decl_stmt
specifier|static
name|int
name|join_field_1
decl_stmt|,
name|join_field_2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* List of fields to print. */
end_comment

begin_decl_stmt
name|struct
name|outlist
modifier|*
name|outlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Last element in `outlist', where a new element can be added. */
end_comment

begin_decl_stmt
name|struct
name|outlist
modifier|*
name|outlist_end
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tab character separating fields; if this is NUL fields are separated    by any nonempty string of white space, otherwise by exactly one    tab character. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tab
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* The name this program was run with. */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Fill in the `fields' structure in LINE. */
end_comment

begin_function
specifier|static
name|void
name|xfields
parameter_list|(
name|line
parameter_list|)
name|struct
name|line
modifier|*
name|line
decl_stmt|;
block|{
specifier|static
name|int
name|nfields
init|=
literal|2
decl_stmt|;
name|int
name|i
decl_stmt|;
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|lim
decl_stmt|;
name|line
operator|->
name|fields
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|malloc
argument_list|(
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|line
operator|->
name|beg
expr_stmt|;
name|lim
operator|=
name|line
operator|->
name|lim
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|ptr
operator|<
name|lim
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|nfields
condition|)
block|{
name|nfields
operator|*=
literal|2
expr_stmt|;
name|line
operator|->
name|fields
operator|=
operator|(
expr|struct
name|field
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
operator|->
name|fields
argument_list|,
name|nfields
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|field
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tab
condition|)
block|{
name|line
operator|->
name|fields
index|[
name|i
index|]
operator|.
name|beg
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|*
name|ptr
operator|!=
name|tab
condition|)
operator|++
name|ptr
expr_stmt|;
name|line
operator|->
name|fields
index|[
name|i
index|]
operator|.
name|lim
operator|=
name|ptr
expr_stmt|;
if|if
condition|(
name|ptr
operator|<
name|lim
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|line
operator|->
name|fields
index|[
name|i
index|]
operator|.
name|beg
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
operator|!
name|ISSPACE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
name|line
operator|->
name|fields
index|[
name|i
index|]
operator|.
name|lim
operator|=
name|ptr
expr_stmt|;
while|while
condition|(
name|ptr
operator|<
name|lim
operator|&&
name|ISSPACE
argument_list|(
operator|*
name|ptr
argument_list|)
condition|)
operator|++
name|ptr
expr_stmt|;
block|}
block|}
name|line
operator|->
name|nfields
operator|=
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a line from FP into LINE and split it into fields.    Return 0 if EOF, 1 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|get_line
parameter_list|(
name|fp
parameter_list|,
name|line
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|line
modifier|*
name|line
decl_stmt|;
block|{
specifier|static
name|int
name|linesize
init|=
literal|80
decl_stmt|;
name|int
name|c
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
name|feof
argument_list|(
name|fp
argument_list|)
condition|)
return|return
literal|0
return|;
name|ptr
operator|=
name|malloc
argument_list|(
name|linesize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|i
operator|==
name|linesize
condition|)
block|{
name|linesize
operator|*=
literal|2
expr_stmt|;
name|ptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|linesize
argument_list|)
expr_stmt|;
block|}
name|ptr
index|[
name|i
index|]
operator|=
name|c
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
operator|&&
name|i
operator|==
literal|0
condition|)
block|{
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
name|line
operator|->
name|beg
operator|=
name|ptr
expr_stmt|;
name|line
operator|->
name|lim
operator|=
name|line
operator|->
name|beg
operator|+
name|i
expr_stmt|;
name|xfields
argument_list|(
name|line
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|freeline
parameter_list|(
name|line
parameter_list|)
name|struct
name|line
modifier|*
name|line
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|line
operator|->
name|fields
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
operator|->
name|beg
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|initseq
parameter_list|(
name|seq
parameter_list|)
name|struct
name|seq
modifier|*
name|seq
decl_stmt|;
block|{
name|seq
operator|->
name|count
operator|=
literal|0
expr_stmt|;
name|seq
operator|->
name|alloc
operator|=
literal|1
expr_stmt|;
name|seq
operator|->
name|lines
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|malloc
argument_list|(
name|seq
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Read a line from FP and add it to SEQ.  Return 0 if EOF, 1 otherwise. */
end_comment

begin_function
specifier|static
name|int
name|getseq
parameter_list|(
name|fp
parameter_list|,
name|seq
parameter_list|)
name|FILE
modifier|*
name|fp
decl_stmt|;
name|struct
name|seq
modifier|*
name|seq
decl_stmt|;
block|{
if|if
condition|(
name|seq
operator|->
name|count
operator|==
name|seq
operator|->
name|alloc
condition|)
block|{
name|seq
operator|->
name|alloc
operator|*=
literal|2
expr_stmt|;
name|seq
operator|->
name|lines
operator|=
operator|(
expr|struct
name|line
operator|*
operator|)
name|realloc
argument_list|(
operator|(
name|char
operator|*
operator|)
name|seq
operator|->
name|lines
argument_list|,
name|seq
operator|->
name|alloc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|line
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|get_line
argument_list|(
name|fp
argument_list|,
operator|&
name|seq
operator|->
name|lines
index|[
name|seq
operator|->
name|count
index|]
argument_list|)
condition|)
block|{
operator|++
name|seq
operator|->
name|count
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|delseq
parameter_list|(
name|seq
parameter_list|)
name|struct
name|seq
modifier|*
name|seq
decl_stmt|;
block|{
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|seq
operator|->
name|lines
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Return<0 if the join field in LINE1 compares less than the one in LINE2;>0 if it compares greater; 0 if it compares equal. */
end_comment

begin_function
specifier|static
name|int
name|keycmp
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
name|struct
name|line
modifier|*
name|line1
decl_stmt|;
name|struct
name|line
modifier|*
name|line2
decl_stmt|;
block|{
name|char
modifier|*
name|beg1
decl_stmt|,
modifier|*
name|beg2
decl_stmt|;
comment|/* Start of field to compare in each file. */
name|int
name|len1
decl_stmt|,
name|len2
decl_stmt|;
comment|/* Length of fields to compare. */
name|int
name|diff
decl_stmt|;
if|if
condition|(
name|join_field_1
operator|<
name|line1
operator|->
name|nfields
condition|)
block|{
name|beg1
operator|=
name|line1
operator|->
name|fields
index|[
name|join_field_1
index|]
operator|.
name|beg
expr_stmt|;
name|len1
operator|=
name|line1
operator|->
name|fields
index|[
name|join_field_1
index|]
operator|.
name|lim
operator|-
name|line1
operator|->
name|fields
index|[
name|join_field_1
index|]
operator|.
name|beg
expr_stmt|;
block|}
else|else
block|{
name|beg1
operator|=
name|NULL
expr_stmt|;
name|len1
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|join_field_2
operator|<
name|line2
operator|->
name|nfields
condition|)
block|{
name|beg2
operator|=
name|line2
operator|->
name|fields
index|[
name|join_field_2
index|]
operator|.
name|beg
expr_stmt|;
name|len2
operator|=
name|line2
operator|->
name|fields
index|[
name|join_field_2
index|]
operator|.
name|lim
operator|-
name|line2
operator|->
name|fields
index|[
name|join_field_2
index|]
operator|.
name|beg
expr_stmt|;
block|}
else|else
block|{
name|beg2
operator|=
name|NULL
expr_stmt|;
name|len2
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|len1
operator|==
literal|0
condition|)
return|return
name|len2
operator|==
literal|0
condition|?
literal|0
else|:
operator|-
literal|1
return|;
if|if
condition|(
name|len2
operator|==
literal|0
condition|)
return|return
literal|1
return|;
name|diff
operator|=
name|memcmp
argument_list|(
name|beg1
argument_list|,
name|beg2
argument_list|,
name|min
argument_list|(
name|len1
argument_list|,
name|len2
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
condition|)
return|return
name|diff
return|;
return|return
name|len1
operator|-
name|len2
return|;
block|}
end_function

begin_comment
comment|/* Print field N of LINE if it exists and is nonempty, otherwise    `empty_filler' if it is nonempty. */
end_comment

begin_function
specifier|static
name|void
name|prfield
parameter_list|(
name|n
parameter_list|,
name|line
parameter_list|)
name|int
name|n
decl_stmt|;
name|struct
name|line
modifier|*
name|line
decl_stmt|;
block|{
name|int
name|len
decl_stmt|;
if|if
condition|(
name|n
operator|<
name|line
operator|->
name|nfields
condition|)
block|{
name|len
operator|=
name|line
operator|->
name|fields
index|[
name|n
index|]
operator|.
name|lim
operator|-
name|line
operator|->
name|fields
index|[
name|n
index|]
operator|.
name|beg
expr_stmt|;
if|if
condition|(
name|len
condition|)
name|fwrite
argument_list|(
name|line
operator|->
name|fields
index|[
name|n
index|]
operator|.
name|beg
argument_list|,
literal|1
argument_list|,
name|len
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|empty_filler
condition|)
name|fputs
argument_list|(
name|empty_filler
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|empty_filler
condition|)
name|fputs
argument_list|(
name|empty_filler
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Print LINE, with its fields separated by `tab'. */
end_comment

begin_function
specifier|static
name|void
name|prline
parameter_list|(
name|line
parameter_list|)
name|struct
name|line
modifier|*
name|line
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|line
operator|->
name|nfields
condition|;
operator|++
name|i
control|)
block|{
name|prfield
argument_list|(
name|i
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|line
operator|->
name|nfields
operator|-
literal|1
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|putchar
argument_list|(
name|tab
condition|?
name|tab
else|:
literal|' '
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the join of LINE1 and LINE2. */
end_comment

begin_function
specifier|static
name|void
name|prjoin
parameter_list|(
name|line1
parameter_list|,
name|line2
parameter_list|)
name|struct
name|line
modifier|*
name|line1
decl_stmt|;
name|struct
name|line
modifier|*
name|line2
decl_stmt|;
block|{
if|if
condition|(
name|outlist
condition|)
block|{
name|struct
name|outlist
modifier|*
name|o
decl_stmt|;
name|prfield
argument_list|(
name|outlist
operator|->
name|field
operator|-
literal|1
argument_list|,
name|outlist
operator|->
name|file
operator|==
literal|1
condition|?
name|line1
else|:
name|line2
argument_list|)
expr_stmt|;
for|for
control|(
name|o
operator|=
name|outlist
operator|->
name|next
init|;
name|o
condition|;
name|o
operator|=
name|o
operator|->
name|next
control|)
block|{
name|putchar
argument_list|(
name|tab
condition|?
name|tab
else|:
literal|' '
argument_list|)
expr_stmt|;
name|prfield
argument_list|(
name|o
operator|->
name|field
operator|-
literal|1
argument_list|,
name|o
operator|->
name|file
operator|==
literal|1
condition|?
name|line1
else|:
name|line2
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|i
decl_stmt|;
name|prfield
argument_list|(
name|join_field_1
argument_list|,
name|line1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|join_field_1
operator|&&
name|i
operator|<
name|line1
operator|->
name|nfields
condition|;
operator|++
name|i
control|)
block|{
name|putchar
argument_list|(
name|tab
condition|?
name|tab
else|:
literal|' '
argument_list|)
expr_stmt|;
name|prfield
argument_list|(
name|i
argument_list|,
name|line1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|join_field_1
operator|+
literal|1
init|;
name|i
operator|<
name|line1
operator|->
name|nfields
condition|;
operator|++
name|i
control|)
block|{
name|putchar
argument_list|(
name|tab
condition|?
name|tab
else|:
literal|' '
argument_list|)
expr_stmt|;
name|prfield
argument_list|(
name|i
argument_list|,
name|line1
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|join_field_2
operator|&&
name|i
operator|<
name|line2
operator|->
name|nfields
condition|;
operator|++
name|i
control|)
block|{
name|putchar
argument_list|(
name|tab
condition|?
name|tab
else|:
literal|' '
argument_list|)
expr_stmt|;
name|prfield
argument_list|(
name|i
argument_list|,
name|line2
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
name|join_field_2
operator|+
literal|1
init|;
name|i
operator|<
name|line2
operator|->
name|nfields
condition|;
operator|++
name|i
control|)
block|{
name|putchar
argument_list|(
name|tab
condition|?
name|tab
else|:
literal|' '
argument_list|)
expr_stmt|;
name|prfield
argument_list|(
name|i
argument_list|,
name|line2
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Print the join of the files in FP1 and FP2. */
end_comment

begin_function
specifier|static
name|void
name|join
parameter_list|(
name|fp1
parameter_list|,
name|fp2
parameter_list|)
name|FILE
modifier|*
name|fp1
decl_stmt|;
name|FILE
modifier|*
name|fp2
decl_stmt|;
block|{
name|struct
name|seq
name|seq1
decl_stmt|,
name|seq2
decl_stmt|;
name|struct
name|line
name|line
decl_stmt|;
name|int
name|diff
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|,
name|eof1
decl_stmt|,
name|eof2
decl_stmt|;
comment|/* Read the first line of each file. */
name|initseq
argument_list|(
operator|&
name|seq1
argument_list|)
expr_stmt|;
name|getseq
argument_list|(
name|fp1
argument_list|,
operator|&
name|seq1
argument_list|)
expr_stmt|;
name|initseq
argument_list|(
operator|&
name|seq2
argument_list|)
expr_stmt|;
name|getseq
argument_list|(
name|fp2
argument_list|,
operator|&
name|seq2
argument_list|)
expr_stmt|;
while|while
condition|(
name|seq1
operator|.
name|count
operator|&&
name|seq2
operator|.
name|count
condition|)
block|{
name|diff
operator|=
name|keycmp
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
literal|0
index|]
argument_list|,
operator|&
name|seq2
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|print_unpairables_1
condition|)
name|prline
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|freeline
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|seq1
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|getseq
argument_list|(
name|fp1
argument_list|,
operator|&
name|seq1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|diff
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|print_unpairables_2
condition|)
name|prline
argument_list|(
operator|&
name|seq2
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|freeline
argument_list|(
operator|&
name|seq2
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|seq2
operator|.
name|count
operator|=
literal|0
expr_stmt|;
name|getseq
argument_list|(
name|fp2
argument_list|,
operator|&
name|seq2
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* Keep reading lines from file1 as long as they continue to 	 match the current line from file2. */
name|eof1
operator|=
literal|0
expr_stmt|;
do|do
if|if
condition|(
operator|!
name|getseq
argument_list|(
name|fp1
argument_list|,
operator|&
name|seq1
argument_list|)
condition|)
block|{
name|eof1
operator|=
literal|1
expr_stmt|;
operator|++
name|seq1
operator|.
name|count
expr_stmt|;
break|break;
block|}
do|while
condition|(
operator|!
name|keycmp
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
name|seq1
operator|.
name|count
operator|-
literal|1
index|]
argument_list|,
operator|&
name|seq2
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
condition|)
do|;
comment|/* Keep reading lines from file2 as long as they continue to 	 match the current line from file1. */
name|eof2
operator|=
literal|0
expr_stmt|;
do|do
if|if
condition|(
operator|!
name|getseq
argument_list|(
name|fp2
argument_list|,
operator|&
name|seq2
argument_list|)
condition|)
block|{
name|eof2
operator|=
literal|1
expr_stmt|;
operator|++
name|seq2
operator|.
name|count
expr_stmt|;
break|break;
block|}
do|while
condition|(
operator|!
name|keycmp
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
literal|0
index|]
argument_list|,
operator|&
name|seq2
operator|.
name|lines
index|[
name|seq2
operator|.
name|count
operator|-
literal|1
index|]
argument_list|)
condition|)
do|;
if|if
condition|(
name|print_pairables
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seq1
operator|.
name|count
operator|-
literal|1
condition|;
operator|++
name|i
control|)
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|seq2
operator|.
name|count
operator|-
literal|1
condition|;
operator|++
name|j
control|)
name|prjoin
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
name|i
index|]
argument_list|,
operator|&
name|seq2
operator|.
name|lines
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seq1
operator|.
name|count
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|freeline
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof1
condition|)
block|{
name|seq1
operator|.
name|lines
index|[
literal|0
index|]
operator|=
name|seq1
operator|.
name|lines
index|[
name|seq1
operator|.
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|seq1
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|seq1
operator|.
name|count
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|seq2
operator|.
name|count
operator|-
literal|1
condition|;
operator|++
name|i
control|)
name|freeline
argument_list|(
operator|&
name|seq2
operator|.
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|eof2
condition|)
block|{
name|seq2
operator|.
name|lines
index|[
literal|0
index|]
operator|=
name|seq2
operator|.
name|lines
index|[
name|seq2
operator|.
name|count
operator|-
literal|1
index|]
expr_stmt|;
name|seq2
operator|.
name|count
operator|=
literal|1
expr_stmt|;
block|}
else|else
name|seq2
operator|.
name|count
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|print_unpairables_1
operator|&&
name|seq1
operator|.
name|count
condition|)
block|{
name|prline
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|freeline
argument_list|(
operator|&
name|seq1
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|get_line
argument_list|(
name|fp1
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
name|prline
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|freeline
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|print_unpairables_2
operator|&&
name|seq2
operator|.
name|count
condition|)
block|{
name|prline
argument_list|(
operator|&
name|seq2
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|freeline
argument_list|(
operator|&
name|seq2
operator|.
name|lines
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
while|while
condition|(
name|get_line
argument_list|(
name|fp2
argument_list|,
operator|&
name|line
argument_list|)
condition|)
block|{
name|prline
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
name|freeline
argument_list|(
operator|&
name|line
argument_list|)
expr_stmt|;
block|}
block|}
name|delseq
argument_list|(
operator|&
name|seq1
argument_list|)
expr_stmt|;
name|delseq
argument_list|(
operator|&
name|seq2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Add a field spec for field FIELD of file FILE to `outlist' and return 1,    unless either argument is invalid; then just return 0. */
end_comment

begin_function
specifier|static
name|int
name|add_field
parameter_list|(
name|file
parameter_list|,
name|field
parameter_list|)
name|int
name|file
decl_stmt|;
name|int
name|field
decl_stmt|;
block|{
name|struct
name|outlist
modifier|*
name|o
decl_stmt|;
if|if
condition|(
name|file
operator|<
literal|1
operator|||
name|file
operator|>
literal|2
operator|||
name|field
operator|<
literal|1
condition|)
return|return
literal|0
return|;
name|o
operator|=
operator|(
expr|struct
name|outlist
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|outlist
argument_list|)
argument_list|)
expr_stmt|;
name|o
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|o
operator|->
name|field
operator|=
name|field
expr_stmt|;
name|o
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
comment|/* Add to the end of the list so the fields are in the right order. */
if|if
condition|(
name|outlist
operator|==
name|NULL
condition|)
name|outlist
operator|=
name|o
expr_stmt|;
else|else
name|outlist_end
operator|->
name|next
operator|=
name|o
expr_stmt|;
name|outlist_end
operator|=
name|o
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* Add the comma or blank separated field spec(s) in STR to `outlist'.    Return the number of fields added. */
end_comment

begin_function
specifier|static
name|int
name|add_field_list
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|int
name|added
init|=
literal|0
decl_stmt|;
name|int
name|file
init|=
operator|-
literal|1
decl_stmt|,
name|field
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|dot_found
init|=
literal|0
decl_stmt|;
for|for
control|(
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|str
operator|==
literal|','
operator|||
name|isblank
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
name|added
operator|+=
name|add_field
argument_list|(
name|file
argument_list|,
name|field
argument_list|)
expr_stmt|;
name|file
operator|=
name|field
operator|=
operator|-
literal|1
expr_stmt|;
name|dot_found
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|str
operator|==
literal|'.'
condition|)
name|dot_found
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|ISDIGIT
argument_list|(
operator|*
name|str
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|dot_found
condition|)
block|{
if|if
condition|(
name|file
operator|==
operator|-
literal|1
condition|)
name|file
operator|=
literal|0
expr_stmt|;
name|file
operator|=
name|file
operator|*
literal|10
operator|+
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|field
operator|==
operator|-
literal|1
condition|)
name|field
operator|=
literal|0
expr_stmt|;
name|field
operator|=
name|field
operator|*
literal|10
operator|+
operator|*
name|str
operator|-
literal|'0'
expr_stmt|;
block|}
block|}
else|else
return|return
literal|0
return|;
block|}
name|added
operator|+=
name|add_field
argument_list|(
name|file
argument_list|,
name|field
argument_list|)
expr_stmt|;
return|return
name|added
return|;
block|}
end_function

begin_comment
comment|/* When using getopt_long_only, no long option can start with    a character that is a short option. */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|option
name|longopts
index|[]
init|=
block|{
block|{
literal|"j"
block|,
literal|1
block|,
name|NULL
block|,
literal|'j'
block|}
block|,
block|{
literal|"j1"
block|,
literal|1
block|,
name|NULL
block|,
literal|'1'
block|}
block|,
block|{
literal|"j2"
block|,
literal|1
block|,
name|NULL
block|,
literal|'2'
block|}
block|,
block|{
name|NULL
block|,
literal|0
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|names
index|[
literal|2
index|]
decl_stmt|;
name|FILE
modifier|*
name|fp1
decl_stmt|,
modifier|*
name|fp2
decl_stmt|;
name|int
name|optc
decl_stmt|,
name|prev_optc
init|=
literal|0
decl_stmt|,
name|nfiles
decl_stmt|,
name|val
decl_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|nfiles
operator|=
literal|0
expr_stmt|;
name|print_pairables
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|optc
operator|=
name|getopt_long_only
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"-a:e:1:2:o:t:v:"
argument_list|,
name|longopts
argument_list|,
operator|(
name|int
operator|*
operator|)
literal|0
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
switch|switch
condition|(
name|optc
condition|)
block|{
case|case
literal|'a'
case|:
name|val
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|print_unpairables_1
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|2
condition|)
name|print_unpairables_2
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid file number for `-a'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|empty_filler
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'1'
case|:
name|val
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid field number for `-1'"
argument_list|)
expr_stmt|;
name|join_field_1
operator|=
name|val
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'2'
case|:
name|val
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid field number for `-2'"
argument_list|)
expr_stmt|;
name|join_field_2
operator|=
name|val
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|val
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<=
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid field number for `-j'"
argument_list|)
expr_stmt|;
name|join_field_1
operator|=
name|join_field_2
operator|=
name|val
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|add_field_list
argument_list|(
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid field list for `-o'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|tab
operator|=
operator|*
name|optarg
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|val
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|==
literal|1
condition|)
name|print_unpairables_1
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|val
operator|==
literal|2
condition|)
name|print_unpairables_2
operator|=
literal|1
expr_stmt|;
else|else
name|error
argument_list|(
literal|2
argument_list|,
literal|0
argument_list|,
literal|"invalid file number for `-v'"
argument_list|)
expr_stmt|;
name|print_pairables
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* Non-option argument. */
if|if
condition|(
name|prev_optc
operator|==
literal|'o'
condition|)
block|{
comment|/* Might be continuation of args to -o. */
if|if
condition|(
name|add_field_list
argument_list|(
name|optarg
argument_list|)
operator|>
literal|0
condition|)
continue|continue;
comment|/* Don't change `prev_optc'. */
block|}
if|if
condition|(
name|nfiles
operator|>
literal|1
condition|)
name|usage
argument_list|()
expr_stmt|;
name|names
index|[
name|nfiles
operator|++
index|]
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|usage
argument_list|()
expr_stmt|;
block|}
name|prev_optc
operator|=
name|optc
expr_stmt|;
block|}
if|if
condition|(
name|nfiles
operator|!=
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
name|fp1
operator|=
name|strcmp
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
condition|?
name|fopen
argument_list|(
name|names
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fp1
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|names
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|fp2
operator|=
name|strcmp
argument_list|(
name|names
index|[
literal|1
index|]
argument_list|,
literal|"-"
argument_list|)
condition|?
name|fopen
argument_list|(
name|names
index|[
literal|1
index|]
argument_list|,
literal|"r"
argument_list|)
else|:
name|stdin
expr_stmt|;
if|if
condition|(
operator|!
name|fp2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"%s"
argument_list|,
name|names
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|fp1
operator|==
name|fp2
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"both files cannot be standard input"
argument_list|)
expr_stmt|;
name|join
argument_list|(
name|fp1
argument_list|,
name|fp2
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fp1
operator|==
name|stdin
operator|||
name|fp2
operator|==
name|stdin
operator|)
operator|&&
name|fclose
argument_list|(
name|stdin
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
name|errno
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
operator|||
name|fclose
argument_list|(
name|stdout
argument_list|)
operator|==
name|EOF
condition|)
name|error
argument_list|(
literal|1
argument_list|,
literal|0
argument_list|,
literal|"write error"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\ Usage: %s [-a 1|2] [-v 1|2] [-e empty-string] [-o field-list...] [-t char]\n\        [-j[1|2] field] [-1 field] [-2 field] file1 file2\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* error.c -- error handler for noninteractive utilities    Copyright (C) 1990, 1991 Free Software Foundation, Inc.     This program is free software; you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation; either version 2, or (at your option)    any later version.     This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.     You should have received a copy of the GNU General Public License    along with this program; if not, write to the Free Software    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */
end_comment

begin_comment
comment|/* David MacKenzie */
end_comment

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_define
define|#
directive|define
name|VA_START
parameter_list|(
name|args
parameter_list|,
name|lastarg
parameter_list|)
value|va_start(args, lastarg)
end_define

begin_comment
comment|/* Print the program name and error message MESSAGE, which is a printf-style    format string with optional args.    If ERRNUM is nonzero, print its corresponding system error message.    Exit with status STATUS if it is nonzero. */
end_comment

begin_comment
comment|/* VARARGS */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|int
name|status
parameter_list|,
name|int
name|errnum
parameter_list|,
name|char
modifier|*
name|message
parameter_list|,
modifier|...
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|program_name
decl_stmt|;
name|va_list
name|args
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: "
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|va_start
argument_list|(
name|args
argument_list|,
name|message
argument_list|)
expr_stmt|;
name|vfprintf
argument_list|(
name|stderr
argument_list|,
name|message
argument_list|,
name|args
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|args
argument_list|)
expr_stmt|;
if|if
condition|(
name|errnum
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|": %s"
argument_list|,
name|strerror
argument_list|(
name|errnum
argument_list|)
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|status
condition|)
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

