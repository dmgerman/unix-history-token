begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * ++Copyright++ 1989  * -  * Copyright (c) 1989  *    The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  * 	This product includes software developed by the University of  * 	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  * -  * Portions Copyright (c) 1993 by Digital Equipment Corporation.  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies, and that  * the name of Digital Equipment Corporation not be used in advertising or  * publicity pertaining to distribution of the document or software without  * specific, written prior permission.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND DIGITAL EQUIPMENT CORP. DISCLAIMS ALL  * WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES  * OF MERCHANTABILITY AND FITNESS.   IN NO EVENT SHALL DIGITAL EQUIPMENT  * CORPORATION BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL  * DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR  * PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS  * ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS  * SOFTWARE.  * -  * --Copyright--  */
end_comment

begin_comment
comment|/*********************** Notes for the BIND 4.9 release (Paul Vixie, DEC)  *	dig 2.0 was written by copying sections of libresolv.a and nslookup  *	and modifying them to be more useful for a general lookup utility.  *	as of BIND 4.9, the changes needed to support dig have mostly been  *	incorporated into libresolv.a and nslookup; dig now links against  *	some of nslookup's .o files rather than #including them or maintaining  *	local copies of them.  in some sense, dig belongs in the nslookup  *	subdirectory rather than up here in "tools", but that's for arc@sgi.com  *	(owner of nslookup) to decide.  *  *	while merging dig back into the BIND release, i made a number of  *	structural changes.  for one thing, i put all of dig's private  *	library routines into this file rather than maintaining them in  *	separate, #included, files.  i don't like to #include ".c" files.  *	i removed all calls to "bcopy", replacing them with structure  *	assignments.  i removed all "extern"'s of standard functions,  *	replacing them with #include's of standard header files.  this  *	version of dig is probably as portable as the rest of BIND.  *  *	i had to remove the query-time and packet-count statistics since  *	the current libresolv.a is a lot harder to modify to maintain these  *	than the 4.8 one (used in the original dig) was.  for consolation,  *	i added a "usage" message with extensive help text.  *  *	to save my (limited, albeit) sanity, i ran "indent" over the source.  *	i also added the standard berkeley/DEC copyrights, since this file now  *	contains a fair amount of non-USC code.  note that the berkeley and  *	DEC copyrights do not prohibit redistribution, with or without fee;  *	we add them only to protect ourselves (you have to claim copyright  *	in order to disclaim liability and warranty).  *  *	Paul Vixie, Palo Alto, CA, April 1993  ****************************************************************************/
end_comment

begin_comment
comment|/*******************************************************************  **      DiG -- Domain Information Groper                          **  **                                                                **  **        dig.c - Version 2.1 (7/12/94) ("BIND takeover")         **  **                                                                **  **        Developed by: Steve Hotz& Paul Mockapetris             **  **        USC Information Sciences Institute (USC-ISI)            **  **        Marina del Rey, California                              **  **        1989                                                    **  **                                                                **  **        dig.c -                                                 **  **           Version 2.0 (9/1/90)                                 **  **               o renamed difftime() difftv() to avoid           **  **                 clash with ANSI C                              **  **               o fixed incorrect # args to strcmp,gettimeofday  **  **               o incorrect length specified to strncmp          **  **               o fixed broken -sticky -envsa -envset functions  **  **               o print options/flags redefined& modified       **  **                                                                **  **           Version 2.0.beta (5/9/90)                            **  **               o output format - helpful to `doc`               **  **               o minor cleanup                                  **  **               o release to beta testers                        **  **                                                                **  **           Version 1.1.beta (10/26/89)                          **  **               o hanging zone transer (when REFUSED) fixed      **  **               o trailing dot added to domain names in RDATA    **  **               o ISI internal                                   **  **                                                                **  **           Version 1.0.tmp  (8/27/89)                           **  **               o Error in prnttime() fixed                      **  **               o no longer dumps core on large pkts             **  **               o zone transfer (axfr) added                     **  **               o -x added for inverse queries                   **  **                               (i.e. "dig -x 128.9.0.32")       **  **               o give address of default server                 **  **               o accept broadcast to server @255.255.255.255    **  **                                                                **  **           Version 1.0  (3/27/89)                               **  **               o original release                               **  **                                                                **  **     DiG is Public Domain, and may be used for any purpose as   **  **     long as this notice is not removed.                        **  ****                                                            ****  ****   NOTE: Version 2.0.beta is not for public distribution    ****  ****                                                            ****  *******************************************************************/
end_comment

begin_define
define|#
directive|define
name|VERSION
value|21
end_define

begin_define
define|#
directive|define
name|VSTRING
value|"2.1"
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/nameser.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<resolv.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"res.h"
end_include

begin_define
define|#
directive|define
name|PRF_DEF
value|0x2ff9
end_define

begin_define
define|#
directive|define
name|PRF_MIN
value|0xA930
end_define

begin_define
define|#
directive|define
name|PRF_ZONE
value|0x24f9
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|MAXHOSTNAMELEN
end_ifndef

begin_define
define|#
directive|define
name|MAXHOSTNAMELEN
value|256
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|eecode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|qfp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sockFD
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|SAVEENV
value|"DiG.env"
end_define

begin_define
define|#
directive|define
name|DIG_MAXARGS
value|30
end_define

begin_decl_stmt
name|char
modifier|*
name|defsrv
decl_stmt|,
modifier|*
name|srvmsg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|defbuf
index|[
literal|40
index|]
init|=
literal|"default -- "
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|srvbuf
index|[
literal|60
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|void
name|Usage
parameter_list|()
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|SetOption
argument_list|()
decl_stmt|,
name|printZone
argument_list|()
decl_stmt|,
name|printRR
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|struct
name|timeval
name|difftv
parameter_list|()
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|prnttime
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* stuff for nslookup modules */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|filePtr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|env
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HostInfo
modifier|*
name|defaultPtr
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|HostInfo
name|curHostInfo
decl_stmt|,
name|defaultRec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|curHostValid
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|queryType
decl_stmt|,
name|queryClass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|StringToClass
argument_list|()
decl_stmt|,
name|StringToType
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* subr.c */
end_comment

begin_if
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|&&
name|BSD
operator|>=
literal|199006
operator|&&
operator|!
name|defined
argument_list|(
name|RISCOS_BSD
argument_list|)
end_if

begin_decl_stmt
name|FILE
modifier|*
name|yyin
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|yyrestart
parameter_list|(
name|f
parameter_list|)
block|{ }
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|pager
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of nslookup stuff */
end_comment

begin_comment
comment|/*  ** Take arguments appearing in simple string (from file or command line)  ** place in char**.  */
end_comment

begin_macro
name|stackarg
argument_list|(
argument|y
argument_list|,
argument|l
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|l
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|y
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|done
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|!
name|done
condition|)
block|{
switch|switch
condition|(
operator|*
name|l
condition|)
block|{
case|case
literal|'\t'
case|:
case|case
literal|' '
case|:
name|l
operator|++
expr_stmt|;
break|break;
case|case
literal|'\0'
case|:
case|case
literal|'\n'
case|:
name|done
operator|++
expr_stmt|;
operator|*
name|y
operator|=
name|NULL
expr_stmt|;
break|break;
default|default:
operator|*
name|y
operator|++
operator|=
name|l
expr_stmt|;
while|while
condition|(
operator|!
name|isspace
argument_list|(
operator|*
name|l
argument_list|)
condition|)
name|l
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|l
operator|==
literal|'\n'
condition|)
name|done
operator|++
expr_stmt|;
operator|*
name|l
operator|++
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|y
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_block

begin_decl_stmt
name|char
name|myhostname
index|[
name|MAXHOSTNAMELEN
index|]
decl_stmt|;
end_decl_stmt

begin_function
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|struct
name|hostent
modifier|*
name|hp
decl_stmt|;
name|short
name|port
init|=
name|htons
argument_list|(
name|NAMESERVER_PORT
argument_list|)
decl_stmt|;
comment|/* Wierd stuff for SPARC alignment, hurts nothing else. */
union|union
block|{
name|HEADER
name|header_
decl_stmt|;
name|u_char
name|packet_
index|[
name|PACKETSZ
index|]
decl_stmt|;
block|}
name|packet_
union|;
define|#
directive|define
name|packet
value|(packet_.packet_)
name|u_char
name|answer
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
name|int
name|n
decl_stmt|;
name|char
name|doping
index|[
literal|90
index|]
decl_stmt|;
name|char
name|pingstr
index|[
literal|50
index|]
decl_stmt|;
name|char
modifier|*
name|afile
decl_stmt|;
name|char
modifier|*
name|addrc
decl_stmt|,
modifier|*
name|addrend
decl_stmt|,
modifier|*
name|addrbegin
decl_stmt|;
name|struct
name|timeval
name|exectime
decl_stmt|,
name|tv1
decl_stmt|,
name|tv2
decl_stmt|,
name|start_time
decl_stmt|,
name|end_time
decl_stmt|,
name|query_time
decl_stmt|;
name|char
modifier|*
name|srv
decl_stmt|;
name|int
name|anyflag
init|=
literal|0
decl_stmt|;
name|int
name|sticky
init|=
literal|0
decl_stmt|;
name|int
name|tmp
decl_stmt|;
name|int
name|qtypeSet
decl_stmt|;
name|int
name|addrflag
init|=
literal|0
decl_stmt|;
name|int
name|zone
init|=
literal|0
decl_stmt|;
name|int
name|bytes_out
decl_stmt|,
name|bytes_in
decl_stmt|;
name|char
name|cmd
index|[
literal|256
index|]
decl_stmt|;
name|char
name|domain
index|[
name|MAXDNAME
index|]
decl_stmt|;
name|char
name|msg
index|[
literal|120
index|]
decl_stmt|,
modifier|*
name|msgptr
decl_stmt|;
name|char
modifier|*
modifier|*
name|vtmp
decl_stmt|;
name|char
modifier|*
name|args
index|[
name|DIG_MAXARGS
index|]
decl_stmt|;
name|char
modifier|*
modifier|*
name|ax
decl_stmt|;
name|char
modifier|*
modifier|*
name|ay
decl_stmt|;
name|int
name|once
init|=
literal|1
decl_stmt|,
name|dofile
init|=
literal|0
decl_stmt|;
comment|/* batch -vs- interactive control */
name|char
name|fileq
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|qptr
decl_stmt|;
name|int
name|fp
decl_stmt|;
name|int
name|wait
init|=
literal|0
decl_stmt|,
name|delay
decl_stmt|;
name|int
name|envset
init|=
literal|0
decl_stmt|,
name|envsave
init|=
literal|0
decl_stmt|;
name|struct
name|__res_state
name|res_x
decl_stmt|,
name|res_t
decl_stmt|;
name|char
modifier|*
name|pp
decl_stmt|;
name|res_init
argument_list|()
expr_stmt|;
name|_res
operator|.
name|pfcode
operator|=
name|PRF_DEF
expr_stmt|;
name|qtypeSet
operator|=
literal|0
expr_stmt|;
name|gethostname
argument_list|(
name|myhostname
argument_list|,
operator|(
sizeof|sizeof
name|myhostname
operator|)
argument_list|)
expr_stmt|;
name|defsrv
operator|=
name|strcat
argument_list|(
name|defbuf
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|res_x
operator|=
name|_res
expr_stmt|;
comment|/*  ** If LOCALDEF in environment, should point to file  ** containing local favourite defaults.  Also look for file  ** DiG.env (i.e. SAVEENV) in local directory.  */
if|if
condition|(
operator|(
operator|(
operator|(
name|afile
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"LOCALDEF"
argument_list|)
operator|)
operator|!=
operator|(
name|char
operator|*
operator|)
name|NULL
operator|)
operator|&&
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|afile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|SAVEENV
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|read
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|res_x
argument_list|,
operator|(
sizeof|sizeof
name|res_x
operator|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
name|_res
operator|=
name|res_x
expr_stmt|;
block|}
comment|/*  **   check for batch-mode DiG; also pre-scan for 'help'  */
name|vtmp
operator|=
name|argv
expr_stmt|;
name|ax
operator|=
name|args
expr_stmt|;
while|while
condition|(
operator|*
name|vtmp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-help"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-usage"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"help"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|vtmp
argument_list|,
literal|"-f"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|dofile
operator|++
expr_stmt|;
name|once
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|qfp
operator|=
name|fopen
argument_list|(
operator|*
operator|++
name|vtmp
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|perror
argument_list|(
literal|"file open"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|ax
operator|-
name|args
operator|==
name|DIG_MAXARGS
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"dig: too many arguments\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|10
argument_list|)
expr_stmt|;
block|}
operator|*
name|ax
operator|++
operator|=
operator|*
name|vtmp
expr_stmt|;
block|}
name|vtmp
operator|++
expr_stmt|;
block|}
name|_res
operator|.
name|id
operator|=
literal|1
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|tv1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/*  **  Main section: once if cmd-line query  **                while !EOF if batch mode  */
operator|*
name|fileq
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|dofile
operator|&&
operator|(
name|fgets
argument_list|(
name|fileq
argument_list|,
literal|100
argument_list|,
name|qfp
argument_list|)
operator|!=
name|NULL
operator|)
operator|)
operator|||
operator|(
operator|(
operator|!
name|dofile
operator|)
operator|&&
operator|(
name|once
operator|--
operator|)
operator|)
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|fileq
operator|==
literal|'\n'
operator|)
operator|||
operator|(
operator|*
name|fileq
operator|==
literal|'#'
operator|)
operator|||
operator|(
operator|*
name|fileq
operator|==
literal|';'
operator|)
condition|)
block|{
continue|continue;
comment|/* ignore blank lines& comments */
block|}
comment|/*  * "sticky" requests that before current parsing args  * return to current "working" environment (X******)  */
if|if
condition|(
name|sticky
condition|)
block|{
name|printf
argument_list|(
literal|";; (using sticky settings)\n"
argument_list|)
expr_stmt|;
name|_res
operator|=
name|res_x
expr_stmt|;
block|}
comment|/* concat cmd-line and file args */
name|ay
operator|=
name|ax
expr_stmt|;
name|qptr
operator|=
name|fileq
expr_stmt|;
name|stackarg
argument_list|(
name|ay
argument_list|,
name|qptr
argument_list|)
expr_stmt|;
comment|/* defaults */
name|queryType
operator|=
name|T_NS
expr_stmt|;
name|queryClass
operator|=
name|C_IN
expr_stmt|;
name|zone
operator|=
literal|0
expr_stmt|;
operator|*
name|pingstr
operator|=
literal|0
expr_stmt|;
name|srv
operator|=
name|NULL
expr_stmt|;
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"\n;<<>> DiG %s<<>> "
argument_list|,
name|VSTRING
argument_list|)
expr_stmt|;
name|argv
operator|=
name|args
expr_stmt|;
name|argc
operator|=
name|ax
operator|-
name|args
expr_stmt|;
comment|/*  * More cmd-line options than anyone should ever have to  * deal with ....  */
while|while
condition|(
operator|*
operator|(
operator|++
name|argv
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|*
name|argv
operator|!=
literal|'\0'
condition|)
block|{
name|strcat
argument_list|(
name|cmd
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|cmd
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'@'
condition|)
block|{
name|srv
operator|=
operator|(
operator|*
name|argv
operator|+
literal|1
operator|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'%'
condition|)
continue|continue;
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'+'
condition|)
block|{
name|SetOption
argument_list|(
operator|*
name|argv
operator|+
literal|1
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-nost"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sticky
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-st"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sticky
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-envsa"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|envsave
operator|++
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-envse"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|envset
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
operator|*
name|argv
operator|==
literal|'-'
condition|)
block|{
switch|switch
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'T'
case|:
name|wait
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
operator|(
name|tmp
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
operator|)
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
name|queryClass
operator|=
name|tmp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|=
name|StringToClass
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|queryClass
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"; invalid class specified\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'t'
case|:
if|if
condition|(
operator|(
name|tmp
operator|=
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
operator|)
operator|||
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'0'
condition|)
block|{
name|queryType
operator|=
name|tmp
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tmp
operator|=
name|StringToType
argument_list|(
operator|*
name|argv
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|)
condition|)
block|{
name|queryType
operator|=
name|tmp
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"; invalid type specified\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'x'
case|:
if|if
condition|(
operator|!
name|qtypeSet
condition|)
block|{
name|queryType
operator|=
name|T_ANY
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
operator|(
name|addrc
operator|=
operator|*
operator|++
name|argv
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"; no arg for -x?\n"
argument_list|)
expr_stmt|;
break|break;
block|}
name|addrend
operator|=
name|addrc
operator|+
name|strlen
argument_list|(
name|addrc
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|addrend
operator|==
literal|'.'
condition|)
operator|*
name|addrend
operator|=
literal|'\0'
expr_stmt|;
operator|*
name|domain
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|addrbegin
operator|=
name|strrchr
argument_list|(
name|addrc
argument_list|,
literal|'.'
argument_list|)
condition|)
block|{
name|strcat
argument_list|(
name|domain
argument_list|,
name|addrbegin
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|domain
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
operator|*
name|addrbegin
operator|=
literal|'\0'
expr_stmt|;
block|}
name|strcat
argument_list|(
name|domain
argument_list|,
name|addrc
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|domain
argument_list|,
literal|".in-addr.arpa."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|port
operator|=
name|htons
argument_list|(
name|atoi
argument_list|(
operator|*
operator|++
name|argv
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
operator|!=
literal|'\0'
condition|)
name|strcpy
argument_list|(
name|pingstr
argument_list|,
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|pingstr
argument_list|,
literal|"ping -s"
argument_list|)
expr_stmt|;
break|break;
if|#
directive|if
name|defined
argument_list|(
name|__RES
argument_list|)
operator|&&
operator|(
name|__RES
operator|>=
literal|19931104
operator|)
case|case
literal|'n'
case|:
name|_res
operator|.
name|ndots
operator|=
name|atoi
argument_list|(
operator|&
name|argv
index|[
literal|0
index|]
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/*__RES*/
block|}
comment|/* switch - */
continue|continue;
block|}
comment|/* if '-'   */
if|if
condition|(
operator|(
name|tmp
operator|=
name|StringToType
argument_list|(
operator|*
name|argv
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
operator|(
name|T_ANY
operator|==
name|tmp
operator|)
operator|&&
name|anyflag
operator|++
condition|)
block|{
name|queryClass
operator|=
name|C_ANY
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|T_AXFR
operator|==
name|tmp
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|=
name|PRF_ZONE
expr_stmt|;
name|zone
operator|++
expr_stmt|;
block|}
else|else
block|{
name|queryType
operator|=
name|tmp
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|tmp
operator|=
name|StringToClass
argument_list|(
operator|*
name|argv
argument_list|,
operator|-
literal|1
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
name|queryClass
operator|=
name|tmp
expr_stmt|;
block|}
else|else
block|{
name|bzero
argument_list|(
name|domain
argument_list|,
operator|(
sizeof|sizeof
name|domain
operator|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|domain
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* while argv remains */
if|if
condition|(
name|_res
operator|.
name|pfcode
operator|&
literal|0x80000
condition|)
name|printf
argument_list|(
literal|"; pfcode: %08x, options: %08x\n"
argument_list|,
name|_res
operator|.
name|pfcode
argument_list|,
name|_res
operator|.
name|options
argument_list|)
expr_stmt|;
comment|/*  * Current env. (after this parse) is to become the  * new "working environmnet. Used in conj. with sticky.  */
if|if
condition|(
name|envset
condition|)
block|{
name|res_x
operator|=
name|_res
expr_stmt|;
name|envset
operator|=
literal|0
expr_stmt|;
block|}
comment|/*  * Current env. (after this parse) is to become the  * new default saved environmnet. Save in user specified  * file if exists else is SAVEENV (== "DiG.env").  */
if|if
condition|(
name|envsave
condition|)
block|{
name|afile
operator|=
operator|(
name|char
operator|*
operator|)
name|getenv
argument_list|(
literal|"LOCALDEF"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|afile
operator|&&
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|afile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|S_IREAD
operator||
name|S_IWRITE
argument_list|)
operator|)
operator|>
literal|0
operator|)
operator|)
operator|||
operator|(
operator|(
name|fp
operator|=
name|open
argument_list|(
name|SAVEENV
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
operator||
name|O_TRUNC
argument_list|,
name|S_IREAD
operator||
name|S_IWRITE
argument_list|)
operator|)
operator|>
literal|0
operator|)
condition|)
block|{
name|write
argument_list|(
name|fp
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|_res
argument_list|,
operator|(
sizeof|sizeof
name|_res
operator|)
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fp
argument_list|)
expr_stmt|;
block|}
name|envsave
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|_res
operator|.
name|pfcode
operator|&
name|RES_PRF_CMD
condition|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|addrflag
operator|=
name|anyflag
operator|=
literal|0
expr_stmt|;
comment|/*  * Find address of server to query. If not dot-notation, then  * try to resolve domain-name (if so, save and turn off print  * options, this domain-query is not the one we want. Restore  * user options when done.  * Things get a bit wierd since we need to use resolver to be  * able to "put the resolver to work".  */
name|srvbuf
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|srvmsg
operator|=
name|defsrv
expr_stmt|;
if|if
condition|(
name|srv
operator|!=
name|NULL
condition|)
block|{
name|struct
name|in_addr
name|addr
decl_stmt|;
if|if
condition|(
name|inet_aton
argument_list|(
name|srv
argument_list|,
operator|&
name|addr
argument_list|)
condition|)
block|{
name|_res
operator|.
name|nscount
operator|=
literal|1
expr_stmt|;
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
operator|=
name|addr
expr_stmt|;
name|srvmsg
operator|=
name|strcat
argument_list|(
name|srvbuf
argument_list|,
name|srv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|res_t
operator|=
name|_res
expr_stmt|;
name|_res
operator|.
name|pfcode
operator|=
literal|0
expr_stmt|;
name|_res
operator|.
name|options
operator|=
name|RES_DEFAULT
expr_stmt|;
name|res_init
argument_list|()
expr_stmt|;
name|hp
operator|=
name|gethostbyname
argument_list|(
name|srv
argument_list|)
expr_stmt|;
name|_res
operator|=
name|res_t
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
operator|||
name|hp
operator|->
name|h_addr_list
operator|==
name|NULL
operator|||
operator|*
name|hp
operator|->
name|h_addr_list
operator|==
name|NULL
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; Bad server: %s -- using default server and timer opts\n"
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|srvmsg
operator|=
name|defsrv
expr_stmt|;
name|srv
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|u_int32_t
modifier|*
modifier|*
name|addr
decl_stmt|;
name|_res
operator|.
name|nscount
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|addr
operator|=
operator|(
name|u_int32_t
operator|*
operator|*
operator|)
name|hp
operator|->
name|h_addr_list
init|;
operator|*
name|addr
operator|&&
operator|(
name|_res
operator|.
name|nscount
operator|<
name|MAXNS
operator|)
condition|;
name|addr
operator|++
control|)
block|{
name|_res
operator|.
name|nsaddr_list
index|[
name|_res
operator|.
name|nscount
operator|++
index|]
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
operator|*
operator|*
name|addr
expr_stmt|;
block|}
name|srvmsg
operator|=
name|strcat
argument_list|(
name|srvbuf
argument_list|,
name|srv
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|srvbuf
argument_list|,
literal|"  "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|srvmsg
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"; (%d server%s found)\n"
argument_list|,
name|_res
operator|.
name|nscount
argument_list|,
operator|(
name|_res
operator|.
name|nscount
operator|==
literal|1
operator|)
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|_res
operator|.
name|id
operator|+=
name|_res
operator|.
name|retry
expr_stmt|;
block|}
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
block|{
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
block|}
name|_res
operator|.
name|id
operator|+=
name|_res
operator|.
name|retry
expr_stmt|;
block|}
if|if
condition|(
name|zone
condition|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|_res
operator|.
name|nscount
condition|;
name|i
operator|++
control|)
block|{
name|int
name|x
init|=
name|printZone
argument_list|(
name|domain
argument_list|,
operator|&
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
argument_list|)
decl_stmt|;
if|if
condition|(
name|_res
operator|.
name|pfcode
operator|&
name|RES_PRF_STATS
condition|)
block|{
name|struct
name|timeval
name|exectime
decl_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|exectime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; FROM: %s to SERVER: %s\n"
argument_list|,
name|myhostname
argument_list|,
name|inet_ntoa
argument_list|(
name|_res
operator|.
name|nsaddr_list
index|[
name|i
index|]
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; WHEN: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|exectime
operator|.
name|tv_sec
operator|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|x
condition|)
break|break;
comment|/* success */
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|domain
operator|&&
operator|!
name|qtypeSet
condition|)
block|{
name|queryType
operator|=
name|T_A
expr_stmt|;
name|qtypeSet
operator|++
expr_stmt|;
block|}
name|bytes_out
operator|=
name|n
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|domain
argument_list|,
name|queryClass
argument_list|,
name|queryType
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
name|NULL
argument_list|,
name|packet
argument_list|,
sizeof|sizeof
argument_list|(
name|packet
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
block|{
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; res_mkquery: buffer too small\n\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|eecode
operator|=
literal|0
expr_stmt|;
name|__fp_resstat
argument_list|(
name|NULL
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|start_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|bytes_in
operator|=
name|n
operator|=
name|res_send
argument_list|(
name|packet
argument_list|,
name|n
argument_list|,
name|answer
argument_list|,
sizeof|sizeof
argument_list|(
name|answer
argument_list|)
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|n
operator|=
literal|0
operator|-
name|n
expr_stmt|;
name|msg
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
literal|";; res_send to server "
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|msg
argument_list|,
name|srvmsg
argument_list|)
expr_stmt|;
name|perror
argument_list|(
name|msg
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dofile
condition|)
block|{
if|if
condition|(
name|eecode
condition|)
name|exit
argument_list|(
name|eecode
argument_list|)
expr_stmt|;
else|else
name|exit
argument_list|(
literal|9
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|gettimeofday
argument_list|(
operator|&
name|end_time
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|_res
operator|.
name|pfcode
operator|&
name|RES_PRF_STATS
condition|)
block|{
name|query_time
operator|=
name|difftv
argument_list|(
name|start_time
argument_list|,
name|end_time
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; Total query time: "
argument_list|)
expr_stmt|;
name|prnttime
argument_list|(
name|query_time
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|gettimeofday
argument_list|(
operator|&
name|exectime
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; FROM: %s to SERVER: %s\n"
argument_list|,
name|myhostname
argument_list|,
name|srvmsg
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; WHEN: %s"
argument_list|,
name|ctime
argument_list|(
operator|&
operator|(
name|exectime
operator|.
name|tv_sec
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|";; MSG SIZE  sent: %d  rcvd: %d\n"
argument_list|,
name|bytes_out
argument_list|,
name|bytes_in
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
comment|/*  *   Argh ... not particularly elegant. Should put in *real* ping code.  *   Would necessitate root priviledges for icmp port though!  */
if|if
condition|(
operator|*
name|pingstr
condition|)
block|{
name|sprintf
argument_list|(
name|doping
argument_list|,
literal|"%s %s 56 3 | tail -3"
argument_list|,
name|pingstr
argument_list|,
operator|(
name|srv
operator|==
name|NULL
operator|)
condition|?
operator|(
name|defsrv
operator|+
literal|10
operator|)
else|:
name|srv
argument_list|)
expr_stmt|;
name|system
argument_list|(
name|doping
argument_list|)
expr_stmt|;
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/*  * Fairly crude method and low overhead method of keeping two  * batches started at different sites somewhat synchronized.  */
name|gettimeofday
argument_list|(
operator|&
name|tv2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|delay
operator|=
call|(
name|int
call|)
argument_list|(
name|tv2
operator|.
name|tv_sec
operator|-
name|tv1
operator|.
name|tv_sec
argument_list|)
expr_stmt|;
if|if
condition|(
name|delay
operator|<
name|wait
condition|)
block|{
name|sleep
argument_list|(
name|wait
operator|-
name|delay
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
name|eecode
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|Usage
parameter_list|()
block|{
name|fputs
argument_list|(
literal|"\ usage:  dig [@server] [domain] [q-type] [q-class] {q-opt} {d-opt} [%comment]\n\ where:	server,\n\ 	domain	are names in the Domain Name System\n\ 	q-class	is one of (in,any,...) [default: in]\n\ 	q-type	is one of (a,any,mx,ns,soa,hinfo,axfr,txt,...) [default: a]\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ 	q-opt	is one of:\n\ 		-x dot-notation-address	(shortcut to in-addr.arpa lookups)\n\ 		-f file			(batch mode input file name)\n\ 		-T time			(batch mode time delay, per query)\n\ 		-p port			(nameserver is on this port) [53]\n\ 		-Pping-string		(see man page)\n\ 		-t query-type		(synonym for q-type)\n\ 		-c query-class		(synonym for q-class)\n\ 		-envsav,-envset		(see man page)\n\ 		-[no]stick		(see man page)\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ 	d-opt	is of the form ``+keyword=value'' where keyword is one of:\n\ 		[no]debug [no]d2 [no]recurse retry=# time=# [no]ko [no]vc\n\ 		[no]defname [no]search domain=NAME [no]ignore [no]primary\n\ 		[no]aaonly [no]sort [no]cmd [no]stats [no]Header [no]header\n\ 		[no]ttlid [no]cl [no]qr [no]reply [no]ques [no]answer\n\ 		[no]author [no]addit pfdef pfmin pfset=# pfand=# pfor=#\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"\ notes:	defname and search don't work; use fully-qualified names.\n\ "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|SetOption
parameter_list|(
name|string
parameter_list|)
name|char
modifier|*
name|string
decl_stmt|;
block|{
name|char
name|option
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|type
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|i
decl_stmt|;
name|i
operator|=
name|sscanf
argument_list|(
name|string
argument_list|,
literal|" %s"
argument_list|,
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";*** Invalid option: %s\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"aa"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* aaonly */
name|_res
operator|.
name|options
operator||=
name|RES_AAONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noaa"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_AAONLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"deb"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* debug */
name|_res
operator|.
name|options
operator||=
name|RES_DEBUG
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodeb"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ko"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* keepopen */
name|_res
operator|.
name|options
operator||=
operator|(
name|RES_STAYOPEN
operator||
name|RES_USEVC
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noko"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_STAYOPEN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"d2"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* d2 (more debug) */
name|_res
operator|.
name|options
operator||=
operator|(
name|RES_DEBUG
operator||
name|RES_DEBUG2
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nod2"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEBUG2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"def"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* defname */
name|_res
operator|.
name|options
operator||=
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nodef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DEFNAMES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"sea"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* search list */
name|_res
operator|.
name|options
operator||=
name|RES_DNSRCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nosea"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_DNSRCH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"do"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* domain */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%s"
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ti"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* timeout */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|_res
operator|.
name|retrans
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ret"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* retry */
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|sscanf
argument_list|(
operator|++
name|ptr
argument_list|,
literal|"%d"
argument_list|,
operator|&
name|_res
operator|.
name|retry
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"i"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* ignore */
name|_res
operator|.
name|options
operator||=
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noi"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_IGNTC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* primary */
name|_res
operator|.
name|options
operator||=
name|RES_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nop"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_PRIMARY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"rec"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* recurse */
name|_res
operator|.
name|options
operator||=
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"norec"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"v"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* vc */
name|_res
operator|.
name|options
operator||=
name|RES_USEVC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nov"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_USEVC
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfset"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|=
name|xstrtonum
argument_list|(
operator|++
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfand"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|=
name|_res
operator|.
name|pfcode
operator|&
name|xstrtonum
argument_list|(
operator|++
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfor"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|ptr
operator|=
name|strchr
argument_list|(
name|option
argument_list|,
literal|'='
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
name|_res
operator|.
name|pfcode
operator||=
name|xstrtonum
argument_list|(
operator|++
name|ptr
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfmin"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|=
name|PRF_MIN
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"pfdef"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|=
name|PRF_DEF
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"an"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* answer section */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_ANS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noan"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_ANS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"qu"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* question section */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_QUES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noqu"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_QUES
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"au"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* authority section */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_AUTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noau"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_AUTH
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"ad"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* addition section */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noad"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_ADD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"tt"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* TTL& ID */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_TTLID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nott"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_TTLID
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"he"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* head flags stats */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_HEAD2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nohe"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_HEAD2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"H"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* header all */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_HEADX
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noH"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
operator|(
name|RES_PRF_HEADX
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"qr"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* query */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_QUERY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"noqr"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_QUERY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"rep"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* reply */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_REPLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"norep"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_REPLY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"cm"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* command line */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_CMD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nocm"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_CMD
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"cl"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* class mnemonic */
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_CLASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nocl"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_CLASS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"st"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* stats*/
name|_res
operator|.
name|pfcode
operator||=
name|RES_PRF_STATS
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|option
argument_list|,
literal|"nost"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|_res
operator|.
name|pfcode
operator|&=
operator|~
name|RES_PRF_STATS
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; *** Invalid option: %s\n"
argument_list|,
name|option
argument_list|)
expr_stmt|;
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
name|res_re_init
argument_list|()
expr_stmt|;
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Force a reinitialization when the domain is changed.  */
end_comment

begin_macro
name|res_re_init
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|char
name|localdomain
index|[]
init|=
literal|"LOCALDOMAIN"
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|long
name|pfcode
init|=
name|_res
operator|.
name|pfcode
decl_stmt|;
comment|/* this is ugly but putenv() is more portable than setenv() */
name|buf
operator|=
name|malloc
argument_list|(
operator|(
sizeof|sizeof
name|localdomain
operator|)
operator|+
name|strlen
argument_list|(
name|_res
operator|.
name|defdname
argument_list|)
operator|+
literal|10
comment|/*fuzz*/
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s=%s"
argument_list|,
name|localdomain
argument_list|,
name|_res
operator|.
name|defdname
argument_list|)
expr_stmt|;
name|putenv
argument_list|(
name|buf
argument_list|)
expr_stmt|;
comment|/* keeps the argument, so we won't free it */
name|_res
operator|.
name|options
operator|&=
operator|~
name|RES_INIT
expr_stmt|;
name|res_init
argument_list|()
expr_stmt|;
name|_res
operator|.
name|pfcode
operator|=
name|pfcode
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * convert char string (decimal, octal, or hex) to integer  */
end_comment

begin_function
name|int
name|xstrtonum
parameter_list|(
name|p
parameter_list|)
name|char
modifier|*
name|p
decl_stmt|;
block|{
name|int
name|v
init|=
literal|0
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|b
init|=
literal|10
decl_stmt|;
name|int
name|flag
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|p
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|flag
operator|++
condition|)
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
condition|)
block|{
name|b
operator|=
literal|8
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|p
argument_list|)
condition|)
operator|*
name|p
operator|=
name|tolower
argument_list|(
operator|*
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'x'
condition|)
block|{
name|b
operator|=
literal|16
expr_stmt|;
name|p
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|i
operator|=
operator|*
name|p
operator|-
literal|'0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
block|{
name|i
operator|=
operator|*
name|p
operator|-
literal|'a'
operator|+
literal|10
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; *** Bad char in numeric string..ignored\n"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
name|b
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"; *** Bad char in numeric string..ignored\n"
argument_list|)
expr_stmt|;
name|i
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|>=
literal|0
condition|)
name|v
operator|=
name|v
operator|*
name|b
operator|+
name|i
expr_stmt|;
name|p
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|v
operator|)
return|;
block|}
end_function

begin_comment
comment|/* this code was cloned from nslookup/list.c */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|_res_resultcodes
index|[]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* res_debug.c */
end_comment

begin_typedef
typedef|typedef
union|union
block|{
name|HEADER
name|qb1
decl_stmt|;
name|u_char
name|qb2
index|[
name|PACKETSZ
index|]
decl_stmt|;
block|}
name|querybuf
typedef|;
end_typedef

begin_function
specifier|static
name|int
name|printZone
parameter_list|(
name|zone
parameter_list|,
name|sin
parameter_list|)
name|char
modifier|*
name|zone
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
block|{
name|querybuf
name|buf
decl_stmt|;
name|HEADER
modifier|*
name|headerPtr
decl_stmt|;
name|int
name|msglen
decl_stmt|;
name|int
name|amtToRead
decl_stmt|;
name|int
name|numRead
decl_stmt|;
name|int
name|numAnswers
init|=
literal|0
decl_stmt|;
name|int
name|result
decl_stmt|;
name|int
name|soacnt
init|=
literal|0
decl_stmt|;
name|int
name|sockFD
decl_stmt|;
name|u_short
name|len
decl_stmt|;
name|u_char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|nmp
decl_stmt|;
name|char
name|dname
index|[
literal|2
index|]
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|file
index|[
name|NAME_LEN
index|]
decl_stmt|;
specifier|static
name|u_char
modifier|*
name|answer
init|=
name|NULL
decl_stmt|;
specifier|static
name|int
name|answerLen
init|=
literal|0
decl_stmt|;
enum|enum
block|{
name|NO_ERRORS
block|,
name|ERR_READING_LEN
block|,
name|ERR_READING_MSG
block|,
name|ERR_PRINTING
block|}
name|error
init|=
name|NO_ERRORS
enum|;
comment|/* 	 *  Create a query packet for the requested zone name. 	 */
name|msglen
operator|=
name|res_mkquery
argument_list|(
name|QUERY
argument_list|,
name|zone
argument_list|,
name|queryClass
argument_list|,
name|T_AXFR
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
name|buf
operator|.
name|qb2
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|msglen
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|_res
operator|.
name|options
operator|&
name|RES_DEBUG
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|";; res_mkquery failed\n"
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|ERROR
operator|)
return|;
block|}
comment|/* 	 *  Set up a virtual circuit to the server. 	 */
if|if
condition|(
operator|(
name|sockFD
operator|=
name|socket
argument_list|(
name|sin
operator|->
name|sin_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|";; socket"
argument_list|)
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
if|if
condition|(
name|connect
argument_list|(
name|sockFD
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
name|sin
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|sin
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|";; connect"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|e
return|;
block|}
comment|/* 	 * Send length& message for zone transfer 	 */
name|__putshort
argument_list|(
name|msglen
argument_list|,
operator|(
name|u_char
operator|*
operator|)
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|len
argument_list|,
name|INT16SZ
argument_list|)
operator|!=
name|INT16SZ
operator|||
name|write
argument_list|(
name|sockFD
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|buf
argument_list|,
name|msglen
argument_list|)
operator|!=
name|msglen
condition|)
block|{
name|int
name|e
init|=
name|errno
decl_stmt|;
name|perror
argument_list|(
literal|";; write"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|e
operator|)
return|;
block|}
name|dname
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|u_int16_t
name|tmp
decl_stmt|;
comment|/* 	     * Read the length of the response. 	     */
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tmp
expr_stmt|;
name|amtToRead
operator|=
name|INT16SZ
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_LEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|(
name|len
operator|=
name|_getshort
argument_list|(
operator|(
name|u_char
operator|*
operator|)
operator|&
name|tmp
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
break|break;
comment|/* nothing left to read */
block|}
comment|/* 	     * The server sent too much data to fit the existing buffer -- 	     * allocate a new one. 	     */
if|if
condition|(
name|len
operator|>
operator|(
name|u_int
operator|)
name|answerLen
condition|)
block|{
if|if
condition|(
name|answerLen
operator|!=
literal|0
condition|)
block|{
name|free
argument_list|(
name|answer
argument_list|)
expr_stmt|;
block|}
name|answerLen
operator|=
name|len
expr_stmt|;
name|answer
operator|=
operator|(
name|u_char
operator|*
operator|)
name|Malloc
argument_list|(
name|answerLen
argument_list|)
expr_stmt|;
block|}
comment|/* 	     * Read the response. 	     */
name|amtToRead
operator|=
name|len
expr_stmt|;
name|cp
operator|=
name|answer
expr_stmt|;
while|while
condition|(
name|amtToRead
operator|>
literal|0
operator|&&
operator|(
name|numRead
operator|=
name|read
argument_list|(
name|sockFD
argument_list|,
name|cp
argument_list|,
name|amtToRead
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|cp
operator|+=
name|numRead
expr_stmt|;
name|amtToRead
operator|-=
name|numRead
expr_stmt|;
block|}
if|if
condition|(
name|numRead
operator|<=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_READING_MSG
expr_stmt|;
break|break;
block|}
name|result
operator|=
name|printRR
argument_list|(
name|stdout
argument_list|,
name|answer
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
literal|0
condition|)
block|{
name|error
operator|=
name|ERR_PRINTING
expr_stmt|;
break|break;
block|}
name|numAnswers
operator|++
expr_stmt|;
name|cp
operator|=
name|answer
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|ntohs
argument_list|(
operator|(
operator|(
name|HEADER
operator|*
operator|)
name|answer
operator|)
operator|->
name|qdcount
argument_list|)
operator|>
literal|0
condition|)
name|cp
operator|+=
name|dn_skipname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|answer
operator|+
name|len
argument_list|)
operator|+
name|QFIXEDSZ
expr_stmt|;
name|nmp
operator|=
name|cp
expr_stmt|;
name|cp
operator|+=
name|dn_skipname
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|,
operator|(
name|u_char
operator|*
operator|)
name|answer
operator|+
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|_getshort
argument_list|(
operator|(
name|u_char
operator|*
operator|)
name|cp
argument_list|)
operator|==
name|T_SOA
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|dn_expand
argument_list|(
name|answer
argument_list|,
name|answer
operator|+
name|len
argument_list|,
name|nmp
argument_list|,
name|dname
index|[
name|soacnt
index|]
argument_list|,
sizeof|sizeof
name|dname
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|soacnt
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|dname
index|[
literal|0
index|]
argument_list|,
name|dname
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
break|break;
block|}
else|else
name|soacnt
operator|++
expr_stmt|;
block|}
block|}
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|";; Received %d record%s.\n"
argument_list|,
name|numAnswers
argument_list|,
operator|(
name|numAnswers
operator|!=
literal|1
operator|)
condition|?
literal|"s"
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|sockFD
argument_list|)
expr_stmt|;
name|sockFD
operator|=
operator|-
literal|1
expr_stmt|;
switch|switch
condition|(
name|error
condition|)
block|{
case|case
name|NO_ERRORS
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|ERR_READING_LEN
case|:
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
case|case
name|ERR_PRINTING
case|:
return|return
operator|(
name|result
operator|)
return|;
case|case
name|ERR_READING_MSG
case|:
return|return
operator|(
name|EMSGSIZE
operator|)
return|;
default|default:
return|return
operator|(
name|EFAULT
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|printRR
parameter_list|(
name|file
parameter_list|,
name|msg
parameter_list|,
name|eom
parameter_list|)
name|FILE
modifier|*
name|file
decl_stmt|;
name|u_char
modifier|*
name|msg
decl_stmt|,
decl|*
name|eom
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|u_char
modifier|*
name|cp
decl_stmt|;
name|HEADER
modifier|*
name|headerPtr
decl_stmt|;
name|int
name|type
decl_stmt|,
name|class
decl_stmt|,
name|dlen
decl_stmt|,
name|nameLen
decl_stmt|;
name|u_int32_t
name|ttl
decl_stmt|;
name|int
name|n
decl_stmt|,
name|pref
decl_stmt|;
name|struct
name|in_addr
name|inaddr
decl_stmt|;
name|char
name|name
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|char
name|name2
index|[
name|NAME_LEN
index|]
decl_stmt|;
name|Boolean
name|stripped
decl_stmt|;
comment|/*      * Read the header fields.      */
name|headerPtr
operator|=
operator|(
name|HEADER
operator|*
operator|)
name|msg
expr_stmt|;
name|cp
operator|=
name|msg
operator|+
name|HFIXEDSZ
expr_stmt|;
if|if
condition|(
name|headerPtr
operator|->
name|rcode
operator|!=
name|NOERROR
condition|)
block|{
return|return
operator|(
name|headerPtr
operator|->
name|rcode
operator|)
return|;
block|}
comment|/*      *  We are looking for info from answer resource records.      *  If there aren't any, return with an error. We assume      *  there aren't any question records.      */
if|if
condition|(
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|ancount
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
name|NO_INFO
operator|)
return|;
block|}
else|else
block|{
if|if
condition|(
name|ntohs
argument_list|(
name|headerPtr
operator|->
name|qdcount
argument_list|)
operator|>
literal|0
condition|)
block|{
name|nameLen
operator|=
name|dn_skipname
argument_list|(
name|cp
argument_list|,
name|eom
argument_list|)
expr_stmt|;
if|if
condition|(
name|nameLen
operator|<
literal|0
condition|)
return|return
operator|(
name|ERROR
operator|)
return|;
name|cp
operator|+=
name|nameLen
operator|+
name|QFIXEDSZ
expr_stmt|;
block|}
name|cp
operator|=
operator|(
name|u_char
operator|*
operator|)
name|p_rr
argument_list|(
name|cp
argument_list|,
name|msg
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|SUCCESS
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|struct
name|timeval
name|difftv
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|struct
name|timeval
name|a
decl_stmt|,
name|b
decl_stmt|;
block|{
specifier|static
name|struct
name|timeval
name|diff
decl_stmt|;
name|diff
operator|.
name|tv_sec
operator|=
name|b
operator|.
name|tv_sec
operator|-
name|a
operator|.
name|tv_sec
expr_stmt|;
if|if
condition|(
operator|(
name|diff
operator|.
name|tv_usec
operator|=
name|b
operator|.
name|tv_usec
operator|-
name|a
operator|.
name|tv_usec
operator|)
operator|<
literal|0
condition|)
block|{
name|diff
operator|.
name|tv_sec
operator|--
expr_stmt|;
name|diff
operator|.
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
return|return
operator|(
name|diff
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|prnttime
parameter_list|(
name|t
parameter_list|)
name|struct
name|timeval
name|t
decl_stmt|;
block|{
name|printf
argument_list|(
literal|"%u msec"
argument_list|,
name|t
operator|.
name|tv_sec
operator|*
literal|1000
operator|+
operator|(
name|t
operator|.
name|tv_usec
operator|/
literal|1000
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

