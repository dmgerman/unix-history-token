begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Cimarron D. Taylor of the University of California, Berkeley.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)function.c	8.10 (Berkeley) 5/4/95"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"find.h"
end_include

begin_define
define|#
directive|define
name|COMPARE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|{							\ 	switch (plan->flags) {						\ 	case F_EQUAL:							\ 		return (a == b);					\ 	case F_LESSTHAN:						\ 		return (a< b);						\ 	case F_GREATER:							\ 		return (a> b);						\ 	default:							\ 		abort();						\ 	}								\ }
end_define

begin_decl_stmt
specifier|static
name|PLAN
modifier|*
name|palloc
name|__P
argument_list|(
operator|(
expr|enum
name|ntype
operator|,
name|int
argument_list|(
argument|*
argument_list|)
name|__P
argument_list|(
operator|(
name|PLAN
operator|*
operator|,
name|FTSENT
operator|*
operator|)
argument_list|)
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * find_parsenum --  *	Parse a string of the form [+-]# and return the value.  */
end_comment

begin_function
specifier|static
name|long
name|long
name|find_parsenum
parameter_list|(
name|plan
parameter_list|,
name|option
parameter_list|,
name|vp
parameter_list|,
name|endch
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|char
modifier|*
name|option
decl_stmt|,
decl|*
name|vp
decl_stmt|,
modifier|*
name|endch
decl_stmt|;
end_function

begin_block
block|{
name|long
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|endchar
decl_stmt|,
modifier|*
name|str
decl_stmt|;
comment|/* Pointer to character ending conversion. */
comment|/* Determine comparison from leading + or -. */
name|str
operator|=
name|vp
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator|=
name|F_GREATER
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator|=
name|F_LESSTHAN
expr_stmt|;
break|break;
default|default:
name|plan
operator|->
name|flags
operator|=
name|F_EQUAL
expr_stmt|;
break|break;
block|}
comment|/* 	 * Convert the string with strtoq().  Note, if strtoq() returns zero 	 * and endchar points to the beginning of the string we know we have 	 * a syntax error. 	 */
name|value
operator|=
name|strtoq
argument_list|(
name|str
argument_list|,
operator|&
name|endchar
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
operator|&&
name|endchar
operator|==
name|str
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal numeric value"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endchar
index|[
literal|0
index|]
operator|&&
operator|(
name|endch
operator|==
name|NULL
operator|||
name|endchar
index|[
literal|0
index|]
operator|!=
operator|*
name|endch
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal trailing character"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endch
condition|)
operator|*
name|endch
operator|=
name|endchar
index|[
literal|0
index|]
expr_stmt|;
return|return
operator|(
name|value
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * The value of n for the inode times (atime, ctime, and mtime) is a range,  * i.e. n matches from (n - 1) to n 24 hour periods.  This interacts with  * -n, such that "-mtime -1" would be less than 0 days, which isn't what the  * user wanted.  Correct so that -1 is "less than 1".  */
end_comment

begin_define
define|#
directive|define
name|TIME_CORRECT
parameter_list|(
name|p
parameter_list|,
name|ttype
parameter_list|)
define|\
value|if ((p)->type == ttype&& (p)->flags == F_LESSTHAN)		\ 		++((p)->t_data);
end_define

begin_comment
comment|/*  * -amin n functions --  *  *	True if the difference between the file access time and the  *	current time is n min periods.  */
end_comment

begin_function
name|int
name|f_amin
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_atime
operator|+
literal|60
operator|-
literal|1
operator|)
operator|/
literal|60
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_amin
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_AMIN
argument_list|,
name|f_amin
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-amin"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIME_CORRECT
argument_list|(
name|new
argument_list|,
name|N_AMIN
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -atime n functions --  *  *	True if the difference between the file access time and the  *	current time is n 24 hour periods.  */
end_comment

begin_function
name|int
name|f_atime
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_atime
operator|+
literal|86400
operator|-
literal|1
operator|)
operator|/
literal|86400
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_atime
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_ATIME
argument_list|,
name|f_atime
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-atime"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIME_CORRECT
argument_list|(
name|new
argument_list|,
name|N_ATIME
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -cmin n functions --  *  *	True if the difference between the last change of file  *	status information and the current time is n min periods.  */
end_comment

begin_function
name|int
name|f_cmin
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_ctime
operator|+
literal|60
operator|-
literal|1
operator|)
operator|/
literal|60
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_cmin
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_CMIN
argument_list|,
name|f_cmin
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-cmin"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIME_CORRECT
argument_list|(
name|new
argument_list|,
name|N_CMIN
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -ctime n functions --  *  *	True if the difference between the last change of file  *	status information and the current time is n 24 hour periods.  */
end_comment

begin_function
name|int
name|f_ctime
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_ctime
operator|+
literal|86400
operator|-
literal|1
operator|)
operator|/
literal|86400
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_ctime
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_CTIME
argument_list|,
name|f_ctime
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-ctime"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIME_CORRECT
argument_list|(
name|new
argument_list|,
name|N_CTIME
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -depth functions --  *  *	Always true, causes descent of the directory hierarchy to be done  *	so that all entries in a directory are acted on before the directory  *	itself.  */
end_comment

begin_function
name|int
name|f_always_true
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_depth
parameter_list|()
block|{
name|isdepth
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_DEPTH
argument_list|,
name|f_always_true
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * [-exec | -ok] utility [arg ... ] ; functions --  *  *	True if the executed utility returns a zero value as exit status.  *	The end of the primary expression is delimited by a semicolon.  If  *	"{}" occurs anywhere, it gets replaced by the current pathname.  *	The current directory for the execution of utility is the same as  *	the current directory when the find utility was started.  *  *	The primary -ok is different in that it requests affirmation of the  *	user before executing the utility.  */
end_comment

begin_function
name|int
name|f_exec
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
specifier|register
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|int
name|dotfd
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
condition|)
name|brace_subst
argument_list|(
name|plan
operator|->
name|e_orig
index|[
name|cnt
index|]
argument_list|,
operator|&
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|,
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|==
name|F_NEEDOK
operator|&&
operator|!
name|queryuser
argument_list|(
name|plan
operator|->
name|e_argv
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
comment|/* make sure find output is interspersed correctly with subprocesses */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
if|if
condition|(
name|fchdir
argument_list|(
name|dotfd
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"chdir"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|execvp
argument_list|(
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|,
name|plan
operator|->
name|e_argv
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pid
operator|!=
operator|-
literal|1
operator|&&
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * c_exec --  *	build three parallel arrays, one with pointers to the strings passed  *	on the command line, one with (possibly duplicated) pointers to the  *	argv array, and one with integer values that are lengths of the  *	strings, but also flags meaning that the string has to be massaged.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_exec
parameter_list|(
name|argvp
parameter_list|,
name|isok
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
name|int
name|isok
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
comment|/* node returned */
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|isoutput
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_EXEC
argument_list|,
name|f_exec
argument_list|)
expr_stmt|;
if|if
condition|(
name|isok
condition|)
name|new
operator|->
name|flags
operator|=
name|F_NEEDOK
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argv
operator|=
operator|*
name|argvp
init|;
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|ap
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: no terminating \";\""
argument_list|,
name|isok
condition|?
literal|"-ok"
else|:
literal|"-exec"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|';'
condition|)
break|break;
block|}
name|cnt
operator|=
name|ap
operator|-
operator|*
name|argvp
operator|+
literal|1
expr_stmt|;
name|new
operator|->
name|e_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_orig
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_len
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|argv
operator|=
operator|*
name|argvp
operator|,
name|cnt
operator|=
literal|0
init|;
name|argv
operator|<
name|ap
condition|;
operator|++
name|argv
operator|,
operator|++
name|cnt
control|)
block|{
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argv
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'{'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
name|MAXPATHLEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argvp
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -execdir utility [arg ... ] ; functions --  *  *	True if the executed utility returns a zero value as exit status.  *	The end of the primary expression is delimited by a semicolon.  If  *	"{}" occurs anywhere, it gets replaced by the unqualified pathname.  *	The current directory for the execution of utility is the same as  *	the directory where the file lives.  */
end_comment

begin_function
name|int
name|f_execdir
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
specifier|register
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|int
name|dotfd
decl_stmt|;
specifier|register
name|int
name|cnt
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
comment|/* XXX - if file/dir ends in '/' this will not work -- can it? */
if|if
condition|(
operator|(
name|file
operator|=
name|strrchr
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|file
operator|++
expr_stmt|;
else|else
name|file
operator|=
name|entry
operator|->
name|fts_path
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
condition|)
name|brace_subst
argument_list|(
name|plan
operator|->
name|e_orig
index|[
name|cnt
index|]
argument_list|,
operator|&
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
argument_list|,
name|file
argument_list|,
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
comment|/* don't mix output of command with find output */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|vfork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
name|execvp
argument_list|(
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|,
name|plan
operator|->
name|e_argv
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pid
operator|!=
operator|-
literal|1
operator|&&
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * c_execdir --  *	build three parallel arrays, one with pointers to the strings passed  *	on the command line, one with (possibly duplicated) pointers to the  *	argv array, and one with integer values that are lengths of the  *	strings, but also flags meaning that the string has to be massaged.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_execdir
parameter_list|(
name|argvp
parameter_list|)
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
comment|/* node returned */
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|isoutput
operator|=
literal|1
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_EXECDIR
argument_list|,
name|f_execdir
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argv
operator|=
operator|*
name|argvp
init|;
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|ap
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-execdir: no terminating \";\""
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|';'
condition|)
break|break;
block|}
name|cnt
operator|=
name|ap
operator|-
operator|*
name|argvp
operator|+
literal|1
expr_stmt|;
name|new
operator|->
name|e_argv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_orig
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_len
operator|=
operator|(
name|int
operator|*
operator|)
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|argv
operator|=
operator|*
name|argvp
operator|,
name|cnt
operator|=
literal|0
init|;
name|argv
operator|<
name|ap
condition|;
operator|++
name|argv
operator|,
operator|++
name|cnt
control|)
block|{
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argv
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'{'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|emalloc
argument_list|(
operator|(
name|u_int
operator|)
name|MAXPATHLEN
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
name|MAXPATHLEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argvp
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -follow functions --  *  *	Always true, causes symbolic links to be followed on a global  *	basis.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_follow
parameter_list|()
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_PHYSICAL
expr_stmt|;
name|ftsoptions
operator||=
name|FTS_LOGICAL
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_FOLLOW
argument_list|,
name|f_always_true
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -fstype functions --  *  *	True if the file is of a certain type.  */
end_comment

begin_function
name|int
name|f_fstype
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|static
name|dev_t
name|curdev
decl_stmt|;
comment|/* need a guaranteed illegal dev value */
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
name|struct
name|statfs
name|sb
decl_stmt|;
specifier|static
name|int
name|val_type
decl_stmt|,
name|val_flags
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|save
index|[
literal|2
index|]
decl_stmt|;
comment|/* Only check when we cross mount point. */
if|if
condition|(
name|first
operator|||
name|curdev
operator|!=
name|entry
operator|->
name|fts_statp
operator|->
name|st_dev
condition|)
block|{
name|curdev
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_dev
expr_stmt|;
comment|/* 		 * Statfs follows symlinks; find wants the link's file system, 		 * not where it points. 		 */
if|if
condition|(
name|entry
operator|->
name|fts_info
operator|==
name|FTS_SL
operator|||
name|entry
operator|->
name|fts_info
operator|==
name|FTS_SLNONE
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|p
expr_stmt|;
else|else
name|p
operator|=
name|entry
operator|->
name|fts_accpath
expr_stmt|;
name|save
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|save
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|statfs
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|fts_accpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|save
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|save
index|[
literal|1
index|]
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Further tests may need both of these values, so 		 * always copy both of them. 		 */
name|val_flags
operator|=
name|sb
operator|.
name|f_flags
expr_stmt|;
name|val_type
operator|=
name|sb
operator|.
name|f_type
expr_stmt|;
block|}
switch|switch
condition|(
name|plan
operator|->
name|flags
condition|)
block|{
case|case
name|F_MTFLAG
case|:
return|return
operator|(
name|val_flags
operator|&
name|plan
operator|->
name|mt_data
operator|)
operator|!=
literal|0
return|;
case|case
name|F_MTTYPE
case|:
return|return
operator|(
name|val_type
operator|==
name|plan
operator|->
name|mt_data
operator|)
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_fstype
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
specifier|register
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|vfsconf
name|vfc
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_FSTYPE
argument_list|,
name|f_fstype
argument_list|)
expr_stmt|;
comment|/* 	 * Check first for a filesystem name. 	 */
if|if
condition|(
name|getvfsbyname
argument_list|(
name|arg
argument_list|,
operator|&
name|vfc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|F_MTTYPE
expr_stmt|;
name|new
operator|->
name|mt_data
operator|=
name|vfc
operator|.
name|vfc_typenum
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
switch|switch
condition|(
operator|*
name|arg
condition|)
block|{
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"local"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|F_MTFLAG
expr_stmt|;
name|new
operator|->
name|mt_data
operator|=
name|MNT_LOCAL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"rdonly"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|F_MTFLAG
expr_stmt|;
name|new
operator|->
name|mt_data
operator|=
name|MNT_RDONLY
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
break|break;
block|}
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: unknown file type"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * -group gname functions --  *  *	True if the file belongs to the group gname.  If gname is numeric and  *	an equivalent of the getgrnam() function does not return a valid group  *	name, gname is taken as a group ID.  */
end_comment

begin_function
name|int
name|f_group
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_gid
operator|==
name|plan
operator|->
name|g_data
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_group
parameter_list|(
name|gname
parameter_list|)
name|char
modifier|*
name|gname
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|group
modifier|*
name|g
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|g
operator|=
name|getgrnam
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
name|atoi
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|==
literal|0
operator|&&
name|gname
index|[
literal|0
index|]
operator|!=
literal|'0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-group: %s: no such group"
argument_list|,
name|gname
argument_list|)
expr_stmt|;
block|}
else|else
name|gid
operator|=
name|g
operator|->
name|gr_gid
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_GROUP
argument_list|,
name|f_group
argument_list|)
expr_stmt|;
name|new
operator|->
name|g_data
operator|=
name|gid
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -inum n functions --  *  *	True if the file has inode # n.  */
end_comment

begin_function
name|int
name|f_inum
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|COMPARE
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_ino
argument_list|,
name|plan
operator|->
name|i_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_inum
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_INUM
argument_list|,
name|f_inum
argument_list|)
expr_stmt|;
name|new
operator|->
name|i_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-inum"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -links n functions --  *  *	True if the file has n links.  */
end_comment

begin_function
name|int
name|f_links
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|COMPARE
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_nlink
argument_list|,
name|plan
operator|->
name|l_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_links
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_LINKS
argument_list|,
name|f_links
argument_list|)
expr_stmt|;
name|new
operator|->
name|l_data
operator|=
operator|(
name|nlink_t
operator|)
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-links"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -ls functions --  *  *	Always true - prints the current entry to stdout in "ls" format.  */
end_comment

begin_function
name|int
name|f_ls
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|printlong
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|,
name|entry
operator|->
name|fts_accpath
argument_list|,
name|entry
operator|->
name|fts_statp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_ls
parameter_list|()
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|isoutput
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_LS
argument_list|,
name|f_ls
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -mtime n functions --  *  *	True if the difference between the file modification time and the  *	current time is n 24 hour periods.  */
end_comment

begin_function
name|int
name|f_mtime
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_mtime
operator|+
literal|86400
operator|-
literal|1
operator|)
operator|/
literal|86400
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_mtime
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_MTIME
argument_list|,
name|f_mtime
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-mtime"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIME_CORRECT
argument_list|(
name|new
argument_list|,
name|N_MTIME
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -mmin n functions --  *  *	True if the difference between the file modification time and the  *	current time is n min periods.  */
end_comment

begin_function
name|int
name|f_mmin
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_mtime
operator|+
literal|60
operator|-
literal|1
operator|)
operator|/
literal|60
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_mmin
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_MMIN
argument_list|,
name|f_mmin
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-mmin"
argument_list|,
name|arg
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIME_CORRECT
argument_list|(
name|new
argument_list|,
name|N_MMIN
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -name functions --  *  *	True if the basename of the filename being examined  *	matches pattern using Pattern Matching Notation S3.14  */
end_comment

begin_function
name|int
name|f_name
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|fnmatch
argument_list|(
name|plan
operator|->
name|c_data
argument_list|,
name|entry
operator|->
name|fts_name
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_name
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_NAME
argument_list|,
name|f_name
argument_list|)
expr_stmt|;
name|new
operator|->
name|c_data
operator|=
name|pattern
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -newer file functions --  *  *	True if the current file has been modified more recently  *	then the modification time of the file named by the pathname  *	file.  */
end_comment

begin_function
name|int
name|f_newer
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_mtime
operator|>
name|plan
operator|->
name|t_data
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_newer
parameter_list|(
name|filename
parameter_list|)
name|char
modifier|*
name|filename
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
if|if
condition|(
name|stat
argument_list|(
name|filename
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_NEWER
argument_list|,
name|f_newer
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -nogroup functions --  *  *	True if file belongs to a user ID for which the equivalent  *	of the getgrnam() 9.2.1 [POSIX.1] function returns NULL.  */
end_comment

begin_function
name|int
name|f_nogroup
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|char
modifier|*
name|group_from_gid
parameter_list|()
function_decl|;
return|return
operator|(
name|group_from_gid
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_gid
argument_list|,
literal|1
argument_list|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_nogroup
parameter_list|()
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_NOGROUP
argument_list|,
name|f_nogroup
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -nouser functions --  *  *	True if file belongs to a user ID for which the equivalent  *	of the getpwuid() 9.2.2 [POSIX.1] function returns NULL.  */
end_comment

begin_function
name|int
name|f_nouser
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|char
modifier|*
name|user_from_uid
parameter_list|()
function_decl|;
return|return
operator|(
name|user_from_uid
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_uid
argument_list|,
literal|1
argument_list|)
condition|?
literal|0
else|:
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_nouser
parameter_list|()
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_NOUSER
argument_list|,
name|f_nouser
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -path functions --  *  *	True if the path of the filename being examined  *	matches pattern using Pattern Matching Notation S3.14  */
end_comment

begin_function
name|int
name|f_path
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
operator|!
name|fnmatch
argument_list|(
name|plan
operator|->
name|c_data
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|,
literal|0
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_path
parameter_list|(
name|pattern
parameter_list|)
name|char
modifier|*
name|pattern
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_NAME
argument_list|,
name|f_path
argument_list|)
expr_stmt|;
name|new
operator|->
name|c_data
operator|=
name|pattern
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -perm functions --  *  *	The mode argument is used to represent file mode bits.  If it starts  *	with a leading digit, it's treated as an octal mode, otherwise as a  *	symbolic mode.  */
end_comment

begin_function
name|int
name|f_perm
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISTXT
operator||
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
expr_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|==
name|F_ATLEAST
condition|)
return|return
operator|(
operator|(
name|plan
operator|->
name|m_data
operator||
name|mode
operator|)
operator|==
name|mode
operator|)
return|;
else|else
return|return
operator|(
name|mode
operator|==
name|plan
operator|->
name|m_data
operator|)
return|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_perm
parameter_list|(
name|perm
parameter_list|)
name|char
modifier|*
name|perm
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|mode_t
modifier|*
name|set
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_PERM
argument_list|,
name|f_perm
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|perm
operator|==
literal|'-'
condition|)
block|{
name|new
operator|->
name|flags
operator|=
name|F_ATLEAST
expr_stmt|;
operator|++
name|perm
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|set
operator|=
name|setmode
argument_list|(
name|perm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"-perm: %s: illegal mode string"
argument_list|,
name|perm
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_data
operator|=
name|getmode
argument_list|(
name|set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -print functions --  *  *	Always true, causes the current pathame to be written to  *	standard output.  */
end_comment

begin_function
name|int
name|f_print
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_print
parameter_list|()
block|{
name|isoutput
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_PRINT
argument_list|,
name|f_print
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -print0 functions --  *  *	Always true, causes the current pathame to be written to  *	standard output followed by a NUL character  */
end_comment

begin_function
name|int
name|f_print0
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|fputs
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_print0
parameter_list|()
block|{
name|isoutput
operator|=
literal|1
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_PRINT0
argument_list|,
name|f_print0
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -prune functions --  *  *	Prune a portion of the hierarchy.  */
end_comment

begin_function
name|int
name|f_prune
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|FTS
modifier|*
name|tree
decl_stmt|;
if|if
condition|(
name|fts_set
argument_list|(
name|tree
argument_list|,
name|entry
argument_list|,
name|FTS_SKIP
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_prune
parameter_list|()
block|{
return|return
operator|(
name|palloc
argument_list|(
name|N_PRUNE
argument_list|,
name|f_prune
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -size n[c] functions --  *  *	True if the file size in bytes, divided by an implementation defined  *	value and rounded up to the next integer, is n.  If n is followed by  *	a c, the size is in bytes.  */
end_comment

begin_define
define|#
directive|define
name|FIND_SIZE
value|512
end_define

begin_decl_stmt
specifier|static
name|int
name|divsize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|f_size
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|off_t
name|size
decl_stmt|;
name|size
operator|=
name|divsize
condition|?
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_size
operator|+
name|FIND_SIZE
operator|-
literal|1
operator|)
operator|/
name|FIND_SIZE
else|:
name|entry
operator|->
name|fts_statp
operator|->
name|st_size
expr_stmt|;
name|COMPARE
argument_list|(
name|size
argument_list|,
name|plan
operator|->
name|o_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_size
parameter_list|(
name|arg
parameter_list|)
name|char
modifier|*
name|arg
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|char
name|endch
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_SIZE
argument_list|,
name|f_size
argument_list|)
expr_stmt|;
name|endch
operator|=
literal|'c'
expr_stmt|;
name|new
operator|->
name|o_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
literal|"-size"
argument_list|,
name|arg
argument_list|,
operator|&
name|endch
argument_list|)
expr_stmt|;
if|if
condition|(
name|endch
operator|==
literal|'c'
condition|)
name|divsize
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -type c functions --  *  *	True if the type of the file is c, where c is b, c, d, p, f or w  *	for block special file, character special file, directory, FIFO,  *	regular file or whiteout respectively.  */
end_comment

begin_function
name|int
name|f_type
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|plan
operator|->
name|m_data
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_type
parameter_list|(
name|typestring
parameter_list|)
name|char
modifier|*
name|typestring
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|mode_t
name|mask
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
switch|switch
condition|(
name|typestring
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|mask
operator|=
name|S_IFBLK
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|mask
operator|=
name|S_IFCHR
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mask
operator|=
name|S_IFDIR
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|mask
operator|=
name|S_IFREG
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|mask
operator|=
name|S_IFLNK
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|mask
operator|=
name|S_IFIFO
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mask
operator|=
name|S_IFSOCK
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FTS_WHITEOUT
case|case
literal|'w'
case|:
name|mask
operator|=
name|S_IFWHT
expr_stmt|;
name|ftsoptions
operator||=
name|FTS_WHITEOUT
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FTS_WHITEOUT */
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-type: %s: unknown type"
argument_list|,
name|typestring
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|palloc
argument_list|(
name|N_TYPE
argument_list|,
name|f_type
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_data
operator|=
name|mask
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -delete functions --  *  *	True always.  Makes it's best shot and continues on regardless.  */
end_comment

begin_function
name|int
name|f_delete
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
comment|/* ignore these from fts */
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* sanity check */
if|if
condition|(
name|isdepth
operator|==
literal|0
operator|||
comment|/* depth off */
operator|(
name|ftsoptions
operator|&
name|FTS_NOSTAT
operator|)
operator|||
comment|/* not stat()ing */
operator|!
operator|(
name|ftsoptions
operator|&
name|FTS_PHYSICAL
operator|)
operator|||
comment|/* physical off */
operator|(
name|ftsoptions
operator|&
name|FTS_LOGICAL
operator|)
condition|)
comment|/* or finally, logical on */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-delete: insecure options got turned on"
argument_list|)
expr_stmt|;
comment|/* Potentially unsafe - do not accept relative paths whatsoever */
if|if
condition|(
name|strchr
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-delete: %s: relative path potentially not safe"
argument_list|,
name|entry
operator|->
name|fts_accpath
argument_list|)
expr_stmt|;
comment|/* Turn off user immutable bits if running as root */
if|if
condition|(
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_flags
operator|&
operator|(
name|UF_APPEND
operator||
name|UF_IMMUTABLE
operator|)
operator|)
operator|&&
operator|!
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_flags
operator|&
operator|(
name|SF_APPEND
operator||
name|SF_IMMUTABLE
operator|)
operator|)
operator|&&
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
name|chflags
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
name|entry
operator|->
name|fts_statp
operator|->
name|st_flags
operator|&=
operator|~
operator|(
name|UF_APPEND
operator||
name|UF_IMMUTABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* rmdir directories, unlink everything else */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|rmdir
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOTEMPTY
condition|)
name|warn
argument_list|(
literal|"-delete: rmdir(%s)"
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unlink
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"-delete: unlink(%s)"
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
block|}
comment|/* "succeed" */
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_delete
parameter_list|()
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
comment|/* no optimise */
name|ftsoptions
operator||=
name|FTS_PHYSICAL
expr_stmt|;
comment|/* disable -follow */
name|ftsoptions
operator|&=
operator|~
name|FTS_LOGICAL
expr_stmt|;
comment|/* disable -follow */
name|isoutput
operator|=
literal|1
expr_stmt|;
comment|/* possible output */
name|isdepth
operator|=
literal|1
expr_stmt|;
comment|/* -depth implied */
return|return
operator|(
name|palloc
argument_list|(
name|N_DELETE
argument_list|,
name|f_delete
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -user uname functions --  *  *	True if the file belongs to the user uname.  If uname is numeric and  *	an equivalent of the getpwnam() S9.2.2 [POSIX.1] function does not  *	return a valid user name, uname is taken as a user ID.  */
end_comment

begin_function
name|int
name|f_user
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_uid
operator|==
name|plan
operator|->
name|u_data
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_user
parameter_list|(
name|username
parameter_list|)
name|char
modifier|*
name|username
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|p
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|uid
operator|=
name|atoi
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
operator|&&
name|username
index|[
literal|0
index|]
operator|!=
literal|'0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-user: %s: no such user"
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
else|else
name|uid
operator|=
name|p
operator|->
name|pw_uid
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|N_USER
argument_list|,
name|f_user
argument_list|)
expr_stmt|;
name|new
operator|->
name|u_data
operator|=
name|uid
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * -xdev functions --  *  *	Always true, causes find not to decend past directories that have a  *	different device ID (st_dev, see stat() S5.6.2 [POSIX.1])  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_xdev
parameter_list|()
block|{
name|ftsoptions
operator||=
name|FTS_XDEV
expr_stmt|;
return|return
operator|(
name|palloc
argument_list|(
name|N_XDEV
argument_list|,
name|f_always_true
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ( expression ) functions --  *  *	True if expression is true.  */
end_comment

begin_function
name|int
name|f_expr
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|PLAN
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * N_OPENPAREN and N_CLOSEPAREN nodes are temporary place markers.  They are  * eliminated during phase 2 of find_formplan() --- the '(' node is converted  * to a N_EXPR node containing the expression and the ')' node is discarded.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_openparen
parameter_list|()
block|{
return|return
operator|(
name|palloc
argument_list|(
name|N_OPENPAREN
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_closeparen
parameter_list|()
block|{
return|return
operator|(
name|palloc
argument_list|(
name|N_CLOSEPAREN
argument_list|,
operator|(
name|int
argument_list|(
operator|*
argument_list|)
argument_list|()
operator|)
operator|-
literal|1
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * ! expression functions --  *  *	Negation of a primary; the unary NOT operator.  */
end_comment

begin_function
name|int
name|f_not
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|PLAN
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
operator|(
operator|!
name|state
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_not
parameter_list|()
block|{
return|return
operator|(
name|palloc
argument_list|(
name|N_NOT
argument_list|,
name|f_not
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * expression -o expression functions --  *  *	Alternation of primaries; the OR operator.  The second expression is  * not evaluated if the first expression is true.  */
end_comment

begin_function
name|int
name|f_or
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|register
name|PLAN
modifier|*
name|p
decl_stmt|;
specifier|register
name|int
name|state
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|state
condition|)
return|return
operator|(
literal|1
operator|)
return|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|1
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|eval
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
operator|(
name|state
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_or
parameter_list|()
block|{
return|return
operator|(
name|palloc
argument_list|(
name|N_OR
argument_list|,
name|f_or
argument_list|)
operator|)
return|;
block|}
end_function

begin_function_decl
specifier|static
name|PLAN
modifier|*
name|palloc
parameter_list|(
name|t
parameter_list|,
name|f
parameter_list|)
name|enum
name|ntype
name|t
decl_stmt|;
function_decl|int
parameter_list|(
function_decl|*f
end_function_decl

begin_expr_stmt
unit|)
name|__P
argument_list|(
operator|(
name|PLAN
operator|*
operator|,
name|FTSENT
operator|*
operator|)
argument_list|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PLAN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|type
operator|=
name|t
expr_stmt|;
name|new
operator|->
name|eval
operator|=
name|f
expr_stmt|;
name|new
operator|->
name|flags
operator|=
literal|0
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
name|new
operator|)
return|;
block|}
end_block

end_unit

