begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Cimarron D. Taylor of the University of California, Berkeley.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_else
unit|static const char sccsid[] = "@(#)function.c	8.10 (Berkeley) 5/4/95";
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/ucred.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/mount.h>
end_include

begin_include
include|#
directive|include
file|<sys/timeb.h>
end_include

begin_include
include|#
directive|include
file|<dirent.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fnmatch.h>
end_include

begin_include
include|#
directive|include
file|<fts.h>
end_include

begin_include
include|#
directive|include
file|<grp.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"find.h"
end_include

begin_function_decl
specifier|static
name|PLAN
modifier|*
name|palloc
parameter_list|(
name|OPTION
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|long
name|find_parsenum
parameter_list|(
name|PLAN
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|long
name|long
name|find_parsetime
parameter_list|(
name|PLAN
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|nextarg
parameter_list|(
name|OPTION
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|COMPARE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do {						\ 	switch (plan->flags& F_ELG_MASK) {				\ 	case F_EQUAL:							\ 		return (a == b);					\ 	case F_LESSTHAN:						\ 		return (a< b);						\ 	case F_GREATER:							\ 		return (a> b);						\ 	default:							\ 		abort();						\ 	}								\ } while(0)
end_define

begin_function
specifier|static
name|PLAN
modifier|*
name|palloc
parameter_list|(
name|option
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|PLAN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|execute
operator|=
name|option
operator|->
name|execute
expr_stmt|;
name|new
operator|->
name|flags
operator|=
name|option
operator|->
name|flags
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * find_parsenum --  *	Parse a string of the form [+-]# and return the value.  */
end_comment

begin_function
specifier|static
name|long
name|long
name|find_parsenum
parameter_list|(
name|plan
parameter_list|,
name|option
parameter_list|,
name|vp
parameter_list|,
name|endch
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|,
decl|*
name|endch
decl_stmt|;
end_function

begin_block
block|{
name|long
name|long
name|value
decl_stmt|;
name|char
modifier|*
name|endchar
decl_stmt|,
modifier|*
name|str
decl_stmt|;
comment|/* Pointer to character ending conversion. */
comment|/* Determine comparison from leading + or -. */
name|str
operator|=
name|vp
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator||=
name|F_GREATER
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator||=
name|F_LESSTHAN
expr_stmt|;
break|break;
default|default:
name|plan
operator|->
name|flags
operator||=
name|F_EQUAL
expr_stmt|;
break|break;
block|}
comment|/* 	 * Convert the string with strtoq().  Note, if strtoq() returns zero 	 * and endchar points to the beginning of the string we know we have 	 * a syntax error. 	 */
name|value
operator|=
name|strtoq
argument_list|(
name|str
argument_list|,
operator|&
name|endchar
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
operator|&&
name|endchar
operator|==
name|str
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal numeric value"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endchar
index|[
literal|0
index|]
operator|&&
operator|(
name|endch
operator|==
name|NULL
operator|||
name|endchar
index|[
literal|0
index|]
operator|!=
operator|*
name|endch
operator|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal trailing character"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|)
expr_stmt|;
if|if
condition|(
name|endch
condition|)
operator|*
name|endch
operator|=
name|endchar
index|[
literal|0
index|]
expr_stmt|;
return|return
name|value
return|;
block|}
end_block

begin_comment
comment|/*  * find_parsetime --  *	Parse a string of the form [+-]([0-9]+[smhdw]?)+ and return the value.  */
end_comment

begin_function
specifier|static
name|long
name|long
name|find_parsetime
parameter_list|(
name|plan
parameter_list|,
name|option
parameter_list|,
name|vp
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
specifier|const
name|char
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
name|vp
decl_stmt|;
block|{
name|long
name|long
name|secs
decl_stmt|,
name|value
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|,
modifier|*
name|unit
decl_stmt|;
comment|/* Pointer to character ending conversion. */
comment|/* Determine comparison from leading + or -. */
name|str
operator|=
name|vp
expr_stmt|;
switch|switch
condition|(
operator|*
name|str
condition|)
block|{
case|case
literal|'+'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator||=
name|F_GREATER
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
operator|++
name|str
expr_stmt|;
name|plan
operator|->
name|flags
operator||=
name|F_LESSTHAN
expr_stmt|;
break|break;
default|default:
name|plan
operator|->
name|flags
operator||=
name|F_EQUAL
expr_stmt|;
break|break;
block|}
name|value
operator|=
name|strtoq
argument_list|(
name|str
argument_list|,
operator|&
name|unit
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
operator|&&
name|unit
operator|==
name|str
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal time value"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|*
name|unit
operator|==
literal|'\0'
condition|)
return|return
name|value
return|;
comment|/* Units syntax. */
name|secs
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
operator|*
name|unit
condition|)
block|{
case|case
literal|'s'
case|:
comment|/* seconds */
name|secs
operator|+=
name|value
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* minutes */
name|secs
operator|+=
name|value
operator|*
literal|60
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
comment|/* hours */
name|secs
operator|+=
name|value
operator|*
literal|3600
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* days */
name|secs
operator|+=
name|value
operator|*
literal|86400
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
comment|/* weeks */
name|secs
operator|+=
name|value
operator|*
literal|604800
expr_stmt|;
break|break;
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: bad unit '%c'"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|,
operator|*
name|unit
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|str
operator|=
name|unit
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|str
operator|==
literal|'\0'
condition|)
comment|/* EOS */
break|break;
name|value
operator|=
name|strtoq
argument_list|(
name|str
argument_list|,
operator|&
name|unit
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|value
operator|==
literal|0
operator|&&
name|unit
operator|==
name|str
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal time value"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
operator|*
name|unit
operator|==
literal|'\0'
condition|)
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: missing trailing unit"
argument_list|,
name|option
argument_list|,
name|vp
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|plan
operator|->
name|flags
operator||=
name|F_EXACTTIME
expr_stmt|;
return|return
name|secs
return|;
block|}
end_function

begin_comment
comment|/*  * nextarg --  *	Check that another argument still exists, return a pointer to it,  *	and increment the argument vector pointer.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|nextarg
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|arg
decl_stmt|;
if|if
condition|(
operator|(
name|arg
operator|=
operator|*
operator|*
name|argvp
operator|)
operator|==
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: requires additional arguments"
argument_list|,
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
operator|(
operator|*
name|argvp
operator|)
operator|++
expr_stmt|;
return|return
name|arg
return|;
block|}
end_function

begin_comment
comment|/* nextarg() */
end_comment

begin_comment
comment|/*  * The value of n for the inode times (atime, ctime, and mtime) is a range,  * i.e. n matches from (n - 1) to n 24 hour periods.  This interacts with  * -n, such that "-mtime -1" would be less than 0 days, which isn't what the  * user wanted.  Correct so that -1 is "less than 1".  */
end_comment

begin_define
define|#
directive|define
name|TIME_CORRECT
parameter_list|(
name|p
parameter_list|)
define|\
value|if (((p)->flags& F_ELG_MASK) == F_LESSTHAN) \ 		++((p)->t_data);
end_define

begin_comment
comment|/*  * -[acm]min n functions --  *  *    True if the difference between the  *		file access time (-amin)  *		last change of file status information (-cmin)  *		file modification time (-mmin)  *    and the current time is n min periods.  */
end_comment

begin_function
name|int
name|f_Xmin
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_TIME_C
condition|)
block|{
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_ctime
operator|+
literal|60
operator|-
literal|1
operator|)
operator|/
literal|60
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_TIME_A
condition|)
block|{
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_atime
operator|+
literal|60
operator|-
literal|1
operator|)
operator|/
literal|60
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|entry
operator|->
name|fts_statp
operator|->
name|st_mtime
operator|+
literal|60
operator|-
literal|1
operator|)
operator|/
literal|60
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_Xmin
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|nmins
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|nmins
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|nmins
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|TIME_CORRECT
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -[acm]time n functions --  *  *	True if the difference between the  *		file access time (-atime)  *		last change of file status information (-ctime)  *		file modification time (-mtime)  *	and the current time is n 24 hour periods.  */
end_comment

begin_function
name|int
name|f_Xtime
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|time_t
name|now
decl_stmt|;
name|time_t
name|xtime
decl_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_TIME_A
condition|)
name|xtime
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_atime
expr_stmt|;
elseif|else
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_TIME_C
condition|)
name|xtime
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_ctime
expr_stmt|;
else|else
name|xtime
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_mtime
expr_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_EXACTTIME
condition|)
name|COMPARE
argument_list|(
name|now
operator|-
name|xtime
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
else|else
name|COMPARE
argument_list|(
operator|(
name|now
operator|-
name|xtime
operator|+
literal|86400
operator|-
literal|1
operator|)
operator|/
literal|86400
argument_list|,
name|plan
operator|->
name|t_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_Xtime
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|value
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|value
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|t_data
operator|=
name|find_parsetime
argument_list|(
name|new
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|(
name|new
operator|->
name|flags
operator|&
name|F_EXACTTIME
operator|)
condition|)
name|TIME_CORRECT
argument_list|(
name|new
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -maxdepth/-mindepth n functions --  *  *        Does the same as -prune if the level of the current file is  *        greater/less than the specified maximum/minimum depth.  *  *        Note that -maxdepth and -mindepth are handled specially in  *        find_execute() so their f_* functions are set to f_always_true().  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_mXXdepth
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|dstr
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|dstr
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
if|if
condition|(
name|dstr
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
comment|/* all other errors handled by find_parsenum() */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: value must be positive"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|dstr
argument_list|)
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|F_MAXDEPTH
condition|)
name|maxdepth
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|dstr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
else|else
name|mindepth
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|dstr
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -delete functions --  *  *	True always.  Makes its best shot and continues on regardless.  */
end_comment

begin_function
name|int
name|f_delete
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
comment|/* ignore these from fts */
if|if
condition|(
name|strcmp
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|"."
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|".."
argument_list|)
operator|==
literal|0
condition|)
return|return
literal|1
return|;
comment|/* sanity check */
if|if
condition|(
name|isdepth
operator|==
literal|0
operator|||
comment|/* depth off */
operator|(
name|ftsoptions
operator|&
name|FTS_NOSTAT
operator|)
operator|||
comment|/* not stat()ing */
operator|!
operator|(
name|ftsoptions
operator|&
name|FTS_PHYSICAL
operator|)
operator|||
comment|/* physical off */
operator|(
name|ftsoptions
operator|&
name|FTS_LOGICAL
operator|)
condition|)
comment|/* or finally, logical on */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-delete: insecure options got turned on"
argument_list|)
expr_stmt|;
comment|/* Potentially unsafe - do not accept relative paths whatsoever */
if|if
condition|(
name|strchr
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|'/'
argument_list|)
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"-delete: %s: relative path potentially not safe"
argument_list|,
name|entry
operator|->
name|fts_accpath
argument_list|)
expr_stmt|;
comment|/* Turn off user immutable bits if running as root */
if|if
condition|(
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_flags
operator|&
operator|(
name|UF_APPEND
operator||
name|UF_IMMUTABLE
operator|)
operator|)
operator|&&
operator|!
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_flags
operator|&
operator|(
name|SF_APPEND
operator||
name|SF_IMMUTABLE
operator|)
operator|)
operator|&&
name|geteuid
argument_list|()
operator|==
literal|0
condition|)
name|chflags
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
name|entry
operator|->
name|fts_statp
operator|->
name|st_flags
operator|&=
operator|~
operator|(
name|UF_APPEND
operator||
name|UF_IMMUTABLE
operator|)
argument_list|)
expr_stmt|;
comment|/* rmdir directories, unlink everything else */
if|if
condition|(
name|S_ISDIR
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
argument_list|)
condition|)
block|{
if|if
condition|(
name|rmdir
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOTEMPTY
condition|)
name|warn
argument_list|(
literal|"-delete: rmdir(%s)"
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|unlink
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|)
operator|<
literal|0
condition|)
name|warn
argument_list|(
literal|"-delete: unlink(%s)"
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
block|}
comment|/* "succeed" */
return|return
literal|1
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_delete
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
comment|/* no optimise */
name|ftsoptions
operator||=
name|FTS_PHYSICAL
expr_stmt|;
comment|/* disable -follow */
name|ftsoptions
operator|&=
operator|~
name|FTS_LOGICAL
expr_stmt|;
comment|/* disable -follow */
name|isoutput
operator|=
literal|1
expr_stmt|;
comment|/* possible output */
name|isdepth
operator|=
literal|1
expr_stmt|;
comment|/* -depth implied */
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -depth functions --  *  *	Always true, causes descent of the directory hierarchy to be done  *	so that all entries in a directory are acted on before the directory  *	itself.  */
end_comment

begin_function
name|int
name|f_always_true
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
name|__unused
decl_stmt|;
block|{
return|return
literal|1
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_depth
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|isdepth
operator|=
literal|1
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -empty functions --  *  *	True if the file or directory is empty  */
end_comment

begin_function
name|int
name|f_empty
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|S_ISREG
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
argument_list|)
operator|&&
name|entry
operator|->
name|fts_statp
operator|->
name|st_size
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|S_ISDIR
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
argument_list|)
condition|)
block|{
name|struct
name|dirent
modifier|*
name|dp
decl_stmt|;
name|int
name|empty
decl_stmt|;
name|DIR
modifier|*
name|dir
decl_stmt|;
name|empty
operator|=
literal|1
expr_stmt|;
name|dir
operator|=
name|opendir
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|fts_accpath
argument_list|)
expr_stmt|;
for|for
control|(
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
init|;
name|dp
condition|;
name|dp
operator|=
name|readdir
argument_list|(
name|dir
argument_list|)
control|)
if|if
condition|(
name|dp
operator|->
name|d_name
index|[
literal|0
index|]
operator|!=
literal|'.'
operator|||
operator|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'\0'
operator|&&
operator|(
name|dp
operator|->
name|d_name
index|[
literal|1
index|]
operator|!=
literal|'.'
operator|||
name|dp
operator|->
name|d_name
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|)
operator|)
condition|)
block|{
name|empty
operator|=
literal|0
expr_stmt|;
break|break;
block|}
name|closedir
argument_list|(
name|dir
argument_list|)
expr_stmt|;
return|return
name|empty
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_empty
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * [-exec | -execdir | -ok] utility [arg ... ] ; functions --  *  *	True if the executed utility returns a zero value as exit status.  *	The end of the primary expression is delimited by a semicolon.  If  *	"{}" occurs anywhere, it gets replaced by the current pathname,  *	or, in the case of -execdir, the current basename (filename  *	without leading directory prefix). For -exec and -ok,  *	the current directory for the execution of utility is the same as  *	the current directory when the find utility was started, whereas  *	for -execdir, it is the directory the file resides in.  *  *	The primary -ok differs from -exec in that it requests affirmation  *	of the user before executing the utility.  */
end_comment

begin_function
name|int
name|f_exec
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|int
name|dotfd
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|pid_t
name|pid
decl_stmt|;
name|int
name|status
decl_stmt|;
name|char
modifier|*
name|file
decl_stmt|;
comment|/* XXX - if file/dir ends in '/' this will not work -- can it? */
if|if
condition|(
operator|(
name|plan
operator|->
name|flags
operator|&
name|F_EXECDIR
operator|)
operator|&&
expr|\
operator|(
name|file
operator|=
name|strrchr
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|file
operator|++
expr_stmt|;
else|else
name|file
operator|=
name|entry
operator|->
name|fts_path
expr_stmt|;
for|for
control|(
name|cnt
operator|=
literal|0
init|;
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
condition|;
operator|++
name|cnt
control|)
if|if
condition|(
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
condition|)
name|brace_subst
argument_list|(
name|plan
operator|->
name|e_orig
index|[
name|cnt
index|]
argument_list|,
operator|&
name|plan
operator|->
name|e_argv
index|[
name|cnt
index|]
argument_list|,
name|file
argument_list|,
name|plan
operator|->
name|e_len
index|[
name|cnt
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|plan
operator|->
name|flags
operator|&
name|F_NEEDOK
operator|)
operator|&&
operator|!
name|queryuser
argument_list|(
name|plan
operator|->
name|e_argv
argument_list|)
condition|)
return|return
literal|0
return|;
comment|/* make sure find output is interspersed correctly with subprocesses */
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|pid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
case|case
literal|0
case|:
comment|/* change dir back from where we started */
if|if
condition|(
operator|!
operator|(
name|plan
operator|->
name|flags
operator|&
name|F_EXECDIR
operator|)
operator|&&
name|fchdir
argument_list|(
name|dotfd
argument_list|)
condition|)
block|{
name|warn
argument_list|(
literal|"chdir"
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|execvp
argument_list|(
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|,
name|plan
operator|->
name|e_argv
argument_list|)
expr_stmt|;
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|plan
operator|->
name|e_argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|_exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|pid
operator|=
name|waitpid
argument_list|(
name|pid
argument_list|,
operator|&
name|status
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|pid
operator|!=
operator|-
literal|1
operator|&&
name|WIFEXITED
argument_list|(
name|status
argument_list|)
operator|&&
operator|!
name|WEXITSTATUS
argument_list|(
name|status
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * c_exec, c_execdir, c_ok --  *	build three parallel arrays, one with pointers to the strings passed  *	on the command line, one with (possibly duplicated) pointers to the  *	argv array, and one with integer values that are lengths of the  *	strings, but also flags meaning that the string has to be massaged.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_exec
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
comment|/* node returned */
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|,
modifier|*
modifier|*
name|ap
decl_stmt|,
modifier|*
name|p
decl_stmt|;
comment|/* XXX - was in c_execdir, but seems unnecessary!? 	ftsoptions&= ~FTS_NOSTAT; 	*/
name|isoutput
operator|=
literal|1
expr_stmt|;
comment|/* XXX - this is a change from the previous coding */
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
for|for
control|(
name|ap
operator|=
name|argv
operator|=
operator|*
name|argvp
init|;
condition|;
operator|++
name|ap
control|)
block|{
if|if
condition|(
operator|!
operator|*
name|ap
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: no terminating \";\""
argument_list|,
name|option
operator|->
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ap
operator|==
literal|';'
condition|)
break|break;
block|}
name|cnt
operator|=
name|ap
operator|-
operator|*
name|argvp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|->
name|e_argv
operator|=
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|->
name|e_orig
operator|=
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|->
name|e_len
operator|=
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|cnt
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|argv
operator|=
operator|*
name|argvp
operator|,
name|cnt
operator|=
literal|0
init|;
name|argv
operator|<
name|ap
condition|;
operator|++
name|argv
operator|,
operator|++
name|cnt
control|)
block|{
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
for|for
control|(
name|p
operator|=
operator|*
name|argv
init|;
operator|*
name|p
condition|;
operator|++
name|p
control|)
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'{'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
literal|'}'
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|malloc
argument_list|(
operator|(
name|u_int
operator|)
name|MAXPATHLEN
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
name|MAXPATHLEN
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|!
operator|*
name|p
condition|)
block|{
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
operator|*
name|argv
expr_stmt|;
name|new
operator|->
name|e_len
index|[
name|cnt
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
name|new
operator|->
name|e_argv
index|[
name|cnt
index|]
operator|=
name|new
operator|->
name|e_orig
index|[
name|cnt
index|]
operator|=
name|NULL
expr_stmt|;
operator|*
name|argvp
operator|=
name|argv
operator|+
literal|1
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_function
name|int
name|f_flags
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|u_long
name|flags
decl_stmt|;
name|flags
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_flags
expr_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_ATLEAST
condition|)
return|return
operator|(
name|flags
operator||
name|plan
operator|->
name|fl_flags
operator|)
operator|==
name|flags
operator|&&
operator|!
operator|(
name|flags
operator|&
name|plan
operator|->
name|fl_notflags
operator|)
return|;
elseif|else
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_ANY
condition|)
return|return
operator|(
name|flags
operator|&
name|plan
operator|->
name|fl_flags
operator|)
operator|||
operator|(
name|flags
operator||
name|plan
operator|->
name|fl_notflags
operator|)
operator|!=
name|flags
return|;
else|else
return|return
name|flags
operator|==
name|plan
operator|->
name|fl_flags
operator|&&
operator|!
operator|(
name|plan
operator|->
name|fl_flags
operator|&
name|plan
operator|->
name|fl_notflags
operator|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_flags
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|flags_str
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|u_long
name|flags
decl_stmt|,
name|notflags
decl_stmt|;
name|flags_str
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|flags_str
operator|==
literal|'-'
condition|)
block|{
name|new
operator|->
name|flags
operator||=
name|F_ATLEAST
expr_stmt|;
name|flags_str
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|flags_str
operator|==
literal|'+'
condition|)
block|{
name|new
operator|->
name|flags
operator||=
name|F_ANY
expr_stmt|;
name|flags_str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|strtofflags
argument_list|(
operator|&
name|flags_str
argument_list|,
operator|&
name|flags
argument_list|,
operator|&
name|notflags
argument_list|)
operator|==
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal flags string"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|flags_str
argument_list|)
expr_stmt|;
name|new
operator|->
name|fl_flags
operator|=
name|flags
expr_stmt|;
name|new
operator|->
name|fl_notflags
operator|=
name|notflags
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -follow functions --  *  *	Always true, causes symbolic links to be followed on a global  *	basis.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_follow
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_PHYSICAL
expr_stmt|;
name|ftsoptions
operator||=
name|FTS_LOGICAL
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -fstype functions --  *  *	True if the file is of a certain type.  */
end_comment

begin_function
name|int
name|f_fstype
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|static
name|dev_t
name|curdev
decl_stmt|;
comment|/* need a guaranteed illegal dev value */
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
name|struct
name|statfs
name|sb
decl_stmt|;
specifier|static
name|int
name|val_type
decl_stmt|,
name|val_flags
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|,
name|save
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|plan
operator|->
name|flags
operator|&
name|F_MTMASK
operator|)
operator|==
name|F_MTUNKNOWN
condition|)
return|return
literal|0
return|;
comment|/* Only check when we cross mount point. */
if|if
condition|(
name|first
operator|||
name|curdev
operator|!=
name|entry
operator|->
name|fts_statp
operator|->
name|st_dev
condition|)
block|{
name|curdev
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_dev
expr_stmt|;
comment|/* 		 * Statfs follows symlinks; find wants the link's file system, 		 * not where it points. 		 */
if|if
condition|(
name|entry
operator|->
name|fts_info
operator|==
name|FTS_SL
operator|||
name|entry
operator|->
name|fts_info
operator|==
name|FTS_SLNONE
condition|)
block|{
if|if
condition|(
operator|(
name|p
operator|=
name|strrchr
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|++
name|p
expr_stmt|;
else|else
name|p
operator|=
name|entry
operator|->
name|fts_accpath
expr_stmt|;
name|save
index|[
literal|0
index|]
operator|=
name|p
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|0
index|]
operator|=
literal|'.'
expr_stmt|;
name|save
index|[
literal|1
index|]
operator|=
name|p
index|[
literal|1
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
name|p
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|statfs
argument_list|(
name|entry
operator|->
name|fts_accpath
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|fts_accpath
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
condition|)
block|{
name|p
index|[
literal|0
index|]
operator|=
name|save
index|[
literal|0
index|]
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|=
name|save
index|[
literal|1
index|]
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
comment|/* 		 * Further tests may need both of these values, so 		 * always copy both of them. 		 */
name|val_flags
operator|=
name|sb
operator|.
name|f_flags
expr_stmt|;
name|val_type
operator|=
name|sb
operator|.
name|f_type
expr_stmt|;
block|}
switch|switch
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_MTMASK
condition|)
block|{
case|case
name|F_MTFLAG
case|:
return|return
name|val_flags
operator|&
name|plan
operator|->
name|mt_data
return|;
case|case
name|F_MTTYPE
case|:
return|return
name|val_type
operator|==
name|plan
operator|->
name|mt_data
return|;
default|default:
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_if
if|#
directive|if
operator|!
name|defined
argument_list|(
name|__NetBSD__
argument_list|)
end_if

begin_function
name|PLAN
modifier|*
name|c_fstype
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|fsname
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|vfsconf
name|vfc
decl_stmt|;
name|fsname
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
comment|/* 	 * Check first for a filesystem name. 	 */
if|if
condition|(
name|getvfsbyname
argument_list|(
name|fsname
argument_list|,
operator|&
name|vfc
argument_list|)
operator|==
literal|0
condition|)
block|{
name|new
operator|->
name|flags
operator||=
name|F_MTTYPE
expr_stmt|;
name|new
operator|->
name|mt_data
operator|=
name|vfc
operator|.
name|vfc_typenum
expr_stmt|;
return|return
name|new
return|;
block|}
switch|switch
condition|(
operator|*
name|fsname
condition|)
block|{
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fsname
argument_list|,
literal|"local"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator||=
name|F_MTFLAG
expr_stmt|;
name|new
operator|->
name|mt_data
operator|=
name|MNT_LOCAL
expr_stmt|;
return|return
name|new
return|;
block|}
break|break;
case|case
literal|'r'
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|fsname
argument_list|,
literal|"rdonly"
argument_list|)
condition|)
block|{
name|new
operator|->
name|flags
operator||=
name|F_MTFLAG
expr_stmt|;
name|new
operator|->
name|mt_data
operator|=
name|MNT_RDONLY
expr_stmt|;
return|return
name|new
return|;
block|}
break|break;
block|}
comment|/* 	 * We need to make filesystem checks for filesystems 	 * that exists but aren't in the kernel work. 	 */
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: Unknown filesystem type %s\n"
argument_list|,
name|fsname
argument_list|)
expr_stmt|;
name|new
operator|->
name|flags
operator||=
name|F_MTUNKNOWN
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* __NetBSD__ */
end_comment

begin_comment
comment|/*  * -group gname functions --  *  *	True if the file belongs to the group gname.  If gname is numeric and  *	an equivalent of the getgrnam() function does not return a valid group  *	name, gname is taken as a group ID.  */
end_comment

begin_function
name|int
name|f_group
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|entry
operator|->
name|fts_statp
operator|->
name|st_gid
operator|==
name|plan
operator|->
name|g_data
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_group
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|gname
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|group
modifier|*
name|g
decl_stmt|;
name|gid_t
name|gid
decl_stmt|;
name|gname
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|g
operator|=
name|getgrnam
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|g
operator|==
name|NULL
condition|)
block|{
name|gid
operator|=
name|atoi
argument_list|(
name|gname
argument_list|)
expr_stmt|;
if|if
condition|(
name|gid
operator|==
literal|0
operator|&&
name|gname
index|[
literal|0
index|]
operator|!=
literal|'0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: no such group"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|gname
argument_list|)
expr_stmt|;
block|}
else|else
name|gid
operator|=
name|g
operator|->
name|gr_gid
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|g_data
operator|=
name|gid
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -inum n functions --  *  *	True if the file has inode # n.  */
end_comment

begin_function
name|int
name|f_inum
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|COMPARE
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_ino
argument_list|,
name|plan
operator|->
name|i_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_inum
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|inum_str
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|inum_str
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|i_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|inum_str
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -links n functions --  *  *	True if the file has n links.  */
end_comment

begin_function
name|int
name|f_links
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|COMPARE
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_nlink
argument_list|,
name|plan
operator|->
name|l_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_links
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|nlinks
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|nlinks
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|l_data
operator|=
operator|(
name|nlink_t
operator|)
name|find_parsenum
argument_list|(
name|new
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|nlinks
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -ls functions --  *  *	Always true - prints the current entry to stdout in "ls" format.  */
end_comment

begin_function
name|int
name|f_ls
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|printlong
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|,
name|entry
operator|->
name|fts_accpath
argument_list|,
name|entry
operator|->
name|fts_statp
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_ls
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|isoutput
operator|=
literal|1
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -name functions --  *  *	True if the basename of the filename being examined  *	matches pattern using Pattern Matching Notation S3.14  */
end_comment

begin_function
name|int
name|f_name
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|!
name|fnmatch
argument_list|(
name|plan
operator|->
name|c_data
argument_list|,
name|entry
operator|->
name|fts_name
argument_list|,
name|plan
operator|->
name|flags
operator|&
name|F_IGNCASE
condition|?
name|FNM_CASEFOLD
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_name
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|pattern
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|pattern
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|c_data
operator|=
name|pattern
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -newer file functions --  *  *	True if the current file has been modified more recently  *	then the modification time of the file named by the pathname  *	file.  */
end_comment

begin_function
name|int
name|f_newer
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_TIME_C
condition|)
return|return
name|entry
operator|->
name|fts_statp
operator|->
name|st_ctime
operator|>
name|plan
operator|->
name|t_data
return|;
elseif|else
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_TIME_A
condition|)
return|return
name|entry
operator|->
name|fts_statp
operator|->
name|st_atime
operator|>
name|plan
operator|->
name|t_data
return|;
else|else
return|return
name|entry
operator|->
name|fts_statp
operator|->
name|st_mtime
operator|>
name|plan
operator|->
name|t_data
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_newer
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|fn_or_tspec
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|fn_or_tspec
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
comment|/* compare against what */
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|F_TIME2_T
condition|)
block|{
name|new
operator|->
name|t_data
operator|=
name|parsedate
argument_list|(
name|fn_or_tspec
argument_list|,
operator|(
expr|struct
name|timeb
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|->
name|t_data
operator|==
operator|(
name|time_t
operator|)
operator|-
literal|1
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Can't parse date/time: %s"
argument_list|,
name|fn_or_tspec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|stat
argument_list|(
name|fn_or_tspec
argument_list|,
operator|&
name|sb
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|fn_or_tspec
argument_list|)
expr_stmt|;
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|F_TIME2_C
condition|)
name|new
operator|->
name|t_data
operator|=
name|sb
operator|.
name|st_ctime
expr_stmt|;
elseif|else
if|if
condition|(
name|option
operator|->
name|flags
operator|&
name|F_TIME2_A
condition|)
name|new
operator|->
name|t_data
operator|=
name|sb
operator|.
name|st_atime
expr_stmt|;
else|else
name|new
operator|->
name|t_data
operator|=
name|sb
operator|.
name|st_mtime
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -nogroup functions --  *  *	True if file belongs to a user ID for which the equivalent  *	of the getgrnam() 9.2.1 [POSIX.1] function returns NULL.  */
end_comment

begin_function
name|int
name|f_nogroup
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|group_from_gid
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_gid
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_nogroup
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -nouser functions --  *  *	True if file belongs to a user ID for which the equivalent  *	of the getpwuid() 9.2.2 [POSIX.1] function returns NULL.  */
end_comment

begin_function
name|int
name|f_nouser
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|user_from_uid
argument_list|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_uid
argument_list|,
literal|1
argument_list|)
operator|==
name|NULL
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_nouser
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -path functions --  *  *	True if the path of the filename being examined  *	matches pattern using Pattern Matching Notation S3.14  */
end_comment

begin_function
name|int
name|f_path
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|!
name|fnmatch
argument_list|(
name|plan
operator|->
name|c_data
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|,
name|plan
operator|->
name|flags
operator|&
name|F_IGNCASE
condition|?
name|FNM_CASEFOLD
else|:
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* c_path is the same as c_name */
end_comment

begin_comment
comment|/*  * -perm functions --  *  *	The mode argument is used to represent file mode bits.  If it starts  *	with a leading digit, it's treated as an octal mode, otherwise as a  *	symbolic mode.  */
end_comment

begin_function
name|int
name|f_perm
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|mode_t
name|mode
decl_stmt|;
name|mode
operator|=
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
operator|&
operator|(
name|S_ISUID
operator||
name|S_ISGID
operator||
name|S_ISTXT
operator||
name|S_IRWXU
operator||
name|S_IRWXG
operator||
name|S_IRWXO
operator|)
expr_stmt|;
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_ATLEAST
condition|)
return|return
operator|(
name|plan
operator|->
name|m_data
operator||
name|mode
operator|)
operator|==
name|mode
return|;
elseif|else
if|if
condition|(
name|plan
operator|->
name|flags
operator|&
name|F_ANY
condition|)
return|return
operator|(
name|mode
operator|&
name|plan
operator|->
name|m_data
operator|)
return|;
else|else
return|return
name|mode
operator|==
name|plan
operator|->
name|m_data
return|;
comment|/* NOTREACHED */
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_perm
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|perm
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|mode_t
modifier|*
name|set
decl_stmt|;
name|perm
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|perm
operator|==
literal|'-'
condition|)
block|{
name|new
operator|->
name|flags
operator||=
name|F_ATLEAST
expr_stmt|;
operator|++
name|perm
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|perm
operator|==
literal|'+'
condition|)
block|{
name|new
operator|->
name|flags
operator||=
name|F_ANY
expr_stmt|;
operator|++
name|perm
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|set
operator|=
name|setmode
argument_list|(
name|perm
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: illegal mode string"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|perm
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_data
operator|=
name|getmode
argument_list|(
name|set
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -print functions --  *  *	Always true, causes the current pathname to be written to  *	standard output.  */
end_comment

begin_function
name|int
name|f_print
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
operator|(
name|void
operator|)
name|puts
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_print
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|isoutput
operator|=
literal|1
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -print0 functions --  *  *	Always true, causes the current pathname to be written to  *	standard output followed by a NUL character  */
end_comment

begin_function
name|int
name|f_print0
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|fputs
argument_list|(
name|entry
operator|->
name|fts_path
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fputc
argument_list|(
literal|'\0'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* c_print0 is the same as c_print */
end_comment

begin_comment
comment|/*  * -prune functions --  *  *	Prune a portion of the hierarchy.  */
end_comment

begin_function
name|int
name|f_prune
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
specifier|extern
name|FTS
modifier|*
name|tree
decl_stmt|;
if|if
condition|(
name|fts_set
argument_list|(
name|tree
argument_list|,
name|entry
argument_list|,
name|FTS_SKIP
argument_list|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|entry
operator|->
name|fts_path
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
end_function

begin_comment
comment|/* c_prune == c_simple */
end_comment

begin_comment
comment|/*  * -regex functions --  *  *	True if the whole path of the file matches pattern using  *	regular expression.  */
end_comment

begin_function
name|int
name|f_regex
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|char
modifier|*
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|regex_t
modifier|*
name|pre
decl_stmt|;
name|regmatch_t
name|pmatch
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|char
name|errbuf
index|[
name|LINE_MAX
index|]
decl_stmt|;
name|int
name|matched
decl_stmt|;
name|pre
operator|=
name|plan
operator|->
name|re_data
expr_stmt|;
name|str
operator|=
name|entry
operator|->
name|fts_path
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|matched
operator|=
literal|0
expr_stmt|;
name|pmatch
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|pmatch
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
name|errcode
operator|=
name|regexec
argument_list|(
name|pre
argument_list|,
name|str
argument_list|,
literal|1
argument_list|,
operator|&
name|pmatch
argument_list|,
name|REG_STARTEND
argument_list|)
expr_stmt|;
if|if
condition|(
name|errcode
operator|!=
literal|0
operator|&&
name|errcode
operator|!=
name|REG_NOMATCH
condition|)
block|{
name|regerror
argument_list|(
name|errcode
argument_list|,
name|pre
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
name|errbuf
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s"
argument_list|,
name|plan
operator|->
name|flags
operator|&
name|F_IGNCASE
condition|?
literal|"-iregex"
else|:
literal|"-regex"
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|errcode
operator|==
literal|0
operator|&&
name|pmatch
operator|.
name|rm_so
operator|==
literal|0
operator|&&
name|pmatch
operator|.
name|rm_eo
operator|==
name|len
condition|)
name|matched
operator|=
literal|1
expr_stmt|;
return|return
name|matched
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_regex
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|PLAN
modifier|*
name|new
decl_stmt|;
name|char
modifier|*
name|pattern
decl_stmt|;
name|regex_t
modifier|*
name|pre
decl_stmt|;
name|int
name|errcode
decl_stmt|;
name|char
name|errbuf
index|[
name|LINE_MAX
index|]
decl_stmt|;
if|if
condition|(
operator|(
name|pre
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|regex_t
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|pattern
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|errcode
operator|=
name|regcomp
argument_list|(
name|pre
argument_list|,
name|pattern
argument_list|,
name|regexp_flags
operator||
operator|(
name|option
operator|->
name|flags
operator|&
name|F_IGNCASE
condition|?
name|REG_ICASE
else|:
literal|0
operator|)
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|regerror
argument_list|(
name|errcode
argument_list|,
name|pre
argument_list|,
name|errbuf
argument_list|,
sizeof|sizeof
name|errbuf
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: %s"
argument_list|,
name|option
operator|->
name|flags
operator|&
name|F_IGNCASE
condition|?
literal|"-iregex"
else|:
literal|"-regex"
argument_list|,
name|pattern
argument_list|,
name|errbuf
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|re_data
operator|=
name|pre
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/* c_simple covers c_prune, c_openparen, c_closeparen, c_not, c_or */
end_comment

begin_function
name|PLAN
modifier|*
name|c_simple
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * -size n[c] functions --  *  *	True if the file size in bytes, divided by an implementation defined  *	value and rounded up to the next integer, is n.  If n is followed by  *	a c, the size is in bytes.  */
end_comment

begin_define
define|#
directive|define
name|FIND_SIZE
value|512
end_define

begin_decl_stmt
specifier|static
name|int
name|divsize
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|f_size
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|off_t
name|size
decl_stmt|;
name|size
operator|=
name|divsize
condition|?
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_size
operator|+
name|FIND_SIZE
operator|-
literal|1
operator|)
operator|/
name|FIND_SIZE
else|:
name|entry
operator|->
name|fts_statp
operator|->
name|st_size
expr_stmt|;
name|COMPARE
argument_list|(
name|size
argument_list|,
name|plan
operator|->
name|o_data
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_size
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|size_str
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|char
name|endch
decl_stmt|;
name|size_str
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|endch
operator|=
literal|'c'
expr_stmt|;
name|new
operator|->
name|o_data
operator|=
name|find_parsenum
argument_list|(
name|new
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|size_str
argument_list|,
operator|&
name|endch
argument_list|)
expr_stmt|;
if|if
condition|(
name|endch
operator|==
literal|'c'
condition|)
name|divsize
operator|=
literal|0
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -type c functions --  *  *	True if the type of the file is c, where c is b, c, d, p, f or w  *	for block special file, character special file, directory, FIFO,  *	regular file or whiteout respectively.  */
end_comment

begin_function
name|int
name|f_type
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
operator|(
name|entry
operator|->
name|fts_statp
operator|->
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|==
name|plan
operator|->
name|m_data
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_type
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|typestring
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|mode_t
name|mask
decl_stmt|;
name|typestring
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
switch|switch
condition|(
name|typestring
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|mask
operator|=
name|S_IFBLK
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|mask
operator|=
name|S_IFCHR
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|mask
operator|=
name|S_IFDIR
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|mask
operator|=
name|S_IFREG
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|mask
operator|=
name|S_IFLNK
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|mask
operator|=
name|S_IFIFO
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|mask
operator|=
name|S_IFSOCK
expr_stmt|;
break|break;
ifdef|#
directive|ifdef
name|FTS_WHITEOUT
case|case
literal|'w'
case|:
name|mask
operator|=
name|S_IFWHT
expr_stmt|;
name|ftsoptions
operator||=
name|FTS_WHITEOUT
expr_stmt|;
break|break;
endif|#
directive|endif
comment|/* FTS_WHITEOUT */
default|default:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: unknown type"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|typestring
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|m_data
operator|=
name|mask
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -user uname functions --  *  *	True if the file belongs to the user uname.  If uname is numeric and  *	an equivalent of the getpwnam() S9.2.2 [POSIX.1] function does not  *	return a valid user name, uname is taken as a user ID.  */
end_comment

begin_function
name|int
name|f_user
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
return|return
name|entry
operator|->
name|fts_statp
operator|->
name|st_uid
operator|==
name|plan
operator|->
name|u_data
return|;
block|}
end_function

begin_function
name|PLAN
modifier|*
name|c_user
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
decl_stmt|;
block|{
name|char
modifier|*
name|username
decl_stmt|;
name|PLAN
modifier|*
name|new
decl_stmt|;
name|struct
name|passwd
modifier|*
name|p
decl_stmt|;
name|uid_t
name|uid
decl_stmt|;
name|username
operator|=
name|nextarg
argument_list|(
name|option
argument_list|,
name|argvp
argument_list|)
expr_stmt|;
name|ftsoptions
operator|&=
operator|~
name|FTS_NOSTAT
expr_stmt|;
name|p
operator|=
name|getpwnam
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|uid
operator|=
name|atoi
argument_list|(
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|uid
operator|==
literal|0
operator|&&
name|username
index|[
literal|0
index|]
operator|!=
literal|'0'
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"%s: %s: no such user"
argument_list|,
name|option
operator|->
name|name
argument_list|,
name|username
argument_list|)
expr_stmt|;
block|}
else|else
name|uid
operator|=
name|p
operator|->
name|pw_uid
expr_stmt|;
name|new
operator|=
name|palloc
argument_list|(
name|option
argument_list|)
expr_stmt|;
name|new
operator|->
name|u_data
operator|=
name|uid
expr_stmt|;
return|return
name|new
return|;
block|}
end_function

begin_comment
comment|/*  * -xdev functions --  *  *	Always true, causes find not to descend past directories that have a  *	different device ID (st_dev, see stat() S5.6.2 [POSIX.1])  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_xdev
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
name|ftsoptions
operator||=
name|FTS_XDEV
expr_stmt|;
return|return
name|palloc
argument_list|(
name|option
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * ( expression ) functions --  *  *	True if expression is true.  */
end_comment

begin_function
name|int
name|f_expr
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|PLAN
modifier|*
name|p
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|execute
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_comment
comment|/*  * f_openparen and f_closeparen nodes are temporary place markers.  They are  * eliminated during phase 2 of find_formplan() --- the '(' node is converted  * to a f_expr node containing the expression and the ')' node is discarded.  * The functions themselves are only used as constants.  */
end_comment

begin_function
name|int
name|f_openparen
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
name|__unused
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|int
name|f_closeparen
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
name|__unused
decl_stmt|;
name|FTSENT
modifier|*
name|entry
name|__unused
decl_stmt|;
block|{
name|abort
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* c_openparen == c_simple */
end_comment

begin_comment
comment|/* c_closeparen == c_simple */
end_comment

begin_comment
comment|/*  * AND operator. Since AND is implicit, no node is allocated.  */
end_comment

begin_function
name|PLAN
modifier|*
name|c_and
parameter_list|(
name|option
parameter_list|,
name|argvp
parameter_list|)
name|OPTION
modifier|*
name|option
name|__unused
decl_stmt|;
name|char
modifier|*
modifier|*
modifier|*
name|argvp
name|__unused
decl_stmt|;
block|{
return|return
name|NULL
return|;
block|}
end_function

begin_comment
comment|/*  * ! expression functions --  *  *	Negation of a primary; the unary NOT operator.  */
end_comment

begin_function
name|int
name|f_not
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|PLAN
modifier|*
name|p
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|execute
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
operator|!
name|state
return|;
block|}
end_function

begin_comment
comment|/* c_not == c_simple */
end_comment

begin_comment
comment|/*  * expression -o expression functions --  *  *	Alternation of primaries; the OR operator.  The second expression is  * not evaluated if the first expression is true.  */
end_comment

begin_function
name|int
name|f_or
parameter_list|(
name|plan
parameter_list|,
name|entry
parameter_list|)
name|PLAN
modifier|*
name|plan
decl_stmt|;
name|FTSENT
modifier|*
name|entry
decl_stmt|;
block|{
name|PLAN
modifier|*
name|p
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|0
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|execute
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
if|if
condition|(
name|state
condition|)
return|return
literal|1
return|;
for|for
control|(
name|p
operator|=
name|plan
operator|->
name|p_data
index|[
literal|1
index|]
init|;
name|p
operator|&&
operator|(
name|state
operator|=
call|(
name|p
operator|->
name|execute
call|)
argument_list|(
name|p
argument_list|,
name|entry
argument_list|)
operator|)
condition|;
name|p
operator|=
name|p
operator|->
name|next
control|)
empty_stmt|;
return|return
name|state
return|;
block|}
end_function

begin_comment
comment|/* c_or == c_simple */
end_comment

end_unit

