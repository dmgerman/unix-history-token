begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1983, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)printgprof.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|"gprof.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_macro
name|printprof
argument_list|()
end_macro

begin_block
block|{
specifier|register
name|nltype
modifier|*
name|np
decl_stmt|;
name|nltype
modifier|*
modifier|*
name|sortednlp
decl_stmt|;
name|int
name|index
decl_stmt|,
name|timecmp
argument_list|()
decl_stmt|;
name|actime
operator|=
literal|0.0
expr_stmt|;
name|printf
argument_list|(
literal|"\f\n"
argument_list|)
expr_stmt|;
name|flatprofheader
argument_list|()
expr_stmt|;
comment|/* 	 *	Sort the symbol table in by time 	 */
name|sortednlp
operator|=
operator|(
name|nltype
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nname
argument_list|,
sizeof|sizeof
argument_list|(
name|nltype
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sortednlp
operator|==
operator|(
name|nltype
operator|*
operator|*
operator|)
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[printprof] ran out of memory for time sorting\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nname
condition|;
name|index
operator|+=
literal|1
control|)
block|{
name|sortednlp
index|[
name|index
index|]
operator|=
operator|&
name|nl
index|[
name|index
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|sortednlp
argument_list|,
name|nname
argument_list|,
sizeof|sizeof
argument_list|(
name|nltype
operator|*
argument_list|)
argument_list|,
name|timecmp
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nname
condition|;
name|index
operator|+=
literal|1
control|)
block|{
name|np
operator|=
name|sortednlp
index|[
name|index
index|]
expr_stmt|;
name|flatprofline
argument_list|(
name|np
argument_list|)
expr_stmt|;
block|}
name|actime
operator|=
literal|0.0
expr_stmt|;
name|free
argument_list|(
name|sortednlp
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|timecmp
argument_list|(
argument|npp1
argument_list|,
argument|npp2
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
modifier|*
name|npp1
decl_stmt|,
modifier|*
modifier|*
name|npp2
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|double
name|timediff
decl_stmt|;
name|long
name|calldiff
decl_stmt|;
name|timediff
operator|=
operator|(
operator|*
name|npp2
operator|)
operator|->
name|time
operator|-
operator|(
operator|*
name|npp1
operator|)
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|timediff
operator|>
literal|0.0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|timediff
operator|<
literal|0.0
condition|)
return|return
operator|-
literal|1
return|;
name|calldiff
operator|=
operator|(
operator|*
name|npp2
operator|)
operator|->
name|ncall
operator|-
operator|(
operator|*
name|npp1
operator|)
operator|->
name|ncall
expr_stmt|;
if|if
condition|(
name|calldiff
operator|>
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|calldiff
operator|<
literal|0
condition|)
return|return
operator|-
literal|1
return|;
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|*
name|npp1
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|npp2
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_block

begin_comment
comment|/*      *	header for flatprofline      */
end_comment

begin_macro
name|flatprofheader
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|bflag
condition|)
block|{
name|printblurb
argument_list|(
name|_PATH_FLAT_BLURB
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ngranularity: each sample hit covers %g byte(s)"
argument_list|,
name|scale
operator|*
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|totime
operator|>
literal|0.0
condition|)
block|{
name|printf
argument_list|(
literal|" for %.2f%% of %.2f seconds\n\n"
argument_list|,
literal|100.0
operator|/
name|totime
argument_list|,
name|totime
operator|/
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" no time accumulated\n\n"
argument_list|)
expr_stmt|;
comment|/* 	     *	this doesn't hurt sinc eall the numerators will be zero. 	     */
name|totime
operator|=
literal|1.0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n"
argument_list|,
literal|"%  "
argument_list|,
literal|"cumulative"
argument_list|,
literal|"self  "
argument_list|,
literal|""
argument_list|,
literal|"self  "
argument_list|,
literal|"total "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%5.5s %10.10s %8.8s %8.8s %8.8s %8.8s  %-8.8s\n"
argument_list|,
literal|"time"
argument_list|,
literal|"seconds "
argument_list|,
literal|"seconds"
argument_list|,
literal|"calls"
argument_list|,
name|hz
operator|>=
literal|10000000
condition|?
literal|"ns/call"
else|:
name|hz
operator|>=
literal|10000
condition|?
literal|"us/call"
else|:
literal|"ms/call"
argument_list|,
name|hz
operator|>=
literal|10000000
condition|?
literal|"ns/call"
else|:
name|hz
operator|>=
literal|10000
condition|?
literal|"us/call"
else|:
literal|"ms/call"
argument_list|,
literal|"name"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|flatprofline
argument_list|(
name|np
argument_list|)
specifier|register
name|nltype
operator|*
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
if|if
condition|(
name|zflag
operator|==
literal|0
operator|&&
name|np
operator|->
name|ncall
operator|==
literal|0
operator|&&
name|np
operator|->
name|time
operator|==
literal|0
condition|)
block|{
return|return;
block|}
name|actime
operator|+=
name|np
operator|->
name|time
expr_stmt|;
if|if
condition|(
name|hz
operator|>=
literal|10000
condition|)
name|printf
argument_list|(
literal|"%5.1f %10.3f %8.3f"
argument_list|,
literal|100
operator|*
name|np
operator|->
name|time
operator|/
name|totime
argument_list|,
name|actime
operator|/
name|hz
argument_list|,
name|np
operator|->
name|time
operator|/
name|hz
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%5.1f %10.2f %8.2f"
argument_list|,
literal|100
operator|*
name|np
operator|->
name|time
operator|/
name|totime
argument_list|,
name|actime
operator|/
name|hz
argument_list|,
name|np
operator|->
name|time
operator|/
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|ncall
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|hz
operator|>=
literal|10000000
condition|)
name|printf
argument_list|(
literal|" %8ld %8.0f %8.0f  "
argument_list|,
name|np
operator|->
name|ncall
argument_list|,
literal|1e9
operator|*
name|np
operator|->
name|time
operator|/
name|hz
operator|/
name|np
operator|->
name|ncall
argument_list|,
literal|1e9
operator|*
operator|(
name|np
operator|->
name|time
operator|+
name|np
operator|->
name|childtime
operator|)
operator|/
name|hz
operator|/
name|np
operator|->
name|ncall
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|hz
operator|>=
literal|10000
condition|)
name|printf
argument_list|(
literal|" %8ld %8.0f %8.0f  "
argument_list|,
name|np
operator|->
name|ncall
argument_list|,
literal|1e6
operator|*
name|np
operator|->
name|time
operator|/
name|hz
operator|/
name|np
operator|->
name|ncall
argument_list|,
literal|1e6
operator|*
operator|(
name|np
operator|->
name|time
operator|+
name|np
operator|->
name|childtime
operator|)
operator|/
name|hz
operator|/
name|np
operator|->
name|ncall
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|" %8ld %8.2f %8.2f  "
argument_list|,
name|np
operator|->
name|ncall
argument_list|,
literal|1000
operator|*
name|np
operator|->
name|time
operator|/
name|hz
operator|/
name|np
operator|->
name|ncall
argument_list|,
literal|1000
operator|*
operator|(
name|np
operator|->
name|time
operator|+
name|np
operator|->
name|childtime
operator|)
operator|/
name|hz
operator|/
name|np
operator|->
name|ncall
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" %8.8s %8.8s %8.8s  "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|printname
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|gprofheader
argument_list|()
end_macro

begin_block
block|{
if|if
condition|(
name|bflag
condition|)
block|{
name|printblurb
argument_list|(
name|_PATH_CALLG_BLURB
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\ngranularity: each sample hit covers %g byte(s)"
argument_list|,
name|scale
operator|*
sizeof|sizeof
argument_list|(
name|UNIT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|printtime
operator|>
literal|0.0
condition|)
block|{
name|printf
argument_list|(
literal|" for %.2f%% of %.2f seconds\n\n"
argument_list|,
literal|100.0
operator|/
name|printtime
argument_list|,
name|printtime
operator|/
name|hz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" no time propagated\n\n"
argument_list|)
expr_stmt|;
comment|/* 	     *	this doesn't hurt, since all the numerators will be 0.0 	     */
name|printtime
operator|=
literal|1.0
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7.7s/%-7.7s     %-8.8s\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"called"
argument_list|,
literal|"total"
argument_list|,
literal|"parents"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-6.6s %5.5s %7.7s %11.11s %7.7s+%-7.7s %-8.8s\t%5.5s\n"
argument_list|,
literal|"index"
argument_list|,
literal|"%time"
argument_list|,
literal|"self"
argument_list|,
literal|"descendents"
argument_list|,
literal|"called"
argument_list|,
literal|"self"
argument_list|,
literal|"name"
argument_list|,
literal|"index"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7.7s/%-7.7s     %-8.8s\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|"called"
argument_list|,
literal|"total"
argument_list|,
literal|"children"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
name|gprofline
argument_list|(
name|np
argument_list|)
specifier|register
name|nltype
operator|*
name|np
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
name|kirkbuffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|kirkbuffer
argument_list|,
literal|"[%d]"
argument_list|,
name|np
operator|->
name|index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-6.6s %5.1f %7.2f %11.2f"
argument_list|,
name|kirkbuffer
argument_list|,
literal|100
operator|*
operator|(
name|np
operator|->
name|propself
operator|+
name|np
operator|->
name|propchild
operator|)
operator|/
name|printtime
argument_list|,
name|np
operator|->
name|propself
operator|/
name|hz
argument_list|,
name|np
operator|->
name|propchild
operator|/
name|hz
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|np
operator|->
name|ncall
operator|+
name|np
operator|->
name|selfcalls
operator|)
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|" %7ld"
argument_list|,
name|np
operator|->
name|npropcall
argument_list|)
expr_stmt|;
if|if
condition|(
name|np
operator|->
name|selfcalls
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"+%-7ld "
argument_list|,
name|np
operator|->
name|selfcalls
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" %7.7s "
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|printf
argument_list|(
literal|" %7.7s %7.7s "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|printname
argument_list|(
name|np
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_block

begin_macro
name|printgprof
argument_list|(
argument|timesortnlp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
modifier|*
name|timesortnlp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|index
decl_stmt|;
name|nltype
modifier|*
name|parentp
decl_stmt|;
comment|/* 	 *	Print out the structured profiling list 	 */
name|gprofheader
argument_list|()
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|0
init|;
name|index
operator|<
name|nname
operator|+
name|ncycle
condition|;
name|index
operator|++
control|)
block|{
name|parentp
operator|=
name|timesortnlp
index|[
name|index
index|]
expr_stmt|;
if|if
condition|(
name|zflag
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|ncall
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|selfcalls
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|propself
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|propchild
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
operator|!
name|parentp
operator|->
name|printflag
condition|)
block|{
continue|continue;
block|}
if|if
condition|(
name|parentp
operator|->
name|name
operator|==
literal|0
operator|&&
name|parentp
operator|->
name|cycleno
operator|!=
literal|0
condition|)
block|{
comment|/* 		 *	cycle header 		 */
name|printcycle
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|printmembers
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printparents
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|gprofline
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|printchildren
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"-----------------------------------------------\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|timesortnlp
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	sort by decreasing propagated time      *	if times are equal, but one is a cycle header,      *		say that's first (e.g. less, i.e. -1).      *	if one's name doesn't have an underscore and the other does,      *		say the one is first.      *	all else being equal, sort by names.      */
end_comment

begin_function
name|int
name|totalcmp
parameter_list|(
name|npp1
parameter_list|,
name|npp2
parameter_list|)
name|nltype
modifier|*
modifier|*
name|npp1
decl_stmt|;
name|nltype
modifier|*
modifier|*
name|npp2
decl_stmt|;
block|{
specifier|register
name|nltype
modifier|*
name|np1
init|=
operator|*
name|npp1
decl_stmt|;
specifier|register
name|nltype
modifier|*
name|np2
init|=
operator|*
name|npp2
decl_stmt|;
name|double
name|diff
decl_stmt|;
name|diff
operator|=
operator|(
name|np1
operator|->
name|propself
operator|+
name|np1
operator|->
name|propchild
operator|)
operator|-
operator|(
name|np2
operator|->
name|propself
operator|+
name|np2
operator|->
name|propchild
operator|)
expr_stmt|;
if|if
condition|(
name|diff
operator|<
literal|0.0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|diff
operator|>
literal|0.0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|np1
operator|->
name|name
operator|==
literal|0
operator|&&
name|np1
operator|->
name|cycleno
operator|!=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|np2
operator|->
name|name
operator|==
literal|0
operator|&&
name|np2
operator|->
name|cycleno
operator|!=
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|np1
operator|->
name|name
operator|==
literal|0
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|np2
operator|->
name|name
operator|==
literal|0
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
operator|(
name|np1
operator|->
name|name
operator|)
operator|!=
literal|'_'
operator|&&
operator|*
operator|(
name|np2
operator|->
name|name
operator|)
operator|==
literal|'_'
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
operator|*
operator|(
name|np1
operator|->
name|name
operator|)
operator|==
literal|'_'
operator|&&
operator|*
operator|(
name|np2
operator|->
name|name
operator|)
operator|!=
literal|'_'
condition|)
return|return
literal|1
return|;
if|if
condition|(
name|np1
operator|->
name|ncall
operator|>
name|np2
operator|->
name|ncall
condition|)
return|return
operator|-
literal|1
return|;
if|if
condition|(
name|np1
operator|->
name|ncall
operator|<
name|np2
operator|->
name|ncall
condition|)
return|return
literal|1
return|;
return|return
name|strcmp
argument_list|(
name|np1
operator|->
name|name
argument_list|,
name|np2
operator|->
name|name
argument_list|)
return|;
block|}
end_function

begin_macro
name|printparents
argument_list|(
argument|childp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|childp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nltype
modifier|*
name|parentp
decl_stmt|;
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|nltype
modifier|*
name|cycleheadp
decl_stmt|;
if|if
condition|(
name|childp
operator|->
name|cyclehead
operator|!=
literal|0
condition|)
block|{
name|cycleheadp
operator|=
name|childp
operator|->
name|cyclehead
expr_stmt|;
block|}
else|else
block|{
name|cycleheadp
operator|=
name|childp
expr_stmt|;
block|}
if|if
condition|(
name|childp
operator|->
name|parents
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7.7s %7.7s<spontaneous>\n"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return;
block|}
name|sortparents
argument_list|(
name|childp
argument_list|)
expr_stmt|;
for|for
control|(
name|arcp
operator|=
name|childp
operator|->
name|parents
init|;
name|arcp
condition|;
name|arcp
operator|=
name|arcp
operator|->
name|arc_parentlist
control|)
block|{
name|parentp
operator|=
name|arcp
operator|->
name|arc_parentp
expr_stmt|;
if|if
condition|(
name|childp
operator|==
name|parentp
operator|||
operator|(
name|arcp
operator|->
name|arc_flags
operator|&
name|DEADARC
operator|)
operator|||
operator|(
name|childp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|parentp
operator|->
name|cycleno
operator|==
name|childp
operator|->
name|cycleno
operator|)
condition|)
block|{
comment|/* 		 *	selfcall or call among siblings 		 */
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7ld %7.7s     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	regular parent of child 		 */
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.2f %11.2f %7ld/%-7ld     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_time
operator|/
name|hz
argument_list|,
name|arcp
operator|->
name|arc_childtime
operator|/
name|hz
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
name|cycleheadp
operator|->
name|npropcall
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|printchildren
argument_list|(
argument|parentp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|parentp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nltype
modifier|*
name|childp
decl_stmt|;
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|sortchildren
argument_list|(
name|parentp
argument_list|)
expr_stmt|;
name|arcp
operator|=
name|parentp
operator|->
name|children
expr_stmt|;
for|for
control|(
name|arcp
operator|=
name|parentp
operator|->
name|children
init|;
name|arcp
condition|;
name|arcp
operator|=
name|arcp
operator|->
name|arc_childlist
control|)
block|{
name|childp
operator|=
name|arcp
operator|->
name|arc_childp
expr_stmt|;
if|if
condition|(
name|childp
operator|==
name|parentp
operator|||
operator|(
name|arcp
operator|->
name|arc_flags
operator|&
name|DEADARC
operator|)
operator|||
operator|(
name|childp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|childp
operator|->
name|cycleno
operator|==
name|parentp
operator|->
name|cycleno
operator|)
condition|)
block|{
comment|/* 		 *	self call or call to sibling 		 */
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.7s %11.11s %7ld %7.7s     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
literal|""
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|childp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 *	regular child of parent 		 */
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.2f %11.2f %7ld/%-7ld     "
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|arcp
operator|->
name|arc_time
operator|/
name|hz
argument_list|,
name|arcp
operator|->
name|arc_childtime
operator|/
name|hz
argument_list|,
name|arcp
operator|->
name|arc_count
argument_list|,
name|childp
operator|->
name|cyclehead
operator|->
name|npropcall
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|childp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|printname
argument_list|(
argument|selfp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|selfp
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|selfp
operator|->
name|name
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|selfp
operator|->
name|name
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|DFNDEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"{%d} "
argument_list|,
name|selfp
operator|->
name|toporder
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|debug
operator|&
name|PROPDEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"%5.2f%% "
argument_list|,
name|selfp
operator|->
name|propfraction
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
block|}
if|if
condition|(
name|selfp
operator|->
name|cycleno
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"<cycle %d>"
argument_list|,
name|selfp
operator|->
name|cycleno
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|selfp
operator|->
name|index
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|selfp
operator|->
name|printflag
condition|)
block|{
name|printf
argument_list|(
literal|" [%d]"
argument_list|,
name|selfp
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" (%d)"
argument_list|,
name|selfp
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_macro
name|sortchildren
argument_list|(
argument|parentp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|parentp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|arctype
modifier|*
name|detachedp
decl_stmt|;
name|arctype
name|sorted
decl_stmt|;
name|arctype
modifier|*
name|prevp
decl_stmt|;
comment|/* 	 *	unlink children from parent, 	 *	then insertion sort back on to sorted's children. 	 *	    *arcp	the arc you have detached and are inserting. 	 *	    *detachedp	the rest of the arcs to be sorted. 	 *	    sorted	arc list onto which you insertion sort. 	 *	    *prevp	arc before the arc you are comparing. 	 */
name|sorted
operator|.
name|arc_childlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|arcp
operator|=
name|parentp
operator|->
name|children
operator|)
operator|&&
operator|(
name|detachedp
operator|=
name|arcp
operator|->
name|arc_childlist
operator|)
init|;
name|arcp
condition|;
operator|(
name|arcp
operator|=
name|detachedp
operator|)
operator|&&
operator|(
name|detachedp
operator|=
name|detachedp
operator|->
name|arc_childlist
operator|)
control|)
block|{
comment|/* 	     *	consider *arcp as disconnected 	     *	insert it into sorted 	     */
for|for
control|(
name|prevp
operator|=
operator|&
name|sorted
init|;
name|prevp
operator|->
name|arc_childlist
condition|;
name|prevp
operator|=
name|prevp
operator|->
name|arc_childlist
control|)
block|{
if|if
condition|(
name|arccmp
argument_list|(
name|arcp
argument_list|,
name|prevp
operator|->
name|arc_childlist
argument_list|)
operator|!=
name|LESSTHAN
condition|)
block|{
break|break;
block|}
block|}
name|arcp
operator|->
name|arc_childlist
operator|=
name|prevp
operator|->
name|arc_childlist
expr_stmt|;
name|prevp
operator|->
name|arc_childlist
operator|=
name|arcp
expr_stmt|;
block|}
comment|/* 	 *	reattach sorted children to parent 	 */
name|parentp
operator|->
name|children
operator|=
name|sorted
operator|.
name|arc_childlist
expr_stmt|;
block|}
end_block

begin_macro
name|sortparents
argument_list|(
argument|childp
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|childp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|arctype
modifier|*
name|arcp
decl_stmt|;
name|arctype
modifier|*
name|detachedp
decl_stmt|;
name|arctype
name|sorted
decl_stmt|;
name|arctype
modifier|*
name|prevp
decl_stmt|;
comment|/* 	 *	unlink parents from child, 	 *	then insertion sort back on to sorted's parents. 	 *	    *arcp	the arc you have detached and are inserting. 	 *	    *detachedp	the rest of the arcs to be sorted. 	 *	    sorted	arc list onto which you insertion sort. 	 *	    *prevp	arc before the arc you are comparing. 	 */
name|sorted
operator|.
name|arc_parentlist
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|arcp
operator|=
name|childp
operator|->
name|parents
operator|)
operator|&&
operator|(
name|detachedp
operator|=
name|arcp
operator|->
name|arc_parentlist
operator|)
init|;
name|arcp
condition|;
operator|(
name|arcp
operator|=
name|detachedp
operator|)
operator|&&
operator|(
name|detachedp
operator|=
name|detachedp
operator|->
name|arc_parentlist
operator|)
control|)
block|{
comment|/* 	     *	consider *arcp as disconnected 	     *	insert it into sorted 	     */
for|for
control|(
name|prevp
operator|=
operator|&
name|sorted
init|;
name|prevp
operator|->
name|arc_parentlist
condition|;
name|prevp
operator|=
name|prevp
operator|->
name|arc_parentlist
control|)
block|{
if|if
condition|(
name|arccmp
argument_list|(
name|arcp
argument_list|,
name|prevp
operator|->
name|arc_parentlist
argument_list|)
operator|!=
name|GREATERTHAN
condition|)
block|{
break|break;
block|}
block|}
name|arcp
operator|->
name|arc_parentlist
operator|=
name|prevp
operator|->
name|arc_parentlist
expr_stmt|;
name|prevp
operator|->
name|arc_parentlist
operator|=
name|arcp
expr_stmt|;
block|}
comment|/* 	 *	reattach sorted arcs to child 	 */
name|childp
operator|->
name|parents
operator|=
name|sorted
operator|.
name|arc_parentlist
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	print a cycle header      */
end_comment

begin_macro
name|printcycle
argument_list|(
argument|cyclep
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|cyclep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|kirkbuffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|kirkbuffer
argument_list|,
literal|"[%d]"
argument_list|,
name|cyclep
operator|->
name|index
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-6.6s %5.1f %7.2f %11.2f %7ld"
argument_list|,
name|kirkbuffer
argument_list|,
literal|100
operator|*
operator|(
name|cyclep
operator|->
name|propself
operator|+
name|cyclep
operator|->
name|propchild
operator|)
operator|/
name|printtime
argument_list|,
name|cyclep
operator|->
name|propself
operator|/
name|hz
argument_list|,
name|cyclep
operator|->
name|propchild
operator|/
name|hz
argument_list|,
name|cyclep
operator|->
name|npropcall
argument_list|)
expr_stmt|;
if|if
condition|(
name|cyclep
operator|->
name|selfcalls
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"+%-7ld"
argument_list|,
name|cyclep
operator|->
name|selfcalls
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" %7.7s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"<cycle %d as a whole>\t[%d]\n"
argument_list|,
name|cyclep
operator|->
name|cycleno
argument_list|,
name|cyclep
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/*      *	print the members of a cycle      */
end_comment

begin_macro
name|printmembers
argument_list|(
argument|cyclep
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|cyclep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nltype
modifier|*
name|memberp
decl_stmt|;
name|sortmembers
argument_list|(
name|cyclep
argument_list|)
expr_stmt|;
for|for
control|(
name|memberp
operator|=
name|cyclep
operator|->
name|cnext
init|;
name|memberp
condition|;
name|memberp
operator|=
name|memberp
operator|->
name|cnext
control|)
block|{
name|printf
argument_list|(
literal|"%6.6s %5.5s %7.2f %11.2f %7ld"
argument_list|,
literal|""
argument_list|,
literal|""
argument_list|,
name|memberp
operator|->
name|propself
operator|/
name|hz
argument_list|,
name|memberp
operator|->
name|propchild
operator|/
name|hz
argument_list|,
name|memberp
operator|->
name|npropcall
argument_list|)
expr_stmt|;
if|if
condition|(
name|memberp
operator|->
name|selfcalls
operator|!=
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"+%-7ld"
argument_list|,
name|memberp
operator|->
name|selfcalls
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|" %7.7s"
argument_list|,
literal|""
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"     "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|memberp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	sort members of a cycle      */
end_comment

begin_macro
name|sortmembers
argument_list|(
argument|cyclep
argument_list|)
end_macro

begin_decl_stmt
name|nltype
modifier|*
name|cyclep
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|nltype
modifier|*
name|todo
decl_stmt|;
name|nltype
modifier|*
name|doing
decl_stmt|;
name|nltype
modifier|*
name|prev
decl_stmt|;
comment|/* 	 *	detach cycle members from cyclehead, 	 *	and insertion sort them back on. 	 */
name|todo
operator|=
name|cyclep
operator|->
name|cnext
expr_stmt|;
name|cyclep
operator|->
name|cnext
operator|=
literal|0
expr_stmt|;
for|for
control|(
operator|(
name|doing
operator|=
name|todo
operator|)
operator|&&
operator|(
name|todo
operator|=
name|doing
operator|->
name|cnext
operator|)
init|;
name|doing
condition|;
operator|(
name|doing
operator|=
name|todo
operator|)
operator|&&
operator|(
name|todo
operator|=
name|doing
operator|->
name|cnext
operator|)
control|)
block|{
for|for
control|(
name|prev
operator|=
name|cyclep
init|;
name|prev
operator|->
name|cnext
condition|;
name|prev
operator|=
name|prev
operator|->
name|cnext
control|)
block|{
if|if
condition|(
name|membercmp
argument_list|(
name|doing
argument_list|,
name|prev
operator|->
name|cnext
argument_list|)
operator|==
name|GREATERTHAN
condition|)
block|{
break|break;
block|}
block|}
name|doing
operator|->
name|cnext
operator|=
name|prev
operator|->
name|cnext
expr_stmt|;
name|prev
operator|->
name|cnext
operator|=
name|doing
expr_stmt|;
block|}
block|}
end_block

begin_comment
comment|/*      *	major sort is on propself + propchild,      *	next is sort on ncalls + selfcalls.      */
end_comment

begin_function
name|int
name|membercmp
parameter_list|(
name|this
parameter_list|,
name|that
parameter_list|)
name|nltype
modifier|*
name|this
decl_stmt|;
name|nltype
modifier|*
name|that
decl_stmt|;
block|{
name|double
name|thistime
init|=
name|this
operator|->
name|propself
operator|+
name|this
operator|->
name|propchild
decl_stmt|;
name|double
name|thattime
init|=
name|that
operator|->
name|propself
operator|+
name|that
operator|->
name|propchild
decl_stmt|;
name|long
name|thiscalls
init|=
name|this
operator|->
name|ncall
operator|+
name|this
operator|->
name|selfcalls
decl_stmt|;
name|long
name|thatcalls
init|=
name|that
operator|->
name|ncall
operator|+
name|that
operator|->
name|selfcalls
decl_stmt|;
if|if
condition|(
name|thistime
operator|>
name|thattime
condition|)
block|{
return|return
name|GREATERTHAN
return|;
block|}
if|if
condition|(
name|thistime
operator|<
name|thattime
condition|)
block|{
return|return
name|LESSTHAN
return|;
block|}
if|if
condition|(
name|thiscalls
operator|>
name|thatcalls
condition|)
block|{
return|return
name|GREATERTHAN
return|;
block|}
if|if
condition|(
name|thiscalls
operator|<
name|thatcalls
condition|)
block|{
return|return
name|LESSTHAN
return|;
block|}
return|return
name|EQUALTO
return|;
block|}
end_function

begin_comment
comment|/*      *	compare two arcs to/from the same child/parent.      *	- if one arc is a self arc, it's least.      *	- if one arc is within a cycle, it's less than.      *	- if both arcs are within a cycle, compare arc counts.      *	- if neither arc is within a cycle, compare with      *		arc_time + arc_childtime as major key      *		arc count as minor key      */
end_comment

begin_function
name|int
name|arccmp
parameter_list|(
name|thisp
parameter_list|,
name|thatp
parameter_list|)
name|arctype
modifier|*
name|thisp
decl_stmt|;
name|arctype
modifier|*
name|thatp
decl_stmt|;
block|{
name|nltype
modifier|*
name|thisparentp
init|=
name|thisp
operator|->
name|arc_parentp
decl_stmt|;
name|nltype
modifier|*
name|thischildp
init|=
name|thisp
operator|->
name|arc_childp
decl_stmt|;
name|nltype
modifier|*
name|thatparentp
init|=
name|thatp
operator|->
name|arc_parentp
decl_stmt|;
name|nltype
modifier|*
name|thatchildp
init|=
name|thatp
operator|->
name|arc_childp
decl_stmt|;
name|double
name|thistime
decl_stmt|;
name|double
name|thattime
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
name|debug
operator|&
name|TIMEDEBUG
condition|)
block|{
name|printf
argument_list|(
literal|"[arccmp] "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thisparentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" calls "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thischildp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %f + %f %ld/%ld\n"
argument_list|,
name|thisp
operator|->
name|arc_time
argument_list|,
name|thisp
operator|->
name|arc_childtime
argument_list|,
name|thisp
operator|->
name|arc_count
argument_list|,
name|thischildp
operator|->
name|ncall
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"[arccmp] "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thatparentp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" calls "
argument_list|)
expr_stmt|;
name|printname
argument_list|(
name|thatchildp
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %f + %f %ld/%ld\n"
argument_list|,
name|thatp
operator|->
name|arc_time
argument_list|,
name|thatp
operator|->
name|arc_childtime
argument_list|,
name|thatp
operator|->
name|arc_count
argument_list|,
name|thatchildp
operator|->
name|ncall
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|DEBUG
if|if
condition|(
name|thisparentp
operator|==
name|thischildp
condition|)
block|{
comment|/* this is a self call */
return|return
name|LESSTHAN
return|;
block|}
if|if
condition|(
name|thatparentp
operator|==
name|thatchildp
condition|)
block|{
comment|/* that is a self call */
return|return
name|GREATERTHAN
return|;
block|}
if|if
condition|(
name|thisparentp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thischildp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thisparentp
operator|->
name|cycleno
operator|==
name|thischildp
operator|->
name|cycleno
condition|)
block|{
comment|/* this is a call within a cycle */
if|if
condition|(
name|thatparentp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatchildp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatparentp
operator|->
name|cycleno
operator|==
name|thatchildp
operator|->
name|cycleno
condition|)
block|{
comment|/* that is a call within the cycle, too */
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|<
name|thatp
operator|->
name|arc_count
condition|)
block|{
return|return
name|LESSTHAN
return|;
block|}
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|>
name|thatp
operator|->
name|arc_count
condition|)
block|{
return|return
name|GREATERTHAN
return|;
block|}
return|return
name|EQUALTO
return|;
block|}
else|else
block|{
comment|/* that isn't a call within the cycle */
return|return
name|LESSTHAN
return|;
block|}
block|}
else|else
block|{
comment|/* this isn't a call within a cycle */
if|if
condition|(
name|thatparentp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatchildp
operator|->
name|cycleno
operator|!=
literal|0
operator|&&
name|thatparentp
operator|->
name|cycleno
operator|==
name|thatchildp
operator|->
name|cycleno
condition|)
block|{
comment|/* that is a call within a cycle */
return|return
name|GREATERTHAN
return|;
block|}
else|else
block|{
comment|/* neither is a call within a cycle */
name|thistime
operator|=
name|thisp
operator|->
name|arc_time
operator|+
name|thisp
operator|->
name|arc_childtime
expr_stmt|;
name|thattime
operator|=
name|thatp
operator|->
name|arc_time
operator|+
name|thatp
operator|->
name|arc_childtime
expr_stmt|;
if|if
condition|(
name|thistime
operator|<
name|thattime
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|thistime
operator|>
name|thattime
condition|)
return|return
name|GREATERTHAN
return|;
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|<
name|thatp
operator|->
name|arc_count
condition|)
return|return
name|LESSTHAN
return|;
if|if
condition|(
name|thisp
operator|->
name|arc_count
operator|>
name|thatp
operator|->
name|arc_count
condition|)
return|return
name|GREATERTHAN
return|;
return|return
name|EQUALTO
return|;
block|}
block|}
block|}
end_function

begin_macro
name|printblurb
argument_list|(
argument|blurbname
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|blurbname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|FILE
modifier|*
name|blurbfile
decl_stmt|;
name|int
name|input
decl_stmt|;
name|blurbfile
operator|=
name|fopen
argument_list|(
name|blurbname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blurbfile
operator|==
name|NULL
condition|)
block|{
name|perror
argument_list|(
name|blurbname
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|input
operator|=
name|getc
argument_list|(
name|blurbfile
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|putchar
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
name|fclose
argument_list|(
name|blurbfile
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|int
name|namecmp
parameter_list|(
name|npp1
parameter_list|,
name|npp2
parameter_list|)
name|nltype
modifier|*
modifier|*
name|npp1
decl_stmt|,
decl|*
modifier|*
name|npp2
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
operator|(
operator|*
name|npp1
operator|)
operator|->
name|name
argument_list|,
operator|(
operator|*
name|npp2
operator|)
operator|->
name|name
argument_list|)
operator|)
return|;
block|}
end_block

begin_macro
name|printindex
argument_list|()
end_macro

begin_block
block|{
name|nltype
modifier|*
modifier|*
name|namesortnlp
decl_stmt|;
specifier|register
name|nltype
modifier|*
name|nlp
decl_stmt|;
name|int
name|index
decl_stmt|,
name|nnames
decl_stmt|,
name|todo
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
name|char
name|peterbuffer
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* 	 *	Now, sort regular function name alphbetically 	 *	to create an index. 	 */
name|namesortnlp
operator|=
operator|(
name|nltype
operator|*
operator|*
operator|)
name|calloc
argument_list|(
name|nname
operator|+
name|ncycle
argument_list|,
sizeof|sizeof
argument_list|(
name|nltype
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|namesortnlp
operator|==
operator|(
name|nltype
operator|*
operator|*
operator|)
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"ran out of memory for sorting"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|index
operator|=
literal|0
operator|,
name|nnames
operator|=
literal|0
init|;
name|index
operator|<
name|nname
condition|;
name|index
operator|++
control|)
block|{
if|if
condition|(
name|zflag
operator|==
literal|0
operator|&&
name|nl
index|[
name|index
index|]
operator|.
name|ncall
operator|==
literal|0
operator|&&
name|nl
index|[
name|index
index|]
operator|.
name|time
operator|==
literal|0
condition|)
continue|continue;
name|namesortnlp
index|[
name|nnames
operator|++
index|]
operator|=
operator|&
name|nl
index|[
name|index
index|]
expr_stmt|;
block|}
name|qsort
argument_list|(
name|namesortnlp
argument_list|,
name|nnames
argument_list|,
sizeof|sizeof
argument_list|(
name|nltype
operator|*
argument_list|)
argument_list|,
name|namecmp
argument_list|)
expr_stmt|;
for|for
control|(
name|index
operator|=
literal|1
operator|,
name|todo
operator|=
name|nnames
init|;
name|index
operator|<=
name|ncycle
condition|;
name|index
operator|++
control|)
block|{
name|namesortnlp
index|[
name|todo
operator|++
index|]
operator|=
operator|&
name|cyclenl
index|[
name|index
index|]
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\f\nIndex by function name\n\n"
argument_list|)
expr_stmt|;
name|index
operator|=
operator|(
name|todo
operator|+
literal|2
operator|)
operator|/
literal|3
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|index
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
name|i
init|;
name|j
operator|<
name|todo
condition|;
name|j
operator|+=
name|index
control|)
block|{
name|nlp
operator|=
name|namesortnlp
index|[
name|j
index|]
expr_stmt|;
if|if
condition|(
name|nlp
operator|->
name|printflag
condition|)
block|{
name|sprintf
argument_list|(
name|peterbuffer
argument_list|,
literal|"[%d]"
argument_list|,
name|nlp
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|peterbuffer
argument_list|,
literal|"(%d)"
argument_list|,
name|nlp
operator|->
name|index
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|j
operator|<
name|nnames
condition|)
block|{
name|printf
argument_list|(
literal|"%6.6s %-19.19s"
argument_list|,
name|peterbuffer
argument_list|,
name|nlp
operator|->
name|name
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printf
argument_list|(
literal|"%6.6s "
argument_list|,
name|peterbuffer
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|peterbuffer
argument_list|,
literal|"<cycle %d>"
argument_list|,
name|nlp
operator|->
name|cycleno
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%-19.19s"
argument_list|,
name|peterbuffer
argument_list|)
expr_stmt|;
block|}
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|namesortnlp
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

