begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: fmt.c,v 1.16 2000/06/25 15:35:42 pjanzen Exp $	*/
end_comment

begin_comment
comment|/* Sensible version of fmt  *  * Syntax: fmt [ options ] [ goal [ max ] ] [ filename ... ]  *  * Since the documentation for the original fmt is so poor, here  * is an accurate description of what this one does. It's usually  * the same. The *mechanism* used may differ from that suggested  * here. Note that we are *not* entirely compatible with fmt,  * because fmt gets so many things wrong.  *  * 1. Tabs are expanded, assuming 8-space tab stops.  *    If the `-t<n>' option is given, we assume<n>-space  *    tab stops instead.  *    Trailing blanks are removed from all lines.  *    x\b == nothing, for any x other than \b.  *    Other control characters are simply stripped. This  *    includes \r.  * 2. Each line is split into leading whitespace and  *    everything else. Maximal consecutive sequences of  *    lines with the same leading whitespace are considered  *    to form paragraphs, except that a blank line is always  *    a paragraph to itself.  *    If the `-p' option is given then the first line of a  *    paragraph is permitted to have indentation different  *    from that of the other lines.  *    If the `-m' option is given then a line that looks  *    like a mail message header, if it is not immediately  *    preceded by a non-blank non-message-header line, is  *    taken to start a new paragraph, which also contains  *    any subsequent lines with non-empty leading whitespace.  *    Unless the `-n' option is given, lines beginning with  *    a . (dot) are not formatted.  * 3. The "everything else" is split into words; a word  *    includes its trailing whitespace, and a word at the  *    end of a line is deemed to be followed by a single  *    space, or two spaces if it ends with a sentence-end  *    character. (See the `-d' option for how to change that.)  *    If the `-s' option has been given, then a word's trailing  *    whitespace is replaced by what it would have had if it  *    had occurred at end of line.  * 4. Each paragraph is sent to standard output as follows.  *    We output the leading whitespace, and then enough words  *    to make the line length as near as possible to the goal  *    without exceeding the maximum. (If a single word would  *    exceed the maximum, we output that anyway.) Of course  *    the trailing whitespace of the last word is ignored.  *    We then emit a newline and start again if there are any  *    words left.  *    Note that for a blank line this translates as "We emit  *    a newline".  *    If the `-l<n>' option is given, then leading whitespace  *    is modified slightly:<n> spaces are replaced by a tab.  *    Indented paragraphs (see above under `-p') make matters  *    more complicated than this suggests. Actually every paragraph  *    has two `leading whitespace' values; the value for the first  *    line, and the value for the most recent line. (While processing  *    the first line, the two are equal. When `-p' has not been  *    given, they are always equal.) The leading whitespace  *    actually output is that of the first line (for the first  *    line of *output*) or that of the most recent line (for  *    all other lines of output).  *    When `-m' has been given, message header paragraphs are  *    taken as having first-leading-whitespace empty and  *    subsequent-leading-whitespace two spaces.  *  * Multiple input files are formatted one at a time, so that a file  * never ends in the middle of a line.  *  * There's an alternative mode of operation, invoked by giving  * the `-c' option. In that case we just center every line,  * and most of the other options are ignored. This should  * really be in a separate program, but we must stay compatible  * with old `fmt'.  *  * QUERY: Should `-m' also try to do the right thing with quoted text?  * QUERY: `-b' to treat backslashed whitespace as old `fmt' does?  * QUERY: Option meaning `never join lines'?  * QUERY: Option meaning `split in mid-word to avoid overlong lines'?  * (Those last two might not be useful, since we have `fold'.)  *  * Differences from old `fmt':  *  *   - We have many more options. Options that aren't understood  *     generate a lengthy usage message, rather than being  *     treated as filenames.  *   - Even with `-m', our handling of message headers is  *     significantly different. (And much better.)  *   - We don't treat `\ ' as non-word-breaking.  *   - Downward changes of indentation start new paragraphs  *     for us, as well as upward. (I think old `fmt' behaves  *     in the way it does in order to allow indented paragraphs,  *     but this is a broken way of making indented paragraphs  *     behave right.)  *   - Given the choice of going over or under |goal_length|  *     by the same amount, we go over; old `fmt' goes under.  *   - We treat `?' as ending a sentence, and not `:'. Old `fmt'  *     does the reverse.  *   - We return approved return codes. Old `fmt' returns  *     1 for some errors, and *the number of unopenable files*  *     when that was all that went wrong.  *   - We have fewer crashes and more helpful error messages.  *   - We don't turn spaces into tabs at starts of lines unless  *     specifically requested.  *   - New `fmt' is somewhat smaller and slightly faster than  *     old `fmt'.  *  * Bugs:  *  *   None known. There probably are some, though.  *  * Portability:  *  *   I believe this code to be pretty portable. It does require  *   that you have `getopt'. If you need to include "getopt.h"  *   for this (e.g., if your system didn't come with `getopt'  *   and you installed it yourself) then you should arrange for  *   NEED_getopt_h to be #defined.  *  *   Everything here should work OK even on nasty 16-bit  *   machines and nice 64-bit ones. However, it's only really  *   been tested on my FreeBSD machine. Your mileage may vary.  */
end_comment

begin_comment
comment|/* Copyright (c) 1997 Gareth McCaughan. All rights reserved.  *  * Redistribution and use of this code, in source or binary forms,  * with or without modification, are permitted subject to the following  * conditions:  *  *  - Redistribution of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  *  *  - If you distribute modified source code it must also include  *    a notice saying that it has been modified, and giving a brief  *    description of what changes have been made.  *  * Disclaimer: I am not responsible for the results of using this code.  *             If it formats your hard disc, sends obscene messages to  *             your boss and kills your children then that's your problem  *             not mine. I give absolutely no warranty of any sort as to  *             what the program will do, and absolutely refuse to be held  *             liable for any consequences of your using it.  *             Thank you. Have a nice day.  */
end_comment

begin_comment
comment|/* RCS change log:  * Revision 1.5  1998/03/02 18:02:21  gjm11  * Minor changes for portability.  *  * Revision 1.4  1997/10/01 11:51:28  gjm11  * Repair broken indented-paragraph handling.  * Add mail message header stuff.  * Improve comments and layout.  * Make usable with non-BSD systems.  * Add revision display to usage message.  *  * Revision 1.3  1997/09/30 16:24:47  gjm11  * Add copyright notice, rcsid string and log message.  *  * Revision 1.2  1997/09/30 16:13:39  gjm11  * Add options: -d<chars>, -l<width>, -p, -s, -t<width>, -h .  * Parse options with `getopt'. Clean up code generally.  * Make comments more accurate.  *  * Revision 1.1  1997/09/30 11:29:57  gjm11  * Initial revision  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"Copyright (c) 1997 Gareth McCaughan. All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* Something that, we hope, will never be a genuine line length,  * indentation etc.  */
end_comment

begin_define
define|#
directive|define
name|SILLY
value|((size_t)-1)
end_define

begin_comment
comment|/* I used to use |strtoul| for this, but (1) not all systems have it  * and (2) it's probably better to use |strtol| to detect negative  * numbers better.  * If |fussyp==0| then we don't complain about non-numbers  * (returning 0 instead), but we do complain about bad numbers.  */
end_comment

begin_function
specifier|static
name|size_t
name|get_positive
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|err_mess
parameter_list|,
name|int
name|fussyP
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|long
name|result
init|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
name|fussyP
condition|)
goto|goto
name|Lose
goto|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|result
operator|<=
literal|0
condition|)
block|{
name|Lose
label|:
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"%s"
argument_list|,
name|err_mess
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size_t
operator|)
name|result
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|get_nonnegative
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|err_mess
parameter_list|,
name|int
name|fussyP
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|long
name|result
init|=
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|t
argument_list|,
literal|0
argument_list|)
decl_stmt|;
if|if
condition|(
operator|*
name|t
condition|)
block|{
if|if
condition|(
name|fussyP
condition|)
goto|goto
name|Lose
goto|;
else|else
return|return
literal|0
return|;
block|}
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|Lose
label|:
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"%s"
argument_list|,
name|err_mess
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|size_t
operator|)
name|result
return|;
block|}
end_function

begin_comment
comment|/* Global variables */
end_comment

begin_decl_stmt
specifier|static
name|int
name|centerP
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Try to center lines? */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|goal_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Target length for output lines */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|max_length
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Maximum length for output lines */
end_comment

begin_decl_stmt
specifier|static
name|int
name|coalesce_spaces_P
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Coalesce multiple whitespace -> ' ' ? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allow_indented_paragraphs
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Can first line have diff. ind.? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|tab_width
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of spaces per tab stop */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|output_tab_width
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ditto, when squashing leading spaces */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sentence_enders
init|=
literal|".?!"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Double-space after these */
end_comment

begin_decl_stmt
specifier|static
name|int
name|grok_mail_headers
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* treat embedded mail headers magically? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|format_troff
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Format troff? */
end_comment

begin_decl_stmt
specifier|static
name|int
name|n_errors
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Number of failed files. Return on exit. */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|output_buffer
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Output line will be built here */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|x
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Horizontal position in output line */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|x0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Ditto, ignoring leading whitespace */
end_comment

begin_decl_stmt
specifier|static
name|size_t
name|pending_spaces
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Spaces to add before next word */
end_comment

begin_decl_stmt
specifier|static
name|int
name|output_in_paragraph
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Any of current para written out yet? */
end_comment

begin_comment
comment|/* Prototypes */
end_comment

begin_function_decl
specifier|static
name|void
name|process_named_file
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process_stream
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|indent_length
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|might_be_header
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|new_paragraph
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_word
parameter_list|(
name|size_t
parameter_list|,
name|size_t
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|output_indent
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|center_stream
parameter_list|(
name|FILE
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|get_line
parameter_list|(
name|FILE
modifier|*
parameter_list|,
name|size_t
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|XMALLOC
parameter_list|(
name|x
parameter_list|)
value|xrealloc(0,x)
end_define

begin_comment
comment|/* Here is perhaps the right place to mention that this code is  * all in top-down order. Hence, |main| comes first.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
comment|/* used for |getopt| processing */
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_CTYPE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* 1. Grok parameters. */
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"0123456789cd:hl:mnpst:w:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'c'
case|:
name|centerP
operator|=
literal|1
expr_stmt|;
name|format_troff
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'d'
case|:
name|sentence_enders
operator|=
name|optarg
expr_stmt|;
continue|continue;
case|case
literal|'l'
case|:
name|output_tab_width
operator|=
name|get_nonnegative
argument_list|(
name|optarg
argument_list|,
literal|"output tab width must be non-negative"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'m'
case|:
name|grok_mail_headers
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'n'
case|:
name|format_troff
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'p'
case|:
name|allow_indented_paragraphs
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'s'
case|:
name|coalesce_spaces_P
operator|=
literal|1
expr_stmt|;
continue|continue;
case|case
literal|'t'
case|:
name|tab_width
operator|=
name|get_positive
argument_list|(
name|optarg
argument_list|,
literal|"tab width must be positive"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
continue|continue;
case|case
literal|'w'
case|:
name|goal_length
operator|=
name|get_positive
argument_list|(
name|optarg
argument_list|,
literal|"width must be positive"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|max_length
operator|=
name|goal_length
expr_stmt|;
continue|continue;
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
comment|/* XXX  this is not a stylistically approved use of getopt() */
if|if
condition|(
name|goal_length
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|argv
index|[
name|optind
operator|-
literal|1
index|]
expr_stmt|;
if|if
condition|(
name|p
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|p
index|[
literal|1
index|]
operator|==
name|ch
operator|&&
operator|!
name|p
index|[
literal|2
index|]
condition|)
name|goal_length
operator|=
name|get_positive
argument_list|(
operator|++
name|p
argument_list|,
literal|"width must be nonzero"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|goal_length
operator|=
name|get_positive
argument_list|(
name|argv
index|[
name|optind
index|]
operator|+
literal|1
argument_list|,
literal|"width must be nonzero"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|max_length
operator|=
name|goal_length
expr_stmt|;
block|}
continue|continue;
case|case
literal|'h'
case|:
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage:   fmt [-cmps] [-d chars] [-l num] [-t num]\n"
literal|"             [-w width | -width | goal [maximum]] [file ...]\n"
literal|"Options: -c     center each line instead of formatting\n"
literal|"         -d<chars> double-space after<chars> at line end\n"
literal|"         -l<n> turn each<n> spaces at start of line into a tab\n"
literal|"         -m     try to make sure mail header lines stay separate\n"
literal|"         -n     format lines beginning with a dot\n"
literal|"         -p     allow indented paragraphs\n"
literal|"         -s     coalesce whitespace inside lines\n"
literal|"         -t<n> have tabs every<n> columns\n"
literal|"         -w<n> set maximum width to<n>\n"
literal|"         goal   set target width to goal\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|ch
operator|==
literal|'h'
condition|?
literal|0
else|:
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
comment|/* [ goal [ maximum ] ] */
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
name|goal_length
operator|==
literal|0
operator|&&
operator|(
name|goal_length
operator|=
name|get_positive
argument_list|(
operator|*
name|argv
argument_list|,
literal|"goal length must be positive"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
operator|&&
operator|(
name|max_length
operator|=
name|get_positive
argument_list|(
operator|*
name|argv
argument_list|,
literal|"max length must be positive"
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
if|if
condition|(
name|max_length
operator|<
name|goal_length
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"max length must be>= goal length"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|goal_length
operator|==
literal|0
condition|)
name|goal_length
operator|=
literal|65
expr_stmt|;
if|if
condition|(
name|max_length
operator|==
literal|0
condition|)
name|max_length
operator|=
name|goal_length
operator|+
literal|10
expr_stmt|;
name|output_buffer
operator|=
name|XMALLOC
argument_list|(
name|max_length
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* really needn't be longer */
comment|/* 2. Process files. */
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
name|process_named_file
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|process_stream
argument_list|(
name|stdin
argument_list|,
literal|"standard input"
argument_list|)
expr_stmt|;
block|}
comment|/* We're done. */
return|return
name|n_errors
condition|?
name|EX_NOINPUT
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Process a single file, given its name.  */
end_comment

begin_function
specifier|static
name|void
name|process_named_file
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|FILE
modifier|*
name|f
init|=
name|fopen
argument_list|(
name|name
argument_list|,
literal|"r"
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|f
condition|)
block|{
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|++
name|n_errors
expr_stmt|;
block|}
else|else
block|{
name|process_stream
argument_list|(
name|f
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Types of mail header continuation lines:  */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|hdr_ParagraphStart
init|=
operator|-
literal|1
block|,
name|hdr_NonHeader
init|=
literal|0
block|,
name|hdr_Header
init|=
literal|1
block|,
name|hdr_Continuation
init|=
literal|2
block|}
name|HdrType
typedef|;
end_typedef

begin_comment
comment|/* Process a stream. This is where the real work happens,  * except that centering is handled separately.  */
end_comment

begin_function
specifier|static
name|void
name|process_stream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|size_t
name|last_indent
init|=
name|SILLY
decl_stmt|;
comment|/* how many spaces in last indent? */
name|size_t
name|para_line_number
init|=
literal|0
decl_stmt|;
comment|/* how many lines already read in this para? */
name|size_t
name|first_indent
init|=
name|SILLY
decl_stmt|;
comment|/* indentation of line 0 of paragraph */
name|HdrType
name|prev_header_type
init|=
name|hdr_ParagraphStart
decl_stmt|;
comment|/* ^-- header_type of previous line; -1 at para start */
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|length
decl_stmt|;
if|if
condition|(
name|centerP
condition|)
block|{
name|center_stream
argument_list|(
name|stream
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return;
block|}
while|while
condition|(
operator|(
name|line
operator|=
name|get_line
argument_list|(
name|stream
argument_list|,
operator|&
name|length
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|size_t
name|np
init|=
name|indent_length
argument_list|(
name|line
argument_list|,
name|length
argument_list|)
decl_stmt|;
block|{
name|HdrType
name|header_type
init|=
name|hdr_NonHeader
decl_stmt|;
if|if
condition|(
name|grok_mail_headers
operator|&&
name|prev_header_type
operator|!=
name|hdr_NonHeader
condition|)
block|{
if|if
condition|(
name|np
operator|==
literal|0
operator|&&
name|might_be_header
argument_list|(
name|line
argument_list|)
condition|)
name|header_type
operator|=
name|hdr_Header
expr_stmt|;
elseif|else
if|if
condition|(
name|np
operator|>
literal|0
operator|&&
name|prev_header_type
operator|>
name|hdr_NonHeader
condition|)
name|header_type
operator|=
name|hdr_Continuation
expr_stmt|;
block|}
comment|/* We need a new paragraph if and only if:        *   this line is blank,        *   OR it's a troff request (and we don't format troff),        *   OR it's a mail header,        *   OR it's not a mail header AND the last line was one,        *   OR the indentation has changed        *      AND the line isn't a mail header continuation line        *      AND this isn't the second line of an indented paragraph.        */
if|if
condition|(
name|length
operator|==
literal|0
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|format_troff
operator|)
operator|||
name|header_type
operator|==
name|hdr_Header
operator|||
operator|(
name|header_type
operator|==
name|hdr_NonHeader
operator|&&
name|prev_header_type
operator|>
name|hdr_NonHeader
operator|)
operator|||
operator|(
name|np
operator|!=
name|last_indent
operator|&&
name|header_type
operator|!=
name|hdr_Continuation
operator|&&
operator|(
operator|!
name|allow_indented_paragraphs
operator|||
name|para_line_number
operator|!=
literal|1
operator|)
operator|)
condition|)
block|{
name|new_paragraph
argument_list|(
name|output_in_paragraph
condition|?
name|last_indent
else|:
name|first_indent
argument_list|,
name|np
argument_list|)
expr_stmt|;
name|para_line_number
operator|=
literal|0
expr_stmt|;
name|first_indent
operator|=
name|np
expr_stmt|;
name|last_indent
operator|=
name|np
expr_stmt|;
if|if
condition|(
name|header_type
operator|==
name|hdr_Header
condition|)
name|last_indent
operator|=
literal|2
expr_stmt|;
comment|/* for cont. lines */
if|if
condition|(
name|length
operator|==
literal|0
operator|||
operator|(
name|line
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|format_troff
operator|)
condition|)
block|{
if|if
condition|(
name|length
operator|==
literal|0
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
operator|(
name|int
operator|)
name|length
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|prev_header_type
operator|=
name|hdr_ParagraphStart
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
comment|/* If this is an indented paragraph other than a mail header          * continuation, set |last_indent|.          */
if|if
condition|(
name|np
operator|!=
name|last_indent
operator|&&
name|header_type
operator|!=
name|hdr_Continuation
condition|)
name|last_indent
operator|=
name|np
expr_stmt|;
block|}
name|prev_header_type
operator|=
name|header_type
expr_stmt|;
block|}
block|{
name|size_t
name|n
init|=
name|np
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|length
condition|)
block|{
comment|/* Find word end and count spaces after it */
name|size_t
name|word_length
init|=
literal|0
decl_stmt|,
name|space_length
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|+
name|word_length
operator|<
name|length
operator|&&
name|line
index|[
name|n
operator|+
name|word_length
index|]
operator|!=
literal|' '
condition|)
operator|++
name|word_length
expr_stmt|;
name|space_length
operator|=
name|word_length
expr_stmt|;
while|while
condition|(
name|n
operator|+
name|space_length
operator|<
name|length
operator|&&
name|line
index|[
name|n
operator|+
name|space_length
index|]
operator|==
literal|' '
condition|)
operator|++
name|space_length
expr_stmt|;
comment|/* Send the word to the output machinery. */
name|output_word
argument_list|(
name|first_indent
argument_list|,
name|last_indent
argument_list|,
name|line
operator|+
name|n
argument_list|,
name|word_length
argument_list|,
name|space_length
operator|-
name|word_length
argument_list|)
expr_stmt|;
name|n
operator|+=
name|space_length
expr_stmt|;
block|}
block|}
operator|++
name|para_line_number
expr_stmt|;
block|}
name|new_paragraph
argument_list|(
name|output_in_paragraph
condition|?
name|last_indent
else|:
name|first_indent
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|++
name|n_errors
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* How long is the indent on this line?  */
end_comment

begin_function
specifier|static
name|size_t
name|indent_length
parameter_list|(
specifier|const
name|char
modifier|*
name|line
parameter_list|,
name|size_t
name|length
parameter_list|)
block|{
name|size_t
name|n
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|n
operator|<
name|length
operator|&&
operator|*
name|line
operator|++
operator|==
literal|' '
condition|)
operator|++
name|n
expr_stmt|;
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/* Might this line be a mail header?  * We deem a line to be a possible header if it matches the  * Perl regexp /^[A-Z][-A-Za-z0-9]*:\s/. This is *not* the same  * as in RFC whatever-number-it-is; we want to be gratuitously  * conservative to avoid mangling ordinary civilised text.  */
end_comment

begin_function
specifier|static
name|int
name|might_be_header
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|line
parameter_list|)
block|{
if|if
condition|(
operator|!
name|isupper
argument_list|(
operator|*
name|line
operator|++
argument_list|)
condition|)
return|return
literal|0
return|;
while|while
condition|(
operator|*
name|line
operator|&&
operator|(
name|isalnum
argument_list|(
operator|*
name|line
argument_list|)
operator|||
operator|*
name|line
operator|==
literal|'-'
operator|)
condition|)
operator|++
name|line
expr_stmt|;
return|return
operator|(
operator|*
name|line
operator|==
literal|':'
operator|&&
name|isspace
argument_list|(
name|line
index|[
literal|1
index|]
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Begin a new paragraph with an indent of |indent| spaces.  */
end_comment

begin_function
specifier|static
name|void
name|new_paragraph
parameter_list|(
name|size_t
name|old_indent
parameter_list|,
name|size_t
name|indent
parameter_list|)
block|{
if|if
condition|(
name|x0
condition|)
block|{
if|if
condition|(
name|old_indent
operator|>
literal|0
condition|)
name|output_indent
argument_list|(
name|old_indent
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|output_buffer
argument_list|,
literal|1
argument_list|,
name|x0
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|x
operator|=
name|indent
expr_stmt|;
name|x0
operator|=
literal|0
expr_stmt|;
name|pending_spaces
operator|=
literal|0
expr_stmt|;
name|output_in_paragraph
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output spaces or tabs for leading indentation.  */
end_comment

begin_function
specifier|static
name|void
name|output_indent
parameter_list|(
name|size_t
name|n_spaces
parameter_list|)
block|{
if|if
condition|(
name|output_tab_width
condition|)
block|{
while|while
condition|(
name|n_spaces
operator|>=
name|output_tab_width
condition|)
block|{
name|putchar
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|n_spaces
operator|-=
name|output_tab_width
expr_stmt|;
block|}
block|}
while|while
condition|(
name|n_spaces
operator|--
operator|>
literal|0
condition|)
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output a single word, or add it to the buffer.  * indent0 and indent1 are the indents to use on the first and subsequent  * lines of a paragraph. They'll often be the same, of course.  */
end_comment

begin_function
specifier|static
name|void
name|output_word
parameter_list|(
name|size_t
name|indent0
parameter_list|,
name|size_t
name|indent1
parameter_list|,
specifier|const
name|char
modifier|*
name|word
parameter_list|,
name|size_t
name|length
parameter_list|,
name|size_t
name|spaces
parameter_list|)
block|{
name|size_t
name|new_x
init|=
name|x
operator|+
name|pending_spaces
operator|+
name|length
decl_stmt|;
name|size_t
name|indent
init|=
name|output_in_paragraph
condition|?
name|indent1
else|:
name|indent0
decl_stmt|;
comment|/* If either |spaces==0| (at end of line) or |coalesce_spaces_P|    * (squashing internal whitespace), then add just one space;    * except that if the last character was a sentence-ender we    * actually add two spaces.    */
if|if
condition|(
name|coalesce_spaces_P
operator|||
name|spaces
operator|==
literal|0
condition|)
name|spaces
operator|=
name|strchr
argument_list|(
name|sentence_enders
argument_list|,
name|word
index|[
name|length
operator|-
literal|1
index|]
argument_list|)
condition|?
literal|2
else|:
literal|1
expr_stmt|;
if|if
condition|(
name|new_x
operator|<=
name|goal_length
condition|)
block|{
comment|/* After adding the word we still aren't at the goal length,      * so clearly we add it to the buffer rather than outputing it.      */
name|memset
argument_list|(
name|output_buffer
operator|+
name|x0
argument_list|,
literal|' '
argument_list|,
name|pending_spaces
argument_list|)
expr_stmt|;
name|x0
operator|+=
name|pending_spaces
expr_stmt|;
name|x
operator|+=
name|pending_spaces
expr_stmt|;
name|memcpy
argument_list|(
name|output_buffer
operator|+
name|x0
argument_list|,
name|word
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|x0
operator|+=
name|length
expr_stmt|;
name|x
operator|+=
name|length
expr_stmt|;
name|pending_spaces
operator|=
name|spaces
expr_stmt|;
block|}
else|else
block|{
comment|/* Adding the word takes us past the goal. Print the line-so-far,      * and the word too iff either (1) the lsf is empty or (2) that      * makes us nearer the goal but doesn't take us over the limit,      * or (3) the word on its own takes us over the limit.      * In case (3) we put a newline in between.      */
if|if
condition|(
name|indent
operator|>
literal|0
condition|)
name|output_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|fwrite
argument_list|(
name|output_buffer
argument_list|,
literal|1
argument_list|,
name|x0
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|x0
operator|==
literal|0
operator|||
operator|(
name|new_x
operator|<=
name|max_length
operator|&&
name|new_x
operator|-
name|goal_length
operator|<=
name|goal_length
operator|-
name|x
operator|)
condition|)
block|{
name|printf
argument_list|(
literal|"%*s"
argument_list|,
operator|(
name|int
operator|)
name|pending_spaces
argument_list|,
literal|""
argument_list|)
expr_stmt|;
goto|goto
name|write_out_word
goto|;
block|}
else|else
block|{
comment|/* If the word takes us over the limit on its own, just        * spit it out and don't bother buffering it.        */
if|if
condition|(
name|indent
operator|+
name|length
operator|>
name|max_length
condition|)
block|{
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|indent
operator|>
literal|0
condition|)
name|output_indent
argument_list|(
name|indent
argument_list|)
expr_stmt|;
name|write_out_word
label|:
name|fwrite
argument_list|(
name|word
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|x0
operator|=
literal|0
expr_stmt|;
name|x
operator|=
name|indent1
expr_stmt|;
name|pending_spaces
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
name|memcpy
argument_list|(
name|output_buffer
argument_list|,
name|word
argument_list|,
name|length
argument_list|)
expr_stmt|;
name|x0
operator|=
name|length
expr_stmt|;
name|x
operator|=
name|length
operator|+
name|indent1
expr_stmt|;
name|pending_spaces
operator|=
name|spaces
expr_stmt|;
block|}
block|}
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|output_in_paragraph
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Process a stream, but just center its lines rather than trying to  * format them neatly.  */
end_comment

begin_function
specifier|static
name|void
name|center_stream
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
specifier|const
name|char
modifier|*
name|name
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|length
decl_stmt|;
while|while
condition|(
operator|(
name|line
operator|=
name|get_line
argument_list|(
name|stream
argument_list|,
operator|&
name|length
argument_list|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|size_t
name|l
init|=
name|length
decl_stmt|;
while|while
condition|(
name|l
operator|>
literal|0
operator|&&
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
operator|++
name|line
expr_stmt|;
operator|--
name|l
expr_stmt|;
block|}
name|length
operator|=
name|l
expr_stmt|;
while|while
condition|(
name|l
operator|<
name|goal_length
condition|)
block|{
name|putchar
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|l
operator|+=
literal|2
expr_stmt|;
block|}
name|fwrite
argument_list|(
name|line
argument_list|,
literal|1
argument_list|,
name|length
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|stream
argument_list|)
condition|)
block|{
name|perror
argument_list|(
name|name
argument_list|)
expr_stmt|;
operator|++
name|n_errors
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Get a single line from a stream. Expand tabs, strip control  * characters and trailing whitespace, and handle backspaces.  * Return the address of the buffer containing the line, and  * put the length of the line in |lengthp|.  * This can cope with arbitrarily long lines, and with lines  * without terminating \n.  * If there are no characters left or an error happens, we  * return 0.  * Don't confuse |spaces_pending| here with the global  * |pending_spaces|.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|get_line
parameter_list|(
name|FILE
modifier|*
name|stream
parameter_list|,
name|size_t
modifier|*
name|lengthp
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|length
init|=
literal|0
decl_stmt|;
name|size_t
name|len
init|=
literal|0
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|size_t
name|spaces_pending
init|=
literal|0
decl_stmt|;
name|int
name|troff
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
block|{
name|length
operator|=
literal|100
expr_stmt|;
name|buf
operator|=
name|XMALLOC
argument_list|(
name|length
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|stream
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|ch
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|len
operator|+
name|spaces_pending
operator|==
literal|0
operator|&&
name|ch
operator|==
literal|'.'
operator|&&
operator|!
name|format_troff
condition|)
name|troff
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|ch
operator|==
literal|' '
condition|)
operator|++
name|spaces_pending
expr_stmt|;
elseif|else
if|if
condition|(
name|troff
operator|||
name|isprint
argument_list|(
name|ch
argument_list|)
condition|)
block|{
while|while
condition|(
name|len
operator|+
name|spaces_pending
operator|>=
name|length
condition|)
block|{
name|length
operator|*=
literal|2
expr_stmt|;
name|buf
operator|=
name|xrealloc
argument_list|(
name|buf
argument_list|,
name|length
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|spaces_pending
operator|>
literal|0
condition|)
block|{
operator|--
name|spaces_pending
expr_stmt|;
name|buf
index|[
name|len
operator|++
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\t'
condition|)
name|spaces_pending
operator|+=
name|tab_width
operator|-
operator|(
name|len
operator|+
name|spaces_pending
operator|)
operator|%
name|tab_width
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\b'
condition|)
block|{
if|if
condition|(
name|len
condition|)
operator|--
name|len
expr_stmt|;
block|}
block|}
operator|*
name|lengthp
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|len
operator|>
literal|0
operator|||
name|ch
operator|!=
name|EOF
operator|)
condition|?
name|buf
else|:
literal|0
return|;
block|}
end_function

begin_comment
comment|/* (Re)allocate some memory, exiting with an error if we can't.  */
end_comment

begin_function
specifier|static
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|nbytes
parameter_list|)
block|{
name|void
modifier|*
name|p
init|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|nbytes
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|errx
argument_list|(
name|EX_OSERR
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
return|return
name|p
return|;
block|}
end_function

end_unit

