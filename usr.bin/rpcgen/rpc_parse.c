begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)rpc_parse.c	2.1 88/08/01 4.0 RPCSRC */
end_comment

begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *  * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *  * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_comment
comment|/*static char sccsid[] = "from: @(#)rpc_parse.c 1.4 87/04/28 (C) 1987 SMI";*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * rpc_parse.c, Parser for the RPC protocol compiler  * Copyright (C) 1987 Sun Microsystems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"rpc_util.h"
end_include

begin_include
include|#
directive|include
file|"rpc_scan.h"
end_include

begin_include
include|#
directive|include
file|"rpc_parse.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|isdefined
argument_list|()
decl_stmt|,
name|def_struct
argument_list|()
decl_stmt|,
name|def_program
argument_list|()
decl_stmt|,
name|def_enum
argument_list|()
decl_stmt|,
name|def_const
argument_list|()
decl_stmt|,
name|def_union
argument_list|()
decl_stmt|,
name|def_typedef
argument_list|()
decl_stmt|,
name|get_declaration
argument_list|()
decl_stmt|,
name|get_type
argument_list|()
decl_stmt|,
name|unsigned_dec
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * return the next definition you see  */
end_comment

begin_function
name|definition
modifier|*
name|get_definition
parameter_list|()
block|{
name|definition
modifier|*
name|defp
decl_stmt|;
name|token
name|tok
decl_stmt|;
name|defp
operator|=
name|ALLOC
argument_list|(
name|definition
argument_list|)
expr_stmt|;
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
operator|.
name|kind
condition|)
block|{
case|case
name|TOK_STRUCT
case|:
name|def_struct
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_UNION
case|:
name|def_union
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_TYPEDEF
case|:
name|def_typedef
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_ENUM
case|:
name|def_enum
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_PROGRAM
case|:
name|def_program
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_CONST
case|:
name|def_const
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_EOF
case|:
return|return
operator|(
name|NULL
operator|)
return|;
break|break;
default|default:
name|error
argument_list|(
literal|"definition keyword expected"
argument_list|)
expr_stmt|;
block|}
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|isdefined
argument_list|(
name|defp
argument_list|)
expr_stmt|;
return|return
operator|(
name|defp
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|isdefined
argument_list|(
argument|defp
argument_list|)
name|definition
operator|*
name|defp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|STOREVAL
argument_list|(
operator|&
name|defined
argument_list|,
name|defp
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|def_struct
argument_list|(
argument|defp
argument_list|)
name|definition
operator|*
name|defp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
name|declaration
name|dec
decl_stmt|;
name|decl_list
modifier|*
name|decls
decl_stmt|;
name|decl_list
modifier|*
modifier|*
name|tailp
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_STRUCT
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|tailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|st
operator|.
name|decls
expr_stmt|;
do|do
block|{
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_STRUCT
argument_list|)
expr_stmt|;
name|decls
operator|=
name|ALLOC
argument_list|(
name|decl_list
argument_list|)
expr_stmt|;
name|decls
operator|->
name|decl
operator|=
name|dec
expr_stmt|;
operator|*
name|tailp
operator|=
name|decls
expr_stmt|;
name|tailp
operator|=
operator|&
name|decls
operator|->
name|next
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|peek
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|!=
name|TOK_RBRACE
condition|)
do|;
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|tailp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|def_program
argument_list|(
argument|defp
argument_list|)
name|definition
operator|*
name|defp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
name|version_list
modifier|*
name|vlist
decl_stmt|;
name|version_list
modifier|*
modifier|*
name|vtailp
decl_stmt|;
name|proc_list
modifier|*
name|plist
decl_stmt|;
name|proc_list
modifier|*
modifier|*
name|ptailp
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_PROGRAM
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|vtailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|pr
operator|.
name|versions
expr_stmt|;
name|scan
argument_list|(
name|TOK_VERSION
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
do|do
block|{
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|vlist
operator|=
name|ALLOC
argument_list|(
name|version_list
argument_list|)
expr_stmt|;
name|vlist
operator|->
name|vers_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|ptailp
operator|=
operator|&
name|vlist
operator|->
name|procs
expr_stmt|;
do|do
block|{
name|plist
operator|=
name|ALLOC
argument_list|(
name|proc_list
argument_list|)
expr_stmt|;
name|get_type
argument_list|(
operator|&
name|plist
operator|->
name|res_prefix
argument_list|,
operator|&
name|plist
operator|->
name|res_type
argument_list|,
name|DEF_PROGRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|plist
operator|->
name|res_type
argument_list|,
literal|"opaque"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"illegal result type"
argument_list|)
expr_stmt|;
block|}
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|plist
operator|->
name|proc_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|get_type
argument_list|(
operator|&
name|plist
operator|->
name|arg_prefix
argument_list|,
operator|&
name|plist
operator|->
name|arg_type
argument_list|,
name|DEF_PROGRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|plist
operator|->
name|arg_type
argument_list|,
literal|"opaque"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"illegal argument type"
argument_list|)
expr_stmt|;
block|}
name|scan
argument_list|(
name|TOK_RPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|plist
operator|->
name|proc_num
operator|=
name|tok
operator|.
name|str
expr_stmt|;
operator|*
name|ptailp
operator|=
name|plist
expr_stmt|;
name|ptailp
operator|=
operator|&
name|plist
operator|->
name|next
expr_stmt|;
name|peek
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|!=
name|TOK_RBRACE
condition|)
do|;
operator|*
name|ptailp
operator|=
name|NULL
expr_stmt|;
operator|*
name|vtailp
operator|=
name|vlist
expr_stmt|;
name|vtailp
operator|=
operator|&
name|vlist
operator|->
name|next
expr_stmt|;
name|scan
argument_list|(
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|vlist
operator|->
name|vers_num
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan2
argument_list|(
name|TOK_VERSION
argument_list|,
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_VERSION
condition|)
do|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|pr
operator|.
name|prog_num
operator|=
name|tok
operator|.
name|str
expr_stmt|;
operator|*
name|vtailp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|def_enum
argument_list|(
argument|defp
argument_list|)
name|definition
operator|*
name|defp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
name|enumval_list
modifier|*
name|elist
decl_stmt|;
name|enumval_list
modifier|*
modifier|*
name|tailp
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_ENUM
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|tailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|en
operator|.
name|vals
expr_stmt|;
do|do
block|{
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|elist
operator|=
name|ALLOC
argument_list|(
name|enumval_list
argument_list|)
expr_stmt|;
name|elist
operator|->
name|name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|elist
operator|->
name|assignment
operator|=
name|NULL
expr_stmt|;
name|scan3
argument_list|(
name|TOK_COMMA
argument_list|,
name|TOK_RBRACE
argument_list|,
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_EQUAL
condition|)
block|{
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|elist
operator|->
name|assignment
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan2
argument_list|(
name|TOK_COMMA
argument_list|,
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
operator|*
name|tailp
operator|=
name|elist
expr_stmt|;
name|tailp
operator|=
operator|&
name|elist
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|!=
name|TOK_RBRACE
condition|)
do|;
operator|*
name|tailp
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|def_const
argument_list|(
argument|defp
argument_list|)
name|definition
operator|*
name|defp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_CONST
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan2
argument_list|(
name|TOK_IDENT
argument_list|,
name|TOK_STRCONST
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|co
operator|=
name|tok
operator|.
name|str
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|def_union
argument_list|(
argument|defp
argument_list|)
name|definition
operator|*
name|defp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
name|declaration
name|dec
decl_stmt|;
name|case_list
modifier|*
name|cases
decl_stmt|;
name|case_list
modifier|*
modifier|*
name|tailp
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_UNION
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_SWITCH
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_LPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_UNION
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|enum_decl
operator|=
name|dec
expr_stmt|;
name|tailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|cases
expr_stmt|;
name|scan
argument_list|(
name|TOK_RPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_CASE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
while|while
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_CASE
condition|)
block|{
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|cases
operator|=
name|ALLOC
argument_list|(
name|case_list
argument_list|)
expr_stmt|;
name|cases
operator|->
name|case_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_COLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_UNION
argument_list|)
expr_stmt|;
name|cases
operator|->
name|case_decl
operator|=
name|dec
expr_stmt|;
operator|*
name|tailp
operator|=
name|cases
expr_stmt|;
name|tailp
operator|=
operator|&
name|cases
operator|->
name|next
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan3
argument_list|(
name|TOK_CASE
argument_list|,
name|TOK_DEFAULT
argument_list|,
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
operator|*
name|tailp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_DEFAULT
condition|)
block|{
name|scan
argument_list|(
name|TOK_COLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_UNION
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|default_decl
operator|=
name|ALLOC
argument_list|(
name|declaration
argument_list|)
expr_stmt|;
operator|*
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|default_decl
operator|=
name|dec
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|default_decl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|def_typedef
argument_list|(
argument|defp
argument_list|)
name|definition
operator|*
name|defp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|declaration
name|dec
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_TYPEDEF
expr_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_TYPEDEF
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|dec
operator|.
name|name
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|old_prefix
operator|=
name|dec
operator|.
name|prefix
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
operator|=
name|dec
operator|.
name|type
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|rel
operator|=
name|dec
operator|.
name|rel
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|array_max
operator|=
name|dec
operator|.
name|array_max
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|get_declaration
argument_list|(
argument|dec
argument_list|,
argument|dkind
argument_list|)
name|declaration
operator|*
name|dec
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|defkind
name|dkind
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
name|get_type
argument_list|(
operator|&
name|dec
operator|->
name|prefix
argument_list|,
operator|&
name|dec
operator|->
name|type
argument_list|,
name|dkind
argument_list|)
expr_stmt|;
name|dec
operator|->
name|rel
operator|=
name|REL_ALIAS
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"void"
argument_list|)
condition|)
block|{
return|return;
block|}
name|scan2
argument_list|(
name|TOK_STAR
argument_list|,
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_STAR
condition|)
block|{
name|dec
operator|->
name|rel
operator|=
name|REL_POINTER
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_LBRACKET
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|==
name|REL_POINTER
condition|)
block|{
name|error
argument_list|(
literal|"no array-of-pointer declarations -- use typedef"
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|rel
operator|=
name|REL_VECTOR
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|dec
operator|->
name|array_max
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_RBRACKET
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_LANGLE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|==
name|REL_POINTER
condition|)
block|{
name|error
argument_list|(
literal|"no array-of-pointer declarations -- use typedef"
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|rel
operator|=
name|REL_ARRAY
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_RANGLE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
name|dec
operator|->
name|array_max
operator|=
literal|"~0"
expr_stmt|;
comment|/* unspecified size, use max */
block|}
else|else
block|{
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|dec
operator|->
name|array_max
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_RANGLE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"opaque"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|!=
name|REL_ARRAY
operator|&&
name|dec
operator|->
name|rel
operator|!=
name|REL_VECTOR
condition|)
block|{
name|error
argument_list|(
literal|"array declaration expected"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|!=
name|REL_ARRAY
condition|)
block|{
name|error
argument_list|(
literal|"variable-length array declaration expected"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|get_type
argument_list|(
argument|prefixp
argument_list|,
argument|typep
argument_list|,
argument|dkind
argument_list|)
name|char
operator|*
operator|*
name|prefixp
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|typep
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|defkind
name|dkind
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
operator|*
name|prefixp
operator|=
name|NULL
expr_stmt|;
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
operator|.
name|kind
condition|)
block|{
case|case
name|TOK_IDENT
case|:
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|TOK_STRUCT
case|:
case|case
name|TOK_ENUM
case|:
case|case
name|TOK_UNION
case|:
operator|*
name|prefixp
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|TOK_UNSIGNED
case|:
name|unsigned_dec
argument_list|(
name|typep
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_SHORT
case|:
operator|*
name|typep
operator|=
literal|"short"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_LONG
case|:
operator|*
name|typep
operator|=
literal|"long"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_VOID
case|:
if|if
condition|(
name|dkind
operator|!=
name|DEF_UNION
operator|&&
name|dkind
operator|!=
name|DEF_PROGRAM
condition|)
block|{
name|error
argument_list|(
literal|"voids allowed only inside union and program definitions"
argument_list|)
expr_stmt|;
block|}
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|TOK_STRING
case|:
case|case
name|TOK_OPAQUE
case|:
case|case
name|TOK_CHAR
case|:
case|case
name|TOK_INT
case|:
case|case
name|TOK_FLOAT
case|:
case|case
name|TOK_DOUBLE
case|:
case|case
name|TOK_BOOL
case|:
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"expected type specifier"
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_expr_stmt
specifier|static
name|unsigned_dec
argument_list|(
argument|typep
argument_list|)
name|char
operator|*
operator|*
name|typep
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|token
name|tok
decl_stmt|;
name|peek
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
operator|.
name|kind
condition|)
block|{
case|case
name|TOK_CHAR
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_char"
expr_stmt|;
break|break;
case|case
name|TOK_SHORT
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_short"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_LONG
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_long"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_INT
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_int"
expr_stmt|;
break|break;
default|default:
operator|*
name|typep
operator|=
literal|"u_int"
expr_stmt|;
break|break;
block|}
block|}
end_block

end_unit

