begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *  * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *  * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_empty
empty|#ident	"@(#)rpc_parse.c	1.12	93/07/05 SMI"
end_empty

begin_endif
unit|static char sccsid[] = "@(#)rpc_parse.c 1.8 89/02/22 (C) 1987 SMI";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * rpc_parse.c, Parser for the RPC protocol compiler  * Copyright (C) 1987 Sun Microsystems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"rpc/types.h"
end_include

begin_include
include|#
directive|include
file|"rpc_parse.h"
end_include

begin_include
include|#
directive|include
file|"rpc_scan.h"
end_include

begin_include
include|#
directive|include
file|"rpc_util.h"
end_include

begin_define
define|#
directive|define
name|ARGNAME
value|"arg"
end_define

begin_function_decl
specifier|static
name|void
name|isdefined
parameter_list|(
name|definition
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_struct
parameter_list|(
name|definition
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_program
parameter_list|(
name|definition
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_enum
parameter_list|(
name|definition
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_const
parameter_list|(
name|definition
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_union
parameter_list|(
name|definition
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|def_typedef
parameter_list|(
name|definition
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_declaration
parameter_list|(
name|declaration
modifier|*
parameter_list|,
name|defkind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_prog_declaration
parameter_list|(
name|declaration
modifier|*
parameter_list|,
name|defkind
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_type
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|defkind
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unsigned_dec
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * return the next definition you see  */
end_comment

begin_function
name|definition
modifier|*
name|get_definition
parameter_list|(
name|void
parameter_list|)
block|{
name|definition
modifier|*
name|defp
decl_stmt|;
name|token
name|tok
decl_stmt|;
name|defp
operator|=
name|XALLOC
argument_list|(
name|definition
argument_list|)
expr_stmt|;
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
operator|.
name|kind
condition|)
block|{
case|case
name|TOK_STRUCT
case|:
name|def_struct
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_UNION
case|:
name|def_union
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_TYPEDEF
case|:
name|def_typedef
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_ENUM
case|:
name|def_enum
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_PROGRAM
case|:
name|def_program
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_CONST
case|:
name|def_const
argument_list|(
name|defp
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_EOF
case|:
return|return
operator|(
name|NULL
operator|)
return|;
default|default:
name|error
argument_list|(
literal|"definition keyword expected"
argument_list|)
expr_stmt|;
block|}
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|isdefined
argument_list|(
name|defp
argument_list|)
expr_stmt|;
return|return
operator|(
name|defp
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|isdefined
parameter_list|(
name|definition
modifier|*
name|defp
parameter_list|)
block|{
name|STOREVAL
argument_list|(
operator|&
name|defined
argument_list|,
name|defp
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|def_struct
parameter_list|(
name|definition
modifier|*
name|defp
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|declaration
name|dec
decl_stmt|;
name|decl_list
modifier|*
name|decls
decl_stmt|;
name|decl_list
modifier|*
modifier|*
name|tailp
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_STRUCT
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|tailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|st
operator|.
name|decls
expr_stmt|;
do|do
block|{
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_STRUCT
argument_list|)
expr_stmt|;
name|decls
operator|=
name|XALLOC
argument_list|(
name|decl_list
argument_list|)
expr_stmt|;
name|decls
operator|->
name|decl
operator|=
name|dec
expr_stmt|;
operator|*
name|tailp
operator|=
name|decls
expr_stmt|;
name|tailp
operator|=
operator|&
name|decls
operator|->
name|next
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|peek
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|!=
name|TOK_RBRACE
condition|)
do|;
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|tailp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|def_program
parameter_list|(
name|definition
modifier|*
name|defp
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|declaration
name|dec
decl_stmt|;
name|decl_list
modifier|*
name|decls
decl_stmt|;
name|decl_list
modifier|*
modifier|*
name|tailp
decl_stmt|;
name|version_list
modifier|*
name|vlist
decl_stmt|;
name|version_list
modifier|*
modifier|*
name|vtailp
decl_stmt|;
name|proc_list
modifier|*
name|plist
decl_stmt|;
name|proc_list
modifier|*
modifier|*
name|ptailp
decl_stmt|;
name|int
name|num_args
decl_stmt|;
name|bool_t
name|isvoid
init|=
name|FALSE
decl_stmt|;
comment|/* whether first argument is void */
name|defp
operator|->
name|def_kind
operator|=
name|DEF_PROGRAM
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|vtailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|pr
operator|.
name|versions
expr_stmt|;
name|tailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|st
operator|.
name|decls
expr_stmt|;
name|scan
argument_list|(
name|TOK_VERSION
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
do|do
block|{
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|vlist
operator|=
name|XALLOC
argument_list|(
name|version_list
argument_list|)
expr_stmt|;
name|vlist
operator|->
name|vers_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|ptailp
operator|=
operator|&
name|vlist
operator|->
name|procs
expr_stmt|;
do|do
block|{
comment|/* get result type */
name|plist
operator|=
name|XALLOC
argument_list|(
name|proc_list
argument_list|)
expr_stmt|;
name|get_type
argument_list|(
operator|&
name|plist
operator|->
name|res_prefix
argument_list|,
operator|&
name|plist
operator|->
name|res_type
argument_list|,
name|DEF_PROGRAM
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|plist
operator|->
name|res_type
argument_list|,
literal|"opaque"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"illegal result type"
argument_list|)
expr_stmt|;
block|}
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|plist
operator|->
name|proc_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
comment|/* get args - first one */
name|num_args
operator|=
literal|1
expr_stmt|;
name|isvoid
operator|=
name|FALSE
expr_stmt|;
comment|/* 			 * type of DEF_PROGRAM in the first 			 * get_prog_declaration and DEF_STURCT in the next 			 * allows void as argument if it is the only argument 			 */
name|get_prog_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_PROGRAM
argument_list|,
name|num_args
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|.
name|type
argument_list|,
literal|"void"
argument_list|)
condition|)
name|isvoid
operator|=
name|TRUE
expr_stmt|;
name|decls
operator|=
name|XALLOC
argument_list|(
name|decl_list
argument_list|)
expr_stmt|;
name|plist
operator|->
name|args
operator|.
name|decls
operator|=
name|decls
expr_stmt|;
name|decls
operator|->
name|decl
operator|=
name|dec
expr_stmt|;
name|tailp
operator|=
operator|&
name|decls
operator|->
name|next
expr_stmt|;
comment|/* get args */
while|while
condition|(
name|peekscan
argument_list|(
name|TOK_COMMA
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
name|num_args
operator|++
expr_stmt|;
name|get_prog_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_STRUCT
argument_list|,
name|num_args
argument_list|)
expr_stmt|;
name|decls
operator|=
name|XALLOC
argument_list|(
name|decl_list
argument_list|)
expr_stmt|;
name|decls
operator|->
name|decl
operator|=
name|dec
expr_stmt|;
operator|*
name|tailp
operator|=
name|decls
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|.
name|type
argument_list|,
literal|"void"
argument_list|)
condition|)
name|isvoid
operator|=
name|TRUE
expr_stmt|;
name|tailp
operator|=
operator|&
name|decls
operator|->
name|next
expr_stmt|;
block|}
comment|/* multiple arguments are only allowed in newstyle */
if|if
condition|(
operator|!
name|newstyle
operator|&&
name|num_args
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"only one argument is allowed"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|isvoid
operator|&&
name|num_args
operator|>
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"illegal use of void in program definition"
argument_list|)
expr_stmt|;
block|}
operator|*
name|tailp
operator|=
name|NULL
expr_stmt|;
name|scan
argument_list|(
name|TOK_RPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|plist
operator|->
name|proc_num
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|plist
operator|->
name|arg_num
operator|=
name|num_args
expr_stmt|;
operator|*
name|ptailp
operator|=
name|plist
expr_stmt|;
name|ptailp
operator|=
operator|&
name|plist
operator|->
name|next
expr_stmt|;
name|peek
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|!=
name|TOK_RBRACE
condition|)
do|;
operator|*
name|ptailp
operator|=
name|NULL
expr_stmt|;
operator|*
name|vtailp
operator|=
name|vlist
expr_stmt|;
name|vtailp
operator|=
operator|&
name|vlist
operator|->
name|next
expr_stmt|;
name|scan
argument_list|(
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|vlist
operator|->
name|vers_num
operator|=
name|tok
operator|.
name|str
expr_stmt|;
comment|/* make the argument structure name for each arg */
for|for
control|(
name|plist
operator|=
name|vlist
operator|->
name|procs
init|;
name|plist
operator|!=
name|NULL
condition|;
name|plist
operator|=
name|plist
operator|->
name|next
control|)
block|{
name|plist
operator|->
name|args
operator|.
name|argname
operator|=
name|make_argname
argument_list|(
name|plist
operator|->
name|proc_name
argument_list|,
name|vlist
operator|->
name|vers_num
argument_list|)
expr_stmt|;
comment|/* free the memory ?? */
block|}
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan2
argument_list|(
name|TOK_VERSION
argument_list|,
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_VERSION
condition|)
do|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|pr
operator|.
name|prog_num
operator|=
name|tok
operator|.
name|str
expr_stmt|;
operator|*
name|vtailp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|def_enum
parameter_list|(
name|definition
modifier|*
name|defp
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|enumval_list
modifier|*
name|elist
decl_stmt|;
name|enumval_list
modifier|*
modifier|*
name|tailp
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_ENUM
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|tailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|en
operator|.
name|vals
expr_stmt|;
do|do
block|{
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|elist
operator|=
name|XALLOC
argument_list|(
name|enumval_list
argument_list|)
expr_stmt|;
name|elist
operator|->
name|name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|elist
operator|->
name|assignment
operator|=
name|NULL
expr_stmt|;
name|scan3
argument_list|(
name|TOK_COMMA
argument_list|,
name|TOK_RBRACE
argument_list|,
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_EQUAL
condition|)
block|{
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|elist
operator|->
name|assignment
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan2
argument_list|(
name|TOK_COMMA
argument_list|,
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
operator|*
name|tailp
operator|=
name|elist
expr_stmt|;
name|tailp
operator|=
operator|&
name|elist
operator|->
name|next
expr_stmt|;
block|}
do|while
condition|(
name|tok
operator|.
name|kind
operator|!=
name|TOK_RBRACE
condition|)
do|;
operator|*
name|tailp
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|def_const
parameter_list|(
name|definition
modifier|*
name|defp
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_CONST
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_EQUAL
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan2
argument_list|(
name|TOK_IDENT
argument_list|,
name|TOK_STRCONST
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|co
operator|=
name|tok
operator|.
name|str
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|def_union
parameter_list|(
name|definition
modifier|*
name|defp
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|declaration
name|dec
decl_stmt|;
name|case_list
modifier|*
name|cases
decl_stmt|;
name|case_list
modifier|*
modifier|*
name|tailp
decl_stmt|;
name|int
name|flag
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_UNION
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_SWITCH
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_LPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_UNION
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|enum_decl
operator|=
name|dec
expr_stmt|;
name|tailp
operator|=
operator|&
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|cases
expr_stmt|;
name|scan
argument_list|(
name|TOK_RPAREN
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_LBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_CASE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
while|while
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_CASE
condition|)
block|{
name|scan2
argument_list|(
name|TOK_IDENT
argument_list|,
name|TOK_CHARCONST
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|cases
operator|=
name|XALLOC
argument_list|(
name|case_list
argument_list|)
expr_stmt|;
name|cases
operator|->
name|case_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_COLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
comment|/* now peek at next token */
name|flag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_CASE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
do|do
block|{
name|scan2
argument_list|(
name|TOK_IDENT
argument_list|,
name|TOK_CHARCONST
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|cases
operator|->
name|contflag
operator|=
literal|1
expr_stmt|;
comment|/* continued case statement */
operator|*
name|tailp
operator|=
name|cases
expr_stmt|;
name|tailp
operator|=
operator|&
name|cases
operator|->
name|next
expr_stmt|;
name|cases
operator|=
name|XALLOC
argument_list|(
name|case_list
argument_list|)
expr_stmt|;
name|cases
operator|->
name|case_name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_COLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|peekscan
argument_list|(
name|TOK_CASE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
do|;
block|}
elseif|else
if|if
condition|(
name|flag
condition|)
block|{
operator|*
name|tailp
operator|=
name|cases
expr_stmt|;
name|tailp
operator|=
operator|&
name|cases
operator|->
name|next
expr_stmt|;
name|cases
operator|=
name|XALLOC
argument_list|(
name|case_list
argument_list|)
expr_stmt|;
block|}
empty_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_UNION
argument_list|)
expr_stmt|;
name|cases
operator|->
name|case_decl
operator|=
name|dec
expr_stmt|;
name|cases
operator|->
name|contflag
operator|=
literal|0
expr_stmt|;
comment|/* no continued case statement */
operator|*
name|tailp
operator|=
name|cases
expr_stmt|;
name|tailp
operator|=
operator|&
name|cases
operator|->
name|next
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan3
argument_list|(
name|TOK_CASE
argument_list|,
name|TOK_DEFAULT
argument_list|,
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
operator|*
name|tailp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_DEFAULT
condition|)
block|{
name|scan
argument_list|(
name|TOK_COLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_UNION
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|default_decl
operator|=
name|XALLOC
argument_list|(
name|declaration
argument_list|)
expr_stmt|;
operator|*
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|default_decl
operator|=
name|dec
expr_stmt|;
name|scan
argument_list|(
name|TOK_SEMICOLON
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
name|scan
argument_list|(
name|TOK_RBRACE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|defp
operator|->
name|def
operator|.
name|un
operator|.
name|default_decl
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|reserved_words
index|[]
init|=
block|{
literal|"array"
block|,
literal|"bytes"
block|,
literal|"destroy"
block|,
literal|"free"
block|,
literal|"getpos"
block|,
literal|"inline"
block|,
literal|"pointer"
block|,
literal|"reference"
block|,
literal|"setpos"
block|,
literal|"sizeof"
block|,
literal|"union"
block|,
literal|"vector"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|reserved_types
index|[]
init|=
block|{
literal|"opaque"
block|,
literal|"string"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * check that the given name is not one that would eventually result in  * xdr routines that would conflict with internal XDR routines.  */
end_comment

begin_function
specifier|static
name|void
name|check_type_name
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|int
name|new_type
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|tmp
index|[
literal|100
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reserved_words
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|reserved_words
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"illegal (reserved) name :\'%s\' in type definition"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|new_type
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|reserved_types
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|reserved_types
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"illegal (reserved) name :\'%s\' in type definition"
argument_list|,
name|name
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|def_typedef
parameter_list|(
name|definition
modifier|*
name|defp
parameter_list|)
block|{
name|declaration
name|dec
decl_stmt|;
name|defp
operator|->
name|def_kind
operator|=
name|DEF_TYPEDEF
expr_stmt|;
name|get_declaration
argument_list|(
operator|&
name|dec
argument_list|,
name|DEF_TYPEDEF
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def_name
operator|=
name|dec
operator|.
name|name
expr_stmt|;
name|check_type_name
argument_list|(
name|dec
operator|.
name|name
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|old_prefix
operator|=
name|dec
operator|.
name|prefix
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
operator|=
name|dec
operator|.
name|type
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|rel
operator|=
name|dec
operator|.
name|rel
expr_stmt|;
name|defp
operator|->
name|def
operator|.
name|ty
operator|.
name|array_max
operator|=
name|dec
operator|.
name|array_max
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_declaration
parameter_list|(
name|declaration
modifier|*
name|dec
parameter_list|,
name|defkind
name|dkind
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|get_type
argument_list|(
operator|&
name|dec
operator|->
name|prefix
argument_list|,
operator|&
name|dec
operator|->
name|type
argument_list|,
name|dkind
argument_list|)
expr_stmt|;
name|dec
operator|->
name|rel
operator|=
name|REL_ALIAS
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"void"
argument_list|)
condition|)
block|{
return|return;
block|}
name|check_type_name
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|scan2
argument_list|(
name|TOK_STAR
argument_list|,
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_STAR
condition|)
block|{
name|dec
operator|->
name|rel
operator|=
name|REL_POINTER
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|name
operator|=
name|tok
operator|.
name|str
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_LBRACKET
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|==
name|REL_POINTER
condition|)
block|{
name|error
argument_list|(
literal|"no array-of-pointer declarations -- use typedef"
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|rel
operator|=
name|REL_VECTOR
expr_stmt|;
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|dec
operator|->
name|array_max
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_RBRACKET
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_LANGLE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|==
name|REL_POINTER
condition|)
block|{
name|error
argument_list|(
literal|"no array-of-pointer declarations -- use typedef"
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|rel
operator|=
name|REL_ARRAY
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_RANGLE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
name|dec
operator|->
name|array_max
operator|=
literal|"~0"
expr_stmt|;
comment|/* unspecified size, use max */
block|}
else|else
block|{
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|dec
operator|->
name|array_max
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_RANGLE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"opaque"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|!=
name|REL_ARRAY
operator|&&
name|dec
operator|->
name|rel
operator|!=
name|REL_VECTOR
condition|)
block|{
name|error
argument_list|(
literal|"array declaration expected"
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|!=
name|REL_ARRAY
condition|)
block|{
name|error
argument_list|(
literal|"variable-length array declaration expected"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_prog_declaration
parameter_list|(
name|declaration
modifier|*
name|dec
parameter_list|,
name|defkind
name|dkind
parameter_list|,
name|int
name|num
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|char
name|name
index|[
literal|10
index|]
decl_stmt|;
comment|/* argument name */
if|if
condition|(
name|dkind
operator|==
name|DEF_PROGRAM
condition|)
block|{
name|peek
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
if|if
condition|(
name|tok
operator|.
name|kind
operator|==
name|TOK_RPAREN
condition|)
block|{
comment|/* no arguments */
name|dec
operator|->
name|rel
operator|=
name|REL_ALIAS
expr_stmt|;
name|dec
operator|->
name|type
operator|=
literal|"void"
expr_stmt|;
name|dec
operator|->
name|prefix
operator|=
name|NULL
expr_stmt|;
name|dec
operator|->
name|name
operator|=
name|NULL
expr_stmt|;
return|return;
block|}
block|}
name|get_type
argument_list|(
operator|&
name|dec
operator|->
name|prefix
argument_list|,
operator|&
name|dec
operator|->
name|type
argument_list|,
name|dkind
argument_list|)
expr_stmt|;
name|dec
operator|->
name|rel
operator|=
name|REL_ALIAS
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
comment|/* optional name of argument */
name|strcpy
argument_list|(
name|name
argument_list|,
name|tok
operator|.
name|str
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s%d"
argument_list|,
name|ARGNAME
argument_list|,
name|num
argument_list|)
expr_stmt|;
comment|/* default name of argument */
name|dec
operator|->
name|name
operator|=
operator|(
name|char
operator|*
operator|)
name|xstrdup
argument_list|(
name|name
argument_list|)
expr_stmt|;
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"void"
argument_list|)
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"opaque"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"opaque -- illegal argument type"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_STAR
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"pointer to string not allowed in program arguments"
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|rel
operator|=
name|REL_POINTER
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
comment|/* optional name of argument */
name|dec
operator|->
name|name
operator|=
name|xstrdup
argument_list|(
name|tok
operator|.
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_LANGLE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
name|error
argument_list|(
literal|"arrays cannot be declared as arguments to procedures -- use typedef"
argument_list|)
expr_stmt|;
block|}
name|dec
operator|->
name|rel
operator|=
name|REL_ARRAY
expr_stmt|;
if|if
condition|(
name|peekscan
argument_list|(
name|TOK_RANGLE
argument_list|,
operator|&
name|tok
argument_list|)
condition|)
block|{
name|dec
operator|->
name|array_max
operator|=
literal|"~0"
expr_stmt|;
comment|/* unspecified size, use max */
block|}
else|else
block|{
name|scan_num
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
name|dec
operator|->
name|array_max
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_RANGLE
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|streq
argument_list|(
name|dec
operator|->
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
if|if
condition|(
name|dec
operator|->
name|rel
operator|!=
name|REL_ARRAY
condition|)
block|{
comment|/* 			 * .x specifies just string as 			 * type of argument 			 * - make it string<> 			 */
name|dec
operator|->
name|rel
operator|=
name|REL_ARRAY
expr_stmt|;
name|dec
operator|->
name|array_max
operator|=
literal|"~0"
expr_stmt|;
comment|/* unspecified size, use max */
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_type
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|prefixp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|typep
parameter_list|,
name|defkind
name|dkind
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
operator|*
name|prefixp
operator|=
name|NULL
expr_stmt|;
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
operator|.
name|kind
condition|)
block|{
case|case
name|TOK_IDENT
case|:
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|TOK_STRUCT
case|:
case|case
name|TOK_ENUM
case|:
case|case
name|TOK_UNION
case|:
operator|*
name|prefixp
operator|=
name|tok
operator|.
name|str
expr_stmt|;
name|scan
argument_list|(
name|TOK_IDENT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|TOK_UNSIGNED
case|:
name|unsigned_dec
argument_list|(
name|typep
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_SHORT
case|:
operator|*
name|typep
operator|=
literal|"short"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_LONG
case|:
operator|*
name|typep
operator|=
literal|"long"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_HYPER
case|:
operator|*
name|typep
operator|=
literal|"int64_t"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_VOID
case|:
if|if
condition|(
name|dkind
operator|!=
name|DEF_UNION
operator|&&
name|dkind
operator|!=
name|DEF_PROGRAM
condition|)
block|{
name|error
argument_list|(
literal|"voids allowed only inside union and program definitions with one argument"
argument_list|)
expr_stmt|;
block|}
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
case|case
name|TOK_STRING
case|:
case|case
name|TOK_OPAQUE
case|:
case|case
name|TOK_CHAR
case|:
case|case
name|TOK_INT
case|:
case|case
name|TOK_FLOAT
case|:
case|case
name|TOK_DOUBLE
case|:
case|case
name|TOK_BOOL
case|:
case|case
name|TOK_QUAD
case|:
operator|*
name|typep
operator|=
name|tok
operator|.
name|str
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
literal|"expected type specifier"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|unsigned_dec
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|typep
parameter_list|)
block|{
name|token
name|tok
decl_stmt|;
name|peek
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tok
operator|.
name|kind
condition|)
block|{
case|case
name|TOK_CHAR
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_char"
expr_stmt|;
break|break;
case|case
name|TOK_SHORT
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_short"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_LONG
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_long"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_HYPER
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_int64_t"
expr_stmt|;
operator|(
name|void
operator|)
name|peekscan
argument_list|(
name|TOK_INT
argument_list|,
operator|&
name|tok
argument_list|)
expr_stmt|;
break|break;
case|case
name|TOK_INT
case|:
name|get_token
argument_list|(
operator|&
name|tok
argument_list|)
expr_stmt|;
operator|*
name|typep
operator|=
literal|"u_int"
expr_stmt|;
break|break;
default|default:
operator|*
name|typep
operator|=
literal|"u_int"
expr_stmt|;
break|break;
block|}
block|}
end_function

end_unit

