begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)rpc_scan.c	2.1 88/08/01 4.0 RPCSRC */
end_comment

begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *   * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *   * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *   * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *   * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *   * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_comment
comment|/*static char sccsid[] = "from: @(#)rpc_scan.c 1.6 87/06/24 (C) 1987 SMI";*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: rpc_scan.c,v 1.1 1993/09/13 23:20:18 jtc Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * rpc_scan.c, Scanner for the RPC protocol compiler   * Copyright (C) 1987, Sun Microsystems, Inc.   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|"rpc_scan.h"
end_include

begin_include
include|#
directive|include
file|"rpc_util.h"
end_include

begin_define
define|#
directive|define
name|startcomment
parameter_list|(
name|where
parameter_list|)
value|(where[0] == '/'&& where[1] == '*')
end_define

begin_define
define|#
directive|define
name|endcomment
parameter_list|(
name|where
parameter_list|)
value|(where[-1] == '*'&& where[0] == '/')
end_define

begin_decl_stmt
specifier|static
name|int
name|pushed
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is a token pushed */
end_comment

begin_decl_stmt
specifier|static
name|token
name|lasttok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last token, if pushed */
end_comment

begin_decl_stmt
specifier|static
name|int
name|unget_token
argument_list|()
decl_stmt|,
name|findstrconst
argument_list|()
decl_stmt|,
name|findconst
argument_list|()
decl_stmt|,
name|findkind
argument_list|()
decl_stmt|,
name|cppline
argument_list|()
decl_stmt|,
name|directive
argument_list|()
decl_stmt|,
name|printdirective
argument_list|()
decl_stmt|,
name|docppline
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * scan expecting 1 given token   */
end_comment

begin_function
name|void
name|scan
parameter_list|(
name|expect
parameter_list|,
name|tokp
parameter_list|)
name|tok_kind
name|expect
decl_stmt|;
name|token
modifier|*
name|tokp
decl_stmt|;
block|{
name|get_token
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokp
operator|->
name|kind
operator|!=
name|expect
condition|)
block|{
name|expected1
argument_list|(
name|expect
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * scan expecting 2 given tokens   */
end_comment

begin_function
name|void
name|scan2
parameter_list|(
name|expect1
parameter_list|,
name|expect2
parameter_list|,
name|tokp
parameter_list|)
name|tok_kind
name|expect1
decl_stmt|;
name|tok_kind
name|expect2
decl_stmt|;
name|token
modifier|*
name|tokp
decl_stmt|;
block|{
name|get_token
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokp
operator|->
name|kind
operator|!=
name|expect1
operator|&&
name|tokp
operator|->
name|kind
operator|!=
name|expect2
condition|)
block|{
name|expected2
argument_list|(
name|expect1
argument_list|,
name|expect2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * scan expecting 3 given token   */
end_comment

begin_function
name|void
name|scan3
parameter_list|(
name|expect1
parameter_list|,
name|expect2
parameter_list|,
name|expect3
parameter_list|,
name|tokp
parameter_list|)
name|tok_kind
name|expect1
decl_stmt|;
name|tok_kind
name|expect2
decl_stmt|;
name|tok_kind
name|expect3
decl_stmt|;
name|token
modifier|*
name|tokp
decl_stmt|;
block|{
name|get_token
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokp
operator|->
name|kind
operator|!=
name|expect1
operator|&&
name|tokp
operator|->
name|kind
operator|!=
name|expect2
operator|&&
name|tokp
operator|->
name|kind
operator|!=
name|expect3
condition|)
block|{
name|expected3
argument_list|(
name|expect1
argument_list|,
name|expect2
argument_list|,
name|expect3
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * scan expecting a constant, possibly symbolic   */
end_comment

begin_function
name|void
name|scan_num
parameter_list|(
name|tokp
parameter_list|)
name|token
modifier|*
name|tokp
decl_stmt|;
block|{
name|get_token
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tokp
operator|->
name|kind
condition|)
block|{
case|case
name|TOK_IDENT
case|:
break|break;
default|default:
name|error
argument_list|(
literal|"constant or identifier expected"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Peek at the next token   */
end_comment

begin_function
name|void
name|peek
parameter_list|(
name|tokp
parameter_list|)
name|token
modifier|*
name|tokp
decl_stmt|;
block|{
name|get_token
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
name|unget_token
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Peek at the next token and scan it if it matches what you expect   */
end_comment

begin_function
name|int
name|peekscan
parameter_list|(
name|expect
parameter_list|,
name|tokp
parameter_list|)
name|tok_kind
name|expect
decl_stmt|;
name|token
modifier|*
name|tokp
decl_stmt|;
block|{
name|peek
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
if|if
condition|(
name|tokp
operator|->
name|kind
operator|==
name|expect
condition|)
block|{
name|get_token
argument_list|(
name|tokp
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Get the next token, printing out any directive that are encountered.   */
end_comment

begin_function
name|void
name|get_token
parameter_list|(
name|tokp
parameter_list|)
name|token
modifier|*
name|tokp
decl_stmt|;
block|{
name|int
name|commenting
decl_stmt|;
if|if
condition|(
name|pushed
condition|)
block|{
name|pushed
operator|=
literal|0
expr_stmt|;
operator|*
name|tokp
operator|=
name|lasttok
expr_stmt|;
return|return;
block|}
name|commenting
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|where
operator|==
literal|0
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|curline
argument_list|,
name|MAXLINESIZE
argument_list|,
name|fin
argument_list|)
condition|)
block|{
name|tokp
operator|->
name|kind
operator|=
name|TOK_EOF
expr_stmt|;
operator|*
name|where
operator|=
literal|0
expr_stmt|;
return|return;
block|}
name|linenum
operator|++
expr_stmt|;
if|if
condition|(
name|commenting
condition|)
block|{
break|break;
block|}
elseif|else
if|if
condition|(
name|cppline
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|docppline
argument_list|(
name|curline
argument_list|,
operator|&
name|linenum
argument_list|,
operator|&
name|infilename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|directive
argument_list|(
name|curline
argument_list|)
condition|)
block|{
name|printdirective
argument_list|(
name|curline
argument_list|)
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
name|where
operator|=
name|curline
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|*
name|where
argument_list|)
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|where
argument_list|)
condition|)
block|{
name|where
operator|++
expr_stmt|;
comment|/* eat */
block|}
block|}
elseif|else
if|if
condition|(
name|commenting
condition|)
block|{
name|where
operator|++
expr_stmt|;
if|if
condition|(
name|endcomment
argument_list|(
name|where
argument_list|)
condition|)
block|{
name|where
operator|++
expr_stmt|;
name|commenting
operator|--
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|startcomment
argument_list|(
name|where
argument_list|)
condition|)
block|{
name|where
operator|+=
literal|2
expr_stmt|;
name|commenting
operator|++
expr_stmt|;
block|}
else|else
block|{
break|break;
block|}
block|}
comment|/* 	 * 'where' is not whitespace, comment or directive Must be a token!  	 */
switch|switch
condition|(
operator|*
name|where
condition|)
block|{
case|case
literal|':'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_COLON
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|';'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_SEMICOLON
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|','
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_COMMA
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_EQUAL
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_STAR
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_LBRACKET
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|']'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_RBRACKET
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'{'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_LBRACE
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_RBRACE
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'('
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_LPAREN
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|')'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_RPAREN
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'<'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_LANGLE
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_RANGLE
expr_stmt|;
name|where
operator|++
expr_stmt|;
break|break;
case|case
literal|'"'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_STRCONST
expr_stmt|;
name|findstrconst
argument_list|(
operator|&
name|where
argument_list|,
operator|&
name|tokp
operator|->
name|str
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
name|tokp
operator|->
name|kind
operator|=
name|TOK_IDENT
expr_stmt|;
name|findconst
argument_list|(
operator|&
name|where
argument_list|,
operator|&
name|tokp
operator|->
name|str
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
operator|!
operator|(
name|isalpha
argument_list|(
operator|*
name|where
argument_list|)
operator|||
operator|*
name|where
operator|==
literal|'_'
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|s_print
argument_list|(
name|buf
argument_list|,
literal|"illegal character in file: "
argument_list|)
expr_stmt|;
name|p
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|isprint
argument_list|(
operator|*
name|where
argument_list|)
condition|)
block|{
name|s_print
argument_list|(
name|p
argument_list|,
literal|"%c"
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|s_print
argument_list|(
name|p
argument_list|,
literal|"%d"
argument_list|,
operator|*
name|where
argument_list|)
expr_stmt|;
block|}
name|error
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
name|findkind
argument_list|(
operator|&
name|where
argument_list|,
name|tokp
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|unget_token
argument_list|(
argument|tokp
argument_list|)
name|token
operator|*
name|tokp
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|lasttok
operator|=
operator|*
name|tokp
expr_stmt|;
name|pushed
operator|=
literal|1
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|findstrconst
argument_list|(
argument|str
argument_list|,
argument|val
argument_list|)
name|char
operator|*
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
name|p
operator|=
operator|*
name|str
expr_stmt|;
do|do
block|{
operator|*
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|p
operator|&&
operator|*
name|p
operator|!=
literal|'"'
condition|)
do|;
if|if
condition|(
operator|*
name|p
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"unterminated string constant"
argument_list|)
expr_stmt|;
block|}
name|p
operator|++
expr_stmt|;
name|size
operator|=
name|p
operator|-
operator|*
name|str
expr_stmt|;
operator|*
name|val
operator|=
name|alloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|*
name|val
argument_list|,
operator|*
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|val
operator|)
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|findconst
argument_list|(
argument|str
argument_list|,
argument|val
argument_list|)
name|char
operator|*
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|int
name|size
decl_stmt|;
name|p
operator|=
operator|*
name|str
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'0'
operator|&&
operator|*
operator|(
name|p
operator|+
literal|1
operator|)
operator|==
literal|'x'
condition|)
block|{
name|p
operator|++
expr_stmt|;
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
block|}
else|else
block|{
do|do
block|{
name|p
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|isdigit
argument_list|(
operator|*
name|p
argument_list|)
condition|)
do|;
block|}
name|size
operator|=
name|p
operator|-
operator|*
name|str
expr_stmt|;
operator|*
name|val
operator|=
name|alloc
argument_list|(
name|size
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|*
name|val
argument_list|,
operator|*
name|str
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
operator|*
name|val
operator|)
index|[
name|size
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|str
operator|=
name|p
expr_stmt|;
block|}
end_block

begin_decl_stmt
specifier|static
name|token
name|symbols
index|[]
init|=
block|{
block|{
name|TOK_CONST
block|,
literal|"const"
block|}
block|,
block|{
name|TOK_UNION
block|,
literal|"union"
block|}
block|,
block|{
name|TOK_SWITCH
block|,
literal|"switch"
block|}
block|,
block|{
name|TOK_CASE
block|,
literal|"case"
block|}
block|,
block|{
name|TOK_DEFAULT
block|,
literal|"default"
block|}
block|,
block|{
name|TOK_STRUCT
block|,
literal|"struct"
block|}
block|,
block|{
name|TOK_TYPEDEF
block|,
literal|"typedef"
block|}
block|,
block|{
name|TOK_ENUM
block|,
literal|"enum"
block|}
block|,
block|{
name|TOK_OPAQUE
block|,
literal|"opaque"
block|}
block|,
block|{
name|TOK_BOOL
block|,
literal|"bool"
block|}
block|,
block|{
name|TOK_VOID
block|,
literal|"void"
block|}
block|,
block|{
name|TOK_CHAR
block|,
literal|"char"
block|}
block|,
block|{
name|TOK_INT
block|,
literal|"int"
block|}
block|,
block|{
name|TOK_UNSIGNED
block|,
literal|"unsigned"
block|}
block|,
block|{
name|TOK_SHORT
block|,
literal|"short"
block|}
block|,
block|{
name|TOK_LONG
block|,
literal|"long"
block|}
block|,
block|{
name|TOK_FLOAT
block|,
literal|"float"
block|}
block|,
block|{
name|TOK_DOUBLE
block|,
literal|"double"
block|}
block|,
block|{
name|TOK_STRING
block|,
literal|"string"
block|}
block|,
block|{
name|TOK_PROGRAM
block|,
literal|"program"
block|}
block|,
block|{
name|TOK_VERSION
block|,
literal|"version"
block|}
block|,
block|{
name|TOK_EOF
block|,
literal|"??????"
block|}
block|, }
decl_stmt|;
end_decl_stmt

begin_expr_stmt
specifier|static
name|findkind
argument_list|(
argument|mark
argument_list|,
argument|tokp
argument_list|)
name|char
operator|*
operator|*
name|mark
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|token
modifier|*
name|tokp
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|int
name|len
decl_stmt|;
name|token
modifier|*
name|s
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|str
operator|=
operator|*
name|mark
expr_stmt|;
for|for
control|(
name|s
operator|=
name|symbols
init|;
name|s
operator|->
name|kind
operator|!=
name|TOK_EOF
condition|;
name|s
operator|++
control|)
block|{
name|len
operator|=
name|strlen
argument_list|(
name|s
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|str
argument_list|,
name|s
operator|->
name|str
argument_list|,
name|len
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|str
index|[
name|len
index|]
argument_list|)
operator|&&
name|str
index|[
name|len
index|]
operator|!=
literal|'_'
condition|)
block|{
name|tokp
operator|->
name|kind
operator|=
name|s
operator|->
name|kind
expr_stmt|;
name|tokp
operator|->
name|str
operator|=
name|s
operator|->
name|str
expr_stmt|;
operator|*
name|mark
operator|=
name|str
operator|+
name|len
expr_stmt|;
return|return;
block|}
block|}
block|}
name|tokp
operator|->
name|kind
operator|=
name|TOK_IDENT
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|0
init|;
name|isalnum
argument_list|(
name|str
index|[
name|len
index|]
argument_list|)
operator|||
name|str
index|[
name|len
index|]
operator|==
literal|'_'
condition|;
name|len
operator|++
control|)
empty_stmt|;
name|tokp
operator|->
name|str
operator|=
name|alloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|tokp
operator|->
name|str
argument_list|,
name|str
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|tokp
operator|->
name|str
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
operator|*
name|mark
operator|=
name|str
operator|+
name|len
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|cppline
argument_list|(
argument|line
argument_list|)
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|line
operator|==
name|curline
operator|&&
operator|*
name|line
operator|==
literal|'#'
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|directive
argument_list|(
argument|line
argument_list|)
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
return|return
operator|(
name|line
operator|==
name|curline
operator|&&
operator|*
name|line
operator|==
literal|'%'
operator|)
return|;
block|}
end_block

begin_expr_stmt
specifier|static
name|printdirective
argument_list|(
argument|line
argument_list|)
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"%s"
argument_list|,
name|line
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_expr_stmt
specifier|static
name|docppline
argument_list|(
argument|line
argument_list|,
argument|lineno
argument_list|,
argument|fname
argument_list|)
name|char
operator|*
name|line
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|int
modifier|*
name|lineno
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|fname
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|num
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|line
operator|++
expr_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
name|num
operator|=
name|atoi
argument_list|(
name|line
argument_list|)
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|line
argument_list|)
condition|)
block|{
name|line
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|line
operator|!=
literal|'"'
condition|)
block|{
name|error
argument_list|(
literal|"preprocessor error"
argument_list|)
expr_stmt|;
block|}
name|line
operator|++
expr_stmt|;
name|p
operator|=
name|file
operator|=
name|alloc
argument_list|(
name|strlen
argument_list|(
name|line
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|line
operator|&&
operator|*
name|line
operator|!=
literal|'"'
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|*
name|line
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|line
operator|==
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"preprocessor error"
argument_list|)
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|file
operator|==
literal|0
condition|)
block|{
operator|*
name|fname
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|*
name|fname
operator|=
name|file
expr_stmt|;
block|}
operator|*
name|lineno
operator|=
name|num
operator|-
literal|1
expr_stmt|;
block|}
end_block

end_unit

