begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* @(#)rpc_util.c	2.1 88/08/01 4.0 RPCSRC */
end_comment

begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *   * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *   * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *   * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *   * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *   * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_comment
comment|/*static char sccsid[] = "from: @(#)rpc_util.c 1.5 87/06/24 (C) 1987 SMI";*/
end_comment

begin_decl_stmt
specifier|static
name|char
name|rcsid
index|[]
init|=
literal|"$Id: rpc_util.c,v 1.1 1993/09/13 23:20:20 jtc Exp $"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * rpc_util.c, Utility routines for the RPC protocol compiler   * Copyright (C) 1987, Sun Microsystems, Inc.   */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"rpc_scan.h"
end_include

begin_include
include|#
directive|include
file|"rpc_parse.h"
end_include

begin_include
include|#
directive|include
file|"rpc_util.h"
end_include

begin_decl_stmt
name|char
name|curline
index|[
name|MAXLINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current read line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|where
init|=
name|curline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current point in line */
end_comment

begin_decl_stmt
name|int
name|linenum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|infilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input filename */
end_comment

begin_define
define|#
directive|define
name|NFILES
value|4
end_define

begin_decl_stmt
name|char
modifier|*
name|outfiles
index|[
name|NFILES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file names */
end_comment

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file pointer of current output */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file pointer of current input */
end_comment

begin_decl_stmt
name|list
modifier|*
name|defined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of defined things */
end_comment

begin_function_decl
specifier|static
name|int
name|printwhere
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * Reinitialize the world   */
end_comment

begin_macro
name|reinitialize
argument_list|()
end_macro

begin_block
block|{
name|bzero
argument_list|(
name|curline
argument_list|,
name|MAXLINESIZE
argument_list|)
expr_stmt|;
name|where
operator|=
name|curline
expr_stmt|;
name|linenum
operator|=
literal|0
expr_stmt|;
name|defined
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/*  * string equality   */
end_comment

begin_macro
name|streq
argument_list|(
argument|a
argument_list|,
argument|b
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|a
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|b
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * find a value in a list   */
end_comment

begin_decl_stmt
name|char
modifier|*
name|findval
argument_list|(
name|lst
argument_list|,
name|val
argument_list|,
name|cmp
argument_list|)
name|list
modifier|*
name|lst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
for|for
control|(
init|;
name|lst
operator|!=
name|NULL
condition|;
name|lst
operator|=
name|lst
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|lst
operator|->
name|val
argument_list|,
name|val
argument_list|)
condition|)
block|{
return|return
operator|(
name|lst
operator|->
name|val
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * store a value in a list   */
end_comment

begin_function
name|void
name|storeval
parameter_list|(
name|lstp
parameter_list|,
name|val
parameter_list|)
name|list
modifier|*
modifier|*
name|lstp
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
block|{
name|list
modifier|*
modifier|*
name|l
decl_stmt|;
name|list
modifier|*
name|lst
decl_stmt|;
for|for
control|(
name|l
operator|=
name|lstp
init|;
operator|*
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
operator|(
name|list
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|l
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|lst
operator|=
name|ALLOC
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|lst
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|lst
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|l
operator|=
name|lst
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|findit
argument_list|(
argument|def
argument_list|,
argument|type
argument_list|)
name|definition
operator|*
name|def
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
return|return
operator|(
name|streq
argument_list|(
name|def
operator|->
name|def_name
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|fixit
parameter_list|(
name|type
parameter_list|,
name|orig
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|orig
decl_stmt|;
block|{
name|definition
modifier|*
name|def
decl_stmt|;
name|def
operator|=
operator|(
name|definition
operator|*
operator|)
name|FINDVAL
argument_list|(
name|defined
argument_list|,
name|type
argument_list|,
name|findit
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
operator|||
name|def
operator|->
name|def_kind
operator|!=
name|DEF_TYPEDEF
condition|)
block|{
return|return
operator|(
name|orig
operator|)
return|;
block|}
switch|switch
condition|(
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|rel
condition|)
block|{
case|case
name|REL_VECTOR
case|:
return|return
operator|(
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
operator|)
return|;
case|case
name|REL_ALIAS
case|:
return|return
operator|(
name|fixit
argument_list|(
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
argument_list|,
name|orig
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|orig
operator|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|fixtype
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
return|return
operator|(
name|fixit
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|stringfix
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|streq
argument_list|(
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
return|return
operator|(
literal|"wrapstring"
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|type
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|ptype
parameter_list|(
name|prefix
parameter_list|,
name|type
parameter_list|,
name|follow
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|follow
decl_stmt|;
block|{
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|prefix
argument_list|,
literal|"enum"
argument_list|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|streq
argument_list|(
name|type
argument_list|,
literal|"bool"
argument_list|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"bool_t "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"char *"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"%s "
argument_list|,
name|follow
condition|?
name|fixtype
argument_list|(
name|type
argument_list|)
else|:
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_expr_stmt
specifier|static
name|typedefed
argument_list|(
argument|def
argument_list|,
argument|type
argument_list|)
name|definition
operator|*
name|def
expr_stmt|;
end_expr_stmt

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|def
operator|->
name|def_kind
operator|!=
name|DEF_TYPEDEF
operator|||
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_prefix
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|streq
argument_list|(
name|def
operator|->
name|def_name
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
block|}
end_block

begin_macro
name|isvectordef
argument_list|(
argument|type
argument_list|,
argument|rel
argument_list|)
end_macro

begin_decl_stmt
name|char
modifier|*
name|type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|relation
name|rel
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|definition
modifier|*
name|def
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|rel
condition|)
block|{
case|case
name|REL_VECTOR
case|:
return|return
operator|(
operator|!
name|streq
argument_list|(
name|type
argument_list|,
literal|"string"
argument_list|)
operator|)
return|;
case|case
name|REL_ARRAY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|REL_POINTER
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|REL_ALIAS
case|:
name|def
operator|=
operator|(
name|definition
operator|*
operator|)
name|FINDVAL
argument_list|(
name|defined
argument_list|,
name|type
argument_list|,
name|typedefed
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|type
operator|=
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
expr_stmt|;
name|rel
operator|=
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|rel
expr_stmt|;
block|}
block|}
block|}
end_block

begin_function
specifier|static
name|char
modifier|*
name|locase
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
while|while
condition|(
name|c
operator|=
operator|*
name|str
operator|++
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|?
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|'a'
operator|)
else|:
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pvname
parameter_list|(
name|pname
parameter_list|,
name|vnum
parameter_list|)
name|char
modifier|*
name|pname
decl_stmt|;
name|char
modifier|*
name|vnum
decl_stmt|;
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"%s_%s"
argument_list|,
name|locase
argument_list|(
name|pname
argument_list|)
argument_list|,
name|vnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print a useful (?) error message, and then die   */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|printwhere
argument_list|()
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"%s, line %d: "
argument_list|,
name|infilename
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Something went wrong, unlink any files that we may have created and then  * die.   */
end_comment

begin_macro
name|crash
argument_list|()
end_macro

begin_block
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_block

begin_function
name|void
name|record_open
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|nfiles
operator|<
name|NFILES
condition|)
block|{
name|outfiles
index|[
name|nfiles
operator|++
index|]
operator|=
name|file
expr_stmt|;
block|}
else|else
block|{
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"too many files!\n"
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|expectbuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|toktostr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * error, token encountered was not the expected one   */
end_comment

begin_function
name|void
name|expected1
parameter_list|(
name|exp1
parameter_list|)
name|tok_kind
name|exp1
decl_stmt|;
block|{
name|s_print
argument_list|(
name|expectbuf
argument_list|,
literal|"expected '%s'"
argument_list|,
name|toktostr
argument_list|(
name|exp1
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|expectbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * error, token encountered was not one of two expected ones   */
end_comment

begin_function
name|void
name|expected2
parameter_list|(
name|exp1
parameter_list|,
name|exp2
parameter_list|)
name|tok_kind
name|exp1
decl_stmt|,
name|exp2
decl_stmt|;
block|{
name|s_print
argument_list|(
name|expectbuf
argument_list|,
literal|"expected '%s' or '%s'"
argument_list|,
name|toktostr
argument_list|(
name|exp1
argument_list|)
argument_list|,
name|toktostr
argument_list|(
name|exp2
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|expectbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * error, token encountered was not one of 3 expected ones   */
end_comment

begin_function
name|void
name|expected3
parameter_list|(
name|exp1
parameter_list|,
name|exp2
parameter_list|,
name|exp3
parameter_list|)
name|tok_kind
name|exp1
decl_stmt|,
name|exp2
decl_stmt|,
name|exp3
decl_stmt|;
block|{
name|s_print
argument_list|(
name|expectbuf
argument_list|,
literal|"expected '%s', '%s' or '%s'"
argument_list|,
name|toktostr
argument_list|(
name|exp1
argument_list|)
argument_list|,
name|toktostr
argument_list|(
name|exp2
argument_list|)
argument_list|,
name|toktostr
argument_list|(
name|exp3
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|expectbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tabify
parameter_list|(
name|f
parameter_list|,
name|tab
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|tab
decl_stmt|;
block|{
while|while
condition|(
name|tab
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|token
name|tokstrings
index|[]
init|=
block|{
block|{
name|TOK_IDENT
block|,
literal|"identifier"
block|}
block|,
block|{
name|TOK_CONST
block|,
literal|"const"
block|}
block|,
block|{
name|TOK_RPAREN
block|,
literal|")"
block|}
block|,
block|{
name|TOK_LPAREN
block|,
literal|"("
block|}
block|,
block|{
name|TOK_RBRACE
block|,
literal|"}"
block|}
block|,
block|{
name|TOK_LBRACE
block|,
literal|"{"
block|}
block|,
block|{
name|TOK_LBRACKET
block|,
literal|"["
block|}
block|,
block|{
name|TOK_RBRACKET
block|,
literal|"]"
block|}
block|,
block|{
name|TOK_STAR
block|,
literal|"*"
block|}
block|,
block|{
name|TOK_COMMA
block|,
literal|","
block|}
block|,
block|{
name|TOK_EQUAL
block|,
literal|"="
block|}
block|,
block|{
name|TOK_COLON
block|,
literal|":"
block|}
block|,
block|{
name|TOK_SEMICOLON
block|,
literal|";"
block|}
block|,
block|{
name|TOK_UNION
block|,
literal|"union"
block|}
block|,
block|{
name|TOK_STRUCT
block|,
literal|"struct"
block|}
block|,
block|{
name|TOK_SWITCH
block|,
literal|"switch"
block|}
block|,
block|{
name|TOK_CASE
block|,
literal|"case"
block|}
block|,
block|{
name|TOK_DEFAULT
block|,
literal|"default"
block|}
block|,
block|{
name|TOK_ENUM
block|,
literal|"enum"
block|}
block|,
block|{
name|TOK_TYPEDEF
block|,
literal|"typedef"
block|}
block|,
block|{
name|TOK_INT
block|,
literal|"int"
block|}
block|,
block|{
name|TOK_SHORT
block|,
literal|"short"
block|}
block|,
block|{
name|TOK_LONG
block|,
literal|"long"
block|}
block|,
block|{
name|TOK_UNSIGNED
block|,
literal|"unsigned"
block|}
block|,
block|{
name|TOK_DOUBLE
block|,
literal|"double"
block|}
block|,
block|{
name|TOK_FLOAT
block|,
literal|"float"
block|}
block|,
block|{
name|TOK_CHAR
block|,
literal|"char"
block|}
block|,
block|{
name|TOK_STRING
block|,
literal|"string"
block|}
block|,
block|{
name|TOK_OPAQUE
block|,
literal|"opaque"
block|}
block|,
block|{
name|TOK_BOOL
block|,
literal|"bool"
block|}
block|,
block|{
name|TOK_VOID
block|,
literal|"void"
block|}
block|,
block|{
name|TOK_PROGRAM
block|,
literal|"program"
block|}
block|,
block|{
name|TOK_VERSION
block|,
literal|"version"
block|}
block|,
block|{
name|TOK_EOF
block|,
literal|"??????"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|toktostr
parameter_list|(
name|kind
parameter_list|)
name|tok_kind
name|kind
decl_stmt|;
block|{
name|token
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|tokstrings
init|;
name|sp
operator|->
name|kind
operator|!=
name|TOK_EOF
operator|&&
name|sp
operator|->
name|kind
operator|!=
name|kind
condition|;
name|sp
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|sp
operator|->
name|str
operator|)
return|;
block|}
end_function

begin_expr_stmt
specifier|static
name|printbuf
argument_list|()
block|{
name|char
name|c
block|;
name|int
name|i
block|;
name|int
name|cnt
block|;
define|#
directive|define
name|TABSIZE
value|4
for|for
control|(
name|i
operator|=
literal|0
init|;
name|c
operator|=
name|curline
index|[
name|i
index|]
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|cnt
operator|=
literal|8
operator|-
operator|(
name|i
operator|%
name|TABSIZE
operator|)
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
block|}
end_else

begin_while
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
unit|} }
specifier|static
name|printwhere
argument_list|()
block|{
name|int
name|i
block|;
name|char
name|c
block|;
name|int
name|cnt
block|;
name|printbuf
argument_list|()
block|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|where
operator|-
name|curline
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|curline
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|cnt
operator|=
literal|8
operator|-
operator|(
name|i
operator|%
name|TABSIZE
operator|)
expr_stmt|;
block|}
end_expr_stmt

begin_else
else|else
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
block|}
end_else

begin_while
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'^'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_while

begin_expr_stmt
unit|} 	(
name|void
end_expr_stmt

begin_expr_stmt
unit|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
end_expr_stmt

unit|}
end_unit

