begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *   * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *   * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *   * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *   * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *   * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_empty
empty|#ident	"@(#)rpc_util.c	1.14	93/07/05 SMI"
end_empty

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)rpc_util.c 1.11 89/02/22 (C) 1987 SMI";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * rpc_util.c, Utility routines for the RPC protocol compiler  * Copyright (C) 1989, Sun Microsystems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"rpc_scan.h"
end_include

begin_include
include|#
directive|include
file|"rpc_parse.h"
end_include

begin_include
include|#
directive|include
file|"rpc_util.h"
end_include

begin_define
define|#
directive|define
name|ARGEXT
value|"argument"
end_define

begin_decl_stmt
name|char
name|curline
index|[
name|MAXLINESIZE
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current read line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|where
init|=
name|curline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current point in line */
end_comment

begin_decl_stmt
name|int
name|linenum
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number */
end_comment

begin_decl_stmt
name|char
modifier|*
name|infilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input filename */
end_comment

begin_define
define|#
directive|define
name|NFILES
value|7
end_define

begin_decl_stmt
name|char
modifier|*
name|outfiles
index|[
name|NFILES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file names */
end_comment

begin_decl_stmt
name|int
name|nfiles
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|fout
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file pointer of current output */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|fin
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file pointer of current input */
end_comment

begin_decl_stmt
name|list
modifier|*
name|defined
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* list of defined things */
end_comment

begin_decl_stmt
specifier|static
name|void
name|printwhere
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Reinitialize the world  */
end_comment

begin_function
name|void
name|reinitialize
parameter_list|()
block|{
name|memset
argument_list|(
name|curline
argument_list|,
literal|0
argument_list|,
name|MAXLINESIZE
argument_list|)
expr_stmt|;
name|where
operator|=
name|curline
expr_stmt|;
name|linenum
operator|=
literal|0
expr_stmt|;
name|defined
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * string equality  */
end_comment

begin_function
name|int
name|streq
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
name|char
modifier|*
name|a
decl_stmt|;
name|char
modifier|*
name|b
decl_stmt|;
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|a
argument_list|,
name|b
argument_list|)
operator|==
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * find a value in a list  */
end_comment

begin_decl_stmt
name|definition
modifier|*
name|findval
argument_list|(
name|lst
argument_list|,
name|val
argument_list|,
name|cmp
argument_list|)
name|list
modifier|*
name|lst
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|val
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|cmp
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
for|for
control|(
init|;
name|lst
operator|!=
name|NULL
condition|;
name|lst
operator|=
name|lst
operator|->
name|next
control|)
block|{
if|if
condition|(
call|(
modifier|*
name|cmp
call|)
argument_list|(
name|lst
operator|->
name|val
argument_list|,
name|val
argument_list|)
condition|)
block|{
return|return
operator|(
name|lst
operator|->
name|val
operator|)
return|;
block|}
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * store a value in a list  */
end_comment

begin_function
name|void
name|storeval
parameter_list|(
name|lstp
parameter_list|,
name|val
parameter_list|)
name|list
modifier|*
modifier|*
name|lstp
decl_stmt|;
name|definition
modifier|*
name|val
decl_stmt|;
block|{
name|list
modifier|*
modifier|*
name|l
decl_stmt|;
name|list
modifier|*
name|lst
decl_stmt|;
for|for
control|(
name|l
operator|=
name|lstp
init|;
operator|*
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
operator|(
name|list
operator|*
operator|*
operator|)
operator|&
operator|(
operator|*
name|l
operator|)
operator|->
name|next
control|)
empty_stmt|;
name|lst
operator|=
name|ALLOC
argument_list|(
name|list
argument_list|)
expr_stmt|;
name|lst
operator|->
name|val
operator|=
name|val
expr_stmt|;
name|lst
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
operator|*
name|l
operator|=
name|lst
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|int
name|findit
parameter_list|(
name|def
parameter_list|,
name|type
parameter_list|)
name|definition
modifier|*
name|def
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
return|return
operator|(
name|streq
argument_list|(
name|def
operator|->
name|def_name
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|fixit
parameter_list|(
name|type
parameter_list|,
name|orig
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
name|char
modifier|*
name|orig
decl_stmt|;
block|{
name|definition
modifier|*
name|def
decl_stmt|;
name|def
operator|=
operator|(
name|definition
operator|*
operator|)
name|FINDVAL
argument_list|(
name|defined
argument_list|,
name|type
argument_list|,
name|findit
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
operator|||
name|def
operator|->
name|def_kind
operator|!=
name|DEF_TYPEDEF
condition|)
block|{
return|return
operator|(
name|orig
operator|)
return|;
block|}
switch|switch
condition|(
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|rel
condition|)
block|{
case|case
name|REL_VECTOR
case|:
if|if
condition|(
name|streq
argument_list|(
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
argument_list|,
literal|"opaque"
argument_list|)
condition|)
return|return
operator|(
literal|"char"
operator|)
return|;
else|else
return|return
operator|(
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
operator|)
return|;
case|case
name|REL_ALIAS
case|:
return|return
operator|(
name|fixit
argument_list|(
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
argument_list|,
name|orig
argument_list|)
operator|)
return|;
default|default:
return|return
operator|(
name|orig
operator|)
return|;
block|}
block|}
end_function

begin_function
name|char
modifier|*
name|fixtype
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
return|return
operator|(
name|fixit
argument_list|(
name|type
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|stringfix
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|streq
argument_list|(
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
return|return
operator|(
literal|"wrapstring"
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|type
operator|)
return|;
block|}
block|}
end_function

begin_function
name|void
name|ptype
parameter_list|(
name|prefix
parameter_list|,
name|type
parameter_list|,
name|follow
parameter_list|)
name|char
modifier|*
name|prefix
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
name|int
name|follow
decl_stmt|;
block|{
if|if
condition|(
name|prefix
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|prefix
argument_list|,
literal|"enum"
argument_list|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"enum "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"struct "
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|streq
argument_list|(
name|type
argument_list|,
literal|"bool"
argument_list|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"bool_t "
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|type
argument_list|,
literal|"string"
argument_list|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"char *"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"%s "
argument_list|,
name|follow
condition|?
name|fixtype
argument_list|(
name|type
argument_list|)
else|:
name|type
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|typedefed
parameter_list|(
name|def
parameter_list|,
name|type
parameter_list|)
name|definition
modifier|*
name|def
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
if|if
condition|(
name|def
operator|->
name|def_kind
operator|!=
name|DEF_TYPEDEF
operator|||
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_prefix
operator|!=
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|streq
argument_list|(
name|def
operator|->
name|def_name
argument_list|,
name|type
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_function
name|int
name|isvectordef
parameter_list|(
name|type
parameter_list|,
name|rel
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
name|relation
name|rel
decl_stmt|;
block|{
name|definition
modifier|*
name|def
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|rel
condition|)
block|{
case|case
name|REL_VECTOR
case|:
return|return
operator|(
operator|!
name|streq
argument_list|(
name|type
argument_list|,
literal|"string"
argument_list|)
operator|)
return|;
case|case
name|REL_ARRAY
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|REL_POINTER
case|:
return|return
operator|(
literal|0
operator|)
return|;
case|case
name|REL_ALIAS
case|:
name|def
operator|=
operator|(
name|definition
operator|*
operator|)
name|FINDVAL
argument_list|(
name|defined
argument_list|,
name|type
argument_list|,
name|typedefed
argument_list|)
expr_stmt|;
if|if
condition|(
name|def
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|type
operator|=
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|old_type
expr_stmt|;
name|rel
operator|=
name|def
operator|->
name|def
operator|.
name|ty
operator|.
name|rel
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|locase
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|char
name|c
decl_stmt|;
specifier|static
name|char
name|buf
index|[
literal|100
index|]
decl_stmt|;
name|char
modifier|*
name|p
init|=
name|buf
decl_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
operator|*
name|str
operator|++
operator|)
condition|)
block|{
operator|*
name|p
operator|++
operator|=
operator|(
name|c
operator|>=
literal|'A'
operator|&&
name|c
operator|<=
literal|'Z'
operator|)
condition|?
operator|(
name|c
operator|-
literal|'A'
operator|+
literal|'a'
operator|)
else|:
name|c
expr_stmt|;
block|}
operator|*
name|p
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|buf
operator|)
return|;
block|}
end_function

begin_function
name|void
name|pvname_svc
parameter_list|(
name|pname
parameter_list|,
name|vnum
parameter_list|)
name|char
modifier|*
name|pname
decl_stmt|;
name|char
modifier|*
name|vnum
decl_stmt|;
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"%s_%s_svc"
argument_list|,
name|locase
argument_list|(
name|pname
argument_list|)
argument_list|,
name|vnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pvname
parameter_list|(
name|pname
parameter_list|,
name|vnum
parameter_list|)
name|char
modifier|*
name|pname
decl_stmt|;
name|char
modifier|*
name|vnum
decl_stmt|;
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"%s_%s"
argument_list|,
name|locase
argument_list|(
name|pname
argument_list|)
argument_list|,
name|vnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * print a useful (?) error message, and then die  */
end_comment

begin_function
name|void
name|error
parameter_list|(
name|msg
parameter_list|)
name|char
modifier|*
name|msg
decl_stmt|;
block|{
name|printwhere
argument_list|()
expr_stmt|;
name|warnx
argument_list|(
literal|"%s, line %d: %s"
argument_list|,
name|infilename
argument_list|,
name|linenum
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Something went wrong, unlink any files that we may have created and then  * die.  */
end_comment

begin_function
name|void
name|crash
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nfiles
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfiles
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|record_open
parameter_list|(
name|file
parameter_list|)
name|char
modifier|*
name|file
decl_stmt|;
block|{
if|if
condition|(
name|nfiles
operator|<
name|NFILES
condition|)
block|{
name|outfiles
index|[
name|nfiles
operator|++
index|]
operator|=
name|file
expr_stmt|;
block|}
else|else
block|{
name|warnx
argument_list|(
literal|"too many files"
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|expectbuf
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|toktostr
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/*  * error, token encountered was not the expected one  */
end_comment

begin_function
name|void
name|expected1
parameter_list|(
name|exp1
parameter_list|)
name|tok_kind
name|exp1
decl_stmt|;
block|{
name|s_print
argument_list|(
name|expectbuf
argument_list|,
literal|"expected '%s'"
argument_list|,
name|toktostr
argument_list|(
name|exp1
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|expectbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * error, token encountered was not one of two expected ones  */
end_comment

begin_function
name|void
name|expected2
parameter_list|(
name|exp1
parameter_list|,
name|exp2
parameter_list|)
name|tok_kind
name|exp1
decl_stmt|,
name|exp2
decl_stmt|;
block|{
name|s_print
argument_list|(
name|expectbuf
argument_list|,
literal|"expected '%s' or '%s'"
argument_list|,
name|toktostr
argument_list|(
name|exp1
argument_list|)
argument_list|,
name|toktostr
argument_list|(
name|exp2
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|expectbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * error, token encountered was not one of 3 expected ones  */
end_comment

begin_function
name|void
name|expected3
parameter_list|(
name|exp1
parameter_list|,
name|exp2
parameter_list|,
name|exp3
parameter_list|)
name|tok_kind
name|exp1
decl_stmt|,
name|exp2
decl_stmt|,
name|exp3
decl_stmt|;
block|{
name|s_print
argument_list|(
name|expectbuf
argument_list|,
literal|"expected '%s', '%s' or '%s'"
argument_list|,
name|toktostr
argument_list|(
name|exp1
argument_list|)
argument_list|,
name|toktostr
argument_list|(
name|exp2
argument_list|)
argument_list|,
name|toktostr
argument_list|(
name|exp3
argument_list|)
argument_list|)
expr_stmt|;
name|error
argument_list|(
name|expectbuf
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|tabify
parameter_list|(
name|f
parameter_list|,
name|tab
parameter_list|)
name|FILE
modifier|*
name|f
decl_stmt|;
name|int
name|tab
decl_stmt|;
block|{
while|while
condition|(
name|tab
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\t'
argument_list|,
name|f
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|token
name|tokstrings
index|[]
init|=
block|{
block|{
name|TOK_IDENT
block|,
literal|"identifier"
block|}
block|,
block|{
name|TOK_CONST
block|,
literal|"const"
block|}
block|,
block|{
name|TOK_RPAREN
block|,
literal|")"
block|}
block|,
block|{
name|TOK_LPAREN
block|,
literal|"("
block|}
block|,
block|{
name|TOK_RBRACE
block|,
literal|"}"
block|}
block|,
block|{
name|TOK_LBRACE
block|,
literal|"{"
block|}
block|,
block|{
name|TOK_LBRACKET
block|,
literal|"["
block|}
block|,
block|{
name|TOK_RBRACKET
block|,
literal|"]"
block|}
block|,
block|{
name|TOK_STAR
block|,
literal|"*"
block|}
block|,
block|{
name|TOK_COMMA
block|,
literal|","
block|}
block|,
block|{
name|TOK_EQUAL
block|,
literal|"="
block|}
block|,
block|{
name|TOK_COLON
block|,
literal|":"
block|}
block|,
block|{
name|TOK_SEMICOLON
block|,
literal|";"
block|}
block|,
block|{
name|TOK_UNION
block|,
literal|"union"
block|}
block|,
block|{
name|TOK_STRUCT
block|,
literal|"struct"
block|}
block|,
block|{
name|TOK_SWITCH
block|,
literal|"switch"
block|}
block|,
block|{
name|TOK_CASE
block|,
literal|"case"
block|}
block|,
block|{
name|TOK_DEFAULT
block|,
literal|"default"
block|}
block|,
block|{
name|TOK_ENUM
block|,
literal|"enum"
block|}
block|,
block|{
name|TOK_TYPEDEF
block|,
literal|"typedef"
block|}
block|,
block|{
name|TOK_INT
block|,
literal|"int"
block|}
block|,
block|{
name|TOK_SHORT
block|,
literal|"short"
block|}
block|,
block|{
name|TOK_LONG
block|,
literal|"long"
block|}
block|,
block|{
name|TOK_UNSIGNED
block|,
literal|"unsigned"
block|}
block|,
block|{
name|TOK_DOUBLE
block|,
literal|"double"
block|}
block|,
block|{
name|TOK_FLOAT
block|,
literal|"float"
block|}
block|,
block|{
name|TOK_CHAR
block|,
literal|"char"
block|}
block|,
block|{
name|TOK_STRING
block|,
literal|"string"
block|}
block|,
block|{
name|TOK_OPAQUE
block|,
literal|"opaque"
block|}
block|,
block|{
name|TOK_BOOL
block|,
literal|"bool"
block|}
block|,
block|{
name|TOK_VOID
block|,
literal|"void"
block|}
block|,
block|{
name|TOK_PROGRAM
block|,
literal|"program"
block|}
block|,
block|{
name|TOK_VERSION
block|,
literal|"version"
block|}
block|,
block|{
name|TOK_EOF
block|,
literal|"??????"
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|char
modifier|*
name|toktostr
parameter_list|(
name|kind
parameter_list|)
name|tok_kind
name|kind
decl_stmt|;
block|{
name|token
modifier|*
name|sp
decl_stmt|;
for|for
control|(
name|sp
operator|=
name|tokstrings
init|;
name|sp
operator|->
name|kind
operator|!=
name|TOK_EOF
operator|&&
name|sp
operator|->
name|kind
operator|!=
name|kind
condition|;
name|sp
operator|++
control|)
empty_stmt|;
return|return
operator|(
name|sp
operator|->
name|str
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|printbuf
parameter_list|()
block|{
name|char
name|c
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|cnt
decl_stmt|;
define|#
directive|define
name|TABSIZE
value|4
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|c
operator|=
name|curline
index|[
name|i
index|]
operator|)
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|cnt
operator|=
literal|8
operator|-
operator|(
name|i
operator|%
name|TABSIZE
operator|)
expr_stmt|;
name|c
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printwhere
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|printbuf
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|where
operator|-
name|curline
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|curline
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\t'
condition|)
block|{
name|cnt
operator|=
literal|8
operator|-
operator|(
name|i
operator|%
name|TABSIZE
operator|)
expr_stmt|;
block|}
else|else
block|{
name|cnt
operator|=
literal|1
expr_stmt|;
block|}
while|while
condition|(
name|cnt
operator|--
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'^'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|char
modifier|*
name|make_argname
parameter_list|(
name|pname
parameter_list|,
name|vname
parameter_list|)
name|char
modifier|*
name|pname
decl_stmt|;
name|char
modifier|*
name|vname
decl_stmt|;
block|{
name|char
modifier|*
name|name
decl_stmt|;
name|name
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|pname
argument_list|)
operator|+
name|strlen
argument_list|(
name|vname
argument_list|)
operator|+
name|strlen
argument_list|(
name|ARGEXT
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|name
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed in malloc"
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|name
argument_list|,
literal|"%s_%s_%s"
argument_list|,
name|locase
argument_list|(
name|pname
argument_list|)
argument_list|,
name|vname
argument_list|,
name|ARGEXT
argument_list|)
expr_stmt|;
return|return
operator|(
name|name
operator|)
return|;
block|}
end_function

begin_decl_stmt
name|bas_type
modifier|*
name|typ_list_h
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|bas_type
modifier|*
name|typ_list_t
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|add_type
parameter_list|(
name|len
parameter_list|,
name|type
parameter_list|)
name|int
name|len
decl_stmt|;
name|char
modifier|*
name|type
decl_stmt|;
block|{
name|bas_type
modifier|*
name|ptr
decl_stmt|;
if|if
condition|(
operator|(
name|ptr
operator|=
operator|(
name|bas_type
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|bas_type
argument_list|)
argument_list|)
operator|)
operator|==
operator|(
name|bas_type
operator|*
operator|)
name|NULL
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"failed in malloc"
argument_list|)
expr_stmt|;
name|ptr
operator|->
name|name
operator|=
name|type
expr_stmt|;
name|ptr
operator|->
name|length
operator|=
name|len
expr_stmt|;
name|ptr
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|typ_list_t
operator|==
name|NULL
condition|)
block|{
name|typ_list_t
operator|=
name|ptr
expr_stmt|;
name|typ_list_h
operator|=
name|ptr
expr_stmt|;
block|}
else|else
block|{
name|typ_list_t
operator|->
name|next
operator|=
name|ptr
expr_stmt|;
name|typ_list_t
operator|=
name|ptr
expr_stmt|;
block|}
empty_stmt|;
block|}
end_function

begin_function
name|bas_type
modifier|*
name|find_type
parameter_list|(
name|type
parameter_list|)
name|char
modifier|*
name|type
decl_stmt|;
block|{
name|bas_type
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|typ_list_h
expr_stmt|;
while|while
condition|(
name|ptr
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|ptr
operator|->
name|name
argument_list|,
name|type
argument_list|)
operator|==
literal|0
condition|)
return|return
operator|(
name|ptr
operator|)
return|;
else|else
name|ptr
operator|=
name|ptr
operator|->
name|next
expr_stmt|;
block|}
empty_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

end_unit

