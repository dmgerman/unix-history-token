begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Sun RPC is a product of Sun Microsystems, Inc. and is provided for  * unrestricted use provided that this legend is included on all tape  * media and as a part of the software program in whole or part.  Users  * may copy or modify Sun RPC without charge, but are not authorized  * to license or distribute it to anyone else except as part of a product or  * program developed by the user.  *  * SUN RPC IS PROVIDED AS IS WITH NO WARRANTIES OF ANY KIND INCLUDING THE  * WARRANTIES OF DESIGN, MERCHANTIBILITY AND FITNESS FOR A PARTICULAR  * PURPOSE, OR ARISING FROM A COURSE OF DEALING, USAGE OR TRADE PRACTICE.  *  * Sun RPC is provided with no support and without any obligation on the  * part of Sun Microsystems, Inc. to assist in its use, correction,  * modification or enhancement.  *  * SUN MICROSYSTEMS, INC. SHALL HAVE NO LIABILITY WITH RESPECT TO THE  * INFRINGEMENT OF COPYRIGHTS, TRADE SECRETS OR ANY PATENTS BY SUN RPC  * OR ANY PART THEREOF.  *  * In no event will Sun Microsystems, Inc. be liable for any lost revenue  * or profits or other special, indirect and consequential damages, even if  * Sun has been advised of the possibility of such damages.  *  * Sun Microsystems, Inc.  * 2550 Garcia Avenue  * Mountain View, California  94043  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_empty
empty|#ident	"@(#)rpc_main.c	1.21	94/04/25 SMI"
end_empty

begin_endif
unit|static char sccsid[] = "@(#)rpc_main.c 1.30 89/03/30 (C) 1987 SMI";
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * rpc_main.c, Top level of the RPC protocol compiler.  * Copyright (C) 1987, Sun Microsystems, Inc.  */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"rpc_parse.h"
end_include

begin_include
include|#
directive|include
file|"rpc_scan.h"
end_include

begin_include
include|#
directive|include
file|"rpc_util.h"
end_include

begin_function_decl
specifier|static
name|void
name|c_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|h_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|l_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|t_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|clnt_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|generate_guard
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|c_initialize
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|options_usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|do_registers
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|parseargs
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
name|struct
name|commandline
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|svc_output
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|mkfile_output
parameter_list|(
name|struct
name|commandline
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|s_output
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|EXTEND
value|1
end_define

begin_comment
comment|/* alias for TRUE */
end_comment

begin_define
define|#
directive|define
name|DONT_EXTEND
value|0
end_define

begin_comment
comment|/* alias for FALSE */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|svcclosetime
init|=
literal|"120"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|CPP
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|CPPFLAGS
index|[]
init|=
literal|"-C"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pathbuf
index|[
name|MAXPATHLEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|allv
index|[]
init|=
block|{
literal|"rpcgen"
block|,
literal|"-s"
block|,
literal|"udp"
block|,
literal|"-s"
block|,
literal|"tcp"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allc
init|=
sizeof|sizeof
argument_list|(
name|allv
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|allv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|allnv
index|[]
init|=
block|{
literal|"rpcgen"
block|,
literal|"-s"
block|,
literal|"netpath"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|allnc
init|=
sizeof|sizeof
argument_list|(
name|allnv
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|allnv
index|[
literal|0
index|]
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * machinations for handling expanding argument list  */
end_comment

begin_function_decl
specifier|static
name|void
name|addarg
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* add another argument to the list */
end_comment

begin_function_decl
specifier|static
name|void
name|insarg
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* insert arg at specified location */
end_comment

begin_function_decl
specifier|static
name|void
name|clear_args
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* clear argument list */
end_comment

begin_function_decl
specifier|static
name|void
name|checkfiles
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* check if out file already exists */
end_comment

begin_define
define|#
directive|define
name|ARGLISTLEN
value|20
end_define

begin_define
define|#
directive|define
name|FIXEDARGS
value|0
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|arglist
index|[
name|ARGLISTLEN
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|argcount
init|=
name|FIXEDARGS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|nonfatalerrors
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* errors */
end_comment

begin_decl_stmt
name|int
name|inetdflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for inetd is disabled by default, use -I */
end_comment

begin_decl_stmt
name|int
name|pmflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for port monitors is disabled by default */
end_comment

begin_decl_stmt
name|int
name|tirpc_socket
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TI-RPC on socket, no TLI library */
end_comment

begin_decl_stmt
name|int
name|logflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Use syslog instead of fprintf for errors */
end_comment

begin_decl_stmt
name|int
name|tblflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for dispatch table file */
end_comment

begin_decl_stmt
name|int
name|mtflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Support for MT */
end_comment

begin_define
define|#
directive|define
name|INLINE
value|0
end_define

begin_comment
comment|/* length at which to start doing an inline */
end_comment

begin_decl_stmt
name|int
name|inline_size
init|=
name|INLINE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Length at which to start doing an inline. INLINE = default  * if 0, no xdr_inline code  */
end_comment

begin_decl_stmt
name|int
name|indefinitewait
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If started by port monitors, hang till it wants */
end_comment

begin_decl_stmt
name|int
name|exitnow
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* If started by port monitors, exit after the call */
end_comment

begin_decl_stmt
name|int
name|timerflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if !indefinite&& !exitnow */
end_comment

begin_decl_stmt
name|int
name|newstyle
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* newstyle of passing arguments (by value) */
end_comment

begin_decl_stmt
name|int
name|CCflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* C++ files */
end_comment

begin_decl_stmt
specifier|static
name|int
name|allfiles
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generate all files */
end_comment

begin_decl_stmt
name|int
name|tirpcflag
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* generating code for tirpc, by default */
end_comment

begin_decl_stmt
name|xdrfunc
modifier|*
name|xdrfunc_head
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* xdr function list */
end_comment

begin_decl_stmt
name|xdrfunc
modifier|*
name|xdrfunc_tail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* xdr function list */
end_comment

begin_decl_stmt
name|pid_t
name|childpid
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|commandline
name|cmd
decl_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|cmd
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|commandline
argument_list|)
argument_list|)
expr_stmt|;
name|clear_args
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|parseargs
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|cmd
argument_list|)
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* 	 * Only the client and server side stubs are likely to be customized, 	 *  so in that case only, check if the outfile exists, and if so, 	 *  print an error message and exit. 	 */
if|if
condition|(
name|cmd
operator|.
name|Ssflag
operator|||
name|cmd
operator|.
name|Scflag
operator|||
name|cmd
operator|.
name|makefileflag
condition|)
block|{
name|checkfiles
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
else|else
name|checkfiles
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|.
name|cflag
condition|)
block|{
name|c_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_XDR"
argument_list|,
name|DONT_EXTEND
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|hflag
condition|)
block|{
name|h_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_HDR"
argument_list|,
name|DONT_EXTEND
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|,
name|cmd
operator|.
name|hflag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|lflag
condition|)
block|{
name|l_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_CLNT"
argument_list|,
name|DONT_EXTEND
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|sflag
operator|||
name|cmd
operator|.
name|mflag
operator|||
operator|(
name|cmd
operator|.
name|nflag
operator|)
condition|)
block|{
name|s_output
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_SVC"
argument_list|,
name|DONT_EXTEND
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|,
name|cmd
operator|.
name|mflag
argument_list|,
name|cmd
operator|.
name|nflag
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|tflag
condition|)
block|{
name|t_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_TBL"
argument_list|,
name|DONT_EXTEND
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|Ssflag
condition|)
block|{
name|svc_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_SERVER"
argument_list|,
name|DONT_EXTEND
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|Scflag
condition|)
block|{
name|clnt_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_CLIENT"
argument_list|,
name|DONT_EXTEND
argument_list|,
name|cmd
operator|.
name|outfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cmd
operator|.
name|makefileflag
condition|)
block|{
name|mkfile_output
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* the rescans are required, since cpp may effect input */
name|c_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_XDR"
argument_list|,
name|EXTEND
argument_list|,
literal|"_xdr.c"
argument_list|)
expr_stmt|;
name|reinitialize
argument_list|()
expr_stmt|;
name|h_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_HDR"
argument_list|,
name|EXTEND
argument_list|,
literal|".h"
argument_list|,
name|cmd
operator|.
name|hflag
argument_list|)
expr_stmt|;
name|reinitialize
argument_list|()
expr_stmt|;
name|l_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_CLNT"
argument_list|,
name|EXTEND
argument_list|,
literal|"_clnt.c"
argument_list|)
expr_stmt|;
name|reinitialize
argument_list|()
expr_stmt|;
if|if
condition|(
name|inetdflag
operator|||
operator|!
name|tirpcflag
condition|)
name|s_output
argument_list|(
name|allc
argument_list|,
name|allv
argument_list|,
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_SVC"
argument_list|,
name|EXTEND
argument_list|,
literal|"_svc.c"
argument_list|,
name|cmd
operator|.
name|mflag
argument_list|,
name|cmd
operator|.
name|nflag
argument_list|)
expr_stmt|;
else|else
name|s_output
argument_list|(
name|allnc
argument_list|,
name|allnv
argument_list|,
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_SVC"
argument_list|,
name|EXTEND
argument_list|,
literal|"_svc.c"
argument_list|,
name|cmd
operator|.
name|mflag
argument_list|,
name|cmd
operator|.
name|nflag
argument_list|)
expr_stmt|;
if|if
condition|(
name|tblflag
condition|)
block|{
name|reinitialize
argument_list|()
expr_stmt|;
name|t_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_TBL"
argument_list|,
name|EXTEND
argument_list|,
literal|"_tbl.i"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allfiles
condition|)
block|{
name|reinitialize
argument_list|()
expr_stmt|;
name|svc_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_SERVER"
argument_list|,
name|EXTEND
argument_list|,
literal|"_server.c"
argument_list|)
expr_stmt|;
name|reinitialize
argument_list|()
expr_stmt|;
name|clnt_output
argument_list|(
name|cmd
operator|.
name|infile
argument_list|,
literal|"-DRPC_CLIENT"
argument_list|,
name|EXTEND
argument_list|,
literal|"_client.c"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|allfiles
operator|||
operator|(
name|cmd
operator|.
name|makefileflag
operator|==
literal|1
operator|)
condition|)
block|{
name|reinitialize
argument_list|()
expr_stmt|;
name|mkfile_output
argument_list|(
operator|&
name|cmd
argument_list|)
expr_stmt|;
block|}
block|}
name|exit
argument_list|(
name|nonfatalerrors
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
end_function

begin_comment
comment|/*  * add extension to filename  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|extendfile
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|,
specifier|const
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|char
modifier|*
name|res
decl_stmt|;
specifier|const
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
if|if
condition|(
operator|(
name|file
operator|=
name|strrchr
argument_list|(
name|path
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|file
operator|=
name|path
expr_stmt|;
else|else
name|file
operator|++
expr_stmt|;
name|res
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
name|file
argument_list|)
operator|+
name|strlen
argument_list|(
name|ext
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p
operator|=
name|strrchr
argument_list|(
name|file
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
name|p
operator|=
name|file
operator|+
name|strlen
argument_list|(
name|file
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|res
argument_list|,
name|file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|res
operator|+
operator|(
name|p
operator|-
name|file
operator|)
argument_list|,
name|ext
argument_list|)
expr_stmt|;
return|return
operator|(
name|res
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Open output file with given extension  */
end_comment

begin_function
specifier|static
name|void
name|open_output
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
if|if
condition|(
name|outfile
operator|==
name|NULL
condition|)
block|{
name|fout
operator|=
name|stdout
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|infile
operator|!=
name|NULL
operator|&&
name|streq
argument_list|(
name|outfile
argument_list|,
name|infile
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"%s already exists. No output generated"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
name|fout
operator|=
name|fopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"unable to open %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
name|record_open
argument_list|(
name|outfile
argument_list|)
expr_stmt|;
return|return;
block|}
end_function

begin_function
specifier|static
name|void
name|add_warning
parameter_list|(
name|void
parameter_list|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"/*\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|" * Please do not edit this file.\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|" * It was generated using rpcgen.\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|" */\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* clear list of arguments */
end_comment

begin_function
specifier|static
name|void
name|clear_args
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
name|FIXEDARGS
init|;
name|i
operator|<
name|ARGLISTLEN
condition|;
name|i
operator|++
control|)
name|arglist
index|[
name|i
index|]
operator|=
name|NULL
expr_stmt|;
name|argcount
operator|=
name|FIXEDARGS
expr_stmt|;
block|}
end_function

begin_comment
comment|/* prepend C-preprocessor and flags before arguments */
end_comment

begin_function
specifier|static
name|void
name|prepend_cpp
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|idx
init|=
literal|1
decl_stmt|;
specifier|const
name|char
modifier|*
name|var
decl_stmt|;
name|char
modifier|*
name|dupvar
decl_stmt|,
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
if|if
condition|(
name|CPP
operator|!=
name|NULL
condition|)
name|insarg
argument_list|(
literal|0
argument_list|,
name|CPP
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|var
operator|=
name|getenv
argument_list|(
literal|"RPCGEN_CPP"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|insarg
argument_list|(
literal|0
argument_list|,
literal|"/usr/bin/cpp"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Parse command line in a rudimentary way */
name|dupvar
operator|=
name|xstrdup
argument_list|(
name|var
argument_list|)
expr_stmt|;
for|for
control|(
name|s
operator|=
name|dupvar
operator|,
name|idx
operator|=
literal|0
init|;
operator|(
name|t
operator|=
name|strsep
argument_list|(
operator|&
name|s
argument_list|,
literal|" \t"
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
name|t
index|[
literal|0
index|]
condition|)
name|insarg
argument_list|(
name|idx
operator|++
argument_list|,
name|t
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|dupvar
argument_list|)
expr_stmt|;
block|}
name|insarg
argument_list|(
name|idx
argument_list|,
name|CPPFLAGS
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open input file with given define for C-preprocessor  */
end_comment

begin_function
specifier|static
name|void
name|open_input
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|)
block|{
name|int
name|pd
index|[
literal|2
index|]
decl_stmt|;
name|infilename
operator|=
operator|(
name|infile
operator|==
name|NULL
operator|)
condition|?
literal|"<stdin>"
else|:
name|infile
expr_stmt|;
operator|(
name|void
operator|)
name|pipe
argument_list|(
name|pd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|childpid
operator|=
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
name|prepend_cpp
argument_list|()
expr_stmt|;
name|addarg
argument_list|(
name|define
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
condition|)
name|addarg
argument_list|(
name|infile
argument_list|)
expr_stmt|;
name|addarg
argument_list|(
operator|(
name|char
operator|*
operator|)
name|NULL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup2
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|,
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|execvp
argument_list|(
name|arglist
index|[
literal|0
index|]
argument_list|,
name|arglist
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"execvp %s"
argument_list|,
name|arglist
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
case|case
operator|-
literal|1
case|:
name|err
argument_list|(
literal|1
argument_list|,
literal|"fork"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|pd
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|fin
operator|=
name|fdopen
argument_list|(
name|pd
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|infilename
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* valid tirpc nettypes */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|valid_ti_nettypes
index|[]
init|=
block|{
literal|"netpath"
block|,
literal|"visible"
block|,
literal|"circuit_v"
block|,
literal|"datagram_v"
block|,
literal|"circuit_n"
block|,
literal|"datagram_n"
block|,
literal|"udp"
block|,
literal|"tcp"
block|,
literal|"raw"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* valid inetd nettypes */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|valid_i_nettypes
index|[]
init|=
block|{
literal|"udp"
block|,
literal|"tcp"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|check_nettype
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
specifier|const
name|char
modifier|*
name|list_to_check
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|list_to_check
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|name
argument_list|,
name|list_to_check
index|[
name|i
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
name|warnx
argument_list|(
literal|"illegal nettype :\'%s\'"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|file_name
parameter_list|(
specifier|const
name|char
modifier|*
name|file
parameter_list|,
specifier|const
name|char
modifier|*
name|ext
parameter_list|)
block|{
name|char
modifier|*
name|temp
decl_stmt|;
name|temp
operator|=
name|extendfile
argument_list|(
name|file
argument_list|,
name|ext
argument_list|)
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|temp
argument_list|,
name|F_OK
argument_list|)
operator|!=
operator|-
literal|1
condition|)
return|return
operator|(
name|temp
operator|)
return|;
else|else
return|return
operator|(
literal|" "
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|c_output
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|,
name|int
name|extend
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|definition
modifier|*
name|def
decl_stmt|;
name|char
modifier|*
name|include
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
name|long
name|tell
decl_stmt|;
name|c_initialize
argument_list|()
expr_stmt|;
name|open_input
argument_list|(
name|infile
argument_list|,
name|define
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|extend
condition|?
name|extendfile
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
else|:
name|outfile
expr_stmt|;
name|open_output
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|add_warning
argument_list|()
expr_stmt|;
if|if
condition|(
name|infile
operator|&&
operator|(
name|include
operator|=
name|extendfile
argument_list|(
name|infile
argument_list|,
literal|".h"
argument_list|)
operator|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|include
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|include
argument_list|)
expr_stmt|;
comment|/* .h file already contains rpc/rpc.h */
block|}
else|else
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/rpc.h>\n"
argument_list|)
expr_stmt|;
name|tell
operator|=
name|ftell
argument_list|(
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|def
operator|=
name|get_definition
argument_list|()
operator|)
condition|)
block|{
name|emit
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extend
operator|&&
name|tell
operator|==
name|ftell
argument_list|(
name|fout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|c_initialize
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* add all the starting basic types */
name|add_type
argument_list|(
literal|1
argument_list|,
literal|"int"
argument_list|)
expr_stmt|;
name|add_type
argument_list|(
literal|1
argument_list|,
literal|"long"
argument_list|)
expr_stmt|;
name|add_type
argument_list|(
literal|1
argument_list|,
literal|"short"
argument_list|)
expr_stmt|;
name|add_type
argument_list|(
literal|1
argument_list|,
literal|"bool"
argument_list|)
expr_stmt|;
name|add_type
argument_list|(
literal|1
argument_list|,
literal|"u_int"
argument_list|)
expr_stmt|;
name|add_type
argument_list|(
literal|1
argument_list|,
literal|"u_long"
argument_list|)
expr_stmt|;
name|add_type
argument_list|(
literal|1
argument_list|,
literal|"u_short"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|const
name|char
name|rpcgen_table_dcl
index|[]
init|=
literal|"struct rpcgen_table {\n\ 	char	*(*proc)(); \n\ 	xdrproc_t	xdr_arg; \n\ 	unsigned	len_arg; \n\ 	xdrproc_t	xdr_res; \n\ 	unsigned	len_res; \n\ }; \n"
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|generate_guard
parameter_list|(
specifier|const
name|char
modifier|*
name|pathname
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
name|char
modifier|*
name|guard
decl_stmt|,
modifier|*
name|tmp
decl_stmt|,
modifier|*
name|stopat
decl_stmt|;
name|filename
operator|=
name|strrchr
argument_list|(
name|pathname
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
comment|/* find last component */
name|filename
operator|=
operator|(
operator|(
name|filename
operator|==
literal|0
operator|)
condition|?
name|pathname
else|:
name|filename
operator|+
literal|1
operator|)
expr_stmt|;
name|guard
operator|=
name|xstrdup
argument_list|(
name|filename
argument_list|)
expr_stmt|;
name|stopat
operator|=
name|strrchr
argument_list|(
name|guard
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
comment|/* 	 * Convert to a valid C macro name and make it upper case. 	 * Map macro unfriendly characterss to '_'. 	 */
for|for
control|(
name|tmp
operator|=
name|guard
init|;
operator|*
name|tmp
operator|!=
literal|'\000'
condition|;
operator|++
name|tmp
control|)
block|{
if|if
condition|(
name|islower
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
operator|*
name|tmp
operator|=
name|toupper
argument_list|(
operator|*
name|tmp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|tmp
argument_list|)
operator|||
operator|*
name|tmp
operator|==
literal|'_'
condition|)
comment|/* OK for C */
empty_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
name|guard
condition|)
operator|*
name|tmp
operator|=
literal|'_'
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|tmp
argument_list|)
condition|)
comment|/* OK for all but first character */
empty_stmt|;
elseif|else
if|if
condition|(
name|tmp
operator|==
name|stopat
condition|)
block|{
operator|*
name|tmp
operator|=
literal|'\0'
expr_stmt|;
break|break;
block|}
else|else
operator|*
name|tmp
operator|=
literal|'_'
expr_stmt|;
block|}
comment|/* 	 * Can't have a '_' in front, because it'll end up being "__". 	 * "__" macros shoudln't be used. So, remove all of the 	 * '_' characters from the front. 	 */
if|if
condition|(
operator|*
name|guard
operator|==
literal|'_'
condition|)
block|{
for|for
control|(
name|tmp
operator|=
name|guard
init|;
operator|*
name|tmp
operator|==
literal|'_'
condition|;
operator|++
name|tmp
control|)
empty_stmt|;
name|strcpy
argument_list|(
name|guard
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
block|}
name|guard
operator|=
name|extendfile
argument_list|(
name|guard
argument_list|,
literal|"_H_RPCGEN"
argument_list|)
expr_stmt|;
return|return
operator|(
name|guard
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compile into an XDR header file  */
end_comment

begin_function
specifier|static
name|void
name|h_output
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|,
name|int
name|extend
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|,
name|int
name|headeronly
parameter_list|)
block|{
name|definition
modifier|*
name|def
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
name|long
name|tell
decl_stmt|;
specifier|const
name|char
modifier|*
name|guard
decl_stmt|;
name|list
modifier|*
name|l
decl_stmt|;
name|xdrfunc
modifier|*
name|xdrfuncp
decl_stmt|;
name|open_input
argument_list|(
name|infile
argument_list|,
name|define
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|extend
condition|?
name|extendfile
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
else|:
name|outfile
expr_stmt|;
name|open_output
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|add_warning
argument_list|()
expr_stmt|;
if|if
condition|(
name|outfilename
operator|||
name|infile
condition|)
block|{
name|guard
operator|=
name|generate_guard
argument_list|(
name|outfilename
condition|?
name|outfilename
else|:
name|infile
argument_list|)
expr_stmt|;
block|}
else|else
name|guard
operator|=
literal|"STDIN_"
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#ifndef _%s\n#define	_%s\n\n"
argument_list|,
name|guard
argument_list|,
name|guard
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/rpc.h>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtflag
condition|)
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<pthread.h>\n"
argument_list|)
expr_stmt|;
comment|/* put the C++ support */
if|if
condition|(
operator|!
name|CCflag
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n#ifdef __cplusplus\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"extern \"C\" {\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#endif\n\n"
argument_list|)
expr_stmt|;
block|}
comment|/* put in a typedef for quadprecision. Only with Cflag */
name|tell
operator|=
name|ftell
argument_list|(
name|fout
argument_list|)
expr_stmt|;
comment|/* print data definitions */
while|while
condition|(
operator|(
name|def
operator|=
name|get_definition
argument_list|()
operator|)
condition|)
block|{
name|print_datadef
argument_list|(
name|def
argument_list|,
name|headeronly
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * print function declarations. 	 *  Do this after data definitions because they might be used as 	 *  arguments for functions 	 */
for|for
control|(
name|l
operator|=
name|defined
init|;
name|l
operator|!=
name|NULL
condition|;
name|l
operator|=
name|l
operator|->
name|next
control|)
block|{
name|print_funcdef
argument_list|(
name|l
operator|->
name|val
argument_list|,
name|headeronly
argument_list|)
expr_stmt|;
block|}
comment|/* Now  print all xdr func declarations */
if|if
condition|(
name|xdrfunc_head
operator|!=
name|NULL
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n/* the xdr functions */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|CCflag
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n#ifdef __cplusplus\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"extern \"C\" {\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
name|xdrfuncp
operator|=
name|xdrfunc_head
expr_stmt|;
while|while
condition|(
name|xdrfuncp
operator|!=
name|NULL
condition|)
block|{
name|print_xdr_func_def
argument_list|(
name|xdrfuncp
operator|->
name|name
argument_list|,
name|xdrfuncp
operator|->
name|pointerp
argument_list|)
expr_stmt|;
name|xdrfuncp
operator|=
name|xdrfuncp
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|extend
operator|&&
name|tell
operator|==
name|ftell
argument_list|(
name|fout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|tblflag
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
name|rpcgen_table_dcl
argument_list|)
expr_stmt|;
block|}
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n#ifdef __cplusplus\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"}\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n#endif /* !_%s */\n"
argument_list|,
name|guard
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Compile into an RPC service  */
end_comment

begin_function
specifier|static
name|void
name|s_output
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|,
name|int
name|extend
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|,
name|int
name|nomain
parameter_list|,
name|int
name|netflag
parameter_list|)
block|{
name|char
modifier|*
name|include
decl_stmt|;
name|definition
modifier|*
name|def
decl_stmt|;
name|int
name|foundprogram
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
name|open_input
argument_list|(
name|infile
argument_list|,
name|define
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|extend
condition|?
name|extendfile
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
else|:
name|outfile
expr_stmt|;
name|open_output
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|add_warning
argument_list|()
expr_stmt|;
if|if
condition|(
name|infile
operator|&&
operator|(
name|include
operator|=
name|extendfile
argument_list|(
name|infile
argument_list|,
literal|".h"
argument_list|)
operator|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|include
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|include
argument_list|)
expr_stmt|;
block|}
else|else
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/rpc.h>\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<stdio.h>\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<stdlib.h> /* getenv, exit */\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/pmap_clnt.h> /* for pmap_unset */\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<string.h> /* strcmp */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tirpcflag
condition|)
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/rpc_com.h>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|svcclosetime
argument_list|,
literal|"-1"
argument_list|)
operator|==
literal|0
condition|)
name|indefinitewait
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|svcclosetime
argument_list|,
literal|"0"
argument_list|)
operator|==
literal|0
condition|)
name|exitnow
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
name|inetdflag
operator|||
name|pmflag
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<signal.h>\n"
argument_list|)
expr_stmt|;
name|timerflag
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|tirpcflag
operator|&&
name|inetdflag
condition|)
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<sys/ttycom.h> /* TIOCNOTTY */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inetdflag
operator|||
name|pmflag
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#ifdef __cplusplus\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<sys/sysent.h> /* getdtablesize, open */\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#endif /* __cplusplus */\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tirpcflag
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<fcntl.h> /* open */\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<unistd.h> /* fork / setsid */\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<sys/types.h>\n"
argument_list|)
expr_stmt|;
block|}
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<string.h>\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|inetdflag
operator|||
operator|!
name|tirpcflag
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<sys/socket.h>\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<netinet/in.h>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|netflag
operator|||
name|pmflag
operator|)
operator|&&
name|tirpcflag
operator|&&
operator|!
name|nomain
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<netconfig.h>\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|tirpcflag
condition|)
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<sys/resource.h> /* rlimit */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|logflag
operator|||
name|inetdflag
operator|||
name|pmflag
operator|||
name|tirpcflag
condition|)
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<syslog.h>\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n#ifdef DEBUG\n#define	RPC_SVC_FG\n#endif\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|timerflag
condition|)
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n#define	_RPCSVC_CLOSEDOWN %s\n"
argument_list|,
name|svcclosetime
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|def
operator|=
name|get_definition
argument_list|()
operator|)
condition|)
block|{
name|foundprogram
operator||=
operator|(
name|def
operator|->
name|def_kind
operator|==
name|DEF_PROGRAM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extend
operator|&&
operator|!
name|foundprogram
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
return|return;
block|}
name|write_most
argument_list|(
name|infile
argument_list|,
name|netflag
argument_list|,
name|nomain
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nomain
condition|)
block|{
if|if
condition|(
operator|!
name|do_registers
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
condition|)
block|{
if|if
condition|(
name|outfilename
condition|)
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
block|}
name|write_rest
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * generate client side stubs  */
end_comment

begin_function
specifier|static
name|void
name|l_output
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|,
name|int
name|extend
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|char
modifier|*
name|include
decl_stmt|;
name|definition
modifier|*
name|def
decl_stmt|;
name|int
name|foundprogram
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
name|open_input
argument_list|(
name|infile
argument_list|,
name|define
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|extend
condition|?
name|extendfile
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
else|:
name|outfile
expr_stmt|;
name|open_output
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|add_warning
argument_list|()
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<string.h> /* for memset */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|infile
operator|&&
operator|(
name|include
operator|=
name|extendfile
argument_list|(
name|infile
argument_list|,
literal|".h"
argument_list|)
operator|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|include
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|include
argument_list|)
expr_stmt|;
block|}
else|else
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/rpc.h>\n"
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|def
operator|=
name|get_definition
argument_list|()
operator|)
condition|)
block|{
name|foundprogram
operator||=
operator|(
name|def
operator|->
name|def_kind
operator|==
name|DEF_PROGRAM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extend
operator|&&
operator|!
name|foundprogram
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
return|return;
block|}
name|write_stubs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * generate the dispatch table  */
end_comment

begin_function
specifier|static
name|void
name|t_output
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|,
name|int
name|extend
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|definition
modifier|*
name|def
decl_stmt|;
name|int
name|foundprogram
init|=
literal|0
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
name|open_input
argument_list|(
name|infile
argument_list|,
name|define
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|extend
condition|?
name|extendfile
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
else|:
name|outfile
expr_stmt|;
name|open_output
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|add_warning
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|def
operator|=
name|get_definition
argument_list|()
operator|)
condition|)
block|{
name|foundprogram
operator||=
operator|(
name|def
operator|->
name|def_kind
operator|==
name|DEF_PROGRAM
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|extend
operator|&&
operator|!
name|foundprogram
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
return|return;
block|}
name|write_tables
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* sample routine for the server template */
end_comment

begin_function
specifier|static
name|void
name|svc_output
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|,
name|int
name|extend
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|definition
modifier|*
name|def
decl_stmt|;
name|char
modifier|*
name|include
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
name|long
name|tell
decl_stmt|;
name|open_input
argument_list|(
name|infile
argument_list|,
name|define
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|extend
condition|?
name|extendfile
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
else|:
name|outfile
expr_stmt|;
name|checkfiles
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
comment|/* 	 * Check if outfile already exists. 	 * if so, print an error message and exit 	 */
name|open_output
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|add_sample_msg
argument_list|()
expr_stmt|;
if|if
condition|(
name|infile
operator|&&
operator|(
name|include
operator|=
name|extendfile
argument_list|(
name|infile
argument_list|,
literal|".h"
argument_list|)
operator|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|include
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|include
argument_list|)
expr_stmt|;
block|}
else|else
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/rpc.h>\n"
argument_list|)
expr_stmt|;
name|tell
operator|=
name|ftell
argument_list|(
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|def
operator|=
name|get_definition
argument_list|()
operator|)
condition|)
block|{
name|write_sample_svc
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|extend
operator|&&
name|tell
operator|==
name|ftell
argument_list|(
name|fout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* sample main routine for client */
end_comment

begin_function
specifier|static
name|void
name|clnt_output
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|define
parameter_list|,
name|int
name|extend
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|definition
modifier|*
name|def
decl_stmt|;
name|char
modifier|*
name|include
decl_stmt|;
specifier|const
name|char
modifier|*
name|outfilename
decl_stmt|;
name|long
name|tell
decl_stmt|;
name|int
name|has_program
init|=
literal|0
decl_stmt|;
name|open_input
argument_list|(
name|infile
argument_list|,
name|define
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|extend
condition|?
name|extendfile
argument_list|(
name|infile
argument_list|,
name|outfile
argument_list|)
else|:
name|outfile
expr_stmt|;
name|checkfiles
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
comment|/* 	 * Check if outfile already exists. 	 * if so, print an error message and exit 	 */
name|open_output
argument_list|(
name|infile
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|add_sample_msg
argument_list|()
expr_stmt|;
if|if
condition|(
name|infile
operator|&&
operator|(
name|include
operator|=
name|extendfile
argument_list|(
name|infile
argument_list|,
literal|".h"
argument_list|)
operator|)
condition|)
block|{
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include \"%s\"\n"
argument_list|,
name|include
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|include
argument_list|)
expr_stmt|;
block|}
else|else
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"#include<rpc/rpc.h>\n"
argument_list|)
expr_stmt|;
name|tell
operator|=
name|ftell
argument_list|(
name|fout
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|def
operator|=
name|get_definition
argument_list|()
operator|)
condition|)
block|{
name|has_program
operator|+=
name|write_sample_clnt
argument_list|(
name|def
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|has_program
condition|)
name|write_sample_clnt_main
argument_list|()
expr_stmt|;
if|if
condition|(
name|extend
operator|&&
name|tell
operator|==
name|ftell
argument_list|(
name|fout
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|outfilename
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|mkfile_output
parameter_list|(
name|struct
name|commandline
modifier|*
name|cmd
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|mkfilename
decl_stmt|,
modifier|*
name|clientname
decl_stmt|,
modifier|*
name|clntname
decl_stmt|,
modifier|*
name|xdrname
decl_stmt|,
modifier|*
name|hdrname
decl_stmt|;
specifier|const
name|char
modifier|*
name|servername
decl_stmt|,
modifier|*
name|svcname
decl_stmt|,
modifier|*
name|servprogname
decl_stmt|,
modifier|*
name|clntprogname
decl_stmt|;
name|char
modifier|*
name|temp
decl_stmt|,
modifier|*
name|mkftemp
decl_stmt|;
name|svcname
operator|=
name|file_name
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|"_svc.c"
argument_list|)
expr_stmt|;
name|clntname
operator|=
name|file_name
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|"_clnt.c"
argument_list|)
expr_stmt|;
name|xdrname
operator|=
name|file_name
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|"_xdr.c"
argument_list|)
expr_stmt|;
name|hdrname
operator|=
name|file_name
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|".h"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allfiles
condition|)
block|{
name|servername
operator|=
name|extendfile
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|"_server.c"
argument_list|)
expr_stmt|;
name|clientname
operator|=
name|extendfile
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|"_client.c"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|servername
operator|=
literal|" "
expr_stmt|;
name|clientname
operator|=
literal|" "
expr_stmt|;
block|}
name|servprogname
operator|=
name|extendfile
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|"_server"
argument_list|)
expr_stmt|;
name|clntprogname
operator|=
name|extendfile
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|"_client"
argument_list|)
expr_stmt|;
if|if
condition|(
name|allfiles
condition|)
block|{
name|mkftemp
operator|=
name|xmalloc
argument_list|(
name|strlen
argument_list|(
literal|"makefile."
argument_list|)
operator|+
name|strlen
argument_list|(
name|cmd
operator|->
name|infile
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|temp
operator|=
name|strrchr
argument_list|(
name|cmd
operator|->
name|infile
argument_list|,
literal|'.'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|mkftemp
argument_list|,
literal|"makefile."
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|mkftemp
argument_list|,
name|cmd
operator|->
name|infile
argument_list|,
operator|(
name|temp
operator|-
name|cmd
operator|->
name|infile
operator|)
argument_list|)
expr_stmt|;
name|mkfilename
operator|=
name|mkftemp
expr_stmt|;
block|}
else|else
name|mkfilename
operator|=
name|cmd
operator|->
name|outfile
expr_stmt|;
name|checkfiles
argument_list|(
name|NULL
argument_list|,
name|mkfilename
argument_list|)
expr_stmt|;
name|open_output
argument_list|(
name|NULL
argument_list|,
name|mkfilename
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n# This is a template makefile generated\ 		by rpcgen \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n# Parameters \n\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"CLIENT = %s\nSERVER = %s\n\n"
argument_list|,
name|clntprogname
argument_list|,
name|servprogname
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"SOURCES_CLNT.c = \nSOURCES_CLNT.h = \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"SOURCES_SVC.c = \nSOURCES_SVC.h = \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"SOURCES.x = %s\n\n"
argument_list|,
name|cmd
operator|->
name|infile
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"TARGETS_SVC.c = %s %s %s \n"
argument_list|,
name|svcname
argument_list|,
name|servername
argument_list|,
name|xdrname
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"TARGETS_CLNT.c = %s %s %s \n"
argument_list|,
name|clntname
argument_list|,
name|clientname
argument_list|,
name|xdrname
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"TARGETS = %s %s %s %s %s %s\n\n"
argument_list|,
name|hdrname
argument_list|,
name|xdrname
argument_list|,
name|clntname
argument_list|,
name|svcname
argument_list|,
name|clientname
argument_list|,
name|servername
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"OBJECTS_CLNT = $(SOURCES_CLNT.c:%%.c=%%.o) \ $(TARGETS_CLNT.c:%%.c=%%.o) "
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\nOBJECTS_SVC = $(SOURCES_SVC.c:%%.c=%%.o) \ $(TARGETS_SVC.c:%%.c=%%.o) "
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n# Compiler flags \n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|mtflag
condition|)
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\nCFLAGS += -D_REENTRANT -D_THEAD_SAFE \nLDLIBS += -pthread\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"RPCGENFLAGS = \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\n# Targets \n\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"all : $(CLIENT) $(SERVER)\n\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"$(TARGETS) : $(SOURCES.x) \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\trpcgen $(RPCGENFLAGS) $(SOURCES.x)\n\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"$(OBJECTS_CLNT) : $(SOURCES_CLNT.c) $(SOURCES_CLNT.h) \ $(TARGETS_CLNT.c) \n\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"$(OBJECTS_SVC) : $(SOURCES_SVC.c) $(SOURCES_SVC.h) \ $(TARGETS_SVC.c) \n\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"$(CLIENT) : $(OBJECTS_CLNT) \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\t$(CC) -o $(CLIENT) $(OBJECTS_CLNT) \ $(LDLIBS) \n\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"$(SERVER) : $(OBJECTS_SVC) \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"\t$(CC) -o $(SERVER) $(OBJECTS_SVC) $(LDLIBS)\n\n "
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|fout
argument_list|,
literal|"clean:\n\t $(RM) -f core $(TARGETS) $(OBJECTS_CLNT) \ $(OBJECTS_SVC) $(CLIENT) $(SERVER)\n\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Perform registrations for service output  * Return 0 if failed; 1 otherwise.  */
end_comment

begin_function
specifier|static
name|int
name|do_registers
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|inetdflag
operator|||
operator|!
name|tirpcflag
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|streq
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-s"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|check_nettype
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|valid_i_nettypes
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|write_inetd_register
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|streq
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-s"
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|check_nettype
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|,
name|valid_ti_nettypes
argument_list|)
condition|)
return|return
operator|(
literal|0
operator|)
return|;
name|write_nettype_register
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|streq
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
name|write_netid_register
argument_list|(
name|argv
index|[
name|i
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add another argument to the arg list  */
end_comment

begin_function
specifier|static
name|void
name|addarg
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|argcount
operator|>=
name|ARGLISTLEN
condition|)
block|{
name|warnx
argument_list|(
literal|"too many defines"
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|arglist
index|[
name|argcount
operator|++
index|]
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
else|else
name|arglist
index|[
name|argcount
operator|++
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Insert an argument at the specified location  */
end_comment

begin_function
specifier|static
name|void
name|insarg
parameter_list|(
name|int
name|place
parameter_list|,
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argcount
operator|>=
name|ARGLISTLEN
condition|)
block|{
name|warnx
argument_list|(
literal|"too many defines"
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
comment|/*NOTREACHED*/
block|}
comment|/* Move up existing arguments */
for|for
control|(
name|i
operator|=
name|argcount
operator|-
literal|1
init|;
name|i
operator|>=
name|place
condition|;
name|i
operator|--
control|)
name|arglist
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|arglist
index|[
name|i
index|]
expr_stmt|;
name|arglist
index|[
name|place
index|]
operator|=
name|xstrdup
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|argcount
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * if input file is stdin and an output file is specified then complain  * if the file already exists. Otherwise the file may get overwritten  * If input file does not exist, exit with an error  */
end_comment

begin_function
specifier|static
name|void
name|checkfiles
parameter_list|(
specifier|const
name|char
modifier|*
name|infile
parameter_list|,
specifier|const
name|char
modifier|*
name|outfile
parameter_list|)
block|{
name|struct
name|stat
name|buf
decl_stmt|;
if|if
condition|(
name|infile
condition|)
comment|/* infile ! = NULL */
if|if
condition|(
name|stat
argument_list|(
name|infile
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warn
argument_list|(
literal|"%s"
argument_list|,
name|infile
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
empty_stmt|;
if|if
condition|(
name|outfile
condition|)
block|{
if|if
condition|(
name|stat
argument_list|(
name|outfile
argument_list|,
operator|&
name|buf
argument_list|)
operator|<
literal|0
condition|)
return|return;
comment|/* file does not exist */
else|else
block|{
name|warnx
argument_list|(
literal|"file '%s' already exists and may be overwritten"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|crash
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * Parse command line arguments  */
end_comment

begin_function
specifier|static
name|int
name|parseargs
parameter_list|(
name|int
name|argc
parameter_list|,
specifier|const
name|char
modifier|*
name|argv
index|[]
parameter_list|,
name|struct
name|commandline
modifier|*
name|cmd
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|char
name|c
decl_stmt|,
name|ch
decl_stmt|;
name|char
name|flag
index|[
operator|(
literal|1
operator|<<
literal|8
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
operator|)
index|]
decl_stmt|;
name|int
name|nflags
decl_stmt|;
name|cmd
operator|->
name|infile
operator|=
name|cmd
operator|->
name|outfile
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|allfiles
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'c'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'h'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'l'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'m'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'o'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'s'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'n'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'t'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'S'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'C'
index|]
operator|=
literal|0
expr_stmt|;
name|flag
index|[
literal|'M'
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|infile
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot specify more than one input file"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cmd
operator|->
name|infile
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|j
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
operator|!=
literal|0
condition|;
name|j
operator|++
control|)
block|{
name|c
operator|=
name|argv
index|[
name|i
index|]
index|[
name|j
index|]
expr_stmt|;
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'a'
case|:
name|allfiles
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
case|case
literal|'h'
case|:
case|case
literal|'l'
case|:
case|case
literal|'m'
case|:
case|case
literal|'t'
case|:
if|if
condition|(
name|flag
index|[
operator|(
name|int
operator|)
name|c
index|]
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flag
index|[
operator|(
name|int
operator|)
name|c
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* 					 * sample flag: Ss or Sc. 					 *  Ss means set flag['S']; 					 *  Sc means set flag['C']; 					 *  Sm means set flag['M']; 					 */
name|ch
operator|=
name|argv
index|[
name|i
index|]
index|[
operator|++
name|j
index|]
expr_stmt|;
comment|/* get next char */
if|if
condition|(
name|ch
operator|==
literal|'s'
condition|)
name|ch
operator|=
literal|'S'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'c'
condition|)
name|ch
operator|=
literal|'C'
expr_stmt|;
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'m'
condition|)
name|ch
operator|=
literal|'M'
expr_stmt|;
else|else
return|return
operator|(
literal|0
operator|)
return|;
if|if
condition|(
name|flag
index|[
operator|(
name|int
operator|)
name|ch
index|]
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flag
index|[
operator|(
name|int
operator|)
name|ch
index|]
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
comment|/* ANSI C syntax */
name|ch
operator|=
name|argv
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
expr_stmt|;
comment|/* get next char */
if|if
condition|(
name|ch
operator|!=
literal|'C'
condition|)
break|break;
name|CCflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
comment|/* 					 *  Turn TIRPC flag off for 					 *  generating backward compatible 					 *  code 					 */
name|tirpcflag
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|inetdflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|newstyle
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|logflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|pmflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|svcclosetime
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'T'
case|:
name|tblflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|mtflag
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|inline_size
operator|=
name|atoi
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'n'
case|:
case|case
literal|'o'
case|:
case|case
literal|'s'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
name|i
index|]
index|[
name|j
operator|+
literal|1
index|]
operator|!=
literal|0
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|flag
index|[
operator|(
name|int
operator|)
name|c
index|]
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'o'
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|outfile
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cmd
operator|->
name|outfile
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
goto|goto
name|nextarg
goto|;
case|case
literal|'D'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
name|j
operator|-
literal|1
index|]
operator|!=
literal|'-'
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|addarg
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
goto|goto
name|nextarg
goto|;
case|case
literal|'Y'
case|:
if|if
condition|(
operator|++
name|i
operator|==
name|argc
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strlcpy
argument_list|(
name|pathbuf
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
operator|||
name|strlcat
argument_list|(
name|pathbuf
argument_list|,
literal|"/cpp"
argument_list|,
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
argument_list|)
operator|>=
sizeof|sizeof
argument_list|(
name|pathbuf
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"argument too long"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|CPP
operator|=
name|pathbuf
expr_stmt|;
goto|goto
name|nextarg
goto|;
default|default:
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
name|nextarg
label|:
empty_stmt|;
block|}
block|}
name|cmd
operator|->
name|cflag
operator|=
name|flag
index|[
literal|'c'
index|]
expr_stmt|;
name|cmd
operator|->
name|hflag
operator|=
name|flag
index|[
literal|'h'
index|]
expr_stmt|;
name|cmd
operator|->
name|lflag
operator|=
name|flag
index|[
literal|'l'
index|]
expr_stmt|;
name|cmd
operator|->
name|mflag
operator|=
name|flag
index|[
literal|'m'
index|]
expr_stmt|;
name|cmd
operator|->
name|nflag
operator|=
name|flag
index|[
literal|'n'
index|]
expr_stmt|;
name|cmd
operator|->
name|sflag
operator|=
name|flag
index|[
literal|'s'
index|]
expr_stmt|;
name|cmd
operator|->
name|tflag
operator|=
name|flag
index|[
literal|'t'
index|]
expr_stmt|;
name|cmd
operator|->
name|Ssflag
operator|=
name|flag
index|[
literal|'S'
index|]
expr_stmt|;
name|cmd
operator|->
name|Scflag
operator|=
name|flag
index|[
literal|'C'
index|]
expr_stmt|;
name|cmd
operator|->
name|makefileflag
operator|=
name|flag
index|[
literal|'M'
index|]
expr_stmt|;
if|if
condition|(
name|tirpcflag
condition|)
block|{
if|if
condition|(
name|inetdflag
condition|)
name|pmflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|inetdflag
operator|&&
name|cmd
operator|->
name|nflag
operator|)
condition|)
block|{
comment|/* netid not allowed with inetdflag */
name|warnx
argument_list|(
literal|"cannot use netid flag with inetd flag"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 4.1 mode */
name|pmflag
operator|=
literal|0
expr_stmt|;
comment|/* set pmflag only in tirpcmode */
if|if
condition|(
name|cmd
operator|->
name|nflag
condition|)
block|{
comment|/* netid needs TIRPC */
name|warnx
argument_list|(
literal|"cannot use netid flag without TIRPC"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
if|if
condition|(
name|newstyle
operator|&&
operator|(
name|tblflag
operator|||
name|cmd
operator|->
name|tflag
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot use table flags with newstyle"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* check no conflicts with file generation flags */
name|nflags
operator|=
name|cmd
operator|->
name|cflag
operator|+
name|cmd
operator|->
name|hflag
operator|+
name|cmd
operator|->
name|lflag
operator|+
name|cmd
operator|->
name|mflag
operator|+
name|cmd
operator|->
name|sflag
operator|+
name|cmd
operator|->
name|nflag
operator|+
name|cmd
operator|->
name|tflag
operator|+
name|cmd
operator|->
name|Ssflag
operator|+
name|cmd
operator|->
name|Scflag
operator|+
name|cmd
operator|->
name|makefileflag
expr_stmt|;
if|if
condition|(
name|nflags
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cmd
operator|->
name|outfile
operator|!=
name|NULL
operator|||
name|cmd
operator|->
name|infile
operator|==
name|NULL
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
name|cmd
operator|->
name|infile
operator|==
name|NULL
operator|&&
operator|(
name|cmd
operator|->
name|Ssflag
operator|||
name|cmd
operator|->
name|Scflag
operator|||
name|cmd
operator|->
name|makefileflag
operator|)
condition|)
block|{
name|warnx
argument_list|(
literal|"\"infile\" is required for template generation flags"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|nflags
operator|>
literal|1
condition|)
block|{
name|warnx
argument_list|(
literal|"cannot have more than one file generation flag"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"%s\n%s\n%s\n%s\n%s\n"
argument_list|,
literal|"usage: rpcgen infile"
argument_list|,
literal|"       rpcgen [-abCLNTM] [-Dname[=value]] [-i size]\ [-I -P [-K seconds]] [-Y path] infile"
argument_list|,
literal|"       rpcgen [-c | -h | -l | -m | -t | -Sc | -Ss | -Sm]\ [-o outfile] [infile]"
argument_list|,
literal|"       rpcgen [-s nettype]* [-o outfile] [infile]"
argument_list|,
literal|"       rpcgen [-n netid]* [-o outfile] [infile]"
argument_list|)
expr_stmt|;
name|options_usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|options_usage
parameter_list|(
name|void
parameter_list|)
block|{
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"options:\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-a\t\tgenerate all files, including samples\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-b\t\tbackward compatibility mode (generates code \ for FreeBSD 4.X)\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-c\t\tgenerate XDR routines\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-C\t\tANSI C mode\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-Dname[=value]\tdefine a symbol (same as #define)\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-h\t\tgenerate header file\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-i size\t\tsize at which to start generating\ inline code\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-I\t\tgenerate code for inetd support in server\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-K seconds\tserver exits after K seconds of\ inactivity\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-l\t\tgenerate client side stubs\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-L\t\tserver errors will be printed to syslog\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-m\t\tgenerate server side stubs\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-M\t\tgenerate MT-safe code\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-n netid\tgenerate server code that supports\ named netid\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-N\t\tsupports multiple arguments and\ call-by-value\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-o outfile\tname of the output file\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-P\t\tgenerate code for port monitoring support in server\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-s nettype\tgenerate server code that supports named\ nettype\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-Sc\t\tgenerate sample client code that uses remote\ procedures\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-Ss\t\tgenerate sample server code that defines\ remote procedures\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-Sm \t\tgenerate makefile template \n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-t\t\tgenerate RPC dispatch table\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-T\t\tgenerate code to support RPC dispatch tables\n"
argument_list|)
expr_stmt|;
name|f_print
argument_list|(
name|stderr
argument_list|,
literal|"-Y path\t\tpath where cpp is found\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

