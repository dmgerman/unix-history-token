begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1989 Stephen Deering  * Copyright (c) 1992, 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Stephen Deering of Stanford University.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  *	@(#)mroute.c	8.1 (Berkeley) 6/6/93  */
end_comment

begin_comment
comment|/*  * Print DVMRP multicast routing structures and statistics.  *  * MROUTING 1.0  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/socketvar.h>
end_include

begin_include
include|#
directive|include
file|<sys/protosw.h>
end_include

begin_include
include|#
directive|include
file|<net/if.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<netinet/igmp.h>
end_include

begin_define
define|#
directive|define
name|KERNEL
value|1
end_define

begin_include
include|#
directive|include
file|<netinet/ip_mroute.h>
end_include

begin_undef
undef|#
directive|undef
name|KERNEL
end_undef

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"netstat.h"
end_include

begin_function
name|void
name|mroutepr
parameter_list|(
name|mrpaddr
parameter_list|,
name|mrtaddr
parameter_list|,
name|vifaddr
parameter_list|)
name|u_long
name|mrpaddr
decl_stmt|,
name|mrtaddr
decl_stmt|,
name|vifaddr
decl_stmt|;
block|{
if|#
directive|if
literal|0
block|u_int mrtproto; 	struct mrt *mrttable[MRTHASHSIZ]; 	struct vif viftable[MAXVIFS]; 	register struct mrt *mrt; 	struct mrt smrt; 	register struct vif *v; 	register vifi_t vifi; 	register struct in_addr *grp; 	register int i, n; 	register int banner_printed; 	register int saved_nflag;  	if (mrpaddr == 0) { 		printf("ip_mrtproto: symbol not in namelist\n"); 		return; 	}  	kread(mrpaddr, (char *)&mrtproto, sizeof(mrtproto)); 	switch (mrtproto) {  	case 0: 		printf("no multicast routing compiled into this system\n"); 		return;  	case IGMP_DVMRP: 		break;  	default: 		printf("multicast routing protocol %u, unknown\n", mrtproto); 		return; 	}  	if (mrtaddr == 0) { 		printf("mrttable: symbol not in namelist\n"); 		return; 	} 	if (vifaddr == 0) { 		printf("viftable: symbol not in namelist\n"); 		return; 	}  	saved_nflag = nflag; 	nflag = 1;  	kread(vifaddr, (char *)&viftable, sizeof(viftable)); 	banner_printed = 0; 	for (vifi = 0, v = viftable; vifi< MAXVIFS; ++vifi, ++v) { 		if (v->v_lcl_addr.s_addr == 0) 			continue;  		if (!banner_printed) { 			printf("\nVirtual Interface Table\n%s%s", 			    " Vif   Threshold   Local-Address   ", 			    "Remote-Address   Groups\n"); 			banner_printed = 1; 		}  		printf(" %2u       %3u      %-15.15s", 		    vifi, v->v_threshold, routename(v->v_lcl_addr.s_addr)); 		printf(" %-15.15s\n", (v->v_flags& VIFF_TUNNEL) ? 		    routename(v->v_rmt_addr.s_addr) : "");  		n = v->v_lcl_grps_n; 		grp = (struct in_addr *)malloc(n * sizeof(*grp)); 		if (grp == NULL) { 			printf("v_lcl_grps_n: malloc failed\n"); 			return; 		} 		kread((u_long)v->v_lcl_grps, (caddr_t)grp, n * sizeof(*grp)); 		for (i = 0; i< n; ++i) 			printf("%51s %-15.15s\n", 			    "", routename((grp++)->s_addr)); 		free(grp); 	} 	if (!banner_printed) 		printf("\nVirtual Interface Table is empty\n");  	kread(mrtaddr, (char *)&mrttable, sizeof(mrttable)); 	banner_printed = 0; 	for (i = 0; i< MRTHASHSIZ; ++i) { 		for (mrt = mrttable[i]; mrt != NULL; mrt = mrt->mrt_next) { 			if (!banner_printed) { 				printf("\nMulticast Routing Table\n%s", 				    " Hash  Origin-Subnet  In-Vif  Out-Vifs\n"); 				banner_printed = 1; 			}  			kread((u_long)mrt, (char *)&smrt, sizeof(*mrt)); 			mrt =&smrt; 			printf(" %3u   %-15.15s  %2u   ", 			    i, netname(mrt->mrt_origin.s_addr, 			    ntohl(mrt->mrt_originmask.s_addr)), 			    mrt->mrt_parent); 			for (vifi = 0; vifi< MAXVIFS; ++vifi) 				if (VIFM_ISSET(vifi, mrt->mrt_children)) 					printf(" %u%c", 					    vifi, 					    VIFM_ISSET(vifi, mrt->mrt_leaves) ? 					    '*' : ' '); 			printf("\n"); 		} 	} 	if (!banner_printed) 		printf("\nMulticast Routing Table is empty\n");  	printf("\n"); 	nflag = saved_nflag;
else|#
directive|else
name|printf
argument_list|(
literal|"this isn't supported yet\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_function
name|void
name|mrt_stats
parameter_list|(
name|mrpaddr
parameter_list|,
name|mstaddr
parameter_list|)
name|u_long
name|mrpaddr
decl_stmt|,
name|mstaddr
decl_stmt|;
block|{
name|u_int
name|mrtproto
decl_stmt|;
name|struct
name|mrtstat
name|mrtstat
decl_stmt|;
if|if
condition|(
name|mrpaddr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"ip_mrtproto: symbol not in namelist\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|kread
argument_list|(
name|mrpaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mrtproto
argument_list|,
sizeof|sizeof
argument_list|(
name|mrtproto
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|mrtproto
condition|)
block|{
case|case
literal|0
case|:
name|printf
argument_list|(
literal|"no multicast routing compiled into this system\n"
argument_list|)
expr_stmt|;
return|return;
case|case
name|IGMP_DVMRP
case|:
break|break;
default|default:
name|printf
argument_list|(
literal|"multicast routing protocol %u, unknown\n"
argument_list|,
name|mrtproto
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|mstaddr
operator|==
literal|0
condition|)
block|{
name|printf
argument_list|(
literal|"mrtstat: symbol not in namelist\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|kread
argument_list|(
name|mstaddr
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|mrtstat
argument_list|,
sizeof|sizeof
argument_list|(
name|mrtstat
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"multicast routing:\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u multicast forwarding cache lookup%s\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_mfc_lookups
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_mfc_lookups
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u multicast forwarding cache miss%s\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_mfc_misses
argument_list|,
name|plurales
argument_list|(
name|mrtstat
operator|.
name|mrts_mfc_misses
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u upcall%s to mrouted\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_upcalls
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_upcalls
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u upcall queue overflow%s\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_upq_ovflw
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_upq_ovflw
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u cache cleanup%s\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_cache_cleanups
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_cache_cleanups
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u datagram%s with no route for origin\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_no_route
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_no_route
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u datagram%s with malformed tunnel options\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_bad_tunnel
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_bad_tunnel
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u datagram%s with no room for tunnel options\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_cant_tunnel
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_cant_tunnel
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u datagram%s arrived on wrong interface\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_wrong_if
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_wrong_if
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u datagram%s selectively dropped\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_drop_sel
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_drop_sel
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u datagram%s dropped due to queue overflow\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_q_overflow
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_q_overflow
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" %10u datagram%s dropped for being too large\n"
argument_list|,
name|mrtstat
operator|.
name|mrts_pkt2large
argument_list|,
name|plural
argument_list|(
name|mrtstat
operator|.
name|mrts_pkt2large
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

