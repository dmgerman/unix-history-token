begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright 1986, Larry Wall  *   * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following condition is met:  * 1. Redistributions of source code must retain the above copyright notice,  * this condition and the following disclaimer.  *   * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY  * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED  * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE  * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR  * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR  * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER  * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *   * patch - a program to apply diffs to original files  *  * -C option added in 1998, original code by Marc Espie, based on FreeBSD  * behaviour  *  * $OpenBSD: pch.c,v 1.43 2014/11/18 17:03:35 tobias Exp $  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdint.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"common.h"
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"pch.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_comment
comment|/* Patch (diff listing) abstract type. */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|p_filesize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of the patch file */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_first
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_newfirst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 1st line number of replacement */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_ptrn_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in pattern */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_repl_lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # lines in replacement text */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_end
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last line in hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_max
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max allowed value of p_end */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_context
init|=
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* # of context lines */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_input_line
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line # from patch file */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
modifier|*
name|p_line
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the text of the hunk */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|short
modifier|*
name|p_len
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of each line */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|p_char
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* +, -, and ! */
end_comment

begin_decl_stmt
specifier|static
name|int
name|hunkmax
init|=
name|INITHUNKMAX
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size of above arrays to begin with */
end_comment

begin_decl_stmt
specifier|static
name|int
name|p_indent
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indent to patch */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|p_base
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where to intuit this time */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line # of p_base */
end_comment

begin_decl_stmt
specifier|static
name|off_t
name|p_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* where intuit found a patch */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_sline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* and the line number for it */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_hunk_beg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line number of current hunk */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_efake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of faked up lines--don't free */
end_comment

begin_decl_stmt
specifier|static
name|LINENUM
name|p_bfake
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* beg of faked up lines */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|pfp
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* patch file pointer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|bestguess
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* guess at correct filename */
end_comment

begin_function_decl
specifier|static
name|void
name|grow_hunkmax
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|intuit_diff_type
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|next_intuit_at
parameter_list|(
name|off_t
parameter_list|,
name|LINENUM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skip_to
parameter_list|(
name|off_t
parameter_list|,
name|LINENUM
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|pgets
parameter_list|(
name|bool
name|_do_indent
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|best_name
parameter_list|(
specifier|const
name|struct
name|file_name
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|posix_name
parameter_list|(
specifier|const
name|struct
name|file_name
modifier|*
parameter_list|,
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|size_t
name|num_components
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|LINENUM
name|strtolinenum
parameter_list|(
name|char
modifier|*
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Prepare to look for the next patch in the patch file.  */
end_comment

begin_function
name|void
name|re_patch
parameter_list|(
name|void
parameter_list|)
block|{
name|p_first
operator|=
literal|0
expr_stmt|;
name|p_newfirst
operator|=
literal|0
expr_stmt|;
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_end
operator|=
operator|(
name|LINENUM
operator|)
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
literal|0
expr_stmt|;
name|p_indent
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Open the patch file at the beginning of time.  */
end_comment

begin_function
name|void
name|open_patch_file
parameter_list|(
specifier|const
name|char
modifier|*
name|filename
parameter_list|)
block|{
name|struct
name|stat
name|filestat
decl_stmt|;
name|int
name|nr
decl_stmt|,
name|nw
decl_stmt|;
if|if
condition|(
name|filename
operator|==
name|NULL
operator|||
operator|*
name|filename
operator|==
literal|'\0'
operator|||
name|strEQ
argument_list|(
name|filename
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|pfp
operator|=
name|fopen
argument_list|(
name|TMPPATNAME
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
name|pfatal
argument_list|(
literal|"can't create %s"
argument_list|,
name|TMPPATNAME
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|nr
operator|=
name|fread
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|buf_size
argument_list|,
name|stdin
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|nw
operator|=
name|fwrite
argument_list|(
name|buf
argument_list|,
literal|1
argument_list|,
name|nr
argument_list|,
name|pfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|nr
operator|!=
name|nw
condition|)
name|pfatal
argument_list|(
literal|"write error to %s"
argument_list|,
name|TMPPATNAME
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|pfp
argument_list|)
operator|||
name|fclose
argument_list|(
name|pfp
argument_list|)
condition|)
name|pfatal
argument_list|(
literal|"can't write %s"
argument_list|,
name|TMPPATNAME
argument_list|)
expr_stmt|;
name|filename
operator|=
name|TMPPATNAME
expr_stmt|;
block|}
name|pfp
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|pfp
operator|==
name|NULL
condition|)
name|pfatal
argument_list|(
literal|"patch file %s not found"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|pfp
argument_list|)
argument_list|,
operator|&
name|filestat
argument_list|)
condition|)
name|pfatal
argument_list|(
literal|"can't stat %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|p_filesize
operator|=
name|filestat
operator|.
name|st_size
expr_stmt|;
name|next_intuit_at
argument_list|(
literal|0
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
comment|/* start at the beginning */
name|set_hunkmax
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Make sure our dynamically realloced tables are malloced to begin with.  */
end_comment

begin_function
name|void
name|set_hunkmax
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|p_line
operator|==
name|NULL
condition|)
name|p_line
operator|=
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_len
operator|==
name|NULL
condition|)
name|p_len
operator|=
name|malloc
argument_list|(
name|hunkmax
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_char
operator|==
name|NULL
condition|)
name|p_char
operator|=
name|malloc
argument_list|(
name|hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Enlarge the arrays containing the current hunk of patch.  */
end_comment

begin_function
specifier|static
name|void
name|grow_hunkmax
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|new_hunkmax
init|=
name|hunkmax
operator|*
literal|2
decl_stmt|;
if|if
condition|(
name|p_line
operator|==
name|NULL
operator|||
name|p_len
operator|==
name|NULL
operator|||
name|p_char
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"Internal memory allocation error\n"
argument_list|)
expr_stmt|;
name|p_line
operator|=
name|reallocf
argument_list|(
name|p_line
argument_list|,
name|new_hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|p_len
operator|=
name|reallocf
argument_list|(
name|p_len
argument_list|,
name|new_hunkmax
operator|*
expr|sizeof
operator|(
name|unsigned
name|short
operator|)
argument_list|)
expr_stmt|;
name|p_char
operator|=
name|reallocf
argument_list|(
name|p_char
argument_list|,
name|new_hunkmax
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_line
operator|!=
name|NULL
operator|&&
name|p_len
operator|!=
name|NULL
operator|&&
name|p_char
operator|!=
name|NULL
condition|)
block|{
name|hunkmax
operator|=
name|new_hunkmax
expr_stmt|;
return|return;
block|}
if|if
condition|(
operator|!
name|using_plan_a
condition|)
name|fatal
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
name|out_of_mem
operator|=
name|true
expr_stmt|;
comment|/* whatever is null will be allocated again */
comment|/* from within plan_a(), of all places */
block|}
end_function

begin_comment
comment|/* True if the remainder of the patch file contains a diff of some sort. */
end_comment

begin_function
name|bool
name|there_is_another_patch
parameter_list|(
name|void
parameter_list|)
block|{
name|bool
name|exists
init|=
name|false
decl_stmt|;
if|if
condition|(
name|p_base
operator|!=
literal|0
operator|&&
name|p_base
operator|>=
name|p_filesize
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say
argument_list|(
literal|"done\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|say
argument_list|(
literal|"Hmm..."
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|intuit_diff_type
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|diff_type
condition|)
block|{
if|if
condition|(
name|p_base
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say
argument_list|(
literal|"  Ignoring the trailing garbage.\ndone\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|say
argument_list|(
literal|"  I can't seem to find a patch in there anywhere.\n"
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|verbose
condition|)
name|say
argument_list|(
literal|"  %sooks like %s to me...\n"
argument_list|,
operator|(
name|p_base
operator|==
literal|0
condition|?
literal|"L"
else|:
literal|"The next patch l"
operator|)
argument_list|,
name|diff_type
operator|==
name|UNI_DIFF
condition|?
literal|"a unified diff"
else|:
name|diff_type
operator|==
name|CONTEXT_DIFF
condition|?
literal|"a context diff"
else|:
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
condition|?
literal|"a new-style context diff"
else|:
name|diff_type
operator|==
name|NORMAL_DIFF
condition|?
literal|"a normal diff"
else|:
literal|"an ed script"
argument_list|)
expr_stmt|;
if|if
condition|(
name|p_indent
operator|&&
name|verbose
condition|)
name|say
argument_list|(
literal|"(Patch is indented %d space%s.)\n"
argument_list|,
name|p_indent
argument_list|,
name|p_indent
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
argument_list|)
expr_stmt|;
name|skip_to
argument_list|(
name|p_start
argument_list|,
name|p_sline
argument_list|)
expr_stmt|;
while|while
condition|(
name|filearg
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|force
operator|||
name|batch
condition|)
block|{
name|say
argument_list|(
literal|"No file to patch.  Skipping...\n"
argument_list|)
expr_stmt|;
name|filearg
index|[
literal|0
index|]
operator|=
name|xstrdup
argument_list|(
name|bestguess
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
name|ask
argument_list|(
literal|"File to patch: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'\n'
condition|)
block|{
name|free
argument_list|(
name|bestguess
argument_list|)
expr_stmt|;
name|bestguess
operator|=
name|xstrdup
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|filearg
index|[
literal|0
index|]
operator|=
name|fetchname
argument_list|(
name|buf
argument_list|,
operator|&
name|exists
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|exists
condition|)
block|{
name|int
name|def_skip
init|=
operator|*
name|bestguess
operator|==
literal|'\0'
decl_stmt|;
name|ask
argument_list|(
literal|"No file found--skip this patch? [%c] "
argument_list|,
name|def_skip
condition|?
literal|'y'
else|:
literal|'n'
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|==
literal|'n'
operator|||
operator|(
operator|!
name|def_skip
operator|&&
operator|*
name|buf
operator|!=
literal|'y'
operator|)
condition|)
continue|continue;
if|if
condition|(
name|verbose
condition|)
name|say
argument_list|(
literal|"Skipping patch...\n"
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|filearg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|filearg
index|[
literal|0
index|]
operator|=
name|fetchname
argument_list|(
name|bestguess
argument_list|,
operator|&
name|exists
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skip_rest_of_patch
operator|=
name|true
expr_stmt|;
return|return
name|true
return|;
block|}
block|}
return|return
name|true
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|p4_fetchname
parameter_list|(
name|struct
name|file_name
modifier|*
name|name
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|,
modifier|*
name|h
decl_stmt|;
comment|/* Skip leading whitespace. */
while|while
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|str
argument_list|)
condition|)
name|str
operator|++
expr_stmt|;
comment|/* Remove the file revision number. */
for|for
control|(
name|t
operator|=
name|str
operator|,
name|h
operator|=
name|NULL
init|;
operator|*
name|t
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
if|if
condition|(
operator|*
name|t
operator|==
literal|'#'
condition|)
name|h
operator|=
name|t
expr_stmt|;
if|if
condition|(
name|h
operator|!=
name|NULL
condition|)
operator|*
name|h
operator|=
literal|'\0'
expr_stmt|;
name|name
operator|->
name|path
operator|=
name|fetchname
argument_list|(
name|str
argument_list|,
operator|&
name|name
operator|->
name|exists
argument_list|,
name|strippath
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Determine what kind of diff is in the remaining part of the patch file. */
end_comment

begin_function
specifier|static
name|int
name|intuit_diff_type
parameter_list|(
name|void
parameter_list|)
block|{
name|off_t
name|this_line
init|=
literal|0
decl_stmt|,
name|previous_line
decl_stmt|;
name|off_t
name|first_command_line
init|=
operator|-
literal|1
decl_stmt|;
name|LINENUM
name|fcl_line
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|last_line_was_command
init|=
name|false
decl_stmt|,
name|this_is_a_command
init|=
name|false
decl_stmt|;
name|bool
name|stars_last_line
init|=
name|false
decl_stmt|,
name|stars_this_line
init|=
name|false
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|,
modifier|*
name|t
decl_stmt|;
name|int
name|indent
decl_stmt|,
name|retval
decl_stmt|;
name|struct
name|file_name
name|names
index|[
name|MAX_FILE
index|]
decl_stmt|;
name|memset
argument_list|(
name|names
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|names
argument_list|)
argument_list|)
expr_stmt|;
name|ok_to_create_file
operator|=
name|false
expr_stmt|;
name|fseeko
argument_list|(
name|pfp
argument_list|,
name|p_base
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|p_bline
operator|-
literal|1
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|previous_line
operator|=
name|this_line
expr_stmt|;
name|last_line_was_command
operator|=
name|this_is_a_command
expr_stmt|;
name|stars_last_line
operator|=
name|stars_this_line
expr_stmt|;
name|this_line
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|indent
operator|=
literal|0
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|pgets
argument_list|(
name|false
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|first_command_line
operator|>=
literal|0
condition|)
block|{
comment|/* nothing but deletes!? */
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
else|else
block|{
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
name|retval
operator|=
literal|0
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
operator|||
operator|*
name|s
operator|==
literal|'X'
condition|;
name|s
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|indent
operator|+=
literal|8
operator|-
operator|(
name|indent
operator|%
literal|8
operator|)
expr_stmt|;
else|else
name|indent
operator|++
expr_stmt|;
block|}
for|for
control|(
name|t
operator|=
name|s
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|this_is_a_command
operator|=
operator|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'a'
operator|)
operator|)
expr_stmt|;
if|if
condition|(
name|first_command_line
operator|<
literal|0
operator|&&
name|this_is_a_command
condition|)
block|{
name|first_command_line
operator|=
name|this_line
expr_stmt|;
name|fcl_line
operator|=
name|p_input_line
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
comment|/* assume this for now */
block|}
if|if
condition|(
operator|!
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
name|names
index|[
name|OLD_FILE
index|]
operator|.
name|path
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
operator|&
name|names
index|[
name|OLD_FILE
index|]
operator|.
name|exists
argument_list|,
name|strippath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"--- "
argument_list|,
literal|4
argument_list|)
condition|)
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|path
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
operator|&
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|exists
argument_list|,
name|strippath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"+++ "
argument_list|,
literal|4
argument_list|)
condition|)
comment|/* pretend it is the old name */
name|names
index|[
name|OLD_FILE
index|]
operator|.
name|path
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|4
argument_list|,
operator|&
name|names
index|[
name|OLD_FILE
index|]
operator|.
name|exists
argument_list|,
name|strippath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Index:"
argument_list|,
literal|6
argument_list|)
condition|)
name|names
index|[
name|INDEX_FILE
index|]
operator|.
name|path
operator|=
name|fetchname
argument_list|(
name|s
operator|+
literal|6
argument_list|,
operator|&
name|names
index|[
name|INDEX_FILE
index|]
operator|.
name|exists
argument_list|,
name|strippath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"Prereq:"
argument_list|,
literal|7
argument_list|)
condition|)
block|{
for|for
control|(
name|t
operator|=
name|s
operator|+
literal|7
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
name|revision
operator|=
name|xstrdup
argument_list|(
name|t
argument_list|)
expr_stmt|;
for|for
control|(
name|t
operator|=
name|revision
init|;
operator|*
name|t
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
condition|;
name|t
operator|++
control|)
empty_stmt|;
operator|*
name|t
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|revision
operator|==
literal|'\0'
condition|)
block|{
name|free
argument_list|(
name|revision
argument_list|)
expr_stmt|;
name|revision
operator|=
name|NULL
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"==== "
argument_list|,
literal|5
argument_list|)
condition|)
block|{
comment|/* Perforce-style diffs. */
if|if
condition|(
operator|(
name|t
operator|=
name|strstr
argument_list|(
name|s
operator|+
literal|5
argument_list|,
literal|" - "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p4_fetchname
argument_list|(
operator|&
name|names
index|[
name|NEW_FILE
index|]
argument_list|,
name|t
operator|+
literal|3
argument_list|)
expr_stmt|;
name|p4_fetchname
argument_list|(
operator|&
name|names
index|[
name|OLD_FILE
index|]
argument_list|,
name|s
operator|+
literal|5
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|ED_DIFF
operator|)
operator|&&
name|first_command_line
operator|>=
literal|0
operator|&&
name|strEQ
argument_list|(
name|s
argument_list|,
literal|".\n"
argument_list|)
condition|)
block|{
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|first_command_line
expr_stmt|;
name|p_sline
operator|=
name|fcl_line
expr_stmt|;
name|retval
operator|=
name|ED_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|UNI_DIFF
operator|)
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|strnEQ
argument_list|(
name|s
operator|+
literal|4
argument_list|,
literal|"0,0"
argument_list|,
literal|3
argument_list|)
condition|)
name|ok_to_create_file
operator|=
name|true
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|this_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
expr_stmt|;
name|retval
operator|=
name|UNI_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
name|stars_this_line
operator|=
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|)
operator|&&
name|stars_last_line
operator|&&
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"*** "
argument_list|,
literal|4
argument_list|)
condition|)
block|{
if|if
condition|(
name|strtolinenum
argument_list|(
name|s
operator|+
literal|4
argument_list|,
operator|&
name|s
argument_list|)
operator|==
literal|0
condition|)
name|ok_to_create_file
operator|=
name|true
expr_stmt|;
comment|/* 			 * If this is a new context diff the character just 			 * at the end of the line is a '*'. 			 */
while|while
condition|(
operator|*
name|s
operator|&&
operator|*
name|s
operator|!=
literal|'\n'
condition|)
name|s
operator|++
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|retval
operator|=
operator|(
operator|*
operator|(
name|s
operator|-
literal|1
operator|)
operator|==
literal|'*'
condition|?
name|NEW_CONTEXT_DIFF
else|:
name|CONTEXT_DIFF
operator|)
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
if|if
condition|(
operator|(
operator|!
name|diff_type
operator|||
name|diff_type
operator|==
name|NORMAL_DIFF
operator|)
operator|&&
name|last_line_was_command
operator|&&
operator|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"< "
argument_list|,
literal|2
argument_list|)
operator|||
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"> "
argument_list|,
literal|2
argument_list|)
operator|)
condition|)
block|{
name|p_start
operator|=
name|previous_line
expr_stmt|;
name|p_sline
operator|=
name|p_input_line
operator|-
literal|1
expr_stmt|;
name|p_indent
operator|=
name|indent
expr_stmt|;
name|retval
operator|=
name|NORMAL_DIFF
expr_stmt|;
goto|goto
name|scan_exit
goto|;
block|}
block|}
name|scan_exit
label|:
if|if
condition|(
name|retval
operator|==
name|UNI_DIFF
condition|)
block|{
comment|/* unswap old and new */
name|struct
name|file_name
name|tmp
init|=
name|names
index|[
name|OLD_FILE
index|]
decl_stmt|;
name|names
index|[
name|OLD_FILE
index|]
operator|=
name|names
index|[
name|NEW_FILE
index|]
expr_stmt|;
name|names
index|[
name|NEW_FILE
index|]
operator|=
name|tmp
expr_stmt|;
block|}
if|if
condition|(
name|filearg
index|[
literal|0
index|]
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|posix
condition|)
name|filearg
index|[
literal|0
index|]
operator|=
name|posix_name
argument_list|(
name|names
argument_list|,
name|ok_to_create_file
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Ignore the Index: name for context diffs, like GNU */
if|if
condition|(
name|names
index|[
name|OLD_FILE
index|]
operator|.
name|path
operator|!=
name|NULL
operator|||
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|path
operator|!=
name|NULL
condition|)
block|{
name|free
argument_list|(
name|names
index|[
name|INDEX_FILE
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
name|names
index|[
name|INDEX_FILE
index|]
operator|.
name|path
operator|=
name|NULL
expr_stmt|;
block|}
name|filearg
index|[
literal|0
index|]
operator|=
name|best_name
argument_list|(
name|names
argument_list|,
name|ok_to_create_file
argument_list|)
expr_stmt|;
block|}
block|}
name|free
argument_list|(
name|bestguess
argument_list|)
expr_stmt|;
name|bestguess
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|filearg
index|[
literal|0
index|]
operator|!=
name|NULL
condition|)
name|bestguess
operator|=
name|xstrdup
argument_list|(
name|filearg
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|ok_to_create_file
condition|)
block|{
comment|/* 		 * We don't want to create a new file but we need a 		 * filename to set bestguess.  Avoid setting filearg[0] 		 * so the file is not created automatically. 		 */
if|if
condition|(
name|posix
condition|)
name|bestguess
operator|=
name|posix_name
argument_list|(
name|names
argument_list|,
name|true
argument_list|)
expr_stmt|;
else|else
name|bestguess
operator|=
name|best_name
argument_list|(
name|names
argument_list|,
name|true
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|names
index|[
name|OLD_FILE
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|names
index|[
name|INDEX_FILE
index|]
operator|.
name|path
argument_list|)
expr_stmt|;
return|return
name|retval
return|;
block|}
end_function

begin_comment
comment|/*  * Remember where this patch ends so we know where to start up again.  */
end_comment

begin_function
specifier|static
name|void
name|next_intuit_at
parameter_list|(
name|off_t
name|file_pos
parameter_list|,
name|LINENUM
name|file_line
parameter_list|)
block|{
name|p_base
operator|=
name|file_pos
expr_stmt|;
name|p_bline
operator|=
name|file_line
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Basically a verbose fseeko() to the actual diff listing.  */
end_comment

begin_function
specifier|static
name|void
name|skip_to
parameter_list|(
name|off_t
name|file_pos
parameter_list|,
name|LINENUM
name|file_line
parameter_list|)
block|{
name|size_t
name|len
decl_stmt|;
if|if
condition|(
name|p_base
operator|>
name|file_pos
condition|)
name|fatal
argument_list|(
literal|"Internal error: seek %lld>%lld\n"
argument_list|,
operator|(
name|long
name|long
operator|)
name|p_base
argument_list|,
operator|(
name|long
name|long
operator|)
name|file_pos
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
name|p_base
operator|<
name|file_pos
condition|)
block|{
name|fseeko
argument_list|(
name|pfp
argument_list|,
name|p_base
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|"The text leading up to this was:\n--------------------------\n"
argument_list|)
expr_stmt|;
while|while
condition|(
name|ftello
argument_list|(
name|pfp
argument_list|)
operator|<
name|file_pos
condition|)
block|{
name|len
operator|=
name|pgets
argument_list|(
name|false
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"Unexpected end of file\n"
argument_list|)
expr_stmt|;
name|say
argument_list|(
literal|"|%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|say
argument_list|(
literal|"--------------------------\n"
argument_list|)
expr_stmt|;
block|}
else|else
name|fseeko
argument_list|(
name|pfp
argument_list|,
name|file_pos
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
name|p_input_line
operator|=
name|file_line
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Make this a function for better debugging.  */
end_comment

begin_function
specifier|static
name|void
name|malformed
parameter_list|(
name|void
parameter_list|)
block|{
name|fatal
argument_list|(
literal|"malformed patch at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* about as informative as "Syntax error" in C */
block|}
end_function

begin_comment
comment|/*  * True if the line has been discarded (i.e. it is a line saying  *  "\ No newline at end of file".)  */
end_comment

begin_function
specifier|static
name|bool
name|remove_special_line
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|c
operator|=
name|fgetc
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\\'
condition|)
block|{
do|do
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|c
operator|!=
name|EOF
operator|&&
name|c
operator|!=
literal|'\n'
condition|)
do|;
return|return
name|true
return|;
block|}
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
name|fseeko
argument_list|(
name|pfp
argument_list|,
operator|-
literal|1
argument_list|,
name|SEEK_CUR
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
end_function

begin_comment
comment|/*  * True if there is more of the current diff listing to process.  */
end_comment

begin_function
name|bool
name|another_hunk
parameter_list|(
name|void
parameter_list|)
block|{
name|off_t
name|line_beginning
decl_stmt|;
comment|/* file pos of the current line */
name|LINENUM
name|repl_beginning
decl_stmt|;
comment|/* index of --- line */
name|LINENUM
name|fillcnt
decl_stmt|;
comment|/* #lines of missing ptrn or repl */
name|LINENUM
name|fillsrc
decl_stmt|;
comment|/* index of first line to copy */
name|LINENUM
name|filldst
decl_stmt|;
comment|/* index of first missing line */
name|bool
name|ptrn_spaces_eaten
decl_stmt|;
comment|/* ptrn was slightly malformed */
name|bool
name|repl_could_be_missing
decl_stmt|;
comment|/* no + or ! lines in this hunk */
name|bool
name|repl_missing
decl_stmt|;
comment|/* we are now backtracking */
name|off_t
name|repl_backtrack_position
decl_stmt|;
comment|/* file pos of first repl line */
name|LINENUM
name|repl_patch_line
decl_stmt|;
comment|/* input line number for same */
name|LINENUM
name|ptrn_copiable
decl_stmt|;
comment|/* # of copiable lines in ptrn */
name|char
modifier|*
name|s
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|context
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|p_end
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
name|p_efake
condition|)
name|p_end
operator|=
name|p_bfake
expr_stmt|;
comment|/* don't free twice */
else|else
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|--
expr_stmt|;
block|}
name|p_efake
operator|=
operator|-
literal|1
expr_stmt|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
comment|/* gets reduced when --- found */
if|if
condition|(
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|||
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
condition|)
block|{
name|line_beginning
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|repl_beginning
operator|=
literal|0
expr_stmt|;
name|fillcnt
operator|=
literal|0
expr_stmt|;
name|fillsrc
operator|=
literal|0
expr_stmt|;
name|filldst
operator|=
literal|0
expr_stmt|;
name|ptrn_spaces_eaten
operator|=
name|false
expr_stmt|;
name|repl_could_be_missing
operator|=
name|true
expr_stmt|;
name|repl_missing
operator|=
name|false
expr_stmt|;
name|repl_backtrack_position
operator|=
literal|0
expr_stmt|;
name|repl_patch_line
operator|=
literal|0
expr_stmt|;
name|ptrn_copiable
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|strnNE
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_context
operator|=
literal|100
expr_stmt|;
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_end
operator|<
name|p_max
condition|)
block|{
name|line_beginning
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_max
operator|-
name|p_end
operator|<
literal|4
condition|)
block|{
comment|/* assume blank lines got chopped */
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|"  \n"
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal
argument_list|(
literal|"unexpected end of file in patch\n"
argument_list|)
expr_stmt|;
block|}
block|}
name|p_end
operator|++
expr_stmt|;
if|if
condition|(
name|p_end
operator|>=
name|hunkmax
condition|)
name|fatal
argument_list|(
literal|"Internal error: hunk larger than hunk "
literal|"buffer size"
argument_list|)
expr_stmt|;
name|p_char
index|[
name|p_end
index|]
operator|=
operator|*
name|buf
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
name|NULL
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf
condition|)
block|{
case|case
literal|'*'
case|:
if|if
condition|(
name|strnEQ
argument_list|(
name|buf
argument_list|,
literal|"********"
argument_list|,
literal|8
argument_list|)
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
else|else
name|fatal
argument_list|(
literal|"unexpected end of hunk "
literal|"at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|p_end
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal
argument_list|(
literal|"unexpected *** at line %ld: %s"
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
name|context
operator|=
literal|0
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|false
return|;
block|}
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
name|strnEQ
argument_list|(
name|s
argument_list|,
literal|"0,0"
argument_list|,
literal|3
argument_list|)
condition|)
name|memmove
argument_list|(
name|s
argument_list|,
name|s
operator|+
literal|2
argument_list|,
name|strlen
argument_list|(
name|s
operator|+
literal|2
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|p_first
operator|=
name|strtolinenum
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_ptrn_lines
operator|=
name|strtolinenum
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p_ptrn_lines
operator|<
literal|0
condition|)
name|malformed
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_first
condition|)
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
name|p_first
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p_first
operator|>=
name|LINENUM_MAX
operator|-
name|p_ptrn_lines
operator|||
name|p_ptrn_lines
operator|>=
name|LINENUM_MAX
operator|-
literal|6
condition|)
name|malformed
argument_list|()
expr_stmt|;
comment|/* we need this much at least */
name|p_max
operator|=
name|p_ptrn_lines
operator|+
literal|6
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
name|p_max
operator|=
name|hunkmax
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|repl_beginning
operator|||
operator|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
operator|+
operator|(
name|p_char
index|[
name|p_end
operator|-
literal|1
index|]
operator|==
literal|'\n'
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|p_end
operator|==
literal|1
condition|)
block|{
comment|/* 							 * `old' lines were omitted; 							 * set up to fill them in 							 * from 'new' context lines. 							 */
name|p_end
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|fillsrc
operator|=
name|p_end
operator|+
literal|1
expr_stmt|;
name|filldst
operator|=
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_ptrn_lines
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|repl_beginning
condition|)
block|{
if|if
condition|(
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|fatal
argument_list|(
literal|"duplicate \"---\" at line %ld--check line numbers at line %ld\n"
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
operator|+
name|repl_beginning
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"%s \"---\" at line %ld--check line numbers at line %ld\n"
argument_list|,
operator|(
name|p_end
operator|<=
name|p_ptrn_lines
condition|?
literal|"Premature"
else|:
literal|"Overdue"
operator|)
argument_list|,
name|p_input_line
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|repl_beginning
operator|=
name|p_end
expr_stmt|;
name|repl_backtrack_position
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|repl_patch_line
operator|=
name|p_input_line
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_char
index|[
name|p_end
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|buf
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
name|strtolinenum
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
for|for
control|(
init|;
operator|*
name|s
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
argument_list|)
condition|;
name|s
operator|++
control|)
empty_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_repl_lines
operator|=
name|strtolinenum
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|)
operator|-
name|p_newfirst
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p_repl_lines
operator|<
literal|0
condition|)
name|malformed
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|p_newfirst
condition|)
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
else|else
block|{
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_newfirst
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|p_newfirst
operator|>=
name|LINENUM_MAX
operator|-
name|p_repl_lines
operator|||
name|p_repl_lines
operator|>=
name|LINENUM_MAX
operator|-
name|p_end
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_max
operator|=
name|p_repl_lines
operator|+
name|p_end
expr_stmt|;
if|if
condition|(
name|p_max
operator|>
name|MAXHUNKSIZE
condition|)
name|fatal
argument_list|(
literal|"hunk too large (%ld lines) at line %ld: %s"
argument_list|,
name|p_max
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_repl_lines
operator|!=
name|ptrn_copiable
operator|&&
operator|(
name|p_context
operator|!=
literal|0
operator|||
name|p_repl_lines
operator|!=
literal|1
operator|)
condition|)
name|repl_could_be_missing
operator|=
name|false
expr_stmt|;
break|break;
block|}
goto|goto
name|change_line
goto|;
case|case
literal|'+'
case|:
case|case
literal|'!'
case|:
name|repl_could_be_missing
operator|=
name|false
expr_stmt|;
name|change_line
label|:
if|if
condition|(
name|buf
index|[
literal|1
index|]
operator|==
literal|'\n'
operator|&&
name|canonicalize
condition|)
name|strlcpy
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|" \n"
argument_list|,
name|buf_size
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'>'
operator|&&
name|buf
index|[
literal|1
index|]
operator|!=
literal|'<'
operator|&&
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
if|if
condition|(
name|context
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|context
operator|<
name|p_context
condition|)
name|p_context
operator|=
name|context
expr_stmt|;
name|context
operator|=
operator|-
literal|1000
expr_stmt|;
block|}
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|p_end
operator|==
name|p_ptrn_lines
condition|)
block|{
if|if
condition|(
name|remove_special_line
argument_list|()
condition|)
block|{
name|int
name|l
decl_stmt|;
name|l
operator|=
name|strlen
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
operator|-
literal|1
expr_stmt|;
operator|(
name|p_line
index|[
name|p_end
index|]
operator|)
index|[
name|l
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
comment|/* assume the 2 spaces got eaten */
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
operator|&&
operator|(
operator|!
name|ptrn_spaces_eaten
operator|||
name|diff_type
operator|==
name|NEW_CONTEXT_DIFF
operator|)
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|p_end
operator|!=
name|p_ptrn_lines
operator|+
literal|1
condition|)
block|{
name|ptrn_spaces_eaten
operator||=
operator|(
name|repl_beginning
operator|!=
literal|0
operator|)
expr_stmt|;
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|p_char
index|[
name|p_end
index|]
operator|=
literal|' '
expr_stmt|;
block|}
break|break;
case|case
literal|' '
case|:
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|buf
index|[
literal|1
index|]
argument_list|)
operator|&&
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|context
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|repl_beginning
condition|)
name|ptrn_copiable
operator|++
expr_stmt|;
name|p_line
index|[
name|p_end
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|--
expr_stmt|;
return|return
name|false
return|;
block|}
break|break;
default|default:
if|if
condition|(
name|repl_beginning
operator|&&
name|repl_could_be_missing
condition|)
block|{
name|repl_missing
operator|=
name|true
expr_stmt|;
goto|goto
name|hunk_done
goto|;
block|}
name|malformed
argument_list|()
expr_stmt|;
block|}
comment|/* set up p_len for strncmp() so we don't have to */
comment|/* assume null termination */
if|if
condition|(
name|p_line
index|[
name|p_end
index|]
condition|)
name|p_len
index|[
name|p_end
index|]
operator|=
name|strlen
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
else|else
name|p_len
index|[
name|p_end
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|hunk_done
label|:
if|if
condition|(
name|p_end
operator|>=
literal|0
operator|&&
operator|!
name|repl_beginning
condition|)
name|fatal
argument_list|(
literal|"no --- found in patch at line %ld\n"
argument_list|,
name|pch_hunk_beg
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|repl_missing
condition|)
block|{
comment|/* reset state back to just after --- */
name|p_input_line
operator|=
name|repl_patch_line
expr_stmt|;
for|for
control|(
name|p_end
operator|--
init|;
name|p_end
operator|>
name|repl_beginning
condition|;
name|p_end
operator|--
control|)
name|free
argument_list|(
name|p_line
index|[
name|p_end
index|]
argument_list|)
expr_stmt|;
name|fseeko
argument_list|(
name|pfp
argument_list|,
name|repl_backtrack_position
argument_list|,
name|SEEK_SET
argument_list|)
expr_stmt|;
comment|/* redundant 'new' context lines were omitted - set */
comment|/* up to fill them in from the old file context */
if|if
condition|(
operator|!
name|p_context
operator|&&
name|p_repl_lines
operator|==
literal|1
condition|)
block|{
name|p_repl_lines
operator|=
literal|0
expr_stmt|;
name|p_max
operator|--
expr_stmt|;
block|}
name|fillsrc
operator|=
literal|1
expr_stmt|;
name|filldst
operator|=
name|repl_beginning
operator|+
literal|1
expr_stmt|;
name|fillcnt
operator|=
name|p_repl_lines
expr_stmt|;
name|p_end
operator|=
name|p_max
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|p_context
operator|&&
name|fillcnt
operator|==
literal|1
condition|)
block|{
comment|/* the first hunk was a null hunk with no context */
comment|/* and we were expecting one line -- fix it up. */
while|while
condition|(
name|filldst
operator|<
name|p_end
condition|)
block|{
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_char
index|[
name|filldst
index|]
operator|=
name|p_char
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|filldst
operator|+
literal|1
index|]
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
if|#
directive|if
literal|0
block|repl_beginning--;
comment|/* this doesn't need to be fixed */
endif|#
directive|endif
name|p_end
operator|--
expr_stmt|;
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|fillcnt
operator|=
literal|0
expr_stmt|;
name|p_ptrn_lines
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|diff_type
operator|==
name|CONTEXT_DIFF
operator|&&
operator|(
name|fillcnt
operator|||
operator|(
name|p_first
operator|>
literal|1
operator|&&
name|ptrn_copiable
operator|>
literal|2
operator|*
name|p_context
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|say
argument_list|(
literal|"%s\n%s\n%s\n"
argument_list|,
literal|"(Fascinating--this is really a new-style context diff but without"
argument_list|,
literal|"the telltale extra asterisks on the *** line that usually indicate"
argument_list|,
literal|"the new style...)"
argument_list|)
expr_stmt|;
name|diff_type
operator|=
name|NEW_CONTEXT_DIFF
expr_stmt|;
block|}
comment|/* if there were omitted context lines, fill them in now */
if|if
condition|(
name|fillcnt
condition|)
block|{
name|p_bfake
operator|=
name|filldst
expr_stmt|;
comment|/* remember where not to free() */
name|p_efake
operator|=
name|filldst
operator|+
name|fillcnt
operator|-
literal|1
expr_stmt|;
while|while
condition|(
name|fillcnt
operator|--
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|p_char
index|[
name|fillsrc
index|]
operator|!=
literal|' '
condition|)
name|fillsrc
operator|++
expr_stmt|;
if|if
condition|(
name|fillsrc
operator|>
name|p_end
condition|)
name|fatal
argument_list|(
literal|"replacement text or line numbers mangled in hunk at line %ld\n"
argument_list|,
name|p_hunk_beg
argument_list|)
expr_stmt|;
name|p_line
index|[
name|filldst
index|]
operator|=
name|p_line
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_char
index|[
name|filldst
index|]
operator|=
name|p_char
index|[
name|fillsrc
index|]
expr_stmt|;
name|p_len
index|[
name|filldst
index|]
operator|=
name|p_len
index|[
name|fillsrc
index|]
expr_stmt|;
name|fillsrc
operator|++
expr_stmt|;
name|filldst
operator|++
expr_stmt|;
block|}
while|while
condition|(
name|fillsrc
operator|<=
name|p_end
operator|&&
name|fillsrc
operator|!=
name|repl_beginning
operator|&&
name|p_char
index|[
name|fillsrc
index|]
operator|!=
literal|' '
condition|)
name|fillsrc
operator|++
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|64
condition|)
name|printf
argument_list|(
literal|"fillsrc %ld, filldst %ld, rb %ld, e+1 %ld\n"
argument_list|,
name|fillsrc
argument_list|,
name|filldst
argument_list|,
name|repl_beginning
argument_list|,
name|p_end
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|fillsrc
operator|!=
name|p_end
operator|+
literal|1
operator|&&
name|fillsrc
operator|!=
name|repl_beginning
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
name|filldst
operator|!=
name|p_end
operator|+
literal|1
operator|&&
name|filldst
operator|!=
name|repl_beginning
condition|)
name|malformed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|p_line
index|[
name|p_end
index|]
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|remove_special_line
argument_list|()
condition|)
block|{
name|p_len
index|[
name|p_end
index|]
operator|-=
literal|1
expr_stmt|;
operator|(
name|p_line
index|[
name|p_end
index|]
operator|)
index|[
name|p_len
index|[
name|p_end
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|diff_type
operator|==
name|UNI_DIFF
condition|)
block|{
name|LINENUM
name|fillold
decl_stmt|;
comment|/* index of old lines */
name|LINENUM
name|fillnew
decl_stmt|;
comment|/* index of new lines */
name|char
name|ch
decl_stmt|;
name|line_beginning
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
comment|/* file pos of the current line */
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
name|strnNE
argument_list|(
name|buf
argument_list|,
literal|"@@ -"
argument_list|,
literal|4
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|s
operator|=
name|buf
operator|+
literal|4
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_first
operator|=
name|strtolinenum
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
name|strtolinenum
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'+'
operator|||
operator|!
operator|*
operator|++
name|s
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_newfirst
operator|=
name|strtolinenum
argument_list|(
name|s
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_repl_lines
operator|=
name|strtolinenum
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
block|}
else|else
name|p_repl_lines
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|' '
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|!=
literal|'@'
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_first
operator|>=
name|LINENUM_MAX
operator|-
name|p_ptrn_lines
operator|||
name|p_newfirst
operator|>
name|LINENUM_MAX
operator|-
name|p_repl_lines
operator|||
name|p_ptrn_lines
operator|>=
name|LINENUM_MAX
operator|-
name|p_repl_lines
operator|-
literal|1
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|p_ptrn_lines
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|p_max
operator|=
name|p_ptrn_lines
operator|+
name|p_repl_lines
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|p_max
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
name|fillold
operator|=
literal|1
expr_stmt|;
name|fillnew
operator|=
name|fillold
operator|+
name|p_ptrn_lines
expr_stmt|;
name|p_end
operator|=
name|fillnew
operator|+
name|p_repl_lines
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
literal|"*** %ld,%ld ****\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
literal|"--- %ld,%ld ----\n"
argument_list|,
name|p_newfirst
argument_list|,
name|p_newfirst
operator|+
name|p_repl_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_line
index|[
name|fillnew
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
literal|0
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_char
index|[
name|fillnew
operator|++
index|]
operator|=
literal|'='
expr_stmt|;
name|p_context
operator|=
literal|100
expr_stmt|;
name|context
operator|=
literal|0
expr_stmt|;
name|p_hunk_beg
operator|=
name|p_input_line
operator|+
literal|1
expr_stmt|;
while|while
condition|(
name|fillold
operator|<=
name|p_ptrn_lines
operator|||
name|fillnew
operator|<=
name|p_end
condition|)
block|{
name|line_beginning
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|p_max
operator|-
name|fillnew
operator|<
literal|3
condition|)
block|{
comment|/* assume blank lines got chopped */
name|strlcpy
argument_list|(
name|buf
argument_list|,
literal|" \n"
argument_list|,
name|buf_size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fatal
argument_list|(
literal|"unexpected end of file in patch\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|buf
operator|==
literal|'\t'
operator|||
operator|*
name|buf
operator|==
literal|'\n'
condition|)
block|{
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* assume the space got eaten */
name|s
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|ch
operator|=
operator|*
name|buf
expr_stmt|;
name|s
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|out_of_mem
condition|)
block|{
while|while
condition|(
operator|--
name|fillnew
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|fillnew
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillold
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'-'
case|:
if|if
condition|(
name|fillold
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillnew
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|p_char
index|[
name|fillold
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillold
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillold
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fillold
operator|>
name|p_ptrn_lines
condition|)
block|{
if|if
condition|(
name|remove_special_line
argument_list|()
condition|)
block|{
name|p_len
index|[
name|fillold
operator|-
literal|1
index|]
operator|-=
literal|1
expr_stmt|;
name|s
index|[
name|p_len
index|[
name|fillold
operator|-
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|'='
case|:
name|ch
operator|=
literal|' '
expr_stmt|;
comment|/* FALL THROUGH */
case|case
literal|' '
case|:
if|if
condition|(
name|fillold
operator|>
name|p_ptrn_lines
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|fillnew
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|fillnew
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillold
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|context
operator|++
expr_stmt|;
name|p_char
index|[
name|fillold
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillold
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillold
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|savestr
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
while|while
condition|(
operator|--
name|fillnew
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|fillnew
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillold
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
if|if
condition|(
name|fillold
operator|>
name|p_ptrn_lines
condition|)
block|{
if|if
condition|(
name|remove_special_line
argument_list|()
condition|)
block|{
name|p_len
index|[
name|fillold
operator|-
literal|1
index|]
operator|-=
literal|1
expr_stmt|;
name|s
index|[
name|p_len
index|[
name|fillold
operator|-
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* FALL THROUGH */
case|case
literal|'+'
case|:
if|if
condition|(
name|fillnew
operator|>
name|p_end
condition|)
block|{
name|free
argument_list|(
name|s
argument_list|)
expr_stmt|;
while|while
condition|(
operator|--
name|fillnew
operator|>
name|p_ptrn_lines
condition|)
name|free
argument_list|(
name|p_line
index|[
name|fillnew
index|]
argument_list|)
expr_stmt|;
name|p_end
operator|=
name|fillold
operator|-
literal|1
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
name|p_char
index|[
name|fillnew
index|]
operator|=
name|ch
expr_stmt|;
name|p_line
index|[
name|fillnew
index|]
operator|=
name|s
expr_stmt|;
name|p_len
index|[
name|fillnew
operator|++
index|]
operator|=
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|fillold
operator|>
name|p_ptrn_lines
condition|)
block|{
if|if
condition|(
name|remove_special_line
argument_list|()
condition|)
block|{
name|p_len
index|[
name|fillnew
operator|-
literal|1
index|]
operator|-=
literal|1
expr_stmt|;
name|s
index|[
name|p_len
index|[
name|fillnew
operator|-
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
default|default:
name|p_end
operator|=
name|fillnew
expr_stmt|;
name|malformed
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ch
operator|!=
literal|' '
operator|&&
name|context
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|context
operator|<
name|p_context
condition|)
name|p_context
operator|=
name|context
expr_stmt|;
name|context
operator|=
operator|-
literal|1000
expr_stmt|;
block|}
block|}
comment|/* while */
block|}
else|else
block|{
comment|/* normal diff--fake it up */
name|char
name|hunk_type
decl_stmt|;
name|int
name|i
decl_stmt|;
name|LINENUM
name|min
decl_stmt|,
name|max
decl_stmt|;
name|line_beginning
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
name|p_context
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
argument_list|)
condition|)
block|{
name|next_intuit_at
argument_list|(
name|line_beginning
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_first
operator|=
name|strtolinenum
argument_list|(
name|buf
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
block|{
name|p_ptrn_lines
operator|=
name|strtolinenum
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|)
operator|-
name|p_first
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p_ptrn_lines
operator|<
literal|0
condition|)
name|malformed
argument_list|()
expr_stmt|;
block|}
else|else
name|p_ptrn_lines
operator|=
operator|(
operator|*
name|s
operator|!=
literal|'a'
operator|)
expr_stmt|;
name|hunk_type
operator|=
operator|*
name|s
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'a'
condition|)
name|p_first
operator|++
expr_stmt|;
comment|/* do append rather than insert */
name|min
operator|=
name|strtolinenum
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|','
condition|)
name|max
operator|=
name|strtolinenum
argument_list|(
name|s
operator|+
literal|1
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
else|else
name|max
operator|=
name|min
expr_stmt|;
if|if
condition|(
name|min
operator|<
literal|0
operator|||
name|min
operator|>
name|max
operator|||
name|max
operator|-
name|min
operator|==
name|LINENUM_MAX
condition|)
name|malformed
argument_list|()
expr_stmt|;
if|if
condition|(
name|hunk_type
operator|==
literal|'d'
condition|)
name|min
operator|++
expr_stmt|;
name|p_newfirst
operator|=
name|min
expr_stmt|;
name|p_repl_lines
operator|=
name|max
operator|-
name|min
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p_newfirst
operator|>
name|LINENUM_MAX
operator|-
name|p_repl_lines
operator|||
name|p_ptrn_lines
operator|>=
name|LINENUM_MAX
operator|-
name|p_repl_lines
operator|-
literal|1
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|p_end
operator|=
name|p_ptrn_lines
operator|+
name|p_repl_lines
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|p_end
operator|>
name|MAXHUNKSIZE
condition|)
name|fatal
argument_list|(
literal|"hunk too large (%ld lines) at line %ld: %s"
argument_list|,
name|p_end
argument_list|,
name|p_input_line
argument_list|,
name|buf
argument_list|)
expr_stmt|;
while|while
condition|(
name|p_end
operator|>=
name|hunkmax
condition|)
name|grow_hunkmax
argument_list|()
expr_stmt|;
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
literal|"*** %ld,%ld\n"
argument_list|,
name|p_first
argument_list|,
name|p_first
operator|+
name|p_ptrn_lines
operator|-
literal|1
argument_list|)
expr_stmt|;
name|p_line
index|[
literal|0
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|p_ptrn_lines
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'<'
condition|)
name|fatal
argument_list|(
literal|"< expected at line %ld of patch\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|p_line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p_char
index|[
name|i
index|]
operator|=
literal|'-'
expr_stmt|;
block|}
if|if
condition|(
name|remove_special_line
argument_list|()
condition|)
block|{
name|p_len
index|[
name|i
operator|-
literal|1
index|]
operator|-=
literal|1
expr_stmt|;
operator|(
name|p_line
index|[
name|i
operator|-
literal|1
index|]
operator|)
index|[
name|p_len
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|hunk_type
operator|==
literal|'c'
condition|)
block|{
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'-'
condition|)
name|fatal
argument_list|(
literal|"--- expected at line %ld of patch\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
literal|"--- %ld,%ld\n"
argument_list|,
name|min
argument_list|,
name|max
argument_list|)
expr_stmt|;
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_char
index|[
name|i
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|i
operator|++
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
name|len
operator|=
name|pgets
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"unexpected end of file in patch at line %ld\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|buf
operator|!=
literal|'>'
condition|)
name|fatal
argument_list|(
literal|"> expected at line %ld of patch\n"
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
name|p_line
index|[
name|i
index|]
operator|=
name|savestr
argument_list|(
name|buf
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|out_of_mem
condition|)
block|{
name|p_end
operator|=
name|i
operator|-
literal|1
expr_stmt|;
return|return
name|false
return|;
block|}
name|p_len
index|[
name|i
index|]
operator|=
name|strlen
argument_list|(
name|p_line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|p_char
index|[
name|i
index|]
operator|=
literal|'+'
expr_stmt|;
block|}
if|if
condition|(
name|remove_special_line
argument_list|()
condition|)
block|{
name|p_len
index|[
name|i
operator|-
literal|1
index|]
operator|-=
literal|1
expr_stmt|;
operator|(
name|p_line
index|[
name|i
operator|-
literal|1
index|]
operator|)
index|[
name|p_len
index|[
name|i
operator|-
literal|1
index|]
index|]
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|reverse
condition|)
comment|/* backwards patch? */
if|if
condition|(
operator|!
name|pch_swap
argument_list|()
condition|)
name|say
argument_list|(
literal|"Not enough memory to swap next hunk!\n"
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
if|if
condition|(
name|debug
operator|&
literal|2
condition|)
block|{
name|LINENUM
name|i
decl_stmt|;
name|char
name|special
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|p_ptrn_lines
condition|)
name|special
operator|=
literal|'^'
expr_stmt|;
else|else
name|special
operator|=
literal|' '
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3ld %c %c %s"
argument_list|,
name|i
argument_list|,
name|p_char
index|[
name|i
index|]
argument_list|,
name|special
argument_list|,
name|p_line
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
if|if
condition|(
name|p_end
operator|+
literal|1
operator|<
name|hunkmax
condition|)
comment|/* paranoia reigns supreme... */
name|p_char
index|[
name|p_end
operator|+
literal|1
index|]
operator|=
literal|'^'
expr_stmt|;
comment|/* add a stopper for apply_hunk */
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Input a line from the patch file.  * Worry about indentation if do_indent is true.  * The line is read directly into the buf global variable which  * is resized if necessary in order to hold the complete line.  * Returns the number of characters read including the terminating  * '\n', if any.  */
end_comment

begin_function
name|size_t
name|pgets
parameter_list|(
name|bool
name|do_indent
parameter_list|)
block|{
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|indent
init|=
literal|0
decl_stmt|,
name|skipped
init|=
literal|0
decl_stmt|;
name|line
operator|=
name|fgetln
argument_list|(
name|pfp
argument_list|,
operator|&
name|len
argument_list|)
expr_stmt|;
if|if
condition|(
name|line
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|len
operator|+
literal|1
operator|>
name|buf_size
condition|)
block|{
while|while
condition|(
name|len
operator|+
literal|1
operator|>
name|buf_size
condition|)
name|buf_size
operator|*=
literal|2
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|buf
operator|=
name|malloc
argument_list|(
name|buf_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"out of memory\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_indent
operator|==
literal|1
operator|&&
name|p_indent
condition|)
block|{
for|for
control|(
init|;
name|indent
operator|<
name|p_indent
operator|&&
operator|(
operator|*
name|line
operator|==
literal|' '
operator|||
operator|*
name|line
operator|==
literal|'\t'
operator|||
operator|*
name|line
operator|==
literal|'X'
operator|)
condition|;
name|line
operator|++
operator|,
name|skipped
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|line
operator|==
literal|'\t'
condition|)
name|indent
operator|+=
literal|8
operator|-
operator|(
name|indent
operator|%
literal|7
operator|)
expr_stmt|;
else|else
name|indent
operator|++
expr_stmt|;
block|}
block|}
name|memcpy
argument_list|(
name|buf
argument_list|,
name|line
argument_list|,
name|len
operator|-
name|skipped
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
operator|-
name|skipped
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
return|return
name|len
return|;
block|}
end_function

begin_comment
comment|/*  * Reverse the old and new portions of the current hunk.  */
end_comment

begin_function
name|bool
name|pch_swap
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|tp_line
decl_stmt|;
comment|/* the text of the hunk */
name|unsigned
name|short
modifier|*
name|tp_len
decl_stmt|;
comment|/* length of each line */
name|char
modifier|*
name|tp_char
decl_stmt|;
comment|/* +, -, and ! */
name|LINENUM
name|i
decl_stmt|;
name|LINENUM
name|n
decl_stmt|;
name|bool
name|blankline
init|=
name|false
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|i
operator|=
name|p_first
expr_stmt|;
name|p_first
operator|=
name|p_newfirst
expr_stmt|;
name|p_newfirst
operator|=
name|i
expr_stmt|;
comment|/* make a scratch copy */
name|tp_line
operator|=
name|p_line
expr_stmt|;
name|tp_len
operator|=
name|p_len
expr_stmt|;
name|tp_char
operator|=
name|p_char
expr_stmt|;
name|p_line
operator|=
name|NULL
expr_stmt|;
comment|/* force set_hunkmax to allocate again */
name|p_len
operator|=
name|NULL
expr_stmt|;
name|p_char
operator|=
name|NULL
expr_stmt|;
name|set_hunkmax
argument_list|()
expr_stmt|;
if|if
condition|(
name|p_line
operator|==
name|NULL
operator|||
name|p_len
operator|==
name|NULL
operator|||
name|p_char
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|p_line
argument_list|)
expr_stmt|;
name|p_line
operator|=
name|tp_line
expr_stmt|;
name|free
argument_list|(
name|p_len
argument_list|)
expr_stmt|;
name|p_len
operator|=
name|tp_len
expr_stmt|;
name|free
argument_list|(
name|p_char
argument_list|)
expr_stmt|;
name|p_char
operator|=
name|tp_char
expr_stmt|;
return|return
name|false
return|;
comment|/* not enough memory to swap hunk! */
block|}
comment|/* now turn the new into the old */
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|tp_char
index|[
name|i
index|]
operator|==
literal|'\n'
condition|)
block|{
comment|/* account for possible blank line */
name|blankline
operator|=
name|true
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_efake
operator|>=
literal|0
condition|)
block|{
comment|/* fix non-freeable ptr range */
if|if
condition|(
name|p_efake
operator|<=
name|i
condition|)
name|n
operator|=
name|p_end
operator|-
name|i
operator|+
literal|1
expr_stmt|;
else|else
name|n
operator|=
operator|-
name|i
expr_stmt|;
name|p_efake
operator|+=
name|n
expr_stmt|;
name|p_bfake
operator|+=
name|n
expr_stmt|;
block|}
for|for
control|(
name|n
operator|=
literal|0
init|;
name|i
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_char
index|[
name|n
index|]
operator|==
literal|'+'
condition|)
name|p_char
index|[
name|n
index|]
operator|=
literal|'-'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|blankline
condition|)
block|{
name|i
operator|=
name|p_ptrn_lines
operator|+
literal|1
expr_stmt|;
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
name|n
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|p_char
index|[
literal|0
index|]
operator|!=
literal|'='
condition|)
name|fatal
argument_list|(
literal|"Malformed patch at line %ld: expected '=' found '%c'\n"
argument_list|,
name|p_input_line
argument_list|,
name|p_char
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|p_char
index|[
literal|0
index|]
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
name|s
operator|=
name|p_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'-'
condition|)
operator|*
name|s
operator|=
literal|'*'
expr_stmt|;
comment|/* now turn the old into the new */
if|if
condition|(
name|p_char
index|[
literal|0
index|]
operator|!=
literal|'*'
condition|)
name|fatal
argument_list|(
literal|"Malformed patch at line %ld: expected '*' found '%c'\n"
argument_list|,
name|p_input_line
argument_list|,
name|p_char
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|tp_char
index|[
literal|0
index|]
operator|=
literal|'='
expr_stmt|;
for|for
control|(
name|s
operator|=
name|tp_line
index|[
literal|0
index|]
init|;
operator|*
name|s
condition|;
name|s
operator|++
control|)
if|if
condition|(
operator|*
name|s
operator|==
literal|'*'
condition|)
operator|*
name|s
operator|=
literal|'-'
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|n
operator|<=
name|p_end
condition|;
name|i
operator|++
operator|,
name|n
operator|++
control|)
block|{
name|p_line
index|[
name|n
index|]
operator|=
name|tp_line
index|[
name|i
index|]
expr_stmt|;
name|p_char
index|[
name|n
index|]
operator|=
name|tp_char
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|p_char
index|[
name|n
index|]
operator|==
literal|'-'
condition|)
name|p_char
index|[
name|n
index|]
operator|=
literal|'+'
expr_stmt|;
name|p_len
index|[
name|n
index|]
operator|=
name|tp_len
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|i
operator|!=
name|p_ptrn_lines
operator|+
literal|1
condition|)
name|fatal
argument_list|(
literal|"Malformed patch at line %ld: expected %ld lines, "
literal|"got %ld\n"
argument_list|,
name|p_input_line
argument_list|,
name|p_ptrn_lines
operator|+
literal|1
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|i
operator|=
name|p_ptrn_lines
expr_stmt|;
name|p_ptrn_lines
operator|=
name|p_repl_lines
expr_stmt|;
name|p_repl_lines
operator|=
name|i
expr_stmt|;
name|free
argument_list|(
name|tp_line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp_len
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tp_char
argument_list|)
expr_stmt|;
return|return
name|true
return|;
block|}
end_function

begin_comment
comment|/*  * Return the specified line position in the old file of the old context.  */
end_comment

begin_function
name|LINENUM
name|pch_first
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|p_first
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of lines of old context.  */
end_comment

begin_function
name|LINENUM
name|pch_ptrn_lines
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|p_ptrn_lines
return|;
block|}
end_function

begin_comment
comment|/*  * Return the probable line position in the new file of the first line.  */
end_comment

begin_function
name|LINENUM
name|pch_newfirst
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|p_newfirst
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of lines in the replacement text including context.  */
end_comment

begin_function
name|LINENUM
name|pch_repl_lines
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|p_repl_lines
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of lines in the whole hunk.  */
end_comment

begin_function
name|LINENUM
name|pch_end
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|p_end
return|;
block|}
end_function

begin_comment
comment|/*  * Return the number of context lines before the first changed line.  */
end_comment

begin_function
name|LINENUM
name|pch_context
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|p_context
return|;
block|}
end_function

begin_comment
comment|/*  * Return the length of a particular patch line.  */
end_comment

begin_function
name|unsigned
name|short
name|pch_line_len
parameter_list|(
name|LINENUM
name|line
parameter_list|)
block|{
return|return
name|p_len
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Return the control character (+, -, *, !, etc) for a patch line.  */
end_comment

begin_function
name|char
name|pch_char
parameter_list|(
name|LINENUM
name|line
parameter_list|)
block|{
return|return
name|p_char
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Return a pointer to a particular patch line.  */
end_comment

begin_function
name|char
modifier|*
name|pfetch
parameter_list|(
name|LINENUM
name|line
parameter_list|)
block|{
return|return
name|p_line
index|[
name|line
index|]
return|;
block|}
end_function

begin_comment
comment|/*  * Return where in the patch file this hunk began, for error messages.  */
end_comment

begin_function
name|LINENUM
name|pch_hunk_beg
parameter_list|(
name|void
parameter_list|)
block|{
return|return
name|p_hunk_beg
return|;
block|}
end_function

begin_comment
comment|/*  * Apply an ed script by feeding ed itself.  */
end_comment

begin_function
name|void
name|do_ed_script
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|t
decl_stmt|;
name|off_t
name|beginning_of_this_line
decl_stmt|;
name|FILE
modifier|*
name|pipefp
init|=
name|NULL
decl_stmt|;
name|int
name|continuation
decl_stmt|;
if|if
condition|(
operator|!
name|skip_rest_of_patch
condition|)
block|{
if|if
condition|(
name|copy_file
argument_list|(
name|filearg
index|[
literal|0
index|]
argument_list|,
name|TMPOUTNAME
argument_list|)
operator|<
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|fatal
argument_list|(
literal|"can't create temp file %s"
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
block|}
name|snprintf
argument_list|(
name|buf
argument_list|,
name|buf_size
argument_list|,
literal|"%s%s%s"
argument_list|,
name|_PATH_RED
argument_list|,
name|verbose
condition|?
literal|" "
else|:
literal|" -s "
argument_list|,
name|TMPOUTNAME
argument_list|)
expr_stmt|;
name|pipefp
operator|=
name|popen
argument_list|(
name|buf
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
name|beginning_of_this_line
operator|=
name|ftello
argument_list|(
name|pfp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pgets
argument_list|(
name|true
argument_list|)
operator|==
literal|0
condition|)
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
name|p_input_line
operator|++
expr_stmt|;
for|for
control|(
name|t
operator|=
name|buf
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
argument_list|)
operator|||
operator|*
name|t
operator|==
literal|','
condition|;
name|t
operator|++
control|)
empty_stmt|;
comment|/* POSIX defines allowed commands as {a,c,d,i,s} */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|buf
argument_list|)
operator|&&
operator|(
operator|*
name|t
operator|==
literal|'a'
operator|||
operator|*
name|t
operator|==
literal|'c'
operator|||
operator|*
name|t
operator|==
literal|'d'
operator|||
operator|*
name|t
operator|==
literal|'i'
operator|||
operator|*
name|t
operator|==
literal|'s'
operator|)
condition|)
block|{
if|if
condition|(
name|pipefp
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|t
operator|==
literal|'s'
condition|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
name|continuation
operator|=
literal|0
expr_stmt|;
name|t
operator|=
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'\0'
argument_list|)
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|--
name|t
operator|>=
name|buf
operator|&&
operator|*
name|t
operator|==
literal|'\\'
condition|)
name|continuation
operator|=
operator|!
name|continuation
expr_stmt|;
if|if
condition|(
operator|!
name|continuation
operator|||
name|pgets
argument_list|(
name|true
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|pipefp
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|t
operator|!=
literal|'d'
condition|)
block|{
while|while
condition|(
name|pgets
argument_list|(
name|true
argument_list|)
condition|)
block|{
name|p_input_line
operator|++
expr_stmt|;
if|if
condition|(
name|pipefp
operator|!=
name|NULL
condition|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|pipefp
argument_list|)
expr_stmt|;
if|if
condition|(
name|strEQ
argument_list|(
name|buf
argument_list|,
literal|".\n"
argument_list|)
condition|)
break|break;
block|}
block|}
block|}
else|else
block|{
name|next_intuit_at
argument_list|(
name|beginning_of_this_line
argument_list|,
name|p_input_line
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|pipefp
operator|==
name|NULL
condition|)
return|return;
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"w\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|pipefp
argument_list|,
literal|"q\n"
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
name|pclose
argument_list|(
name|pipefp
argument_list|)
expr_stmt|;
name|ignore_signals
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|check_only
condition|)
block|{
if|if
condition|(
name|move_file
argument_list|(
name|TMPOUTNAME
argument_list|,
name|outname
argument_list|)
operator|<
literal|0
condition|)
block|{
name|toutkeep
operator|=
name|true
expr_stmt|;
name|chmod
argument_list|(
name|TMPOUTNAME
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
block|}
else|else
name|chmod
argument_list|(
name|outname
argument_list|,
name|filemode
argument_list|)
expr_stmt|;
block|}
name|set_signals
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Choose the name of the file to be patched based on POSIX rules.  * NOTE: the POSIX rules are amazingly stupid and we only follow them  *       if the user specified --posix or set POSIXLY_CORRECT.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|posix_name
parameter_list|(
specifier|const
name|struct
name|file_name
modifier|*
name|names
parameter_list|,
name|bool
name|assume_exists
parameter_list|)
block|{
name|char
modifier|*
name|path
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * POSIX states that the filename will be chosen from one 	 * of the old, new and index names (in that order) if 	 * the file exists relative to CWD after -p stripping. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_FILE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|path
operator|!=
name|NULL
operator|&&
name|names
index|[
name|i
index|]
operator|.
name|exists
condition|)
block|{
name|path
operator|=
name|names
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|path
operator|==
name|NULL
operator|&&
operator|!
name|assume_exists
condition|)
block|{
comment|/* 		 * No files found, look for something we can checkout from 		 * RCS/SCCS dirs.  Same order as above. 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|MAX_FILE
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|names
index|[
name|i
index|]
operator|.
name|path
operator|!=
name|NULL
operator|&&
operator|(
name|path
operator|=
name|checked_in
argument_list|(
name|names
index|[
name|i
index|]
operator|.
name|path
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
break|break;
block|}
comment|/* 		 * Still no match?  Check to see if the diff could be creating 		 * a new file. 		 */
if|if
condition|(
name|path
operator|==
name|NULL
operator|&&
name|ok_to_create_file
operator|&&
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|path
operator|!=
name|NULL
condition|)
name|path
operator|=
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|path
expr_stmt|;
block|}
return|return
name|path
condition|?
name|xstrdup
argument_list|(
name|path
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|compare_names
parameter_list|(
specifier|const
name|struct
name|file_name
modifier|*
name|names
parameter_list|,
name|bool
name|assume_exists
parameter_list|,
name|int
name|phase
parameter_list|)
block|{
name|size_t
name|min_components
decl_stmt|,
name|min_baselen
decl_stmt|,
name|min_len
decl_stmt|,
name|tmp
decl_stmt|;
name|char
modifier|*
name|best
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|path
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* 	 * The "best" name is the one with the fewest number of path 	 * components, the shortest basename length, and the shortest 	 * overall length (in that order).  We only use the Index: file 	 * if neither of the old or new files could be intuited from 	 * the diff header. 	 */
name|min_components
operator|=
name|min_baselen
operator|=
name|min_len
operator|=
name|SIZE_MAX
expr_stmt|;
for|for
control|(
name|i
operator|=
name|INDEX_FILE
init|;
name|i
operator|>=
name|OLD_FILE
condition|;
name|i
operator|--
control|)
block|{
name|path
operator|=
name|names
index|[
name|i
index|]
operator|.
name|path
expr_stmt|;
if|if
condition|(
name|path
operator|==
name|NULL
operator|||
operator|(
name|phase
operator|==
literal|1
operator|&&
operator|!
name|names
index|[
name|i
index|]
operator|.
name|exists
operator|&&
operator|!
name|assume_exists
operator|)
operator|||
operator|(
name|phase
operator|==
literal|2
operator|&&
name|checked_in
argument_list|(
name|path
argument_list|)
operator|==
name|NULL
operator|)
condition|)
continue|continue;
if|if
condition|(
operator|(
name|tmp
operator|=
name|num_components
argument_list|(
name|path
argument_list|)
operator|)
operator|>
name|min_components
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|<
name|min_components
condition|)
block|{
name|min_components
operator|=
name|tmp
expr_stmt|;
name|best
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|strlen
argument_list|(
name|basename
argument_list|(
name|path
argument_list|)
argument_list|)
operator|)
operator|>
name|min_baselen
condition|)
continue|continue;
if|if
condition|(
name|tmp
operator|<
name|min_baselen
condition|)
block|{
name|min_baselen
operator|=
name|tmp
expr_stmt|;
name|best
operator|=
name|path
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|tmp
operator|=
name|strlen
argument_list|(
name|path
argument_list|)
operator|)
operator|>
name|min_len
condition|)
continue|continue;
name|min_len
operator|=
name|tmp
expr_stmt|;
name|best
operator|=
name|path
expr_stmt|;
block|}
return|return
name|best
return|;
block|}
end_function

begin_comment
comment|/*  * Choose the name of the file to be patched based the "best" one  * available.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|best_name
parameter_list|(
specifier|const
name|struct
name|file_name
modifier|*
name|names
parameter_list|,
name|bool
name|assume_exists
parameter_list|)
block|{
name|char
modifier|*
name|best
decl_stmt|;
name|best
operator|=
name|compare_names
argument_list|(
name|names
argument_list|,
name|assume_exists
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|best
operator|==
name|NULL
condition|)
block|{
name|best
operator|=
name|compare_names
argument_list|(
name|names
argument_list|,
name|assume_exists
argument_list|,
literal|2
argument_list|)
expr_stmt|;
comment|/* 		 * Still no match?  Check to see if the diff could be creating 		 * a new file. 		 */
if|if
condition|(
name|best
operator|==
name|NULL
operator|&&
name|ok_to_create_file
operator|&&
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|path
operator|!=
name|NULL
condition|)
name|best
operator|=
name|names
index|[
name|NEW_FILE
index|]
operator|.
name|path
expr_stmt|;
block|}
return|return
name|best
condition|?
name|xstrdup
argument_list|(
name|best
argument_list|)
else|:
name|NULL
return|;
block|}
end_function

begin_function
specifier|static
name|size_t
name|num_components
parameter_list|(
specifier|const
name|char
modifier|*
name|path
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
for|for
control|(
name|n
operator|=
literal|0
operator|,
name|cp
operator|=
name|path
init|;
operator|(
name|cp
operator|=
name|strchr
argument_list|(
name|cp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|;
name|n
operator|++
operator|,
name|cp
operator|++
control|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
name|cp
operator|++
expr_stmt|;
comment|/* skip consecutive slashes */
block|}
return|return
name|n
return|;
block|}
end_function

begin_comment
comment|/*  * Convert number at NPTR into LINENUM and save address of first  * character that is not a digit in ENDPTR.  If conversion is not  * possible, call fatal.  */
end_comment

begin_function
specifier|static
name|LINENUM
name|strtolinenum
parameter_list|(
name|char
modifier|*
name|nptr
parameter_list|,
name|char
modifier|*
modifier|*
name|endptr
parameter_list|)
block|{
name|LINENUM
name|rv
decl_stmt|;
name|char
name|c
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
specifier|const
name|char
modifier|*
name|errstr
decl_stmt|;
for|for
control|(
name|p
operator|=
name|nptr
init|;
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|p
argument_list|)
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
name|nptr
condition|)
name|malformed
argument_list|()
expr_stmt|;
name|c
operator|=
operator|*
name|p
expr_stmt|;
operator|*
name|p
operator|=
literal|'\0'
expr_stmt|;
name|rv
operator|=
name|strtonum
argument_list|(
name|nptr
argument_list|,
literal|0
argument_list|,
name|LINENUM_MAX
argument_list|,
operator|&
name|errstr
argument_list|)
expr_stmt|;
if|if
condition|(
name|errstr
operator|!=
name|NULL
condition|)
name|fatal
argument_list|(
literal|"invalid line number at line %ld: `%s' is %s\n"
argument_list|,
name|p_input_line
argument_list|,
name|nptr
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
operator|*
name|p
operator|=
name|c
expr_stmt|;
operator|*
name|endptr
operator|=
name|p
expr_stmt|;
return|return
name|rv
return|;
block|}
end_function

end_unit

