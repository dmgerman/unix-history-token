begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)regexp.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|!(FALSE)
end_define

begin_define
define|#
directive|define
name|NIL
value|0
end_define

begin_decl_stmt
specifier|static
name|void
name|expconv
name|__P
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|boolean
name|_escaped
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if we are currently _escaped */
end_comment

begin_decl_stmt
name|char
modifier|*
name|s_start
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of string */
end_comment

begin_decl_stmt
name|boolean
name|l_onecase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* true if upper and lower equivalent */
end_comment

begin_define
define|#
directive|define
name|makelower
parameter_list|(
name|c
parameter_list|)
value|(isupper((c)) ? tolower((c)) : (c))
end_define

begin_comment
comment|/*  STRNCMP -	like strncmp except that we convert the  *	 	first string to lower case before comparing  *		if l_onecase is set.  */
end_comment

begin_function
name|int
name|STRNCMP
parameter_list|(
name|s1
parameter_list|,
name|s2
parameter_list|,
name|len
parameter_list|)
specifier|register
name|char
modifier|*
name|s1
decl_stmt|,
decl|*
name|s2
decl_stmt|;
end_function

begin_decl_stmt
specifier|register
name|int
name|len
decl_stmt|;
end_decl_stmt

begin_block
block|{
if|if
condition|(
name|l_onecase
condition|)
block|{
do|do
if|if
condition|(
operator|*
name|s2
operator|-
name|makelower
argument_list|(
operator|*
name|s1
argument_list|)
condition|)
return|return
operator|(
operator|*
name|s2
operator|-
name|makelower
argument_list|(
operator|*
name|s1
argument_list|)
operator|)
return|;
else|else
block|{
name|s2
operator|++
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
block|}
else|else
block|{
do|do
if|if
condition|(
operator|*
name|s2
operator|-
operator|*
name|s1
condition|)
return|return
operator|(
operator|*
name|s2
operator|-
operator|*
name|s1
operator|)
return|;
else|else
block|{
name|s2
operator|++
expr_stmt|;
name|s1
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|--
name|len
condition|)
do|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_block

begin_comment
comment|/*	The following routine converts an irregular expression to  *	internal format.  *  *	Either meta symbols (\a \d or \p) or character strings or  *	operations ( alternation or perenthesizing ) can be  *	specified.  Each starts with a descriptor byte.  The descriptor  *	byte has STR set for strings, META set for meta symbols  *	and OPER set for operations.  *	The descriptor byte can also have the OPT bit set if the object  *	defined is optional.  Also ALT can be set to indicate an alternation.  *  *	For metasymbols the byte following the descriptor byte identities  *	the meta symbol (containing an ascii 'a', 'd', 'p', '|', or '(').  For  *	strings the byte after the descriptor is a character count for  *	the string:  *  *		meta symbols := descriptor  *				symbol  *  *		strings :=	descriptor  *				character count  *				the string  *  *		operatins :=	descriptor  *				symbol  *				character count  */
end_comment

begin_comment
comment|/*  *  handy macros for accessing parts of match blocks  */
end_comment

begin_define
define|#
directive|define
name|MSYM
parameter_list|(
name|A
parameter_list|)
value|(*(A+1))
end_define

begin_comment
comment|/* symbol in a meta symbol block */
end_comment

begin_define
define|#
directive|define
name|MNEXT
parameter_list|(
name|A
parameter_list|)
value|(A+2)
end_define

begin_comment
comment|/* character following a metasymbol block */
end_comment

begin_define
define|#
directive|define
name|OSYM
parameter_list|(
name|A
parameter_list|)
value|(*(A+1))
end_define

begin_comment
comment|/* symbol in an operation block */
end_comment

begin_define
define|#
directive|define
name|OCNT
parameter_list|(
name|A
parameter_list|)
value|(*(A+2))
end_define

begin_comment
comment|/* character count */
end_comment

begin_define
define|#
directive|define
name|ONEXT
parameter_list|(
name|A
parameter_list|)
value|(A+3)
end_define

begin_comment
comment|/* next character after the operation */
end_comment

begin_define
define|#
directive|define
name|OPTR
parameter_list|(
name|A
parameter_list|)
value|(A+*(A+2))
end_define

begin_comment
comment|/* place pointed to by the operator */
end_comment

begin_define
define|#
directive|define
name|SCNT
parameter_list|(
name|A
parameter_list|)
value|(*(A+1))
end_define

begin_comment
comment|/* byte count of a string */
end_comment

begin_define
define|#
directive|define
name|SSTR
parameter_list|(
name|A
parameter_list|)
value|(A+2)
end_define

begin_comment
comment|/* address of the string */
end_comment

begin_define
define|#
directive|define
name|SNEXT
parameter_list|(
name|A
parameter_list|)
value|(A+2+*(A+1))
end_define

begin_comment
comment|/* character following the string */
end_comment

begin_comment
comment|/*  *  bit flags in the descriptor  */
end_comment

begin_define
define|#
directive|define
name|OPT
value|1
end_define

begin_define
define|#
directive|define
name|STR
value|2
end_define

begin_define
define|#
directive|define
name|META
value|4
end_define

begin_define
define|#
directive|define
name|ALT
value|8
end_define

begin_define
define|#
directive|define
name|OPER
value|16
end_define

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ccre
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer to current position in converted exp*/
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|ure
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer current position in unconverted exp */
end_comment

begin_function
name|char
modifier|*
name|convexp
parameter_list|(
name|re
parameter_list|)
name|char
modifier|*
name|re
decl_stmt|;
comment|/* unconverted irregular expression */
block|{
specifier|register
name|char
modifier|*
name|cre
decl_stmt|;
comment|/* pointer to converted regular expression */
comment|/* allocate room for the converted expression */
if|if
condition|(
name|re
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|*
name|re
operator|==
literal|'\0'
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|cre
operator|=
name|malloc
argument_list|(
literal|4
operator|*
name|strlen
argument_list|(
name|re
argument_list|)
operator|+
literal|3
argument_list|)
expr_stmt|;
name|ccre
operator|=
name|cre
expr_stmt|;
name|ure
operator|=
name|re
expr_stmt|;
comment|/* start the conversion with a \a */
operator|*
name|cre
operator|=
name|META
operator||
name|OPT
expr_stmt|;
name|MSYM
argument_list|(
name|cre
argument_list|)
operator|=
literal|'a'
expr_stmt|;
name|ccre
operator|=
name|MNEXT
argument_list|(
name|cre
argument_list|)
expr_stmt|;
comment|/* start the conversion (its recursive) */
name|expconv
argument_list|()
expr_stmt|;
operator|*
name|ccre
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|cre
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|expconv
parameter_list|()
block|{
specifier|register
name|char
modifier|*
name|cs
decl_stmt|;
comment|/* pointer to current symbol in converted exp */
specifier|register
name|char
name|c
decl_stmt|;
comment|/* character being processed */
specifier|register
name|char
modifier|*
name|acs
decl_stmt|;
comment|/* pinter to last alternate */
specifier|register
name|int
name|temp
decl_stmt|;
comment|/* let the conversion begin */
name|acs
operator|=
name|NIL
expr_stmt|;
name|cs
operator|=
name|NIL
expr_stmt|;
while|while
condition|(
operator|*
name|ure
operator|!=
name|NIL
condition|)
block|{
switch|switch
condition|(
name|c
operator|=
operator|*
name|ure
operator|++
condition|)
block|{
case|case
literal|'\\'
case|:
switch|switch
condition|(
name|c
operator|=
operator|*
name|ure
operator|++
condition|)
block|{
comment|/* escaped characters are just characters */
default|default:
if|if
condition|(
name|cs
operator|==
name|NIL
operator|||
operator|(
operator|*
name|cs
operator|&
name|STR
operator|)
operator|==
literal|0
condition|)
block|{
name|cs
operator|=
name|ccre
expr_stmt|;
operator|*
name|cs
operator|=
name|STR
expr_stmt|;
name|SCNT
argument_list|(
name|cs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ccre
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|SCNT
argument_list|(
name|cs
argument_list|)
operator|++
expr_stmt|;
operator|*
name|ccre
operator|++
operator|=
name|c
expr_stmt|;
break|break;
comment|/* normal(?) metacharacters */
case|case
literal|'a'
case|:
case|case
literal|'d'
case|:
case|case
literal|'e'
case|:
case|case
literal|'p'
case|:
if|if
condition|(
name|acs
operator|!=
name|NIL
operator|&&
name|acs
operator|!=
name|cs
condition|)
block|{
do|do
block|{
name|temp
operator|=
name|OCNT
argument_list|(
name|acs
argument_list|)
expr_stmt|;
name|OCNT
argument_list|(
name|acs
argument_list|)
operator|=
name|ccre
operator|-
name|acs
expr_stmt|;
name|acs
operator|-=
name|temp
expr_stmt|;
block|}
do|while
condition|(
name|temp
operator|!=
literal|0
condition|)
do|;
name|acs
operator|=
name|NIL
expr_stmt|;
block|}
name|cs
operator|=
name|ccre
expr_stmt|;
operator|*
name|cs
operator|=
name|META
expr_stmt|;
name|MSYM
argument_list|(
name|cs
argument_list|)
operator|=
name|c
expr_stmt|;
name|ccre
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* just put the symbol in */
case|case
literal|'^'
case|:
case|case
literal|'$'
case|:
if|if
condition|(
name|acs
operator|!=
name|NIL
operator|&&
name|acs
operator|!=
name|cs
condition|)
block|{
do|do
block|{
name|temp
operator|=
name|OCNT
argument_list|(
name|acs
argument_list|)
expr_stmt|;
name|OCNT
argument_list|(
name|acs
argument_list|)
operator|=
name|ccre
operator|-
name|acs
expr_stmt|;
name|acs
operator|-=
name|temp
expr_stmt|;
block|}
do|while
condition|(
name|temp
operator|!=
literal|0
condition|)
do|;
name|acs
operator|=
name|NIL
expr_stmt|;
block|}
name|cs
operator|=
name|ccre
expr_stmt|;
operator|*
name|cs
operator|=
name|META
expr_stmt|;
name|MSYM
argument_list|(
name|cs
argument_list|)
operator|=
name|c
expr_stmt|;
name|ccre
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
comment|/* mark the last match sequence as optional */
case|case
literal|'?'
case|:
if|if
condition|(
name|cs
condition|)
operator|*
name|cs
operator|=
operator|*
name|cs
operator||
name|OPT
expr_stmt|;
break|break;
comment|/* recurse and define a subexpression */
case|case
literal|'('
case|:
if|if
condition|(
name|acs
operator|!=
name|NIL
operator|&&
name|acs
operator|!=
name|cs
condition|)
block|{
do|do
block|{
name|temp
operator|=
name|OCNT
argument_list|(
name|acs
argument_list|)
expr_stmt|;
name|OCNT
argument_list|(
name|acs
argument_list|)
operator|=
name|ccre
operator|-
name|acs
expr_stmt|;
name|acs
operator|-=
name|temp
expr_stmt|;
block|}
do|while
condition|(
name|temp
operator|!=
literal|0
condition|)
do|;
name|acs
operator|=
name|NIL
expr_stmt|;
block|}
name|cs
operator|=
name|ccre
expr_stmt|;
operator|*
name|cs
operator|=
name|OPER
expr_stmt|;
name|OSYM
argument_list|(
name|cs
argument_list|)
operator|=
literal|'('
expr_stmt|;
name|ccre
operator|=
name|ONEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|expconv
argument_list|()
expr_stmt|;
name|OCNT
argument_list|(
name|cs
argument_list|)
operator|=
name|ccre
operator|-
name|cs
expr_stmt|;
comment|/* offset to next symbol */
break|break;
comment|/* return from a recursion */
case|case
literal|')'
case|:
if|if
condition|(
name|acs
operator|!=
name|NIL
condition|)
block|{
do|do
block|{
name|temp
operator|=
name|OCNT
argument_list|(
name|acs
argument_list|)
expr_stmt|;
name|OCNT
argument_list|(
name|acs
argument_list|)
operator|=
name|ccre
operator|-
name|acs
expr_stmt|;
name|acs
operator|-=
name|temp
expr_stmt|;
block|}
do|while
condition|(
name|temp
operator|!=
literal|0
condition|)
do|;
name|acs
operator|=
name|NIL
expr_stmt|;
block|}
name|cs
operator|=
name|ccre
expr_stmt|;
operator|*
name|cs
operator|=
name|META
expr_stmt|;
name|MSYM
argument_list|(
name|cs
argument_list|)
operator|=
name|c
expr_stmt|;
name|ccre
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
return|return;
comment|/* mark the last match sequence as having an alternate */
comment|/* the third byte will contain an offset to jump over the */
comment|/* alternate match in case the first did not fail */
case|case
literal|'|'
case|:
if|if
condition|(
name|acs
operator|!=
name|NIL
operator|&&
name|acs
operator|!=
name|cs
condition|)
name|OCNT
argument_list|(
name|ccre
argument_list|)
operator|=
name|ccre
operator|-
name|acs
expr_stmt|;
comment|/* make a back pointer */
else|else
name|OCNT
argument_list|(
name|ccre
argument_list|)
operator|=
literal|0
expr_stmt|;
operator|*
name|cs
operator||=
name|ALT
expr_stmt|;
name|cs
operator|=
name|ccre
expr_stmt|;
operator|*
name|cs
operator|=
name|OPER
expr_stmt|;
name|OSYM
argument_list|(
name|cs
argument_list|)
operator|=
literal|'|'
expr_stmt|;
name|ccre
operator|=
name|ONEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|acs
operator|=
name|cs
expr_stmt|;
comment|/* remember that the pointer is to be filles */
break|break;
comment|/* if its not a metasymbol just build a scharacter string */
default|default:
if|if
condition|(
name|cs
operator|==
name|NIL
operator|||
operator|(
operator|*
name|cs
operator|&
name|STR
operator|)
operator|==
literal|0
condition|)
block|{
name|cs
operator|=
name|ccre
expr_stmt|;
operator|*
name|cs
operator|=
name|STR
expr_stmt|;
name|SCNT
argument_list|(
name|cs
argument_list|)
operator|=
literal|1
expr_stmt|;
name|ccre
operator|=
name|SSTR
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
name|SCNT
argument_list|(
name|cs
argument_list|)
operator|++
expr_stmt|;
operator|*
name|ccre
operator|++
operator|=
name|c
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|acs
operator|!=
name|NIL
condition|)
block|{
do|do
block|{
name|temp
operator|=
name|OCNT
argument_list|(
name|acs
argument_list|)
expr_stmt|;
name|OCNT
argument_list|(
name|acs
argument_list|)
operator|=
name|ccre
operator|-
name|acs
expr_stmt|;
name|acs
operator|-=
name|temp
expr_stmt|;
block|}
do|while
condition|(
name|temp
operator|!=
literal|0
condition|)
do|;
name|acs
operator|=
name|NIL
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_comment
comment|/* end of convertre */
end_comment

begin_comment
comment|/*  *	The following routine recognises an irregular expresion  *	with the following special characters:  *  *		\?	-	means last match was optional  *		\a	-	matches any number of characters  *		\d	-	matches any number of spaces and tabs  *		\p	-	matches any number of alphanumeric  *				characters. The  *				characters matched will be copied into  *				the area pointed to by 'name'.  *		\|	-	alternation  *		\( \)	-	grouping used mostly for alternation and  *				optionality  *  *	The irregular expression must be translated to internal form  *	prior to calling this routine  *  *	The value returned is the pointer to the first non \a  *	character matched.  */
end_comment

begin_function
name|char
modifier|*
name|expmatch
parameter_list|(
name|s
parameter_list|,
name|re
parameter_list|,
name|mstring
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
comment|/* string to check for a match in */
specifier|register
name|char
modifier|*
name|re
decl_stmt|;
comment|/* a converted irregular expression */
specifier|register
name|char
modifier|*
name|mstring
decl_stmt|;
comment|/* where to put whatever matches a \p */
block|{
specifier|register
name|char
modifier|*
name|cs
decl_stmt|;
comment|/* the current symbol */
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|,
modifier|*
name|s1
decl_stmt|;
comment|/* temporary pointer */
name|boolean
name|matched
decl_stmt|;
comment|/* a temporary boolean */
comment|/* initial conditions */
if|if
condition|(
name|re
operator|==
name|NIL
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|cs
operator|=
name|re
expr_stmt|;
name|matched
operator|=
name|FALSE
expr_stmt|;
comment|/* loop till expression string is exhausted (or at least pretty tired) */
while|while
condition|(
operator|*
name|cs
condition|)
block|{
switch|switch
condition|(
operator|*
name|cs
operator|&
operator|(
name|OPER
operator||
name|STR
operator||
name|META
operator|)
condition|)
block|{
comment|/* try to match a string */
case|case
name|STR
case|:
name|matched
operator|=
operator|!
name|STRNCMP
argument_list|(
name|s
argument_list|,
name|SSTR
argument_list|(
name|cs
argument_list|)
argument_list|,
name|SCNT
argument_list|(
name|cs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|matched
condition|)
block|{
comment|/* hoorah it matches */
name|s
operator|+=
name|SCNT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|cs
operator|=
name|SNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|ALT
condition|)
block|{
comment|/* alternation, skip to next expression */
name|cs
operator|=
name|SNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|OPT
condition|)
block|{
comment|/* the match is optional */
name|cs
operator|=
name|SNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* indicate a successful match */
block|}
else|else
block|{
comment|/* no match, error return */
return|return
operator|(
name|NIL
operator|)
return|;
block|}
break|break;
comment|/* an operator, do something fancy */
case|case
name|OPER
case|:
switch|switch
condition|(
name|OSYM
argument_list|(
name|cs
argument_list|)
condition|)
block|{
comment|/* this is an alternation */
case|case
literal|'|'
case|:
if|if
condition|(
name|matched
condition|)
comment|/* last thing in the alternation was a match, skip ahead */
name|cs
operator|=
name|OPTR
argument_list|(
name|cs
argument_list|)
expr_stmt|;
else|else
comment|/* no match, keep trying */
name|cs
operator|=
name|ONEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
comment|/* this is a grouping, recurse */
case|case
literal|'('
case|:
name|ptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|ONEXT
argument_list|(
name|cs
argument_list|)
argument_list|,
name|mstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NIL
condition|)
block|{
comment|/* the subexpression matched */
name|matched
operator|=
literal|1
expr_stmt|;
name|s
operator|=
name|ptr
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|ALT
condition|)
block|{
comment|/* alternation, skip to next expression */
name|matched
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|OPT
condition|)
block|{
comment|/* the match is optional */
name|matched
operator|=
literal|1
expr_stmt|;
comment|/* indicate a successful match */
block|}
else|else
block|{
comment|/* no match, error return */
return|return
operator|(
name|NIL
operator|)
return|;
block|}
name|cs
operator|=
name|OPTR
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
comment|/* try to match a metasymbol */
case|case
name|META
case|:
switch|switch
condition|(
name|MSYM
argument_list|(
name|cs
argument_list|)
condition|)
block|{
comment|/* try to match anything and remember what was matched */
case|case
literal|'p'
case|:
comment|/* 		 *  This is really the same as trying the match the 		 *  remaining parts of the expression to any subset 		 *  of the string. 		 */
name|s1
operator|=
name|s
expr_stmt|;
do|do
block|{
name|ptr
operator|=
name|expmatch
argument_list|(
name|s1
argument_list|,
name|MNEXT
argument_list|(
name|cs
argument_list|)
argument_list|,
name|mstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NIL
operator|&&
name|s1
operator|!=
name|s
condition|)
block|{
comment|/* we have a match, remember the match */
name|strncpy
argument_list|(
name|mstring
argument_list|,
name|s
argument_list|,
name|s1
operator|-
name|s
argument_list|)
expr_stmt|;
name|mstring
index|[
name|s1
operator|-
name|s
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|!=
name|NIL
operator|&&
operator|(
operator|*
name|cs
operator|&
name|OPT
operator|)
condition|)
block|{
comment|/* it was aoptional so no match is ok */
return|return
operator|(
name|ptr
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|!=
name|NIL
condition|)
block|{
comment|/* not optional and we still matched */
return|return
operator|(
name|NIL
operator|)
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|isalnum
argument_list|(
operator|*
name|s1
argument_list|)
operator|||
operator|*
name|s1
operator|==
literal|'_'
operator|||
comment|/* C++ destructor */
operator|*
name|s1
operator|==
literal|'~'
operator|||
comment|/* C++ scope operator */
operator|(
name|strlen
argument_list|(
name|s1
argument_list|)
operator|>
literal|1
operator|&&
operator|*
name|s1
operator|==
literal|':'
operator|&&
name|s1
index|[
literal|1
index|]
operator|==
literal|':'
operator|&&
operator|(
name|s1
operator|++
operator|,
name|TRUE
operator|)
operator|)
operator|)
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\\'
condition|)
name|_escaped
operator|=
name|_escaped
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
else|else
name|_escaped
operator|=
name|FALSE
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s1
operator|++
condition|)
do|;
return|return
operator|(
name|NIL
operator|)
return|;
comment|/* try to match anything */
case|case
literal|'a'
case|:
comment|/* 		 *  This is really the same as trying the match the 		 *  remaining parts of the expression to any subset 		 *  of the string. 		 */
name|s1
operator|=
name|s
expr_stmt|;
do|do
block|{
name|ptr
operator|=
name|expmatch
argument_list|(
name|s1
argument_list|,
name|MNEXT
argument_list|(
name|cs
argument_list|)
argument_list|,
name|mstring
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NIL
operator|&&
name|s1
operator|!=
name|s
condition|)
block|{
comment|/* we have a match */
return|return
operator|(
name|ptr
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|!=
name|NIL
operator|&&
operator|(
operator|*
name|cs
operator|&
name|OPT
operator|)
condition|)
block|{
comment|/* it was aoptional so no match is ok */
return|return
operator|(
name|ptr
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|ptr
operator|!=
name|NIL
condition|)
block|{
comment|/* not optional and we still matched */
return|return
operator|(
name|NIL
operator|)
return|;
block|}
if|if
condition|(
operator|*
name|s1
operator|==
literal|'\\'
condition|)
name|_escaped
operator|=
name|_escaped
condition|?
name|FALSE
else|:
name|TRUE
expr_stmt|;
else|else
name|_escaped
operator|=
name|FALSE
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s1
operator|++
condition|)
do|;
return|return
operator|(
name|NIL
operator|)
return|;
comment|/* fail if we are currently _escaped */
case|case
literal|'e'
case|:
if|if
condition|(
name|_escaped
condition|)
return|return
operator|(
name|NIL
operator|)
return|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
break|break;
comment|/* match any number of tabs and spaces */
case|case
literal|'d'
case|:
name|ptr
operator|=
name|s
expr_stmt|;
while|while
condition|(
operator|*
name|s
operator|==
literal|' '
operator|||
operator|*
name|s
operator|==
literal|'\t'
condition|)
name|s
operator|++
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|ptr
operator|||
name|s
operator|==
name|s_start
condition|)
block|{
comment|/* match, be happy */
name|matched
operator|=
literal|1
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|s
operator|==
literal|'\n'
operator|||
operator|*
name|s
operator|==
literal|'\0'
condition|)
block|{
comment|/* match, be happy */
name|matched
operator|=
literal|1
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|ALT
condition|)
block|{
comment|/* try the next part */
name|matched
operator|=
literal|0
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|OPT
condition|)
block|{
comment|/* doesn't matter */
name|matched
operator|=
literal|1
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* no match, error return */
return|return
operator|(
name|NIL
operator|)
return|;
break|break;
comment|/* check for end of line */
case|case
literal|'$'
case|:
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|||
operator|*
name|s
operator|==
literal|'\n'
condition|)
block|{
comment|/* match, be happy */
name|s
operator|++
expr_stmt|;
name|matched
operator|=
literal|1
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|ALT
condition|)
block|{
comment|/* try the next part */
name|matched
operator|=
literal|0
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|OPT
condition|)
block|{
comment|/* doesn't matter */
name|matched
operator|=
literal|1
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* no match, error return */
return|return
operator|(
name|NIL
operator|)
return|;
break|break;
comment|/* check for start of line */
case|case
literal|'^'
case|:
if|if
condition|(
name|s
operator|==
name|s_start
condition|)
block|{
comment|/* match, be happy */
name|matched
operator|=
literal|1
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|ALT
condition|)
block|{
comment|/* try the next part */
name|matched
operator|=
literal|0
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cs
operator|&
name|OPT
condition|)
block|{
comment|/* doesn't matter */
name|matched
operator|=
literal|1
expr_stmt|;
name|cs
operator|=
name|MNEXT
argument_list|(
name|cs
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* no match, error return */
return|return
operator|(
name|NIL
operator|)
return|;
break|break;
comment|/* end of a subexpression, return success */
case|case
literal|')'
case|:
return|return
operator|(
name|s
operator|)
return|;
block|}
break|break;
block|}
block|}
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

end_unit

