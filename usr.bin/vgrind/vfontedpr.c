begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1980, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)vfontedpr.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_define
define|#
directive|define
name|FALSE
value|0
end_define

begin_define
define|#
directive|define
name|TRUE
value|!(FALSE)
end_define

begin_define
define|#
directive|define
name|NIL
value|0
end_define

begin_define
define|#
directive|define
name|STANDARD
value|0
end_define

begin_define
define|#
directive|define
name|ALTERNATE
value|1
end_define

begin_comment
comment|/*  * Vfontedpr.  *  * Dave Presotto 1/12/81 (adapted from an earlier version by Bill Joy)  *  */
end_comment

begin_define
define|#
directive|define
name|STRLEN
value|10
end_define

begin_comment
comment|/* length of strings introducing things */
end_comment

begin_define
define|#
directive|define
name|PNAMELEN
value|40
end_define

begin_comment
comment|/* length of a function/procedure name */
end_comment

begin_define
define|#
directive|define
name|PSMAX
value|20
end_define

begin_comment
comment|/* size of procedure name stacking */
end_comment

begin_decl_stmt
specifier|static
name|int
name|iskw
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|isproc
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putKcp
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|,
name|boolean
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putScp
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|void
name|putcp
name|__P
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|tabs
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|width
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *	The state variables  */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|filter
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* act as a filter (like eqn) */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|inchr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in a string constant */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|incomm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in a comment of the primary type */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|idx
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* form an index */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|instr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* in a string constant */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|nokeyw
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* no keywords being flagged */
end_comment

begin_decl_stmt
specifier|static
name|boolean
name|pass
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 				 * when acting as a filter, pass indicates 				 * whether we are currently processing 				 * input. 				 */
end_comment

begin_decl_stmt
specifier|static
name|int
name|blklevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current nesting level */
end_comment

begin_decl_stmt
specifier|static
name|int
name|comtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* type of comment */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|defsfile
index|[
literal|2
index|]
init|=
block|{
name|_PATH_VGRINDEFS
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of language definitions file */
end_comment

begin_decl_stmt
specifier|static
name|int
name|margin
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|plstack
index|[
name|PSMAX
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the procedure nesting level stack */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pname
index|[
name|BUFSIZ
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|boolean
name|prccont
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* continue last procedure */
end_comment

begin_decl_stmt
specifier|static
name|int
name|psptr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the stack index of the current procedure */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pstack
index|[
name|PSMAX
index|]
index|[
name|PNAMELEN
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the procedure name stack */
end_comment

begin_comment
comment|/*  *	The language specific globals  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_acmbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string introducing a comment */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_acmend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string ending a comment */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_blkbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string begining of a block */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_blkend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string ending a block */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_chrbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delimiter for character constant */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_chrend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delimiter for character constant */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_combeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string introducing a comment */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_comend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* string ending a comment */
end_comment

begin_decl_stmt
name|char
name|l_escape
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* character used to  escape characters */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_keywds
index|[
name|BUFSIZ
operator|/
literal|2
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* keyword table address */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_nocom
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regexp for non-comments */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_prcbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* regular expr for procedure begin */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_strbeg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delimiter for string constant */
end_comment

begin_decl_stmt
name|char
modifier|*
name|l_strend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* delimiter for string constant */
end_comment

begin_decl_stmt
name|boolean
name|l_toplex
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* procedures only defined at top lex level */
end_comment

begin_decl_stmt
name|char
modifier|*
name|language
init|=
literal|"c"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the language indicator */
end_comment

begin_define
define|#
directive|define
name|ps
parameter_list|(
name|x
parameter_list|)
value|printf("%s", x)
end_define

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
block|{
name|char
modifier|*
name|fname
init|=
literal|""
decl_stmt|;
name|struct
name|stat
name|stbuf
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
name|char
modifier|*
name|defs
decl_stmt|;
name|int
name|needbp
init|=
literal|0
decl_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
do|do
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-h"
argument_list|)
condition|)
block|{
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
block|{
name|printf
argument_list|(
literal|"'ds =H\n"
argument_list|)
expr_stmt|;
name|argc
operator|=
literal|0
expr_stmt|;
goto|goto
name|rest
goto|;
block|}
name|printf
argument_list|(
literal|"'ds =H %s\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|0
condition|)
continue|continue;
goto|goto
name|rest
goto|;
block|}
comment|/* act as a filter like eqn */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-f"
argument_list|)
condition|)
block|{
name|filter
operator|++
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
name|argv
index|[
name|argc
operator|-
literal|1
index|]
expr_stmt|;
name|argv
index|[
name|argc
operator|-
literal|1
index|]
operator|=
literal|"-"
expr_stmt|;
continue|continue;
block|}
comment|/* take input from the standard place */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-"
argument_list|)
condition|)
block|{
name|argc
operator|=
literal|0
expr_stmt|;
goto|goto
name|rest
goto|;
block|}
comment|/* build an index */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-x"
argument_list|)
condition|)
block|{
name|idx
operator|++
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|"-n"
expr_stmt|;
block|}
comment|/* indicate no keywords */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-n"
argument_list|)
condition|)
block|{
name|nokeyw
operator|++
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* specify the font size */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-s"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|i
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
name|i
operator|=
name|i
operator|*
literal|10
operator|+
operator|(
operator|*
name|cp
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
name|printf
argument_list|(
literal|"'ps %d\n'vs %d\n"
argument_list|,
name|i
argument_list|,
name|i
operator|+
literal|1
argument_list|)
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* specify the language */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-l"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|language
operator|=
name|argv
index|[
literal|0
index|]
operator|+
literal|2
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* specify the language description file */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"-d"
argument_list|,
literal|2
argument_list|)
condition|)
block|{
name|defsfile
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* open the file for input */
if|if
condition|(
name|freopen
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|"r"
argument_list|,
name|stdin
argument_list|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|idx
condition|)
name|printf
argument_list|(
literal|"'ta 4i 4.25i 5.5iR\n'in .5i\n"
argument_list|)
expr_stmt|;
name|fname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|argc
operator|--
operator|,
name|argv
operator|++
expr_stmt|;
block|}
name|rest
label|:
comment|/* 	 *  get the  language definition from the defs file 	 */
name|i
operator|=
name|cgetent
argument_list|(
operator|&
name|defs
argument_list|,
name|defsfile
argument_list|,
name|language
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"no entry for language %s\n"
argument_list|,
name|language
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|2
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"cannot find vgrindefs file %s\n"
argument_list|,
name|defsfile
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|==
operator|-
literal|3
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"potential reference loop detected in vgrindefs file %s\n"
argument_list|,
name|defsfile
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"kw"
argument_list|,
operator|&
name|cp
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|nokeyw
operator|=
name|TRUE
expr_stmt|;
else|else
block|{
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|;
name|cpp
operator|=
name|l_keywds
expr_stmt|;
while|while
condition|(
operator|*
name|cp
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|==
literal|' '
operator|||
operator|*
name|cp
operator|==
literal|'\t'
condition|)
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|*
name|cp
condition|)
operator|*
name|cpp
operator|++
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|' '
operator|&&
operator|*
name|cp
operator|!=
literal|'\t'
operator|&&
operator|*
name|cp
condition|)
name|cp
operator|++
expr_stmt|;
block|}
operator|*
name|cpp
operator|=
name|NIL
expr_stmt|;
block|}
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"pb"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_prcbeg
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"cb"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_combeg
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"ce"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_comend
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"ab"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_acmbeg
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"ae"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_acmend
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"sb"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_strbeg
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"se"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_strend
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"bb"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_blkbeg
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"be"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_blkend
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"lb"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_chrbeg
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"le"
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
name|l_chrend
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cgetustr
argument_list|(
name|defs
argument_list|,
literal|"nc"
argument_list|,
operator|&
name|cp
argument_list|)
operator|>=
literal|0
condition|)
name|l_nocom
operator|=
name|convexp
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|l_escape
operator|=
literal|'\\'
expr_stmt|;
name|l_onecase
operator|=
operator|(
name|cgetcap
argument_list|(
name|defs
argument_list|,
literal|"oc"
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
name|l_toplex
operator|=
operator|(
name|cgetcap
argument_list|(
name|defs
argument_list|,
literal|"tl"
argument_list|,
literal|':'
argument_list|)
operator|!=
name|NULL
operator|)
expr_stmt|;
comment|/* initialize the program */
name|incomm
operator|=
name|FALSE
expr_stmt|;
name|instr
operator|=
name|FALSE
expr_stmt|;
name|inchr
operator|=
name|FALSE
expr_stmt|;
name|_escaped
operator|=
name|FALSE
expr_stmt|;
name|blklevel
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|psptr
operator|=
literal|0
init|;
name|psptr
operator|<
name|PSMAX
condition|;
name|psptr
operator|++
control|)
block|{
name|pstack
index|[
name|psptr
index|]
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|plstack
index|[
name|psptr
index|]
operator|=
literal|0
expr_stmt|;
block|}
name|psptr
operator|=
operator|-
literal|1
expr_stmt|;
name|ps
argument_list|(
literal|"'-F\n"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|printf
argument_list|(
literal|".ds =F %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"'wh 0 vH\n"
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"'wh -1i vF\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|needbp
condition|)
block|{
name|needbp
operator|=
literal|0
expr_stmt|;
name|printf
argument_list|(
literal|".()\n"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|".bp\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|filter
condition|)
block|{
name|fstat
argument_list|(
name|fileno
argument_list|(
name|stdin
argument_list|)
argument_list|,
operator|&
name|stbuf
argument_list|)
expr_stmt|;
name|cp
operator|=
name|ctime
argument_list|(
operator|&
name|stbuf
operator|.
name|st_mtime
argument_list|)
expr_stmt|;
name|cp
index|[
literal|16
index|]
operator|=
literal|'\0'
expr_stmt|;
name|cp
index|[
literal|24
index|]
operator|=
literal|'\0'
expr_stmt|;
name|printf
argument_list|(
literal|".ds =M %s %s\n"
argument_list|,
name|cp
operator|+
literal|4
argument_list|,
name|cp
operator|+
literal|20
argument_list|)
expr_stmt|;
block|}
comment|/* 	 *	MAIN LOOP!!! 	 */
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|stdin
argument_list|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\f'
condition|)
block|{
name|printf
argument_list|(
literal|".bp\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
condition|)
block|{
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"vS"
argument_list|,
literal|2
argument_list|)
condition|)
name|pass
operator|=
name|TRUE
expr_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
operator|+
literal|1
argument_list|,
literal|"vE"
argument_list|,
literal|2
argument_list|)
condition|)
name|pass
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
name|prccont
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
operator|!
name|filter
operator|||
name|pass
condition|)
name|putScp
argument_list|(
name|buf
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
if|if
condition|(
name|prccont
operator|&&
operator|(
name|psptr
operator|>=
literal|0
operator|)
condition|)
block|{
name|ps
argument_list|(
literal|"'FC "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|pstack
index|[
name|psptr
index|]
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"com %o str %o chr %o ptr %d\n"
argument_list|,
name|incomm
argument_list|,
name|instr
argument_list|,
name|inchr
argument_list|,
name|psptr
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|margin
operator|=
literal|0
expr_stmt|;
block|}
name|needbp
operator|=
literal|1
expr_stmt|;
block|}
do|while
condition|(
name|argc
operator|>
literal|0
condition|)
do|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|isidchr
parameter_list|(
name|c
parameter_list|)
value|(isalnum(c) || (c) == '_')
end_define

begin_function
specifier|static
name|void
name|putScp
parameter_list|(
name|os
parameter_list|)
name|char
modifier|*
name|os
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|s
init|=
name|os
decl_stmt|;
comment|/* pointer to unmatched string */
name|char
name|dummy
index|[
name|BUFSIZ
index|]
decl_stmt|;
comment|/* dummy to be used by expmatch */
name|char
modifier|*
name|comptr
decl_stmt|;
comment|/* end of a comment delimiter */
name|char
modifier|*
name|acmptr
decl_stmt|;
comment|/* end of a comment delimiter */
name|char
modifier|*
name|strptr
decl_stmt|;
comment|/* end of a string delimiter */
name|char
modifier|*
name|chrptr
decl_stmt|;
comment|/* end of a character const delimiter */
name|char
modifier|*
name|blksptr
decl_stmt|;
comment|/* end of a lexical block start */
name|char
modifier|*
name|blkeptr
decl_stmt|;
comment|/* end of a lexical block end */
name|char
modifier|*
name|nocomptr
decl_stmt|;
comment|/* end of a non-comment delimiter */
name|s_start
operator|=
name|os
expr_stmt|;
comment|/* remember the start for expmatch */
name|_escaped
operator|=
name|FALSE
expr_stmt|;
if|if
condition|(
name|nokeyw
operator|||
name|incomm
operator|||
name|instr
condition|)
goto|goto
name|skip
goto|;
if|if
condition|(
name|isproc
argument_list|(
name|s
argument_list|)
condition|)
block|{
name|ps
argument_list|(
literal|"'FN "
argument_list|)
expr_stmt|;
name|ps
argument_list|(
name|pname
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|psptr
operator|<
name|PSMAX
condition|)
block|{
operator|++
name|psptr
expr_stmt|;
name|strncpy
argument_list|(
name|pstack
index|[
name|psptr
index|]
argument_list|,
name|pname
argument_list|,
name|PNAMELEN
argument_list|)
expr_stmt|;
name|pstack
index|[
name|psptr
index|]
index|[
name|PNAMELEN
index|]
operator|=
literal|'\0'
expr_stmt|;
name|plstack
index|[
name|psptr
index|]
operator|=
name|blklevel
expr_stmt|;
block|}
block|}
name|skip
label|:
do|do
block|{
comment|/* check for string, comment, blockstart, etc */
if|if
condition|(
operator|!
name|incomm
operator|&&
operator|!
name|instr
operator|&&
operator|!
name|inchr
condition|)
block|{
name|blkeptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_blkend
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|blksptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_blkbeg
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|comptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_combeg
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|acmptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_acmbeg
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|strptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_strbeg
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|chrptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_chrbeg
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|nocomptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_nocom
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
comment|/* start of non-comment? */
if|if
condition|(
name|nocomptr
operator|!=
name|NIL
condition|)
if|if
condition|(
operator|(
name|nocomptr
operator|<=
name|comptr
operator|||
name|comptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|nocomptr
operator|<=
name|acmptr
operator|||
name|acmptr
operator|==
name|NIL
operator|)
condition|)
block|{
comment|/* continue after non-comment */
name|putKcp
argument_list|(
name|s
argument_list|,
name|nocomptr
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|nocomptr
expr_stmt|;
continue|continue;
block|}
comment|/* start of a comment? */
if|if
condition|(
name|comptr
operator|!=
name|NIL
condition|)
if|if
condition|(
operator|(
name|comptr
operator|<
name|strptr
operator|||
name|strptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|comptr
operator|<
name|acmptr
operator|||
name|acmptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|comptr
operator|<
name|chrptr
operator|||
name|chrptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|comptr
operator|<
name|blksptr
operator|||
name|blksptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|comptr
operator|<
name|blkeptr
operator|||
name|blkeptr
operator|==
name|NIL
operator|)
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|comptr
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|comptr
expr_stmt|;
name|incomm
operator|=
name|TRUE
expr_stmt|;
name|comtype
operator|=
name|STANDARD
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|os
condition|)
name|ps
argument_list|(
literal|"\\c"
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'+C\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* start of a comment? */
if|if
condition|(
name|acmptr
operator|!=
name|NIL
condition|)
if|if
condition|(
operator|(
name|acmptr
operator|<
name|strptr
operator|||
name|strptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|acmptr
operator|<
name|chrptr
operator|||
name|chrptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|acmptr
operator|<
name|blksptr
operator|||
name|blksptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|acmptr
operator|<
name|blkeptr
operator|||
name|blkeptr
operator|==
name|NIL
operator|)
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|acmptr
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|acmptr
expr_stmt|;
name|incomm
operator|=
name|TRUE
expr_stmt|;
name|comtype
operator|=
name|ALTERNATE
expr_stmt|;
if|if
condition|(
name|s
operator|!=
name|os
condition|)
name|ps
argument_list|(
literal|"\\c"
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'+C\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* start of a string? */
if|if
condition|(
name|strptr
operator|!=
name|NIL
condition|)
if|if
condition|(
operator|(
name|strptr
operator|<
name|chrptr
operator|||
name|chrptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|strptr
operator|<
name|blksptr
operator|||
name|blksptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|strptr
operator|<
name|blkeptr
operator|||
name|blkeptr
operator|==
name|NIL
operator|)
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|strptr
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|strptr
expr_stmt|;
name|instr
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* start of a character string? */
if|if
condition|(
name|chrptr
operator|!=
name|NIL
condition|)
if|if
condition|(
operator|(
name|chrptr
operator|<
name|blksptr
operator|||
name|blksptr
operator|==
name|NIL
operator|)
operator|&&
operator|(
name|chrptr
operator|<
name|blkeptr
operator|||
name|blkeptr
operator|==
name|NIL
operator|)
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|chrptr
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|chrptr
expr_stmt|;
name|inchr
operator|=
name|TRUE
expr_stmt|;
continue|continue;
block|}
comment|/* end of a lexical block */
if|if
condition|(
name|blkeptr
operator|!=
name|NIL
condition|)
block|{
if|if
condition|(
name|blkeptr
operator|<
name|blksptr
operator|||
name|blksptr
operator|==
name|NIL
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|blkeptr
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|blkeptr
expr_stmt|;
if|if
condition|(
name|blklevel
operator|>
literal|0
comment|/* sanity */
condition|)
name|blklevel
operator|--
expr_stmt|;
if|if
condition|(
name|psptr
operator|>=
literal|0
operator|&&
name|plstack
index|[
name|psptr
index|]
operator|>=
name|blklevel
condition|)
block|{
comment|/* end of current procedure */
if|if
condition|(
name|s
operator|!=
name|os
condition|)
name|ps
argument_list|(
literal|"\\c"
argument_list|)
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'-F\n"
argument_list|)
expr_stmt|;
name|blklevel
operator|=
name|plstack
index|[
name|psptr
index|]
expr_stmt|;
comment|/* see if we should print the last proc name */
if|if
condition|(
operator|--
name|psptr
operator|>=
literal|0
condition|)
name|prccont
operator|=
name|TRUE
expr_stmt|;
else|else
name|psptr
operator|=
operator|-
literal|1
expr_stmt|;
block|}
continue|continue;
block|}
block|}
comment|/* start of a lexical block */
if|if
condition|(
name|blksptr
operator|!=
name|NIL
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|blksptr
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|blksptr
expr_stmt|;
name|blklevel
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* check for end of comment */
block|}
elseif|else
if|if
condition|(
name|incomm
condition|)
block|{
name|comptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_comend
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
name|acmptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_acmend
argument_list|,
name|dummy
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|comtype
operator|==
name|STANDARD
operator|)
operator|&&
operator|(
name|comptr
operator|!=
name|NIL
operator|)
operator|)
operator|||
operator|(
operator|(
name|comtype
operator|==
name|ALTERNATE
operator|)
operator|&&
operator|(
name|acmptr
operator|!=
name|NIL
operator|)
operator|)
condition|)
block|{
if|if
condition|(
name|comtype
operator|==
name|STANDARD
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|comptr
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|comptr
expr_stmt|;
block|}
else|else
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|acmptr
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|acmptr
expr_stmt|;
block|}
name|incomm
operator|=
name|FALSE
expr_stmt|;
name|ps
argument_list|(
literal|"\\c\n'-C\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check for end of string */
block|}
elseif|else
if|if
condition|(
name|instr
condition|)
block|{
if|if
condition|(
operator|(
name|strptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_strend
argument_list|,
name|dummy
argument_list|)
operator|)
operator|!=
name|NIL
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|strptr
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|strptr
expr_stmt|;
name|instr
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* check for end of character string */
block|}
elseif|else
if|if
condition|(
name|inchr
condition|)
block|{
if|if
condition|(
operator|(
name|chrptr
operator|=
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_chrend
argument_list|,
name|dummy
argument_list|)
operator|)
operator|!=
name|NIL
condition|)
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|chrptr
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|chrptr
expr_stmt|;
name|inchr
operator|=
name|FALSE
expr_stmt|;
continue|continue;
block|}
else|else
block|{
name|putKcp
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* print out the line */
name|putKcp
argument_list|(
name|s
argument_list|,
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
operator|-
literal|1
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|s
operator|=
name|s
operator|+
name|strlen
argument_list|(
name|s
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
operator|*
name|s
condition|)
do|;
block|}
end_function

begin_function
specifier|static
name|void
name|putKcp
parameter_list|(
name|start
parameter_list|,
name|end
parameter_list|,
name|force
parameter_list|)
name|char
modifier|*
name|start
decl_stmt|;
comment|/* start of string to write */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* end of string to write */
name|boolean
name|force
decl_stmt|;
comment|/* true if we should force nokeyw */
block|{
name|int
name|i
decl_stmt|;
name|int
name|xfld
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|start
operator|<=
name|end
condition|)
block|{
if|if
condition|(
name|idx
condition|)
block|{
if|if
condition|(
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|)
block|{
if|if
condition|(
name|xfld
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"\001"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\t"
argument_list|)
expr_stmt|;
name|xfld
operator|=
literal|1
expr_stmt|;
while|while
condition|(
operator|*
name|start
operator|==
literal|' '
operator|||
operator|*
name|start
operator|==
literal|'\t'
condition|)
name|start
operator|++
expr_stmt|;
continue|continue;
block|}
block|}
comment|/* take care of nice tab stops */
if|if
condition|(
operator|*
name|start
operator|==
literal|'\t'
condition|)
block|{
while|while
condition|(
operator|*
name|start
operator|==
literal|'\t'
condition|)
name|start
operator|++
expr_stmt|;
name|i
operator|=
name|tabs
argument_list|(
name|s_start
argument_list|,
name|start
argument_list|)
operator|-
name|margin
operator|/
literal|8
expr_stmt|;
name|printf
argument_list|(
literal|"\\h'|%dn'"
argument_list|,
name|i
operator|*
literal|10
operator|+
literal|1
operator|-
name|margin
operator|%
literal|8
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|nokeyw
operator|&&
operator|!
name|force
condition|)
if|if
condition|(
operator|(
operator|*
name|start
operator|==
literal|'#'
operator|||
name|isidchr
argument_list|(
operator|*
name|start
argument_list|)
operator|)
operator|&&
operator|(
name|start
operator|==
name|s_start
operator|||
operator|!
name|isidchr
argument_list|(
name|start
index|[
operator|-
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|i
operator|=
name|iskw
argument_list|(
name|start
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|ps
argument_list|(
literal|"\\*(+K"
argument_list|)
expr_stmt|;
do|do
name|putcp
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|start
operator|++
argument_list|)
expr_stmt|;
do|while
condition|(
operator|--
name|i
operator|>
literal|0
condition|)
do|;
name|ps
argument_list|(
literal|"\\*(-K"
argument_list|)
expr_stmt|;
continue|continue;
block|}
block|}
name|putcp
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|start
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|tabs
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|os
decl_stmt|;
end_function

begin_block
block|{
return|return
operator|(
name|width
argument_list|(
name|s
argument_list|,
name|os
argument_list|)
operator|/
literal|8
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|int
name|width
parameter_list|(
name|s
parameter_list|,
name|os
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|,
decl|*
name|os
decl_stmt|;
end_function

begin_block
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
while|while
condition|(
name|s
operator|<
name|os
condition|)
block|{
if|if
condition|(
operator|*
name|s
operator|==
literal|'\t'
condition|)
block|{
name|i
operator|=
operator|(
name|i
operator|+
literal|8
operator|)
operator|&
operator|~
literal|7
expr_stmt|;
name|s
operator|++
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|*
name|s
operator|<
literal|' '
condition|)
name|i
operator|+=
literal|2
expr_stmt|;
else|else
name|i
operator|++
expr_stmt|;
name|s
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_block

begin_function
specifier|static
name|void
name|putcp
parameter_list|(
name|c
parameter_list|)
specifier|register
name|int
name|c
decl_stmt|;
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|0
case|:
break|break;
case|case
literal|'\f'
case|:
break|break;
case|case
literal|'\r'
case|:
break|break;
case|case
literal|'{'
case|:
name|ps
argument_list|(
literal|"\\*(+K{\\*(-K"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'}'
case|:
name|ps
argument_list|(
literal|"\\*(+K}\\*(-K"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\\'
case|:
name|ps
argument_list|(
literal|"\\e"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'_'
case|:
name|ps
argument_list|(
literal|"\\*_"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|ps
argument_list|(
literal|"\\*-"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'`'
case|:
name|ps
argument_list|(
literal|"\\`"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
name|ps
argument_list|(
literal|"\\'"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|ps
argument_list|(
literal|"\\&."
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
name|ps
argument_list|(
literal|"\\fI*\\fP"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'/'
case|:
name|ps
argument_list|(
literal|"\\fI\\h'\\w' 'u-\\w'/'u'/\\fP"
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|c
operator|<
literal|040
condition|)
name|putchar
argument_list|(
literal|'^'
argument_list|)
operator|,
name|c
operator||=
literal|'@'
expr_stmt|;
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
name|putchar
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  *	look for a process beginning on this line  */
end_comment

begin_function
specifier|static
name|boolean
name|isproc
parameter_list|(
name|s
parameter_list|)
name|char
modifier|*
name|s
decl_stmt|;
block|{
name|pname
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|l_toplex
operator|||
name|blklevel
operator|==
literal|0
condition|)
if|if
condition|(
name|expmatch
argument_list|(
name|s
argument_list|,
name|l_prcbeg
argument_list|,
name|pname
argument_list|)
operator|!=
name|NIL
condition|)
block|{
return|return
operator|(
name|TRUE
operator|)
return|;
block|}
return|return
operator|(
name|FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  iskw -	check to see if the next word is a keyword  */
end_comment

begin_function
specifier|static
name|int
name|iskw
parameter_list|(
name|s
parameter_list|)
specifier|register
name|char
modifier|*
name|s
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
modifier|*
name|ss
init|=
name|l_keywds
decl_stmt|;
specifier|register
name|int
name|i
init|=
literal|1
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp
init|=
name|s
decl_stmt|;
while|while
condition|(
operator|++
name|cp
operator|,
name|isidchr
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|i
operator|++
expr_stmt|;
while|while
condition|(
name|cp
operator|=
operator|*
name|ss
operator|++
condition|)
if|if
condition|(
operator|!
name|STRNCMP
argument_list|(
name|s
argument_list|,
name|cp
argument_list|,
name|i
argument_list|)
operator|&&
operator|!
name|isidchr
argument_list|(
name|cp
index|[
name|i
index|]
argument_list|)
condition|)
return|return
operator|(
name|i
operator|)
return|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

