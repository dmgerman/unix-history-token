begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: bcode.c,v 1.40 2009/10/27 23:59:37 deraadt Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 2003, Otto Moerbeek<otto@drijf.net>  *  * Permission to use, copy, modify, and distribute this software for any  * purpose with or without fee is hereby granted, provided that the above  * copyright notice and this permission notice appear in all copies.  *  * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES  * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR  * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES  * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN  * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF  * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<openssl/ssl.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_decl_stmt
name|BIGNUM
name|zero
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|__inline
end_define

begin_define
define|#
directive|define
name|MAX_ARRAY_INDEX
value|2048
end_define

begin_define
define|#
directive|define
name|READSTACK_SIZE
value|8
end_define

begin_define
define|#
directive|define
name|NO_ELSE
value|-2
end_define

begin_comment
comment|/* -1 is EOF */
end_comment

begin_define
define|#
directive|define
name|REG_ARRAY_SIZE_SMALL
value|(UCHAR_MAX + 1)
end_define

begin_define
define|#
directive|define
name|REG_ARRAY_SIZE_BIG
value|(UCHAR_MAX + 1 + USHRT_MAX + 1)
end_define

begin_struct
struct|struct
name|bmachine
block|{
name|struct
name|source
modifier|*
name|readstack
decl_stmt|;
name|struct
name|stack
modifier|*
name|reg
decl_stmt|;
name|struct
name|stack
name|stack
decl_stmt|;
name|u_int
name|scale
decl_stmt|;
name|u_int
name|obase
decl_stmt|;
name|u_int
name|ibase
decl_stmt|;
name|size_t
name|readsp
decl_stmt|;
name|size_t
name|reg_array_size
decl_stmt|;
name|size_t
name|readstack_sz
decl_stmt|;
name|bool
name|extended_regs
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|struct
name|bmachine
name|bmachine
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|__inline
name|int
name|readch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|unreadch
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|char
modifier|*
name|readline
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|src_free
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|u_int
name|max
parameter_list|(
name|u_int
parameter_list|,
name|u_int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_long
name|get_ulong
parameter_list|(
name|struct
name|number
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|push_number
parameter_list|(
name|struct
name|number
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|push_string
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|push
parameter_list|(
name|struct
name|value
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|value
operator|*
name|tos
argument_list|(
name|void
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|number
operator|*
name|pop_number
argument_list|(
name|void
argument_list|)
expr_stmt|;
end_expr_stmt

begin_function_decl
specifier|static
name|__inline
name|char
modifier|*
name|pop_string
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|clear_stack
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|print_tos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_print
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|pop_printn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|print_stack
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|__inline
name|void
name|dup
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|swap
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|drop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_scale
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_scale
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_obase
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_obase
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|get_ibase
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|set_ibase
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|stackdepth
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_scale
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int
name|count_digits
parameter_list|(
specifier|const
name|struct
name|number
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|num_digits
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|to_ascii
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|push_line
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|comment
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bexec
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|badd
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bsub
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bmul
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bdiv
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bmod
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bdivmod
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bexp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|bsqrt_stop
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
parameter_list|,
name|u_int
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|bsqrt
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|not
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|equal_numbers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|less_numbers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|lesseq_numbers
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|equal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|not_equal
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|less
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|not_less
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|greater
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|not_greater
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|not_compare
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|compare_numbers
parameter_list|(
name|enum
name|bcode_compare
parameter_list|,
name|struct
name|number
modifier|*
parameter_list|,
name|struct
name|number
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|compare
parameter_list|(
name|enum
name|bcode_compare
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|readreg
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_stack
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_stack
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|load_array
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|store_array
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nop
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quit
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|quitN
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skipN
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|skip_until_mark
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|parse_number
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unknown
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eval_string
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eval_line
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|eval_tos
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_typedef
typedef|typedef
name|void
function_decl|(
modifier|*
name|opcode_function
function_decl|)
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_struct
struct|struct
name|jump_entry
block|{
name|u_char
name|ch
decl_stmt|;
name|opcode_function
name|f
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
name|opcode_function
name|jump_table
index|[
name|UCHAR_MAX
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|jump_entry
name|jump_table_data
index|[]
init|=
block|{
block|{
literal|' '
block|,
name|nop
block|}
block|,
block|{
literal|'!'
block|,
name|not_compare
block|}
block|,
block|{
literal|'#'
block|,
name|comment
block|}
block|,
block|{
literal|'%'
block|,
name|bmod
block|}
block|,
block|{
literal|'('
block|,
name|less_numbers
block|}
block|,
block|{
literal|'*'
block|,
name|bmul
block|}
block|,
block|{
literal|'+'
block|,
name|badd
block|}
block|,
block|{
literal|'-'
block|,
name|bsub
block|}
block|,
block|{
literal|'.'
block|,
name|parse_number
block|}
block|,
block|{
literal|'/'
block|,
name|bdiv
block|}
block|,
block|{
literal|'0'
block|,
name|parse_number
block|}
block|,
block|{
literal|'1'
block|,
name|parse_number
block|}
block|,
block|{
literal|'2'
block|,
name|parse_number
block|}
block|,
block|{
literal|'3'
block|,
name|parse_number
block|}
block|,
block|{
literal|'4'
block|,
name|parse_number
block|}
block|,
block|{
literal|'5'
block|,
name|parse_number
block|}
block|,
block|{
literal|'6'
block|,
name|parse_number
block|}
block|,
block|{
literal|'7'
block|,
name|parse_number
block|}
block|,
block|{
literal|'8'
block|,
name|parse_number
block|}
block|,
block|{
literal|'9'
block|,
name|parse_number
block|}
block|,
block|{
literal|':'
block|,
name|store_array
block|}
block|,
block|{
literal|';'
block|,
name|load_array
block|}
block|,
block|{
literal|'<'
block|,
name|less
block|}
block|,
block|{
literal|'='
block|,
name|equal
block|}
block|,
block|{
literal|'>'
block|,
name|greater
block|}
block|,
block|{
literal|'?'
block|,
name|eval_line
block|}
block|,
block|{
literal|'A'
block|,
name|parse_number
block|}
block|,
block|{
literal|'B'
block|,
name|parse_number
block|}
block|,
block|{
literal|'C'
block|,
name|parse_number
block|}
block|,
block|{
literal|'D'
block|,
name|parse_number
block|}
block|,
block|{
literal|'E'
block|,
name|parse_number
block|}
block|,
block|{
literal|'F'
block|,
name|parse_number
block|}
block|,
block|{
literal|'G'
block|,
name|equal_numbers
block|}
block|,
block|{
literal|'I'
block|,
name|get_ibase
block|}
block|,
block|{
literal|'J'
block|,
name|skipN
block|}
block|,
block|{
literal|'K'
block|,
name|get_scale
block|}
block|,
block|{
literal|'L'
block|,
name|load_stack
block|}
block|,
block|{
literal|'M'
block|,
name|nop
block|}
block|,
block|{
literal|'N'
block|,
name|not
block|}
block|,
block|{
literal|'O'
block|,
name|get_obase
block|}
block|,
block|{
literal|'P'
block|,
name|pop_print
block|}
block|,
block|{
literal|'Q'
block|,
name|quitN
block|}
block|,
block|{
literal|'R'
block|,
name|drop
block|}
block|,
block|{
literal|'S'
block|,
name|store_stack
block|}
block|,
block|{
literal|'X'
block|,
name|push_scale
block|}
block|,
block|{
literal|'Z'
block|,
name|num_digits
block|}
block|,
block|{
literal|'['
block|,
name|push_line
block|}
block|,
block|{
literal|'\f'
block|,
name|nop
block|}
block|,
block|{
literal|'\n'
block|,
name|nop
block|}
block|,
block|{
literal|'\r'
block|,
name|nop
block|}
block|,
block|{
literal|'\t'
block|,
name|nop
block|}
block|,
block|{
literal|'^'
block|,
name|bexp
block|}
block|,
block|{
literal|'_'
block|,
name|parse_number
block|}
block|,
block|{
literal|'a'
block|,
name|to_ascii
block|}
block|,
block|{
literal|'c'
block|,
name|clear_stack
block|}
block|,
block|{
literal|'d'
block|,
name|dup
block|}
block|,
block|{
literal|'f'
block|,
name|print_stack
block|}
block|,
block|{
literal|'i'
block|,
name|set_ibase
block|}
block|,
block|{
literal|'k'
block|,
name|set_scale
block|}
block|,
block|{
literal|'l'
block|,
name|load
block|}
block|,
block|{
literal|'n'
block|,
name|pop_printn
block|}
block|,
block|{
literal|'o'
block|,
name|set_obase
block|}
block|,
block|{
literal|'p'
block|,
name|print_tos
block|}
block|,
block|{
literal|'q'
block|,
name|quit
block|}
block|,
block|{
literal|'r'
block|,
name|swap
block|}
block|,
block|{
literal|'s'
block|,
name|store
block|}
block|,
block|{
literal|'v'
block|,
name|bsqrt
block|}
block|,
block|{
literal|'x'
block|,
name|eval_tos
block|}
block|,
block|{
literal|'z'
block|,
name|stackdepth
block|}
block|,
block|{
literal|'{'
block|,
name|lesseq_numbers
block|}
block|,
block|{
literal|'~'
block|,
name|bdivmod
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|JUMP_TABLE_DATA_SIZE
define|\
value|(sizeof(jump_table_data)/sizeof(jump_table_data[0]))
end_define

begin_function
name|void
name|init_bmachine
parameter_list|(
name|bool
name|extended_registers
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|bmachine
operator|.
name|extended_regs
operator|=
name|extended_registers
expr_stmt|;
name|bmachine
operator|.
name|reg_array_size
operator|=
name|bmachine
operator|.
name|extended_regs
condition|?
name|REG_ARRAY_SIZE_BIG
else|:
name|REG_ARRAY_SIZE_SMALL
expr_stmt|;
name|bmachine
operator|.
name|reg
operator|=
name|calloc
argument_list|(
name|bmachine
operator|.
name|reg_array_size
argument_list|,
sizeof|sizeof
argument_list|(
name|bmachine
operator|.
name|reg
index|[
literal|0
index|]
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmachine
operator|.
name|reg
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|UCHAR_MAX
condition|;
name|i
operator|++
control|)
name|jump_table
index|[
name|i
index|]
operator|=
name|unknown
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|JUMP_TABLE_DATA_SIZE
condition|;
name|i
operator|++
control|)
name|jump_table
index|[
name|jump_table_data
index|[
name|i
index|]
operator|.
name|ch
index|]
operator|=
name|jump_table_data
index|[
name|i
index|]
operator|.
name|f
expr_stmt|;
name|stack_init
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|bmachine
operator|.
name|reg_array_size
condition|;
name|i
operator|++
control|)
name|stack_init
argument_list|(
operator|&
name|bmachine
operator|.
name|reg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|bmachine
operator|.
name|readstack_sz
operator|=
name|READSTACK_SIZE
expr_stmt|;
name|bmachine
operator|.
name|readstack
operator|=
name|calloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|source
argument_list|)
argument_list|,
name|bmachine
operator|.
name|readstack_sz
argument_list|)
expr_stmt|;
if|if
condition|(
name|bmachine
operator|.
name|readstack
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|bmachine
operator|.
name|obase
operator|=
name|bmachine
operator|.
name|ibase
operator|=
literal|10
expr_stmt|;
name|BN_init
argument_list|(
operator|&
name|zero
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_zero
argument_list|(
operator|&
name|zero
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Reset the things needed before processing a (new) file */
end_comment

begin_function
name|void
name|reset_bmachine
parameter_list|(
name|struct
name|source
modifier|*
name|src
parameter_list|)
block|{
name|bmachine
operator|.
name|readsp
operator|=
literal|0
expr_stmt|;
name|bmachine
operator|.
name|readstack
index|[
literal|0
index|]
operator|=
operator|*
name|src
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|int
name|readch
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|source
modifier|*
name|src
init|=
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
decl_stmt|;
return|return
operator|(
name|src
operator|->
name|vtable
operator|->
name|readchar
argument_list|(
name|src
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|unreadch
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|source
modifier|*
name|src
init|=
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
decl_stmt|;
name|src
operator|->
name|vtable
operator|->
name|unreadchar
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|readline
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|source
modifier|*
name|src
init|=
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
decl_stmt|;
return|return
operator|(
name|src
operator|->
name|vtable
operator|->
name|readline
argument_list|(
name|src
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|src_free
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|source
modifier|*
name|src
init|=
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
decl_stmt|;
name|src
operator|->
name|vtable
operator|->
name|free
argument_list|(
name|src
argument_list|)
expr_stmt|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUGGING
end_ifdef

begin_function
name|void
name|pn
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|struct
name|number
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|BN_bn2dec
argument_list|(
name|n
operator|->
name|number
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"BN_bn2dec failed"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|str
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s (%u)\n"
argument_list|,
name|p
argument_list|,
name|n
operator|->
name|scale
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pbn
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|n
parameter_list|)
block|{
name|char
modifier|*
name|p
init|=
name|BN_bn2dec
argument_list|(
name|n
argument_list|)
decl_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"BN_bn2dec failed"
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|str
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" %s\n"
argument_list|,
name|p
argument_list|)
expr_stmt|;
name|OPENSSL_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|__inline
name|u_int
name|max
parameter_list|(
name|u_int
name|a
parameter_list|,
name|u_int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>
name|b
condition|?
name|a
else|:
name|b
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|factors
index|[]
init|=
block|{
literal|0
block|,
literal|10
block|,
literal|100
block|,
literal|1000
block|,
literal|10000
block|,
literal|100000
block|,
literal|1000000
block|,
literal|10000000
block|,
literal|100000000
block|,
literal|1000000000
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|scale_number
parameter_list|(
name|BIGNUM
modifier|*
name|n
parameter_list|,
name|int
name|s
parameter_list|)
block|{
name|unsigned
name|int
name|abs_scale
decl_stmt|;
if|if
condition|(
name|s
operator|==
literal|0
condition|)
return|return;
name|abs_scale
operator|=
name|s
operator|>
literal|0
condition|?
name|s
else|:
operator|-
name|s
expr_stmt|;
if|if
condition|(
name|abs_scale
operator|<
sizeof|sizeof
argument_list|(
name|factors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|factors
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
if|if
condition|(
name|s
operator|>
literal|0
condition|)
name|bn_check
argument_list|(
name|BN_mul_word
argument_list|(
name|n
argument_list|,
name|factors
index|[
name|abs_scale
index|]
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|BN_div_word
argument_list|(
name|n
argument_list|,
name|factors
index|[
name|abs_scale
index|]
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BIGNUM
modifier|*
name|a
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|a
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|a
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|p
argument_list|,
name|abs_scale
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_exp
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|>
literal|0
condition|)
name|bn_check
argument_list|(
name|BN_mul
argument_list|(
name|n
argument_list|,
name|n
argument_list|,
name|a
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|bn_check
argument_list|(
name|BN_div
argument_list|(
name|n
argument_list|,
name|NULL
argument_list|,
name|n
argument_list|,
name|a
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|split_number
parameter_list|(
specifier|const
name|struct
name|number
modifier|*
name|n
parameter_list|,
name|BIGNUM
modifier|*
name|i
parameter_list|,
name|BIGNUM
modifier|*
name|f
parameter_list|)
block|{
name|u_long
name|rem
decl_stmt|;
name|bn_checkp
argument_list|(
name|BN_copy
argument_list|(
name|i
argument_list|,
name|n
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|->
name|scale
operator|==
literal|0
operator|&&
name|f
operator|!=
name|NULL
condition|)
name|bn_check
argument_list|(
name|BN_zero
argument_list|(
name|f
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|n
operator|->
name|scale
operator|<
sizeof|sizeof
argument_list|(
name|factors
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|factors
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|rem
operator|=
name|BN_div_word
argument_list|(
name|i
argument_list|,
name|factors
index|[
name|n
operator|->
name|scale
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|f
argument_list|,
name|rem
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|BIGNUM
modifier|*
name|a
decl_stmt|,
modifier|*
name|p
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|a
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|p
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|a
argument_list|,
literal|10
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|p
argument_list|,
name|n
operator|->
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_exp
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|p
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_div
argument_list|(
name|i
argument_list|,
name|f
argument_list|,
name|n
operator|->
name|number
argument_list|,
name|a
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|__inline
name|void
name|normalize
parameter_list|(
name|struct
name|number
modifier|*
name|n
parameter_list|,
name|u_int
name|s
parameter_list|)
block|{
name|scale_number
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|s
operator|-
name|n
operator|->
name|scale
argument_list|)
expr_stmt|;
name|n
operator|->
name|scale
operator|=
name|s
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|u_long
name|get_ulong
parameter_list|(
name|struct
name|number
modifier|*
name|n
parameter_list|)
block|{
name|normalize
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
return|return
operator|(
name|BN_get_word
argument_list|(
name|n
operator|->
name|number
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|void
name|negate
parameter_list|(
name|struct
name|number
modifier|*
name|n
parameter_list|)
block|{
name|bn_check
argument_list|(
name|BN_sub
argument_list|(
name|n
operator|->
name|number
argument_list|,
operator|&
name|zero
argument_list|,
name|n
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|push_number
parameter_list|(
name|struct
name|number
modifier|*
name|n
parameter_list|)
block|{
name|stack_pushnumber
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|push_string
parameter_list|(
name|char
modifier|*
name|string
parameter_list|)
block|{
name|stack_pushstring
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|,
name|string
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|push
parameter_list|(
name|struct
name|value
modifier|*
name|v
parameter_list|)
block|{
name|stack_push
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|,
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|value
operator|*
name|tos
argument_list|(
argument|void
argument_list|)
block|{
return|return
operator|(
name|stack_tos
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|value
operator|*
name|pop
argument_list|(
argument|void
argument_list|)
block|{
return|return
operator|(
name|stack_pop
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_expr_stmt
specifier|static
name|__inline
expr|struct
name|number
operator|*
name|pop_number
argument_list|(
argument|void
argument_list|)
block|{
return|return
operator|(
name|stack_popnumber
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
operator|)
return|;
block|}
end_expr_stmt

begin_function
specifier|static
name|__inline
name|char
modifier|*
name|pop_string
parameter_list|(
name|void
parameter_list|)
block|{
return|return
operator|(
name|stack_popstring
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|clear_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|stack_clear
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|print_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|stack_print
argument_list|(
name|stdout
argument_list|,
operator|&
name|bmachine
operator|.
name|stack
argument_list|,
literal|""
argument_list|,
name|bmachine
operator|.
name|obase
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|print_tos
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|value
init|=
name|tos
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|print_value
argument_list|(
name|stdout
argument_list|,
name|value
argument_list|,
literal|""
argument_list|,
name|bmachine
operator|.
name|obase
argument_list|)
expr_stmt|;
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
name|warnx
argument_list|(
literal|"stack empty"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|pop_print
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|value
init|=
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|value
operator|->
name|type
condition|)
block|{
case|case
name|BCODE_NONE
case|:
break|break;
case|case
name|BCODE_NUMBER
case|:
name|normalize
argument_list|(
name|value
operator|->
name|u
operator|.
name|num
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|print_ascii
argument_list|(
name|stdout
argument_list|,
name|value
operator|->
name|u
operator|.
name|num
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCODE_STRING
case|:
name|fputs
argument_list|(
name|value
operator|->
name|u
operator|.
name|string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
block|}
name|stack_free_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|pop_printn
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|value
init|=
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|print_value
argument_list|(
name|stdout
argument_list|,
name|value
argument_list|,
literal|""
argument_list|,
name|bmachine
operator|.
name|obase
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|stack_free_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|__inline
name|void
name|dup
parameter_list|(
name|void
parameter_list|)
block|{
name|stack_dup
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|swap
parameter_list|(
name|void
parameter_list|)
block|{
name|stack_swap
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|v
init|=
name|pop
argument_list|()
decl_stmt|;
if|if
condition|(
name|v
operator|!=
name|NULL
condition|)
name|stack_free_value
argument_list|(
name|v
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|get_scale
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|bmachine
operator|.
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_scale
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|u_long
name|scale
decl_stmt|;
name|n
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|BN_cmp
argument_list|(
name|n
operator|->
name|number
argument_list|,
operator|&
name|zero
argument_list|)
operator|<
literal|0
condition|)
name|warnx
argument_list|(
literal|"scale must be a nonnegative number"
argument_list|)
expr_stmt|;
else|else
block|{
name|scale
operator|=
name|get_ulong
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|!=
name|BN_MASK2
operator|&&
name|scale
operator|<=
name|UINT_MAX
condition|)
name|bmachine
operator|.
name|scale
operator|=
operator|(
name|u_int
operator|)
name|scale
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"scale too large"
argument_list|)
expr_stmt|;
block|}
name|free_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_obase
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|bmachine
operator|.
name|obase
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_obase
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|u_long
name|base
decl_stmt|;
name|n
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|base
operator|=
name|get_ulong
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|BN_MASK2
operator|&&
name|base
operator|>
literal|1
operator|&&
name|base
operator|<=
name|UINT_MAX
condition|)
name|bmachine
operator|.
name|obase
operator|=
operator|(
name|u_int
operator|)
name|base
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"output base must be a number greater than 1"
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|get_ibase
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|bmachine
operator|.
name|ibase
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|set_ibase
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|u_long
name|base
decl_stmt|;
name|n
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|!=
name|NULL
condition|)
block|{
name|base
operator|=
name|get_ulong
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|base
operator|!=
name|BN_MASK2
operator|&&
literal|2
operator|<=
name|base
operator|&&
name|base
operator|<=
literal|16
condition|)
name|bmachine
operator|.
name|ibase
operator|=
operator|(
name|u_int
operator|)
name|base
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"input base must be a number between 2 and 16 "
literal|"(inclusive)"
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|stackdepth
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|size_t
name|i
decl_stmt|;
name|i
operator|=
name|stack_size
argument_list|(
operator|&
name|bmachine
operator|.
name|stack
argument_list|)
expr_stmt|;
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|push_scale
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|u_int
name|scale
init|=
literal|0
decl_stmt|;
name|value
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|value
operator|->
name|type
condition|)
block|{
case|case
name|BCODE_NONE
case|:
return|return;
case|case
name|BCODE_NUMBER
case|:
name|scale
operator|=
name|value
operator|->
name|u
operator|.
name|num
operator|->
name|scale
expr_stmt|;
break|break;
case|case
name|BCODE_STRING
case|:
break|break;
block|}
name|stack_free_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|scale
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int
name|count_digits
parameter_list|(
specifier|const
name|struct
name|number
modifier|*
name|n
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|int_part
decl_stmt|,
modifier|*
name|fract_part
decl_stmt|;
name|u_int
name|i
decl_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|n
operator|->
name|number
argument_list|)
condition|)
return|return
operator|(
name|n
operator|->
name|scale
condition|?
name|n
operator|->
name|scale
else|:
literal|1
operator|)
return|;
name|int_part
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|fract_part
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|fract_part
operator|->
name|scale
operator|=
name|n
operator|->
name|scale
expr_stmt|;
name|split_number
argument_list|(
name|n
argument_list|,
name|int_part
operator|->
name|number
argument_list|,
name|fract_part
operator|->
name|number
argument_list|)
expr_stmt|;
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|!
name|BN_is_zero
argument_list|(
name|int_part
operator|->
name|number
argument_list|)
condition|)
block|{
name|BN_div_word
argument_list|(
name|int_part
operator|->
name|number
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|i
operator|++
expr_stmt|;
block|}
name|free_number
argument_list|(
name|int_part
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|fract_part
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|+
name|n
operator|->
name|scale
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|num_digits
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
init|=
name|NULL
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|size_t
name|digits
decl_stmt|;
name|value
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
switch|switch
condition|(
name|value
operator|->
name|type
condition|)
block|{
case|case
name|BCODE_NONE
case|:
return|return;
case|case
name|BCODE_NUMBER
case|:
name|digits
operator|=
name|count_digits
argument_list|(
name|value
operator|->
name|u
operator|.
name|num
argument_list|)
expr_stmt|;
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|digits
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCODE_STRING
case|:
name|digits
operator|=
name|strlen
argument_list|(
name|value
operator|->
name|u
operator|.
name|string
argument_list|)
expr_stmt|;
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|n
operator|->
name|number
argument_list|,
name|digits
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
name|stack_free_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|to_ascii
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|char
name|str
index|[
literal|2
index|]
decl_stmt|;
name|value
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
block|{
name|str
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
switch|switch
condition|(
name|value
operator|->
name|type
condition|)
block|{
case|case
name|BCODE_NONE
case|:
return|return;
case|case
name|BCODE_NUMBER
case|:
name|n
operator|=
name|value
operator|->
name|u
operator|.
name|num
expr_stmt|;
name|normalize
argument_list|(
name|n
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_num_bits
argument_list|(
name|n
operator|->
name|number
argument_list|)
operator|>
literal|8
condition|)
name|bn_check
argument_list|(
name|BN_mask_bits
argument_list|(
name|n
operator|->
name|number
argument_list|,
literal|8
argument_list|)
argument_list|)
expr_stmt|;
name|str
index|[
literal|0
index|]
operator|=
operator|(
name|char
operator|)
name|BN_get_word
argument_list|(
name|n
operator|->
name|number
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCODE_STRING
case|:
name|str
index|[
literal|0
index|]
operator|=
name|value
operator|->
name|u
operator|.
name|string
index|[
literal|0
index|]
expr_stmt|;
break|break;
block|}
name|stack_free_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|push_string
argument_list|(
name|bstrdup
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|int
name|readreg
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch1
decl_stmt|,
name|ch2
decl_stmt|,
name|idx
decl_stmt|;
name|idx
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|idx
operator|==
literal|0xff
operator|&&
name|bmachine
operator|.
name|extended_regs
condition|)
block|{
name|ch1
operator|=
name|readch
argument_list|()
expr_stmt|;
name|ch2
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch1
operator|==
name|EOF
operator|||
name|ch2
operator|==
name|EOF
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected eof"
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
else|else
name|idx
operator|=
operator|(
name|ch1
operator|<<
literal|8
operator|)
operator|+
name|ch2
operator|+
name|UCHAR_MAX
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|idx
operator|<
literal|0
operator|||
operator|(
name|unsigned
operator|)
name|idx
operator|>=
name|bmachine
operator|.
name|reg_array_size
condition|)
block|{
name|warnx
argument_list|(
literal|"internal error: reg num = %d"
argument_list|,
name|idx
argument_list|)
expr_stmt|;
name|idx
operator|=
operator|-
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|idx
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|load
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|struct
name|value
name|copy
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|v
operator|=
name|stack_tos
argument_list|(
operator|&
name|bmachine
operator|.
name|reg
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
block|{
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_zero
argument_list|(
name|n
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|push
argument_list|(
name|stack_dup_value
argument_list|(
name|v
argument_list|,
operator|&
name|copy
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|val
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|val
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|val
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|stack_set_tos
argument_list|(
operator|&
name|bmachine
operator|.
name|reg
index|[
name|idx
index|]
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|load_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stack
modifier|*
name|stack
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|stack
operator|=
operator|&
name|bmachine
operator|.
name|reg
index|[
name|idx
index|]
expr_stmt|;
name|value
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|stack_size
argument_list|(
name|stack
argument_list|)
operator|>
literal|0
condition|)
block|{
name|value
operator|=
name|stack_pop
argument_list|(
name|stack
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|value
operator|!=
name|NULL
condition|)
name|push
argument_list|(
name|value
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"stack register '%c' (0%o) is empty"
argument_list|,
name|idx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_stack
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|int
name|idx
decl_stmt|;
name|idx
operator|=
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
condition|)
block|{
name|value
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
return|return;
name|stack_push
argument_list|(
operator|&
name|bmachine
operator|.
name|reg
index|[
name|idx
index|]
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|load_array
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|inumber
decl_stmt|,
modifier|*
name|n
decl_stmt|;
name|struct
name|stack
modifier|*
name|stack
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|struct
name|value
name|copy
decl_stmt|;
name|u_long
name|idx
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
name|inumber
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|inumber
operator|==
name|NULL
condition|)
return|return;
name|idx
operator|=
name|get_ulong
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|inumber
operator|->
name|number
argument_list|,
operator|&
name|zero
argument_list|)
operator|<
literal|0
condition|)
name|warnx
argument_list|(
literal|"negative idx"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|idx
operator|==
name|BN_MASK2
operator|||
name|idx
operator|>
name|MAX_ARRAY_INDEX
condition|)
name|warnx
argument_list|(
literal|"idx too big"
argument_list|)
expr_stmt|;
else|else
block|{
name|stack
operator|=
operator|&
name|bmachine
operator|.
name|reg
index|[
name|reg
index|]
expr_stmt|;
name|v
operator|=
name|frame_retrieve
argument_list|(
name|stack
argument_list|,
name|idx
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
operator|||
name|v
operator|->
name|type
operator|==
name|BCODE_NONE
condition|)
block|{
name|n
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_zero
argument_list|(
name|n
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
else|else
name|push
argument_list|(
name|stack_dup_value
argument_list|(
name|v
argument_list|,
operator|&
name|copy
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|free_number
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|store_array
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|inumber
decl_stmt|;
name|struct
name|value
modifier|*
name|value
decl_stmt|;
name|struct
name|stack
modifier|*
name|stack
decl_stmt|;
name|u_long
name|idx
decl_stmt|;
name|int
name|reg
decl_stmt|;
name|reg
operator|=
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|reg
operator|>=
literal|0
condition|)
block|{
name|inumber
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|inumber
operator|==
name|NULL
condition|)
return|return;
name|value
operator|=
name|pop
argument_list|()
expr_stmt|;
if|if
condition|(
name|value
operator|==
name|NULL
condition|)
block|{
name|free_number
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
return|return;
block|}
name|idx
operator|=
name|get_ulong
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|inumber
operator|->
name|number
argument_list|,
operator|&
name|zero
argument_list|)
operator|<
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"negative idx"
argument_list|)
expr_stmt|;
name|stack_free_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|idx
operator|==
name|BN_MASK2
operator|||
name|idx
operator|>
name|MAX_ARRAY_INDEX
condition|)
block|{
name|warnx
argument_list|(
literal|"idx too big"
argument_list|)
expr_stmt|;
name|stack_free_value
argument_list|(
name|value
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|stack
operator|=
operator|&
name|bmachine
operator|.
name|reg
index|[
name|reg
index|]
expr_stmt|;
name|frame_assign
argument_list|(
name|stack
argument_list|,
name|idx
argument_list|,
name|value
argument_list|)
expr_stmt|;
block|}
name|free_number
argument_list|(
name|inumber
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|push_line
parameter_list|(
name|void
parameter_list|)
block|{
name|push_string
argument_list|(
name|read_string
argument_list|(
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|comment
parameter_list|(
name|void
parameter_list|)
block|{
name|free
argument_list|(
name|readline
argument_list|()
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bexec
parameter_list|(
name|char
modifier|*
name|line
parameter_list|)
block|{
name|system
argument_list|(
name|line
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|badd
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|r
operator|->
name|scale
operator|=
name|max
argument_list|(
name|a
operator|->
name|scale
argument_list|,
name|b
operator|->
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|scale
operator|>
name|a
operator|->
name|scale
condition|)
name|normalize
argument_list|(
name|a
argument_list|,
name|r
operator|->
name|scale
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|scale
operator|>
name|b
operator|->
name|scale
condition|)
name|normalize
argument_list|(
name|b
argument_list|,
name|r
operator|->
name|scale
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_add
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|a
operator|->
name|number
argument_list|,
name|b
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsub
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|r
operator|->
name|scale
operator|=
name|max
argument_list|(
name|a
operator|->
name|scale
argument_list|,
name|b
operator|->
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|r
operator|->
name|scale
operator|>
name|a
operator|->
name|scale
condition|)
name|normalize
argument_list|(
name|a
argument_list|,
name|r
operator|->
name|scale
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|r
operator|->
name|scale
operator|>
name|b
operator|->
name|scale
condition|)
name|normalize
argument_list|(
name|b
argument_list|,
name|r
operator|->
name|scale
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_sub
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|a
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|bmul_number
parameter_list|(
name|struct
name|number
modifier|*
name|r
parameter_list|,
name|struct
name|number
modifier|*
name|a
parameter_list|,
name|struct
name|number
modifier|*
name|b
parameter_list|)
block|{
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
comment|/* Create copies of the scales, since r might be equal to a or b */
name|u_int
name|ascale
init|=
name|a
operator|->
name|scale
decl_stmt|;
name|u_int
name|bscale
init|=
name|b
operator|->
name|scale
decl_stmt|;
name|u_int
name|rscale
init|=
name|ascale
operator|+
name|bscale
decl_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_mul
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|a
operator|->
name|number
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
if|if
condition|(
name|rscale
operator|>
name|bmachine
operator|.
name|scale
operator|&&
name|rscale
operator|>
name|ascale
operator|&&
name|rscale
operator|>
name|bscale
condition|)
block|{
name|r
operator|->
name|scale
operator|=
name|rscale
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|,
name|max
argument_list|(
name|bmachine
operator|.
name|scale
argument_list|,
name|max
argument_list|(
name|ascale
argument_list|,
name|bscale
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|r
operator|->
name|scale
operator|=
name|rscale
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bmul
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bmul_number
argument_list|(
name|r
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdiv
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|u_int
name|scale
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|r
operator|->
name|scale
operator|=
name|bmachine
operator|.
name|scale
expr_stmt|;
name|scale
operator|=
name|max
argument_list|(
name|a
operator|->
name|scale
argument_list|,
name|b
operator|->
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|a
operator|->
name|number
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"divide by zero"
argument_list|)
expr_stmt|;
else|else
block|{
name|normalize
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|b
argument_list|,
name|scale
operator|+
name|r
operator|->
name|scale
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_div
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|NULL
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|a
operator|->
name|number
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bmod
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|u_int
name|scale
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|scale
operator|=
name|max
argument_list|(
name|a
operator|->
name|scale
argument_list|,
name|b
operator|->
name|scale
argument_list|)
expr_stmt|;
name|r
operator|->
name|scale
operator|=
name|max
argument_list|(
name|b
operator|->
name|scale
argument_list|,
name|a
operator|->
name|scale
operator|+
name|bmachine
operator|.
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|a
operator|->
name|number
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"remainder by zero"
argument_list|)
expr_stmt|;
else|else
block|{
name|normalize
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|b
argument_list|,
name|scale
operator|+
name|bmachine
operator|.
name|scale
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_mod
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|a
operator|->
name|number
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bdivmod
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|rdiv
decl_stmt|,
modifier|*
name|rmod
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|u_int
name|scale
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|rdiv
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|rmod
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|rdiv
operator|->
name|scale
operator|=
name|bmachine
operator|.
name|scale
expr_stmt|;
name|rmod
operator|->
name|scale
operator|=
name|max
argument_list|(
name|b
operator|->
name|scale
argument_list|,
name|a
operator|->
name|scale
operator|+
name|bmachine
operator|.
name|scale
argument_list|)
expr_stmt|;
name|scale
operator|=
name|max
argument_list|(
name|a
operator|->
name|scale
argument_list|,
name|b
operator|->
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_zero
argument_list|(
name|a
operator|->
name|number
argument_list|)
condition|)
name|warnx
argument_list|(
literal|"divide by zero"
argument_list|)
expr_stmt|;
else|else
block|{
name|normalize
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|b
argument_list|,
name|scale
operator|+
name|bmachine
operator|.
name|scale
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_div
argument_list|(
name|rdiv
operator|->
name|number
argument_list|,
name|rmod
operator|->
name|number
argument_list|,
name|b
operator|->
name|number
argument_list|,
name|a
operator|->
name|number
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
name|push_number
argument_list|(
name|rdiv
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|rmod
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|b
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|bexp
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|p
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|u_int
name|scale
decl_stmt|;
name|bool
name|neg
decl_stmt|;
name|p
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|p
operator|->
name|scale
operator|!=
literal|0
condition|)
name|warnx
argument_list|(
literal|"Runtime warning: non-zero scale in exponent"
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|p
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|neg
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|BN_cmp
argument_list|(
name|p
operator|->
name|number
argument_list|,
operator|&
name|zero
argument_list|)
operator|<
literal|0
condition|)
block|{
name|neg
operator|=
name|true
expr_stmt|;
name|negate
argument_list|(
name|p
argument_list|)
expr_stmt|;
name|scale
operator|=
name|bmachine
operator|.
name|scale
expr_stmt|;
block|}
else|else
block|{
comment|/* Posix bc says min(a.scale * b, max(a.scale, scale) */
name|u_long
name|b
decl_stmt|;
name|u_int
name|m
decl_stmt|;
name|b
operator|=
name|BN_get_word
argument_list|(
name|p
operator|->
name|number
argument_list|)
expr_stmt|;
name|m
operator|=
name|max
argument_list|(
name|a
operator|->
name|scale
argument_list|,
name|bmachine
operator|.
name|scale
argument_list|)
expr_stmt|;
name|scale
operator|=
name|a
operator|->
name|scale
operator|*
operator|(
name|u_int
operator|)
name|b
expr_stmt|;
if|if
condition|(
name|scale
operator|>
name|m
operator|||
operator|(
name|a
operator|->
name|scale
operator|>
literal|0
operator|&&
operator|(
name|b
operator|==
name|BN_MASK2
operator|||
name|b
operator|>
name|UINT_MAX
operator|)
operator|)
condition|)
name|scale
operator|=
name|m
expr_stmt|;
block|}
if|if
condition|(
name|BN_is_zero
argument_list|(
name|p
operator|->
name|number
argument_list|)
condition|)
block|{
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_one
argument_list|(
name|r
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|!
name|BN_is_bit_set
argument_list|(
name|p
operator|->
name|number
argument_list|,
literal|0
argument_list|)
condition|)
block|{
name|bmul_number
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_rshift1
argument_list|(
name|p
operator|->
name|number
argument_list|,
name|p
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|r
operator|=
name|dup_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_rshift1
argument_list|(
name|p
operator|->
name|number
argument_list|,
name|p
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
while|while
condition|(
operator|!
name|BN_is_zero
argument_list|(
name|p
operator|->
name|number
argument_list|)
condition|)
block|{
name|bmul_number
argument_list|(
name|a
argument_list|,
name|a
argument_list|,
name|a
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_bit_set
argument_list|(
name|p
operator|->
name|number
argument_list|,
literal|0
argument_list|)
condition|)
name|bmul_number
argument_list|(
name|r
argument_list|,
name|r
argument_list|,
name|a
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_rshift1
argument_list|(
name|p
operator|->
name|number
argument_list|,
name|p
operator|->
name|number
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|neg
condition|)
block|{
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|BIGNUM
modifier|*
name|one
decl_stmt|;
name|one
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|one
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_one
argument_list|(
name|one
argument_list|)
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|scale_number
argument_list|(
name|one
argument_list|,
name|r
operator|->
name|scale
operator|+
name|scale
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|r
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_div
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|NULL
argument_list|,
name|one
argument_list|,
name|r
operator|->
name|number
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|one
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
block|}
else|else
name|normalize
argument_list|(
name|r
argument_list|,
name|scale
argument_list|)
expr_stmt|;
block|}
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|bsqrt_stop
parameter_list|(
specifier|const
name|BIGNUM
modifier|*
name|x
parameter_list|,
specifier|const
name|BIGNUM
modifier|*
name|y
parameter_list|,
name|u_int
modifier|*
name|onecount
parameter_list|)
block|{
name|BIGNUM
modifier|*
name|r
decl_stmt|;
name|bool
name|ret
decl_stmt|;
name|r
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_sub
argument_list|(
name|r
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|BN_is_one
argument_list|(
name|r
argument_list|)
condition|)
operator|(
operator|*
name|onecount
operator|)
operator|++
expr_stmt|;
name|ret
operator|=
name|BN_is_zero
argument_list|(
name|r
argument_list|)
expr_stmt|;
name|BN_free
argument_list|(
name|r
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|||
operator|*
name|onecount
operator|>
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|bsqrt
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|BIGNUM
modifier|*
name|x
decl_stmt|,
modifier|*
name|y
decl_stmt|;
name|BN_CTX
modifier|*
name|ctx
decl_stmt|;
name|u_int
name|onecount
decl_stmt|,
name|scale
decl_stmt|;
name|onecount
operator|=
literal|0
expr_stmt|;
name|n
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
if|if
condition|(
name|BN_is_zero
argument_list|(
name|n
operator|->
name|number
argument_list|)
condition|)
block|{
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|BN_cmp
argument_list|(
name|n
operator|->
name|number
argument_list|,
operator|&
name|zero
argument_list|)
operator|<
literal|0
condition|)
name|warnx
argument_list|(
literal|"square root of negative number"
argument_list|)
expr_stmt|;
else|else
block|{
name|scale
operator|=
name|max
argument_list|(
name|bmachine
operator|.
name|scale
argument_list|,
name|n
operator|->
name|scale
argument_list|)
expr_stmt|;
name|normalize
argument_list|(
name|n
argument_list|,
literal|2
operator|*
name|scale
argument_list|)
expr_stmt|;
name|x
operator|=
name|BN_dup
argument_list|(
name|n
operator|->
name|number
argument_list|)
expr_stmt|;
name|bn_checkp
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_rshift
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|BN_num_bits
argument_list|(
name|x
argument_list|)
operator|/
literal|2
argument_list|)
argument_list|)
expr_stmt|;
name|y
operator|=
name|BN_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|y
argument_list|)
expr_stmt|;
name|ctx
operator|=
name|BN_CTX_new
argument_list|()
expr_stmt|;
name|bn_checkp
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|bn_checkp
argument_list|(
name|BN_copy
argument_list|(
name|y
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_div
argument_list|(
name|x
argument_list|,
name|NULL
argument_list|,
name|n
operator|->
name|number
argument_list|,
name|x
argument_list|,
name|ctx
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_add
argument_list|(
name|x
argument_list|,
name|x
argument_list|,
name|y
argument_list|)
argument_list|)
expr_stmt|;
name|bn_check
argument_list|(
name|BN_rshift1
argument_list|(
name|x
argument_list|,
name|x
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bsqrt_stop
argument_list|(
name|x
argument_list|,
name|y
argument_list|,
operator|&
name|onecount
argument_list|)
condition|)
break|break;
block|}
name|r
operator|=
name|bmalloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|r
argument_list|)
argument_list|)
expr_stmt|;
name|r
operator|->
name|scale
operator|=
name|scale
expr_stmt|;
name|r
operator|->
name|number
operator|=
name|y
expr_stmt|;
name|BN_free
argument_list|(
name|x
argument_list|)
expr_stmt|;
name|BN_CTX_free
argument_list|(
name|ctx
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
name|free_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|not
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|a
operator|->
name|scale
operator|=
literal|0
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|a
operator|->
name|number
argument_list|,
name|BN_get_word
argument_list|(
name|a
operator|->
name|number
argument_list|)
condition|?
literal|0
else|:
literal|1
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|equal
parameter_list|(
name|void
parameter_list|)
block|{
name|compare
argument_list|(
name|BCODE_EQUAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|equal_numbers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|compare_numbers
argument_list|(
name|BCODE_EQUAL
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|less_numbers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|compare_numbers
argument_list|(
name|BCODE_LESS
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|lesseq_numbers
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|,
modifier|*
name|r
decl_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
block|{
return|return;
block|}
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|r
operator|=
name|new_number
argument_list|()
expr_stmt|;
name|bn_check
argument_list|(
name|BN_set_word
argument_list|(
name|r
operator|->
name|number
argument_list|,
name|compare_numbers
argument_list|(
name|BCODE_NOT_GREATER
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
condition|?
literal|1
else|:
literal|0
argument_list|)
argument_list|)
expr_stmt|;
name|push_number
argument_list|(
name|r
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|not_equal
parameter_list|(
name|void
parameter_list|)
block|{
name|compare
argument_list|(
name|BCODE_NOT_EQUAL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|less
parameter_list|(
name|void
parameter_list|)
block|{
name|compare
argument_list|(
name|BCODE_LESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|not_compare
parameter_list|(
name|void
parameter_list|)
block|{
switch|switch
condition|(
name|readch
argument_list|()
condition|)
block|{
case|case
literal|'<'
case|:
name|not_less
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
name|not_greater
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'='
case|:
name|not_equal
argument_list|()
expr_stmt|;
break|break;
default|default:
name|unreadch
argument_list|()
expr_stmt|;
name|bexec
argument_list|(
name|readline
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|not_less
parameter_list|(
name|void
parameter_list|)
block|{
name|compare
argument_list|(
name|BCODE_NOT_LESS
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|greater
parameter_list|(
name|void
parameter_list|)
block|{
name|compare
argument_list|(
name|BCODE_GREATER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|not_greater
parameter_list|(
name|void
parameter_list|)
block|{
name|compare
argument_list|(
name|BCODE_NOT_GREATER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|bool
name|compare_numbers
parameter_list|(
name|enum
name|bcode_compare
name|type
parameter_list|,
name|struct
name|number
modifier|*
name|a
parameter_list|,
name|struct
name|number
modifier|*
name|b
parameter_list|)
block|{
name|u_int
name|scale
decl_stmt|;
name|int
name|cmp
decl_stmt|;
name|scale
operator|=
name|max
argument_list|(
name|a
operator|->
name|scale
argument_list|,
name|b
operator|->
name|scale
argument_list|)
expr_stmt|;
if|if
condition|(
name|scale
operator|>
name|a
operator|->
name|scale
condition|)
name|normalize
argument_list|(
name|a
argument_list|,
name|scale
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|scale
operator|>
name|b
operator|->
name|scale
condition|)
name|normalize
argument_list|(
name|b
argument_list|,
name|scale
argument_list|)
expr_stmt|;
name|cmp
operator|=
name|BN_cmp
argument_list|(
name|a
operator|->
name|number
argument_list|,
name|b
operator|->
name|number
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|b
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|BCODE_EQUAL
case|:
return|return
operator|(
name|cmp
operator|==
literal|0
operator|)
return|;
case|case
name|BCODE_NOT_EQUAL
case|:
return|return
operator|(
name|cmp
operator|!=
literal|0
operator|)
return|;
case|case
name|BCODE_LESS
case|:
return|return
operator|(
name|cmp
operator|<
literal|0
operator|)
return|;
case|case
name|BCODE_NOT_LESS
case|:
return|return
operator|(
name|cmp
operator|>=
literal|0
operator|)
return|;
case|case
name|BCODE_GREATER
case|:
return|return
operator|(
name|cmp
operator|>
literal|0
operator|)
return|;
case|case
name|BCODE_NOT_GREATER
case|:
return|return
operator|(
name|cmp
operator|<=
literal|0
operator|)
return|;
block|}
return|return
operator|(
name|false
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|compare
parameter_list|(
name|enum
name|bcode_compare
name|type
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|struct
name|value
modifier|*
name|v
decl_stmt|;
name|int
name|idx
decl_stmt|,
name|elseidx
decl_stmt|;
name|bool
name|ok
decl_stmt|;
name|elseidx
operator|=
name|NO_ELSE
expr_stmt|;
name|idx
operator|=
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|readch
argument_list|()
operator|==
literal|'e'
condition|)
name|elseidx
operator|=
name|readreg
argument_list|()
expr_stmt|;
else|else
name|unreadch
argument_list|()
expr_stmt|;
name|a
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return;
name|b
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|b
operator|==
name|NULL
condition|)
block|{
name|push_number
argument_list|(
name|a
argument_list|)
expr_stmt|;
return|return;
block|}
name|ok
operator|=
name|compare_numbers
argument_list|(
name|type
argument_list|,
name|a
argument_list|,
name|b
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ok
operator|&&
name|elseidx
operator|!=
name|NO_ELSE
condition|)
name|idx
operator|=
name|elseidx
expr_stmt|;
if|if
condition|(
name|idx
operator|>=
literal|0
operator|&&
operator|(
name|ok
operator|||
operator|(
operator|!
name|ok
operator|&&
name|elseidx
operator|!=
name|NO_ELSE
operator|)
operator|)
condition|)
block|{
name|v
operator|=
name|stack_tos
argument_list|(
operator|&
name|bmachine
operator|.
name|reg
index|[
name|idx
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|v
operator|==
name|NULL
condition|)
name|warnx
argument_list|(
literal|"register '%c' (0%o) is empty"
argument_list|,
name|idx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|v
operator|->
name|type
condition|)
block|{
case|case
name|BCODE_NONE
case|:
name|warnx
argument_list|(
literal|"register '%c' (0%o) is empty"
argument_list|,
name|idx
argument_list|,
name|idx
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCODE_NUMBER
case|:
name|warn
argument_list|(
literal|"eval called with non-string argument"
argument_list|)
expr_stmt|;
break|break;
case|case
name|BCODE_STRING
case|:
name|eval_string
argument_list|(
name|bstrdup
argument_list|(
name|v
operator|->
name|u
operator|.
name|string
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|nop
parameter_list|(
name|void
parameter_list|)
block|{  }
end_function

begin_function
specifier|static
name|void
name|quit
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|bmachine
operator|.
name|readsp
operator|<
literal|2
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|src_free
argument_list|()
expr_stmt|;
name|bmachine
operator|.
name|readsp
operator|--
expr_stmt|;
name|src_free
argument_list|()
expr_stmt|;
name|bmachine
operator|.
name|readsp
operator|--
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|quitN
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|u_long
name|i
decl_stmt|;
name|n
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return;
name|i
operator|=
name|get_ulong
argument_list|(
name|n
argument_list|)
expr_stmt|;
name|free_number
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|BN_MASK2
operator|||
name|i
operator|==
literal|0
condition|)
name|warnx
argument_list|(
literal|"Q command requires a number>= 1"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|bmachine
operator|.
name|readsp
operator|<
name|i
condition|)
name|warnx
argument_list|(
literal|"Q command argument exceeded string execution depth"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|src_free
argument_list|()
expr_stmt|;
name|bmachine
operator|.
name|readsp
operator|--
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|skipN
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|number
modifier|*
name|n
decl_stmt|;
name|u_long
name|i
decl_stmt|;
name|n
operator|=
name|pop_number
argument_list|()
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|NULL
condition|)
return|return;
name|i
operator|=
name|get_ulong
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|BN_MASK2
condition|)
name|warnx
argument_list|(
literal|"J command requires a number>= 0"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|bmachine
operator|.
name|readsp
operator|<
name|i
condition|)
name|warnx
argument_list|(
literal|"J command argument exceeded string execution depth"
argument_list|)
expr_stmt|;
else|else
block|{
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
name|src_free
argument_list|()
expr_stmt|;
name|bmachine
operator|.
name|readsp
operator|--
expr_stmt|;
block|}
name|skip_until_mark
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|skip_until_mark
parameter_list|(
name|void
parameter_list|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
switch|switch
condition|(
name|readch
argument_list|()
condition|)
block|{
case|case
literal|'M'
case|:
return|return;
case|case
name|EOF
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"mark not found"
argument_list|)
expr_stmt|;
return|return;
case|case
literal|'l'
case|:
case|case
literal|'L'
case|:
case|case
literal|'s'
case|:
case|case
literal|'S'
case|:
case|case
literal|':'
case|:
case|case
literal|';'
case|:
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'='
case|:
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|readch
argument_list|()
operator|==
literal|'e'
condition|)
name|readreg
argument_list|()
expr_stmt|;
else|else
name|unreadch
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'['
case|:
name|free
argument_list|(
name|read_string
argument_list|(
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
switch|switch
condition|(
name|readch
argument_list|()
condition|)
block|{
case|case
literal|'<'
case|:
case|case
literal|'>'
case|:
case|case
literal|'='
case|:
name|readreg
argument_list|()
expr_stmt|;
if|if
condition|(
name|readch
argument_list|()
operator|==
literal|'e'
condition|)
name|readreg
argument_list|()
expr_stmt|;
else|else
name|unreadch
argument_list|()
expr_stmt|;
break|break;
default|default:
name|free
argument_list|(
name|readline
argument_list|()
argument_list|)
expr_stmt|;
break|break;
block|}
break|break;
default|default:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|parse_number
parameter_list|(
name|void
parameter_list|)
block|{
name|unreadch
argument_list|()
expr_stmt|;
name|push_number
argument_list|(
name|readnumber
argument_list|(
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
argument_list|,
name|bmachine
operator|.
name|ibase
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unknown
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
init|=
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
operator|.
name|lastchar
decl_stmt|;
name|warnx
argument_list|(
literal|"%c (0%o) is unimplemented"
argument_list|,
name|ch
argument_list|,
name|ch
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eval_string
parameter_list|(
name|char
modifier|*
name|p
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
if|if
condition|(
name|bmachine
operator|.
name|readsp
operator|>
literal|0
condition|)
block|{
comment|/* Check for tail call. Do not recurse in that case. */
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
name|src_free
argument_list|()
expr_stmt|;
name|src_setstring
argument_list|(
operator|&
name|bmachine
operator|.
name|readstack
index|[
name|bmachine
operator|.
name|readsp
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
return|return;
block|}
else|else
name|unreadch
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|bmachine
operator|.
name|readsp
operator|==
name|bmachine
operator|.
name|readstack_sz
operator|-
literal|1
condition|)
block|{
name|size_t
name|newsz
init|=
name|bmachine
operator|.
name|readstack_sz
operator|*
literal|2
decl_stmt|;
name|struct
name|source
modifier|*
name|stack
decl_stmt|;
name|stack
operator|=
name|realloc
argument_list|(
name|bmachine
operator|.
name|readstack
argument_list|,
name|newsz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|source
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|stack
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"recursion too deep"
argument_list|)
expr_stmt|;
name|bmachine
operator|.
name|readstack_sz
operator|=
name|newsz
expr_stmt|;
name|bmachine
operator|.
name|readstack
operator|=
name|stack
expr_stmt|;
block|}
name|src_setstring
argument_list|(
operator|&
name|bmachine
operator|.
name|readstack
index|[
operator|++
name|bmachine
operator|.
name|readsp
index|]
argument_list|,
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eval_line
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Always read from stdin */
name|struct
name|source
name|in
decl_stmt|;
name|char
modifier|*
name|p
decl_stmt|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|src_setstream
argument_list|(
operator|&
name|in
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|p
operator|=
call|(
modifier|*
name|in
operator|.
name|vtable
operator|->
name|readline
call|)
argument_list|(
operator|&
name|in
argument_list|)
expr_stmt|;
name|eval_string
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|eval_tos
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|p
decl_stmt|;
name|p
operator|=
name|pop_string
argument_list|()
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
return|return;
name|eval_string
argument_list|(
name|p
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|eval
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|ch
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|ch
operator|=
name|readch
argument_list|()
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|bmachine
operator|.
name|readsp
operator|==
literal|0
condition|)
return|return;
name|src_free
argument_list|()
expr_stmt|;
name|bmachine
operator|.
name|readsp
operator|--
expr_stmt|;
continue|continue;
block|}
ifdef|#
directive|ifdef
name|DEBUGGING
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"# %c\n"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|stack_print
argument_list|(
name|stderr
argument_list|,
operator|&
name|bmachine
operator|.
name|stack
argument_list|,
literal|"* "
argument_list|,
name|bmachine
operator|.
name|obase
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%zd =>\n"
argument_list|,
name|bmachine
operator|.
name|readsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
literal|0
operator|<=
name|ch
operator|&&
name|ch
operator|<
operator|(
name|signed
operator|)
name|UCHAR_MAX
condition|)
call|(
modifier|*
name|jump_table
index|[
name|ch
index|]
call|)
argument_list|()
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"internal error: opcode %d"
argument_list|,
name|ch
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUGGING
name|stack_print
argument_list|(
name|stderr
argument_list|,
operator|&
name|bmachine
operator|.
name|stack
argument_list|,
literal|"* "
argument_list|,
name|bmachine
operator|.
name|obase
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%zd ==\n"
argument_list|,
name|bmachine
operator|.
name|readsp
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
block|}
end_function

end_unit

