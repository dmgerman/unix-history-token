begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2007-2011 Robert N. M. Watson  * Copyright (c) 2015 Allan Jude<allanjude@freebsd.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/socket.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/un.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<libprocstat.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"procstat.h"
end_include

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|protocol_to_string
parameter_list|(
name|int
name|domain
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|protocol
parameter_list|)
block|{
switch|switch
condition|(
name|domain
condition|)
block|{
case|case
name|AF_INET
case|:
case|case
name|AF_INET6
case|:
switch|switch
condition|(
name|protocol
condition|)
block|{
case|case
name|IPPROTO_TCP
case|:
return|return
operator|(
literal|"TCP"
operator|)
return|;
case|case
name|IPPROTO_UDP
case|:
return|return
operator|(
literal|"UDP"
operator|)
return|;
case|case
name|IPPROTO_ICMP
case|:
return|return
operator|(
literal|"ICM"
operator|)
return|;
case|case
name|IPPROTO_RAW
case|:
return|return
operator|(
literal|"RAW"
operator|)
return|;
case|case
name|IPPROTO_SCTP
case|:
return|return
operator|(
literal|"SCT"
operator|)
return|;
case|case
name|IPPROTO_DIVERT
case|:
return|return
operator|(
literal|"IPD"
operator|)
return|;
default|default:
return|return
operator|(
literal|"IP?"
operator|)
return|;
block|}
case|case
name|AF_LOCAL
case|:
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SOCK_STREAM
case|:
return|return
operator|(
literal|"UDS"
operator|)
return|;
case|case
name|SOCK_DGRAM
case|:
return|return
operator|(
literal|"UDD"
operator|)
return|;
default|default:
return|return
operator|(
literal|"UD?"
operator|)
return|;
block|}
default|default:
return|return
operator|(
literal|"?"
operator|)
return|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|addr_to_string
parameter_list|(
name|struct
name|sockaddr_storage
modifier|*
name|ss
parameter_list|,
name|char
modifier|*
name|buffer
parameter_list|,
name|int
name|buflen
parameter_list|)
block|{
name|char
name|buffer2
index|[
name|INET6_ADDRSTRLEN
index|]
decl_stmt|;
name|struct
name|sockaddr_in6
modifier|*
name|sin6
decl_stmt|;
name|struct
name|sockaddr_in
modifier|*
name|sin
decl_stmt|;
name|struct
name|sockaddr_un
modifier|*
name|sun
decl_stmt|;
switch|switch
condition|(
name|ss
operator|->
name|ss_family
condition|)
block|{
case|case
name|AF_LOCAL
case|:
name|sun
operator|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
name|ss
expr_stmt|;
if|if
condition|(
name|strlen
argument_list|(
name|sun
operator|->
name|sun_path
argument_list|)
operator|==
literal|0
condition|)
name|strlcpy
argument_list|(
name|buffer
argument_list|,
literal|"-"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|buffer
argument_list|,
name|sun
operator|->
name|sun_path
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET
case|:
name|sin
operator|=
operator|(
expr|struct
name|sockaddr_in
operator|*
operator|)
name|ss
expr_stmt|;
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|buflen
argument_list|,
literal|"%s:%d"
argument_list|,
name|inet_ntoa
argument_list|(
name|sin
operator|->
name|sin_addr
argument_list|)
argument_list|,
name|ntohs
argument_list|(
name|sin
operator|->
name|sin_port
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
name|AF_INET6
case|:
name|sin6
operator|=
operator|(
expr|struct
name|sockaddr_in6
operator|*
operator|)
name|ss
expr_stmt|;
if|if
condition|(
name|inet_ntop
argument_list|(
name|AF_INET6
argument_list|,
operator|&
name|sin6
operator|->
name|sin6_addr
argument_list|,
name|buffer2
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer2
argument_list|)
argument_list|)
operator|!=
name|NULL
condition|)
name|snprintf
argument_list|(
name|buffer
argument_list|,
name|buflen
argument_list|,
literal|"%s.%d"
argument_list|,
name|buffer2
argument_list|,
name|ntohs
argument_list|(
name|sin6
operator|->
name|sin6_port
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|buffer
argument_list|,
literal|"-"
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
break|break;
default|default:
name|strlcpy
argument_list|(
name|buffer
argument_list|,
literal|""
argument_list|,
name|buflen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_struct
specifier|static
struct|struct
name|cap_desc
block|{
name|uint64_t
name|cd_right
decl_stmt|;
specifier|const
name|char
modifier|*
name|cd_desc
decl_stmt|;
block|}
name|cap_desc
index|[]
init|=
block|{
comment|/* General file I/O. */
block|{
name|CAP_READ
block|,
literal|"rd"
block|}
block|,
block|{
name|CAP_WRITE
block|,
literal|"wr"
block|}
block|,
block|{
name|CAP_SEEK
block|,
literal|"se"
block|}
block|,
block|{
name|CAP_MMAP
block|,
literal|"mm"
block|}
block|,
block|{
name|CAP_CREATE
block|,
literal|"cr"
block|}
block|,
block|{
name|CAP_FEXECVE
block|,
literal|"fe"
block|}
block|,
block|{
name|CAP_FSYNC
block|,
literal|"fy"
block|}
block|,
block|{
name|CAP_FTRUNCATE
block|,
literal|"ft"
block|}
block|,
comment|/* VFS methods. */
block|{
name|CAP_FCHDIR
block|,
literal|"cd"
block|}
block|,
block|{
name|CAP_FCHFLAGS
block|,
literal|"cf"
block|}
block|,
block|{
name|CAP_FCHMOD
block|,
literal|"cm"
block|}
block|,
block|{
name|CAP_FCHOWN
block|,
literal|"cn"
block|}
block|,
block|{
name|CAP_FCNTL
block|,
literal|"fc"
block|}
block|,
block|{
name|CAP_FLOCK
block|,
literal|"fl"
block|}
block|,
block|{
name|CAP_FPATHCONF
block|,
literal|"fp"
block|}
block|,
block|{
name|CAP_FSCK
block|,
literal|"fk"
block|}
block|,
block|{
name|CAP_FSTAT
block|,
literal|"fs"
block|}
block|,
block|{
name|CAP_FSTATFS
block|,
literal|"sf"
block|}
block|,
block|{
name|CAP_FUTIMES
block|,
literal|"fu"
block|}
block|,
block|{
name|CAP_LINKAT_SOURCE
block|,
literal|"ls"
block|}
block|,
block|{
name|CAP_LINKAT_TARGET
block|,
literal|"lt"
block|}
block|,
block|{
name|CAP_MKDIRAT
block|,
literal|"md"
block|}
block|,
block|{
name|CAP_MKFIFOAT
block|,
literal|"mf"
block|}
block|,
block|{
name|CAP_MKNODAT
block|,
literal|"mn"
block|}
block|,
block|{
name|CAP_RENAMEAT_SOURCE
block|,
literal|"rs"
block|}
block|,
block|{
name|CAP_RENAMEAT_TARGET
block|,
literal|"rt"
block|}
block|,
block|{
name|CAP_SYMLINKAT
block|,
literal|"sl"
block|}
block|,
block|{
name|CAP_UNLINKAT
block|,
literal|"un"
block|}
block|,
comment|/* Lookups - used to constrain *at() calls. */
block|{
name|CAP_LOOKUP
block|,
literal|"lo"
block|}
block|,
comment|/* Extended attributes. */
block|{
name|CAP_EXTATTR_GET
block|,
literal|"eg"
block|}
block|,
block|{
name|CAP_EXTATTR_SET
block|,
literal|"es"
block|}
block|,
block|{
name|CAP_EXTATTR_DELETE
block|,
literal|"ed"
block|}
block|,
block|{
name|CAP_EXTATTR_LIST
block|,
literal|"el"
block|}
block|,
comment|/* Access Control Lists. */
block|{
name|CAP_ACL_GET
block|,
literal|"ag"
block|}
block|,
block|{
name|CAP_ACL_SET
block|,
literal|"as"
block|}
block|,
block|{
name|CAP_ACL_DELETE
block|,
literal|"ad"
block|}
block|,
block|{
name|CAP_ACL_CHECK
block|,
literal|"ac"
block|}
block|,
comment|/* Socket operations. */
block|{
name|CAP_ACCEPT
block|,
literal|"at"
block|}
block|,
block|{
name|CAP_BIND
block|,
literal|"bd"
block|}
block|,
block|{
name|CAP_CONNECT
block|,
literal|"co"
block|}
block|,
block|{
name|CAP_GETPEERNAME
block|,
literal|"pn"
block|}
block|,
block|{
name|CAP_GETSOCKNAME
block|,
literal|"sn"
block|}
block|,
block|{
name|CAP_GETSOCKOPT
block|,
literal|"gs"
block|}
block|,
block|{
name|CAP_LISTEN
block|,
literal|"ln"
block|}
block|,
block|{
name|CAP_PEELOFF
block|,
literal|"pf"
block|}
block|,
block|{
name|CAP_SETSOCKOPT
block|,
literal|"ss"
block|}
block|,
block|{
name|CAP_SHUTDOWN
block|,
literal|"sh"
block|}
block|,
comment|/* Mandatory Access Control. */
block|{
name|CAP_MAC_GET
block|,
literal|"mg"
block|}
block|,
block|{
name|CAP_MAC_SET
block|,
literal|"ms"
block|}
block|,
comment|/* Methods on semaphores. */
block|{
name|CAP_SEM_GETVALUE
block|,
literal|"sg"
block|}
block|,
block|{
name|CAP_SEM_POST
block|,
literal|"sp"
block|}
block|,
block|{
name|CAP_SEM_WAIT
block|,
literal|"sw"
block|}
block|,
comment|/* Event monitoring and posting. */
block|{
name|CAP_EVENT
block|,
literal|"ev"
block|}
block|,
block|{
name|CAP_KQUEUE_EVENT
block|,
literal|"ke"
block|}
block|,
block|{
name|CAP_KQUEUE_CHANGE
block|,
literal|"kc"
block|}
block|,
comment|/* Strange and powerful rights that should not be given lightly. */
block|{
name|CAP_IOCTL
block|,
literal|"io"
block|}
block|,
block|{
name|CAP_TTYHOOK
block|,
literal|"ty"
block|}
block|,
comment|/* Process management via process descriptors. */
block|{
name|CAP_PDGETPID
block|,
literal|"pg"
block|}
block|,
block|{
name|CAP_PDWAIT
block|,
literal|"pw"
block|}
block|,
block|{
name|CAP_PDKILL
block|,
literal|"pk"
block|}
block|,
comment|/* 	 * Rights that allow to use bindat(2) and connectat(2) syscalls on a 	 * directory descriptor. 	 */
block|{
name|CAP_BINDAT
block|,
literal|"ba"
block|}
block|,
block|{
name|CAP_CONNECTAT
block|,
literal|"ca"
block|}
block|,
comment|/* Aliases and defines that combine multiple rights. */
block|{
name|CAP_PREAD
block|,
literal|"prd"
block|}
block|,
block|{
name|CAP_PWRITE
block|,
literal|"pwr"
block|}
block|,
block|{
name|CAP_MMAP_R
block|,
literal|"mmr"
block|}
block|,
block|{
name|CAP_MMAP_W
block|,
literal|"mmw"
block|}
block|,
block|{
name|CAP_MMAP_X
block|,
literal|"mmx"
block|}
block|,
block|{
name|CAP_MMAP_RW
block|,
literal|"mrw"
block|}
block|,
block|{
name|CAP_MMAP_RX
block|,
literal|"mrx"
block|}
block|,
block|{
name|CAP_MMAP_WX
block|,
literal|"mwx"
block|}
block|,
block|{
name|CAP_MMAP_RWX
block|,
literal|"mma"
block|}
block|,
block|{
name|CAP_RECV
block|,
literal|"re"
block|}
block|,
block|{
name|CAP_SEND
block|,
literal|"sd"
block|}
block|,
block|{
name|CAP_SOCK_CLIENT
block|,
literal|"scl"
block|}
block|,
block|{
name|CAP_SOCK_SERVER
block|,
literal|"ssr"
block|}
block|, }
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|u_int
name|cap_desc_count
init|=
name|nitems
argument_list|(
name|cap_desc
argument_list|)
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|u_int
name|width_capability
parameter_list|(
name|cap_rights_t
modifier|*
name|rightsp
parameter_list|)
block|{
name|u_int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|width
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap_desc_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cap_rights_is_set
argument_list|(
name|rightsp
argument_list|,
name|cap_desc
index|[
name|i
index|]
operator|.
name|cd_right
argument_list|)
condition|)
block|{
name|width
operator|+=
name|strlen
argument_list|(
name|cap_desc
index|[
name|i
index|]
operator|.
name|cd_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|width
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
return|return
operator|(
name|width
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|print_capability
parameter_list|(
name|cap_rights_t
modifier|*
name|rightsp
parameter_list|,
name|u_int
name|capwidth
parameter_list|)
block|{
name|u_int
name|count
decl_stmt|,
name|i
decl_stmt|,
name|width
decl_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
name|width
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
name|width_capability
argument_list|(
name|rightsp
argument_list|)
init|;
name|i
operator|<
name|capwidth
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|!=
literal|0
condition|)
name|xo_emit
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
else|else
name|xo_emit
argument_list|(
literal|"-"
argument_list|)
expr_stmt|;
block|}
name|xo_open_list
argument_list|(
literal|"capabilities"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cap_desc_count
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|cap_rights_is_set
argument_list|(
name|rightsp
argument_list|,
name|cap_desc
index|[
name|i
index|]
operator|.
name|cd_right
argument_list|)
condition|)
block|{
name|xo_emit
argument_list|(
literal|"{D:/%s}{l:capabilities/%s}"
argument_list|,
name|count
condition|?
literal|","
else|:
literal|""
argument_list|,
name|cap_desc
index|[
name|i
index|]
operator|.
name|cd_desc
argument_list|)
expr_stmt|;
name|width
operator|+=
name|strlen
argument_list|(
name|cap_desc
index|[
name|i
index|]
operator|.
name|cd_desc
argument_list|)
expr_stmt|;
if|if
condition|(
name|count
condition|)
name|width
operator|++
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
block|}
name|xo_close_list
argument_list|(
literal|"capabilities"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|procstat_files
parameter_list|(
name|struct
name|procstat
modifier|*
name|procstat
parameter_list|,
name|struct
name|kinfo_proc
modifier|*
name|kipp
parameter_list|)
block|{
name|struct
name|sockstat
name|sock
decl_stmt|;
name|struct
name|filestat_list
modifier|*
name|head
decl_stmt|;
name|struct
name|filestat
modifier|*
name|fst
decl_stmt|;
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|struct
name|vnstat
name|vn
decl_stmt|;
name|u_int
name|capwidth
decl_stmt|,
name|width
decl_stmt|;
name|int
name|error
decl_stmt|;
name|char
name|src_addr
index|[
name|PATH_MAX
index|]
decl_stmt|;
name|char
name|dst_addr
index|[
name|PATH_MAX
index|]
decl_stmt|;
comment|/* 	 * To print the header in capability mode, we need to know the width 	 * of the widest capability string.  Even if we get no processes 	 * back, we will print the header, so we defer aborting due to a lack 	 * of processes until after the header logic. 	 */
name|capwidth
operator|=
literal|0
expr_stmt|;
name|head
operator|=
name|procstat_getfiles
argument_list|(
name|procstat
argument_list|,
name|kipp
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|head
operator|!=
name|NULL
operator|&&
name|Cflag
condition|)
block|{
name|STAILQ_FOREACH
argument_list|(
argument|fst
argument_list|,
argument|head
argument_list|,
argument|next
argument_list|)
block|{
name|width
operator|=
name|width_capability
argument_list|(
operator|&
name|fst
operator|->
name|fs_cap_rights
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|capwidth
condition|)
name|capwidth
operator|=
name|width
expr_stmt|;
block|}
if|if
condition|(
name|capwidth
operator|<
name|strlen
argument_list|(
literal|"CAPABILITIES"
argument_list|)
condition|)
name|capwidth
operator|=
name|strlen
argument_list|(
literal|"CAPABILITIES"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|hflag
condition|)
block|{
if|if
condition|(
name|Cflag
condition|)
name|xo_emit
argument_list|(
literal|"{T:/%5s %-16s %5s %1s %-8s %-*s "
literal|"%-3s %-12s}\n"
argument_list|,
literal|"PID"
argument_list|,
literal|"COMM"
argument_list|,
literal|"FD"
argument_list|,
literal|"T"
argument_list|,
literal|"FLAGS"
argument_list|,
name|capwidth
argument_list|,
literal|"CAPABILITIES"
argument_list|,
literal|"PRO"
argument_list|,
literal|"NAME"
argument_list|)
expr_stmt|;
else|else
name|xo_emit
argument_list|(
literal|"{T:/%5s %-16s %5s %1s %1s %-8s "
literal|"%3s %7s %-3s %-12s}\n"
argument_list|,
literal|"PID"
argument_list|,
literal|"COMM"
argument_list|,
literal|"FD"
argument_list|,
literal|"T"
argument_list|,
literal|"V"
argument_list|,
literal|"FLAGS"
argument_list|,
literal|"REF"
argument_list|,
literal|"OFFSET"
argument_list|,
literal|"PRO"
argument_list|,
literal|"NAME"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|head
operator|==
name|NULL
condition|)
return|return;
name|xo_emit
argument_list|(
literal|"{ek:process_id/%5d/%d}"
argument_list|,
name|kipp
operator|->
name|ki_pid
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{e:command/%-16s/%s}"
argument_list|,
name|kipp
operator|->
name|ki_comm
argument_list|)
expr_stmt|;
name|xo_open_list
argument_list|(
literal|"files"
argument_list|)
expr_stmt|;
name|STAILQ_FOREACH
argument_list|(
argument|fst
argument_list|,
argument|head
argument_list|,
argument|next
argument_list|)
block|{
name|xo_open_instance
argument_list|(
literal|"files"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{dk:process_id/%5d/%d} "
argument_list|,
name|kipp
operator|->
name|ki_pid
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:command/%-16s/%s} "
argument_list|,
name|kipp
operator|->
name|ki_comm
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_uflags
operator|&
name|PS_FST_UFLAG_CTTY
condition|)
name|xo_emit
argument_list|(
literal|"{P: }{:fd/%s} "
argument_list|,
literal|"ctty"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fst
operator|->
name|fs_uflags
operator|&
name|PS_FST_UFLAG_CDIR
condition|)
name|xo_emit
argument_list|(
literal|"{P:  }{:fd/%s} "
argument_list|,
literal|"cwd"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fst
operator|->
name|fs_uflags
operator|&
name|PS_FST_UFLAG_JAIL
condition|)
name|xo_emit
argument_list|(
literal|"{P: }{:fd/%s} "
argument_list|,
literal|"jail"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fst
operator|->
name|fs_uflags
operator|&
name|PS_FST_UFLAG_RDIR
condition|)
name|xo_emit
argument_list|(
literal|"{P: }{:fd/%s} "
argument_list|,
literal|"root"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fst
operator|->
name|fs_uflags
operator|&
name|PS_FST_UFLAG_TEXT
condition|)
name|xo_emit
argument_list|(
literal|"{P: }{:fd/%s} "
argument_list|,
literal|"text"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fst
operator|->
name|fs_uflags
operator|&
name|PS_FST_UFLAG_TRACE
condition|)
name|xo_emit
argument_list|(
literal|"{:fd/%s} "
argument_list|,
literal|"trace"
argument_list|)
expr_stmt|;
else|else
name|xo_emit
argument_list|(
literal|"{:fd/%5d} "
argument_list|,
name|fst
operator|->
name|fs_fd
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|fst
operator|->
name|fs_type
condition|)
block|{
case|case
name|PS_FST_TYPE_VNODE
case|:
name|str
operator|=
literal|"v"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/vnode}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_SOCKET
case|:
name|str
operator|=
literal|"s"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/socket}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_PIPE
case|:
name|str
operator|=
literal|"p"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/pipe}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_FIFO
case|:
name|str
operator|=
literal|"f"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/fifo}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_KQUEUE
case|:
name|str
operator|=
literal|"k"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/kqueue}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_CRYPTO
case|:
name|str
operator|=
literal|"c"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/crypto}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_MQUEUE
case|:
name|str
operator|=
literal|"m"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/mqueue}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_SHM
case|:
name|str
operator|=
literal|"h"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/shm}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_PTS
case|:
name|str
operator|=
literal|"t"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/pts}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_SEM
case|:
name|str
operator|=
literal|"e"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/sem}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_NONE
case|:
name|str
operator|=
literal|"?"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/none}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_TYPE_UNKNOWN
case|:
default|default:
name|str
operator|=
literal|"?"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:fd_type/unknown}"
argument_list|)
expr_stmt|;
break|break;
block|}
name|xo_emit
argument_list|(
literal|"{d:fd_type/%1s/%s} "
argument_list|,
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Cflag
condition|)
block|{
name|str
operator|=
literal|"-"
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_type
operator|==
name|PS_FST_TYPE_VNODE
condition|)
block|{
name|error
operator|=
name|procstat_get_vnode_info
argument_list|(
name|procstat
argument_list|,
name|fst
argument_list|,
operator|&
name|vn
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|vn
operator|.
name|vn_type
condition|)
block|{
case|case
name|PS_FST_VTYPE_VREG
case|:
name|str
operator|=
literal|"r"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/regular}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VDIR
case|:
name|str
operator|=
literal|"d"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/directory}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VBLK
case|:
name|str
operator|=
literal|"b"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/block}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VCHR
case|:
name|str
operator|=
literal|"c"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/character}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VLNK
case|:
name|str
operator|=
literal|"l"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/link}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VSOCK
case|:
name|str
operator|=
literal|"s"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/socket}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VFIFO
case|:
name|str
operator|=
literal|"f"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/fifo}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VBAD
case|:
name|str
operator|=
literal|"x"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/revoked_device}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_VNON
case|:
name|str
operator|=
literal|"?"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/non}"
argument_list|)
expr_stmt|;
break|break;
case|case
name|PS_FST_VTYPE_UNKNOWN
case|:
default|default:
name|str
operator|=
literal|"?"
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{eq:vode_type/unknown}"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
name|xo_emit
argument_list|(
literal|"{d:vnode_type/%1s/%s} "
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_READ
condition|?
literal|"r"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_WRITE
condition|?
literal|"w"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_APPEND
condition|?
literal|"a"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_ASYNC
condition|?
literal|"s"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_SYNC
condition|?
literal|"f"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_NONBLOCK
condition|?
literal|"n"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_DIRECT
condition|?
literal|"d"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{d:/%s}"
argument_list|,
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_HASLOCK
condition|?
literal|"l"
else|:
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
name|xo_open_list
argument_list|(
literal|"fd_flags"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_READ
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/read}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_WRITE
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/write}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_APPEND
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/append}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_ASYNC
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/async}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_SYNC
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/fsync}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_NONBLOCK
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/nonblocking}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_DIRECT
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/direct_io}"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_fflags
operator|&
name|PS_FST_FFLAG_HASLOCK
condition|)
name|xo_emit
argument_list|(
literal|"{elq:fd_flags/lock_held}"
argument_list|)
expr_stmt|;
name|xo_close_list
argument_list|(
literal|"fd_flags"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|Cflag
condition|)
block|{
if|if
condition|(
name|fst
operator|->
name|fs_ref_count
operator|>
operator|-
literal|1
condition|)
name|xo_emit
argument_list|(
literal|"{:ref_count/%3d/%d} "
argument_list|,
name|fst
operator|->
name|fs_ref_count
argument_list|)
expr_stmt|;
else|else
name|xo_emit
argument_list|(
literal|"{q:ref_count/%3c/%c} "
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
if|if
condition|(
name|fst
operator|->
name|fs_offset
operator|>
operator|-
literal|1
condition|)
name|xo_emit
argument_list|(
literal|"{:offset/%7jd/%jd} "
argument_list|,
operator|(
name|intmax_t
operator|)
name|fst
operator|->
name|fs_offset
argument_list|)
expr_stmt|;
else|else
name|xo_emit
argument_list|(
literal|"{q:offset/%7c/%c} "
argument_list|,
literal|'-'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|Cflag
condition|)
block|{
name|print_capability
argument_list|(
operator|&
name|fst
operator|->
name|fs_cap_rights
argument_list|,
name|capwidth
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|" "
argument_list|)
expr_stmt|;
block|}
switch|switch
condition|(
name|fst
operator|->
name|fs_type
condition|)
block|{
case|case
name|PS_FST_TYPE_SOCKET
case|:
name|error
operator|=
name|procstat_get_socket_info
argument_list|(
name|procstat
argument_list|,
name|fst
argument_list|,
operator|&
name|sock
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|error
operator|!=
literal|0
condition|)
break|break;
name|xo_emit
argument_list|(
literal|"{:protocol/%-3s/%s} "
argument_list|,
name|protocol_to_string
argument_list|(
name|sock
operator|.
name|dom_family
argument_list|,
name|sock
operator|.
name|type
argument_list|,
name|sock
operator|.
name|proto
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|sock
operator|.
name|proto
operator|==
name|IPPROTO_TCP
operator|||
name|sock
operator|.
name|proto
operator|==
name|IPPROTO_SCTP
operator|||
name|sock
operator|.
name|type
operator|==
name|SOCK_STREAM
condition|)
block|{
name|xo_emit
argument_list|(
literal|"{:sendq/%u} "
argument_list|,
name|sock
operator|.
name|sendq
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{:recvq/%u} "
argument_list|,
name|sock
operator|.
name|recvq
argument_list|)
expr_stmt|;
block|}
comment|/* 			 * While generally we like to print two addresses, 			 * local and peer, for sockets, it turns out to be 			 * more useful to print the first non-nul address for 			 * local sockets, as typically they aren't bound and 			 *  connected, and the path strings can get long. 			 */
if|if
condition|(
name|sock
operator|.
name|dom_family
operator|==
name|AF_LOCAL
condition|)
block|{
name|struct
name|sockaddr_un
modifier|*
name|sun
init|=
operator|(
expr|struct
name|sockaddr_un
operator|*
operator|)
operator|&
name|sock
operator|.
name|sa_local
decl_stmt|;
if|if
condition|(
name|sun
operator|->
name|sun_path
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
name|addr_to_string
argument_list|(
operator|&
name|sock
operator|.
name|sa_local
argument_list|,
name|src_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|addr_to_string
argument_list|(
operator|&
name|sock
operator|.
name|sa_peer
argument_list|,
name|src_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{:path/%s}"
argument_list|,
name|src_addr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addr_to_string
argument_list|(
operator|&
name|sock
operator|.
name|sa_local
argument_list|,
name|src_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|src_addr
argument_list|)
argument_list|)
expr_stmt|;
name|addr_to_string
argument_list|(
operator|&
name|sock
operator|.
name|sa_peer
argument_list|,
name|dst_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|dst_addr
argument_list|)
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{:path/%s %s}"
argument_list|,
name|src_addr
argument_list|,
name|dst_addr
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|xo_emit
argument_list|(
literal|"{:protocol/%-3s/%s} "
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
name|xo_emit
argument_list|(
literal|"{:path/%-18s/%s}"
argument_list|,
name|fst
operator|->
name|fs_path
operator|!=
name|NULL
condition|?
name|fst
operator|->
name|fs_path
else|:
literal|"-"
argument_list|)
expr_stmt|;
block|}
name|xo_emit
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|xo_close_instance
argument_list|(
literal|"files"
argument_list|)
expr_stmt|;
block|}
name|xo_close_list
argument_list|(
literal|"files"
argument_list|)
expr_stmt|;
name|procstat_freefiles
argument_list|(
name|procstat
argument_list|,
name|head
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

