begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cmds.c */
end_comment

begin_comment
comment|/*  $RCSfile: cmds.c,v $  *  $Revision: 1.1.1.1 $  *  $Date: 1994/09/22 23:45:33 $  */
end_comment

begin_include
include|#
directive|include
file|"sys.h"
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSLOG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"ftp.h"
end_include

begin_include
include|#
directive|include
file|"ftprc.h"
end_include

begin_include
include|#
directive|include
file|"getpass.h"
end_include

begin_include
include|#
directive|include
file|"glob.h"
end_include

begin_include
include|#
directive|include
file|"open.h"
end_include

begin_include
include|#
directive|include
file|"set.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"copyright.h"
end_include

begin_comment
comment|/* cmds.c globals */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASSIVEMODE
end_ifdef

begin_decl_stmt
name|int
name|passivemode
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|curtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file transfer type */
end_comment

begin_decl_stmt
name|char
modifier|*
name|typeabbrs
init|=
literal|"abiet"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|str32
name|curtypename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of file transfer type */
end_comment

begin_decl_stmt
name|int
name|verbose
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* verbosity level of output */
end_comment

begin_decl_stmt
name|int
name|mprompt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* interactively prompt on m* cmds */
end_comment

begin_decl_stmt
name|int
name|debug
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* debugging level */
end_comment

begin_decl_stmt
name|int
name|options
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used during socket creation */
end_comment

begin_decl_stmt
name|int
name|macnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of defined macros */
end_comment

begin_decl_stmt
name|int
name|paging
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|creating
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|macel
name|macros
index|[
name|MAXMACROS
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|macbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* holds ALL macros */
end_comment

begin_decl_stmt
name|int
name|doingInitMacro
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if executing "init" macro. */
end_comment

begin_decl_stmt
name|jmp_buf
name|jabort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|mname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of current m* command */
end_comment

begin_decl_stmt
name|int
name|activemcmd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag: if != 0, then active multi command */
end_comment

begin_decl_stmt
name|int
name|warnNoLSFlagsWithWildcards
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Tells whether the user has been 										 * warned about not being able to use 										 * flags with ls when using wildcards. 										 */
end_comment

begin_decl_stmt
name|longstring
name|cwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current remote directory */
end_comment

begin_decl_stmt
name|longstring
name|lcwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current local directory */
end_comment

begin_decl_stmt
name|Hostname
name|lasthostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of last host w/ lookup(). */
end_comment

begin_decl_stmt
name|int
name|logged_in
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if connected and user/pw OK. */
end_comment

begin_decl_stmt
name|int
name|is_ls
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are we doing an ls?  if so, then 										   read input into a line buffer 										   for re-use. */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|buffer_only
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|lslist
modifier|*
name|lshead
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* hold last output from host */
end_comment

begin_decl_stmt
name|struct
name|lslist
modifier|*
name|lstail
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cmds.c externs */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|globerr
decl_stmt|,
modifier|*
name|home
decl_stmt|,
modifier|*
name|reply_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|margc
decl_stmt|,
name|connected
decl_stmt|,
name|ansi_escapes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|code
decl_stmt|,
name|connected
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|toatty
decl_stmt|,
name|fromatty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|data
decl_stmt|,
name|progress_meter
decl_stmt|,
name|remote_is_unix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|parsing_rc
decl_stmt|,
name|keep_recent
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|altarg
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|margv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|globchars
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Hostname
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|RemoteSiteInfo
name|gRmtInfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|string
name|progname
decl_stmt|,
name|pager
decl_stmt|,
name|anon_password
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|string
name|prompt
decl_stmt|,
name|version
decl_stmt|,
name|indataline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|longstring
name|logfname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|logsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|size_t
name|xferbufsize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|servent
name|serv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd
name|cmdtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|userinfo
name|uinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|cin
decl_stmt|,
modifier|*
name|cout
decl_stmt|,
modifier|*
name|logf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Optarg
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Optarg
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|STRICT_PROTOS
end_ifdef

begin_decl_stmt
specifier|extern
name|int
name|gethostname
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|,
name|getdomainname
argument_list|(
name|char
operator|*
argument_list|,
name|int
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|struct
name|types
name|types
index|[]
init|=
block|{
block|{
literal|"ascii"
block|,
literal|"A"
block|,
name|TYPE_A
block|,
literal|0
block|}
block|,
block|{
literal|"binary"
block|,
literal|"I"
block|,
name|TYPE_I
block|,
literal|0
block|}
block|,
block|{
literal|"image"
block|,
literal|"I"
block|,
name|TYPE_I
block|,
literal|0
block|}
block|,
block|{
literal|"ebcdic"
block|,
literal|"E"
block|,
name|TYPE_E
block|,
literal|0
block|}
block|,
block|{
literal|"tenex"
block|,
literal|"L"
block|,
name|TYPE_L
block|,
literal|"8"
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|long
name|GetDateSizeFromLSLine
parameter_list|(
name|char
modifier|*
name|fName
parameter_list|,
name|unsigned
name|long
modifier|*
name|mod_time
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|np
decl_stmt|;
name|string
name|lsline
decl_stmt|;
name|long
name|size
init|=
name|SIZE_UNKNOWN
decl_stmt|;
name|int
name|n
decl_stmt|,
name|v
decl_stmt|;
name|struct
name|lslist
modifier|*
name|savedh
decl_stmt|,
modifier|*
name|savedt
decl_stmt|;
specifier|static
name|int
name|depth
init|=
literal|0
decl_stmt|;
name|depth
operator|++
expr_stmt|;
comment|/* Try to prevent infinite recursion. */
operator|*
name|mod_time
operator|=
name|MDTM_UNKNOWN
expr_stmt|;
name|v
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
name|is_ls
operator|=
literal|1
expr_stmt|;
name|buffer_only
operator|=
literal|1
expr_stmt|;
name|savedh
operator|=
name|lshead
expr_stmt|;
name|savedt
operator|=
name|lstail
expr_stmt|;
name|lshead
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|recvrequest
argument_list|(
literal|"LIST"
argument_list|,
literal|"-"
argument_list|,
name|fName
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|is_ls
operator|=
literal|0
expr_stmt|;
name|buffer_only
operator|=
literal|0
expr_stmt|;
name|verbose
operator|=
name|v
expr_stmt|;
if|if
condition|(
name|lshead
operator|==
name|NULL
condition|)
block|{
name|PurgeLineBuffer
argument_list|()
expr_stmt|;
name|lshead
operator|=
name|savedh
expr_stmt|;
name|lstail
operator|=
name|savedt
expr_stmt|;
goto|goto
name|aa
goto|;
block|}
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|lsline
argument_list|,
name|lshead
operator|->
name|string
argument_list|)
expr_stmt|;
name|PurgeLineBuffer
argument_list|()
expr_stmt|;
name|lshead
operator|=
name|savedh
expr_stmt|;
name|lstail
operator|=
name|savedt
expr_stmt|;
if|if
condition|(
name|code
operator|>=
literal|400
operator|&&
name|code
operator|<
literal|500
condition|)
goto|goto
name|aa
goto|;
comment|/* See if this line looks like a unix-style ls line.  	 * If so, we can grab the date and size from it. 	 */
if|if
condition|(
name|strpbrk
argument_list|(
name|lsline
argument_list|,
literal|"-dlsbcp"
argument_list|)
operator|==
name|lsline
condition|)
block|{
comment|/* See if it looks like a typical '-rwxrwxrwx' line. */
name|cp
operator|=
name|lsline
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'r'
operator|&&
operator|*
name|cp
operator|!=
literal|'-'
condition|)
goto|goto
name|aa
goto|;
operator|++
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'w'
operator|&&
operator|*
name|cp
operator|!=
literal|'-'
condition|)
goto|goto
name|aa
goto|;
name|cp
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'r'
operator|&&
operator|*
name|cp
operator|!=
literal|'-'
condition|)
goto|goto
name|aa
goto|;
comment|/* skip mode, links, owner (and possibly group) */
for|for
control|(
name|n
operator|=
literal|0
init|;
name|n
operator|<
literal|4
condition|;
name|n
operator|++
control|)
block|{
name|np
operator|=
name|cp
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|++
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
name|cp
operator|=
name|np
expr_stmt|;
comment|/* back up (no group) */
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%ld%n"
argument_list|,
operator|&
name|size
argument_list|,
operator|&
name|n
argument_list|)
expr_stmt|;
operator|*
name|mod_time
operator|=
name|UnLSDate
argument_list|(
name|cp
operator|+
name|n
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<
literal|100
condition|)
block|{
comment|/* May be the size of a link to the file, instead of the file. */
if|if
condition|(
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|lsline
argument_list|,
literal|" -> "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* Yes, it was a link. */
name|size
operator|=
operator|(
name|depth
operator|>
literal|4
operator|)
condition|?
name|SIZE_UNKNOWN
else|:
name|GetDateAndSize
argument_list|(
name|cp
operator|+
literal|4
argument_list|,
name|mod_time
argument_list|)
expr_stmt|;
comment|/* Try the file. */
block|}
block|}
block|}
name|aa
label|:
operator|--
name|depth
expr_stmt|;
return|return
operator|(
name|size
operator|)
return|;
block|}
end_function

begin_comment
comment|/* GetDateSizeFromLSLine */
end_comment

begin_comment
comment|/* The caller wanted to know the modification date and size of the remote  * file given to us.  We try to get this information by using the SIZE  * and MDTM ftp commands, and if that didn't work we try sending the site  * a "ls -l<fName>" and try to get that information from the line it  * sends us back.  It is possible that we won't be able to determine  * either of these, though.  */
end_comment

begin_function
name|long
name|GetDateAndSize
parameter_list|(
name|char
modifier|*
name|fName
parameter_list|,
name|unsigned
name|long
modifier|*
name|mod_time
parameter_list|)
block|{
name|unsigned
name|long
name|mdtm
decl_stmt|,
name|ls_mdtm
decl_stmt|;
name|long
name|size
decl_stmt|,
name|ls_size
decl_stmt|;
name|int
name|have_mdtm
decl_stmt|,
name|have_size
decl_stmt|;
name|string
name|cmd
decl_stmt|;
name|size
operator|=
name|SIZE_UNKNOWN
expr_stmt|;
name|mdtm
operator|=
name|MDTM_UNKNOWN
expr_stmt|;
if|if
condition|(
name|fName
operator|!=
name|NULL
condition|)
block|{
name|have_mdtm
operator|=
name|have_size
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|gRmtInfo
operator|.
name|hasSIZE
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|cmd
argument_list|,
literal|"SIZE "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|cmd
argument_list|,
name|fName
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet_command
argument_list|(
name|cmd
argument_list|)
operator|==
literal|2
condition|)
block|{
if|if
condition|(
name|sscanf
argument_list|(
name|reply_string
argument_list|,
literal|"%*d %ld"
argument_list|,
operator|&
name|size
argument_list|)
operator|==
literal|1
condition|)
name|have_size
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|reply_string
argument_list|,
literal|"550"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
operator|!=
literal|0
condition|)
name|gRmtInfo
operator|.
name|hasSIZE
operator|=
literal|0
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_MKTIME
comment|/* We'll need mktime() to un-mangle this. */
if|if
condition|(
name|gRmtInfo
operator|.
name|hasMDTM
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|cmd
argument_list|,
literal|"MDTM "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|cmd
argument_list|,
name|fName
argument_list|)
expr_stmt|;
if|if
condition|(
name|quiet_command
argument_list|(
name|cmd
argument_list|)
operator|==
literal|2
condition|)
block|{
comment|/* Result should look like "213 19930602204445\n" */
name|mdtm
operator|=
name|UnMDTMDate
argument_list|(
name|reply_string
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdtm
operator|!=
name|MDTM_UNKNOWN
condition|)
name|have_mdtm
operator|=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|reply_string
argument_list|,
literal|"550"
argument_list|,
operator|(
name|size_t
operator|)
literal|3
argument_list|)
operator|!=
literal|0
condition|)
name|gRmtInfo
operator|.
name|hasMDTM
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* NO_MKTIME */
if|if
condition|(
operator|!
name|have_mdtm
operator|||
operator|!
name|have_size
condition|)
name|ls_size
operator|=
name|GetDateSizeFromLSLine
argument_list|(
name|fName
argument_list|,
operator|&
name|ls_mdtm
argument_list|)
expr_stmt|;
comment|/* Try to use the information from the real SIZE/MDTM commands if 		 * we could, since some maverick ftp server may be using a non-standard 		 * ls command, and we could parse it wrong. 		 */
if|if
condition|(
operator|!
name|have_mdtm
condition|)
name|mdtm
operator|=
name|ls_mdtm
expr_stmt|;
if|if
condition|(
operator|!
name|have_size
condition|)
name|size
operator|=
name|ls_size
expr_stmt|;
name|dbprintf
argument_list|(
literal|"Used SIZE: %s;  Used MDTM: %s\n"
argument_list|,
name|have_size
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|,
name|have_mdtm
condition|?
literal|"yes"
else|:
literal|"no"
argument_list|)
expr_stmt|;
if|if
condition|(
name|debug
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|size
operator|!=
name|SIZE_UNKNOWN
condition|)
name|dbprintf
argument_list|(
literal|"Size: %ld\n"
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|mdtm
operator|!=
name|MDTM_UNKNOWN
condition|)
name|dbprintf
argument_list|(
literal|"Mdtm: %s\n"
argument_list|,
name|ctime
argument_list|(
operator|(
name|time_t
operator|*
operator|)
operator|&
name|mdtm
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|mod_time
operator|=
name|mdtm
expr_stmt|;
return|return
name|size
return|;
block|}
end_function

begin_comment
comment|/* GetDateAndSize */
end_comment

begin_function
name|int
name|_settype
parameter_list|(
name|char
modifier|*
name|typename
parameter_list|)
block|{
specifier|register
name|struct
name|types
modifier|*
name|p
decl_stmt|;
name|int
name|comret
decl_stmt|,
name|c
decl_stmt|;
name|string
name|cmd
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|c
operator|=
name|isupper
argument_list|(
operator|*
name|typename
argument_list|)
condition|?
name|tolower
argument_list|(
operator|*
name|typename
argument_list|)
else|:
operator|(
operator|*
name|typename
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|typeabbrs
argument_list|,
name|c
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|p
operator|=
operator|&
name|types
index|[
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|typeabbrs
argument_list|)
index|]
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: unknown type\n"
argument_list|,
name|typename
argument_list|)
expr_stmt|;
return|return
name|USAGE
return|;
block|}
if|if
condition|(
name|c
operator|==
literal|'t'
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cmd
argument_list|,
literal|"TYPE L 8"
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|cmd
argument_list|,
literal|"TYPE %s"
argument_list|,
name|p
operator|->
name|t_mode
argument_list|)
expr_stmt|;
name|comret
operator|=
name|command
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
if|if
condition|(
name|comret
operator|==
name|COMPLETE
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|curtypename
argument_list|,
name|p
operator|->
name|t_name
argument_list|)
expr_stmt|;
name|curtype
operator|=
name|p
operator|->
name|t_type
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* _settype */
end_comment

begin_function
name|int
name|SetTypeByNumber
parameter_list|(
name|int
name|i
parameter_list|)
block|{
name|char
name|tstr
index|[
literal|4
index|]
decl_stmt|,
modifier|*
name|tp
init|=
name|tstr
decl_stmt|,
name|c
decl_stmt|;
name|tp
index|[
literal|1
index|]
operator|=
name|c
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|i
condition|)
block|{
case|case
name|TYPE_A
case|:
name|c
operator|=
literal|'a'
expr_stmt|;
break|break;
case|case
name|TYPE_I
case|:
name|c
operator|=
literal|'b'
expr_stmt|;
break|break;
case|case
name|TYPE_E
case|:
name|c
operator|=
literal|'e'
expr_stmt|;
break|break;
case|case
name|TYPE_L
case|:
name|c
operator|=
literal|'t'
expr_stmt|;
block|}
operator|*
name|tp
operator|=
name|c
expr_stmt|;
return|return
operator|(
name|c
operator|==
literal|0
condition|?
operator|-
literal|1
else|:
name|_settype
argument_list|(
name|tp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* SetTypeByNumber */
end_comment

begin_comment
comment|/*  * Set transfer type.  */
end_comment

begin_function
name|int
name|settype
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|result
init|=
name|NOERR
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|2
condition|)
block|{
name|result
operator|=
name|USAGE
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
goto|goto
name|xx
goto|;
name|result
operator|=
name|_settype
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|IS_VVERBOSE
condition|)
name|xx
label|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Using %s mode to transfer files.\n"
argument_list|,
name|curtypename
argument_list|)
expr_stmt|;
block|}
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* settype */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|setbinary
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|_settype
argument_list|(
literal|"binary"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|setascii
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
return|return
operator|(
name|_settype
argument_list|(
literal|"ascii"
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Send a single file.  */
end_comment

begin_function
name|int
name|put
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|cmd
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|argc
operator|++
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|argv
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(local-file) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
label|:
return|return
name|USAGE
return|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-file) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
goto|goto
name|usage
goto|;
name|cmd
operator|=
operator|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|==
literal|'a'
operator|)
condition|?
literal|"APPE"
else|:
literal|"STOR"
expr_stmt|;
operator|(
name|void
operator|)
name|sendrequest
argument_list|(
name|cmd
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* put */
end_comment

begin_comment
comment|/*  * Send multiple files.  */
end_comment

begin_function
name|int
name|mput
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|Sig_t
name|oldintr
decl_stmt|;
name|char
modifier|*
name|tp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(local-files) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
name|mname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|activemcmd
operator|=
literal|1
expr_stmt|;
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|mabort
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|jabort
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
modifier|*
name|cpp
decl_stmt|,
modifier|*
modifier|*
name|gargs
decl_stmt|;
name|char
modifier|*
name|icopy
decl_stmt|;
comment|/* Make a copy of the argument, because glob() will just copy 		 * the pointer you give it to the glob-arg vector, and blkfree() 		 * will want to free each element of the glob-arg vector 		 * later. 		 */
if|if
condition|(
operator|(
name|icopy
operator|=
name|NewString
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
name|gargs
operator|=
name|glob
argument_list|(
name|icopy
argument_list|)
expr_stmt|;
if|if
condition|(
name|globerr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|globerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|gargs
condition|)
block|{
name|blkfree
argument_list|(
name|gargs
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|gargs
argument_list|)
expr_stmt|;
block|}
continue|continue;
block|}
for|for
control|(
name|cpp
operator|=
name|gargs
init|;
name|cpp
operator|&&
operator|*
name|cpp
operator|!=
name|NULL
condition|;
name|cpp
operator|++
control|)
block|{
if|if
condition|(
name|activemcmd
operator|&&
name|confirm
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
operator|*
name|cpp
argument_list|)
condition|)
block|{
name|tp
operator|=
operator|*
name|cpp
expr_stmt|;
operator|(
name|void
operator|)
name|sendrequest
argument_list|(
literal|"STOR"
argument_list|,
operator|*
name|cpp
argument_list|,
name|tp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|activemcmd
operator|&&
name|fromatty
condition|)
block|{
if|if
condition|(
name|confirm
argument_list|(
literal|"Continue with"
argument_list|,
literal|"mput"
argument_list|)
condition|)
block|{
name|activemcmd
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
if|if
condition|(
name|gargs
operator|!=
name|NULL
condition|)
block|{
name|blkfree
argument_list|(
name|gargs
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|gargs
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
name|activemcmd
operator|=
literal|0
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* mput */
end_comment

begin_function
name|int
name|rem_glob_one
parameter_list|(
name|char
modifier|*
name|pattern
parameter_list|)
block|{
name|int
name|oldverbose
decl_stmt|,
name|result
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|string
name|str
decl_stmt|,
name|tname
decl_stmt|;
name|FILE
modifier|*
name|ftemp
decl_stmt|;
comment|/* Check for wildcard characters. */
if|if
condition|(
operator|*
name|pattern
operator|==
literal|'|'
operator|||
name|strpbrk
argument_list|(
name|pattern
argument_list|,
name|globchars
argument_list|)
operator|==
name|NULL
condition|)
return|return
literal|0
return|;
operator|(
name|void
operator|)
name|tmp_name
argument_list|(
name|tname
argument_list|)
expr_stmt|;
name|oldverbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
operator|(
name|void
operator|)
name|recvrequest
argument_list|(
literal|"NLST"
argument_list|,
name|tname
argument_list|,
name|pattern
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|oldverbose
expr_stmt|;
name|ftemp
operator|=
name|fopen
argument_list|(
name|tname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftemp
operator|==
name|NULL
operator|||
name|FGets
argument_list|(
name|str
argument_list|,
name|ftemp
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|NOT_VQUIET
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: no match.\n"
argument_list|,
name|pattern
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|done
goto|;
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|pattern
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|cp
operator|=
name|FGets
argument_list|(
name|str
argument_list|,
name|ftemp
argument_list|)
expr_stmt|;
comment|/* It is an error if the pattern matched more than one file. */
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|NOT_VQUIET
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"?Ambiguous remote file name.\n"
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|2
expr_stmt|;
block|}
name|done
label|:
if|if
condition|(
name|ftemp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ftemp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tname
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* rem_glob_one */
end_comment

begin_comment
comment|/*  * Receive (and maybe page) one file.  */
end_comment

begin_function
name|int
name|get
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|local_file
decl_stmt|;
name|char
name|remote_file
index|[
literal|256
index|]
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|oldtype
init|=
name|curtype
decl_stmt|,
name|try_zcat
decl_stmt|;
name|size_t
name|len
decl_stmt|;
comment|/* paging mode is set if the command name is 'page' or 'more.' */
name|paging
operator|=
operator|(
operator|*
operator|*
name|argv
operator|!=
literal|'g'
operator|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-file) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
name|cp
operator|=
name|Strncpy
argument_list|(
name|remote_file
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argv
index|[
literal|1
index|]
operator|=
name|cp
expr_stmt|;
if|if
condition|(
name|rem_glob_one
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
name|CMDERR
return|;
if|if
condition|(
name|paging
condition|)
block|{
name|try_zcat
operator|=
literal|0
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|remote_file
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
operator|(
name|size_t
operator|)
literal|2
condition|)
block|{
if|if
condition|(
name|remote_file
index|[
name|len
operator|-
literal|2
index|]
operator|==
literal|'.'
condition|)
block|{
comment|/* Check for .Z files. */
if|if
condition|(
name|remote_file
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'Z'
condition|)
name|try_zcat
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|GZCAT
comment|/* Check for .z (gzip) files. */
if|if
condition|(
name|remote_file
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'z'
condition|)
name|try_zcat
operator|=
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* GZCAT */
block|}
block|}
ifdef|#
directive|ifdef
name|GZCAT
if|if
condition|(
name|len
operator|>
operator|(
name|size_t
operator|)
literal|3
condition|)
block|{
comment|/* Check for ".gz" (gzip) files. */
if|if
condition|(
name|strcmp
argument_list|(
name|remote_file
operator|+
name|len
operator|-
literal|3
argument_list|,
literal|".gz"
argument_list|)
operator|==
literal|0
condition|)
name|try_zcat
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* GZCAT */
comment|/* Run compressed remote files through zcat, then the pager. 		 * If GZCAT was defined, we also try paging gzipped files. 		 * Note that ZCAT is defined to be GZCAT if you defined 		 * GZCAT. 		 */
if|if
condition|(
name|try_zcat
condition|)
block|{
operator|(
name|void
operator|)
name|_settype
argument_list|(
literal|"b"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|local_file
argument_list|,
literal|"|%s "
argument_list|,
name|ZCAT
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|Strncat
argument_list|(
name|local_file
argument_list|,
name|pager
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Try to use text mode for paging, so newlines get converted. */
operator|(
name|void
operator|)
name|_settype
argument_list|(
literal|"a"
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|pager
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* normal get */
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|local_file
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|argv
index|[
literal|2
index|]
operator|=
name|local_file
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(local-file) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
return|return
name|USAGE
return|;
operator|(
name|void
operator|)
name|LocalDotPath
argument_list|(
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|recvrequest
argument_list|(
literal|"RETR"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|paging
condition|)
block|{
operator|(
name|void
operator|)
name|SetTypeByNumber
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
comment|/* Restore it to what it was. */
name|paging
operator|=
literal|0
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* get */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|void
name|mabort
name|SIG_PARAMS
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|activemcmd
operator|&&
name|fromatty
condition|)
block|{
if|if
condition|(
name|confirm
argument_list|(
literal|"Continue with"
argument_list|,
name|mname
argument_list|)
condition|)
block|{
name|longjmp
argument_list|(
name|jabort
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
name|activemcmd
operator|=
literal|0
expr_stmt|;
name|longjmp
argument_list|(
name|jabort
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* mabort */
end_comment

begin_comment
comment|/*  * Get multiple files.  */
end_comment

begin_function
name|int
name|mget
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|longstring
name|local
decl_stmt|;
name|Sig_t
name|oldintr
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-files) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
name|mname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|activemcmd
operator|=
literal|1
expr_stmt|;
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|mabort
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|jabort
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|remglob
argument_list|(
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|activemcmd
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|activemcmd
operator|&&
name|confirm
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|cp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|local
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|recvrequest
argument_list|(
literal|"RETR"
argument_list|,
name|local
argument_list|,
name|cp
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|activemcmd
operator|&&
name|fromatty
condition|)
block|{
if|if
condition|(
name|confirm
argument_list|(
literal|"Continue with"
argument_list|,
literal|"mget"
argument_list|)
condition|)
block|{
name|activemcmd
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
name|activemcmd
operator|=
literal|0
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* mget */
end_comment

begin_function
name|char
modifier|*
name|remglob
parameter_list|(
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
specifier|static
name|FILE
modifier|*
name|ftemp
init|=
name|NULL
decl_stmt|;
name|int
name|oldverbose
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|mode
decl_stmt|;
specifier|static
name|string
name|tmpname
decl_stmt|,
name|str
decl_stmt|;
name|int
name|result
decl_stmt|,
name|errs
decl_stmt|;
if|if
condition|(
operator|!
name|activemcmd
condition|)
block|{
name|xx
label|:
if|if
condition|(
name|ftemp
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ftemp
argument_list|)
expr_stmt|;
name|ftemp
operator|=
name|NULL
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
if|if
condition|(
name|ftemp
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|tmp_name
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
name|oldverbose
operator|=
name|verbose
operator|,
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
name|errs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|mode
operator|=
literal|"w"
operator|,
name|i
operator|=
literal|1
init|;
name|argv
index|[
name|i
index|]
operator|!=
name|NULL
condition|;
name|i
operator|++
operator|,
name|mode
operator|=
literal|"a"
control|)
block|{
name|result
operator|=
name|recvrequest
argument_list|(
literal|"NLST"
argument_list|,
name|tmpname
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|chmod
argument_list|(
name|tmpname
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s.\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
operator|(
name|strpbrk
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|globchars
argument_list|)
operator|!=
name|NULL
operator|)
condition|?
literal|"No match"
else|:
literal|"No such file"
argument_list|)
expr_stmt|;
name|errs
operator|++
expr_stmt|;
block|}
block|}
name|verbose
operator|=
name|oldverbose
expr_stmt|;
if|if
condition|(
name|errs
operator|==
operator|(
name|i
operator|-
literal|1
operator|)
condition|)
block|{
comment|/* Every pattern was in error, so we can't try anything. */
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
comment|/* Shouldn't be there anyway. */
return|return
name|NULL
return|;
block|}
name|ftemp
operator|=
name|fopen
argument_list|(
name|tmpname
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ftemp
operator|==
name|NULL
condition|)
block|{
name|PERROR
argument_list|(
literal|"remglob"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
block|}
if|if
condition|(
name|FGets
argument_list|(
name|str
argument_list|,
name|ftemp
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|xx
goto|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|str
argument_list|,
literal|'\n'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|str
operator|)
return|;
block|}
end_function

begin_comment
comment|/* remglob */
end_comment

begin_comment
comment|/*  * Turn on/off printing of server echo's, messages, and statistics.  */
end_comment

begin_function
name|int
name|setverbose
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|set_verbose
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|0
argument_list|)
expr_stmt|;
else|else
name|set_verbose
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
operator|-
literal|1
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* setverbose */
end_comment

begin_comment
comment|/*  * Toggle interactive prompting  * during mget, mput, and mdelete.  */
end_comment

begin_function
name|int
name|setprompt
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|mprompt
operator|=
name|StrToBool
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
else|else
name|mprompt
operator|=
operator|!
name|mprompt
expr_stmt|;
if|if
condition|(
name|IS_VVERBOSE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Interactive prompting for m* commmands %s.\n"
argument_list|,
name|onoff
argument_list|(
name|mprompt
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* setprompt */
end_comment

begin_function
name|void
name|fix_options
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|debug
condition|)
name|options
operator||=
name|SO_DEBUG
expr_stmt|;
else|else
name|options
operator|&=
operator|~
name|SO_DEBUG
expr_stmt|;
block|}
end_function

begin_comment
comment|/* fix_options */
end_comment

begin_comment
comment|/*  * Set debugging mode on/off and/or  * set level of debugging.  */
end_comment

begin_function
name|int
name|setdebug
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|val
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|val
operator|=
name|StrToBool
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: bad debugging value.\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|USAGE
return|;
block|}
block|}
else|else
name|val
operator|=
operator|!
name|debug
expr_stmt|;
name|debug
operator|=
name|val
expr_stmt|;
name|fix_options
argument_list|()
expr_stmt|;
if|if
condition|(
name|IS_VVERBOSE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Debugging %s (debug=%d).\n"
argument_list|,
name|onoff
argument_list|(
name|debug
argument_list|)
argument_list|,
name|debug
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* debug */
end_comment

begin_comment
comment|/*  * Set current working directory  * on remote machine.  */
end_comment

begin_function
name|int
name|cd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-directory) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
operator|(
name|void
operator|)
name|_cd
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* cd */
end_comment

begin_function
name|int
name|implicit_cd
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|connected
condition|)
block|{
name|i
operator|=
name|verbose
expr_stmt|;
comment|/* Special verbosity level that ignores errors and prints other stuff, 		 * so you will get just the unknown command message and not an error 		 * message from cd. 		 */
name|verbose
operator|=
name|V_IMPLICITCD
expr_stmt|;
name|j
operator|=
name|_cd
argument_list|(
name|dir
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|i
expr_stmt|;
block|}
return|return
name|j
return|;
block|}
end_function

begin_comment
comment|/* implicit_cd */
end_comment

begin_function
name|int
name|_cd
parameter_list|(
name|char
modifier|*
name|dir
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|result
init|=
literal|0
decl_stmt|;
name|string
name|str
decl_stmt|;
if|if
condition|(
name|dir
operator|==
name|NULL
condition|)
goto|goto
name|getrwd
goto|;
comment|/* Won't work because glob really is a ls, so 'cd pu*' will match 	 * pub/README, pub/file2, etc. 	 *	if (result = rem_glob_one(dir)< 0) 	 *	return result; 	 */
if|if
condition|(
name|strncmp
argument_list|(
name|dir
argument_list|,
literal|"CDUP"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"CWD %s"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|str
argument_list|)
operator|!=
literal|5
condition|)
block|{
name|getrwd
label|:
operator|(
name|void
operator|)
name|quiet_command
argument_list|(
literal|"PWD"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|rindex
argument_list|(
name|reply_string
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
block|{
name|result
operator|=
literal|1
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|cp
operator|=
name|index
argument_list|(
name|reply_string
argument_list|,
literal|'\"'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|cwd
argument_list|,
operator|++
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
name|dbprintf
argument_list|(
literal|"Current remote directory is \"%s\"\n"
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* _cd */
end_comment

begin_comment
comment|/*  * Set current working directory  * on local machine.  */
end_comment

begin_function
name|int
name|lcd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|longstring
name|ldir
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argc
operator|++
operator|,
name|argv
index|[
literal|1
index|]
operator|=
name|home
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|ldir
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|chdir
argument_list|(
name|LocalDotPath
argument_list|(
name|ldir
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"lcd"
argument_list|,
name|ldir
argument_list|)
expr_stmt|;
return|return
name|CMDERR
return|;
block|}
operator|(
name|void
operator|)
name|get_cwd
argument_list|(
name|lcwd
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|lcwd
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOT_VQUIET
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Local directory now %s\n"
argument_list|,
name|lcwd
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* lcd */
end_comment

begin_comment
comment|/*  * Delete a single file.  */
end_comment

begin_function
name|int
name|do_delete
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote file to delete) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
if|if
condition|(
name|rem_glob_one
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"DELE %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* do_delete */
end_comment

begin_comment
comment|/*  * Delete multiple files.  */
end_comment

begin_function
name|int
name|mdelete
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
name|Sig_t
name|oldintr
decl_stmt|;
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-files) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
name|mname
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
name|activemcmd
operator|=
literal|1
expr_stmt|;
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|mabort
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|setjmp
argument_list|(
name|jabort
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|cp
operator|=
name|remglob
argument_list|(
name|argv
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|activemcmd
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|activemcmd
operator|&&
name|confirm
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
name|cp
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"DELE %s"
argument_list|,
name|cp
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|activemcmd
operator|&&
name|fromatty
condition|)
block|{
if|if
condition|(
name|confirm
argument_list|(
literal|"Continue with"
argument_list|,
literal|"mdelete"
argument_list|)
condition|)
block|{
name|activemcmd
operator|++
expr_stmt|;
block|}
block|}
block|}
block|}
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
name|activemcmd
operator|=
literal|0
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* mdelete */
end_comment

begin_comment
comment|/*  * Rename a remote file.  */
end_comment

begin_function
name|int
name|renamefile
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(from-name) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
label|:
return|return
name|USAGE
return|;
block|}
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(to-name) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
goto|goto
name|usage
goto|;
if|if
condition|(
name|rem_glob_one
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|<
literal|0
condition|)
return|return
name|CMDERR
return|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"RNFR %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|str
argument_list|)
operator|==
name|CONTINUE
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"RNTO %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* renamefile */
end_comment

begin_comment
comment|/*  * Get a directory listing  * of remote files.  */
end_comment

begin_function
name|int
name|ls
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|whichcmd
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|str32
name|lsflags
decl_stmt|;
name|string
name|remote
decl_stmt|,
name|local
decl_stmt|,
name|str
decl_stmt|;
name|int
name|listmode
decl_stmt|,
name|pagemode
decl_stmt|,
name|i
decl_stmt|;
name|PurgeLineBuffer
argument_list|()
expr_stmt|;
name|pagemode
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
operator|*
operator|*
name|argv
condition|)
block|{
case|case
literal|'p'
case|:
comment|/* pls, pdir, pnlist */
name|pagemode
operator|=
literal|1
expr_stmt|;
name|listmode
operator|=
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'d'
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* dir */
name|listmode
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
comment|/* ls, nlist */
name|listmode
operator|=
literal|0
expr_stmt|;
block|}
name|whichcmd
operator|=
name|listmode
condition|?
literal|"LIST"
else|:
literal|"NLST"
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|local
argument_list|,
operator|(
name|pagemode
condition|?
name|pager
else|:
literal|"-"
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|local
argument_list|)
argument_list|)
expr_stmt|;
name|remote
index|[
literal|0
index|]
operator|=
name|lsflags
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Possible scenarios: 	 *  1.	ls 	 *  2.	ls -flags 	 *  3.	ls directory 	 *  4.  ls -flags>outfile 	 *  5.  ls directory>outfile      *  6.  ls -flags directory 	 *  7.  ls -flags directory>outfile 	 * 	 * Note that using a wildcard will choke with flags.  I.e., don't do 	 * "ls -CF *.tar," but instead do "ls *.tar." 	 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'-'
case|:
comment|/* 				 * If you give more than one set of flags, concat the each 				 * additional set to the first one (without the dash). 				 */
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|lsflags
argument_list|,
operator|(
name|argv
index|[
name|i
index|]
operator|+
operator|(
name|lsflags
index|[
literal|0
index|]
operator|==
literal|'-'
operator|)
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|lsflags
argument_list|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|local
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|LocalDotPath
argument_list|(
name|local
operator|+
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
comment|/* We don't want the '>'. */
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|local
argument_list|,
name|argv
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|LocalDotPath
argument_list|(
name|local
argument_list|)
expr_stmt|;
break|break;
default|default:
name|cp
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* 				 * In case you want to get a remote file called '--README--' 				 * or '>README,' you can use '\--README--' and '\>README.' 				 */
if|if
condition|(
operator|(
name|cp
index|[
literal|1
index|]
operator|!=
literal|0
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|==
literal|'\\'
operator|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
name|remote
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|remote
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|remote
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|remote
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end switch */
block|}
comment|/* end loop */
comment|/* 	 *	If we are given an ls with some flags, make sure we use  	 *	columnized output (-C) unless one column output (-1) is 	 *	specified. 	 */
if|if
condition|(
operator|!
name|listmode
condition|)
block|{
if|if
condition|(
name|lsflags
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
name|lsflags
argument_list|)
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|str
operator|+
literal|1
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'1'
condition|)
goto|goto
name|aa
goto|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|lsflags
argument_list|,
literal|"-FC%s"
argument_list|,
name|str
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|remote_is_unix
condition|)
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|lsflags
argument_list|,
literal|"-FC"
argument_list|)
expr_stmt|;
block|}
comment|/* As noted above, we can't use -flags if the user gave a 		 * wildcard expr. 		 */
if|if
condition|(
name|remote_is_unix
operator|&&
operator|(
name|strpbrk
argument_list|(
name|remote
argument_list|,
name|globchars
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|lsflags
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Warn the user what's going on. */
if|if
condition|(
operator|(
name|warnNoLSFlagsWithWildcards
operator|==
literal|0
operator|)
operator|&&
name|NOT_VQUIET
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Warning: ls flags disabled with wildcard expressions.\n"
argument_list|)
expr_stmt|;
name|warnNoLSFlagsWithWildcards
operator|++
expr_stmt|;
block|}
block|}
block|}
name|aa
label|:
name|is_ls
operator|=
literal|1
expr_stmt|;
comment|/* tells getreply() to start saving input to a buffer. */
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|lsflags
index|[
literal|0
index|]
operator|&&
name|remote
index|[
literal|0
index|]
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|remote
argument_list|,
literal|"%s%c%s"
argument_list|,
name|lsflags
argument_list|,
name|LS_FLAGS_AND_FILE
argument_list|,
name|str
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|remote
argument_list|,
name|lsflags
index|[
literal|0
index|]
condition|?
name|lsflags
else|:
name|str
argument_list|,
sizeof|sizeof
argument_list|(
name|remote
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|recvrequest
argument_list|(
name|whichcmd
argument_list|,
name|local
argument_list|,
operator|(
name|remote
index|[
literal|0
index|]
operator|==
literal|0
condition|?
name|NULL
else|:
name|remote
operator|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
name|is_ls
operator|=
literal|0
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* ls */
end_comment

begin_comment
comment|/*  * Do a shell escape  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|shell
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|pid
decl_stmt|;
name|Sig_t
name|old1
decl_stmt|,
name|old2
decl_stmt|;
name|char
modifier|*
name|theShell
decl_stmt|,
modifier|*
name|namep
decl_stmt|;
ifndef|#
directive|ifndef
name|U_WAIT
name|int
name|Status
decl_stmt|;
else|#
directive|else
name|union
name|wait
name|Status
decl_stmt|;
endif|#
directive|endif
name|string
name|str
decl_stmt|;
name|old1
operator|=
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|old2
operator|=
name|signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* This will prevent<defunct> zombie processes. */
comment|/* (void) signal(SIGCHLD, SIG_IGN); */
if|if
condition|(
operator|(
name|pid
operator|=
name|fork
argument_list|()
operator|)
operator|==
literal|0
condition|)
block|{
for|for
control|(
name|pid
operator|=
literal|3
init|;
name|pid
operator|<
literal|20
condition|;
name|pid
operator|++
control|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|pid
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGQUIT
argument_list|,
name|SIG_DFL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|theShell
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|theShell
operator|=
name|uinfo
operator|.
name|shell
expr_stmt|;
if|if
condition|(
name|theShell
operator|==
name|NULL
condition|)
name|theShell
operator|=
literal|"/bin/sh"
expr_stmt|;
name|namep
operator|=
name|rindex
argument_list|(
name|theShell
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|namep
operator|==
name|NULL
condition|)
name|namep
operator|=
name|theShell
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|str
argument_list|,
literal|"-"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|str
argument_list|,
operator|++
name|namep
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|namep
argument_list|,
literal|"sh"
argument_list|)
operator|!=
literal|0
condition|)
name|str
index|[
literal|0
index|]
operator|=
literal|'+'
expr_stmt|;
name|dbprintf
argument_list|(
literal|"%s\n"
argument_list|,
name|theShell
argument_list|)
expr_stmt|;
if|#
directive|if
name|defined
argument_list|(
name|BSD
argument_list|)
operator|||
name|defined
argument_list|(
name|_POSIX_SOURCE
argument_list|)
name|setreuid
argument_list|(
operator|-
literal|1
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
operator|-
literal|1
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
operator|(
name|void
operator|)
name|execl
argument_list|(
name|theShell
argument_list|,
name|str
argument_list|,
literal|"-c"
argument_list|,
name|altarg
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|execl
argument_list|(
name|theShell
argument_list|,
name|str
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
literal|"shell"
argument_list|,
name|theShell
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pid
operator|>
literal|0
condition|)
while|while
condition|(
name|wait
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|Status
argument_list|)
operator|!=
name|pid
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|old1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGQUIT
argument_list|,
name|old2
argument_list|)
expr_stmt|;
if|if
condition|(
name|pid
operator|==
operator|-
literal|1
condition|)
block|{
name|PERROR
argument_list|(
literal|"shell"
argument_list|,
literal|"Try again later"
argument_list|)
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* shell */
end_comment

begin_comment
comment|/*  * Send new user information (re-login)  */
end_comment

begin_function
name|int
name|do_user
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
name|acct
index|[
literal|80
index|]
decl_stmt|;
name|int
name|n
decl_stmt|,
name|aflag
init|=
literal|0
decl_stmt|;
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(username) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|4
condition|)
block|{
return|return
name|USAGE
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"USER %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|CONTINUE
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|3
condition|)
name|argv
index|[
literal|2
index|]
operator|=
name|Getpass
argument_list|(
literal|"Password: "
argument_list|)
operator|,
name|argc
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"PASS %s"
argument_list|,
name|argv
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
name|CONTINUE
condition|)
block|{
if|if
condition|(
name|argc
operator|<
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Account: "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|FGets
argument_list|(
name|acct
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
name|acct
index|[
name|strlen
argument_list|(
name|acct
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|argv
index|[
literal|3
index|]
operator|=
name|acct
expr_stmt|;
name|argc
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"ACCT %s"
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|aflag
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|!=
name|COMPLETE
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"Login failed.\n"
argument_list|)
expr_stmt|;
name|logged_in
operator|=
literal|0
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
operator|!
name|aflag
operator|&&
name|argc
operator|==
literal|4
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"ACCT %s"
argument_list|,
name|argv
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|logged_in
operator|=
literal|1
expr_stmt|;
name|CheckRemoteSystemType
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* do_user */
end_comment

begin_comment
comment|/*  * Print working directory.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|pwd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
operator|(
name|void
operator|)
name|verbose_command
argument_list|(
literal|"PWD"
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* pwd */
end_comment

begin_comment
comment|/*  * Make a directory.  */
end_comment

begin_function
name|int
name|makedir
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(directory-name) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"MKD %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* makedir */
end_comment

begin_comment
comment|/*  * Remove a directory.  */
end_comment

begin_function
name|int
name|removedir
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(directory-name) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
if|if
condition|(
name|rem_glob_one
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"RMD %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* removedir */
end_comment

begin_comment
comment|/*  * Send a line, verbatim, to the remote machine.  */
end_comment

begin_function
name|int
name|quote
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|tmpverbose
decl_stmt|;
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(command line to send) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
name|str
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|argv
index|[
literal|0
index|]
operator|==
literal|'s'
condition|)
comment|/* Command was 'site' instead of 'quote.' */
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
literal|"site "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|str
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|str
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|str
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|tmpverbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|V_VERBOSE
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|str
argument_list|)
operator|==
name|PRELIM
condition|)
block|{
while|while
condition|(
name|getreply
argument_list|(
literal|0
argument_list|)
operator|==
name|PRELIM
condition|)
empty_stmt|;
block|}
name|verbose
operator|=
name|tmpverbose
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* quote */
end_comment

begin_comment
comment|/*  * Ask the other side for help.  */
end_comment

begin_function
name|int
name|rmthelp
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
condition|)
operator|(
name|void
operator|)
name|verbose_command
argument_list|(
literal|"HELP"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"HELP %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|verbose_command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* rmthelp */
end_comment

begin_comment
comment|/*  * Terminate session and exit.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|quit
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|close_up_shop
argument_list|()
expr_stmt|;
name|trim_log
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* quit */
end_comment

begin_function
name|void
name|close_streams
parameter_list|(
name|int
name|wantShutDown
parameter_list|)
block|{
if|if
condition|(
name|cout
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wantShutDown
condition|)
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|fileno
argument_list|(
name|cout
argument_list|)
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cout
argument_list|)
expr_stmt|;
name|cout
operator|=
name|NULL
expr_stmt|;
block|}
if|if
condition|(
name|cin
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|wantShutDown
condition|)
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|fileno
argument_list|(
name|cin
argument_list|)
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cin
argument_list|)
expr_stmt|;
name|cin
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* close_streams */
end_comment

begin_comment
comment|/*  * Terminate session, but don't exit.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|disconnect
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
ifdef|#
directive|ifdef
name|SYSLOG
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s disconnected from %s."
argument_list|,
name|uinfo
operator|.
name|username
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|command
argument_list|(
literal|"QUIT"
argument_list|)
expr_stmt|;
name|close_streams
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|logged_in
condition|)
name|UpdateRecentSitesList
argument_list|(
name|hostname
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|hostname
index|[
literal|0
index|]
operator|=
name|cwd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|logged_in
operator|=
name|connected
operator|=
literal|0
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
name|macnum
operator|=
literal|0
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* disconnect */
end_comment

begin_function
name|void
name|close_up_shop
parameter_list|(
name|void
parameter_list|)
block|{
specifier|static
name|int
name|only_once
init|=
literal|0
decl_stmt|;
if|if
condition|(
name|only_once
operator|++
operator|>
literal|0
condition|)
return|return;
if|if
condition|(
name|connected
condition|)
operator|(
name|void
operator|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|WriteRecentSitesFile
argument_list|()
expr_stmt|;
if|if
condition|(
name|logf
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|logf
argument_list|)
expr_stmt|;
name|logf
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* close_up_shop */
end_comment

begin_comment
comment|/*  * Glob a local file name specification with  * the expectation of a single return value.  * Can't control multiple values being expanded  * from the expression, we return only the first.  */
end_comment

begin_function
name|int
name|globulize
parameter_list|(
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|globbed
decl_stmt|;
operator|(
name|void
operator|)
name|LocalPath
argument_list|(
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|globbed
operator|=
name|glob
argument_list|(
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
name|globerr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: %s\n"
argument_list|,
operator|*
name|cpp
argument_list|,
name|globerr
argument_list|)
expr_stmt|;
if|if
condition|(
name|globbed
condition|)
block|{
name|blkfree
argument_list|(
name|globbed
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|globbed
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|globbed
condition|)
block|{
operator|*
name|cpp
operator|=
operator|*
name|globbed
operator|++
expr_stmt|;
comment|/* don't waste too much memory */
if|if
condition|(
operator|*
name|globbed
condition|)
block|{
name|blkfree
argument_list|(
name|globbed
argument_list|)
expr_stmt|;
name|Free
argument_list|(
name|globbed
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* globulize */
end_comment

begin_comment
comment|/* change directory to perent directory */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|cdup
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
operator|(
name|void
operator|)
name|_cd
argument_list|(
literal|"CDUP"
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* cdup */
end_comment

begin_comment
comment|/* show remote system type */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|syst
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
operator|(
name|void
operator|)
name|verbose_command
argument_list|(
literal|"SYST"
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* syst */
end_comment

begin_function
name|int
name|make_macro
parameter_list|(
name|char
modifier|*
name|name
parameter_list|,
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|string
name|str
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|macnum
operator|==
name|MAXMACROS
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Limit of %d macros have already been defined.\n"
argument_list|,
name|MAXMACROS
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* Make sure macros have unique names.  If 'init' was attempted to be 	 * redefined, just return, since it was probably cmdOpen() in a redial 	 * mode which tried to define it again. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macnum
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|name
argument_list|,
name|macros
index|[
name|i
index|]
operator|.
name|mac_name
argument_list|,
operator|(
name|size_t
operator|)
literal|8
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|parsing_rc
condition|)
block|{
comment|/* Just shut up and read in the macro, but don't save it, 				 * because we already have it. 				 */
while|while
condition|(
operator|(
name|cp
operator|=
name|FGets
argument_list|(
name|str
argument_list|,
name|fp
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
comment|/* See if we have a 'blank' line: just whitespace. */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cp
condition|)
break|break;
block|}
block|}
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"There is already a macro named '%s.'\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|macros
index|[
name|macnum
index|]
operator|.
name|mac_name
argument_list|,
name|name
argument_list|,
operator|(
name|size_t
operator|)
literal|8
argument_list|)
expr_stmt|;
if|if
condition|(
name|macnum
operator|==
literal|0
condition|)
name|macros
index|[
name|macnum
index|]
operator|.
name|mac_start
operator|=
name|macbuf
expr_stmt|;
else|else
name|macros
index|[
name|macnum
index|]
operator|.
name|mac_start
operator|=
name|macros
index|[
name|macnum
operator|-
literal|1
index|]
operator|.
name|mac_end
operator|+
literal|1
expr_stmt|;
name|tmp
operator|=
name|macros
index|[
name|macnum
index|]
operator|.
name|mac_start
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|cp
operator|=
name|FGets
argument_list|(
name|str
argument_list|,
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
comment|/* 			 * If we had started a macro, we will say it is 			 * okay to skip the blank line delimiter if we 			 * are at the EOF. 			 */
if|if
condition|(
name|tmp
operator|>
name|macros
index|[
name|macnum
index|]
operator|.
name|mac_start
condition|)
goto|goto
name|endmac
goto|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No text supplied for macro \"%s.\"\n"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
comment|/* see if we have a 'blank' line: just whitespace. */
while|while
condition|(
operator|*
name|cp
operator|&&
name|isspace
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
comment|/* Blank line; end this macro. */
name|endmac
label|:
name|macros
index|[
name|macnum
operator|++
index|]
operator|.
name|mac_end
operator|=
name|tmp
expr_stmt|;
return|return
literal|0
return|;
block|}
comment|/* Add the text of this line to the macro. */
name|len
operator|=
name|strlen
argument_list|(
name|cp
argument_list|)
operator|+
literal|1
expr_stmt|;
comment|/* we need the \0 too. */
if|if
condition|(
name|tmp
operator|+
name|len
operator|>=
name|macbuf
operator|+
name|MACBUFLEN
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Macro \"%s\" not defined -- %d byte buffer exceeded.\n"
argument_list|,
name|name
argument_list|,
name|MACBUFLEN
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|tmp
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|tmp
operator|+=
name|len
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* make_macro */
end_comment

begin_function
name|int
name|macdef
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(macro name) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|!=
literal|2
condition|)
block|{
operator|(
name|void
operator|)
name|domacro
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
return|return
name|USAGE
return|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Enter macro line by line, terminating it with a blank line\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|make_macro
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|stdin
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* macdef */
end_comment

begin_function
name|int
name|domacro
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
specifier|register
name|char
modifier|*
name|cp1
decl_stmt|,
modifier|*
name|cp2
decl_stmt|;
name|int
name|count
init|=
literal|2
decl_stmt|,
name|loopflg
init|=
literal|0
decl_stmt|;
name|string
name|str
decl_stmt|;
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
comment|/* print macros. */
if|if
condition|(
name|macnum
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"No macros defined.\n"
argument_list|)
expr_stmt|;
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Current macro definitions:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macnum
condition|;
operator|++
name|i
control|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:\n"
argument_list|,
name|macros
index|[
name|i
index|]
operator|.
name|mac_name
argument_list|)
expr_stmt|;
name|cp1
operator|=
name|macros
index|[
name|i
index|]
operator|.
name|mac_start
expr_stmt|;
name|cp2
operator|=
name|macros
index|[
name|i
index|]
operator|.
name|mac_end
expr_stmt|;
while|while
condition|(
name|cp1
operator|<
name|cp2
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"> "
argument_list|)
expr_stmt|;
while|while
condition|(
name|cp1
operator|<
name|cp2
operator|&&
operator|*
name|cp1
condition|)
name|putchar
argument_list|(
operator|*
name|cp1
operator|++
argument_list|)
expr_stmt|;
operator|++
name|cp1
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
return|return
operator|(
name|NOERR
operator|)
return|;
comment|/* called from macdef(), above. */
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(macro to run) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|macnum
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
name|macros
index|[
name|i
index|]
operator|.
name|mac_name
argument_list|,
operator|(
name|size_t
operator|)
literal|9
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|==
name|macnum
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"'%s' macro not found.\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
return|return
name|USAGE
return|;
block|}
name|doingInitMacro
operator|=
operator|(
name|strcmp
argument_list|(
name|macros
index|[
name|i
index|]
operator|.
name|mac_name
argument_list|,
literal|"init"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
name|line
argument_list|)
expr_stmt|;
name|TOP
label|:
name|cp1
operator|=
name|macros
index|[
name|i
index|]
operator|.
name|mac_start
expr_stmt|;
while|while
condition|(
name|cp1
operator|!=
name|macros
index|[
name|i
index|]
operator|.
name|mac_end
condition|)
block|{
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|cp1
argument_list|)
condition|)
block|{
name|cp1
operator|++
expr_stmt|;
block|}
name|cp2
operator|=
name|line
expr_stmt|;
while|while
condition|(
operator|*
name|cp1
operator|!=
literal|'\0'
condition|)
block|{
switch|switch
condition|(
operator|*
name|cp1
condition|)
block|{
case|case
literal|'\\'
case|:
operator|*
name|cp2
operator|++
operator|=
operator|*
operator|++
name|cp1
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
if|if
condition|(
name|isdigit
argument_list|(
operator|*
operator|(
name|cp1
operator|+
literal|1
operator|)
argument_list|)
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|isdigit
argument_list|(
operator|*
operator|++
name|cp1
argument_list|)
condition|)
block|{
name|j
operator|=
literal|10
operator|*
name|j
operator|+
operator|*
name|cp1
operator|-
literal|'0'
expr_stmt|;
block|}
name|cp1
operator|--
expr_stmt|;
if|if
condition|(
name|argc
operator|-
literal|2
operator|>=
name|j
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp2
argument_list|,
name|argv
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|cp2
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|j
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|cp1
operator|+
literal|1
operator|)
operator|==
literal|'i'
condition|)
block|{
name|loopflg
operator|=
literal|1
expr_stmt|;
name|cp1
operator|++
expr_stmt|;
if|if
condition|(
name|count
operator|<
name|argc
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|cp2
argument_list|,
name|argv
index|[
name|count
index|]
argument_list|)
expr_stmt|;
name|cp2
operator|+=
name|strlen
argument_list|(
name|argv
index|[
name|count
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
comment|/* intentional drop through */
default|default:
operator|*
name|cp2
operator|++
operator|=
operator|*
name|cp1
expr_stmt|;
break|break;
block|}
if|if
condition|(
operator|*
name|cp1
operator|!=
literal|'\0'
condition|)
block|{
name|cp1
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|cp2
operator|=
literal|'\0'
expr_stmt|;
name|makeargv
argument_list|()
expr_stmt|;
name|c
operator|=
name|getcmd
argument_list|(
name|margv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|==
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|-
literal|1
operator|)
operator|&&
operator|!
name|parsing_rc
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"?Ambiguous command\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|==
name|NULL
operator|&&
operator|!
name|parsing_rc
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"?Invalid command\n"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|c
operator|->
name|c_conn
operator|&&
operator|!
name|connected
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Not connected.\n"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|IS_VVERBOSE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
call|(
modifier|*
name|c
operator|->
name|c_handler
call|)
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
operator|==
name|USAGE
condition|)
name|cmd_usage
argument_list|(
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|makeargv
argument_list|()
expr_stmt|;
name|argc
operator|=
name|margc
expr_stmt|;
name|argv
operator|=
name|margv
expr_stmt|;
block|}
if|if
condition|(
name|cp1
operator|!=
name|macros
index|[
name|i
index|]
operator|.
name|mac_end
condition|)
block|{
name|cp1
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|loopflg
operator|&&
operator|++
name|count
operator|<
name|argc
condition|)
block|{
goto|goto
name|TOP
goto|;
block|}
name|doingInitMacro
operator|=
literal|0
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* domacro */
end_comment

begin_comment
comment|/*  * get size of file on remote machine  */
end_comment

begin_function
name|int
name|sizecmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-file) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
if|if
condition|(
name|rem_glob_one
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"SIZE %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|verbose_command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* sizecmd */
end_comment

begin_comment
comment|/*  * get last modification time of file on remote machine  */
end_comment

begin_function
name|int
name|modtime
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|overbose
decl_stmt|;
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-file) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
if|if
condition|(
name|rem_glob_one
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|)
operator|==
literal|0
condition|)
block|{
name|overbose
operator|=
name|verbose
expr_stmt|;
if|if
condition|(
name|debug
operator|==
literal|0
condition|)
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"MDTM %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|str
argument_list|)
operator|==
name|COMPLETE
condition|)
block|{
name|int
name|yy
decl_stmt|,
name|mo
decl_stmt|,
name|day
decl_stmt|,
name|hour
decl_stmt|,
name|min
decl_stmt|,
name|sec
decl_stmt|;
operator|(
name|void
operator|)
name|sscanf
argument_list|(
name|reply_string
argument_list|,
literal|"%*s %04d%02d%02d%02d%02d%02d"
argument_list|,
operator|&
name|yy
argument_list|,
operator|&
name|mo
argument_list|,
operator|&
name|day
argument_list|,
operator|&
name|hour
argument_list|,
operator|&
name|min
argument_list|,
operator|&
name|sec
argument_list|)
expr_stmt|;
comment|/* might want to print this in local time */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\t%02d/%02d/%04d %02d:%02d:%02d GMT\n"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|,
name|mo
argument_list|,
name|day
argument_list|,
name|yy
argument_list|,
name|hour
argument_list|,
name|min
argument_list|,
name|sec
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|reply_string
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|overbose
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* modtime */
end_comment

begin_function
name|int
name|lookup
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|by_name
decl_stmt|,
name|result
init|=
name|NOERR
decl_stmt|;
name|struct
name|hostent
modifier|*
name|host
decl_stmt|;
comment|/* structure returned by gethostbyaddr() */
specifier|extern
name|int
name|h_errno
decl_stmt|;
ifdef|#
directive|ifdef
name|BAD_INETADDR
name|struct
name|in_addr
name|addr
decl_stmt|;
comment|/* address in host order */
define|#
directive|define
name|ADDR
value|addr.s_addr
else|#
directive|else
name|unsigned
name|long
name|addr
decl_stmt|;
comment|/* address in host order */
define|#
directive|define
name|ADDR
value|addr
endif|#
directive|endif
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(sitename) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
name|lasthostname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
name|i
operator|++
control|)
block|{
comment|/* does the argument look like an address? */
if|if
condition|(
literal|4
operator|==
name|sscanf
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"%d.%d.%d.%d"
argument_list|,
operator|&
name|j
argument_list|,
operator|&
name|j
argument_list|,
operator|&
name|j
argument_list|,
operator|&
name|j
argument_list|)
condition|)
block|{
comment|/* ip */
name|addr
operator|=
name|inet_addr
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|ADDR
operator|==
literal|0xffffffff
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"## could not convert \"%s\" into a valid IP address.\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|host
operator|=
name|gethostbyaddr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|ADDR
argument_list|,
literal|4
argument_list|,
name|AF_INET
argument_list|)
expr_stmt|;
name|by_name
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* name */
name|host
operator|=
name|gethostbyname
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|by_name
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|host
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|NOT_VQUIET
condition|)
block|{
comment|/* gethostxxx error */
if|if
condition|(
name|h_errno
operator|==
name|HOST_NOT_FOUND
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: lookup error (%d).\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|,
name|h_errno
argument_list|)
expr_stmt|;
name|result
operator|=
name|h_errno
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s \"%s\"\n"
argument_list|,
operator|(
name|by_name
operator|==
literal|0
condition|?
literal|"unknown address"
else|:
literal|"unknown host"
operator|)
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|result
operator|=
name|h_errno
operator|!=
literal|0
condition|?
name|h_errno
else|:
operator|-
literal|1
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|host
operator|->
name|h_name
condition|)
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|lasthostname
argument_list|,
name|host
operator|->
name|h_name
argument_list|)
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|host
operator|->
name|h_aliases
index|[
name|j
index|]
operator|!=
name|NULL
condition|;
name|j
operator|++
control|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|host
operator|->
name|h_aliases
index|[
name|j
index|]
argument_list|)
operator|>
name|strlen
argument_list|(
name|host
operator|->
name|h_name
argument_list|)
operator|&&
name|strstr
argument_list|(
name|host
operator|->
name|h_aliases
index|[
name|j
index|]
argument_list|,
name|host
operator|->
name|h_name
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|lasthostname
argument_list|,
name|host
operator|->
name|h_aliases
index|[
name|j
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|NOT_VQUIET
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-32s  "
argument_list|,
operator|*
name|host
operator|->
name|h_name
condition|?
name|host
operator|->
name|h_name
else|:
literal|"???"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|host
operator|->
name|h_addr_list
condition|)
block|{
name|unsigned
name|long
name|horder
decl_stmt|;
name|horder
operator|=
name|ntohl
argument_list|(
operator|*
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|*
operator|(
name|char
operator|*
operator|*
operator|)
name|host
operator|->
name|h_addr_list
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%lu.%lu.%lu.%lu\n"
argument_list|,
operator|(
name|horder
operator|>>
literal|24
operator|)
argument_list|,
operator|(
name|horder
operator|>>
literal|16
operator|)
operator|&
literal|0xff
argument_list|,
operator|(
name|horder
operator|>>
literal|8
operator|)
operator|&
literal|0xff
argument_list|,
name|horder
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"???\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
comment|/* loop thru all sites */
return|return
name|result
return|;
block|}
end_function

begin_comment
comment|/* lookup */
end_comment

begin_function
name|int
name|getlocalhostname
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
name|int
name|oldv
decl_stmt|,
name|r
decl_stmt|;
name|char
modifier|*
name|argv
index|[
literal|2
index|]
decl_stmt|;
name|char
name|domain
index|[
literal|64
index|]
decl_stmt|;
ifdef|#
directive|ifdef
name|HOSTNAME
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|host
argument_list|,
name|HOSTNAME
argument_list|,
name|size
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
else|#
directive|else
name|host
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|(
name|r
operator|=
name|gethostname
argument_list|(
name|host
argument_list|,
name|size
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|host
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Could not determine the hostname. Re-compile with HOSTNAME defined\n\ to be the full name of your hostname.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|oldv
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
name|argv
index|[
literal|0
index|]
operator|=
literal|"lookup"
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"lookup %s"
argument_list|,
name|host
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|makeargv
argument_list|()
expr_stmt|;
if|if
condition|(
name|lookup
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
operator|==
literal|0
operator|&&
name|lasthostname
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|_Strncpy
argument_list|(
name|host
argument_list|,
name|lasthostname
argument_list|,
name|size
argument_list|)
expr_stmt|;
name|domain
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
ifdef|#
directive|ifdef
name|HAS_DOMAINNAME
comment|/* getdomainname() returns just the domain name, without a 			 * preceding period.  For example, on "cse.unl.edu", it would 			 * return "unl.edu". 			 * 			 * SunOS note: getdomainname will return an empty string if 			 * this machine isn't on NIS. 			 */
operator|(
name|void
operator|)
name|getdomainname
argument_list|(
name|domain
argument_list|,
sizeof|sizeof
argument_list|(
name|domain
argument_list|)
operator|-
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DOMAIN_NAME
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|domain
argument_list|,
name|DOMAIN_NAME
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|index
argument_list|(
name|host
argument_list|,
literal|'.'
argument_list|)
operator|==
name|NULL
condition|)
block|{
comment|/* If the hostname has periods we'll assume that the 				 * it includes the domain name already.  Some gethostname()s 				 * return the whole host name, others just the machine name. 				 * If we have just the machine name and we successfully 				 * found out the domain name (from above), we'll append 				 * the domain to the machine to get a full hostname. 				 */
if|if
condition|(
name|domain
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|_Strncat
argument_list|(
name|host
argument_list|,
literal|"."
argument_list|,
name|size
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|_Strncat
argument_list|(
name|host
argument_list|,
name|domain
argument_list|,
name|size
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: could not determine full host name (have: '%s').\n\ The program should be re-compiled with DOMAIN_NAME defined to be the\n\ domain name, i.e. -DDOMAIN_NAME=\\\"unl.edu\\\"\n\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|verbose
operator|=
name|oldv
expr_stmt|;
block|}
return|return
name|r
return|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* getlocalhostname */
end_comment

begin_comment
comment|/*  * show status on remote machine  */
end_comment

begin_function
name|int
name|rmtstatus
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"STAT %s"
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|verbose_command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|verbose_command
argument_list|(
literal|"STAT"
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* rmtstatus */
end_comment

begin_comment
comment|/*  * create an empty file on remote machine.  */
end_comment

begin_function
name|int
name|create
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
name|FILE
modifier|*
name|ftemp
decl_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
name|argv
operator|=
name|re_makeargv
argument_list|(
literal|"(remote-file) "
argument_list|,
operator|&
name|argc
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
return|return
name|USAGE
return|;
block|}
operator|(
name|void
operator|)
name|tmp_name
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|ftemp
operator|=
name|fopen
argument_list|(
name|str
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
comment|/* (void) fputc('x', ftemp); */
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ftemp
argument_list|)
expr_stmt|;
name|creating
operator|=
literal|1
expr_stmt|;
operator|(
name|void
operator|)
name|sendrequest
argument_list|(
literal|"STOR"
argument_list|,
name|str
argument_list|,
name|argv
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|creating
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|str
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* create */
end_comment

begin_comment
comment|/* show version info */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|show_version
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|char
modifier|*
name|DStrs
index|[
literal|80
index|]
decl_stmt|;
name|int
name|nDStrs
init|=
literal|0
decl_stmt|,
name|i
decl_stmt|,
name|j
decl_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-30s %s\n"
argument_list|,
literal|"NcFTP Version:"
argument_list|,
name|version
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-30s %s\n"
argument_list|,
literal|"Author:"
argument_list|,
literal|"Mike Gleason, NCEMRSoft (mgleason@cse.unl.edu)."
argument_list|)
expr_stmt|;
comment|/* Now entering CPP hell... */
ifdef|#
directive|ifdef
name|__DATE__
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-30s %s\n"
argument_list|,
literal|"Compile Date:"
argument_list|,
name|__DATE__
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-30s %s (%s)\n"
argument_list|,
literal|"Operating System:"
argument_list|,
ifdef|#
directive|ifdef
name|System
name|System
argument_list|,
else|#
directive|else
ifdef|#
directive|ifdef
name|unix
literal|"UNIX"
argument_list|,
else|#
directive|else
literal|"??"
argument_list|,
endif|#
directive|endif
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SYSV
literal|"SYSV"
argument_list|)
expr_stmt|;
else|#
directive|else
ifdef|#
directive|ifdef
name|BSD
literal|"BSD"
block|)
function|;
end_function

begin_else
else|#
directive|else
end_else

begin_expr_stmt
literal|"neither BSD nor SYSV?"
end_expr_stmt

begin_empty_stmt
unit|)
empty_stmt|;
end_empty_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Show which CPP symbols were used in compilation. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__GNUC__
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"__GNUC__"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|RINDEX
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"RINDEX"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|CURSES
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"CURSES"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_CURSES_H
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_CURSES_H"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HERROR
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"HERROR"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|U_WAIT
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"U_WAIT"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|NO_CONST
argument_list|)
operator|||
name|defined
argument_list|(
specifier|const
argument_list|)
end_if

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_CONST"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FORMATTING
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_FORMATTING"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DONT_TIMESTAMP
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"DONT_TIMESTAMP"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GETPASS
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"GETPASS"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_GETCWD
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"HAS_GETCWD"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GETCWDSIZET
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"GETCWDSIZET"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HAS_DOMAINNAME
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"HAS_DOMAINNAME"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DOMAIN_NAME
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"DOMAIN_NAME"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|Solaris
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"Solaris"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|USE_GETPWUID
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"USE_GETPWUID"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|HOSTNAME
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"HOSTNAME"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYSDIRH
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"SYSDIRH"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYSSELECTH
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"SYSSELECTH"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMH
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"TERMH"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UNISTDH
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_UNISTDH"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STDLIBH
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_STDLIBH"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SYSLOG
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"SYSLOG"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BAD_INETADDR
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"BAD_INETADDR"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SGTTYB
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"SGTTYB"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"TERMIOS"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|STRICT_PROTOS
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"STRICT_PROTOS"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|dFTP_PORT
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"dFTP_PORT"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|BROKEN_MEMCPY
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"BROKEN_MEMCPY"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|READLINE
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"READLINE"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GETLINE
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"GETLINE"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"_POSIX_SOURCE"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_XOPEN_SOURCE
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"_XOPEN_SOURCE"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_TIPS
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_TIPS"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GZCAT
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"GZCAT"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|LINGER
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"LINGER"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TRY_NOREPLY
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"TRY_NOREPLY"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UTIMEH
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_UTIMEH"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|DB_ERRS
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"DB_ERRS"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_VARARGS
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_VARARGS"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STDARGH
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_STDARGH"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_MKTIME
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_MKTIME"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STRSTR
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_STRSTR"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_STRFTIME
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_STRFTIME"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NO_RENAME
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NO_RENAME"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|TRY_ABOR
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"TRY_ABOR"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|GATEWAY
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"GATEWAY"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SOCKS
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"SOCKS"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|NET_ERRNO_H
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"NET_ERRNO_H"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|PASSIVEMODE
end_ifdef

begin_expr_stmt
name|DStrs
index|[
name|nDStrs
operator|++
index|]
operator|=
literal|"PASSIVEMODE"
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* DONE with #ifdefs for now! */
end_comment

begin_expr_stmt
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nCompile Options:\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_for
for|for
control|(
name|i
operator|=
name|j
operator|=
literal|0
init|;
name|i
operator|<
name|nDStrs
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|j
operator|==
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"    "
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%-15s"
argument_list|,
name|DStrs
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|==
literal|4
condition|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_for

begin_if
if|if
condition|(
name|j
operator|!=
literal|0
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|MK
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nMK: %s\n"
argument_list|,
name|MK
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* MK */
end_comment

begin_expr_stmt
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\nDefaults:\n"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\     Xfer Buf Size: %8d   Debug: %d   MPrompt: %d   Verbosity: %d\n\     Prompt: %s   Pager: %s  ZCat: %s\n\     Logname: %s   Logging: %d   Type: %s   Cmd Len: %d\n\     Recv Line Len: %d   #Macros: %d   Macbuf: %d  Auto-Binary: %d\n\     Recent File: %s   Recent On: %d   nRecents: %d\n\     Redial Delay: %d  Anon Open: %d  New Mail Message: \"%s\"\n"
argument_list|,
name|MAX_XFER_BUFSIZE
argument_list|,
name|dDEBUG
argument_list|,
name|dMPROMPT
argument_list|,
name|dVERBOSE
argument_list|,
name|dPROMPT
argument_list|,
name|dPAGER
argument_list|,
name|ZCAT
argument_list|,
name|dLOGNAME
argument_list|,
name|dLOGGING
argument_list|,
name|dTYPESTR
argument_list|,
name|CMDLINELEN
argument_list|,
name|RECEIVEDLINELEN
argument_list|,
name|MAXMACROS
argument_list|,
name|MACBUFLEN
argument_list|,
name|dAUTOBINARY
argument_list|,
name|dRECENTF
argument_list|,
name|dRECENT_ON
argument_list|,
name|dMAXRECENTS
argument_list|,
name|dREDIALDELAY
argument_list|,
name|dANONOPEN
argument_list|,
name|NEWMAILMESSAGE
argument_list|)
expr_stmt|;
end_expr_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATEWAY
end_ifdef

begin_expr_stmt
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\     Gateway Login: %s\n"
argument_list|,
name|dGATEWAY_LOGIN
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_return
return|return
name|NOERR
return|;
end_return

begin_comment
unit|}
comment|/* show_version */
end_comment

begin_macro
unit|void
name|PurgeLineBuffer
argument_list|(
argument|void
argument_list|)
end_macro

begin_block
block|{
specifier|register
name|struct
name|lslist
modifier|*
name|a
decl_stmt|,
modifier|*
name|b
decl_stmt|;
for|for
control|(
name|a
operator|=
name|lshead
init|;
name|a
operator|!=
name|NULL
condition|;
control|)
block|{
name|b
operator|=
name|a
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|a
operator|->
name|string
condition|)
name|free
argument_list|(
name|a
operator|->
name|string
argument_list|)
expr_stmt|;
comment|/* free string */
name|Free
argument_list|(
name|a
argument_list|)
expr_stmt|;
comment|/* free node */
name|a
operator|=
name|b
expr_stmt|;
block|}
name|lshead
operator|=
name|lstail
operator|=
name|NULL
expr_stmt|;
block|}
end_block

begin_comment
comment|/* PurgeLineBuffer */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|ShowLineBuffer
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|register
name|struct
name|lslist
modifier|*
name|a
init|=
name|lshead
decl_stmt|;
name|int
name|pagemode
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|Sig_t
name|oldintp
decl_stmt|;
if|if
condition|(
name|a
operator|==
name|NULL
condition|)
return|return
name|CMDERR
return|;
name|pagemode
operator|=
operator|(
operator|*
operator|*
name|argv
operator|)
operator|==
literal|'p'
operator|&&
name|pager
index|[
literal|0
index|]
operator|==
literal|'|'
expr_stmt|;
if|if
condition|(
name|pagemode
condition|)
block|{
name|fp
operator|=
name|popen
argument_list|(
name|pager
operator|+
literal|1
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fp
condition|)
block|{
name|PERROR
argument_list|(
literal|"ShowLineBuffer"
argument_list|,
name|pager
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|CMDERR
return|;
block|}
block|}
else|else
name|fp
operator|=
name|stdout
expr_stmt|;
name|oldintp
operator|=
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
while|while
condition|(
name|a
condition|)
block|{
if|if
condition|(
name|a
operator|->
name|string
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"%s\n"
argument_list|,
name|a
operator|->
name|string
argument_list|)
expr_stmt|;
name|a
operator|=
name|a
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|pagemode
condition|)
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|fp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* ShowLineBuffer */
end_comment

begin_if
if|#
directive|if
name|LIBMALLOC
operator|!=
name|LIBC_MALLOC
end_if

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|MallocStatusCmd
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|#
directive|if
operator|(
name|LIBMALLOC
operator|==
name|FAST_MALLOC
operator|)
name|struct
name|mallinfo
name|mi
decl_stmt|;
name|mi
operator|=
name|mallinfo
argument_list|()
expr_stmt|;
name|printf
argument_list|(
literal|"\ total space in arena:               %d\n\ number of ordinary blocks:          %d\n\ number of small blocks:             %d\n\ number of holding blocks:           %d\n\ space in holding block headers:     %d\n\ space in small blocks in use:       %d\n\ space in free small blocks:         %d\n\ space in ordinary blocks in use:    %d\n\ space in free ordinary blocks:      %d\n\ cost of enabling keep option:       %d\n"
argument_list|,
name|mi
operator|.
name|arena
argument_list|,
name|mi
operator|.
name|ordblks
argument_list|,
name|mi
operator|.
name|smblks
argument_list|,
name|mi
operator|.
name|hblks
argument_list|,
name|mi
operator|.
name|hblkhd
argument_list|,
name|mi
operator|.
name|usmblks
argument_list|,
name|mi
operator|.
name|fsmblks
argument_list|,
name|mi
operator|.
name|uordblks
argument_list|,
name|mi
operator|.
name|fordblks
argument_list|,
name|mi
operator|.
name|keepcost
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
operator|(
name|LIBMALLOC
operator|==
name|DEBUG_MALLOC
operator|)
name|printf
argument_list|(
literal|"malloc_chain_check: %d\n\n"
argument_list|,
name|malloc_chain_check
argument_list|(
literal|0
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
name|malloc_dump
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"malloc_inuse: %lu\n"
argument_list|,
name|malloc_inuse
argument_list|(
name|NULL
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
literal|"Nothing to report.\n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* (LIBMALLOC == DEBUG_MALLOC) */
endif|#
directive|endif
comment|/* (LIBMALLOC == FAST_MALLOC) */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* MallocStatusCmd */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* LIBMALLOC */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|int
name|unimpl
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
if|if
condition|(
operator|!
name|parsing_rc
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: command not supported. (and probably won't ever be).\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* unimpl */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|PASSIVEMODE
end_ifdef

begin_function
name|int
name|setpassive
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|passivemode
operator|=
operator|!
name|passivemode
expr_stmt|;
name|printf
argument_list|(
literal|"Passive mode %s.\n"
argument_list|,
operator|(
name|passivemode
condition|?
literal|"ON"
else|:
literal|"OFF"
operator|)
argument_list|)
expr_stmt|;
return|return
name|NOERR
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* eof cmds.c */
end_comment

end_unit

