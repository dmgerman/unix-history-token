begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* main.c */
end_comment

begin_define
define|#
directive|define
name|_main_c_
end_define

begin_define
define|#
directive|define
name|FTP_VERSION
value|"1.9.2 (January 20, 1995)"
end_define

begin_comment
comment|/* #define BETA 1 */
end_comment

begin_comment
comment|/* If defined, it prints a little warning message. */
end_comment

begin_include
include|#
directive|include
file|"sys.h"
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSLOG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|defined
argument_list|(
name|CURSES
argument_list|)
operator|&&
operator|!
name|defined
argument_list|(
name|NO_CURSES_H
argument_list|)
end_if

begin_undef
undef|#
directive|undef
name|HZ
end_undef

begin_comment
comment|/* Collides with HaZeltine ! */
end_comment

begin_include
include|#
directive|include
file|<curses.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TERMH
end_ifdef

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CURSES */
end_comment

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"ftp.h"
end_include

begin_include
include|#
directive|include
file|"ftprc.h"
end_include

begin_include
include|#
directive|include
file|"open.h"
end_include

begin_include
include|#
directive|include
file|"set.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"copyright.h"
end_include

begin_comment
comment|/* main.c globals */
end_comment

begin_decl_stmt
name|int
name|slrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fromatty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input is from a terminal */
end_comment

begin_decl_stmt
name|int
name|toatty
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output is to a terminal */
end_comment

begin_decl_stmt
name|int
name|doing_script
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* is a file being<redirected to me? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|altarg
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argv[1] with no shell-like preprocessing  */
end_comment

begin_decl_stmt
name|struct
name|servent
name|serv
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* service spec for tcp/ftp */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pad2a
index|[
literal|8
index|]
init|=
literal|"Pad 2a"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* SunOS overwrites jmp_bufs... */
end_comment

begin_decl_stmt
name|jmp_buf
name|toplevel
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* non-local goto stuff for cmd scanner */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pad2b
index|[
literal|8
index|]
init|=
literal|"Pad 2b"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|line
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input line buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|stringbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current scan point in line buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|argbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* argument storage buffer */
end_comment

begin_decl_stmt
name|char
modifier|*
name|argbase
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current storage point in arg buffer */
end_comment

begin_decl_stmt
name|int
name|margc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of arguments on input line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|margv
index|[
literal|20
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* args parsed from input line */
end_comment

begin_decl_stmt
name|struct
name|userinfo
name|uinfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a copy of their pwent really */
end_comment

begin_decl_stmt
name|int
name|ansi_escapes
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* for fancy graphics */
end_comment

begin_decl_stmt
name|int
name|startup_msg
init|=
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TAR: display message on startup? */
end_comment

begin_decl_stmt
name|int
name|ignore_rc
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* are we supposed to ignore the netrc */
end_comment

begin_decl_stmt
name|string
name|progname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* simple filename */
end_comment

begin_decl_stmt
name|string
name|prompt
decl_stmt|,
name|prompt2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* shell prompt string */
end_comment

begin_decl_stmt
name|string
name|anon_password
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* most likely your email address */
end_comment

begin_decl_stmt
name|string
name|pager
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program to browse text files */
end_comment

begin_decl_stmt
name|string
name|version
init|=
name|FTP_VERSION
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|eventnumber
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of commands we've done */
end_comment

begin_decl_stmt
name|FILE
modifier|*
name|logf
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log user activity */
end_comment

begin_decl_stmt
name|longstring
name|logfname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of the logfile */
end_comment

begin_decl_stmt
name|long
name|logsize
init|=
literal|4096L
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* max log size. 0 == no limit */
end_comment

begin_decl_stmt
name|int
name|percent_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "%" in prompt string? */
end_comment

begin_decl_stmt
name|int
name|at_flags
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* "@" in prompt string? */
end_comment

begin_decl_stmt
name|string
name|mail_path
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* your mailbox */
end_comment

begin_decl_stmt
name|time_t
name|mbox_time
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* last modified time of mbox */
end_comment

begin_decl_stmt
name|size_t
name|epromptlen
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* length of the last line of the 										 * prompt as it will appear on screen, 										 * (i.e. no invis escape codes). 										 */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|HPUX
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|tcap_normal
init|=
literal|"\033&d@"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default ANSI escapes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tcap_boldface
init|=
literal|"\033&dH"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Half Bright */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tcap_underline
init|=
literal|"\033&dD"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tcap_reverse
init|=
literal|"\033&dB"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|NO_FORMATTING
end_ifdef

begin_decl_stmt
name|char
modifier|*
name|tcap_normal
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tcap_boldface
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tcap_underline
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tcap_reverse
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|tcap_normal
init|=
literal|"\033[0m"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Default ANSI escapes */
end_comment

begin_decl_stmt
name|char
modifier|*
name|tcap_boldface
init|=
literal|"\033[1m"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tcap_underline
init|=
literal|"\033[4m"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|tcap_reverse
init|=
literal|"\033[7m"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|size_t
name|tcl_normal
init|=
literal|4
decl_stmt|,
comment|/* lengths of the above strings. */
name|tcl_bold
init|=
literal|4
decl_stmt|,
name|tcl_uline
init|=
literal|4
decl_stmt|,
name|tcl_rev
init|=
literal|4
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|CURSES
end_ifdef

begin_decl_stmt
specifier|static
name|char
name|tcbuf
index|[
literal|2048
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* main.c externs */
end_comment

begin_decl_stmt
specifier|extern
name|int
name|debug
decl_stmt|,
name|verbose
decl_stmt|,
name|mprompt
decl_stmt|,
name|passivemode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|options
decl_stmt|,
name|cpend
decl_stmt|,
name|data
decl_stmt|,
name|connected
decl_stmt|,
name|logged_in
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|curtype
decl_stmt|,
name|macnum
decl_stmt|,
name|remote_is_unix
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|cout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|cmd
name|cmdtab
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|str32
name|curtypename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|macbuf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reply_string
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|short_verbose_msgs
index|[
literal|4
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|string
name|vstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Hostname
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|longstring
name|cwd
decl_stmt|,
name|lcwd
decl_stmt|,
name|recent_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Optind
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|Optarg
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATEWAY
end_ifdef

begin_decl_stmt
specifier|extern
name|string
name|gate_login
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|top
decl_stmt|,
name|opt
decl_stmt|,
name|openopts
init|=
literal|0
decl_stmt|;
name|string
name|tmp
decl_stmt|,
name|oline
decl_stmt|;
name|struct
name|servent
modifier|*
name|sptr
decl_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|rindex
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
else|else
name|cp
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|progname
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|sptr
operator|=
name|getservbyname
argument_list|(
literal|"ftp"
argument_list|,
literal|"tcp"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sptr
operator|==
literal|0
condition|)
name|fatal
argument_list|(
literal|"ftp/tcp: unknown service"
argument_list|)
expr_stmt|;
name|serv
operator|=
operator|*
name|sptr
expr_stmt|;
if|if
condition|(
name|init_arrays
argument_list|()
condition|)
comment|/* Reserve large blocks of memory now */
name|fatal
argument_list|(
literal|"could not reserve large amounts of memory."
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GZCAT
if|if
condition|(
operator|(
name|GZCAT
operator|==
operator|(
name|char
operator|*
operator|)
literal|1
operator|)
operator|||
operator|(
name|GZCAT
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You compiled the program with -DGZCAT, but you must specify the path with it!\n\ Re-compile, this time with -DGZCAT=\\\"/path/to/gzcat\\\".\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|ZCAT
if|if
condition|(
operator|(
name|ZCAT
operator|==
operator|(
name|char
operator|*
operator|)
literal|1
operator|)
operator|||
operator|(
name|ZCAT
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You compiled the program with -DZCAT, but you must specify the path with it!\n\ Re-compile, this time with -DZCAT=\\\"/path/to/zcat\\\".\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* 	 * Set up defaults for FTP. 	 */
name|mprompt
operator|=
name|dMPROMPT
expr_stmt|;
name|debug
operator|=
name|dDEBUG
expr_stmt|;
name|verbose
operator|=
name|dVERBOSE
expr_stmt|;
name|passivemode
operator|=
name|dPASSIVE
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|vstr
argument_list|,
name|short_verbose_msgs
index|[
name|verbose
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|curtypename
argument_list|,
name|dTYPESTR
argument_list|)
expr_stmt|;
name|curtype
operator|=
name|dTYPE
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|prompt
argument_list|,
name|dPROMPT
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATEWAY
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|gate_login
argument_list|,
name|dGATEWAY_LOGIN
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SOCKS
name|SOCKSinit
argument_list|(
literal|"ncftp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/*	Setup our pager variable, before we run through the rc, 		which may change it. */
name|set_pager
argument_list|(
name|getenv
argument_list|(
literal|"PAGER"
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|CURSES
name|ansi_escapes
operator|=
literal|1
expr_stmt|;
name|termcap_init
argument_list|()
expr_stmt|;
else|#
directive|else
name|ansi_escapes
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'v'
operator|&&
name|cp
index|[
literal|1
index|]
operator|==
literal|'t'
operator|)
comment|/* vt100, vt102, ... */
operator|||
operator|(
name|strcmp
argument_list|(
name|cp
argument_list|,
literal|"xterm"
argument_list|)
operator|==
literal|0
operator|)
condition|)
name|ansi_escapes
operator|=
literal|1
expr_stmt|;
block|}
endif|#
directive|endif
operator|(
name|void
operator|)
name|getuserinfo
argument_list|()
expr_stmt|;
comment|/* Init the mailbox checking code. */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|mbox_time
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|anon_password
argument_list|,
name|uinfo
operator|.
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|getlocalhostname
argument_list|(
name|uinfo
operator|.
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|uinfo
operator|.
name|hostname
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|anon_password
argument_list|,
literal|"@"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|anon_password
argument_list|,
name|uinfo
operator|.
name|hostname
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|dLOGGING
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|logfname
argument_list|,
name|dLOGNAME
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|LocalDotPath
argument_list|(
name|logfname
argument_list|)
expr_stmt|;
else|#
directive|else
operator|*
name|logfname
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|recent_file
argument_list|,
name|dRECENTF
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|LocalDotPath
argument_list|(
name|recent_file
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_cwd
argument_list|(
name|lcwd
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|lcwd
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYSLOG
ifdef|#
directive|ifdef
name|LOG_LOCAL3
name|openlog
argument_list|(
literal|"NcFTP"
argument_list|,
name|LOG_PID
argument_list|,
name|LOG_LOCAL3
argument_list|)
expr_stmt|;
else|#
directive|else
name|openlog
argument_list|(
literal|"NcFTP"
argument_list|,
name|LOG_PID
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
comment|/* SYSLOG */
name|ignore_rc
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|oline
argument_list|,
literal|"open "
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|Getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"D:V:INPRHaicmup:rd:g:"
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'a'
case|:
case|case
literal|'c'
case|:
case|case
literal|'i'
case|:
case|case
literal|'m'
case|:
case|case
literal|'u'
case|:
case|case
literal|'r'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"-%c "
argument_list|,
name|opt
argument_list|)
expr_stmt|;
goto|goto
name|cattmp
goto|;
case|case
literal|'p'
case|:
case|case
literal|'d'
case|:
case|case
literal|'g'
case|:
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|tmp
argument_list|,
literal|"-%c %s "
argument_list|,
name|opt
argument_list|,
name|Optarg
argument_list|)
expr_stmt|;
name|cattmp
label|:
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|oline
argument_list|,
name|tmp
argument_list|)
expr_stmt|;
name|openopts
operator|++
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
name|debug
operator|=
name|atoi
argument_list|(
name|Optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|set_verbose
argument_list|(
name|Optarg
argument_list|,
literal|0
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|mprompt
operator|=
operator|!
name|mprompt
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
operator|++
name|ignore_rc
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
name|passivemode
operator|=
operator|!
name|passivemode
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
operator|(
name|void
operator|)
name|show_version
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|usage
label|:
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Usage: %s [program options] [[open options] site.to.open[:path]]\n\ Program Options:\n\     -D x   : Set debugging level to x (a number).\n\     -H     : Show version and compilation information.\n\     -I     : Toggle interactive (mprompt) mode.\n\     -N     : Toggle reading of the .netrc/.ncftprc.\n\     -P     : Toggle passive mode ftp (for use behind firewalls).\n\     -V x   : Set verbosity to level x (-1,0,1,2).\n\ Open Options:\n\     -a     : Open anonymously (this is the default).\n\     -u     : Open, specify user/password.\n\     -i     : Ignore machine entry in your .netrc.\n\     -p N   : Use port #N for connection.\n\     -r     : \"Redial\" until connected.\n\     -d N   : Redial, pausing N seconds between tries.\n\     -g N   : Redial, giving up after N tries.\n\     :path  : ``Colon-mode:'' If \"path\" is a file, it opens site, retrieves\n\              file \"path,\" then exits; if \"path\" is a remote directory,\n\              it opens site then starts you in that directory..\n\     -c     : If you're using colon-mode with a file path, this will cat the\n\              file to stdout instead of storing on disk.\n\     -m     : Just like -c, only it pipes the file to your $PAGER.\n\ Examples:\n\     ncftp ftp.unl.edu:/pub/README (just fetches README then quits)\n\     ncftp  (just enters ncftp command shell)\n\     ncftp -V -u ftp.unl.edu\n\     ncftp -c ftp.unl.edu:/pub/README (cats README to stdout then quits)\n\     ncftp -D -r -d 120 -g 10 ftp.unl.edu\n"
argument_list|,
name|progname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|cp
operator|=
name|argv
index|[
name|Optind
index|]
expr_stmt|;
comment|/* the site to open. */
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|openopts
condition|)
goto|goto
name|usage
goto|;
block|}
else|else
operator|(
name|void
operator|)
name|strcat
argument_list|(
name|oline
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ignore_rc
operator|<=
literal|0
condition|)
operator|(
name|void
operator|)
name|thrash_rc
argument_list|()
expr_stmt|;
if|if
condition|(
name|ignore_rc
operator|<=
literal|1
condition|)
name|ReadRecentSitesFile
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|fix_options
argument_list|()
expr_stmt|;
comment|/* adjust "options" according to "debug"  */
name|fromatty
operator|=
name|doing_script
operator|=
name|isatty
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|toatty
operator|=
name|isatty
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|UserLoggedIn
argument_list|()
expr_stmt|;
comment|/* Init parent-death detection. */
name|cpend
operator|=
literal|0
expr_stmt|;
comment|/* no pending replies */
if|if
condition|(
operator|*
name|logfname
condition|)
name|logf
operator|=
name|fopen
argument_list|(
name|logfname
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
comment|/* The user specified a host, maybe in 'colon-mode', on the command 	 * line.  Open it now... 	 */
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|cp
condition|)
block|{
if|if
condition|(
name|setjmp
argument_list|(
name|toplevel
argument_list|)
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|lostpeer
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
name|oline
argument_list|)
expr_stmt|;
name|makeargv
argument_list|()
expr_stmt|;
comment|/* setpeer uses this to tell if it was called from the cmd-line. */
name|eventnumber
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|cmdOpen
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
operator|!=
name|NOERR
condition|)
block|{
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
name|eventnumber
operator|=
literal|1L
expr_stmt|;
operator|(
name|void
operator|)
name|init_prompt
argument_list|()
expr_stmt|;
if|if
condition|(
name|startup_msg
condition|)
block|{
comment|/* TAR */
if|if
condition|(
name|ansi_escapes
condition|)
block|{
ifdef|#
directive|ifdef
name|BETA
define|#
directive|define
name|BETA_MSG
value|"\n\ For testing purposes only.  Do not re-distribute or subject to novice users."
else|#
directive|else
define|#
directive|define
name|BETA_MSG
value|""
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CURSES
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%sNcFTP %s by Mike Gleason, NCEMRSoft.%s%s%s%s\n"
argument_list|,
name|tcap_boldface
argument_list|,
name|FTP_VERSION
argument_list|,
name|tcap_normal
argument_list|,
name|tcap_reverse
argument_list|,
name|BETA_MSG
argument_list|,
name|tcap_normal
argument_list|)
expr_stmt|;
else|#
directive|else
name|char
name|vis
index|[
literal|256
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|vis
argument_list|,
literal|"%sNcFTP %s by Mike Gleason, NCEMRSoft.%s%s%s%s\n"
argument_list|,
name|tcap_boldface
argument_list|,
name|FTP_VERSION
argument_list|,
name|tcap_normal
argument_list|,
name|tcap_reverse
argument_list|,
name|BETA_MSG
argument_list|,
name|tcap_normal
argument_list|)
expr_stmt|;
name|tcap_put
argument_list|(
name|vis
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* !CURSES */
block|}
else|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s%s\n"
argument_list|,
name|FTP_VERSION
argument_list|,
name|BETA_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* TAR */
if|if
condition|(
name|NOT_VQUIET
condition|)
name|PrintTip
argument_list|()
expr_stmt|;
name|top
operator|=
name|setjmp
argument_list|(
name|toplevel
argument_list|)
operator|==
literal|0
expr_stmt|;
if|if
condition|(
name|top
condition|)
block|{
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|lostpeer
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|cmdscanner
argument_list|(
name|top
argument_list|)
operator|&&
operator|!
name|fromatty
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|top
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* main */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|void
name|intr
name|SIG_PARAMS
block|{
name|dbprintf
argument_list|(
literal|"intr()\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|longjmp
argument_list|(
name|toplevel
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* intr */
end_comment

begin_function
name|int
name|getuserinfo
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|string
name|str
decl_stmt|;
specifier|extern
name|char
modifier|*
name|home
decl_stmt|;
comment|/* for glob.c */
name|home
operator|=
name|uinfo
operator|.
name|homedir
expr_stmt|;
comment|/* for glob.c */
name|pw
operator|=
name|NULL
expr_stmt|;
ifdef|#
directive|ifdef
name|USE_GETPWUID
comment|/* Try to use getpwuid(), but if we have to, fall back to getpwnam(). */
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
comment|/* Oh well, try getpwnam() then. */
name|cp
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|pw
operator|=
name|getpwnam
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* Try to use getpwnam(), but if we have to, fall back to getpwuid(). */
name|cp
operator|=
name|getlogin
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
block|{
name|cp
operator|=
name|getenv
argument_list|(
literal|"LOGNAME"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|getenv
argument_list|(
literal|"USER"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cp
operator|!=
name|NULL
condition|)
name|pw
operator|=
name|getpwnam
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|pw
operator|==
name|NULL
condition|)
block|{
comment|/* Oh well, try getpwuid() then. */
name|pw
operator|=
name|getpwuid
argument_list|(
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|pw
operator|!=
name|NULL
condition|)
block|{
name|uinfo
operator|.
name|uid
operator|=
name|pw
operator|->
name|pw_uid
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|uinfo
operator|.
name|username
argument_list|,
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|uinfo
operator|.
name|shell
argument_list|,
name|pw
operator|->
name|pw_shell
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|uinfo
operator|.
name|homedir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|uinfo
operator|.
name|homedir
argument_list|,
name|pw
operator|->
name|pw_dir
argument_list|)
expr_stmt|;
name|cp
operator|=
name|getenv
argument_list|(
literal|"MAIL"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|getenv
argument_list|(
literal|"mail"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"/usr/spool/mail/%s"
argument_list|,
name|uinfo
operator|.
name|username
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|str
expr_stmt|;
comment|/* 		 * mbox variable may be like MAIL=(28 /usr/mail/me /usr/mail/you), 		 * so try to find the first mail path. 		 */
while|while
condition|(
operator|(
operator|*
name|cp
operator|!=
literal|'/'
operator|)
operator|&&
operator|(
operator|*
name|cp
operator|!=
literal|0
operator|)
condition|)
name|cp
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|mail_path
argument_list|,
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|mail_path
argument_list|,
literal|' '
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|PERROR
argument_list|(
literal|"getuserinfo"
argument_list|,
literal|"Could not get your passwd entry!"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|uinfo
operator|.
name|shell
argument_list|,
literal|"/bin/sh"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|uinfo
operator|.
name|homedir
argument_list|,
literal|"."
argument_list|)
expr_stmt|;
comment|/* current directory */
name|uinfo
operator|.
name|uid
operator|=
literal|999
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"HOME"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|uinfo
operator|.
name|homedir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
name|mail_path
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* getuserinfo */
end_comment

begin_function
name|int
name|init_arrays
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|(
name|macbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|MACBUFLEN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|barf
goto|;
if|if
condition|(
operator|(
name|line
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|CMDLINELEN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|barf
goto|;
if|if
condition|(
operator|(
name|argbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|CMDLINELEN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|barf
goto|;
if|if
condition|(
operator|(
name|reply_string
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|size_t
call|)
argument_list|(
name|RECEIVEDLINELEN
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|barf
goto|;
operator|*
name|macbuf
operator|=
literal|'\0'
expr_stmt|;
name|init_transfer_buffer
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|barf
label|:
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* init_arrays */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|BUFSIZ
end_ifndef

begin_define
define|#
directive|define
name|BUFSIZ
value|512
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|void
name|init_transfer_buffer
parameter_list|(
name|void
parameter_list|)
block|{
specifier|extern
name|char
modifier|*
name|xferbuf
decl_stmt|;
specifier|extern
name|size_t
name|xferbufsize
decl_stmt|;
comment|/* Make sure we use a multiple of BUFSIZ for efficiency. */
name|xferbufsize
operator|=
operator|(
name|MAX_XFER_BUFSIZE
operator|/
name|BUFSIZ
operator|)
operator|*
name|BUFSIZ
expr_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
name|xferbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|xferbufsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|xferbuf
operator|!=
name|NULL
operator|||
name|xferbufsize
operator|<
literal|1024
condition|)
break|break;
name|xferbufsize
operator|>>=
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|xferbuf
operator|!=
name|NULL
condition|)
return|return;
name|fatal
argument_list|(
literal|"out of memory for transfer buffer."
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* init_transfer_buffer */
end_comment

begin_function
name|void
name|init_prompt
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|cp
decl_stmt|;
name|percent_flags
operator|=
name|at_flags
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|cp
operator|=
name|prompt
init|;
operator|*
name|cp
condition|;
name|cp
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'%'
condition|)
name|percent_flags
operator|=
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'@'
condition|)
name|at_flags
operator|=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* init_prompt */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_decl_stmt
name|void
name|lostpeer
name|SIG_PARAMS
block|{
if|if
condition|(
name|connected
condition|)
block|{
name|close_streams
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|shutdown
argument_list|(
name|data
argument_list|,
literal|1
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|connected
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|connected
condition|)
block|{
name|close_streams
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|connected
operator|=
literal|0
expr_stmt|;
block|}
name|hostname
index|[
literal|0
index|]
operator|=
name|cwd
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|logged_in
operator|=
name|macnum
operator|=
literal|0
expr_stmt|;
block|}
end_decl_stmt

begin_comment
comment|/* lostpeer */
end_comment

begin_comment
comment|/*  * Command parser.  */
end_comment

begin_function
name|int
name|cmdscanner
parameter_list|(
name|int
name|top
parameter_list|)
block|{
specifier|register
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|int
name|cmd_status
decl_stmt|,
name|rcode
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|top
condition|)
operator|(
name|void
operator|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|doing_script
operator|&&
operator|!
name|UserLoggedIn
argument_list|()
condition|)
operator|(
name|void
operator|)
name|quit
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|Gets
argument_list|(
name|strprompt
argument_list|()
argument_list|,
name|line
argument_list|,
operator|(
name|size_t
operator|)
name|CMDLINELEN
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|quit
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
comment|/* control-d */
block|}
name|eventnumber
operator|++
expr_stmt|;
name|dbprintf
argument_list|(
literal|"\"%s\"\n"
argument_list|,
name|line
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|makeargv
argument_list|()
expr_stmt|;
if|if
condition|(
name|margc
operator|==
literal|0
condition|)
block|{
continue|continue;
comment|/* blank line... */
block|}
name|c
operator|=
name|getcmd
argument_list|(
name|margv
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|-
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"?Ambiguous command\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|implicit_cd
argument_list|(
name|margv
index|[
literal|0
index|]
argument_list|)
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"?Invalid command\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|c
operator|->
name|c_conn
operator|&&
operator|!
name|connected
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Not connected.\n"
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|cmd_status
operator|=
call|(
modifier|*
name|c
operator|->
name|c_handler
call|)
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd_status
operator|==
name|USAGE
condition|)
name|cmd_usage
argument_list|(
name|c
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|cmd_status
operator|==
name|CMDERR
condition|)
name|rcode
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|c
operator|->
name|c_handler
operator|!=
name|help
condition|)
break|break;
block|}
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|intr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|lostpeer
argument_list|)
expr_stmt|;
return|return
name|rcode
return|;
block|}
end_function

begin_comment
comment|/* cmdscanner */
end_comment

begin_function
name|char
modifier|*
name|strprompt
parameter_list|(
name|void
parameter_list|)
block|{
name|time_t
name|tyme
decl_stmt|;
name|char
name|eventstr
index|[
literal|8
index|]
decl_stmt|;
name|char
modifier|*
name|dname
decl_stmt|,
modifier|*
name|lastlinestart
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
name|string
name|str
decl_stmt|;
name|int
name|flag
decl_stmt|;
if|if
condition|(
name|at_flags
operator|==
literal|0
operator|&&
name|percent_flags
operator|==
literal|0
condition|)
block|{
name|epromptlen
operator|=
name|strlen
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
return|return
operator|(
name|prompt
operator|)
return|;
comment|/* But don't overwrite it! */
block|}
name|epromptlen
operator|=
literal|0
expr_stmt|;
name|lastlinestart
operator|=
name|prompt2
expr_stmt|;
if|if
condition|(
name|at_flags
condition|)
block|{
for|for
control|(
name|p
operator|=
name|prompt
operator|,
name|q
operator|=
name|prompt2
operator|,
operator|*
name|q
operator|=
literal|0
init|;
operator|(
operator|*
name|p
operator|)
condition|;
name|p
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|'@'
condition|)
switch|switch
condition|(
name|flag
operator|=
operator|*
operator|++
name|p
condition|)
block|{
case|case
literal|'\0'
case|:
operator|--
name|p
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
if|if
condition|(
name|CheckNewMail
argument_list|()
operator|>
literal|0
condition|)
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
literal|"(Mail) "
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'N'
case|:
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|lastlinestart
operator|=
name|q
expr_stmt|;
name|epromptlen
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'P'
case|:
comment|/* reset to no bold, no uline, no inverse, etc. */
if|if
condition|(
name|ansi_escapes
condition|)
block|{
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|tcap_normal
argument_list|)
expr_stmt|;
name|epromptlen
operator|+=
name|tcl_normal
expr_stmt|;
block|}
break|break;
case|case
literal|'B'
case|:
comment|/* toggle boldface */
if|if
condition|(
name|ansi_escapes
condition|)
block|{
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|tcap_boldface
argument_list|)
expr_stmt|;
name|epromptlen
operator|+=
name|tcl_bold
expr_stmt|;
block|}
break|break;
case|case
literal|'U'
case|:
comment|/* toggle underline */
if|if
condition|(
name|ansi_escapes
condition|)
block|{
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|tcap_underline
argument_list|)
expr_stmt|;
name|epromptlen
operator|+=
name|tcl_uline
expr_stmt|;
block|}
break|break;
case|case
literal|'R'
case|:
case|case
literal|'I'
case|:
comment|/* toggle inverse (reverse) video */
if|if
condition|(
name|ansi_escapes
condition|)
block|{
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|tcap_reverse
argument_list|)
expr_stmt|;
name|epromptlen
operator|+=
name|tcl_rev
expr_stmt|;
block|}
break|break;
case|case
literal|'D'
case|:
comment|/* insert current directory */
case|case
literal|'J'
case|:
if|if
condition|(
operator|(
name|flag
operator|==
literal|'J'
operator|)
operator|&&
operator|(
name|remote_is_unix
operator|)
condition|)
block|{
comment|/* Not the whole path, just the dir name. */
name|dname
operator|=
name|rindex
argument_list|(
name|cwd
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|dname
operator|==
name|NULL
condition|)
name|dname
operator|=
name|cwd
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|dname
operator|!=
name|cwd
operator|)
operator|&&
operator|(
name|dname
index|[
literal|1
index|]
operator|)
condition|)
operator|++
name|dname
expr_stmt|;
block|}
else|else
name|dname
operator|=
name|cwd
expr_stmt|;
if|if
condition|(
name|dname
index|[
literal|0
index|]
condition|)
block|{
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|dname
argument_list|)
expr_stmt|;
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'H'
case|:
comment|/* insert name of connected host */
if|if
condition|(
name|logged_in
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s "
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'C'
case|:
comment|/* Insert host:path (colon-mode format. */
if|if
condition|(
name|logged_in
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s:%s "
argument_list|,
name|hostname
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
else|else
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
literal|"(not connected)"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|logged_in
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s:%s\n"
argument_list|,
name|hostname
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|lastlinestart
operator|=
name|q
expr_stmt|;
comment|/* there is a \n at the end. */
name|epromptlen
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|'!'
case|:
case|case
literal|'E'
case|:
comment|/* insert event number */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|eventstr
argument_list|,
literal|"%ld"
argument_list|,
name|eventnumber
argument_list|)
expr_stmt|;
name|q
operator|=
name|Strpcpy
argument_list|(
name|q
argument_list|,
name|eventstr
argument_list|)
expr_stmt|;
break|break;
default|default:
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
comment|/* just copy it; unknown switch */
block|}
else|else
operator|*
name|q
operator|++
operator|=
operator|*
name|p
expr_stmt|;
block|}
operator|*
name|q
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|prompt2
argument_list|,
name|prompt
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_STRFTIME
if|if
condition|(
name|percent_flags
condition|)
block|{
comment|/*	only strftime if the user requested it (with a %something), 			otherwise don't waste time doing nothing. */
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|tyme
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
name|prompt2
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|strftime
argument_list|(
name|prompt2
argument_list|,
sizeof|sizeof
argument_list|(
name|str
argument_list|)
argument_list|,
name|str
argument_list|,
name|localtime
argument_list|(
operator|&
name|tyme
argument_list|)
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|epromptlen
operator|=
call|(
name|size_t
call|)
argument_list|(
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|lastlinestart
argument_list|)
operator|-
operator|(
name|long
operator|)
name|epromptlen
argument_list|)
expr_stmt|;
return|return
operator|(
name|prompt2
operator|)
return|;
block|}
end_function

begin_comment
comment|/* strprompt */
end_comment

begin_comment
comment|/*  * Slice a string up into argc/argv.  */
end_comment

begin_function
name|void
name|makeargv
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|argp
decl_stmt|;
name|margc
operator|=
literal|0
expr_stmt|;
name|argp
operator|=
name|margv
expr_stmt|;
name|stringbase
operator|=
name|line
expr_stmt|;
comment|/* scan from first of buffer */
name|argbase
operator|=
name|argbuf
expr_stmt|;
comment|/* store from first of buffer */
name|slrflag
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
operator|*
name|argp
operator|++
operator|=
name|slurpstring
argument_list|()
operator|)
operator|!=
literal|0
condition|)
name|margc
operator|++
expr_stmt|;
block|}
end_function

begin_comment
comment|/* makeargv */
end_comment

begin_comment
comment|/*  * Parse string into argbuf;  * implemented with FSM to  * handle quoting and strings  */
end_comment

begin_function
name|char
modifier|*
name|slurpstring
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|got_one
init|=
literal|0
decl_stmt|;
specifier|register
name|char
modifier|*
name|sb
init|=
name|stringbase
decl_stmt|;
specifier|register
name|char
modifier|*
name|ap
init|=
name|argbase
decl_stmt|;
name|char
modifier|*
name|tmp
init|=
name|argbase
decl_stmt|;
comment|/* will return this if token found */
if|if
condition|(
operator|*
name|sb
operator|==
literal|'!'
operator|||
operator|*
name|sb
operator|==
literal|'$'
condition|)
block|{
comment|/* recognize ! as a token for shell */
switch|switch
condition|(
name|slrflag
condition|)
block|{
comment|/* and $ as token for macro invoke */
case|case
literal|0
case|:
name|slrflag
operator|++
expr_stmt|;
name|stringbase
operator|++
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|sb
operator|==
literal|'!'
operator|)
condition|?
literal|"!"
else|:
literal|"$"
operator|)
return|;
comment|/* NOTREACHED */
case|case
literal|1
case|:
name|slrflag
operator|++
expr_stmt|;
name|altarg
operator|=
name|stringbase
expr_stmt|;
break|break;
default|default:
break|break;
block|}
block|}
name|S0
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'='
case|:
name|sb
operator|++
expr_stmt|;
goto|goto
name|S0
goto|;
default|default:
switch|switch
condition|(
name|slrflag
condition|)
block|{
case|case
literal|0
case|:
name|slrflag
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|slrflag
operator|++
expr_stmt|;
name|altarg
operator|=
name|sb
expr_stmt|;
break|break;
default|default:
break|break;
block|}
goto|goto
name|S1
goto|;
block|}
name|S1
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|' '
case|:
case|case
literal|'\t'
case|:
case|case
literal|'\n'
case|:
case|case
literal|'='
case|:
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
comment|/* end of token */
case|case
literal|'\\'
case|:
name|sb
operator|++
expr_stmt|;
goto|goto
name|S2
goto|;
comment|/* slurp next character */
case|case
literal|'"'
case|:
name|sb
operator|++
expr_stmt|;
goto|goto
name|S3
goto|;
comment|/* slurp quoted string */
default|default:
operator|*
name|ap
operator|++
operator|=
operator|*
name|sb
operator|++
expr_stmt|;
comment|/* add character to token */
name|got_one
operator|=
literal|1
expr_stmt|;
goto|goto
name|S1
goto|;
block|}
name|S2
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
default|default:
operator|*
name|ap
operator|++
operator|=
operator|*
name|sb
operator|++
expr_stmt|;
name|got_one
operator|=
literal|1
expr_stmt|;
goto|goto
name|S1
goto|;
block|}
name|S3
label|:
switch|switch
condition|(
operator|*
name|sb
condition|)
block|{
case|case
literal|'\0'
case|:
goto|goto
name|OUT
goto|;
case|case
literal|'"'
case|:
name|sb
operator|++
expr_stmt|;
goto|goto
name|S1
goto|;
default|default:
operator|*
name|ap
operator|++
operator|=
operator|*
name|sb
operator|++
expr_stmt|;
name|got_one
operator|=
literal|1
expr_stmt|;
goto|goto
name|S3
goto|;
block|}
name|OUT
label|:
if|if
condition|(
name|got_one
condition|)
operator|*
name|ap
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|argbase
operator|=
name|ap
expr_stmt|;
comment|/* update storage pointer */
name|stringbase
operator|=
name|sb
expr_stmt|;
comment|/* update scan pointer */
if|if
condition|(
name|got_one
condition|)
block|{
return|return
operator|(
name|tmp
operator|)
return|;
block|}
switch|switch
condition|(
name|slrflag
condition|)
block|{
case|case
literal|0
case|:
name|slrflag
operator|++
expr_stmt|;
break|break;
case|case
literal|1
case|:
name|slrflag
operator|++
expr_stmt|;
name|altarg
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
break|break;
default|default:
break|break;
block|}
return|return
operator|(
operator|(
name|char
operator|*
operator|)
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* slurpstring */
end_comment

begin_comment
comment|/*  * Help command.  * Call each command handler with argc == 0 and argv[0] == name.  */
end_comment

begin_function
name|int
name|help
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|register
name|struct
name|cmd
modifier|*
name|c
decl_stmt|;
name|int
name|showall
init|=
literal|0
decl_stmt|,
name|helpall
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|int
name|nRows
decl_stmt|,
name|nCols
decl_stmt|;
name|int
name|nCmds2Print
decl_stmt|;
name|int
name|screenColumns
decl_stmt|;
name|int
name|len
decl_stmt|,
name|widestName
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
modifier|*
name|cmdnames
decl_stmt|,
name|spec
index|[
literal|16
index|]
decl_stmt|;
if|if
condition|(
name|argc
operator|==
literal|2
condition|)
block|{
name|showall
operator|=
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"showall"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
name|helpall
operator|=
operator|(
name|strcmp
argument_list|(
name|argv
index|[
literal|1
index|]
argument_list|,
literal|"helpall"
argument_list|)
operator|==
literal|0
operator|)
expr_stmt|;
block|}
if|if
condition|(
name|argc
operator|==
literal|1
operator|||
name|showall
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\ Commands may be abbreviated.  'help showall' shows aliases, invisible and\n\ unsupported commands.  'help<command>' gives a brief description of<command>.\n\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cmdtab
operator|,
name|nCmds2Print
operator|=
literal|0
init|;
name|c
operator|->
name|c_name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
if|if
condition|(
operator|!
name|c
operator|->
name|c_hidden
operator|||
name|showall
condition|)
name|nCmds2Print
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|cmdnames
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
name|nCmds2Print
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|fatal
argument_list|(
literal|"out of memory!"
argument_list|)
expr_stmt|;
for|for
control|(
name|c
operator|=
name|cmdtab
operator|,
name|i
operator|=
literal|0
operator|,
name|widestName
operator|=
literal|0
init|;
name|c
operator|->
name|c_name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|c
operator|->
name|c_hidden
operator|||
name|showall
condition|)
block|{
name|cmdnames
index|[
name|i
operator|++
index|]
operator|=
name|c
operator|->
name|c_name
expr_stmt|;
name|len
operator|=
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|c
operator|->
name|c_name
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
name|widestName
condition|)
name|widestName
operator|=
name|len
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|(
name|cp
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|screenColumns
operator|=
literal|80
expr_stmt|;
else|else
name|screenColumns
operator|=
name|atoi
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|widestName
operator|+=
literal|2
expr_stmt|;
comment|/* leave room for white-space in between cols. */
name|nCols
operator|=
name|screenColumns
operator|/
name|widestName
expr_stmt|;
comment|/* if ((screenColumns % widestName)> 0) nCols++; */
name|nRows
operator|=
name|nCmds2Print
operator|/
name|nCols
expr_stmt|;
if|if
condition|(
operator|(
name|nCmds2Print
operator|%
name|nCols
operator|)
operator|>
literal|0
condition|)
name|nRows
operator|++
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|spec
argument_list|,
literal|"%%-%ds"
argument_list|,
name|widestName
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nRows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|nCols
condition|;
name|j
operator|++
control|)
block|{
name|k
operator|=
name|nRows
operator|*
name|j
operator|+
name|i
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|nCmds2Print
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
name|spec
argument_list|,
name|cmdnames
index|[
name|k
index|]
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|Free
argument_list|(
name|cmdnames
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|helpall
condition|)
block|{
comment|/* Really intended to debug the help strings. */
for|for
control|(
name|c
operator|=
name|cmdtab
init|;
name|c
operator|->
name|c_name
operator|!=
name|NULL
condition|;
name|c
operator|++
control|)
block|{
name|cmd_help
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cmd_usage
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
operator|--
name|argc
operator|>
literal|0
condition|)
block|{
name|arg
operator|=
operator|*
operator|++
name|argv
expr_stmt|;
name|c
operator|=
name|getcmd
argument_list|(
name|arg
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd
operator|*
operator|)
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"?Ambiguous help command %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
operator|(
expr|struct
name|cmd
operator|*
operator|)
literal|0
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"?Invalid help command %s\n"
argument_list|,
name|arg
argument_list|)
expr_stmt|;
else|else
block|{
name|cmd_help
argument_list|(
name|c
argument_list|)
expr_stmt|;
name|cmd_usage
argument_list|(
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* help */
end_comment

begin_comment
comment|/*  * If the user wants to, s/he can specify the maximum size of the log  * file, so it doesn't waste too much disk space.  If the log is too  * fat, trim the older lines (at the top) until we're under the limit.  */
end_comment

begin_function
name|void
name|trim_log
parameter_list|(
name|void
parameter_list|)
block|{
name|FILE
modifier|*
name|new
decl_stmt|,
modifier|*
name|old
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|long
name|fat
decl_stmt|;
name|string
name|tmplogname
decl_stmt|,
name|str
decl_stmt|;
if|if
condition|(
name|logsize
operator|<=
literal|0
operator|||
operator|*
name|logfname
operator|==
literal|0
operator|||
name|stat
argument_list|(
name|logfname
argument_list|,
operator|&
name|st
argument_list|)
operator|||
operator|(
name|old
operator|=
name|fopen
argument_list|(
name|logfname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return;
comment|/* never trim, or no log */
name|fat
operator|=
name|st
operator|.
name|st_size
operator|-
name|logsize
expr_stmt|;
if|if
condition|(
name|fat
operator|<=
literal|0L
condition|)
return|return;
comment|/* log too small yet */
while|while
condition|(
name|fat
operator|>
literal|0L
condition|)
block|{
if|if
condition|(
name|FGets
argument_list|(
name|str
argument_list|,
name|old
argument_list|)
operator|==
name|NULL
condition|)
return|return;
name|fat
operator|-=
operator|(
name|long
operator|)
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* skip lines until a new site was opened */
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
name|FGets
argument_list|(
name|str
argument_list|,
name|old
argument_list|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|old
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|unlink
argument_list|(
name|logfname
argument_list|)
expr_stmt|;
return|return;
comment|/* nothing left, start anew */
block|}
if|if
condition|(
operator|*
name|str
operator|!=
literal|'\t'
condition|)
break|break;
block|}
comment|/* copy the remaining lines in "old" to "new" */
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|tmplogname
argument_list|,
name|logfname
argument_list|)
expr_stmt|;
name|tmplogname
index|[
name|strlen
argument_list|(
name|tmplogname
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|'T'
expr_stmt|;
if|if
condition|(
operator|(
name|new
operator|=
name|fopen
argument_list|(
name|tmplogname
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|PERROR
argument_list|(
literal|"trim_log"
argument_list|,
name|tmplogname
argument_list|)
expr_stmt|;
return|return;
block|}
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|str
argument_list|,
name|new
argument_list|)
expr_stmt|;
while|while
condition|(
name|FGets
argument_list|(
name|str
argument_list|,
name|old
argument_list|)
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|str
argument_list|,
name|new
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|old
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|unlink
argument_list|(
name|logfname
argument_list|)
operator|<
literal|0
condition|)
name|PERROR
argument_list|(
literal|"trim_log"
argument_list|,
name|logfname
argument_list|)
expr_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|tmplogname
argument_list|,
name|logfname
argument_list|)
operator|<
literal|0
condition|)
name|PERROR
argument_list|(
literal|"trim_log"
argument_list|,
name|tmplogname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* trim_log */
end_comment

begin_function
name|int
name|CheckNewMail
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|stat
name|stbuf
decl_stmt|;
if|if
condition|(
operator|*
name|mail_path
operator|==
literal|'\0'
condition|)
return|return
literal|0
return|;
if|if
condition|(
name|stat
argument_list|(
name|mail_path
argument_list|,
operator|&
name|stbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* cant find mail_path so we'll */
operator|*
name|mail_path
operator|=
literal|'\0'
expr_stmt|;
comment|/* never check it again */
return|return
literal|0
return|;
block|}
comment|/* 	 * Check if the size is non-zero and the access time is less than 	 * the modify time -- this indicates unread mail. 	 */
if|if
condition|(
operator|(
name|stbuf
operator|.
name|st_size
operator|!=
literal|0
operator|)
operator|&&
operator|(
name|stbuf
operator|.
name|st_atime
operator|<=
name|stbuf
operator|.
name|st_mtime
operator|)
condition|)
block|{
if|if
condition|(
name|stbuf
operator|.
name|st_mtime
operator|>
name|mbox_time
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|NEWMAILMESSAGE
argument_list|)
expr_stmt|;
name|mbox_time
operator|=
name|stbuf
operator|.
name|st_mtime
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* CheckNewMail */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|CURSES
end_ifdef

begin_function
name|int
name|termcap_get
parameter_list|(
name|char
modifier|*
modifier|*
name|dest
parameter_list|,
name|char
modifier|*
name|attr
parameter_list|)
block|{
specifier|static
name|char
name|area
index|[
literal|1024
index|]
decl_stmt|;
specifier|static
name|char
modifier|*
name|s
init|=
name|area
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|,
modifier|*
name|cp
decl_stmt|;
name|int
name|i
decl_stmt|,
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|len
init|=
literal|0
decl_stmt|;
operator|*
name|dest
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|attr
operator|!=
literal|'\0'
condition|)
block|{
name|buf
operator|=
name|tgetstr
argument_list|(
name|attr
argument_list|,
operator|&
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|buf
operator|!=
name|NULL
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|buf
index|[
name|i
index|]
operator|<=
literal|'9'
operator|)
operator|&&
operator|(
name|buf
index|[
name|i
index|]
operator|>=
literal|'0'
operator|)
condition|;
control|)
name|i
operator|++
expr_stmt|;
comment|/* Get rid of the terminal delays, like "$<2>". */
if|if
condition|(
operator|(
name|cp
operator|=
name|strstr
argument_list|(
operator|&
operator|(
name|buf
index|[
name|i
index|]
operator|)
argument_list|,
literal|"$<"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
operator|*
name|cp
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|*
name|dest
operator|==
name|NULL
condition|)
operator|*
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|strlen
argument_list|(
operator|&
operator|(
name|buf
index|[
name|i
index|]
operator|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
else|else
operator|*
name|dest
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
operator|*
name|dest
argument_list|,
name|len
operator|+
name|strlen
argument_list|(
operator|&
operator|(
name|buf
index|[
name|i
index|]
operator|)
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|dest
operator|==
name|NULL
condition|)
break|break;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
operator|*
name|dest
operator|+
name|len
argument_list|,
operator|&
operator|(
name|buf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
name|len
operator|+=
name|strlen
argument_list|(
operator|&
operator|(
name|buf
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
name|attr
operator|+=
literal|2
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|dest
operator|==
name|NULL
condition|)
operator|*
name|dest
operator|=
literal|""
expr_stmt|;
else|else
name|result
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* termcap_get */
end_comment

begin_function
name|void
name|termcap_init
parameter_list|(
name|void
parameter_list|)
block|{
name|char
modifier|*
name|term
decl_stmt|;
if|if
condition|(
operator|(
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|term
operator|=
literal|"dumb"
expr_stmt|;
comment|/* TAR */
name|ansi_escapes
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|tgetent
argument_list|(
name|tcbuf
argument_list|,
name|term
argument_list|)
operator|!=
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Can't get termcap entry for terminal [%s]\n"
argument_list|,
name|term
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|termcap_get
argument_list|(
operator|&
name|tcap_normal
argument_list|,
literal|"meuese"
argument_list|)
expr_stmt|;
if|if
condition|(
name|termcap_get
argument_list|(
operator|&
name|tcap_boldface
argument_list|,
literal|"md"
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* Dim-mode is better than nothing... */
operator|(
name|void
operator|)
name|termcap_get
argument_list|(
operator|&
name|tcap_boldface
argument_list|,
literal|"mh"
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|termcap_get
argument_list|(
operator|&
name|tcap_underline
argument_list|,
literal|"us"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|termcap_get
argument_list|(
operator|&
name|tcap_reverse
argument_list|,
literal|"so"
argument_list|)
expr_stmt|;
name|tcl_normal
operator|=
name|strlen
argument_list|(
name|tcap_normal
argument_list|)
expr_stmt|;
name|tcl_bold
operator|=
name|strlen
argument_list|(
name|tcap_boldface
argument_list|)
expr_stmt|;
name|tcl_uline
operator|=
name|strlen
argument_list|(
name|tcap_underline
argument_list|)
expr_stmt|;
name|tcl_rev
operator|=
name|strlen
argument_list|(
name|tcap_reverse
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* termcap_init */
end_comment

begin_function
specifier|static
name|int
name|c_output
parameter_list|(
name|int
name|c
parameter_list|)
block|{
return|return
operator|(
name|putchar
argument_list|(
name|c
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* c_output */
end_comment

begin_function
name|void
name|tcap_put
parameter_list|(
name|char
modifier|*
name|cap
parameter_list|)
block|{
name|tputs
argument_list|(
name|cap
argument_list|,
literal|0
argument_list|,
name|c_output
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* tcap_put */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* CURSES */
end_comment

begin_comment
comment|/* eof main.c */
end_comment

end_unit

