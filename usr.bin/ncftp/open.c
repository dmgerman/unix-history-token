begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* open.c */
end_comment

begin_comment
comment|/*  $RCSfile: open.c,v $  *  $Revision: 1.1 $  *  $Date: 93/07/09 11:27:07 $  */
end_comment

begin_include
include|#
directive|include
file|"sys.h"
end_include

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"open.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"ftp.h"
end_include

begin_include
include|#
directive|include
file|"ftprc.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"copyright.h"
end_include

begin_comment
comment|/* open.c globals */
end_comment

begin_decl_stmt
name|int
name|remote_is_unix
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if remote host is unix. */
end_comment

begin_decl_stmt
name|int
name|auto_binary
init|=
name|dAUTOBINARY
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|anon_open
init|=
name|dANONOPEN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Anonymous logins by default? */
end_comment

begin_decl_stmt
name|int
name|connected
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE if connected to server */
end_comment

begin_comment
comment|/* If TRUE, set binary each connection. */
end_comment

begin_decl_stmt
name|int
name|www
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* TRUE	if use URL */
end_comment

begin_decl_stmt
name|Hostname
name|hostname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Name of current host */
end_comment

begin_decl_stmt
name|RemoteSiteInfo
name|gRmtInfo
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATEWAY
end_ifdef

begin_decl_stmt
name|string
name|gateway
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* node name of firewall gateway */
end_comment

begin_decl_stmt
name|string
name|gate_login
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* login at firewall gateway */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* open.c externs */
end_comment

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|reply_string
decl_stmt|,
modifier|*
name|line
decl_stmt|,
modifier|*
name|Optarg
decl_stmt|,
modifier|*
name|margv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|Optind
decl_stmt|,
name|margc
decl_stmt|,
name|verbose
decl_stmt|,
name|macnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|long
name|eventnumber
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|servent
name|serv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|cout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|string
name|anon_password
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Given a pointer to an OpenOptions (structure containing all variables  * that can be set from the command line), this routine makes sure all  * the variables have valid values by setting them to their defaults.  */
end_comment

begin_function
name|void
name|InitOpenOptions
parameter_list|(
name|OpenOptions
modifier|*
name|openopt
parameter_list|)
block|{
comment|/* How do you want to open a site if neither -a or -u are given? 	 * anon_open is true (default to anonymous login), unless 	 * defaults.h was edited to set dANONOPEN to 0 instead. 	 */
name|openopt
operator|->
name|openmode
operator|=
name|anon_open
condition|?
name|openImplicitAnon
else|:
name|openImplicitUser
expr_stmt|;
comment|/* Normally you don't want to ignore the entry in your netrc. */
name|openopt
operator|->
name|ignore_rc
operator|=
literal|0
expr_stmt|;
comment|/* Set the default delay if the user specifies redial mode without 	 * specifying the redial delay. 	 */
name|openopt
operator|->
name|redial_delay
operator|=
name|dREDIALDELAY
expr_stmt|;
comment|/* Normally, you only want to try once. If you specify redial mode, 	 * this is changed. 	 */
name|openopt
operator|->
name|max_dials
operator|=
literal|1
expr_stmt|;
comment|/* You don't want to cat the file to stdout by default. */
name|openopt
operator|->
name|ftpcat
operator|=
name|NO_FTPCAT
expr_stmt|;
comment|/* Setup the port number to try. */
ifdef|#
directive|ifdef
name|dFTP_PORT
comment|/* If dFTP_PORT is defined, we use a different port number by default 	 * than the one supplied in the servent structure. 	 */
name|openopt
operator|->
name|port
operator|=
name|dFTP_PORT
expr_stmt|;
comment|/* Make sure the correct byte order is supplied! */
name|openopt
operator|->
name|port
operator|=
name|htons
argument_list|(
name|openopt
operator|->
name|port
argument_list|)
expr_stmt|;
else|#
directive|else
comment|/* Use the port number supplied by the operating system's servent 	 * structure. 	 */
name|openopt
operator|->
name|port
operator|=
name|serv
operator|.
name|s_port
expr_stmt|;
endif|#
directive|endif
comment|/* We are not in colon-mode (yet). */
name|openopt
operator|->
name|colonmodepath
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set the hostname to a null string, since there is no default host. */
name|openopt
operator|->
name|hostname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Set the opening directory path to a null string. */
name|openopt
operator|->
name|cdpath
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
block|}
end_function

begin_comment
comment|/* InitOpenOptions */
end_comment

begin_comment
comment|/* This is responsible for parsing the command line and setting variables  * in the OpenOptions structure according to the user's flags.  */
end_comment

begin_function
name|int
name|GetOpenOptions
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
name|OpenOptions
modifier|*
name|openopt
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|hostp
decl_stmt|,
modifier|*
name|cpath
decl_stmt|;
comment|/* First setup the openopt variables. */
name|InitOpenOptions
argument_list|(
name|openopt
argument_list|)
expr_stmt|;
comment|/* Tell Getopt() that we want to start over with a new command. */
name|Getopt_Reset
argument_list|()
expr_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|Getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"aiup:rd:g:cm"
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'a'
case|:
comment|/* User wants to open anonymously. */
name|openopt
operator|->
name|openmode
operator|=
name|openExplicitAnon
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
comment|/* User wants to open with a login and password. */
name|openopt
operator|->
name|openmode
operator|=
name|openExplicitUser
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
comment|/* User wants to ignore the entry in the netrc. */
name|openopt
operator|->
name|ignore_rc
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
comment|/* User supplied a port number different from the default 				 * ftp port. 				 */
name|openopt
operator|->
name|port
operator|=
name|atoi
argument_list|(
name|Optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|openopt
operator|->
name|port
operator|<=
literal|0
condition|)
block|{
comment|/* Probably never happen, but just in case. */
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: bad port number (%s).\n"
argument_list|,
name|argv
index|[
literal|0
index|]
argument_list|,
name|Optarg
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
comment|/* Must ensure that the port is in the correct byte order! */
name|openopt
operator|->
name|port
operator|=
name|htons
argument_list|(
name|openopt
operator|->
name|port
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
comment|/* User supplied a delay (in seconds) that differs from 				 * the default. 				 */
name|openopt
operator|->
name|redial_delay
operator|=
name|atoi
argument_list|(
name|Optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'g'
case|:
comment|/* User supplied an upper-bound on the number of redials 				 * to try. 				 */
name|openopt
operator|->
name|max_dials
operator|=
name|atoi
argument_list|(
name|Optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|openopt
operator|->
name|max_dials
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* ftpcat mode is only available from your shell command-line, 				 * not from the ncftp shell.  Do that yourself with 'more zz'. 				 */
if|if
condition|(
name|eventnumber
operator|==
literal|0L
condition|)
block|{
comment|/* If eventnumber is zero, then we were called directly 					 * from main(), and before the ftp shell has started. 					 */
name|openopt
operator|->
name|ftpcat
operator|=
name|FTPMORE
expr_stmt|;
comment|/* ftpcat mode is really ftpmore mode. */
break|break;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You can only use this form of colon-mode (-m) from your shell command line.\n\ Try 'ncftp -m wuarchive.wustl.edu:/README'\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
comment|/* break; */
case|case
literal|'c'
case|:
comment|/* ftpcat mode is only available from your shell command-line, 				 * not from the ncftp shell.  Do that yourself with 'get zz -'. 				 */
if|if
condition|(
name|eventnumber
operator|==
literal|0L
condition|)
block|{
comment|/* If eventnumber is zero, then we were called directly 					 * from main(), and before the ftp shell has started. 					 */
name|openopt
operator|->
name|ftpcat
operator|=
name|FTPCAT
expr_stmt|;
break|break;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You can only use ftpcat/colon-mode from your shell command line.\n\ Try 'ncftp -c wuarchive.wustl.edu:/README> file.'\n"
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
comment|/* break; */
default|default:
name|usage
label|:
return|return
name|USAGE
return|;
block|}
block|}
if|if
condition|(
name|argv
index|[
name|Optind
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* No host was supplied.  Print out the list of sites we know 		 * about and ask the user for one. 		 */
name|PrintSiteList
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|Gets
argument_list|(
literal|"(site to open) "
argument_list|,
name|openopt
operator|->
name|hostname
argument_list|,
sizeof|sizeof
argument_list|(
name|openopt
operator|->
name|hostname
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Make sure the user just didn't hit return, in which case we 		 * just give up and go home. 		 */
if|if
condition|(
name|openopt
operator|->
name|hostname
index|[
literal|0
index|]
operator|==
literal|0
condition|)
goto|goto
name|usage
goto|;
block|}
else|else
block|{
comment|/* The user gave us a host to open. 		 * 		 * First, check to see if they gave us a colon-mode path 		 * along with the hostname.  We also understand a WWW path, 		 * like "ftp://bang.nta.no/pub/fm2html.v.0.8.4.tar.Z". 		 */
name|hostp
operator|=
name|argv
index|[
name|Optind
index|]
expr_stmt|;
name|cpath
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|hostp
argument_list|,
literal|':'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cpath
operator|=
name|cp
expr_stmt|;
name|www
operator|=
literal|0
expr_stmt|;
comment|/* Is 0 or 1, depending on the type of path. */
if|if
condition|(
operator|(
operator|*
name|cp
operator|==
literal|'/'
operator|)
operator|&&
operator|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'/'
operator|)
condition|)
block|{
comment|/* First make sure the path was intended to be used 				 * with ftp and not one of the other URLs. 				 */
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|Optind
index|]
argument_list|,
literal|"ftp"
argument_list|)
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Bad URL '%s' -- WWW paths must be prefixed by 'ftp://'.\n"
argument_list|,
name|argv
index|[
name|Optind
index|]
argument_list|)
expr_stmt|;
goto|goto
name|usage
goto|;
block|}
name|cp
operator|+=
literal|2
expr_stmt|;
name|hostp
operator|=
name|cp
expr_stmt|;
name|cpath
operator|=
name|NULL
expr_stmt|;
comment|/* It could have been ftp://hostname only. */
if|if
condition|(
operator|(
name|cp
operator|=
name|index
argument_list|(
name|hostp
argument_list|,
literal|'/'
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|cp
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|cpath
operator|=
name|cp
expr_stmt|;
block|}
name|www
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|cpath
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|openopt
operator|->
name|colonmodepath
argument_list|,
name|www
condition|?
literal|"/"
else|:
literal|""
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|openopt
operator|->
name|colonmodepath
argument_list|,
name|cpath
argument_list|)
expr_stmt|;
name|dbprintf
argument_list|(
literal|"Colon-Mode Path = '%s'\n"
argument_list|,
name|openopt
operator|->
name|colonmodepath
argument_list|)
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|openopt
operator|->
name|hostname
argument_list|,
name|hostp
argument_list|)
expr_stmt|;
name|dbprintf
argument_list|(
literal|"Host = '%s'\n"
argument_list|,
name|hostp
argument_list|)
expr_stmt|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* GetOpenOptions */
end_comment

begin_comment
comment|/* This examines the format of the string stored in the hostname  * field of the OpenOptions, and sees if has to strip out a colon-mode  * pathname (to store in the colonmodepath field).  Since colon-mode  * is run quietly (without any output being generated), we init the  * login_verbosity variable here to quiet if we are running colon-mode.  */
end_comment

begin_function
name|int
name|CheckForColonMode
parameter_list|(
name|OpenOptions
modifier|*
name|openopt
parameter_list|,
name|int
modifier|*
name|login_verbosity
parameter_list|)
block|{
comment|/* Usually the user doesn't supply hostname in colon-mode format, 	 * and wants to interactively browse the remote host, so set the 	 * login_verbosity to whatever it is set to now. 	 */
operator|*
name|login_verbosity
operator|=
name|verbose
expr_stmt|;
if|if
condition|(
name|openopt
operator|->
name|colonmodepath
index|[
literal|0
index|]
operator|!=
literal|0
condition|)
block|{
comment|/* But if the user does use colon-mode, we want to do our business 		 * and leave, without all the login messages, etc., so set 		 * login_verbosity to quiet so we won't print anything until 		 * we finish.  Colon-mode can be specified from the shell command 		 * line, so we would like to be able to execute ncftp as a one 		 * line command from the shell without spewing gobs of output. 		 */
operator|*
name|login_verbosity
operator|=
name|V_QUIET
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openopt
operator|->
name|ftpcat
operator|!=
literal|0
condition|)
block|{
comment|/* User specified ftpcat mode, but didn't supply the host:file. */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"You didn't use colon mode correctly.\n\ If you use -c or -m, you need to do something like this:\n\ 	ncftp -c wuarchive.wustl.edu:/pub/README (to cat this file to stdout).\n"
argument_list|)
expr_stmt|;
return|return
name|USAGE
return|;
block|}
return|return
name|NOERR
return|;
block|}
end_function

begin_comment
comment|/* CheckForColonMode */
end_comment

begin_comment
comment|/* All this short routine does is to hookup a socket to either the  * remote host or the firewall gateway host.  */
end_comment

begin_function
name|int
name|HookupToRemote
parameter_list|(
name|OpenOptions
modifier|*
name|openopt
parameter_list|)
block|{
name|int
name|hErr
decl_stmt|;
ifdef|#
directive|ifdef
name|GATEWAY
comment|/* Try connecting to the gateway host. */
if|if
condition|(
operator|*
name|gateway
condition|)
block|{
name|hErr
operator|=
name|hookup
argument_list|(
name|gateway
argument_list|,
name|openopt
operator|->
name|port
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|hostname
argument_list|,
name|openopt
operator|->
name|hostname
argument_list|)
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|hErr
operator|=
name|hookup
argument_list|(
name|openopt
operator|->
name|hostname
argument_list|,
name|openopt
operator|->
name|port
argument_list|)
expr_stmt|;
return|return
name|hErr
return|;
block|}
end_function

begin_comment
comment|/* HookupToRemote */
end_comment

begin_function
name|void
name|CheckRemoteSystemType
parameter_list|(
name|int
name|force_binary
parameter_list|)
block|{
name|int
name|tmpverbose
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
name|c
decl_stmt|;
comment|/* As of this writing, UNIX is pretty much standard. */
name|remote_is_unix
operator|=
literal|1
expr_stmt|;
comment|/* Do a SYSTem command quietly. */
name|tmpverbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
literal|"SYST"
argument_list|)
operator|==
name|COMPLETE
condition|)
block|{
if|if
condition|(
name|tmpverbose
operator|==
name|V_VERBOSE
condition|)
block|{
comment|/* Find the system type embedded in the reply_string, 			 * and separate it from the rest of the junk. 			 */
name|cp
operator|=
name|index
argument_list|(
name|reply_string
operator|+
literal|4
argument_list|,
literal|' '
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
name|cp
operator|=
name|index
argument_list|(
name|reply_string
operator|+
literal|4
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
block|{
if|if
condition|(
name|cp
index|[
operator|-
literal|1
index|]
operator|==
literal|'.'
condition|)
name|cp
operator|--
expr_stmt|;
name|c
operator|=
operator|*
name|cp
expr_stmt|;
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Remote system type is %s.\n"
argument_list|,
name|reply_string
operator|+
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
condition|)
operator|*
name|cp
operator|=
name|c
expr_stmt|;
block|}
name|remote_is_unix
operator|=
operator|!
name|strncmp
argument_list|(
name|reply_string
operator|+
literal|4
argument_list|,
literal|"UNIX"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* Set to binary mode if any of the following are true: 	 * (a) The user has auto-binary set; 	 * (b) The user is using colon-mode (force_binary); 	 * (c) The reply-string from SYST said it was UNIX with 8-bit chars. 	 */
if|if
condition|(
name|auto_binary
operator|||
name|force_binary
operator|||
operator|!
name|strncmp
argument_list|(
name|reply_string
argument_list|,
literal|"215 UNIX Type: L8"
argument_list|,
operator|(
name|size_t
operator|)
literal|17
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|_settype
argument_list|(
literal|"binary"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpverbose
operator|>
name|V_TERSE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Using binary mode to transfer files.\n"
argument_list|)
expr_stmt|;
block|}
comment|/* Print a warning for that (extremely) rare Tenex machine. */
if|if
condition|(
name|tmpverbose
operator|>=
name|V_ERRS
operator|&&
operator|!
name|strncmp
argument_list|(
name|reply_string
argument_list|,
literal|"215 TOPS20"
argument_list|,
operator|(
name|size_t
operator|)
literal|10
argument_list|)
condition|)
block|{
operator|(
name|void
operator|)
name|_settype
argument_list|(
literal|"tenex"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Using tenex mode to transfer files.\n"
argument_list|)
expr_stmt|;
block|}
name|verbose
operator|=
name|tmpverbose
expr_stmt|;
block|}
end_function

begin_comment
comment|/* CheckRemoteSystemType */
end_comment

begin_comment
comment|/* This is called if the user opened the host with a file appended to  * the host's name, like "wuarchive.wustl.edu:/pub/readme," or  * "wuarchive.wustl.edu:/pub."  In the former case, we open wuarchive,  * and fetch "readme."  In the latter case, we open wuarchive, then set  * the current remote directory to "/pub."  If we are fetching a file,  * we can do some other tricks if "ftpcat mode" is enabled.  This mode  * must be selected from your shell's command line, and this allows you  * to use the program as a one-liner to pipe a remote file into something,  * like "ncftp -c wu:/pub/README | wc."  If the user uses ftpcat mode,  * the program immediately quits instead of going into it's own command  * shell.  */
end_comment

begin_function
name|void
name|ColonMode
parameter_list|(
name|OpenOptions
modifier|*
name|openopt
parameter_list|)
block|{
name|int
name|tmpverbose
decl_stmt|;
name|int
name|cmdstatus
decl_stmt|;
comment|/* How do we tell if colonmodepath is a file or a directory? 	 * We first try cd'ing to the path first.  If we can, then it 	 * was a directory.  If we could not, we'll assume it was a file. 	 */
comment|/* Shut up, so cd won't print 'foobar: Not a directory.' */
name|tmpverbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
comment|/* If we are using ftpcat|more mode, or we couldn't cd to the 	 * colon-mode path (then it must be a file to fetch), then 	 * we need to fetch a file. 	 */
if|if
condition|(
name|openopt
operator|->
name|ftpcat
operator|||
operator|!
name|_cd
argument_list|(
name|openopt
operator|->
name|colonmodepath
argument_list|)
condition|)
block|{
comment|/* We call the appropriate fetching routine, so we have to 		 * have the argc and argv set up correctly.  To do this, 		 * we just make an entire command line, then let makeargv() 		 * convert it to argv/argc. 		 */
if|if
condition|(
name|openopt
operator|->
name|ftpcat
operator|==
name|FTPCAT
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"get %s -"
argument_list|,
name|openopt
operator|->
name|colonmodepath
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|openopt
operator|->
name|ftpcat
operator|==
name|FTPMORE
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"more %s"
argument_list|,
name|openopt
operator|->
name|colonmodepath
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* Regular colon-mode, where we fetch the file, putting the 			 * copy in the current local directory. 			 */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|line
argument_list|,
literal|"mget %s"
argument_list|,
name|openopt
operator|->
name|colonmodepath
argument_list|)
expr_stmt|;
block|}
name|makeargv
argument_list|()
expr_stmt|;
comment|/* Turn on messaging if we aren't catting. */
if|if
condition|(
name|openopt
operator|->
name|ftpcat
operator|==
literal|0
condition|)
name|verbose
operator|=
name|tmpverbose
expr_stmt|;
comment|/* get() also handles 'more'. */
if|if
condition|(
name|openopt
operator|->
name|ftpcat
condition|)
name|cmdstatus
operator|=
name|get
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
expr_stmt|;
else|else
name|cmdstatus
operator|=
name|mget
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
expr_stmt|;
comment|/* If we were invoked from the command line, quit 		 * after we got this file. 		 */
if|if
condition|(
name|eventnumber
operator|==
literal|0L
condition|)
block|{
operator|(
name|void
operator|)
name|quit
argument_list|(
name|cmdstatus
operator|==
name|CMDERR
condition|?
operator|-
literal|1
else|:
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
block|}
name|verbose
operator|=
name|tmpverbose
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ColonMode */
end_comment

begin_comment
comment|/* Given a properly set up OpenOptions, we try connecting to the site,  * redialing if necessary, and do some initialization steps so the user  * can send commands.  */
end_comment

begin_function
name|int
name|Open
parameter_list|(
name|OpenOptions
modifier|*
name|openopt
parameter_list|)
block|{
name|int
name|hErr
decl_stmt|;
name|int
name|dials
decl_stmt|;
name|char
modifier|*
name|ruser
decl_stmt|,
modifier|*
name|rpass
decl_stmt|,
modifier|*
name|racct
decl_stmt|;
name|int
name|siteInRC
decl_stmt|;
name|char
modifier|*
name|user
decl_stmt|,
modifier|*
name|pass
decl_stmt|,
modifier|*
name|acct
decl_stmt|;
name|int
name|login_verbosity
decl_stmt|,
name|oldv
decl_stmt|;
name|int
name|result
init|=
name|CMDERR
decl_stmt|;
name|macnum
operator|=
literal|0
expr_stmt|;
comment|/* Reset macros. */
comment|/* If the hostname supplied is in the form host.name.str:/path/file, 	 * then colon mode was used, and we need to fix the hostname to be 	 * just the hostname, copy the /path/file to colonmode path, and init 	 * the login_verbosity variable. 	 */
if|if
condition|(
name|CheckForColonMode
argument_list|(
name|openopt
argument_list|,
operator|&
name|login_verbosity
argument_list|)
operator|==
name|USAGE
condition|)
return|return
name|USAGE
return|;
comment|/* If the hostname supplied was an abbreviation, such as just 	 * "wu" (wuarchive.wustl.edu), look through the list of sites 	 * we know about and get the whole name.  We also would like 	 * the path we want to start out in, if it is available. 	 */
name|GetFullSiteName
argument_list|(
name|openopt
operator|->
name|hostname
argument_list|,
name|openopt
operator|->
name|cdpath
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|GATEWAY
comment|/* Make sure the gateway host name is a full name and not an 	 * abbreviation. 	 */
if|if
condition|(
operator|*
name|gateway
condition|)
name|GetFullSiteName
argument_list|(
name|gateway
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|ruser
operator|=
name|rpass
operator|=
name|racct
operator|=
name|NULL
expr_stmt|;
comment|/* This also loads the init macro. */
name|siteInRC
operator|=
name|ruserpass2
argument_list|(
name|openopt
operator|->
name|hostname
argument_list|,
operator|&
name|ruser
argument_list|,
operator|&
name|rpass
argument_list|,
operator|&
name|racct
argument_list|)
expr_stmt|;
if|if
condition|(
name|ISANONOPEN
argument_list|(
name|openopt
operator|->
name|openmode
argument_list|)
condition|)
block|{
name|user
operator|=
literal|"anonymous"
expr_stmt|;
name|pass
operator|=
name|anon_password
expr_stmt|;
block|}
else|else
block|{
name|user
operator|=
name|NULL
expr_stmt|;
name|pass
operator|=
name|NULL
expr_stmt|;
block|}
name|acct
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|siteInRC
operator|&&
operator|!
name|openopt
operator|->
name|ignore_rc
condition|)
block|{
name|acct
operator|=
name|racct
expr_stmt|;
if|if
condition|(
name|ruser
operator|!=
name|NULL
condition|)
block|{
comment|/* We were given a username.  If we were given explicit 			 * instructions from the command line, follow those and 			 * ignore what the RC had.  Otherwise if no -a or -u 			 * was specified, we use whatever was in the RC. 			 */
if|if
condition|(
name|ISIMPLICITOPEN
argument_list|(
name|openopt
operator|->
name|openmode
argument_list|)
condition|)
block|{
name|user
operator|=
name|ruser
expr_stmt|;
name|pass
operator|=
name|rpass
expr_stmt|;
block|}
block|}
block|}
for|for
control|(
name|dials
operator|=
literal|0
init|;
name|openopt
operator|->
name|max_dials
operator|<
literal|0
operator|||
name|dials
operator|<
name|openopt
operator|->
name|max_dials
condition|;
name|dials
operator|++
control|)
block|{
if|if
condition|(
name|dials
operator|>
literal|0
condition|)
block|{
comment|/* If this is the second dial or higher, sleep a bit. */
operator|(
name|void
operator|)
name|sleep
argument_list|(
name|openopt
operator|->
name|redial_delay
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Retry Number: %d\n"
argument_list|,
name|dials
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|hErr
operator|=
name|HookupToRemote
argument_list|(
name|openopt
argument_list|)
operator|)
operator|==
operator|-
literal|2
condition|)
comment|/* Recoverable, so we can try re-dialing. */
continue|continue;
elseif|else
if|if
condition|(
name|hErr
operator|==
name|NOERR
condition|)
block|{
comment|/* We were hookup'd successfully. */
name|connected
operator|=
literal|1
expr_stmt|;
name|oldv
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|login_verbosity
expr_stmt|;
ifdef|#
directive|ifdef
name|GATEWAY
if|if
condition|(
operator|*
name|gateway
condition|)
block|{
if|if
condition|(
operator|(
name|Login
argument_list|(
name|user
argument_list|,
name|pass
argument_list|,
name|acct
argument_list|,
operator|(
operator|!
name|openopt
operator|->
name|ignore_rc
operator|&&
operator|!
name|openopt
operator|->
name|colonmodepath
index|[
literal|0
index|]
operator|)
argument_list|)
operator|!=
name|NOERR
operator|)
operator|||
name|cout
operator|==
name|NULL
condition|)
goto|goto
name|nextdial
goto|;
comment|/* error! */
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|GATEWAY
if|if
condition|(
operator|!
operator|*
name|gateway
condition|)
block|{
endif|#
directive|endif
comment|/* We don't want to run the init macro for colon-mode. */
if|if
condition|(
operator|(
name|Login
argument_list|(
name|user
argument_list|,
name|pass
argument_list|,
name|acct
argument_list|,
operator|(
operator|!
name|openopt
operator|->
name|ignore_rc
operator|&&
operator|!
name|openopt
operator|->
name|colonmodepath
index|[
literal|0
index|]
operator|)
argument_list|)
operator|!=
name|NOERR
operator|)
operator|||
name|cout
operator|==
name|NULL
condition|)
block|{
goto|goto
name|nextdial
goto|;
comment|/* error! */
block|}
ifdef|#
directive|ifdef
name|GATEWAY
block|}
endif|#
directive|endif
name|verbose
operator|=
name|oldv
expr_stmt|;
comment|/* We need to check for unix and see if we should set binary 			 * mode automatically. 			 */
name|CheckRemoteSystemType
argument_list|(
name|openopt
operator|->
name|colonmodepath
index|[
literal|0
index|]
operator|!=
operator|(
name|char
operator|)
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|openopt
operator|->
name|colonmodepath
index|[
literal|0
index|]
condition|)
block|{
name|ColonMode
argument_list|(
name|openopt
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|openopt
operator|->
name|cdpath
index|[
literal|0
index|]
condition|)
block|{
comment|/* If we didn't have a colon-mode path, we try setting 				 * the current remote directory to cdpath.  cdpath is 				 * usually the last directory we were in the previous 				 * time we called this site. 				 */
operator|(
name|void
operator|)
name|_cd
argument_list|(
name|openopt
operator|->
name|cdpath
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Freshen 'cwd' variable for the prompt.  				 * We have to do atleast one 'cd' so our variable 				 * cwd (which is saved by _cd()) is set to something 				 * valid. 				 */
operator|(
name|void
operator|)
name|_cd
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
block|}
name|result
operator|=
name|NOERR
expr_stmt|;
break|break;
comment|/* we are connected, so break the redial loop. */
comment|/* end if we are connected */
block|}
else|else
block|{
comment|/* Irrecoverable error, so don't bother redialing. */
comment|/* The error message should have already been printed 			 * from Hookup(). 			 */
break|break;
block|}
name|nextdial
label|:
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
continue|continue;
comment|/* Try re-dialing. */
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Open */
end_comment

begin_comment
comment|/* This stub is called by our command parser. */
end_comment

begin_function
name|int
name|cmdOpen
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|OpenOptions
name|openopt
decl_stmt|;
name|int
name|result
init|=
name|NOERR
decl_stmt|;
comment|/* If there is already a site open, close that one so we can 	 * open a new one. 	 */
if|if
condition|(
name|connected
operator|&&
name|NOT_VQUIET
operator|&&
name|hostname
index|[
literal|0
index|]
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Closing %s...\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|disconnect
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
comment|/* Reset the remote info structure for the new site we want to open. 	 * Assume we have these properties until we discover otherwise. 	 */
name|gRmtInfo
operator|.
name|hasSIZE
operator|=
literal|1
expr_stmt|;
name|gRmtInfo
operator|.
name|hasMDTM
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|(
name|GetOpenOptions
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|openopt
argument_list|)
operator|==
name|USAGE
operator|)
operator|||
operator|(
operator|(
name|result
operator|=
name|Open
argument_list|(
operator|&
name|openopt
argument_list|)
operator|)
operator|==
name|USAGE
operator|)
condition|)
return|return
name|USAGE
return|;
comment|/* Return an error if colon-mode/URL didn't work. */
return|return
operator|(
name|openopt
operator|.
name|colonmodepath
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|result
else|:
name|NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* cmdOpen */
end_comment

begin_comment
comment|/* eof open.c */
end_comment

end_unit

