begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ftp.c */
end_comment

begin_comment
comment|/*  $RCSfile: ftp.c,v $  *  $Revision: 14020.12 $  *  $Date: 93/07/09 11:30:28 $  */
end_comment

begin_include
include|#
directive|include
file|"sys.h"
end_include

begin_include
include|#
directive|include
file|<setjmp.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|AIX
end_ifndef

begin_comment
comment|/* AIX-2.2.1 declares utimbuf in unistd.h */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|NO_UTIMEH
end_ifdef

begin_struct
struct|struct
name|utimbuf
block|{
name|time_t
name|actime
decl_stmt|;
name|time_t
name|modtime
decl_stmt|;
block|}
struct|;
end_struct

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<utime.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*AIX*/
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSLOG
end_ifdef

begin_include
include|#
directive|include
file|<syslog.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* You may need this for declarations of fd_set, etc. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|SYSSELECTH
end_ifdef

begin_include
include|#
directive|include
file|<sys/select.h>
end_include

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|STRICT_PROTOS
end_ifdef

begin_ifndef
ifndef|#
directive|ifndef
name|Select
end_ifndef

begin_function_decl
specifier|extern
name|int
name|select
parameter_list|(
name|int
parameter_list|,
name|fd_set
modifier|*
parameter_list|,
name|fd_set
modifier|*
parameter_list|,
name|fd_set
modifier|*
parameter_list|,
name|struct
name|timeval
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netinet/in.h>
end_include

begin_include
include|#
directive|include
file|<arpa/ftp.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_include
include|#
directive|include
file|<arpa/telnet.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|NET_ERRNO_H
end_ifdef

begin_include
include|#
directive|include
file|<net/errno.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<netdb.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"util.h"
end_include

begin_include
include|#
directive|include
file|"ftp.h"
end_include

begin_include
include|#
directive|include
file|"cmds.h"
end_include

begin_include
include|#
directive|include
file|"main.h"
end_include

begin_include
include|#
directive|include
file|"ftprc.h"
end_include

begin_include
include|#
directive|include
file|"getpass.h"
end_include

begin_include
include|#
directive|include
file|"defaults.h"
end_include

begin_include
include|#
directive|include
file|"copyright.h"
end_include

begin_comment
comment|/* ftp.c globals */
end_comment

begin_decl_stmt
name|struct
name|sockaddr_in
name|hisctladdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|data_addr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|data
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|abrtflag
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|sockaddr_in
name|myctladdr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|cin
init|=
name|NULL
decl_stmt|,
modifier|*
name|cout
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|reply_string
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pad3a
index|[
literal|8
index|]
init|=
literal|"Pad 3a"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For SunOS :-( */
end_comment

begin_decl_stmt
name|jmp_buf
name|sendabort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pad3b
index|[
literal|8
index|]
init|=
literal|"Pad 3b"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|jmp_buf
name|recvabort
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|pad3c
index|[
literal|8
index|]
init|=
literal|"Pad 3c"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|progress_meter
init|=
name|dPROGRESS
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cur_progress_meter
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sendport
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use PORT cmd for each data connection */
end_comment

begin_decl_stmt
name|int
name|using_pasv
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|code
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* return/reply code for ftp command */
end_comment

begin_decl_stmt
name|string
name|indataline
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|cpend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* flag: if != 0, then pending server reply */
end_comment

begin_decl_stmt
name|char
modifier|*
name|xferbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for local and remote I/O */
end_comment

begin_decl_stmt
name|size_t
name|xferbufsize
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* size in bytes, of the transfer buffer. */
end_comment

begin_decl_stmt
name|long
name|next_report
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|bytes
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|now_sec
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|long
name|file_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|timeval
name|start
decl_stmt|,
name|stop
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|buffer_only
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* True if reading into redir line 										 * buffer only (not echoing to 										 * stdout). 										 */
end_comment

begin_comment
comment|/* ftp.c externs */
end_comment

begin_decl_stmt
specifier|extern
name|FILE
modifier|*
name|logf
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|string
name|anon_password
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|longstring
name|cwd
decl_stmt|,
name|lcwd
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|Hostname
name|hostname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|verbose
decl_stmt|,
name|debug
decl_stmt|,
name|macnum
decl_stmt|,
name|margc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|curtype
decl_stmt|,
name|creating
decl_stmt|,
name|toatty
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|options
decl_stmt|,
name|activemcmd
decl_stmt|,
name|paging
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|ansi_escapes
decl_stmt|,
name|logged_in
decl_stmt|,
name|macnum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|line
decl_stmt|,
modifier|*
name|margv
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tcap_normal
decl_stmt|,
modifier|*
name|tcap_boldface
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|tcap_underline
decl_stmt|,
modifier|*
name|tcap_reverse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|userinfo
name|uinfo
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|macel
name|macros
index|[]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|lslist
modifier|*
name|lshead
decl_stmt|,
modifier|*
name|lstail
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|is_ls
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|passivemode
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|GATEWAY
end_ifdef

begin_decl_stmt
specifier|extern
name|string
name|gateway
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|string
name|gate_login
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|_POSIX_SOURCE
end_ifdef

begin_function
name|FILE
modifier|*
name|safeopen
parameter_list|(
name|int
name|s
parameter_list|,
name|char
modifier|*
name|lmode
parameter_list|)
block|{
name|FILE
modifier|*
name|file
decl_stmt|;
name|setreuid
argument_list|(
name|geteuid
argument_list|()
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|getegid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
name|file
operator|=
name|fdopen
argument_list|(
name|s
argument_list|,
name|lmode
argument_list|)
expr_stmt|;
name|setreuid
argument_list|(
name|geteuid
argument_list|()
argument_list|,
name|getuid
argument_list|()
argument_list|)
expr_stmt|;
name|setregid
argument_list|(
name|getegid
argument_list|()
argument_list|,
name|getgid
argument_list|()
argument_list|)
expr_stmt|;
return|return
operator|(
name|file
operator|)
return|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|safeopen
value|fdopen
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|hookup
parameter_list|(
name|char
modifier|*
name|host
parameter_list|,
name|unsigned
name|int
name|port
parameter_list|)
block|{
specifier|register
name|struct
name|hostent
modifier|*
name|hp
init|=
literal|0
decl_stmt|;
name|int
name|s
decl_stmt|,
name|len
decl_stmt|,
name|hErr
init|=
operator|-
literal|1
decl_stmt|;
name|string
name|errstr
decl_stmt|;
name|char
modifier|*
modifier|*
name|curaddr
init|=
name|NULL
decl_stmt|;
name|bzero
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|&
name|hisctladdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hisctladdr
argument_list|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|BAD_INETADDR
name|hisctladdr
operator|.
name|sin_addr
operator|=
name|inet_addr
argument_list|(
name|host
argument_list|)
expr_stmt|;
else|#
directive|else
name|hisctladdr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|=
name|inet_addr
argument_list|(
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|hisctladdr
operator|.
name|sin_addr
operator|.
name|s_addr
operator|!=
operator|-
literal|1
condition|)
block|{
name|hisctladdr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|hostname
argument_list|,
name|host
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|hp
operator|=
name|gethostbyname
argument_list|(
name|host
argument_list|)
expr_stmt|;
if|if
condition|(
name|hp
operator|==
name|NULL
condition|)
block|{
ifdef|#
directive|ifdef
name|HERROR
specifier|extern
name|int
name|h_errno
decl_stmt|;
if|if
condition|(
name|h_errno
operator|==
name|HOST_NOT_FOUND
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: unknown host\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: gethostbyname herror (%d):  "
argument_list|,
name|host
argument_list|,
name|h_errno
argument_list|)
expr_stmt|;
name|herror
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: unknown host\n"
argument_list|,
name|host
argument_list|)
expr_stmt|;
endif|#
directive|endif
goto|goto
name|done
goto|;
block|}
name|hisctladdr
operator|.
name|sin_family
operator|=
name|hp
operator|->
name|h_addrtype
expr_stmt|;
name|curaddr
operator|=
name|hp
operator|->
name|h_addr_list
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|curaddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|hisctladdr
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|hostname
argument_list|,
name|hp
operator|->
name|h_name
argument_list|)
expr_stmt|;
block|}
name|s
operator|=
name|socket
argument_list|(
name|hisctladdr
operator|.
name|sin_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"hookup"
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|hisctladdr
operator|.
name|sin_port
operator|=
name|port
expr_stmt|;
ifdef|#
directive|ifdef
name|SOCKS
while|while
condition|(
name|Rconnect
argument_list|(
name|s
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|hisctladdr
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|hisctladdr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
while|while
condition|(
name|Connect
argument_list|(
name|s
argument_list|,
operator|&
name|hisctladdr
argument_list|,
sizeof|sizeof
argument_list|(
name|hisctladdr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|curaddr
operator|!=
name|NULL
condition|)
block|{
name|curaddr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|curaddr
operator|!=
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|errstr
argument_list|,
literal|"connect error to address %s"
argument_list|,
name|inet_ntoa
argument_list|(
name|hisctladdr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
literal|"hookup"
argument_list|,
name|errstr
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|*
name|curaddr
argument_list|,
operator|(
name|caddr_t
operator|)
operator|&
name|hisctladdr
operator|.
name|sin_addr
argument_list|,
name|hp
operator|->
name|h_length
argument_list|)
expr_stmt|;
name|dbprintf
argument_list|(
literal|"Trying %s...\n"
argument_list|,
name|inet_ntoa
argument_list|(
name|hisctladdr
operator|.
name|sin_addr
argument_list|)
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
name|s
operator|=
name|socket
argument_list|(
name|hisctladdr
operator|.
name|sin_family
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"hookup"
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
continue|continue;
block|}
block|}
name|PERROR
argument_list|(
literal|"hookup"
argument_list|,
name|host
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|errno
condition|)
block|{
case|case
name|ENETDOWN
case|:
case|case
name|ENETUNREACH
case|:
case|case
name|ECONNABORTED
case|:
case|case
name|ETIMEDOUT
case|:
case|case
name|ECONNREFUSED
case|:
case|case
name|EHOSTDOWN
case|:
name|hErr
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* we can re-try later. */
block|}
goto|goto
name|bad
goto|;
block|}
name|len
operator|=
sizeof|sizeof
argument_list|(
name|myctladdr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Getsockname
argument_list|(
name|s
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|myctladdr
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"hookup"
argument_list|,
literal|"getsockname"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
name|cin
operator|=
name|safeopen
argument_list|(
name|s
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
name|cout
operator|=
name|safeopen
argument_list|(
name|dup
argument_list|(
name|s
argument_list|)
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cin
operator|==
name|NULL
operator|||
name|cout
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"ftp: safeopen failed.\n"
argument_list|)
expr_stmt|;
name|close_streams
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
if|if
condition|(
name|IS_VVERBOSE
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Connected to %s.\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|IPTOS_LOWDELAY
comment|/* control is interactive */
ifdef|#
directive|ifdef
name|IP_TOS
block|{
name|int
name|nType
init|=
name|IPTOS_LOWDELAY
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TOS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nType
argument_list|,
sizeof|sizeof
argument_list|(
name|nType
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"hookup"
argument_list|,
literal|"setsockopt(IP_TOS)"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|getreply
argument_list|(
literal|0
argument_list|)
operator|>
literal|2
condition|)
block|{
comment|/* read startup message from server */
name|close_streams
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|421
condition|)
name|hErr
operator|=
operator|-
literal|2
expr_stmt|;
comment|/* We can try again later. */
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|SO_OOBINLINE
block|{
name|int
name|on
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|s
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_OOBINLINE
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
operator|&&
name|debug
condition|)
block|{
name|PERROR
argument_list|(
literal|"hookup"
argument_list|,
literal|"setsockopt(SO_OOBINLINE)"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* SO_OOBINLINE */
name|hErr
operator|=
literal|0
expr_stmt|;
name|using_pasv
operator|=
name|passivemode
expr_stmt|;
comment|/* Re-init for each new connection. */
goto|goto
name|done
goto|;
name|bad
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
name|cin
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cin
argument_list|)
expr_stmt|;
if|if
condition|(
name|cout
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|cout
argument_list|)
expr_stmt|;
name|cin
operator|=
name|cout
operator|=
name|NULL
expr_stmt|;
name|done
label|:
return|return
operator|(
name|hErr
operator|)
return|;
block|}
comment|/* hookup */
comment|/* This registers the user's username, password, and account with the remote  * host which validates it.  If we get on, we also do some other things, like  * enter a log entry and execute the startup macro.  */
name|int
name|Login
parameter_list|(
name|char
modifier|*
name|userNamePtr
parameter_list|,
name|char
modifier|*
name|passWordPtr
parameter_list|,
name|char
modifier|*
name|accountPtr
parameter_list|,
name|int
name|doInit
parameter_list|)
block|{
name|string
name|userName
decl_stmt|;
name|string
name|str
decl_stmt|;
name|int
name|n
decl_stmt|;
name|int
name|sentAcct
init|=
literal|0
decl_stmt|;
name|int
name|userWasPrompted
init|=
literal|0
decl_stmt|;
name|int
name|result
init|=
name|CMDERR
decl_stmt|;
name|time_t
name|now
decl_stmt|;
if|if
condition|(
name|userNamePtr
operator|==
name|NULL
condition|)
block|{
comment|/* Prompt for a username. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"Login Name (%s): "
argument_list|,
name|uinfo
operator|.
name|username
argument_list|)
expr_stmt|;
operator|++
name|userWasPrompted
expr_stmt|;
if|if
condition|(
name|Gets
argument_list|(
name|str
argument_list|,
name|userName
argument_list|,
sizeof|sizeof
argument_list|(
name|userName
argument_list|)
argument_list|)
operator|==
name|NULL
condition|)
goto|goto
name|done
goto|;
elseif|else
if|if
condition|(
name|userName
index|[
literal|0
index|]
condition|)
block|{
comment|/* User didn't just hit return. */
name|userNamePtr
operator|=
name|userName
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * User can hit return if he wants to enter his username 			 * automatically. 			 */
if|if
condition|(
operator|*
name|uinfo
operator|.
name|username
operator|!=
literal|'\0'
condition|)
name|userNamePtr
operator|=
name|uinfo
operator|.
name|username
expr_stmt|;
else|else
goto|goto
name|done
goto|;
block|}
block|}
ifdef|#
directive|ifdef
name|GATEWAY
if|if
condition|(
operator|*
name|gateway
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"USER %s@%s"
argument_list|,
operator|(
operator|*
name|gate_login
condition|?
name|gate_login
else|:
name|dGATEWAY_LOGIN
operator|)
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"USER %s"
argument_list|,
name|userNamePtr
argument_list|)
expr_stmt|;
comment|/* Send the user name. */
name|n
operator|=
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|CONTINUE
condition|)
block|{
if|if
condition|(
name|passWordPtr
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
operator|(
name|strcmp
argument_list|(
literal|"anonymous"
argument_list|,
name|userName
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|strcmp
argument_list|(
literal|"ftp"
argument_list|,
name|userName
argument_list|)
operator|==
literal|0
operator|)
operator|)
operator|&&
operator|(
operator|*
name|anon_password
operator|!=
literal|'\0'
operator|)
condition|)
name|passWordPtr
operator|=
name|anon_password
expr_stmt|;
else|else
block|{
comment|/* Prompt for a password. */
operator|++
name|userWasPrompted
expr_stmt|;
name|passWordPtr
operator|=
name|Getpass
argument_list|(
literal|"Password:"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* The remote site is requesting us to send the password now. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"PASS %s"
argument_list|,
name|passWordPtr
argument_list|)
expr_stmt|;
name|n
operator|=
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|CONTINUE
condition|)
block|{
comment|/* The remote site is requesting us to send the account now. */
if|if
condition|(
name|accountPtr
operator|==
name|NULL
condition|)
block|{
comment|/* Prompt for a username. */
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"ACCT %s"
argument_list|,
name|Getpass
argument_list|(
literal|"Account:"
argument_list|)
argument_list|)
expr_stmt|;
operator|++
name|userWasPrompted
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"ACCT %s"
argument_list|,
name|accountPtr
argument_list|)
expr_stmt|;
block|}
operator|++
name|sentAcct
expr_stmt|;
comment|/* Keep track that we've sent the account already. */
name|n
operator|=
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|n
operator|!=
name|COMPLETE
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Login failed.\n"
argument_list|)
expr_stmt|;
goto|goto
name|done
goto|;
block|}
comment|/* If you specified an account, and the remote-host didn't request it 	 * (maybe it's optional), we will send the account information. 	 */
if|if
condition|(
operator|!
name|sentAcct
operator|&&
name|accountPtr
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"ACCT %s"
argument_list|,
name|accountPtr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
comment|/* See if remote host dropped connection.  Some sites will let you log 	 * in anonymously, only to tell you that they already have too many 	 * anon users, then drop you.  We do a no-op here to see if they've 	 * ditched us. 	 */
name|n
operator|=
name|quiet_command
argument_list|(
literal|"NOOP"
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|==
name|TRANSIENT
condition|)
goto|goto
name|done
goto|;
ifdef|#
directive|ifdef
name|SYSLOG
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s connected to %s as %s."
argument_list|,
name|uinfo
operator|.
name|username
argument_list|,
name|hostname
argument_list|,
name|userNamePtr
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Save which sites we opened to the user's logfile. */
if|if
condition|(
name|logf
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|time
argument_list|(
operator|&
name|now
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logf
argument_list|,
literal|"%s opened at %s"
argument_list|,
name|hostname
argument_list|,
name|ctime
argument_list|(
operator|&
name|now
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Let the user know we are logged in, unless he was prompted for some 	 * information already. 	 */
if|if
condition|(
operator|!
name|userWasPrompted
condition|)
if|if
condition|(
name|NOT_VQUIET
condition|)
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"Logged into %s.\n"
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|doInit
operator|)
operator|&&
operator|(
name|macnum
operator|>
literal|0
operator|)
condition|)
block|{
comment|/* Run the startup macro, if any. */
comment|/* If macnum is non-zero, the init macro was defined from 		 * ruserpass.  It would be the only macro defined at this 		 * point. 		 */
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|line
argument_list|,
literal|"$init"
argument_list|)
expr_stmt|;
name|makeargv
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|domacro
argument_list|(
name|margc
argument_list|,
name|margv
argument_list|)
expr_stmt|;
block|}
name|_cd
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
comment|/* Init cwd variable. */
name|result
operator|=
name|NOERR
expr_stmt|;
name|logged_in
operator|=
literal|1
expr_stmt|;
name|done
label|:
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* Login */
comment|/*ARGSUSED*/
name|void
name|cmdabort
name|SIG_PARAMS
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|abrtflag
operator|++
expr_stmt|;
block|}
comment|/* cmdabort */
name|int
name|CommandWithFlags
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|int
name|r
decl_stmt|;
name|Sig_t
name|oldintr
decl_stmt|;
name|string
name|str
decl_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
block|{
comment|/* Should never happen; bug if it does. */
name|PERROR
argument_list|(
literal|"command"
argument_list|,
literal|"NULL command"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
name|abrtflag
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|debug
condition|)
block|{
if|if
condition|(
name|strncmp
argument_list|(
name|cmd
argument_list|,
literal|"PASS"
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
operator|==
literal|0
condition|)
name|dbprintf
argument_list|(
literal|"cmd: \"PASS ********\"\n"
argument_list|)
expr_stmt|;
else|else
name|dbprintf
argument_list|(
literal|"cmd: \"%s\" (length %d)\n"
argument_list|,
name|cmd
argument_list|,
operator|(
name|int
operator|)
name|strlen
argument_list|(
name|cmd
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cout
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s: No control connection for command"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
name|PERROR
argument_list|(
literal|"command"
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
comment|/* cmdabort */
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Used to have BROKEN_MEMCPY tested here. */
if|if
condition|(
name|cout
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%s\r\n"
argument_list|,
name|cmd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cout
argument_list|)
expr_stmt|;
name|cpend
operator|=
literal|1
expr_stmt|;
name|r
operator|=
operator|(
name|flags
operator|==
name|WAIT_FOR_REPLY
operator|)
condition|?
operator|(
name|getreply
argument_list|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"QUIT"
argument_list|)
operator|==
literal|0
argument_list|)
operator|)
else|:
name|PRELIM
expr_stmt|;
if|if
condition|(
name|abrtflag
operator|&&
name|oldintr
operator|!=
name|SIG_IGN
operator|&&
name|oldintr
operator|!=
name|NULL
condition|)
call|(
modifier|*
name|oldintr
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
return|return
operator|(
name|r
operator|)
return|;
block|}
comment|/* CommandWithFlags */
comment|/* This stub runs 'CommandWithFlags' above, telling it to wait for  * reply after the command is sent.  */
name|int
name|command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|CommandWithFlags
argument_list|(
name|cmd
argument_list|,
name|WAIT_FOR_REPLY
argument_list|)
operator|)
return|;
block|}
comment|/* command */
comment|/* This stub runs 'CommandWithFlags' above, telling it to NOT wait for  * reply after the command is sent.  */
name|int
name|command_noreply
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
return|return
operator|(
name|CommandWithFlags
argument_list|(
name|cmd
argument_list|,
name|DONT_WAIT_FOR_REPLY
argument_list|)
operator|)
return|;
block|}
comment|/* command */
name|int
name|quiet_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
specifier|register
name|int
name|oldverbose
decl_stmt|,
name|result
decl_stmt|;
name|oldverbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|debug
condition|?
name|V_VERBOSE
else|:
name|V_QUIET
expr_stmt|;
name|result
operator|=
name|command
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|oldverbose
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* quiet_command */
name|int
name|verbose_command
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|)
block|{
specifier|register
name|int
name|oldverbose
decl_stmt|,
name|result
decl_stmt|;
name|oldverbose
operator|=
name|verbose
expr_stmt|;
name|verbose
operator|=
name|V_VERBOSE
expr_stmt|;
name|result
operator|=
name|command
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|oldverbose
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
comment|/* quiet_command */
name|int
name|getreply
parameter_list|(
name|int
name|expecteof
parameter_list|)
block|{
specifier|register
name|int
name|c
decl_stmt|,
name|n
init|=
literal|0
decl_stmt|;
name|int
name|dig
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|end
decl_stmt|,
modifier|*
name|dp
decl_stmt|;
name|int
name|thiscode
decl_stmt|,
name|originalcode
init|=
literal|0
decl_stmt|,
name|continuation
init|=
literal|0
decl_stmt|;
name|Sig_t
name|oldintr
decl_stmt|;
if|if
condition|(
name|cin
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
comment|/* oldintr = Signal(SIGINT, SIG_IGN); */
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|cmdabort
argument_list|)
expr_stmt|;
name|end
operator|=
name|reply_string
operator|+
name|RECEIVEDLINELEN
operator|-
literal|2
expr_stmt|;
for|for
control|(
init|;
name|abrtflag
operator|==
literal|0
condition|;
control|)
block|{
name|dig
operator|=
name|n
operator|=
name|thiscode
operator|=
name|code
operator|=
literal|0
expr_stmt|;
name|cp
operator|=
name|reply_string
expr_stmt|;
for|for
control|(
init|;
name|abrtflag
operator|==
literal|0
condition|;
control|)
block|{
name|c
operator|=
name|fgetc
argument_list|(
name|cin
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|IAC
condition|)
block|{
comment|/* handle telnet commands */
switch|switch
condition|(
name|c
operator|=
name|fgetc
argument_list|(
name|cin
argument_list|)
condition|)
block|{
case|case
name|WILL
case|:
case|case
name|WONT
case|:
name|c
operator|=
name|fgetc
argument_list|(
name|cin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%c%c%c"
argument_list|,
name|IAC
argument_list|,
name|DONT
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cout
argument_list|)
expr_stmt|;
break|break;
case|case
name|DO
case|:
case|case
name|DONT
case|:
name|c
operator|=
name|fgetc
argument_list|(
name|cin
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%c%c%c"
argument_list|,
name|IAC
argument_list|,
name|WONT
argument_list|,
name|c
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cout
argument_list|)
expr_stmt|;
break|break;
default|default:
break|break;
block|}
continue|continue;
block|}
name|dig
operator|++
expr_stmt|;
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|expecteof
condition|)
block|{
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
name|code
operator|=
literal|221
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|lostpeer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|NOT_VQUIET
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"421 Service not available, remote server has closed connection\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
name|code
operator|=
literal|421
expr_stmt|;
return|return
operator|(
literal|4
operator|)
return|;
block|}
if|if
condition|(
name|cp
operator|<
name|end
operator|&&
name|c
operator|!=
literal|'\r'
condition|)
operator|*
name|cp
operator|++
operator|=
name|c
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
break|break;
if|if
condition|(
name|dig
operator|<
literal|4
operator|&&
name|isdigit
argument_list|(
name|c
argument_list|)
condition|)
name|code
operator|=
name|thiscode
operator|=
name|code
operator|*
literal|10
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
elseif|else
if|if
condition|(
name|dig
operator|==
literal|4
operator|&&
name|c
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|continuation
condition|)
name|code
operator|=
literal|0
expr_stmt|;
name|continuation
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|n
operator|==
literal|0
condition|)
name|n
operator|=
name|c
expr_stmt|;
block|}
comment|/* end for(;;) #2 */
operator|*
name|cp
operator|=
literal|'\0'
expr_stmt|;
name|dbprintf
argument_list|(
literal|"rsp: %s"
argument_list|,
name|reply_string
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|verbose
condition|)
block|{
case|case
name|V_QUIET
case|:
comment|/* Don't print anything. */
break|break;
case|case
name|V_ERRS
case|:
if|if
condition|(
name|n
operator|==
literal|'5'
condition|)
block|{
name|dp
operator|=
name|reply_string
expr_stmt|;
goto|goto
name|stripCode
goto|;
block|}
break|break;
case|case
name|V_IMPLICITCD
case|:
case|case
name|V_TERSE
case|:
name|dp
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|n
operator|==
literal|'5'
operator|&&
name|verbose
operator|==
name|V_TERSE
condition|)
name|dp
operator|=
name|reply_string
expr_stmt|;
else|else
block|{
switch|switch
condition|(
name|thiscode
condition|)
block|{
case|case
literal|230
case|:
case|case
literal|214
case|:
case|case
literal|331
case|:
case|case
literal|332
case|:
case|case
literal|421
case|:
comment|/* For ftp.apple.com, etc. */
name|dp
operator|=
name|reply_string
expr_stmt|;
break|break;
case|case
literal|220
case|:
comment|/* 							 * Skip the foo FTP server ready line. 							 */
if|if
condition|(
name|strstr
argument_list|(
name|reply_string
argument_list|,
literal|"ready."
argument_list|)
operator|==
name|NULL
condition|)
name|dp
operator|=
name|reply_string
expr_stmt|;
break|break;
case|case
literal|250
case|:
comment|/* 							 * Print 250 lines if they aren't 							 * "250 CWD command successful." 							 */
if|if
condition|(
name|strncmp
argument_list|(
name|reply_string
operator|+
literal|4
argument_list|,
literal|"CWD "
argument_list|,
operator|(
name|size_t
operator|)
literal|4
argument_list|)
condition|)
name|dp
operator|=
name|reply_string
expr_stmt|;
block|}
block|}
if|if
condition|(
name|dp
operator|==
name|NULL
condition|)
break|break;
name|stripCode
label|:
comment|/* Try to strip out the code numbers, etc. */
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|dp
operator|++
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|dp
operator|++
argument_list|)
operator|&&
name|isdigit
argument_list|(
operator|*
name|dp
operator|++
argument_list|)
condition|)
block|{
if|if
condition|(
operator|*
name|dp
operator|==
literal|' '
operator|||
operator|*
name|dp
operator|==
literal|'-'
condition|)
block|{
name|dp
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|dp
operator|==
literal|' '
condition|)
name|dp
operator|++
expr_stmt|;
block|}
else|else
name|dp
operator|=
name|reply_string
expr_stmt|;
block|}
else|else
block|{
name|int
name|spaces
decl_stmt|;
name|dp
operator|=
name|reply_string
expr_stmt|;
for|for
control|(
name|spaces
operator|=
literal|0
init|;
name|spaces
operator|<
literal|4
condition|;
operator|++
name|spaces
control|)
if|if
condition|(
name|dp
index|[
name|spaces
index|]
operator|!=
literal|' '
condition|)
break|break;
if|if
condition|(
name|spaces
operator|==
literal|4
condition|)
name|dp
operator|+=
name|spaces
expr_stmt|;
block|}
goto|goto
name|printLine
goto|;
case|case
name|V_VERBOSE
case|:
name|dp
operator|=
name|reply_string
expr_stmt|;
name|printLine
label|:
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|dp
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
comment|/* end switch */
if|if
condition|(
name|continuation
operator|&&
name|code
operator|!=
name|originalcode
condition|)
block|{
if|if
condition|(
name|originalcode
operator|==
literal|0
condition|)
name|originalcode
operator|=
name|code
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|n
operator|!=
literal|'1'
condition|)
name|cpend
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|code
operator|==
literal|421
operator|||
name|originalcode
operator|==
literal|421
condition|)
name|lostpeer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|abrtflag
operator|&&
name|oldintr
operator|!=
name|cmdabort
operator|&&
name|oldintr
operator|!=
name|SIG_IGN
operator|&&
name|oldintr
condition|)
call|(
modifier|*
name|oldintr
call|)
argument_list|(
literal|0
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* end for(;;) #1 */
return|return
operator|(
name|n
operator|-
literal|'0'
operator|)
return|;
block|}
comment|/* getreply */
specifier|static
name|int
name|empty
parameter_list|(
name|struct
name|fd_set
modifier|*
name|mask
parameter_list|,
name|int
name|sec
parameter_list|)
block|{
name|struct
name|timeval
name|t
decl_stmt|;
name|t
operator|.
name|tv_sec
operator|=
operator|(
name|long
operator|)
name|sec
expr_stmt|;
name|t
operator|.
name|tv_usec
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|Select
argument_list|(
literal|32
argument_list|,
name|mask
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
operator|&
name|t
argument_list|)
operator|)
return|;
block|}
comment|/* empty */
specifier|static
name|void
name|tvsub
parameter_list|(
name|struct
name|timeval
modifier|*
name|tdiff
parameter_list|,
name|struct
name|timeval
modifier|*
name|t1
parameter_list|,
name|struct
name|timeval
modifier|*
name|t0
parameter_list|)
block|{
name|tdiff
operator|->
name|tv_sec
operator|=
name|t1
operator|->
name|tv_sec
operator|-
name|t0
operator|->
name|tv_sec
expr_stmt|;
name|tdiff
operator|->
name|tv_usec
operator|=
name|t1
operator|->
name|tv_usec
operator|-
name|t0
operator|->
name|tv_usec
expr_stmt|;
if|if
condition|(
name|tdiff
operator|->
name|tv_usec
operator|<
literal|0
condition|)
name|tdiff
operator|->
name|tv_sec
operator|--
operator|,
name|tdiff
operator|->
name|tv_usec
operator|+=
literal|1000000
expr_stmt|;
block|}
comment|/* tvsub */
comment|/* Variables private to progress_report code. */
specifier|static
name|int
name|barlen
decl_stmt|;
specifier|static
name|long
name|last_dot
decl_stmt|;
specifier|static
name|int
name|dots
decl_stmt|;
name|int
name|start_progress
parameter_list|(
name|int
name|sending
parameter_list|,
name|char
modifier|*
name|local
parameter_list|)
block|{
name|long
name|s
decl_stmt|;
name|char
name|spec
index|[
literal|64
index|]
decl_stmt|;
name|cur_progress_meter
operator|=
name|toatty
condition|?
name|progress_meter
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|(
name|cur_progress_meter
operator|>
name|pr_last
operator|)
operator|||
operator|(
name|cur_progress_meter
operator|<
literal|0
operator|)
condition|)
name|cur_progress_meter
operator|=
name|dPROGRESS
expr_stmt|;
if|if
condition|(
operator|(
name|file_size
operator|<=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|cur_progress_meter
operator|==
name|pr_percent
operator|)
operator|||
operator|(
name|cur_progress_meter
operator|==
name|pr_philbar
operator|)
operator|||
operator|(
name|cur_progress_meter
operator|==
name|pr_last
operator|)
operator|)
condition|)
name|cur_progress_meter
operator|=
name|pr_kbytes
expr_stmt|;
if|if
condition|(
operator|!
name|ansi_escapes
operator|&&
operator|(
name|cur_progress_meter
operator|==
name|pr_philbar
operator|)
condition|)
name|cur_progress_meter
operator|=
name|pr_dots
expr_stmt|;
operator|(
name|void
operator|)
name|Gettimeofday
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
name|now_sec
operator|=
name|start
operator|.
name|tv_sec
expr_stmt|;
switch|switch
condition|(
name|cur_progress_meter
condition|)
block|{
case|case
name|pr_none
case|:
break|break;
case|case
name|pr_percent
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:     "
argument_list|,
name|local
argument_list|)
expr_stmt|;
goto|goto
name|zz
goto|;
case|case
name|pr_kbytes
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s:       "
argument_list|,
name|local
argument_list|)
expr_stmt|;
goto|goto
name|zz
goto|;
case|case
name|pr_philbar
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s%s file: %s %s\n"
argument_list|,
name|tcap_boldface
argument_list|,
name|sending
condition|?
literal|"Sending"
else|:
literal|"Receiving"
argument_list|,
name|local
argument_list|,
name|tcap_normal
argument_list|)
expr_stmt|;
name|barlen
operator|=
literal|52
expr_stmt|;
for|for
control|(
name|s
operator|=
name|file_size
init|;
name|s
operator|>
literal|0
condition|;
name|s
operator|/=
literal|10L
control|)
name|barlen
operator|--
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|spec
argument_list|,
literal|"      0 %%%ds %%ld bytes. ETA: --:--\r"
argument_list|,
name|barlen
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|spec
argument_list|,
literal|" "
argument_list|,
name|file_size
argument_list|)
expr_stmt|;
goto|goto
name|zz
goto|;
case|case
name|pr_dots
case|:
name|last_dot
operator|=
operator|(
name|file_size
operator|/
literal|10
operator|)
operator|+
literal|1
expr_stmt|;
name|dots
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: "
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|zz
label|:
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|Echo
argument_list|(
name|stdin
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* end switch */
return|return
operator|(
name|cur_progress_meter
operator|)
return|;
block|}
comment|/* start_progress */
name|int
name|progress_report
parameter_list|(
name|int
name|finish_up
parameter_list|)
block|{
name|int
name|size
decl_stmt|;
name|int
name|perc
decl_stmt|;
name|float
name|frac
decl_stmt|;
name|char
name|spec
index|[
literal|64
index|]
decl_stmt|;
name|float
name|secsElap
decl_stmt|;
name|int
name|secsLeft
decl_stmt|,
name|minLeft
decl_stmt|;
name|struct
name|timeval
name|td
decl_stmt|;
name|next_report
operator|+=
name|xferbufsize
expr_stmt|;
operator|(
name|void
operator|)
name|Gettimeofday
argument_list|(
operator|&
name|stop
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|stop
operator|.
name|tv_sec
operator|>
name|now_sec
operator|)
operator|||
operator|(
name|finish_up
operator|&&
name|file_size
operator|)
condition|)
block|{
switch|switch
condition|(
name|cur_progress_meter
condition|)
block|{
case|case
name|pr_none
case|:
break|break;
case|case
name|pr_percent
case|:
name|perc
operator|=
call|(
name|int
call|)
argument_list|(
literal|100.0
operator|*
operator|(
name|float
operator|)
name|bytes
operator|/
operator|(
name|float
operator|)
name|file_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|perc
operator|>
literal|100
condition|)
name|perc
operator|=
literal|100
expr_stmt|;
elseif|else
if|if
condition|(
name|perc
operator|<
literal|0
condition|)
name|perc
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\b\b\b\b%3d%%"
argument_list|,
name|perc
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|pr_philbar
case|:
name|frac
operator|=
operator|(
name|float
operator|)
name|bytes
operator|/
operator|(
name|float
operator|)
name|file_size
expr_stmt|;
if|if
condition|(
name|frac
operator|>
literal|1.0
condition|)
name|frac
operator|=
literal|1.0
expr_stmt|;
elseif|else
if|if
condition|(
name|frac
operator|<
literal|0.0
condition|)
name|frac
operator|=
literal|0.0
expr_stmt|;
name|size
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|barlen
operator|*
name|frac
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|spec
argument_list|,
literal|"%%3d%%%%  0 %%s%%%ds%%s%%%ds %%ld bytes. ETA:%%3d:%%02d\r"
argument_list|,
name|size
argument_list|,
name|barlen
operator|-
name|size
argument_list|)
expr_stmt|;
name|perc
operator|=
call|(
name|long
call|)
argument_list|(
literal|100.0
operator|*
name|frac
argument_list|)
expr_stmt|;
name|tvsub
argument_list|(
operator|&
name|td
argument_list|,
operator|&
name|stop
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|secsElap
operator|=
name|td
operator|.
name|tv_sec
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
expr_stmt|;
name|secsLeft
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|float
operator|)
name|file_size
operator|/
operator|(
operator|(
name|float
operator|)
name|bytes
operator|/
name|secsElap
operator|)
operator|-
name|secsElap
operator|+
literal|0.5
argument_list|)
expr_stmt|;
name|minLeft
operator|=
name|secsLeft
operator|/
literal|60
expr_stmt|;
name|secsLeft
operator|=
name|secsLeft
operator|-
operator|(
name|minLeft
operator|*
literal|60
operator|)
expr_stmt|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|spec
argument_list|,
name|perc
argument_list|,
name|tcap_reverse
argument_list|,
literal|""
argument_list|,
name|tcap_normal
argument_list|,
literal|""
argument_list|,
name|file_size
argument_list|,
name|minLeft
argument_list|,
name|secsLeft
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
break|break;
case|case
name|pr_kbytes
case|:
if|if
condition|(
operator|(
name|bytes
operator|/
literal|1024
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\b\b\b\b\b\b%5ldK"
argument_list|,
name|bytes
operator|/
literal|1024
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|pr_dots
case|:
if|if
condition|(
name|bytes
operator|>
name|last_dot
condition|)
block|{
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|last_dot
operator|+=
operator|(
name|file_size
operator|/
literal|10
operator|)
operator|+
literal|1
expr_stmt|;
name|dots
operator|++
expr_stmt|;
block|}
block|}
comment|/* end switch */
name|now_sec
operator|=
name|stop
operator|.
name|tv_sec
expr_stmt|;
block|}
comment|/* end if we updated */
return|return
operator|(
name|UserLoggedIn
argument_list|()
operator|)
return|;
block|}
comment|/* progress_report */
name|void
name|end_progress
parameter_list|(
name|char
modifier|*
name|direction
parameter_list|,
name|char
modifier|*
name|local
parameter_list|,
name|char
modifier|*
name|remote
parameter_list|)
block|{
name|struct
name|timeval
name|td
decl_stmt|;
name|float
name|s
decl_stmt|,
name|bs
init|=
literal|0.0
decl_stmt|;
name|str32
name|bsstr
decl_stmt|;
name|int
name|doLastReport
decl_stmt|;
name|int
name|receiving
decl_stmt|;
name|longstring
name|fullRemote
decl_stmt|,
name|fullLocal
decl_stmt|;
name|doLastReport
operator|=
operator|(
operator|(
name|UserLoggedIn
argument_list|()
operator|)
operator|&&
operator|(
name|cur_progress_meter
operator|!=
name|pr_none
operator|)
operator|&&
operator|(
name|NOT_VQUIET
operator|)
operator|&&
operator|(
name|bytes
operator|>
literal|0
operator|)
operator|)
expr_stmt|;
name|receiving
operator|=
operator|(
name|direction
index|[
literal|0
index|]
operator|==
literal|'r'
operator|)
expr_stmt|;
switch|switch
condition|(
name|FileType
argument_list|(
name|local
argument_list|)
condition|)
block|{
case|case
name|IS_FILE
case|:
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|fullLocal
argument_list|,
name|lcwd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|fullLocal
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|fullLocal
argument_list|,
name|local
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_PIPE
case|:
name|doLastReport
operator|=
literal|0
expr_stmt|;
name|local
operator|=
name|Strncpy
argument_list|(
name|fullLocal
argument_list|,
name|local
argument_list|)
expr_stmt|;
break|break;
case|case
name|IS_STREAM
case|:
default|default:
name|doLastReport
operator|=
literal|0
expr_stmt|;
name|local
operator|=
name|Strncpy
argument_list|(
name|fullLocal
argument_list|,
name|receiving
condition|?
literal|"stdout"
else|:
literal|"stdin"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doLastReport
condition|)
operator|(
name|void
operator|)
name|progress_report
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* tell progress proc to cleanup. */
name|tvsub
argument_list|(
operator|&
name|td
argument_list|,
operator|&
name|stop
argument_list|,
operator|&
name|start
argument_list|)
expr_stmt|;
name|s
operator|=
name|td
operator|.
name|tv_sec
operator|+
operator|(
name|td
operator|.
name|tv_usec
operator|/
literal|1000000.0
operator|)
expr_stmt|;
name|bsstr
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|s
operator|!=
literal|0.0
condition|)
block|{
name|bs
operator|=
operator|(
name|float
operator|)
name|bytes
operator|/
name|s
expr_stmt|;
if|if
condition|(
name|bs
operator|>
literal|1024.0
condition|)
name|sprintf
argument_list|(
name|bsstr
argument_list|,
literal|"%.2f K/s"
argument_list|,
name|bs
operator|/
literal|1024.0
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|bsstr
argument_list|,
literal|"%.2f Bytes/sec"
argument_list|,
name|bs
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|doLastReport
condition|)
switch|switch
condition|(
name|cur_progress_meter
condition|)
block|{
case|case
name|pr_none
case|:
name|zz
label|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s: %ld bytes %s in %.2f seconds, %s.\n"
argument_list|,
name|local
argument_list|,
name|bytes
argument_list|,
name|direction
argument_list|,
name|s
argument_list|,
name|bsstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|pr_kbytes
case|:
case|case
name|pr_percent
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"%s%ld bytes %s in %.2f seconds, %s.\n"
argument_list|,
name|cur_progress_meter
operator|==
name|pr_kbytes
condition|?
literal|"\b\b\b\b\b\b"
else|:
literal|"\b\b\b\b"
argument_list|,
name|bytes
argument_list|,
name|direction
argument_list|,
name|s
argument_list|,
name|bsstr
argument_list|)
expr_stmt|;
name|Echo
argument_list|(
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|pr_philbar
case|:
operator|(
name|void
operator|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
name|Echo
argument_list|(
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|zz
goto|;
case|case
name|pr_dots
case|:
for|for
control|(
init|;
name|dots
operator|<
literal|10
condition|;
name|dots
operator|++
control|)
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'.'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|Echo
argument_list|(
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
goto|goto
name|zz
goto|;
block|}
comment|/* Save transfers to the logfile. */
comment|/* if a simple path is given, try to log the full path */
if|if
condition|(
operator|*
name|remote
operator|!=
literal|'/'
condition|)
block|{
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|fullRemote
argument_list|,
name|cwd
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|fullRemote
argument_list|,
literal|"/"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Strncat
argument_list|(
name|fullRemote
argument_list|,
name|remote
argument_list|)
expr_stmt|;
block|}
else|else
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|fullRemote
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|logf
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|logf
argument_list|,
literal|"\t-> \"%s\" %s, %s\n"
argument_list|,
name|fullRemote
argument_list|,
name|direction
argument_list|,
name|bsstr
argument_list|)
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|SYSLOG
block|{
name|longstring
name|infoPart1
decl_stmt|;
comment|/* Some syslog()'s can't take an unlimited number of arguments,          * so shorten our call to syslog to 5 arguments total.          */
name|Strncpy
argument_list|(
name|infoPart1
argument_list|,
name|uinfo
operator|.
name|username
argument_list|)
expr_stmt|;
if|if
condition|(
name|receiving
condition|)
block|{
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
literal|" received "
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
name|fullRemote
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
literal|" as "
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
name|fullLocal
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
literal|" from "
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
literal|" sent "
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
name|fullLocal
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
literal|" as "
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
name|fullRemote
argument_list|)
expr_stmt|;
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
literal|" to "
argument_list|)
expr_stmt|;
block|}
name|Strncat
argument_list|(
name|infoPart1
argument_list|,
name|hostname
argument_list|)
expr_stmt|;
name|syslog
argument_list|(
name|LOG_INFO
argument_list|,
literal|"%s (%ld bytes, %s)."
argument_list|,
name|infoPart1
argument_list|,
name|bytes
argument_list|,
name|bsstr
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* SYSLOG */
block|}
comment|/* end_progress */
name|void
name|close_file
parameter_list|(
name|FILE
modifier|*
modifier|*
name|fin
parameter_list|,
name|int
name|filetype
parameter_list|)
block|{
if|if
condition|(
operator|*
name|fin
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|filetype
operator|==
name|IS_FILE
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
operator|*
name|fin
argument_list|)
expr_stmt|;
operator|*
name|fin
operator|=
name|NULL
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filetype
operator|==
name|IS_PIPE
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
operator|*
name|fin
argument_list|)
expr_stmt|;
operator|*
name|fin
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
comment|/* close_file */
comment|/*ARGSUSED*/
name|void
name|abortsend
name|SIG_PARAMS
block|{
name|activemcmd
operator|=
literal|0
expr_stmt|;
name|abrtflag
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\nSend aborted.\n"
argument_list|)
expr_stmt|;
name|Echo
argument_list|(
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|sendabort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* abortsend */
name|int
name|sendrequest
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|local
parameter_list|,
name|char
modifier|*
name|remote
parameter_list|)
block|{
name|FILE
modifier|*
name|fin
decl_stmt|,
modifier|*
name|dout
init|=
name|NULL
decl_stmt|;
name|Sig_t
name|oldintr
decl_stmt|,
name|oldintp
decl_stmt|;
name|string
name|str
decl_stmt|;
specifier|register
name|int
name|c
decl_stmt|,
name|d
decl_stmt|;
name|struct
name|stat
name|st
decl_stmt|;
name|int
name|filetype
decl_stmt|,
name|result
init|=
name|NOERR
decl_stmt|;
name|int
name|do_reports
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|mode
decl_stmt|;
specifier|register
name|char
modifier|*
name|bufp
decl_stmt|;
name|dbprintf
argument_list|(
literal|"cmd: %s;  rmt: %s;  loc: %s.\n"
argument_list|,
name|cmd
argument_list|,
name|remote
operator|==
name|NULL
condition|?
literal|"(null)"
else|:
name|remote
argument_list|,
name|local
operator|==
name|NULL
condition|?
literal|"(null)"
else|:
name|local
argument_list|)
expr_stmt|;
name|oldintr
operator|=
name|NULL
expr_stmt|;
name|oldintp
operator|=
name|NULL
expr_stmt|;
name|mode
operator|=
literal|"w"
expr_stmt|;
name|bytes
operator|=
name|file_size
operator|=
literal|0L
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|sendabort
argument_list|)
condition|)
block|{
while|while
condition|(
name|cpend
condition|)
block|{
operator|(
name|void
operator|)
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|data
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|oldintr
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|xx
goto|;
block|}
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|abortsend
argument_list|)
expr_stmt|;
name|file_size
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|local
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fin
operator|=
name|stdin
expr_stmt|;
name|filetype
operator|=
name|IS_STREAM
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|local
operator|==
literal|'|'
condition|)
block|{
name|filetype
operator|=
name|IS_PIPE
expr_stmt|;
name|oldintp
operator|=
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|fin
operator|=
name|popen
argument_list|(
name|local
operator|+
literal|1
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|PERROR
argument_list|(
literal|"sendrequest"
argument_list|,
name|local
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|xx
goto|;
block|}
block|}
else|else
block|{
name|filetype
operator|=
name|IS_FILE
expr_stmt|;
name|fin
operator|=
name|fopen
argument_list|(
name|local
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fin
operator|==
name|NULL
condition|)
block|{
name|PERROR
argument_list|(
literal|"sendrequest"
argument_list|,
name|local
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|xx
goto|;
block|}
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|fin
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
operator|||
operator|(
name|st
operator|.
name|st_mode
operator|&
name|S_IFMT
operator|)
operator|!=
name|S_IFREG
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stdout
argument_list|,
literal|"%s: not a plain file.\n"
argument_list|,
name|local
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fin
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
goto|goto
name|xx
goto|;
block|}
name|file_size
operator|=
name|st
operator|.
name|st_size
expr_stmt|;
block|}
if|if
condition|(
name|initconn
argument_list|()
condition|)
block|{
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|close_file
argument_list|(
operator|&
name|fin
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
goto|goto
name|xx
goto|;
block|}
if|if
condition|(
name|setjmp
argument_list|(
name|sendabort
argument_list|)
condition|)
goto|goto
name|Abort
goto|;
ifdef|#
directive|ifdef
name|TRY_NOREPLY
if|if
condition|(
name|remote
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s %s"
argument_list|,
name|cmd
argument_list|,
name|remote
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|command_noreply
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|command_noreply
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
name|dout
operator|=
name|dataconn
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dout
operator|==
name|NULL
condition|)
goto|goto
name|Abort
goto|;
if|if
condition|(
name|getreply
argument_list|(
literal|0
argument_list|)
operator|!=
name|PRELIM
condition|)
block|{
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
operator|&
name|fin
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
else|#
directive|else
if|if
condition|(
name|remote
condition|)
block|{
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s %s"
argument_list|,
name|cmd
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|command
argument_list|(
name|str
argument_list|)
operator|!=
name|PRELIM
condition|)
block|{
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
operator|&
name|fin
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
goto|goto
name|xx
goto|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|command
argument_list|(
name|cmd
argument_list|)
operator|!=
name|PRELIM
condition|)
block|{
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|close_file
argument_list|(
operator|&
name|fin
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
goto|goto
name|xx
goto|;
block|}
block|}
name|dout
operator|=
name|dataconn
argument_list|(
name|mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|dout
operator|==
name|NULL
condition|)
goto|goto
name|Abort
goto|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|Gettimeofday
argument_list|(
operator|&
name|start
argument_list|)
expr_stmt|;
name|oldintp
operator|=
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|do_reports
operator|=
operator|(
name|filetype
operator|==
name|IS_FILE
operator|&&
name|NOT_VQUIET
operator|)
operator|)
operator|!=
literal|0
condition|)
name|do_reports
operator|=
name|start_progress
argument_list|(
literal|1
argument_list|,
name|local
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|curtype
condition|)
block|{
case|case
name|TYPE_I
case|:
case|case
name|TYPE_L
case|:
name|errno
operator|=
name|d
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|fin
argument_list|)
argument_list|,
name|xferbuf
argument_list|,
operator|(
name|int
operator|)
name|xferbufsize
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
name|bytes
operator|+=
name|c
expr_stmt|;
for|for
control|(
name|bufp
operator|=
name|xferbuf
init|;
name|c
operator|>
literal|0
condition|;
name|c
operator|-=
name|d
operator|,
name|bufp
operator|+=
name|d
control|)
if|if
condition|(
operator|(
name|d
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|dout
argument_list|)
argument_list|,
name|bufp
argument_list|,
name|c
argument_list|)
operator|)
operator|<=
literal|0
condition|)
break|break;
comment|/* Print progress indicator. */
if|if
condition|(
name|do_reports
condition|)
name|do_reports
operator|=
name|progress_report
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|<
literal|0
condition|)
name|PERROR
argument_list|(
literal|"sendrequest"
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|d
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|d
operator|==
literal|0
operator|&&
operator|!
name|creating
condition|)
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"netout: write returned 0?\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
name|PERROR
argument_list|(
literal|"sendrequest"
argument_list|,
literal|"netout"
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
case|case
name|TYPE_A
case|:
name|next_report
operator|=
name|xferbufsize
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|fin
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|c
operator|==
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|dout
argument_list|)
condition|)
break|break;
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|dout
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|dout
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
comment|/* Print progress indicator. */
if|if
condition|(
name|do_reports
operator|&&
name|bytes
operator|>
name|next_report
condition|)
name|do_reports
operator|=
name|progress_report
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fin
argument_list|)
condition|)
name|PERROR
argument_list|(
literal|"sendrequest"
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|dout
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
name|PERROR
argument_list|(
literal|"sendrequest"
argument_list|,
literal|"netout"
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
break|break;
block|}
name|Done
label|:
name|close_file
argument_list|(
operator|&
name|fin
argument_list|,
name|filetype
argument_list|)
expr_stmt|;
if|if
condition|(
name|dout
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|dout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|end_progress
argument_list|(
literal|"sent"
argument_list|,
name|local
argument_list|,
name|remote
argument_list|)
expr_stmt|;
name|xx
label|:
return|return
operator|(
name|result
operator|)
return|;
name|Abort
label|:
name|result
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|!
name|cpend
condition|)
goto|goto
name|xx
goto|;
if|if
condition|(
name|data
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
block|}
goto|goto
name|Done
goto|;
block|}
comment|/* sendrequest */
comment|/*ARGSUSED*/
name|void
name|abortrecv
name|SIG_PARAMS
block|{
name|activemcmd
operator|=
literal|0
expr_stmt|;
name|abrtflag
operator|=
literal|0
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
ifdef|#
directive|ifdef
name|TRY_ABOR
literal|"(abort)\n"
argument_list|)
expr_stmt|;
else|#
directive|else
literal|"\nAborting, please wait..."
block|)
decl_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|Echo
argument_list|(
name|stdin
argument_list|,
literal|1
argument_list|)
expr_stmt|;
name|longjmp
argument_list|(
name|recvabort
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* abortrecv */
end_comment

begin_function
name|void
name|GetLSRemoteDir
parameter_list|(
name|char
modifier|*
name|remote
parameter_list|,
name|char
modifier|*
name|remote_dir
parameter_list|)
block|{
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* 	 * The ls() function can specify a directory to list along with ls flags, 	 * if it sends the flags first followed by the directory name. 	 * 	 * So far, we don't care about the remote directory being listed.  I put 	 * it now so I won't forget in case I need to do something with it later. 	 */
name|remote_dir
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|remote
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|index
argument_list|(
name|remote
argument_list|,
name|LS_FLAGS_AND_FILE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|remote_dir
argument_list|,
name|remote
argument_list|)
expr_stmt|;
else|else
block|{
operator|*
name|cp
operator|++
operator|=
literal|' '
expr_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|remote_dir
argument_list|,
name|cp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* GetLSRemoteDir */
end_comment

begin_function
name|int
name|AdjustLocalFileName
parameter_list|(
name|char
modifier|*
name|local
parameter_list|)
block|{
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* See if the file exists, and if we can overwrite it. */
if|if
condition|(
operator|(
name|access
argument_list|(
name|local
argument_list|,
literal|0
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|access
argument_list|(
name|local
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
operator|)
condition|)
goto|goto
name|noaccess
goto|;
comment|/* 	 * Make sure we are writing to a valid local path. 	 * First check the local directory, and see if we can write to it. 	 */
if|if
condition|(
name|access
argument_list|(
name|local
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|dir
operator|=
name|rindex
argument_list|(
name|local
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|!=
name|ENOENT
operator|&&
name|errno
operator|!=
name|EACCES
condition|)
block|{
comment|/* Report an error if it's one we can't handle. */
name|PERROR
argument_list|(
literal|"AdjustLocalFileName"
argument_list|,
name|local
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
comment|/* See if we have write permission on this directory. */
if|if
condition|(
name|dir
operator|!=
name|NULL
condition|)
block|{
comment|/* Special case: /filename. */
if|if
condition|(
name|dir
operator|!=
name|local
condition|)
operator|*
name|dir
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|access
argument_list|(
name|dir
operator|==
name|local
condition|?
literal|"/"
else|:
name|local
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
comment|/* 				 *	We have a big long pathname, like /a/b/c/d, 				 *	but see if we can write into the current 				 *	directory and call the file ./d. 				 */
if|if
condition|(
name|access
argument_list|(
literal|"."
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|local
argument_list|,
literal|" and ."
argument_list|)
expr_stmt|;
goto|goto
name|noaccess
goto|;
block|}
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|local
argument_list|,
name|dir
operator|+
literal|1
argument_list|)
expr_stmt|;
comment|/* use simple filename. */
block|}
else|else
operator|*
name|dir
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
comment|/* We have a simple path name (file name only). */
if|if
condition|(
name|access
argument_list|(
literal|"."
argument_list|,
literal|2
argument_list|)
operator|<
literal|0
condition|)
block|{
name|noaccess
label|:
name|PERROR
argument_list|(
literal|"AdjustLocalFileName"
argument_list|,
name|local
argument_list|)
expr_stmt|;
return|return
operator|-
literal|1
return|;
block|}
block|}
block|}
return|return
operator|(
name|NOERR
operator|)
return|;
block|}
end_function

begin_comment
comment|/* AdjustLocalFileName */
end_comment

begin_function
name|int
name|SetToAsciiForLS
parameter_list|(
name|int
name|is_retr
parameter_list|,
name|int
name|currenttype
parameter_list|)
block|{
name|int
name|oldt
init|=
operator|-
literal|1
decl_stmt|,
name|oldv
decl_stmt|;
if|if
condition|(
operator|!
name|is_retr
condition|)
block|{
if|if
condition|(
name|currenttype
operator|!=
name|TYPE_A
condition|)
block|{
name|oldt
operator|=
name|currenttype
expr_stmt|;
name|oldv
operator|=
name|verbose
expr_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
operator|(
name|void
operator|)
name|setascii
argument_list|(
literal|0
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|oldv
expr_stmt|;
block|}
block|}
return|return
name|oldt
return|;
block|}
end_function

begin_comment
comment|/* SetToAsciiForLS */
end_comment

begin_function
name|int
name|IssueCommand
parameter_list|(
name|char
modifier|*
name|ftpcmd
parameter_list|,
name|char
modifier|*
name|remote
parameter_list|)
block|{
name|string
name|str
decl_stmt|;
name|int
name|result
init|=
name|NOERR
decl_stmt|;
if|if
condition|(
name|remote
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"%s %s"
argument_list|,
name|ftpcmd
argument_list|,
name|remote
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|str
argument_list|,
name|ftpcmd
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRY_NOREPLY
if|if
condition|(
name|command_noreply
argument_list|(
name|str
argument_list|)
operator|!=
name|PRELIM
condition|)
else|#
directive|else
if|if
condition|(
name|command
argument_list|(
name|str
argument_list|)
operator|!=
name|PRELIM
condition|)
endif|#
directive|endif
name|result
operator|=
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* IssueCommand */
end_comment

begin_function
name|FILE
modifier|*
name|OpenOutputFile
parameter_list|(
name|int
name|filetype
parameter_list|,
name|char
modifier|*
name|local
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|,
name|Sig_t
modifier|*
name|oldintp
parameter_list|)
block|{
name|FILE
modifier|*
name|fout
decl_stmt|;
if|if
condition|(
name|filetype
operator|==
name|IS_STREAM
condition|)
block|{
name|fout
operator|=
name|stdout
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|filetype
operator|==
name|IS_PIPE
condition|)
block|{
comment|/* If it is a pipe, the pipecmd will have a | as the first char. */
operator|++
name|local
expr_stmt|;
name|fout
operator|=
name|popen
argument_list|(
name|local
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
operator|*
name|oldintp
operator|=
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|abortrecv
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|fout
operator|=
name|fopen
argument_list|(
name|local
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fout
operator|==
name|NULL
condition|)
name|PERROR
argument_list|(
literal|"OpenOutputFile"
argument_list|,
name|local
argument_list|)
expr_stmt|;
return|return
operator|(
name|fout
operator|)
return|;
block|}
end_function

begin_comment
comment|/* OpenOutputFile */
end_comment

begin_function
name|void
name|ReceiveBinary
parameter_list|(
name|FILE
modifier|*
name|din
parameter_list|,
name|FILE
modifier|*
name|fout
parameter_list|,
name|int
modifier|*
name|do_reports
parameter_list|,
name|char
modifier|*
name|localfn
parameter_list|)
block|{
name|int
name|c
decl_stmt|,
name|d
decl_stmt|,
name|do2
decl_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
comment|/* Clear any old error left around. */
name|do2
operator|=
operator|*
name|do_reports
expr_stmt|;
comment|/* A slight optimization :-) */
name|bytes
operator|=
literal|0
expr_stmt|;
comment|/* Init the byte-transfer counter. */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Read a block from the input stream. */
name|c
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|din
argument_list|)
argument_list|,
name|xferbuf
argument_list|,
operator|(
name|int
operator|)
name|xferbufsize
argument_list|)
expr_stmt|;
comment|/* If c is zero, then we've read the whole file. */
if|if
condition|(
name|c
operator|==
literal|0
condition|)
break|break;
comment|/* Check for errors that may have occurred while reading. */
if|if
condition|(
name|c
operator|<
literal|0
condition|)
block|{
comment|/* Error occurred while reading. */
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
name|PERROR
argument_list|(
literal|"ReceiveBinary"
argument_list|,
literal|"netin"
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|-
literal|1
expr_stmt|;
break|break;
block|}
comment|/* Write out the same block we just read in. */
name|d
operator|=
name|write
argument_list|(
name|fileno
argument_list|(
name|fout
argument_list|)
argument_list|,
name|xferbuf
argument_list|,
name|c
argument_list|)
expr_stmt|;
comment|/* Check for write errors. */
if|if
condition|(
operator|(
name|d
operator|<
literal|0
operator|)
operator|||
operator|(
name|ferror
argument_list|(
name|fout
argument_list|)
operator|)
condition|)
block|{
comment|/* Error occurred while writing. */
name|PERROR
argument_list|(
literal|"ReceiveBinary"
argument_list|,
literal|"outfile"
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|d
operator|<
name|c
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: short write\n"
argument_list|,
name|localfn
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Update the byte counter. */
name|bytes
operator|+=
operator|(
name|long
operator|)
name|c
expr_stmt|;
comment|/* Print progress indicator. */
if|if
condition|(
name|do2
operator|!=
literal|0
condition|)
name|do2
operator|=
name|progress_report
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|*
name|do_reports
operator|=
name|do2
expr_stmt|;
comment|/* Update the real do_reports variable. */
block|}
end_function

begin_comment
comment|/* ReceiveBinary */
end_comment

begin_function
name|void
name|AddRedirLine
parameter_list|(
name|char
modifier|*
name|str2
parameter_list|)
block|{
specifier|register
name|struct
name|lslist
modifier|*
name|new
decl_stmt|;
operator|(
name|void
operator|)
name|Strncpy
argument_list|(
name|indataline
argument_list|,
name|str2
argument_list|)
expr_stmt|;
name|new
operator|=
operator|(
expr|struct
name|lslist
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
sizeof|sizeof
argument_list|(
expr|struct
name|lslist
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|new
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|(
name|new
operator|->
name|string
operator|=
name|NewString
argument_list|(
name|str2
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|lshead
operator|==
name|NULL
condition|)
name|lshead
operator|=
name|lstail
operator|=
name|new
expr_stmt|;
else|else
block|{
name|lstail
operator|->
name|next
operator|=
name|new
expr_stmt|;
name|lstail
operator|=
name|new
expr_stmt|;
block|}
block|}
block|}
block|}
end_function

begin_comment
comment|/* AddRedirLine */
end_comment

begin_function
name|void
name|ReceiveAscii
parameter_list|(
name|FILE
modifier|*
name|din
parameter_list|,
name|FILE
modifier|*
name|fout
parameter_list|,
name|int
modifier|*
name|do_reports
parameter_list|,
name|char
modifier|*
name|localfn
parameter_list|,
name|int
name|lineMode
parameter_list|)
block|{
name|string
name|str2
decl_stmt|;
name|int
name|nchars
init|=
literal|0
decl_stmt|,
name|c
decl_stmt|;
name|char
modifier|*
name|linePtr
decl_stmt|;
name|int
name|do2
init|=
operator|*
name|do_reports
decl_stmt|,
name|stripped
decl_stmt|;
name|next_report
operator|=
name|xferbufsize
expr_stmt|;
name|bytes
operator|=
name|errno
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|lineMode
condition|)
block|{
while|while
condition|(
operator|(
name|linePtr
operator|=
name|FGets
argument_list|(
name|str2
argument_list|,
name|din
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|bytes
operator|+=
operator|(
name|long
operator|)
name|RemoveTrailingNewline
argument_list|(
name|linePtr
argument_list|,
operator|&
name|stripped
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_ls
operator|||
name|debug
operator|>
literal|0
condition|)
name|AddRedirLine
argument_list|(
name|linePtr
argument_list|)
expr_stmt|;
comment|/* Shutup while getting remote size and mod time. */
if|if
condition|(
operator|!
name|buffer_only
condition|)
block|{
name|c
operator|=
name|fputs
argument_list|(
name|linePtr
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|stripped
operator|>
literal|0
condition|)
name|c
operator|=
name|fputc
argument_list|(
literal|'\n'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|c
operator|==
name|EOF
operator|)
operator|||
operator|(
name|ferror
argument_list|(
name|fout
argument_list|)
operator|)
condition|)
block|{
name|PERROR
argument_list|(
literal|"ReceiveAscii"
argument_list|,
literal|"outfile"
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
comment|/* Print progress indicator. */
if|if
condition|(
name|do2
operator|&&
name|bytes
operator|>
name|next_report
condition|)
name|do2
operator|=
name|progress_report
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|din
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
name|linePtr
operator|=
name|str2
expr_stmt|;
while|while
condition|(
name|c
operator|==
literal|'\r'
condition|)
block|{
name|bytes
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|din
argument_list|)
operator|)
operator|!=
literal|'\n'
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|fout
argument_list|)
condition|)
goto|goto
name|break2
goto|;
comment|/* Shutup while getting remote size and mod time. */
if|if
condition|(
operator|!
name|buffer_only
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\r'
argument_list|,
name|fout
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|==
literal|'\0'
condition|)
block|{
name|bytes
operator|++
expr_stmt|;
goto|goto
name|contin2
goto|;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
goto|goto
name|contin2
goto|;
block|}
block|}
comment|/* Shutup while getting remote size and mod time. */
if|if
condition|(
operator|!
name|buffer_only
condition|)
operator|(
name|void
operator|)
name|putc
argument_list|(
name|c
argument_list|,
name|fout
argument_list|)
expr_stmt|;
name|bytes
operator|++
expr_stmt|;
comment|/* Print progress indicator. */
if|if
condition|(
name|do2
operator|&&
name|bytes
operator|>
name|next_report
condition|)
name|do2
operator|=
name|progress_report
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* No seg violations, please */
if|if
condition|(
name|nchars
operator|<
sizeof|sizeof
argument_list|(
name|str2
argument_list|)
operator|-
literal|1
condition|)
block|{
operator|*
name|linePtr
operator|++
operator|=
name|c
expr_stmt|;
comment|/* build redir string */
name|nchars
operator|++
expr_stmt|;
block|}
name|contin2
label|:
comment|/* Save the input line in the buffer for recall later. */
if|if
condition|(
name|c
operator|==
literal|'\n'
operator|&&
name|is_ls
condition|)
block|{
operator|*
operator|--
name|linePtr
operator|=
literal|0
expr_stmt|;
name|AddRedirLine
argument_list|(
name|str2
argument_list|)
expr_stmt|;
name|nchars
operator|=
literal|0
expr_stmt|;
block|}
block|}
comment|/* while ((c = getc(din)) != EOF) */
name|break2
label|:
if|if
condition|(
name|ferror
argument_list|(
name|din
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
name|PERROR
argument_list|(
literal|"ReceiveAscii"
argument_list|,
literal|"netin"
argument_list|)
expr_stmt|;
name|bytes
operator|=
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|ferror
argument_list|(
name|fout
argument_list|)
condition|)
block|{
if|if
condition|(
name|errno
operator|!=
name|EPIPE
condition|)
name|PERROR
argument_list|(
literal|"ReceiveAscii"
argument_list|,
name|localfn
argument_list|)
expr_stmt|;
block|}
operator|*
name|do_reports
operator|=
name|do2
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ReceiveAscii */
end_comment

begin_function
name|void
name|CloseOutputFile
parameter_list|(
name|FILE
modifier|*
name|f
parameter_list|,
name|int
name|filetype
parameter_list|,
name|char
modifier|*
name|name
parameter_list|,
name|time_t
name|mt
parameter_list|)
block|{
name|struct
name|utimbuf
name|ut
decl_stmt|;
if|if
condition|(
name|f
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|f
argument_list|)
expr_stmt|;
if|if
condition|(
name|filetype
operator|==
name|IS_FILE
condition|)
block|{
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|DONT_TIMESTAMP
if|if
condition|(
name|mt
operator|!=
operator|(
name|time_t
operator|)
literal|0
condition|)
block|{
name|ut
operator|.
name|actime
operator|=
name|ut
operator|.
name|modtime
operator|=
name|mt
expr_stmt|;
operator|(
name|void
operator|)
name|utime
argument_list|(
name|name
argument_list|,
operator|&
name|ut
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* DONT_TIMESTAMP */
block|}
elseif|else
if|if
condition|(
name|filetype
operator|==
name|IS_PIPE
condition|)
block|{
operator|(
name|void
operator|)
name|pclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* close_file */
end_comment

begin_function
name|void
name|ResetOldType
parameter_list|(
name|int
name|oldtype
parameter_list|)
block|{
name|int
name|oldv
decl_stmt|;
if|if
condition|(
name|oldtype
operator|>=
literal|0
condition|)
block|{
name|oldv
operator|=
name|verbose
expr_stmt|;
if|if
condition|(
operator|!
name|debug
condition|)
name|verbose
operator|=
name|V_QUIET
expr_stmt|;
operator|(
name|void
operator|)
name|SetTypeByNumber
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|verbose
operator|=
name|oldv
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* ResetOldType */
end_comment

begin_function
name|int
name|FileType
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|)
block|{
name|int
name|ft
init|=
name|IS_FILE
decl_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|fname
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
name|ft
operator|=
name|IS_STREAM
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|fname
operator|==
literal|'|'
condition|)
name|ft
operator|=
name|IS_PIPE
expr_stmt|;
return|return
operator|(
name|ft
operator|)
return|;
block|}
end_function

begin_comment
comment|/* FileType */
end_comment

begin_function
name|void
name|CloseData
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|data
operator|>=
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* CloseData */
end_comment

begin_function
name|int
name|recvrequest
parameter_list|(
name|char
modifier|*
name|cmd
parameter_list|,
name|char
modifier|*
name|local
parameter_list|,
name|char
modifier|*
name|remote
parameter_list|,
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|FILE
modifier|*
name|fout
init|=
name|NULL
decl_stmt|,
modifier|*
name|din
init|=
name|NULL
decl_stmt|;
name|Sig_t
name|oldintr
init|=
name|NULL
decl_stmt|,
name|oldintp
init|=
name|NULL
decl_stmt|;
name|int
name|oldtype
init|=
operator|-
literal|1
decl_stmt|,
name|is_retr
decl_stmt|;
name|int
name|nfnd
decl_stmt|;
name|char
name|msg
decl_stmt|;
name|struct
name|fd_set
name|mask
decl_stmt|;
name|int
name|filetype
decl_stmt|,
name|do_reports
init|=
literal|0
decl_stmt|;
name|string
name|remote_dir
decl_stmt|;
name|time_t
name|remfTime
init|=
literal|0
decl_stmt|;
name|int
name|result
init|=
operator|-
literal|1
decl_stmt|;
name|dbprintf
argument_list|(
literal|"---> cmd: %s;  rmt: %s;  loc: %s;  mode: %s.\n"
argument_list|,
name|cmd
argument_list|,
name|remote
operator|==
name|NULL
condition|?
literal|"(null)"
else|:
name|remote
argument_list|,
name|local
operator|==
name|NULL
condition|?
literal|"(null)"
else|:
name|local
argument_list|,
name|mode
argument_list|)
expr_stmt|;
name|is_retr
operator|=
name|strcmp
argument_list|(
name|cmd
argument_list|,
literal|"RETR"
argument_list|)
operator|==
literal|0
expr_stmt|;
name|GetLSRemoteDir
argument_list|(
name|remote
argument_list|,
name|remote_dir
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|filetype
operator|=
name|FileType
argument_list|(
name|local
argument_list|)
operator|)
operator|==
name|IS_FILE
condition|)
block|{
if|if
condition|(
name|AdjustLocalFileName
argument_list|(
name|local
argument_list|)
condition|)
goto|goto
name|xx
goto|;
block|}
name|file_size
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|filetype
operator|==
name|IS_FILE
condition|)
name|file_size
operator|=
name|GetDateAndSize
argument_list|(
name|remote
argument_list|,
operator|(
name|unsigned
name|long
operator|*
operator|)
operator|&
name|remfTime
argument_list|)
expr_stmt|;
if|if
condition|(
name|initconn
argument_list|()
condition|)
goto|goto
name|xx
goto|;
name|oldtype
operator|=
name|SetToAsciiForLS
argument_list|(
name|is_retr
argument_list|,
name|curtype
argument_list|)
expr_stmt|;
comment|/* Issue the NLST command but don't wait for the reply.  Some FTP   	 * servers make the data connection before issuing the   	 * "150 Opening ASCII mode data connection for /bin/ls" reply.  	 */
if|if
condition|(
name|IssueCommand
argument_list|(
name|cmd
argument_list|,
name|remote
argument_list|)
condition|)
goto|goto
name|xx
goto|;
if|if
condition|(
operator|(
name|fout
operator|=
name|OpenOutputFile
argument_list|(
name|filetype
argument_list|,
name|local
argument_list|,
name|mode
argument_list|,
operator|&
name|oldintp
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|xx
goto|;
if|if
condition|(
operator|(
name|din
operator|=
name|dataconn
argument_list|(
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
goto|goto
name|Abort
goto|;
ifdef|#
directive|ifdef
name|TRY_NOREPLY
comment|/* Now get the reply we skipped above. */
operator|(
name|void
operator|)
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_reports
operator|=
name|NOT_VQUIET
operator|&&
name|is_retr
operator|&&
name|filetype
operator|==
name|IS_FILE
expr_stmt|;
if|if
condition|(
name|do_reports
condition|)
name|do_reports
operator|=
name|start_progress
argument_list|(
literal|0
argument_list|,
name|local
argument_list|)
expr_stmt|;
if|if
condition|(
name|setjmp
argument_list|(
name|recvabort
argument_list|)
condition|)
block|{
ifdef|#
directive|ifdef
name|TRY_ABOR
goto|goto
name|Abort
goto|;
else|#
directive|else
comment|/* Just read the rest of the stream without doing anything with 		 * the results. 		 */
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Don't bug us while aborting. */
while|while
condition|(
name|read
argument_list|(
name|fileno
argument_list|(
name|din
argument_list|)
argument_list|,
name|xferbuf
argument_list|,
operator|(
name|int
operator|)
name|xferbufsize
argument_list|)
operator|>
literal|0
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\rAborted.                   \n"
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|abortrecv
argument_list|)
expr_stmt|;
if|if
condition|(
name|curtype
operator|==
name|TYPE_A
condition|)
name|ReceiveAscii
argument_list|(
name|din
argument_list|,
name|fout
argument_list|,
operator|&
name|do_reports
argument_list|,
name|local
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|ReceiveBinary
argument_list|(
name|din
argument_list|,
name|fout
argument_list|,
operator|&
name|do_reports
argument_list|,
name|local
argument_list|)
expr_stmt|;
name|result
operator|=
name|NOERR
expr_stmt|;
comment|/* Don't interrupt us now, since we finished successfully. */
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
block|}
name|CloseData
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
goto|goto
name|xx
goto|;
name|Abort
label|:
comment|/* Abort using RFC959 recommended IP,SYNC sequence  */
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
comment|/* Don't bug us while aborting. */
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cpend
operator|||
operator|!
name|cout
condition|)
goto|goto
name|xx
goto|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%c%c"
argument_list|,
name|IAC
argument_list|,
name|IP
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cout
argument_list|)
expr_stmt|;
name|msg
operator|=
name|IAC
expr_stmt|;
comment|/* send IAC in urgent mode instead of DM because UNIX places oob mark */
comment|/* after urgent byte rather than before as now is protocol            */
if|if
condition|(
name|send
argument_list|(
name|fileno
argument_list|(
name|cout
argument_list|)
argument_list|,
operator|&
name|msg
argument_list|,
literal|1
argument_list|,
name|MSG_OOB
argument_list|)
operator|!=
literal|1
condition|)
name|PERROR
argument_list|(
literal|"recvrequest"
argument_list|,
literal|"abort"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|cout
argument_list|,
literal|"%cABOR\r\n"
argument_list|,
name|DM
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|cout
argument_list|)
expr_stmt|;
name|FD_ZERO
argument_list|(
operator|&
name|mask
argument_list|)
expr_stmt|;
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|cin
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
name|din
condition|)
name|FD_SET
argument_list|(
name|fileno
argument_list|(
name|din
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|nfnd
operator|=
name|empty
argument_list|(
operator|&
name|mask
argument_list|,
literal|10
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|nfnd
operator|<
literal|0
condition|)
name|PERROR
argument_list|(
literal|"recvrequest"
argument_list|,
literal|"abort"
argument_list|)
expr_stmt|;
name|lostpeer
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|din
operator|&&
name|FD_ISSET
argument_list|(
name|fileno
argument_list|(
name|din
argument_list|)
argument_list|,
operator|&
name|mask
argument_list|)
condition|)
block|{
while|while
condition|(
operator|(
name|read
argument_list|(
name|fileno
argument_list|(
name|din
argument_list|)
argument_list|,
name|xferbuf
argument_list|,
name|xferbufsize
argument_list|)
operator|)
operator|>
literal|0
condition|)
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|getreply
argument_list|(
literal|0
argument_list|)
operator|)
operator|==
name|ERROR
operator|&&
name|code
operator|==
literal|552
condition|)
block|{
comment|/* needed for nic style abort */
name|CloseData
argument_list|()
expr_stmt|;
operator|(
name|void
operator|)
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|getreply
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|result
operator|=
operator|-
literal|1
expr_stmt|;
name|CloseData
argument_list|()
expr_stmt|;
name|xx
label|:
name|CloseOutputFile
argument_list|(
name|fout
argument_list|,
name|filetype
argument_list|,
name|local
argument_list|,
name|remfTime
argument_list|)
expr_stmt|;
name|dbprintf
argument_list|(
literal|"outfile closed.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|din
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|din
argument_list|)
expr_stmt|;
if|if
condition|(
name|is_retr
condition|)
name|end_progress
argument_list|(
literal|"received"
argument_list|,
name|local
argument_list|,
name|remote
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintr
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldintp
condition|)
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGPIPE
argument_list|,
name|oldintp
argument_list|)
expr_stmt|;
name|dbprintf
argument_list|(
literal|"recvrequest result = %d.\n"
argument_list|,
name|result
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldtype
operator|>=
literal|0
condition|)
name|ResetOldType
argument_list|(
name|oldtype
argument_list|)
expr_stmt|;
name|bytes
operator|=
literal|0L
expr_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* recvrequest */
end_comment

begin_comment
comment|/*  * Need to start a listen on the data channel  * before we send the command, otherwise the  * server's connect may fail.  */
end_comment

begin_function
name|int
name|initconn
parameter_list|(
name|void
parameter_list|)
block|{
specifier|register
name|char
modifier|*
name|p
decl_stmt|,
modifier|*
name|a
decl_stmt|;
name|int
name|result
decl_stmt|,
name|len
decl_stmt|,
name|tmpno
init|=
literal|0
decl_stmt|;
name|int
name|on
init|=
literal|1
decl_stmt|,
name|rval
decl_stmt|;
name|string
name|str
decl_stmt|;
name|Sig_t
name|oldintr
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|a1
decl_stmt|,
name|a2
decl_stmt|,
name|a3
decl_stmt|,
name|a4
decl_stmt|,
name|p1
decl_stmt|,
name|p2
decl_stmt|;
name|unsigned
name|char
name|n
index|[
literal|6
index|]
decl_stmt|;
name|oldintr
operator|=
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
if|if
condition|(
name|using_pasv
condition|)
block|{
name|result
operator|=
name|command
argument_list|(
literal|"PASV"
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|!=
name|COMPLETE
condition|)
block|{
name|printf
argument_list|(
literal|"Passive mode refused.\n"
argument_list|)
expr_stmt|;
name|using_pasv
operator|=
literal|0
expr_stmt|;
goto|goto
name|TryPort
goto|;
block|}
comment|/* 		 * What we've got here is a string of comma separated one-byte 		 * unsigned integer values.  The first four are the IP address, 		 * the fifth is the MSB of the port address, and the sixth is the 		 * LSB of the port address.  Extract this data and prepare a 		 * 'data_addr' (struct sockaddr_in). 		 */
for|for
control|(
name|cp
operator|=
name|reply_string
operator|+
literal|4
init|;
operator|*
name|cp
operator|!=
literal|'\0'
condition|;
name|cp
operator|++
control|)
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
break|break;
if|if
condition|(
name|sscanf
argument_list|(
name|cp
argument_list|,
literal|"%d,%d,%d,%d,%d,%d"
argument_list|,
operator|&
name|a1
argument_list|,
operator|&
name|a2
argument_list|,
operator|&
name|a3
argument_list|,
operator|&
name|a4
argument_list|,
operator|&
name|p1
argument_list|,
operator|&
name|p2
argument_list|)
operator|!=
literal|6
condition|)
block|{
name|printf
argument_list|(
literal|"Cannot parse PASV response: %s\n"
argument_list|,
name|reply_string
argument_list|)
expr_stmt|;
name|using_pasv
operator|=
literal|0
expr_stmt|;
goto|goto
name|TryPort
goto|;
block|}
name|data
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
goto|goto
name|Return
goto|;
block|}
ifdef|#
directive|ifdef
name|LINGER
comment|/* If puts don't complete, you could try this. */
block|{
name|struct
name|linger
name|li
decl_stmt|;
name|li
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|li
operator|.
name|l_linger
operator|=
literal|900
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|data
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|li
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linger
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"setsockopt(SO_LINGER)"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* LINGER */
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
operator|&&
name|setsockopt
argument_list|(
name|data
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"setscokopt (ignored)"
argument_list|)
expr_stmt|;
block|}
name|n
index|[
literal|0
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|a1
expr_stmt|;
name|n
index|[
literal|1
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|a2
expr_stmt|;
name|n
index|[
literal|2
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|a3
expr_stmt|;
name|n
index|[
literal|3
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|a4
expr_stmt|;
name|n
index|[
literal|4
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|p1
expr_stmt|;
name|n
index|[
literal|5
index|]
operator|=
operator|(
name|unsigned
name|char
operator|)
name|p2
expr_stmt|;
name|data_addr
operator|.
name|sin_family
operator|=
name|AF_INET
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|n
index|[
literal|0
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data_addr
operator|.
name|sin_addr
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|bcopy
argument_list|(
operator|(
name|void
operator|*
operator|)
operator|&
name|n
index|[
literal|4
index|]
argument_list|,
operator|(
name|void
operator|*
operator|)
operator|&
name|data_addr
operator|.
name|sin_port
argument_list|,
literal|2
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SOCKS
if|if
condition|(
name|Rconnect
argument_list|(
name|data
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|data_addr
argument_list|,
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|data_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|Connect
argument_list|(
name|data
argument_list|,
operator|&
name|data_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|data_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
if|if
condition|(
name|errno
operator|==
name|ECONNREFUSED
condition|)
block|{
name|dbprintf
argument_list|(
literal|"Could not connect to port specified by server;\n"
argument_list|)
expr_stmt|;
name|dbprintf
argument_list|(
literal|"Falling back to PORT mode.\n"
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
operator|-
literal|1
expr_stmt|;
name|using_pasv
operator|=
literal|0
expr_stmt|;
goto|goto
name|TryPort
goto|;
block|}
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"connect"
argument_list|)
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
goto|goto
name|Return
goto|;
block|}
name|rval
operator|=
literal|0
expr_stmt|;
goto|goto
name|Return
goto|;
block|}
name|TryPort
label|:
name|rval
operator|=
literal|0
expr_stmt|;
name|noport
label|:
name|data_addr
operator|=
name|myctladdr
expr_stmt|;
if|if
condition|(
name|sendport
condition|)
name|data_addr
operator|.
name|sin_port
operator|=
literal|0
expr_stmt|;
comment|/* let system pick one */
if|if
condition|(
name|data
operator|!=
operator|-
literal|1
condition|)
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|socket
argument_list|(
name|AF_INET
argument_list|,
name|SOCK_STREAM
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|data
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"socket"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmpno
condition|)
name|sendport
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
goto|goto
name|Return
goto|;
block|}
if|if
condition|(
operator|!
name|sendport
condition|)
if|if
condition|(
name|setsockopt
argument_list|(
name|data
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_REUSEADDR
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"setsockopt (reuse address)"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|SOCKS
if|if
condition|(
name|Rbind
argument_list|(
name|data
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|data_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|data_addr
argument_list|)
argument_list|,
name|hisctladdr
operator|.
name|sin_addr
operator|.
name|s_addr
argument_list|)
operator|<
literal|0
condition|)
block|{
else|#
directive|else
if|if
condition|(
name|Bind
argument_list|(
name|data
argument_list|,
operator|&
name|data_addr
argument_list|,
sizeof|sizeof
argument_list|(
name|data_addr
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
endif|#
directive|endif
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"bind"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|LINGER
comment|/* If puts don't complete, you could try this. */
block|{
name|struct
name|linger
name|li
decl_stmt|;
name|li
operator|.
name|l_onoff
operator|=
literal|1
expr_stmt|;
name|li
operator|.
name|l_linger
operator|=
literal|900
expr_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|data
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_LINGER
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|li
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|linger
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"setsockopt(SO_LINGER)"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* LINGER */
ifdef|#
directive|ifdef
name|IPTOS_THROUGHPUT
comment|/* transfers are background */
ifdef|#
directive|ifdef
name|IP_TOS
block|{
name|int
name|nType
init|=
name|IPTOS_THROUGHPUT
decl_stmt|;
if|if
condition|(
name|setsockopt
argument_list|(
name|data
argument_list|,
name|IPPROTO_IP
argument_list|,
name|IP_TOS
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|nType
argument_list|,
sizeof|sizeof
argument_list|(
name|nType
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"setsockopt(IP_TOS)"
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
endif|#
directive|endif
if|if
condition|(
name|options
operator|&
name|SO_DEBUG
operator|&&
name|setsockopt
argument_list|(
name|data
argument_list|,
name|SOL_SOCKET
argument_list|,
name|SO_DEBUG
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|on
argument_list|,
sizeof|sizeof
argument_list|(
name|on
argument_list|)
argument_list|)
operator|<
literal|0
condition|)
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"setsockopt (ignored)"
argument_list|)
expr_stmt|;
name|len
operator|=
sizeof|sizeof
argument_list|(
name|data_addr
argument_list|)
expr_stmt|;
if|if
condition|(
name|Getsockname
argument_list|(
name|data
argument_list|,
operator|(
name|char
operator|*
operator|)
operator|&
name|data_addr
argument_list|,
operator|&
name|len
argument_list|)
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"getsockname"
argument_list|)
expr_stmt|;
goto|goto
name|bad
goto|;
block|}
ifdef|#
directive|ifdef
name|SOCKS
if|if
condition|(
name|Rlisten
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
else|#
directive|else
if|if
condition|(
name|listen
argument_list|(
name|data
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
condition|)
endif|#
directive|endif
name|PERROR
argument_list|(
literal|"initconn"
argument_list|,
literal|"listen"
argument_list|)
expr_stmt|;
if|if
condition|(
name|sendport
condition|)
block|{
name|a
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data_addr
operator|.
name|sin_addr
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
operator|&
name|data_addr
operator|.
name|sin_port
expr_stmt|;
define|#
directive|define
name|UC
parameter_list|(
name|x
parameter_list|)
value|(int) (((int) x)& 0xff)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|str
argument_list|,
literal|"PORT %d,%d,%d,%d,%d,%d"
argument_list|,
name|UC
argument_list|(
name|a
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|UC
argument_list|(
name|a
index|[
literal|1
index|]
argument_list|)
argument_list|,
name|UC
argument_list|(
name|a
index|[
literal|2
index|]
argument_list|)
argument_list|,
name|UC
argument_list|(
name|a
index|[
literal|3
index|]
argument_list|)
argument_list|,
name|UC
argument_list|(
name|p
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|UC
argument_list|(
name|p
index|[
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|result
operator|=
name|command
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|result
operator|==
name|ERROR
operator|&&
name|sendport
operator|==
operator|-
literal|1
condition|)
block|{
name|sendport
operator|=
literal|0
expr_stmt|;
name|tmpno
operator|=
literal|1
expr_stmt|;
goto|goto
name|noport
goto|;
block|}
name|rval
operator|=
operator|(
name|result
operator|!=
name|COMPLETE
operator|)
expr_stmt|;
goto|goto
name|Return
goto|;
block|}
if|if
condition|(
name|tmpno
condition|)
name|sendport
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
literal|0
expr_stmt|;
goto|goto
name|Return
goto|;
name|bad
label|:
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
operator|,
name|data
operator|=
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|tmpno
condition|)
name|sendport
operator|=
literal|1
expr_stmt|;
name|rval
operator|=
literal|1
expr_stmt|;
name|Return
label|:
operator|(
name|void
operator|)
name|Signal
argument_list|(
name|SIGINT
argument_list|,
name|oldintr
argument_list|)
expr_stmt|;
return|return
operator|(
name|rval
operator|)
return|;
block|}
comment|/* initconn */
name|FILE
modifier|*
name|dataconn
parameter_list|(
name|char
modifier|*
name|mode
parameter_list|)
block|{
name|struct
name|sockaddr_in
name|from
decl_stmt|;
name|FILE
modifier|*
name|fp
decl_stmt|;
name|int
name|s
decl_stmt|,
name|fromlen
init|=
sizeof|sizeof
argument_list|(
name|from
argument_list|)
decl_stmt|;
if|if
condition|(
name|using_pasv
condition|)
return|return
operator|(
name|fdopen
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
operator|)
return|;
ifdef|#
directive|ifdef
name|SOCKS
name|s
operator|=
name|Raccept
argument_list|(
name|data
argument_list|,
operator|(
expr|struct
name|sockaddr
operator|*
operator|)
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
else|#
directive|else
name|s
operator|=
name|Accept
argument_list|(
name|data
argument_list|,
operator|&
name|from
argument_list|,
operator|&
name|fromlen
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|s
operator|<
literal|0
condition|)
block|{
name|PERROR
argument_list|(
literal|"dataconn"
argument_list|,
literal|"accept"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
operator|,
name|data
operator|=
operator|-
literal|1
expr_stmt|;
name|fp
operator|=
name|NULL
expr_stmt|;
block|}
else|else
block|{
operator|(
name|void
operator|)
name|close
argument_list|(
name|data
argument_list|)
expr_stmt|;
name|data
operator|=
name|s
expr_stmt|;
name|fp
operator|=
name|safeopen
argument_list|(
name|data
argument_list|,
name|mode
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
name|fp
operator|)
return|;
block|}
end_function

begin_comment
comment|/* dataconn */
end_comment

begin_comment
comment|/* eof ftp.c */
end_comment

end_unit

