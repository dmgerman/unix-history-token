begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 - 2005 Tony Finch<dot@dotat.at>.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by Dave Yost.  * It was rewritten to support ANSI C by Tony Finch. The original version of  * unifdef carried the following copyright notice. None of its code remains  * in this version (though some of the names remain).  *  * Copyright (c) 1985, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static const char copyright[] = "@(#) Copyright (c) 1985, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n";
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|__IDSTRING
end_ifdef

begin_expr_stmt
name|__IDSTRING
argument_list|(
name|Berkeley
argument_list|,
literal|"@(#)unifdef.c	8.1 (Berkeley) 6/6/93"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__IDSTRING
argument_list|(
name|NetBSD
argument_list|,
literal|"$NetBSD: unifdef.c,v 1.8 2000/07/03 02:51:36 matt Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_expr_stmt
name|__IDSTRING
argument_list|(
name|dotat
argument_list|,
literal|"$dotat: things/unifdef.c,v 1.171 2005/03/08 12:38:48 fanf2 Exp $"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__FBSDID
end_ifdef

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * unifdef - remove ifdef'ed lines  *  *  Wishlist:  *      provide an option which will append the name of the  *        appropriate symbol after #else's and #endif's  *      provide an option which will check symbols after  *        #else's and #endif's to see that they match their  *        corresponding #ifdef or #ifndef  *  *   The first two items above require better buffer handling, which would  *     also make it possible to handle all "dodgy" directives correctly.  */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdarg.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_comment
comment|/* types of input lines: */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|LT_TRUEI
block|,
comment|/* a true #if with ignore flag */
name|LT_FALSEI
block|,
comment|/* a false #if with ignore flag */
name|LT_IF
block|,
comment|/* an unknown #if */
name|LT_TRUE
block|,
comment|/* a true #if */
name|LT_FALSE
block|,
comment|/* a false #if */
name|LT_ELIF
block|,
comment|/* an unknown #elif */
name|LT_ELTRUE
block|,
comment|/* a true #elif */
name|LT_ELFALSE
block|,
comment|/* a false #elif */
name|LT_ELSE
block|,
comment|/* #else */
name|LT_ENDIF
block|,
comment|/* #endif */
name|LT_DODGY
block|,
comment|/* flag: directive is not on one line */
name|LT_DODGY_LAST
init|=
name|LT_DODGY
operator|+
name|LT_ENDIF
block|,
name|LT_PLAIN
block|,
comment|/* ordinary line */
name|LT_EOF
block|,
comment|/* end of file */
name|LT_COUNT
block|}
name|Linetype
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|linetype_name
index|[]
init|=
block|{
literal|"TRUEI"
block|,
literal|"FALSEI"
block|,
literal|"IF"
block|,
literal|"TRUE"
block|,
literal|"FALSE"
block|,
literal|"ELIF"
block|,
literal|"ELTRUE"
block|,
literal|"ELFALSE"
block|,
literal|"ELSE"
block|,
literal|"ENDIF"
block|,
literal|"DODGY TRUEI"
block|,
literal|"DODGY FALSEI"
block|,
literal|"DODGY IF"
block|,
literal|"DODGY TRUE"
block|,
literal|"DODGY FALSE"
block|,
literal|"DODGY ELIF"
block|,
literal|"DODGY ELTRUE"
block|,
literal|"DODGY ELFALSE"
block|,
literal|"DODGY ELSE"
block|,
literal|"DODGY ENDIF"
block|,
literal|"PLAIN"
block|,
literal|"EOF"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of #if processing */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|IS_OUTSIDE
block|,
name|IS_FALSE_PREFIX
block|,
comment|/* false #if followed by false #elifs */
name|IS_TRUE_PREFIX
block|,
comment|/* first non-false #(el)if is true */
name|IS_PASS_MIDDLE
block|,
comment|/* first non-false #(el)if is unknown */
name|IS_FALSE_MIDDLE
block|,
comment|/* a false #elif after a pass state */
name|IS_TRUE_MIDDLE
block|,
comment|/* a true #elif after a pass state */
name|IS_PASS_ELSE
block|,
comment|/* an else after a pass state */
name|IS_FALSE_ELSE
block|,
comment|/* an else after a true state */
name|IS_TRUE_ELSE
block|,
comment|/* an else after only false states */
name|IS_FALSE_TRAILER
block|,
comment|/* #elifs after a true are false */
name|IS_COUNT
block|}
name|Ifstate
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|ifstate_name
index|[]
init|=
block|{
literal|"OUTSIDE"
block|,
literal|"FALSE_PREFIX"
block|,
literal|"TRUE_PREFIX"
block|,
literal|"PASS_MIDDLE"
block|,
literal|"FALSE_MIDDLE"
block|,
literal|"TRUE_MIDDLE"
block|,
literal|"PASS_ELSE"
block|,
literal|"FALSE_ELSE"
block|,
literal|"TRUE_ELSE"
block|,
literal|"FALSE_TRAILER"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of comment parser */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|NO_COMMENT
init|=
name|false
block|,
comment|/* outside a comment */
name|C_COMMENT
block|,
comment|/* in a comment like this one */
name|CXX_COMMENT
block|,
comment|/* between // and end of line */
name|STARTING_COMMENT
block|,
comment|/* just after slash-backslash-newline */
name|FINISHING_COMMENT
block|,
comment|/* star-backslash-newline in a C comment */
name|CHAR_LITERAL
block|,
comment|/* inside '' */
name|STRING_LITERAL
comment|/* inside "" */
block|}
name|Comment_state
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|comment_name
index|[]
init|=
block|{
literal|"NO"
block|,
literal|"C"
block|,
literal|"CXX"
block|,
literal|"STARTING"
block|,
literal|"FINISHING"
block|,
literal|"CHAR"
block|,
literal|"STRING"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of preprocessor line parser */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|LS_START
block|,
comment|/* only space and comments on this line */
name|LS_HASH
block|,
comment|/* only space, comments, and a hash */
name|LS_DIRTY
comment|/* this line can't be a preprocessor line */
block|}
name|Line_state
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|linestate_name
index|[]
init|=
block|{
literal|"START"
block|,
literal|"HASH"
block|,
literal|"DIRTY"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Minimum translation limits from ISO/IEC 9899:1999 5.2.4.1  */
end_comment

begin_define
define|#
directive|define
name|MAXDEPTH
value|64
end_define

begin_comment
comment|/* maximum #if nesting */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|4096
end_define

begin_comment
comment|/* maximum length of line */
end_comment

begin_define
define|#
directive|define
name|MAXSYMS
value|4096
end_define

begin_comment
comment|/* maximum number of symbols */
end_comment

begin_comment
comment|/*  * Sometimes when editing a keyword the replacement text is longer, so  * we leave some space at the end of the tline buffer to accommodate this.  */
end_comment

begin_define
define|#
directive|define
name|EDITSLOP
value|10
end_define

begin_comment
comment|/*  * Globals.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|complement
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -c: do the complement */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|debugging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d: debugging reports */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|iocccok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -e: fewer IOCCC errors */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|killconsts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -k: eval constant #ifs */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|lnblank
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l: blank deleted lines */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|lnnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -n: add #line directives */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|symlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s: output symbol list */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t: this is a text file */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|symname
index|[
name|MAXSYMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol name */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|value
index|[
name|MAXSYMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Dsym=value */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ignore
index|[
name|MAXSYMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -iDsym or -iUsym */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file pointer */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name */
end_comment

begin_decl_stmt
specifier|static
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tline
index|[
name|MAXLINE
operator|+
name|EDITSLOP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input buffer plus space */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for editing #elif's */
end_comment

begin_decl_stmt
specifier|static
name|Comment_state
name|incomment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* comment parser state */
end_comment

begin_decl_stmt
specifier|static
name|Line_state
name|linestate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #if line parser state */
end_comment

begin_decl_stmt
specifier|static
name|Ifstate
name|ifstate
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #if processor state */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ignoring
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore comments state */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stifline
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of current #if */
end_comment

begin_decl_stmt
specifier|static
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current #if nesting */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of deleted lines */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|keepthis
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* don't delete constant #if */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exitstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program exit status */
end_comment

begin_function_decl
specifier|static
name|void
name|addsym
parameter_list|(
name|bool
parameter_list|,
name|bool
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|done
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findsym
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flushline
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Linetype
name|getline
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Linetype
name|ifeval
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignoreoff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignoreon
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keywordedit
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|skipcomment
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|skipsym
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|state
parameter_list|(
name|Ifstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|strlcmp
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unnest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|endsym
parameter_list|(
name|c
parameter_list|)
value|(!isalpha((unsigned char)c)&& !isdigit((unsigned char)c)&& c != '_')
end_define

begin_comment
comment|/*  * The main program.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"i:D:U:I:cdeklnst"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* treat stuff controlled by these symbols as text */
comment|/* 			 * For strict backwards-compatibility the U or D 			 * should be immediately after the -i but it doesn't 			 * matter much if we relax that requirement. 			 */
name|opt
operator|=
operator|*
name|optarg
operator|++
expr_stmt|;
if|if
condition|(
name|opt
operator|==
literal|'D'
condition|)
name|addsym
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|==
literal|'U'
condition|)
name|addsym
argument_list|(
name|true
argument_list|,
name|false
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* define a symbol */
name|addsym
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* undef a symbol */
name|addsym
argument_list|(
name|false
argument_list|,
name|false
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* no-op for compatibility with cpp */
break|break;
case|case
literal|'c'
case|:
comment|/* treat -D as -U and vice versa */
name|complement
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debugging
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* fewer errors from dodgy lines */
name|iocccok
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* process constant #ifs */
name|killconsts
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
comment|/* blank deleted lines instead of omitting them */
name|lnblank
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* add #line directive after deleted lines */
name|lnnum
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* only output list of symbols that control #ifs */
name|symlist
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* don't parse C comments */
name|text
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
condition|)
block|{
name|errx
argument_list|(
literal|2
argument_list|,
literal|"can only do one file"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
name|strcmp
argument_list|(
operator|*
name|argv
argument_list|,
literal|"-"
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|filename
operator|=
operator|*
name|argv
expr_stmt|;
name|input
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't open %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
literal|"[stdin]"
expr_stmt|;
name|input
operator|=
name|stdin
expr_stmt|;
block|}
name|process
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: unifdef [-cdeklnst] [-Ipath]"
literal|" [-Dsym[=val]] [-Usym] [-iDsym[=val]] [-iUsym] ... [file]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A state transition function alters the global #if processing state  * in a particular way. The table below is indexed by the current  * processing state and the type of the current line.  *  * Nesting is handled by keeping a stack of states; some transition  * functions increase or decrease the depth. They also maintain the  * ignore state on a stack. In some complicated cases they have to  * alter the preprocessor directive, as follows.  *  * When we have processed a group that starts off with a known-false  * #if/#elif sequence (which has therefore been deleted) followed by a  * #elif that we don't understand and therefore must keep, we edit the  * latter into a #if to keep the nesting correct.  *  * When we find a true #elif in a group, the following block will  * always be kept and the rest of the sequence after the next #elif or  * #else will be discarded. We edit the #elif into a #else and the  * following directive to #endif since this has the desired behaviour.  *  * "Dodgy" directives are split across multiple lines, the most common  * example being a multi-line comment hanging off the right of the  * directive. We can handle them correctly only if there is no change  * from printing to dropping (or vice versa) caused by that directive.  * If the directive is the first of a group we have a choice between  * failing with an error, or passing it through unchanged instead of  * evaluating it. The latter is not the default to avoid questions from  * users about unifdef unexpectedly leaving behind preprocessor directives.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|state_fn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* report an error */
end_comment

begin_function
specifier|static
name|void
name|Eelif
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Inappropriate #elif"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eelse
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Inappropriate #else"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eendif
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Inappropriate #endif"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eeof
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Premature EOF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eioccc
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Obfuscated preprocessor control line"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* plain line handling */
end_comment

begin_function
specifier|static
name|void
name|print
parameter_list|(
name|void
parameter_list|)
block|{
name|flushline
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop
parameter_list|(
name|void
parameter_list|)
block|{
name|flushline
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output lacks group's start line */
end_comment

begin_function
specifier|static
name|void
name|Strue
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_TRUE_PREFIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Sfalse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_PREFIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Selse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_TRUE_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print/pass this block */
end_comment

begin_function
specifier|static
name|void
name|Pelif
parameter_list|(
name|void
parameter_list|)
block|{
name|print
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_PASS_MIDDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Pelse
parameter_list|(
name|void
parameter_list|)
block|{
name|print
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_PASS_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Pendif
parameter_list|(
name|void
parameter_list|)
block|{
name|print
argument_list|()
expr_stmt|;
name|unnest
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* discard this block */
end_comment

begin_function
specifier|static
name|void
name|Dfalse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_TRAILER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Delif
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_MIDDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Delse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Dendif
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|unnest
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* first line of group */
end_comment

begin_function
specifier|static
name|void
name|Fdrop
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Dfalse
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Fpass
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Pelif
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ftrue
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Strue
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ffalse
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Sfalse
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* variable pedantry for obfuscated lines */
end_comment

begin_function
specifier|static
name|void
name|Oiffy
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iocccok
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|Fpass
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Oif
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iocccok
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|Fpass
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Oelif
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iocccok
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|Pelif
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ignore comments in this block */
end_comment

begin_function
specifier|static
name|void
name|Idrop
parameter_list|(
name|void
parameter_list|)
block|{
name|Fdrop
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Itrue
parameter_list|(
name|void
parameter_list|)
block|{
name|Ftrue
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ifalse
parameter_list|(
name|void
parameter_list|)
block|{
name|Ffalse
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* edit this line */
end_comment

begin_function
specifier|static
name|void
name|Mpass
parameter_list|(
name|void
parameter_list|)
block|{
name|strncpy
argument_list|(
name|keyword
argument_list|,
literal|"if  "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Pelif
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Mtrue
parameter_list|(
name|void
parameter_list|)
block|{
name|keywordedit
argument_list|(
literal|"else\n"
argument_list|)
expr_stmt|;
name|state
argument_list|(
name|IS_TRUE_MIDDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Melif
parameter_list|(
name|void
parameter_list|)
block|{
name|keywordedit
argument_list|(
literal|"endif\n"
argument_list|)
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_TRAILER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Melse
parameter_list|(
name|void
parameter_list|)
block|{
name|keywordedit
argument_list|(
literal|"endif\n"
argument_list|)
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|state_fn
modifier|*
specifier|const
name|trans_table
index|[
name|IS_COUNT
index|]
index|[
name|LT_COUNT
index|]
init|=
block|{
comment|/* IS_OUTSIDE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eendif
block|,
name|print
block|,
name|done
block|}
block|,
comment|/* IS_FALSE_PREFIX */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Mpass
block|,
name|Strue
block|,
name|Sfalse
block|,
name|Selse
block|,
name|Dendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Mpass
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|}
block|,
comment|/* IS_TRUE_PREFIX */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Delse
block|,
name|Dendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|print
block|,
name|Eeof
block|}
block|,
comment|/* IS_PASS_MIDDLE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Pelif
block|,
name|Mtrue
block|,
name|Delif
block|,
name|Pelse
block|,
name|Pendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Pelif
block|,
name|Oelif
block|,
name|Oelif
block|,
name|Pelse
block|,
name|Pendif
block|,
name|print
block|,
name|Eeof
block|}
block|,
comment|/* IS_FALSE_MIDDLE */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Pelif
block|,
name|Mtrue
block|,
name|Delif
block|,
name|Pelse
block|,
name|Pendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|}
block|,
comment|/* IS_TRUE_MIDDLE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Melif
block|,
name|Melif
block|,
name|Melif
block|,
name|Melse
block|,
name|Pendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Pendif
block|,
name|print
block|,
name|Eeof
block|}
block|,
comment|/* IS_PASS_ELSE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Pendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Pendif
block|,
name|print
block|,
name|Eeof
block|}
block|,
comment|/* IS_FALSE_ELSE */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Dendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|}
block|,
comment|/* IS_TRUE_ELSE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Dendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eioccc
block|,
name|print
block|,
name|Eeof
block|}
block|,
comment|/* IS_FALSE_TRAILER */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Delse
block|,
name|Dendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Delse
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|}
comment|/*TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF   TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF (DODGY)   PLAIN  EOF */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * State machine utility functions  */
end_comment

begin_function
specifier|static
name|void
name|done
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|incomment
condition|)
name|error
argument_list|(
literal|"EOF in comment"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ignoreoff
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
name|ignoring
index|[
name|depth
index|]
operator|=
name|ignoring
index|[
name|depth
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ignoreon
parameter_list|(
name|void
parameter_list|)
block|{
name|ignoring
index|[
name|depth
index|]
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|keywordedit
parameter_list|(
specifier|const
name|char
modifier|*
name|replacement
parameter_list|)
block|{
name|strlcpy
argument_list|(
name|keyword
argument_list|,
name|replacement
argument_list|,
name|tline
operator|+
sizeof|sizeof
argument_list|(
name|tline
argument_list|)
operator|-
name|keyword
argument_list|)
expr_stmt|;
name|print
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nest
parameter_list|(
name|void
parameter_list|)
block|{
name|depth
operator|+=
literal|1
expr_stmt|;
if|if
condition|(
name|depth
operator|>=
name|MAXDEPTH
condition|)
name|error
argument_list|(
literal|"Too many levels of nesting"
argument_list|)
expr_stmt|;
name|stifline
index|[
name|depth
index|]
operator|=
name|linenum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unnest
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
name|depth
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state
parameter_list|(
name|Ifstate
name|is
parameter_list|)
block|{
name|ifstate
index|[
name|depth
index|]
operator|=
name|is
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a line to the output or not, according to command line options.  */
end_comment

begin_function
specifier|static
name|void
name|flushline
parameter_list|(
name|bool
name|keep
parameter_list|)
block|{
if|if
condition|(
name|symlist
condition|)
return|return;
if|if
condition|(
name|keep
operator|^
name|complement
condition|)
block|{
if|if
condition|(
name|lnnum
operator|&&
name|delcount
operator|>
literal|0
condition|)
name|printf
argument_list|(
literal|"#line %d\n"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|tline
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|delcount
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lnblank
condition|)
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|exitstat
operator|=
literal|1
expr_stmt|;
name|delcount
operator|+=
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * The driver for the state machine.  */
end_comment

begin_function
specifier|static
name|void
name|process
parameter_list|(
name|void
parameter_list|)
block|{
name|Linetype
name|lineval
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|linenum
operator|++
expr_stmt|;
name|lineval
operator|=
name|getline
argument_list|()
expr_stmt|;
name|trans_table
index|[
name|ifstate
index|[
name|depth
index|]
index|]
index|[
name|lineval
index|]
operator|(
operator|)
expr_stmt|;
name|debug
argument_list|(
literal|"process %s -> %s depth %d"
argument_list|,
name|linetype_name
index|[
name|lineval
index|]
argument_list|,
name|ifstate_name
index|[
name|ifstate
index|[
name|depth
index|]
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse a line and determine its type. We keep the preprocessor line  * parser state between calls in the global variable linestate, with  * help from skipcomment().  */
end_comment

begin_function
specifier|static
name|Linetype
name|getline
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cursym
decl_stmt|;
name|int
name|kwlen
decl_stmt|;
name|Linetype
name|retval
decl_stmt|;
name|Comment_state
name|wascomment
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|tline
argument_list|,
name|MAXLINE
argument_list|,
name|input
argument_list|)
operator|==
name|NULL
condition|)
return|return
operator|(
name|LT_EOF
operator|)
return|;
name|retval
operator|=
name|LT_PLAIN
expr_stmt|;
name|wascomment
operator|=
name|incomment
expr_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|tline
argument_list|)
expr_stmt|;
if|if
condition|(
name|linestate
operator|==
name|LS_START
condition|)
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'#'
condition|)
block|{
name|linestate
operator|=
name|LS_HASH
expr_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|incomment
operator|&&
name|linestate
operator|==
name|LS_HASH
condition|)
block|{
name|keyword
operator|=
name|tline
operator|+
operator|(
name|cp
operator|-
name|tline
operator|)
expr_stmt|;
name|cp
operator|=
name|skipsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|kwlen
operator|=
name|cp
operator|-
name|keyword
expr_stmt|;
comment|/* no way can we deal with a continuation inside a keyword */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\\\n"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
if|if
condition|(
name|strlcmp
argument_list|(
literal|"ifdef"
argument_list|,
name|keyword
argument_list|,
name|kwlen
argument_list|)
operator|==
literal|0
operator|||
name|strlcmp
argument_list|(
literal|"ifndef"
argument_list|,
name|keyword
argument_list|,
name|kwlen
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cursym
operator|=
name|findsym
argument_list|(
name|cp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|retval
operator|=
name|LT_IF
expr_stmt|;
else|else
block|{
name|retval
operator|=
operator|(
name|keyword
index|[
literal|2
index|]
operator|==
literal|'n'
operator|)
condition|?
name|LT_FALSE
else|:
name|LT_TRUE
expr_stmt|;
if|if
condition|(
name|value
index|[
name|cursym
index|]
operator|==
name|NULL
condition|)
name|retval
operator|=
operator|(
name|retval
operator|==
name|LT_TRUE
operator|)
condition|?
name|LT_FALSE
else|:
name|LT_TRUE
expr_stmt|;
if|if
condition|(
name|ignore
index|[
name|cursym
index|]
condition|)
name|retval
operator|=
operator|(
name|retval
operator|==
name|LT_TRUE
operator|)
condition|?
name|LT_TRUEI
else|:
name|LT_FALSEI
expr_stmt|;
block|}
name|cp
operator|=
name|skipsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strlcmp
argument_list|(
literal|"if"
argument_list|,
name|keyword
argument_list|,
name|kwlen
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|ifeval
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|strlcmp
argument_list|(
literal|"elif"
argument_list|,
name|keyword
argument_list|,
name|kwlen
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|ifeval
argument_list|(
operator|&
name|cp
argument_list|)
operator|-
name|LT_IF
operator|+
name|LT_ELIF
expr_stmt|;
elseif|else
if|if
condition|(
name|strlcmp
argument_list|(
literal|"else"
argument_list|,
name|keyword
argument_list|,
name|kwlen
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|LT_ELSE
expr_stmt|;
elseif|else
if|if
condition|(
name|strlcmp
argument_list|(
literal|"endif"
argument_list|,
name|keyword
argument_list|,
name|kwlen
argument_list|)
operator|==
literal|0
condition|)
name|retval
operator|=
name|LT_ENDIF
expr_stmt|;
else|else
block|{
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
name|retval
operator|=
name|LT_PLAIN
expr_stmt|;
block|}
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LT_TRUE
operator|||
name|retval
operator|==
name|LT_FALSE
operator|||
name|retval
operator|==
name|LT_TRUEI
operator|||
name|retval
operator|==
name|LT_FALSEI
condition|)
name|retval
operator|=
name|LT_IF
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LT_ELTRUE
operator|||
name|retval
operator|==
name|LT_ELFALSE
condition|)
name|retval
operator|=
name|LT_ELIF
expr_stmt|;
block|}
if|if
condition|(
name|retval
operator|!=
name|LT_PLAIN
operator|&&
operator|(
name|wascomment
operator|||
name|incomment
operator|)
condition|)
block|{
name|retval
operator|+=
name|LT_DODGY
expr_stmt|;
if|if
condition|(
name|incomment
condition|)
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
block|}
comment|/* skipcomment should have changed the state */
if|if
condition|(
name|linestate
operator|==
name|LS_HASH
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
block|}
if|if
condition|(
name|linestate
operator|==
name|LS_DIRTY
condition|)
block|{
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"parser %s comment %s line"
argument_list|,
name|comment_name
index|[
name|incomment
index|]
argument_list|,
name|linestate_name
index|[
name|linestate
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These are the binary operators that are supported by the expression  * evaluator. Note that if support for division is added then we also  * need short-circuiting booleans because of divide-by-zero.  */
end_comment

begin_function
specifier|static
name|int
name|op_lt
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|<
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_gt
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_le
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|<=
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_ge
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|>=
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_eq
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|==
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_ne
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|!=
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_or
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|||
name|b
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|op_and
parameter_list|(
name|int
name|a
parameter_list|,
name|int
name|b
parameter_list|)
block|{
return|return
operator|(
name|a
operator|&&
name|b
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * An evaluation function takes three arguments, as follows: (1) a pointer to  * an element of the precedence table which lists the operators at the current  * level of precedence; (2) a pointer to an integer which will receive the  * value of the expression; and (3) a pointer to a char* that points to the  * expression to be evaluated and that is updated to the end of the expression  * when evaluation is complete. The function returns LT_FALSE if the value of  * the expression is zero, LT_TRUE if it is non-zero, or LT_IF if the  * expression could not be evaluated.  */
end_comment

begin_struct_decl
struct_decl|struct
name|ops
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|Linetype
name|eval_fn
parameter_list|(
specifier|const
name|struct
name|ops
modifier|*
parameter_list|,
name|int
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|eval_fn
name|eval_table
decl_stmt|,
name|eval_unary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The precedence table. Expressions involving binary operators are evaluated  * in a table-driven way by eval_table. When it evaluates a subexpression it  * calls the inner function with its first argument pointing to the next  * element of the table. Innermost expressions have special non-table-driven  * handling.  */
end_comment

begin_struct
specifier|static
specifier|const
struct|struct
name|ops
block|{
name|eval_fn
modifier|*
name|inner
decl_stmt|;
struct|struct
name|op
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
block|}
name|op
index|[
literal|5
index|]
struct|;
block|}
name|eval_ops
index|[]
init|=
block|{
block|{
name|eval_table
block|,
block|{
block|{
literal|"||"
block|,
name|op_or
block|}
block|}
block|}
block|,
block|{
name|eval_table
block|,
block|{
block|{
literal|"&&"
block|,
name|op_and
block|}
block|}
block|}
block|,
block|{
name|eval_table
block|,
block|{
block|{
literal|"=="
block|,
name|op_eq
block|}
block|,
block|{
literal|"!="
block|,
name|op_ne
block|}
block|}
block|}
block|,
block|{
name|eval_unary
block|,
block|{
block|{
literal|"<="
block|,
name|op_le
block|}
block|,
block|{
literal|">="
block|,
name|op_ge
block|}
block|,
block|{
literal|"<"
block|,
name|op_lt
block|}
block|,
block|{
literal|">"
block|,
name|op_gt
block|}
block|}
block|}
block|}
struct|;
end_struct

begin_comment
comment|/*  * Function for evaluating the innermost parts of expressions,  * viz. !expr (expr) defined(symbol) symbol number  * We reset the keepthis flag when we find a non-constant subexpression.  */
end_comment

begin_function
specifier|static
name|Linetype
name|eval_unary
parameter_list|(
specifier|const
name|struct
name|ops
modifier|*
name|ops
parameter_list|,
name|int
modifier|*
name|valp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|sym
decl_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d !"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
if|if
condition|(
name|eval_unary
argument_list|(
name|ops
argument_list|,
name|valp
argument_list|,
operator|&
name|cp
argument_list|)
operator|==
name|LT_IF
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
operator|*
name|valp
operator|=
operator|!
operator|*
name|valp
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d ("
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|)
expr_stmt|;
if|if
condition|(
name|eval_table
argument_list|(
name|eval_ops
argument_list|,
name|valp
argument_list|,
operator|&
name|cp
argument_list|)
operator|==
name|LT_IF
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|')'
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d number"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|cp
operator|=
name|skipsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"defined"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|endsym
argument_list|(
name|cp
index|[
literal|7
index|]
argument_list|)
condition|)
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
operator|+
literal|7
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d defined"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|'('
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|sym
operator|=
name|findsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
operator|*
name|valp
operator|=
operator|(
name|value
index|[
name|sym
index|]
operator|!=
name|NULL
operator|)
expr_stmt|;
name|cp
operator|=
name|skipsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|')'
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
name|keepthis
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|endsym
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d symbol"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|)
expr_stmt|;
name|sym
operator|=
name|findsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
if|if
condition|(
name|value
index|[
name|sym
index|]
operator|==
name|NULL
condition|)
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
else|else
block|{
operator|*
name|valp
operator|=
name|strtol
argument_list|(
name|value
index|[
name|sym
index|]
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
name|ep
operator|==
name|value
index|[
name|sym
index|]
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
block|}
name|cp
operator|=
name|skipsym
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|keepthis
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"eval%d bad expr"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|)
expr_stmt|;
return|return
operator|(
name|LT_IF
operator|)
return|;
block|}
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d = %d"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|,
operator|*
name|valp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|valp
condition|?
name|LT_TRUE
else|:
name|LT_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Table-driven evaluation of binary operators.  */
end_comment

begin_function
specifier|static
name|Linetype
name|eval_table
parameter_list|(
specifier|const
name|struct
name|ops
modifier|*
name|ops
parameter_list|,
name|int
modifier|*
name|valp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
specifier|const
name|struct
name|op
modifier|*
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|val
decl_stmt|;
name|debug
argument_list|(
literal|"eval%d"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|*
name|cpp
expr_stmt|;
if|if
condition|(
name|ops
operator|->
name|inner
argument_list|(
name|ops
operator|+
literal|1
argument_list|,
name|valp
argument_list|,
operator|&
name|cp
argument_list|)
operator|==
name|LT_IF
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
name|ops
operator|->
name|op
init|;
name|op
operator|->
name|str
operator|!=
name|NULL
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|op
operator|->
name|str
argument_list|,
name|strlen
argument_list|(
name|op
operator|->
name|str
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|op
operator|->
name|str
operator|==
name|NULL
condition|)
break|break;
name|cp
operator|+=
name|strlen
argument_list|(
name|op
operator|->
name|str
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d %s"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|,
name|op
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|ops
operator|->
name|inner
argument_list|(
name|ops
operator|+
literal|1
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|cp
argument_list|)
operator|==
name|LT_IF
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
operator|*
name|valp
operator|=
name|op
operator|->
name|fn
argument_list|(
operator|*
name|valp
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d = %d"
argument_list|,
name|ops
operator|-
name|eval_ops
argument_list|,
operator|*
name|valp
argument_list|)
expr_stmt|;
return|return
operator|(
operator|*
name|valp
condition|?
name|LT_TRUE
else|:
name|LT_FALSE
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate the expression on a #if or #elif line. If we can work out  * the result we return LT_TRUE or LT_FALSE accordingly, otherwise we  * return just a generic LT_IF.  */
end_comment

begin_function
specifier|static
name|Linetype
name|ifeval
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|int
name|val
decl_stmt|;
name|debug
argument_list|(
literal|"eval %s"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|keepthis
operator|=
name|killconsts
condition|?
name|false
else|:
name|true
expr_stmt|;
name|ret
operator|=
name|eval_table
argument_list|(
name|eval_ops
argument_list|,
operator|&
name|val
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"eval = %d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|keepthis
condition|?
name|LT_IF
else|:
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over comments, strings, and character literals and stop at the  * next character position that is not whitespace. Between calls we keep  * the comment state in the global variable incomment, and we also adjust  * the global variable linestate when we see a newline.  * XXX: doesn't cope with the buffer splitting inside a state transition.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skipcomment
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|text
operator|||
name|ignoring
index|[
name|depth
index|]
condition|)
block|{
for|for
control|(
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|linestate
operator|=
name|LS_START
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
comment|/* don't reset to LS_START after a line continuation */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\\\n"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|+=
literal|2
expr_stmt|;
else|else
switch|switch
condition|(
name|incomment
condition|)
block|{
case|case
name|NO_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"/\\\n"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|STARTING_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"/*"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|C_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"//"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|CXX_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\'"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|CHAR_LITERAL
expr_stmt|;
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|STRING_LITERAL
expr_stmt|;
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|linestate
operator|=
name|LS_START
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|" \t"
argument_list|,
operator|*
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
return|return
operator|(
name|cp
operator|)
return|;
continue|continue;
case|case
name|CXX_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|linestate
operator|=
name|LS_START
expr_stmt|;
block|}
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
name|CHAR_LITERAL
case|:
case|case
name|STRING_LITERAL
case|:
if|if
condition|(
operator|(
name|incomment
operator|==
name|CHAR_LITERAL
operator|&&
name|cp
index|[
literal|0
index|]
operator|==
literal|'\''
operator|)
operator|||
operator|(
name|incomment
operator|==
name|STRING_LITERAL
operator|&&
name|cp
index|[
literal|0
index|]
operator|==
literal|'\"'
operator|)
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|cp
operator|+=
literal|1
expr_stmt|;
else|else
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|incomment
operator|==
name|CHAR_LITERAL
condition|)
name|error
argument_list|(
literal|"unterminated char literal"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unterminated string literal"
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
name|C_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"*\\\n"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|FINISHING_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"*/"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
name|STARTING_COMMENT
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
name|incomment
operator|=
name|C_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|incomment
operator|=
name|CXX_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
block|}
continue|continue;
case|case
name|FINISHING_COMMENT
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|incomment
operator|=
name|C_COMMENT
expr_stmt|;
continue|continue;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over an identifier.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skipsym
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
operator|!
name|endsym
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for the symbol in the symbol table. If is is found, we return  * the symbol table index, else we return -1.  */
end_comment

begin_function
specifier|static
name|int
name|findsym
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|symind
decl_stmt|;
name|cp
operator|=
name|skipsym
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|str
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|symlist
condition|)
block|{
name|printf
argument_list|(
literal|"%.*s\n"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|cp
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|)
expr_stmt|;
comment|/* we don't care about the value of the symbol */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|symind
operator|=
literal|0
init|;
name|symind
operator|<
name|nsyms
condition|;
operator|++
name|symind
control|)
block|{
if|if
condition|(
name|strlcmp
argument_list|(
name|symname
index|[
name|symind
index|]
argument_list|,
name|str
argument_list|,
name|cp
operator|-
name|str
argument_list|)
operator|==
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"findsym %s %s"
argument_list|,
name|symname
index|[
name|symind
index|]
argument_list|,
name|value
index|[
name|symind
index|]
condition|?
name|value
index|[
name|symind
index|]
else|:
literal|""
argument_list|)
expr_stmt|;
return|return
operator|(
name|symind
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add a symbol to the symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|addsym
parameter_list|(
name|bool
name|ignorethis
parameter_list|,
name|bool
name|definethis
parameter_list|,
name|char
modifier|*
name|sym
parameter_list|)
block|{
name|int
name|symind
decl_stmt|;
name|char
modifier|*
name|val
decl_stmt|;
name|symind
operator|=
name|findsym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|symind
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|nsyms
operator|>=
name|MAXSYMS
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"too many symbols"
argument_list|)
expr_stmt|;
name|symind
operator|=
name|nsyms
operator|++
expr_stmt|;
block|}
name|symname
index|[
name|symind
index|]
operator|=
name|sym
expr_stmt|;
name|ignore
index|[
name|symind
index|]
operator|=
name|ignorethis
expr_stmt|;
name|val
operator|=
name|sym
operator|+
operator|(
name|skipsym
argument_list|(
name|sym
argument_list|)
operator|-
name|sym
operator|)
expr_stmt|;
if|if
condition|(
name|definethis
condition|)
block|{
if|if
condition|(
operator|*
name|val
operator|==
literal|'='
condition|)
block|{
name|value
index|[
name|symind
index|]
operator|=
name|val
operator|+
literal|1
expr_stmt|;
operator|*
name|val
operator|=
literal|'\0'
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|val
operator|==
literal|'\0'
condition|)
name|value
index|[
name|symind
index|]
operator|=
literal|""
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|val
operator|!=
literal|'\0'
condition|)
name|usage
argument_list|()
expr_stmt|;
name|value
index|[
name|symind
index|]
operator|=
name|NULL
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compare s with n characters of t.  * The same as strncmp() except that it checks that s[n] == '\0'.  */
end_comment

begin_function
specifier|static
name|int
name|strlcmp
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|t
parameter_list|,
name|size_t
name|n
parameter_list|)
block|{
while|while
condition|(
name|n
operator|--
operator|&&
operator|*
name|t
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|*
name|s
operator|!=
operator|*
name|t
condition|)
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|-
operator|(
name|unsigned
name|char
operator|)
operator|*
name|t
operator|)
return|;
else|else
operator|++
name|s
operator|,
operator|++
name|t
expr_stmt|;
return|return
operator|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Diagnostics.  */
end_comment

begin_function
specifier|static
name|void
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|vwarnx
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|warnx
argument_list|(
literal|"%s: %d: %s"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s: %d: %s (#if line %d depth %d)"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|,
name|msg
argument_list|,
name|stifline
index|[
name|depth
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|2
argument_list|,
literal|"output may be truncated"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

