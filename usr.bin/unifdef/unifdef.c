begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 2002 - 2014 Tony Finch<dot@dotat.at>  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * unifdef - remove ifdef'ed lines  *  * This code was derived from software contributed to Berkeley by Dave Yost.  * It was rewritten to support ANSI C by Tony Finch. The original version  * of unifdef carried the 4-clause BSD copyright licence. None of its code  * remains in this version (though some of the names remain) so it now  * carries a more liberal licence.  *  *  Wishlist:  *      provide an option which will append the name of the  *        appropriate symbol after #else's and #endif's  *      provide an option which will check symbols after  *        #else's and #endif's to see that they match their  *        corresponding #ifdef or #ifndef  *  *   These require better buffer handling, which would also make  *   it possible to handle all "dodgy" directives correctly.  */
end_comment

begin_include
include|#
directive|include
file|"unifdef.h"
end_include

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) $Version: unifdef-2.10 $\n"
literal|"@(#) $FreeBSD$\n"
literal|"@(#) $Author: Tony Finch (dot@dotat.at) $\n"
literal|"@(#) $URL: http://dotat.at/prog/unifdef $\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* types of input lines: */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|LT_TRUEI
block|,
comment|/* a true #if with ignore flag */
name|LT_FALSEI
block|,
comment|/* a false #if with ignore flag */
name|LT_IF
block|,
comment|/* an unknown #if */
name|LT_TRUE
block|,
comment|/* a true #if */
name|LT_FALSE
block|,
comment|/* a false #if */
name|LT_ELIF
block|,
comment|/* an unknown #elif */
name|LT_ELTRUE
block|,
comment|/* a true #elif */
name|LT_ELFALSE
block|,
comment|/* a false #elif */
name|LT_ELSE
block|,
comment|/* #else */
name|LT_ENDIF
block|,
comment|/* #endif */
name|LT_DODGY
block|,
comment|/* flag: directive is not on one line */
name|LT_DODGY_LAST
init|=
name|LT_DODGY
operator|+
name|LT_ENDIF
block|,
name|LT_PLAIN
block|,
comment|/* ordinary line */
name|LT_EOF
block|,
comment|/* end of file */
name|LT_ERROR
block|,
comment|/* unevaluable #if */
name|LT_COUNT
block|}
name|Linetype
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|linetype_name
index|[]
init|=
block|{
literal|"TRUEI"
block|,
literal|"FALSEI"
block|,
literal|"IF"
block|,
literal|"TRUE"
block|,
literal|"FALSE"
block|,
literal|"ELIF"
block|,
literal|"ELTRUE"
block|,
literal|"ELFALSE"
block|,
literal|"ELSE"
block|,
literal|"ENDIF"
block|,
literal|"DODGY TRUEI"
block|,
literal|"DODGY FALSEI"
block|,
literal|"DODGY IF"
block|,
literal|"DODGY TRUE"
block|,
literal|"DODGY FALSE"
block|,
literal|"DODGY ELIF"
block|,
literal|"DODGY ELTRUE"
block|,
literal|"DODGY ELFALSE"
block|,
literal|"DODGY ELSE"
block|,
literal|"DODGY ENDIF"
block|,
literal|"PLAIN"
block|,
literal|"EOF"
block|,
literal|"ERROR"
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|linetype_if2elif
parameter_list|(
name|lt
parameter_list|)
value|((Linetype)(lt - LT_IF + LT_ELIF))
end_define

begin_define
define|#
directive|define
name|linetype_2dodgy
parameter_list|(
name|lt
parameter_list|)
value|((Linetype)(lt + LT_DODGY))
end_define

begin_comment
comment|/* state of #if processing */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|IS_OUTSIDE
block|,
name|IS_FALSE_PREFIX
block|,
comment|/* false #if followed by false #elifs */
name|IS_TRUE_PREFIX
block|,
comment|/* first non-false #(el)if is true */
name|IS_PASS_MIDDLE
block|,
comment|/* first non-false #(el)if is unknown */
name|IS_FALSE_MIDDLE
block|,
comment|/* a false #elif after a pass state */
name|IS_TRUE_MIDDLE
block|,
comment|/* a true #elif after a pass state */
name|IS_PASS_ELSE
block|,
comment|/* an else after a pass state */
name|IS_FALSE_ELSE
block|,
comment|/* an else after a true state */
name|IS_TRUE_ELSE
block|,
comment|/* an else after only false states */
name|IS_FALSE_TRAILER
block|,
comment|/* #elifs after a true are false */
name|IS_COUNT
block|}
name|Ifstate
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|ifstate_name
index|[]
init|=
block|{
literal|"OUTSIDE"
block|,
literal|"FALSE_PREFIX"
block|,
literal|"TRUE_PREFIX"
block|,
literal|"PASS_MIDDLE"
block|,
literal|"FALSE_MIDDLE"
block|,
literal|"TRUE_MIDDLE"
block|,
literal|"PASS_ELSE"
block|,
literal|"FALSE_ELSE"
block|,
literal|"TRUE_ELSE"
block|,
literal|"FALSE_TRAILER"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of comment parser */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|NO_COMMENT
init|=
name|false
block|,
comment|/* outside a comment */
name|C_COMMENT
block|,
comment|/* in a comment like this one */
name|CXX_COMMENT
block|,
comment|/* between // and end of line */
name|STARTING_COMMENT
block|,
comment|/* just after slash-backslash-newline */
name|FINISHING_COMMENT
block|,
comment|/* star-backslash-newline in a C comment */
name|CHAR_LITERAL
block|,
comment|/* inside '' */
name|STRING_LITERAL
comment|/* inside "" */
block|}
name|Comment_state
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|comment_name
index|[]
init|=
block|{
literal|"NO"
block|,
literal|"C"
block|,
literal|"CXX"
block|,
literal|"STARTING"
block|,
literal|"FINISHING"
block|,
literal|"CHAR"
block|,
literal|"STRING"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* state of preprocessor line parser */
end_comment

begin_typedef
typedef|typedef
enum|enum
block|{
name|LS_START
block|,
comment|/* only space and comments on this line */
name|LS_HASH
block|,
comment|/* only space, comments, and a hash */
name|LS_DIRTY
comment|/* this line can't be a preprocessor line */
block|}
name|Line_state
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
specifier|const
modifier|*
specifier|const
name|linestate_name
index|[]
init|=
block|{
literal|"START"
block|,
literal|"HASH"
block|,
literal|"DIRTY"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Minimum translation limits from ISO/IEC 9899:1999 5.2.4.1  */
end_comment

begin_define
define|#
directive|define
name|MAXDEPTH
value|64
end_define

begin_comment
comment|/* maximum #if nesting */
end_comment

begin_define
define|#
directive|define
name|MAXLINE
value|4096
end_define

begin_comment
comment|/* maximum length of line */
end_comment

begin_define
define|#
directive|define
name|MAXSYMS
value|16384
end_define

begin_comment
comment|/* maximum number of symbols */
end_comment

begin_comment
comment|/*  * Sometimes when editing a keyword the replacement text is longer, so  * we leave some space at the end of the tline buffer to accommodate this.  */
end_comment

begin_define
define|#
directive|define
name|EDITSLOP
value|10
end_define

begin_comment
comment|/*  * Globals.  */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|compblank
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -B: compress blank lines */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|lnblank
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -b: blank deleted lines */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|complement
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -c: do the complement */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|debugging
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -d: debugging reports */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|inplace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -m: modify in place */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|iocccok
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -e: fewer IOCCC errors */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|strictlogic
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -K: keep ambiguous #ifs */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|killconsts
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -k: eval constant #ifs */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|lnnum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -n: add #line directives */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|symlist
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s: output symbol list */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|symdepth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -S: output symbol depth */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|text
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -t: this is a text file */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|symname
index|[
name|MAXSYMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* symbol name */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|value
index|[
name|MAXSYMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -Dsym=value */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ignore
index|[
name|MAXSYMS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -iDsym or -iUsym */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nsyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of symbols */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|input
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file pointer */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|filename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file name */
end_comment

begin_decl_stmt
specifier|static
name|int
name|linenum
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current line number */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|linefile
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file name for #line */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|output
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file pointer */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ofilename
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* output file name */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|backext
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backup extension */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|tempname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* avoid splatting input */
end_comment

begin_decl_stmt
specifier|static
name|char
name|tline
index|[
name|MAXLINE
operator|+
name|EDITSLOP
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input buffer plus space */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|keyword
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* used for editing #elif's */
end_comment

begin_comment
comment|/*  * When processing a file, the output's newline style will match the  * input's, and unifdef correctly handles CRLF or LF endings whatever  * the platform's native style. The stdio streams are opened in binary  * mode to accommodate platforms whose native newline style is CRLF.  * When the output isn't a processed input file (when it is error /  * debug / diagnostic messages) then unifdef uses native line endings.  */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|newline
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* input file format */
end_comment

begin_decl_stmt
specifier|static
specifier|const
name|char
name|newline_unix
index|[]
init|=
literal|"\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|newline_crlf
index|[]
init|=
literal|"\r\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|Comment_state
name|incomment
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* comment parser state */
end_comment

begin_decl_stmt
specifier|static
name|Line_state
name|linestate
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #if line parser state */
end_comment

begin_decl_stmt
specifier|static
name|Ifstate
name|ifstate
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #if processor state */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|ignoring
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ignore comments state */
end_comment

begin_decl_stmt
specifier|static
name|int
name|stifline
index|[
name|MAXDEPTH
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* start of current #if */
end_comment

begin_decl_stmt
specifier|static
name|int
name|depth
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* current #if nesting */
end_comment

begin_decl_stmt
specifier|static
name|int
name|delcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of deleted lines */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|blankcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count of blank lines */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|blankmax
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* maximum recent blankcount */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|constexpr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* constant #if expression */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|zerosyms
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* to format symdepth output */
end_comment

begin_decl_stmt
specifier|static
name|bool
name|firstsym
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ditto */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exitmode
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* exit status mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|exitstat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* program exit status */
end_comment

begin_function_decl
specifier|static
name|void
name|addsym1
parameter_list|(
name|bool
parameter_list|,
name|bool
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|addsym2
parameter_list|(
name|bool
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|astrcat
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|cleantemp
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|closeio
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
modifier|...
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|debugsym
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|bool
name|defundef
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|defundefile
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|done
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|findsym
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|flushline
parameter_list|(
name|bool
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|hashline
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|help
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Linetype
name|ifeval
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignoreoff
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|ignoreon
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|indirectsym
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|keywordedit
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|matchsym
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|nest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|Linetype
name|parseline
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|process
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|processinout
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|skipargs
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|skipcomment
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|skiphash
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|skipline
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|skipsym
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|state
parameter_list|(
name|Ifstate
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|unnest
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|version
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|xstrdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|endsym
parameter_list|(
name|c
parameter_list|)
value|(!isalnum((unsigned char)c)&& c != '_')
end_define

begin_comment
comment|/*  * The main program.  */
end_comment

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|opt
decl_stmt|;
while|while
condition|(
operator|(
name|opt
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"i:D:U:f:I:M:o:x:bBcdehKklmnsStV"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|opt
condition|)
block|{
case|case
literal|'i'
case|:
comment|/* treat stuff controlled by these symbols as text */
comment|/* 			 * For strict backwards-compatibility the U or D 			 * should be immediately after the -i but it doesn't 			 * matter much if we relax that requirement. 			 */
name|opt
operator|=
operator|*
name|optarg
operator|++
expr_stmt|;
if|if
condition|(
name|opt
operator|==
literal|'D'
condition|)
name|addsym1
argument_list|(
name|true
argument_list|,
name|true
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|opt
operator|==
literal|'U'
condition|)
name|addsym1
argument_list|(
name|true
argument_list|,
name|false
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
else|else
name|usage
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
comment|/* define a symbol */
name|addsym1
argument_list|(
name|false
argument_list|,
name|true
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
comment|/* undef a symbol */
name|addsym1
argument_list|(
name|false
argument_list|,
name|false
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
comment|/* no-op for compatibility with cpp */
break|break;
case|case
literal|'b'
case|:
comment|/* blank deleted lines instead of omitting them */
case|case
literal|'l'
case|:
comment|/* backwards compatibility */
name|lnblank
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
comment|/* compress blank lines around removed section */
name|compblank
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
comment|/* treat -D as -U and vice versa */
name|complement
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|debugging
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
comment|/* fewer errors from dodgy lines */
name|iocccok
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
comment|/* definitions file */
name|defundefile
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|help
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
comment|/* keep ambiguous #ifs */
name|strictlogic
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'k'
case|:
comment|/* process constant #ifs */
name|killconsts
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
comment|/* modify in place */
name|inplace
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
comment|/* modify in place and keep backup */
name|inplace
operator|=
name|true
expr_stmt|;
name|backext
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* add #line directive after deleted lines */
name|lnnum
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
comment|/* output to a file */
name|ofilename
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
comment|/* only output list of symbols that control #ifs */
name|symlist
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
comment|/* list symbols with their nesting depth */
name|symlist
operator|=
name|symdepth
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
comment|/* don't parse C comments */
name|text
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|version
argument_list|()
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|exitmode
operator|=
name|atoi
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
if|if
condition|(
name|exitmode
operator|<
literal|0
operator|||
name|exitmode
operator|>
literal|2
condition|)
name|usage
argument_list|()
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|compblank
operator|&&
name|lnblank
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"-B and -b are mutually exclusive"
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlist
operator|&&
operator|(
name|ofilename
operator|!=
name|NULL
operator|||
name|inplace
operator|||
name|argc
operator|>
literal|1
operator|)
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"-s only works with one input file"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
name|ofilename
operator|!=
name|NULL
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"-o cannot be used with multiple input files"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|>
literal|1
operator|&&
operator|!
name|inplace
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"multiple input files require -m or -M"
argument_list|)
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|0
condition|)
name|argc
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|argc
operator|==
literal|1
operator|&&
operator|!
name|inplace
operator|&&
name|ofilename
operator|==
name|NULL
condition|)
name|ofilename
operator|=
literal|"-"
expr_stmt|;
name|indirectsym
argument_list|()
expr_stmt|;
name|atexit
argument_list|(
name|cleantemp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ofilename
operator|!=
name|NULL
condition|)
name|processinout
argument_list|(
operator|*
name|argv
argument_list|,
name|ofilename
argument_list|)
expr_stmt|;
else|else
while|while
condition|(
name|argc
operator|--
operator|>
literal|0
condition|)
block|{
name|processinout
argument_list|(
operator|*
name|argv
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|argv
operator|++
expr_stmt|;
block|}
switch|switch
condition|(
name|exitmode
condition|)
block|{
case|case
operator|(
literal|0
operator|)
case|:
name|exit
argument_list|(
name|exitstat
argument_list|)
expr_stmt|;
case|case
operator|(
literal|1
operator|)
case|:
name|exit
argument_list|(
operator|!
name|exitstat
argument_list|)
expr_stmt|;
case|case
operator|(
literal|2
operator|)
case|:
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
block|}
block|}
end_function

begin_comment
comment|/*  * File logistics.  */
end_comment

begin_function
specifier|static
name|void
name|processinout
parameter_list|(
specifier|const
name|char
modifier|*
name|ifn
parameter_list|,
specifier|const
name|char
modifier|*
name|ofn
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
if|if
condition|(
name|ifn
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|ifn
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|filename
operator|=
literal|"[stdin]"
expr_stmt|;
name|linefile
operator|=
name|NULL
expr_stmt|;
name|input
operator|=
name|fbinmode
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|filename
operator|=
name|ifn
expr_stmt|;
name|linefile
operator|=
name|ifn
expr_stmt|;
name|input
operator|=
name|fopen
argument_list|(
name|ifn
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't open %s"
argument_list|,
name|ifn
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|strcmp
argument_list|(
name|ofn
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|output
operator|=
name|fbinmode
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|process
argument_list|()
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|stat
argument_list|(
name|ofn
argument_list|,
operator|&
name|st
argument_list|)
operator|<
literal|0
condition|)
block|{
name|output
operator|=
name|fopen
argument_list|(
name|ofn
argument_list|,
literal|"wb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't create %s"
argument_list|,
name|ofn
argument_list|)
expr_stmt|;
name|process
argument_list|()
expr_stmt|;
return|return;
block|}
name|tempname
operator|=
name|astrcat
argument_list|(
name|ofn
argument_list|,
literal|".XXXXXX"
argument_list|)
expr_stmt|;
name|output
operator|=
name|mktempmode
argument_list|(
name|tempname
argument_list|,
name|st
operator|.
name|st_mode
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't create %s"
argument_list|,
name|tempname
argument_list|)
expr_stmt|;
name|process
argument_list|()
expr_stmt|;
if|if
condition|(
name|backext
operator|!=
name|NULL
condition|)
block|{
name|char
modifier|*
name|backname
init|=
name|astrcat
argument_list|(
name|ofn
argument_list|,
name|backext
argument_list|)
decl_stmt|;
if|if
condition|(
name|rename
argument_list|(
name|ofn
argument_list|,
name|backname
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't rename \"%s\" to \"%s\""
argument_list|,
name|ofn
argument_list|,
name|backname
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|backname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|replace
argument_list|(
name|tempname
argument_list|,
name|ofn
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't rename \"%s\" to \"%s\""
argument_list|,
name|tempname
argument_list|,
name|ofn
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
name|tempname
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * For cleaning up if there is an error.  */
end_comment

begin_function
specifier|static
name|void
name|cleantemp
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|tempname
operator|!=
name|NULL
condition|)
name|remove
argument_list|(
name|tempname
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Self-identification functions.  */
end_comment

begin_function
specifier|static
name|void
name|version
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|c
init|=
name|copyright
decl_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
while|while
condition|(
operator|*
operator|++
name|c
operator|!=
literal|'$'
condition|)
if|if
condition|(
operator|*
name|c
operator|==
literal|'\0'
condition|)
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|c
operator|!=
literal|'$'
condition|)
name|putc
argument_list|(
operator|*
name|c
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|synopsis
parameter_list|(
name|FILE
modifier|*
name|fp
parameter_list|)
block|{
name|fprintf
argument_list|(
name|fp
argument_list|,
literal|"usage:	unifdef [-bBcdehKkmnsStV] [-x{012}] [-Mext] [-opath] \\\n"
literal|"		[-[i]Dsym[=val]] [-[i]Usym] [-fpath] ... [file] ...\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|synopsis
argument_list|(
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|help
parameter_list|(
name|void
parameter_list|)
block|{
name|synopsis
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"	-Dsym=val  define preprocessor symbol with given value\n"
literal|"	-Dsym      define preprocessor symbol with value 1\n"
literal|"	-Usym	   preprocessor symbol is undefined\n"
literal|"	-iDsym=val \\  ignore C strings and comments\n"
literal|"	-iDsym      ) in sections controlled by these\n"
literal|"	-iUsym	   /  preprocessor symbols\n"
literal|"	-fpath	file containing #define and #undef directives\n"
literal|"	-b	blank lines instead of deleting them\n"
literal|"	-B	compress blank lines around deleted section\n"
literal|"	-c	complement (invert) keep vs. delete\n"
literal|"	-d	debugging mode\n"
literal|"	-e	ignore multiline preprocessor directives\n"
literal|"	-h	print help\n"
literal|"	-Ipath	extra include file path (ignored)\n"
literal|"	-K	disable&& and || short-circuiting\n"
literal|"	-k	process constant #if expressions\n"
literal|"	-Mext	modify in place and keep backups\n"
literal|"	-m	modify input files in place\n"
literal|"	-n	add #line directives to output\n"
literal|"	-opath	output file name\n"
literal|"	-S	list #if control symbols with nesting\n"
literal|"	-s	list #if control symbols\n"
literal|"	-t	ignore C strings and comments\n"
literal|"	-V	print version\n"
literal|"	-x{012}	exit status mode\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * A state transition function alters the global #if processing state  * in a particular way. The table below is indexed by the current  * processing state and the type of the current line.  *  * Nesting is handled by keeping a stack of states; some transition  * functions increase or decrease the depth. They also maintain the  * ignore state on a stack. In some complicated cases they have to  * alter the preprocessor directive, as follows.  *  * When we have processed a group that starts off with a known-false  * #if/#elif sequence (which has therefore been deleted) followed by a  * #elif that we don't understand and therefore must keep, we edit the  * latter into a #if to keep the nesting correct. We use memcpy() to  * overwrite the 4 byte token "elif" with "if  " without a '\0' byte.  *  * When we find a true #elif in a group, the following block will  * always be kept and the rest of the sequence after the next #elif or  * #else will be discarded. We edit the #elif into a #else and the  * following directive to #endif since this has the desired behaviour.  *  * "Dodgy" directives are split across multiple lines, the most common  * example being a multi-line comment hanging off the right of the  * directive. We can handle them correctly only if there is no change  * from printing to dropping (or vice versa) caused by that directive.  * If the directive is the first of a group we have a choice between  * failing with an error, or passing it through unchanged instead of  * evaluating it. The latter is not the default to avoid questions from  * users about unifdef unexpectedly leaving behind preprocessor directives.  */
end_comment

begin_typedef
typedef|typedef
name|void
name|state_fn
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_typedef

begin_comment
comment|/* report an error */
end_comment

begin_function
specifier|static
name|void
name|Eelif
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Inappropriate #elif"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eelse
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Inappropriate #else"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eendif
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Inappropriate #endif"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eeof
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Premature EOF"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Eioccc
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
literal|"Obfuscated preprocessor control line"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* plain line handling */
end_comment

begin_function
specifier|static
name|void
name|print
parameter_list|(
name|void
parameter_list|)
block|{
name|flushline
argument_list|(
name|true
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|drop
parameter_list|(
name|void
parameter_list|)
block|{
name|flushline
argument_list|(
name|false
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* output lacks group's start line */
end_comment

begin_function
specifier|static
name|void
name|Strue
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_TRUE_PREFIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Sfalse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_PREFIX
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Selse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_TRUE_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print/pass this block */
end_comment

begin_function
specifier|static
name|void
name|Pelif
parameter_list|(
name|void
parameter_list|)
block|{
name|print
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_PASS_MIDDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Pelse
parameter_list|(
name|void
parameter_list|)
block|{
name|print
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_PASS_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Pendif
parameter_list|(
name|void
parameter_list|)
block|{
name|print
argument_list|()
expr_stmt|;
name|unnest
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* discard this block */
end_comment

begin_function
specifier|static
name|void
name|Dfalse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_TRAILER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Delif
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|ignoreoff
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_MIDDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Delse
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Dendif
parameter_list|(
name|void
parameter_list|)
block|{
name|drop
argument_list|()
expr_stmt|;
name|unnest
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* first line of group */
end_comment

begin_function
specifier|static
name|void
name|Fdrop
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Dfalse
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Fpass
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Pelif
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ftrue
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Strue
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ffalse
parameter_list|(
name|void
parameter_list|)
block|{
name|nest
argument_list|()
expr_stmt|;
name|Sfalse
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* variable pedantry for obfuscated lines */
end_comment

begin_function
specifier|static
name|void
name|Oiffy
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iocccok
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|Fpass
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Oif
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iocccok
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|Fpass
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Oelif
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
operator|!
name|iocccok
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|Pelif
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* ignore comments in this block */
end_comment

begin_function
specifier|static
name|void
name|Idrop
parameter_list|(
name|void
parameter_list|)
block|{
name|Fdrop
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Itrue
parameter_list|(
name|void
parameter_list|)
block|{
name|Ftrue
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Ifalse
parameter_list|(
name|void
parameter_list|)
block|{
name|Ffalse
argument_list|()
expr_stmt|;
name|ignoreon
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* modify this line */
end_comment

begin_function
specifier|static
name|void
name|Mpass
parameter_list|(
name|void
parameter_list|)
block|{
name|memcpy
argument_list|(
name|keyword
argument_list|,
literal|"if  "
argument_list|,
literal|4
argument_list|)
expr_stmt|;
name|Pelif
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Mtrue
parameter_list|(
name|void
parameter_list|)
block|{
name|keywordedit
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|state
argument_list|(
name|IS_TRUE_MIDDLE
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Melif
parameter_list|(
name|void
parameter_list|)
block|{
name|keywordedit
argument_list|(
literal|"endif"
argument_list|)
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_TRAILER
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|Melse
parameter_list|(
name|void
parameter_list|)
block|{
name|keywordedit
argument_list|(
literal|"endif"
argument_list|)
expr_stmt|;
name|state
argument_list|(
name|IS_FALSE_ELSE
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
name|state_fn
modifier|*
specifier|const
name|trans_table
index|[
name|IS_COUNT
index|]
index|[
name|LT_COUNT
index|]
init|=
block|{
comment|/* IS_OUTSIDE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eendif
block|,
name|print
block|,
name|done
block|,
name|abort
block|}
block|,
comment|/* IS_FALSE_PREFIX */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Mpass
block|,
name|Strue
block|,
name|Sfalse
block|,
name|Selse
block|,
name|Dendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Mpass
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_TRUE_PREFIX */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Delse
block|,
name|Dendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|print
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_PASS_MIDDLE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Pelif
block|,
name|Mtrue
block|,
name|Delif
block|,
name|Pelse
block|,
name|Pendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Pelif
block|,
name|Oelif
block|,
name|Oelif
block|,
name|Pelse
block|,
name|Pendif
block|,
name|print
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_FALSE_MIDDLE */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Pelif
block|,
name|Mtrue
block|,
name|Delif
block|,
name|Pelse
block|,
name|Pendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_TRUE_MIDDLE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Melif
block|,
name|Melif
block|,
name|Melif
block|,
name|Melse
block|,
name|Pendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Eioccc
block|,
name|Pendif
block|,
name|print
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_PASS_ELSE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Pendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Pendif
block|,
name|print
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_FALSE_ELSE */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Dendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_TRUE_ELSE */
block|{
name|Itrue
block|,
name|Ifalse
block|,
name|Fpass
block|,
name|Ftrue
block|,
name|Ffalse
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Dendif
block|,
name|Oiffy
block|,
name|Oiffy
block|,
name|Fpass
block|,
name|Oif
block|,
name|Oif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelif
block|,
name|Eelse
block|,
name|Eioccc
block|,
name|print
block|,
name|Eeof
block|,
name|abort
block|}
block|,
comment|/* IS_FALSE_TRAILER */
block|{
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Delse
block|,
name|Dendif
block|,
name|Idrop
block|,
name|Idrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Fdrop
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Dfalse
block|,
name|Delse
block|,
name|Eioccc
block|,
name|drop
block|,
name|Eeof
block|,
name|abort
block|}
comment|/*TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF   TRUEI  FALSEI IF     TRUE   FALSE  ELIF   ELTRUE ELFALSE ELSE  ENDIF (DODGY)   PLAIN  EOF    ERROR */
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * State machine utility functions  */
end_comment

begin_function
specifier|static
name|void
name|ignoreoff
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
name|ignoring
index|[
name|depth
index|]
operator|=
name|ignoring
index|[
name|depth
operator|-
literal|1
index|]
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|ignoreon
parameter_list|(
name|void
parameter_list|)
block|{
name|ignoring
index|[
name|depth
index|]
operator|=
name|true
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|keywordedit
parameter_list|(
specifier|const
name|char
modifier|*
name|replacement
parameter_list|)
block|{
name|snprintf
argument_list|(
name|keyword
argument_list|,
name|tline
operator|+
sizeof|sizeof
argument_list|(
name|tline
argument_list|)
operator|-
name|keyword
argument_list|,
literal|"%s%s"
argument_list|,
name|replacement
argument_list|,
name|newline
argument_list|)
expr_stmt|;
name|print
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nest
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|>
name|MAXDEPTH
operator|-
literal|1
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
if|if
condition|(
name|depth
operator|==
name|MAXDEPTH
operator|-
literal|1
condition|)
name|error
argument_list|(
literal|"Too many levels of nesting"
argument_list|)
expr_stmt|;
name|depth
operator|+=
literal|1
expr_stmt|;
name|stifline
index|[
name|depth
index|]
operator|=
name|linenum
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|unnest
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
name|depth
operator|-=
literal|1
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|state
parameter_list|(
name|Ifstate
name|is
parameter_list|)
block|{
name|ifstate
index|[
name|depth
index|]
operator|=
name|is
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The last state transition function. When this is called,  * lineval == LT_EOF, so the process() loop will terminate.  */
end_comment

begin_function
specifier|static
name|void
name|done
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|incomment
condition|)
name|error
argument_list|(
literal|"EOF in comment"
argument_list|)
expr_stmt|;
name|closeio
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Write a line to the output or not, according to command line options.  * If writing fails, closeio() will print the error and exit.  */
end_comment

begin_function
specifier|static
name|void
name|flushline
parameter_list|(
name|bool
name|keep
parameter_list|)
block|{
if|if
condition|(
name|symlist
condition|)
return|return;
if|if
condition|(
name|keep
operator|^
name|complement
condition|)
block|{
name|bool
name|blankline
init|=
name|tline
index|[
name|strspn
argument_list|(
name|tline
argument_list|,
literal|" \t\r\n"
argument_list|)
index|]
operator|==
literal|'\0'
decl_stmt|;
if|if
condition|(
name|blankline
operator|&&
name|compblank
operator|&&
name|blankcount
operator|!=
name|blankmax
condition|)
block|{
name|delcount
operator|+=
literal|1
expr_stmt|;
name|blankcount
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|lnnum
operator|&&
name|delcount
operator|>
literal|0
condition|)
name|hashline
argument_list|()
expr_stmt|;
if|if
condition|(
name|fputs
argument_list|(
name|tline
argument_list|,
name|output
argument_list|)
operator|==
name|EOF
condition|)
name|closeio
argument_list|()
expr_stmt|;
name|delcount
operator|=
literal|0
expr_stmt|;
name|blankmax
operator|=
name|blankcount
operator|=
name|blankline
condition|?
name|blankcount
operator|+
literal|1
else|:
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|lnblank
operator|&&
name|fputs
argument_list|(
name|newline
argument_list|,
name|output
argument_list|)
operator|==
name|EOF
condition|)
name|closeio
argument_list|()
expr_stmt|;
name|exitstat
operator|=
literal|1
expr_stmt|;
name|delcount
operator|+=
literal|1
expr_stmt|;
name|blankcount
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|debugging
operator|&&
name|fflush
argument_list|(
name|output
argument_list|)
operator|==
name|EOF
condition|)
name|closeio
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Format of #line directives depends on whether we know the input filename.  */
end_comment

begin_function
specifier|static
name|void
name|hashline
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|e
decl_stmt|;
if|if
condition|(
name|linefile
operator|==
name|NULL
condition|)
name|e
operator|=
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"#line %d%s"
argument_list|,
name|linenum
argument_list|,
name|newline
argument_list|)
expr_stmt|;
else|else
name|e
operator|=
name|fprintf
argument_list|(
name|output
argument_list|,
literal|"#line %d \"%s\"%s"
argument_list|,
name|linenum
argument_list|,
name|linefile
argument_list|,
name|newline
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|<
literal|0
condition|)
name|closeio
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Flush the output and handle errors.  */
end_comment

begin_function
specifier|static
name|void
name|closeio
parameter_list|(
name|void
parameter_list|)
block|{
comment|/* Tidy up after findsym(). */
if|if
condition|(
name|symdepth
operator|&&
operator|!
name|zerosyms
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|!=
name|NULL
operator|&&
operator|(
name|ferror
argument_list|(
name|output
argument_list|)
operator|||
name|fclose
argument_list|(
name|output
argument_list|)
operator|==
name|EOF
operator|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s: can't write to output"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * The driver for the state machine.  */
end_comment

begin_function
specifier|static
name|void
name|process
parameter_list|(
name|void
parameter_list|)
block|{
name|Linetype
name|lineval
init|=
name|LT_PLAIN
decl_stmt|;
comment|/* When compressing blank lines, act as if the file 	   is preceded by a large number of blank lines. */
name|blankmax
operator|=
name|blankcount
operator|=
literal|1000
expr_stmt|;
name|zerosyms
operator|=
name|true
expr_stmt|;
name|newline
operator|=
name|NULL
expr_stmt|;
name|linenum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|lineval
operator|!=
name|LT_EOF
condition|)
block|{
name|lineval
operator|=
name|parseline
argument_list|()
expr_stmt|;
name|trans_table
index|[
name|ifstate
index|[
name|depth
index|]
index|]
index|[
name|lineval
index|]
operator|(
operator|)
expr_stmt|;
name|debug
argument_list|(
literal|"process line %d %s -> %s depth %d"
argument_list|,
name|linenum
argument_list|,
name|linetype_name
index|[
name|lineval
index|]
argument_list|,
name|ifstate_name
index|[
name|ifstate
index|[
name|depth
index|]
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Parse a line and determine its type. We keep the preprocessor line  * parser state between calls in the global variable linestate, with  * help from skipcomment().  */
end_comment

begin_function
specifier|static
name|Linetype
name|parseline
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|cursym
decl_stmt|;
name|Linetype
name|retval
decl_stmt|;
name|Comment_state
name|wascomment
decl_stmt|;
name|wascomment
operator|=
name|incomment
expr_stmt|;
name|cp
operator|=
name|skiphash
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|LT_EOF
operator|)
return|;
if|if
condition|(
name|newline
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|strrchr
argument_list|(
name|tline
argument_list|,
literal|'\n'
argument_list|)
operator|==
name|strrchr
argument_list|(
name|tline
argument_list|,
literal|'\r'
argument_list|)
operator|+
literal|1
condition|)
name|newline
operator|=
name|newline_crlf
expr_stmt|;
else|else
name|newline
operator|=
name|newline_unix
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
name|retval
operator|=
name|LT_PLAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|keyword
operator|=
name|tline
operator|+
operator|(
name|cp
operator|-
name|tline
operator|)
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"ifdef"
argument_list|,
name|keyword
argument_list|)
operator|)
operator|!=
name|NULL
operator|||
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"ifndef"
argument_list|,
name|keyword
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|cursym
operator|=
name|findsym
argument_list|(
operator|&
name|cp
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|retval
operator|=
name|LT_IF
expr_stmt|;
else|else
block|{
name|retval
operator|=
operator|(
name|keyword
index|[
literal|2
index|]
operator|==
literal|'n'
operator|)
condition|?
name|LT_FALSE
else|:
name|LT_TRUE
expr_stmt|;
if|if
condition|(
name|value
index|[
name|cursym
index|]
operator|==
name|NULL
condition|)
name|retval
operator|=
operator|(
name|retval
operator|==
name|LT_TRUE
operator|)
condition|?
name|LT_FALSE
else|:
name|LT_TRUE
expr_stmt|;
if|if
condition|(
name|ignore
index|[
name|cursym
index|]
condition|)
name|retval
operator|=
operator|(
name|retval
operator|==
name|LT_TRUE
operator|)
condition|?
name|LT_TRUEI
else|:
name|LT_FALSEI
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"if"
argument_list|,
name|keyword
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|ifeval
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"elif"
argument_list|,
name|keyword
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|linetype_if2elif
argument_list|(
name|ifeval
argument_list|(
operator|&
name|cp
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"else"
argument_list|,
name|keyword
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|LT_ELSE
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"endif"
argument_list|,
name|keyword
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|retval
operator|=
name|LT_ENDIF
expr_stmt|;
else|else
block|{
name|cp
operator|=
name|skipsym
argument_list|(
name|keyword
argument_list|)
expr_stmt|;
comment|/* no way can we deal with a continuation inside a keyword */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\\\r\n"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
operator|||
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\\\n"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|cp
operator|=
name|skipline
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|retval
operator|=
name|LT_PLAIN
expr_stmt|;
goto|goto
name|done
goto|;
block|}
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
block|{
name|cp
operator|=
name|skipline
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LT_TRUE
operator|||
name|retval
operator|==
name|LT_FALSE
operator|||
name|retval
operator|==
name|LT_TRUEI
operator|||
name|retval
operator|==
name|LT_FALSEI
condition|)
name|retval
operator|=
name|LT_IF
expr_stmt|;
if|if
condition|(
name|retval
operator|==
name|LT_ELTRUE
operator|||
name|retval
operator|==
name|LT_ELFALSE
condition|)
name|retval
operator|=
name|LT_ELIF
expr_stmt|;
block|}
comment|/* the following can happen if the last line of the file lacks a 	   newline or if there is too much whitespace in a directive */
if|if
condition|(
name|linestate
operator|==
name|LS_HASH
condition|)
block|{
name|long
name|len
init|=
name|cp
operator|-
name|tline
decl_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|tline
operator|+
name|len
argument_list|,
name|MAXLINE
operator|-
name|len
argument_list|,
name|input
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|input
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't read %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
comment|/* append the missing newline at eof */
name|strcpy
argument_list|(
name|tline
operator|+
name|len
argument_list|,
name|newline
argument_list|)
expr_stmt|;
name|cp
operator|+=
name|strlen
argument_list|(
name|newline
argument_list|)
expr_stmt|;
name|linestate
operator|=
name|LS_START
expr_stmt|;
block|}
else|else
block|{
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
block|}
block|}
if|if
condition|(
name|retval
operator|!=
name|LT_PLAIN
operator|&&
operator|(
name|wascomment
operator|||
name|linestate
operator|!=
name|LS_START
operator|)
condition|)
block|{
name|retval
operator|=
name|linetype_2dodgy
argument_list|(
name|retval
argument_list|)
expr_stmt|;
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
block|}
name|done
label|:
name|debug
argument_list|(
literal|"parser line %d state %s comment %s line"
argument_list|,
name|linenum
argument_list|,
name|comment_name
index|[
name|incomment
index|]
argument_list|,
name|linestate_name
index|[
name|linestate
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * These are the binary operators that are supported by the expression  * evaluator.  */
end_comment

begin_function
specifier|static
name|Linetype
name|op_strict
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|long
name|v
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|Linetype
name|bt
parameter_list|)
block|{
if|if
condition|(
name|at
operator|==
name|LT_IF
operator|||
name|bt
operator|==
name|LT_IF
condition|)
return|return
operator|(
name|LT_IF
operator|)
return|;
return|return
operator|(
operator|*
name|p
operator|=
name|v
operator|,
name|v
condition|?
name|LT_TRUE
else|:
name|LT_FALSE
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_lt
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|<
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_gt
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|>
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_le
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|<=
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_ge
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|>=
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_eq
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|==
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_ne
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|!=
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_or
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strictlogic
operator|&&
operator|(
name|at
operator|==
name|LT_TRUE
operator|||
name|bt
operator|==
name|LT_TRUE
operator|)
condition|)
return|return
operator|(
operator|*
name|p
operator|=
literal|1
operator|,
name|LT_TRUE
operator|)
return|;
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|||
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_function
specifier|static
name|Linetype
name|op_and
parameter_list|(
name|long
modifier|*
name|p
parameter_list|,
name|Linetype
name|at
parameter_list|,
name|long
name|a
parameter_list|,
name|Linetype
name|bt
parameter_list|,
name|long
name|b
parameter_list|)
block|{
if|if
condition|(
operator|!
name|strictlogic
operator|&&
operator|(
name|at
operator|==
name|LT_FALSE
operator|||
name|bt
operator|==
name|LT_FALSE
operator|)
condition|)
return|return
operator|(
operator|*
name|p
operator|=
literal|0
operator|,
name|LT_FALSE
operator|)
return|;
return|return
name|op_strict
argument_list|(
name|p
argument_list|,
name|a
operator|&&
name|b
argument_list|,
name|at
argument_list|,
name|bt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * An evaluation function takes three arguments, as follows: (1) a pointer to  * an element of the precedence table which lists the operators at the current  * level of precedence; (2) a pointer to an integer which will receive the  * value of the expression; and (3) a pointer to a char* that points to the  * expression to be evaluated and that is updated to the end of the expression  * when evaluation is complete. The function returns LT_FALSE if the value of  * the expression is zero, LT_TRUE if it is non-zero, LT_IF if the expression  * depends on an unknown symbol, or LT_ERROR if there is a parse failure.  */
end_comment

begin_struct_decl
struct_decl|struct
name|ops
struct_decl|;
end_struct_decl

begin_typedef
typedef|typedef
name|Linetype
name|eval_fn
parameter_list|(
specifier|const
name|struct
name|ops
modifier|*
parameter_list|,
name|long
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_typedef

begin_decl_stmt
specifier|static
name|eval_fn
name|eval_table
decl_stmt|,
name|eval_unary
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * The precedence table. Expressions involving binary operators are evaluated  * in a table-driven way by eval_table. When it evaluates a subexpression it  * calls the inner function with its first argument pointing to the next  * element of the table. Innermost expressions have special non-table-driven  * handling.  */
end_comment

begin_struct
struct|struct
name|op
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|Linetype
function_decl|(
modifier|*
name|fn
function_decl|)
parameter_list|(
name|long
modifier|*
parameter_list|,
name|Linetype
parameter_list|,
name|long
parameter_list|,
name|Linetype
parameter_list|,
name|long
parameter_list|)
function_decl|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|ops
block|{
name|eval_fn
modifier|*
name|inner
decl_stmt|;
name|struct
name|op
name|op
index|[
literal|5
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|ops
name|eval_ops
index|[]
init|=
block|{
block|{
name|eval_table
block|,
block|{
block|{
literal|"||"
block|,
name|op_or
block|}
block|}
block|}
block|,
block|{
name|eval_table
block|,
block|{
block|{
literal|"&&"
block|,
name|op_and
block|}
block|}
block|}
block|,
block|{
name|eval_table
block|,
block|{
block|{
literal|"=="
block|,
name|op_eq
block|}
block|,
block|{
literal|"!="
block|,
name|op_ne
block|}
block|}
block|}
block|,
block|{
name|eval_unary
block|,
block|{
block|{
literal|"<="
block|,
name|op_le
block|}
block|,
block|{
literal|">="
block|,
name|op_ge
block|}
block|,
block|{
literal|"<"
block|,
name|op_lt
block|}
block|,
block|{
literal|">"
block|,
name|op_gt
block|}
block|}
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Current operator precedence level */
end_comment

begin_function
specifier|static
name|long
name|prec
parameter_list|(
specifier|const
name|struct
name|ops
modifier|*
name|ops
parameter_list|)
block|{
return|return
operator|(
name|ops
operator|-
name|eval_ops
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Function for evaluating the innermost parts of expressions,  * viz. !expr (expr) number defined(symbol) symbol  * We reset the constexpr flag in the last two cases.  */
end_comment

begin_function
specifier|static
name|Linetype
name|eval_unary
parameter_list|(
specifier|const
name|struct
name|ops
modifier|*
name|ops
parameter_list|,
name|long
modifier|*
name|valp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
name|int
name|sym
decl_stmt|;
name|bool
name|defparen
decl_stmt|;
name|Linetype
name|lt
decl_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
operator|*
name|cpp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'!'
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d !"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|++
expr_stmt|;
name|lt
operator|=
name|eval_unary
argument_list|(
name|ops
argument_list|,
name|valp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|LT_ERROR
condition|)
return|return
operator|(
name|LT_ERROR
operator|)
return|;
if|if
condition|(
name|lt
operator|!=
name|LT_IF
condition|)
block|{
operator|*
name|valp
operator|=
operator|!
operator|*
name|valp
expr_stmt|;
name|lt
operator|=
operator|*
name|valp
condition|?
name|LT_TRUE
else|:
name|LT_FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|cp
operator|++
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d ("
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|=
name|eval_table
argument_list|(
name|eval_ops
argument_list|,
name|valp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|LT_ERROR
condition|)
return|return
operator|(
name|LT_ERROR
operator|)
return|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|++
operator|!=
literal|')'
condition|)
return|return
operator|(
name|LT_ERROR
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d number"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
name|strtol
argument_list|(
name|cp
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|ep
operator|==
name|cp
condition|)
return|return
operator|(
name|LT_ERROR
operator|)
return|;
name|lt
operator|=
operator|*
name|valp
condition|?
name|LT_TRUE
else|:
name|LT_FALSE
expr_stmt|;
name|cp
operator|=
name|ep
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|matchsym
argument_list|(
literal|"defined"
argument_list|,
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
operator|+
literal|7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
name|defparen
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|defparen
operator|=
name|false
expr_stmt|;
block|}
name|sym
operator|=
name|findsym
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|defparen
operator|&&
operator|*
name|cp
operator|++
operator|!=
literal|')'
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d defined missing ')'"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|LT_ERROR
operator|)
return|;
block|}
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d defined unknown"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
name|lt
operator|=
name|LT_IF
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"eval%d defined %s"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|,
name|symname
index|[
name|sym
index|]
argument_list|)
expr_stmt|;
operator|*
name|valp
operator|=
operator|(
name|value
index|[
name|sym
index|]
operator|!=
name|NULL
operator|)
expr_stmt|;
name|lt
operator|=
operator|*
name|valp
condition|?
name|LT_TRUE
else|:
name|LT_FALSE
expr_stmt|;
block|}
name|constexpr
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|endsym
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
block|{
name|debug
argument_list|(
literal|"eval%d symbol"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
name|sym
operator|=
name|findsym
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
name|lt
operator|=
name|LT_IF
expr_stmt|;
name|cp
operator|=
name|skipargs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
index|[
name|sym
index|]
operator|==
name|NULL
condition|)
block|{
operator|*
name|valp
operator|=
literal|0
expr_stmt|;
name|lt
operator|=
name|LT_FALSE
expr_stmt|;
block|}
else|else
block|{
operator|*
name|valp
operator|=
name|strtol
argument_list|(
name|value
index|[
name|sym
index|]
argument_list|,
operator|&
name|ep
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|ep
operator|!=
literal|'\0'
operator|||
name|ep
operator|==
name|value
index|[
name|sym
index|]
condition|)
return|return
operator|(
name|LT_ERROR
operator|)
return|;
name|lt
operator|=
operator|*
name|valp
condition|?
name|LT_TRUE
else|:
name|LT_FALSE
expr_stmt|;
name|cp
operator|=
name|skipargs
argument_list|(
name|cp
argument_list|)
expr_stmt|;
block|}
name|constexpr
operator|=
name|false
expr_stmt|;
block|}
else|else
block|{
name|debug
argument_list|(
literal|"eval%d bad expr"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|LT_ERROR
operator|)
return|;
block|}
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d = %d"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|,
operator|*
name|valp
argument_list|)
expr_stmt|;
return|return
operator|(
name|lt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Table-driven evaluation of binary operators.  */
end_comment

begin_function
specifier|static
name|Linetype
name|eval_table
parameter_list|(
specifier|const
name|struct
name|ops
modifier|*
name|ops
parameter_list|,
name|long
modifier|*
name|valp
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
specifier|const
name|struct
name|op
modifier|*
name|op
decl_stmt|;
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|long
name|val
decl_stmt|;
name|Linetype
name|lt
decl_stmt|,
name|rt
decl_stmt|;
name|debug
argument_list|(
literal|"eval%d"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|*
name|cpp
expr_stmt|;
name|lt
operator|=
name|ops
operator|->
name|inner
argument_list|(
name|ops
operator|+
literal|1
argument_list|,
name|valp
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|lt
operator|==
name|LT_ERROR
condition|)
return|return
operator|(
name|LT_ERROR
operator|)
return|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
for|for
control|(
name|op
operator|=
name|ops
operator|->
name|op
init|;
name|op
operator|->
name|str
operator|!=
name|NULL
condition|;
name|op
operator|++
control|)
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
name|op
operator|->
name|str
argument_list|,
name|strlen
argument_list|(
name|op
operator|->
name|str
argument_list|)
argument_list|)
operator|==
literal|0
condition|)
break|break;
if|if
condition|(
name|op
operator|->
name|str
operator|==
name|NULL
condition|)
break|break;
name|cp
operator|+=
name|strlen
argument_list|(
name|op
operator|->
name|str
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d %s"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|,
name|op
operator|->
name|str
argument_list|)
expr_stmt|;
name|rt
operator|=
name|ops
operator|->
name|inner
argument_list|(
name|ops
operator|+
literal|1
argument_list|,
operator|&
name|val
argument_list|,
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|rt
operator|==
name|LT_ERROR
condition|)
return|return
operator|(
name|LT_ERROR
operator|)
return|;
name|lt
operator|=
name|op
operator|->
name|fn
argument_list|(
name|valp
argument_list|,
name|lt
argument_list|,
operator|*
name|valp
argument_list|,
name|rt
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d = %d"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|,
operator|*
name|valp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"eval%d lt = %s"
argument_list|,
name|prec
argument_list|(
name|ops
argument_list|)
argument_list|,
name|linetype_name
index|[
name|lt
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|lt
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Evaluate the expression on a #if or #elif line. If we can work out  * the result we return LT_TRUE or LT_FALSE accordingly, otherwise we  * return just a generic LT_IF.  */
end_comment

begin_function
specifier|static
name|Linetype
name|ifeval
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
name|Linetype
name|ret
decl_stmt|;
name|long
name|val
init|=
literal|0
decl_stmt|;
name|debug
argument_list|(
literal|"eval %s"
argument_list|,
operator|*
name|cpp
argument_list|)
expr_stmt|;
name|constexpr
operator|=
name|killconsts
condition|?
name|false
else|:
name|true
expr_stmt|;
name|ret
operator|=
name|eval_table
argument_list|(
name|eval_ops
argument_list|,
operator|&
name|val
argument_list|,
name|cpp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"eval = %d"
argument_list|,
name|val
argument_list|)
expr_stmt|;
return|return
operator|(
name|constexpr
condition|?
name|LT_IF
else|:
name|ret
operator|==
name|LT_ERROR
condition|?
name|LT_IF
else|:
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Read a line and examine its initial part to determine if it is a  * preprocessor directive. Returns NULL on EOF, or a pointer to a  * preprocessor directive name, or a pointer to the zero byte at the  * end of the line.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skiphash
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|linenum
operator|++
expr_stmt|;
if|if
condition|(
name|fgets
argument_list|(
name|tline
argument_list|,
name|MAXLINE
argument_list|,
name|input
argument_list|)
operator|==
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|input
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't read %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|cp
operator|=
name|skipcomment
argument_list|(
name|tline
argument_list|)
expr_stmt|;
if|if
condition|(
name|linestate
operator|==
name|LS_START
operator|&&
operator|*
name|cp
operator|==
literal|'#'
condition|)
block|{
name|linestate
operator|=
name|LS_HASH
expr_stmt|;
return|return
operator|(
name|skipcomment
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
operator|)
return|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
return|return
operator|(
name|cp
operator|)
return|;
block|}
else|else
block|{
return|return
operator|(
name|skipline
argument_list|(
name|cp
argument_list|)
operator|)
return|;
block|}
block|}
end_function

begin_comment
comment|/*  * Mark a line dirty and consume the rest of it, keeping track of the  * lexical state.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skipline
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over comments, strings, and character literals and stop at the  * next character position that is not whitespace. Between calls we keep  * the comment state in the global variable incomment, and we also adjust  * the global variable linestate when we see a newline.  * XXX: doesn't cope with the buffer splitting inside a state transition.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skipcomment
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
if|if
condition|(
name|text
operator|||
name|ignoring
index|[
name|depth
index|]
condition|)
block|{
for|for
control|(
init|;
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cp
argument_list|)
condition|;
name|cp
operator|++
control|)
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\n'
condition|)
name|linestate
operator|=
name|LS_START
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
comment|/* don't reset to LS_START after a line continuation */
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\\\r\n"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|+=
literal|3
expr_stmt|;
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\\\n"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
name|cp
operator|+=
literal|2
expr_stmt|;
else|else
switch|switch
condition|(
name|incomment
condition|)
block|{
case|case
name|NO_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"/\\\r\n"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|STARTING_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"/\\\n"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|STARTING_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"/*"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|C_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"//"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|CXX_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\'"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|CHAR_LITERAL
expr_stmt|;
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\""
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|STRING_LITERAL
expr_stmt|;
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|linestate
operator|=
name|LS_START
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strchr
argument_list|(
literal|" \r\t"
argument_list|,
operator|*
name|cp
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
return|return
operator|(
name|cp
operator|)
return|;
continue|continue;
case|case
name|CXX_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|linestate
operator|=
name|LS_START
expr_stmt|;
block|}
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
name|CHAR_LITERAL
case|:
case|case
name|STRING_LITERAL
case|:
if|if
condition|(
operator|(
name|incomment
operator|==
name|CHAR_LITERAL
operator|&&
name|cp
index|[
literal|0
index|]
operator|==
literal|'\''
operator|)
operator|||
operator|(
name|incomment
operator|==
name|STRING_LITERAL
operator|&&
name|cp
index|[
literal|0
index|]
operator|==
literal|'\"'
operator|)
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cp
index|[
literal|0
index|]
operator|==
literal|'\\'
condition|)
block|{
if|if
condition|(
name|cp
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
name|cp
operator|+=
literal|1
expr_stmt|;
else|else
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"\n"
argument_list|,
literal|1
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|incomment
operator|==
name|CHAR_LITERAL
condition|)
name|error
argument_list|(
literal|"unterminated char literal"
argument_list|)
expr_stmt|;
else|else
name|error
argument_list|(
literal|"unterminated string literal"
argument_list|)
expr_stmt|;
block|}
else|else
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
name|C_COMMENT
case|:
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"*\\\r\n"
argument_list|,
literal|4
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|FINISHING_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|4
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"*\\\n"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|FINISHING_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|3
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cp
argument_list|,
literal|"*/"
argument_list|,
literal|2
argument_list|)
operator|==
literal|0
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|2
expr_stmt|;
block|}
else|else
name|cp
operator|+=
literal|1
expr_stmt|;
continue|continue;
case|case
name|STARTING_COMMENT
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'*'
condition|)
block|{
name|incomment
operator|=
name|C_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|incomment
operator|=
name|CXX_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|linestate
operator|=
name|LS_DIRTY
expr_stmt|;
block|}
continue|continue;
case|case
name|FINISHING_COMMENT
case|:
if|if
condition|(
operator|*
name|cp
operator|==
literal|'/'
condition|)
block|{
name|incomment
operator|=
name|NO_COMMENT
expr_stmt|;
name|cp
operator|+=
literal|1
expr_stmt|;
block|}
else|else
name|incomment
operator|=
name|C_COMMENT
expr_stmt|;
continue|continue;
default|default:
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
block|}
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip macro arguments.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skipargs
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|ocp
init|=
name|cp
decl_stmt|;
name|int
name|level
init|=
literal|0
decl_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|!=
literal|'('
condition|)
return|return
operator|(
name|cp
operator|)
return|;
do|do
block|{
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
name|level
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|')'
condition|)
name|level
operator|--
expr_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
operator|+
literal|1
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|level
operator|!=
literal|0
operator|&&
operator|*
name|cp
operator|!=
literal|'\0'
condition|)
do|;
if|if
condition|(
name|level
operator|==
literal|0
condition|)
return|return
operator|(
name|cp
operator|)
return|;
else|else
comment|/* Rewind and re-detect the syntax error later. */
return|return
operator|(
name|ocp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip over an identifier.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|skipsym
parameter_list|(
specifier|const
name|char
modifier|*
name|cp
parameter_list|)
block|{
while|while
condition|(
operator|!
name|endsym
argument_list|(
operator|*
name|cp
argument_list|)
condition|)
operator|++
name|cp
expr_stmt|;
return|return
operator|(
name|cp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Skip whitespace and take a copy of any following identifier.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|getsym
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|cpp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
operator|*
name|cpp
decl_stmt|,
modifier|*
name|sym
decl_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|cp
operator|=
name|skipsym
argument_list|(
name|sym
operator|=
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|sym
condition|)
return|return
name|NULL
return|;
operator|*
name|cpp
operator|=
name|cp
expr_stmt|;
return|return
operator|(
name|xstrdup
argument_list|(
name|sym
argument_list|,
name|cp
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check that s (a symbol) matches the start of t, and that the  * following character in t is not a symbol character. Returns a  * pointer to the following character in t if there is a match,  * otherwise NULL.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|matchsym
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
specifier|const
name|char
modifier|*
name|t
parameter_list|)
block|{
while|while
condition|(
operator|*
name|s
operator|!=
literal|'\0'
operator|&&
operator|*
name|t
operator|!=
literal|'\0'
condition|)
if|if
condition|(
operator|*
name|s
operator|!=
operator|*
name|t
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
else|else
operator|++
name|s
operator|,
operator|++
name|t
expr_stmt|;
if|if
condition|(
operator|*
name|s
operator|==
literal|'\0'
operator|&&
name|endsym
argument_list|(
operator|*
name|t
argument_list|)
condition|)
return|return
operator|(
name|t
operator|)
return|;
else|else
return|return
operator|(
name|NULL
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Look for the symbol in the symbol table. If it is found, we return  * the symbol table index, else we return -1.  */
end_comment

begin_function
specifier|static
name|int
name|findsym
parameter_list|(
specifier|const
name|char
modifier|*
modifier|*
name|strp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|symind
decl_stmt|;
name|str
operator|=
operator|*
name|strp
expr_stmt|;
operator|*
name|strp
operator|=
name|skipsym
argument_list|(
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|symlist
condition|)
block|{
if|if
condition|(
operator|*
name|strp
operator|==
name|str
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
name|symdepth
operator|&&
name|firstsym
condition|)
name|printf
argument_list|(
literal|"%s%3d"
argument_list|,
name|zerosyms
condition|?
literal|""
else|:
literal|"\n"
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|firstsym
operator|=
name|zerosyms
operator|=
name|false
expr_stmt|;
name|printf
argument_list|(
literal|"%s%.*s%s"
argument_list|,
name|symdepth
condition|?
literal|" "
else|:
literal|""
argument_list|,
call|(
name|int
call|)
argument_list|(
operator|*
name|strp
operator|-
name|str
argument_list|)
argument_list|,
name|str
argument_list|,
name|symdepth
condition|?
literal|""
else|:
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* we don't care about the value of the symbol */
return|return
operator|(
literal|0
operator|)
return|;
block|}
for|for
control|(
name|symind
operator|=
literal|0
init|;
name|symind
operator|<
name|nsyms
condition|;
operator|++
name|symind
control|)
block|{
if|if
condition|(
name|matchsym
argument_list|(
name|symname
index|[
name|symind
index|]
argument_list|,
name|str
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|debugsym
argument_list|(
literal|"findsym"
argument_list|,
name|symind
argument_list|)
expr_stmt|;
return|return
operator|(
name|symind
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Resolve indirect symbol values to their final definitions.  */
end_comment

begin_function
specifier|static
name|void
name|indirectsym
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|;
name|int
name|changed
decl_stmt|,
name|sym
decl_stmt|,
name|ind
decl_stmt|;
do|do
block|{
name|changed
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|sym
operator|=
literal|0
init|;
name|sym
operator|<
name|nsyms
condition|;
operator|++
name|sym
control|)
block|{
if|if
condition|(
name|value
index|[
name|sym
index|]
operator|==
name|NULL
condition|)
continue|continue;
name|cp
operator|=
name|value
index|[
name|sym
index|]
expr_stmt|;
name|ind
operator|=
name|findsym
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|ind
operator|==
operator|-
literal|1
operator|||
name|ind
operator|==
name|sym
operator|||
operator|*
name|cp
operator|!=
literal|'\0'
operator|||
name|value
index|[
name|ind
index|]
operator|==
name|NULL
operator|||
name|value
index|[
name|ind
index|]
operator|==
name|value
index|[
name|sym
index|]
condition|)
continue|continue;
name|debugsym
argument_list|(
literal|"indir..."
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|value
index|[
name|sym
index|]
operator|=
name|value
index|[
name|ind
index|]
expr_stmt|;
name|debugsym
argument_list|(
literal|"...ectsym"
argument_list|,
name|sym
argument_list|)
expr_stmt|;
name|changed
operator|++
expr_stmt|;
block|}
block|}
do|while
condition|(
name|changed
condition|)
do|;
block|}
end_function

begin_comment
comment|/*  * Add a symbol to the symbol table, specified with the format sym=val  */
end_comment

begin_function
specifier|static
name|void
name|addsym1
parameter_list|(
name|bool
name|ignorethis
parameter_list|,
name|bool
name|definethis
parameter_list|,
name|char
modifier|*
name|symval
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|sym
decl_stmt|,
modifier|*
name|val
decl_stmt|;
name|sym
operator|=
name|symval
expr_stmt|;
name|val
operator|=
name|skipsym
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|definethis
operator|&&
operator|*
name|val
operator|==
literal|'='
condition|)
block|{
name|symval
index|[
name|val
operator|-
name|sym
index|]
operator|=
literal|'\0'
expr_stmt|;
name|val
operator|=
name|val
operator|+
literal|1
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|val
operator|==
literal|'\0'
condition|)
block|{
name|val
operator|=
name|definethis
condition|?
literal|"1"
else|:
name|NULL
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
name|addsym2
argument_list|(
name|ignorethis
argument_list|,
name|sym
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add a symbol to the symbol table.  */
end_comment

begin_function
specifier|static
name|void
name|addsym2
parameter_list|(
name|bool
name|ignorethis
parameter_list|,
specifier|const
name|char
modifier|*
name|sym
parameter_list|,
specifier|const
name|char
modifier|*
name|val
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
init|=
name|sym
decl_stmt|;
name|int
name|symind
decl_stmt|;
name|symind
operator|=
name|findsym
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|symind
operator|<
literal|0
condition|)
block|{
if|if
condition|(
name|nsyms
operator|>=
name|MAXSYMS
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
literal|"too many symbols"
argument_list|)
expr_stmt|;
name|symind
operator|=
name|nsyms
operator|++
expr_stmt|;
block|}
name|ignore
index|[
name|symind
index|]
operator|=
name|ignorethis
expr_stmt|;
name|symname
index|[
name|symind
index|]
operator|=
name|sym
expr_stmt|;
name|value
index|[
name|symind
index|]
operator|=
name|val
expr_stmt|;
name|debugsym
argument_list|(
literal|"addsym"
argument_list|,
name|symind
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|debugsym
parameter_list|(
specifier|const
name|char
modifier|*
name|why
parameter_list|,
name|int
name|symind
parameter_list|)
block|{
name|debug
argument_list|(
literal|"%s %s%c%s"
argument_list|,
name|why
argument_list|,
name|symname
index|[
name|symind
index|]
argument_list|,
name|value
index|[
name|symind
index|]
condition|?
literal|'='
else|:
literal|' '
argument_list|,
name|value
index|[
name|symind
index|]
condition|?
name|value
index|[
name|symind
index|]
else|:
literal|"undef"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Add symbols to the symbol table from a file containing  * #define and #undef preprocessor directives.  */
end_comment

begin_function
specifier|static
name|void
name|defundefile
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|filename
operator|=
name|fn
expr_stmt|;
name|input
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't open %s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|linenum
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|defundef
argument_list|()
condition|)
empty_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|input
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"can't read %s"
argument_list|,
name|filename
argument_list|)
expr_stmt|;
else|else
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
if|if
condition|(
name|incomment
condition|)
name|error
argument_list|(
literal|"EOF in comment"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Read and process one #define or #undef directive  */
end_comment

begin_function
specifier|static
name|bool
name|defundef
parameter_list|(
name|void
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|cp
decl_stmt|,
modifier|*
name|kw
decl_stmt|,
modifier|*
name|sym
decl_stmt|,
modifier|*
name|val
decl_stmt|,
modifier|*
name|end
decl_stmt|;
name|cp
operator|=
name|skiphash
argument_list|()
expr_stmt|;
if|if
condition|(
name|cp
operator|==
name|NULL
condition|)
return|return
operator|(
name|false
operator|)
return|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
goto|goto
name|done
goto|;
comment|/* strip trailing whitespace, and do a fairly rough check to 	   avoid unsupported multi-line preprocessor directives */
name|end
operator|=
name|cp
operator|+
name|strlen
argument_list|(
name|cp
argument_list|)
expr_stmt|;
while|while
condition|(
name|end
operator|>
name|tline
operator|&&
name|strchr
argument_list|(
literal|" \t\n\r"
argument_list|,
name|end
index|[
operator|-
literal|1
index|]
argument_list|)
operator|!=
name|NULL
condition|)
operator|--
name|end
expr_stmt|;
if|if
condition|(
name|end
operator|>
name|tline
operator|&&
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|'\\'
condition|)
name|Eioccc
argument_list|()
expr_stmt|;
name|kw
operator|=
name|cp
expr_stmt|;
if|if
condition|(
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"define"
argument_list|,
name|kw
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|=
name|getsym
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"missing macro name in #define"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'('
condition|)
block|{
name|val
operator|=
literal|"1"
expr_stmt|;
block|}
else|else
block|{
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|val
operator|=
operator|(
name|cp
operator|<
name|end
operator|)
condition|?
name|xstrdup
argument_list|(
name|cp
argument_list|,
name|end
argument_list|)
else|:
literal|""
expr_stmt|;
block|}
name|debug
argument_list|(
literal|"#define"
argument_list|)
expr_stmt|;
name|addsym2
argument_list|(
name|false
argument_list|,
name|sym
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cp
operator|=
name|matchsym
argument_list|(
literal|"undef"
argument_list|,
name|kw
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|sym
operator|=
name|getsym
argument_list|(
operator|&
name|cp
argument_list|)
expr_stmt|;
if|if
condition|(
name|sym
operator|==
name|NULL
condition|)
name|error
argument_list|(
literal|"missing macro name in #undef"
argument_list|)
expr_stmt|;
name|cp
operator|=
name|skipcomment
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|debug
argument_list|(
literal|"#undef"
argument_list|)
expr_stmt|;
name|addsym2
argument_list|(
name|false
argument_list|,
name|sym
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|error
argument_list|(
literal|"unrecognized preprocessor directive"
argument_list|)
expr_stmt|;
block|}
name|skipline
argument_list|(
name|cp
argument_list|)
expr_stmt|;
name|done
label|:
name|debug
argument_list|(
literal|"parser line %d state %s comment %s line"
argument_list|,
name|linenum
argument_list|,
name|comment_name
index|[
name|incomment
index|]
argument_list|,
name|linestate_name
index|[
name|linestate
index|]
argument_list|)
expr_stmt|;
return|return
operator|(
name|true
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Concatenate two strings into new memory, checking for failure.  */
end_comment

begin_function
specifier|static
name|char
modifier|*
name|astrcat
parameter_list|(
specifier|const
name|char
modifier|*
name|s1
parameter_list|,
specifier|const
name|char
modifier|*
name|s2
parameter_list|)
block|{
name|char
modifier|*
name|s
decl_stmt|;
name|int
name|len
decl_stmt|;
name|size_t
name|size
decl_stmt|;
name|len
operator|=
name|snprintf
argument_list|(
name|NULL
argument_list|,
literal|0
argument_list|,
literal|"%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"snprintf"
argument_list|)
expr_stmt|;
name|size
operator|=
operator|(
name|size_t
operator|)
name|len
operator|+
literal|1
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|size
argument_list|,
literal|"%s%s"
argument_list|,
name|s1
argument_list|,
name|s2
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Duplicate a segment of a string, checking for failure.  */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|xstrdup
parameter_list|(
specifier|const
name|char
modifier|*
name|start
parameter_list|,
specifier|const
name|char
modifier|*
name|end
parameter_list|)
block|{
name|size_t
name|n
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
if|if
condition|(
name|end
operator|<
name|start
condition|)
name|abort
argument_list|()
expr_stmt|;
comment|/* bug */
name|n
operator|=
call|(
name|size_t
call|)
argument_list|(
name|end
operator|-
name|start
argument_list|)
operator|+
literal|1
expr_stmt|;
name|s
operator|=
name|malloc
argument_list|(
name|n
argument_list|)
expr_stmt|;
if|if
condition|(
name|s
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|s
argument_list|,
name|n
argument_list|,
literal|"%s"
argument_list|,
name|start
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Diagnostics.  */
end_comment

begin_function
specifier|static
name|void
name|debug
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|,
modifier|...
parameter_list|)
block|{
name|va_list
name|ap
decl_stmt|;
if|if
condition|(
name|debugging
condition|)
block|{
name|va_start
argument_list|(
name|ap
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|vwarnx
argument_list|(
name|msg
argument_list|,
name|ap
argument_list|)
expr_stmt|;
name|va_end
argument_list|(
name|ap
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
if|if
condition|(
name|depth
operator|==
literal|0
condition|)
name|warnx
argument_list|(
literal|"%s: %d: %s"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|,
name|msg
argument_list|)
expr_stmt|;
else|else
name|warnx
argument_list|(
literal|"%s: %d: %s (#if line %d depth %d)"
argument_list|,
name|filename
argument_list|,
name|linenum
argument_list|,
name|msg
argument_list|,
name|stifline
index|[
name|depth
index|]
argument_list|,
name|depth
argument_list|)
expr_stmt|;
name|closeio
argument_list|()
expr_stmt|;
name|errx
argument_list|(
literal|2
argument_list|,
literal|"output may be truncated"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

