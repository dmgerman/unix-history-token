begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * units.c   Copyright (c) 1993 by Adrian Mariano (adrian@cam.cornell.edu)  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. The name of the author may not be used to endorse or promote products  *    derived from this software without specific prior written permission.  * Disclaimer:  This software is provided by the author "as is".  The author  * shall not be liable for any damages caused in any way by this software.  *  * I would appreciate (though I do not require) receiving a copy of any  * improvements you might make to this program.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_define
define|#
directive|define
name|VERSION
value|"1.0"
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|UNITSFILE
end_ifndef

begin_define
define|#
directive|define
name|UNITSFILE
value|_PATH_UNITSLIB
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|MAXUNITS
value|1000
end_define

begin_define
define|#
directive|define
name|MAXPREFIXES
value|100
end_define

begin_define
define|#
directive|define
name|MAXSUBUNITS
value|500
end_define

begin_define
define|#
directive|define
name|PRIMITIVECHAR
value|'!'
end_define

begin_decl_stmt
specifier|const
name|char
modifier|*
name|powerstring
init|=
literal|"^"
decl_stmt|;
end_decl_stmt

begin_struct
struct|struct
block|{
name|char
modifier|*
name|uname
decl_stmt|;
name|char
modifier|*
name|uval
decl_stmt|;
block|}
name|unittable
index|[
name|MAXUNITS
index|]
struct|;
end_struct

begin_struct
struct|struct
name|unittype
block|{
name|char
modifier|*
name|numerator
index|[
name|MAXSUBUNITS
index|]
decl_stmt|;
name|char
modifier|*
name|denominator
index|[
name|MAXSUBUNITS
index|]
decl_stmt|;
name|double
name|factor
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
block|{
name|char
modifier|*
name|prefixname
decl_stmt|;
name|char
modifier|*
name|prefixval
decl_stmt|;
block|}
name|prefixtable
index|[
name|MAXPREFIXES
index|]
struct|;
end_struct

begin_decl_stmt
name|char
name|NULLUNIT
index|[]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|MSDOS
end_ifdef

begin_define
define|#
directive|define
name|SEPARATOR
value|";"
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|SEPARATOR
value|":"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|unitcount
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|prefixcount
decl_stmt|;
end_decl_stmt

begin_function
name|char
modifier|*
name|dupstr
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|ret
decl_stmt|;
name|ret
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret
condition|)
name|errx
argument_list|(
literal|3
argument_list|,
literal|"memory allocation error"
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|ret
argument_list|,
name|str
argument_list|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_function
name|void
name|readunits
parameter_list|(
specifier|const
name|char
modifier|*
name|userfile
parameter_list|)
block|{
name|FILE
modifier|*
name|unitfile
decl_stmt|;
name|char
name|line
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|lineptr
decl_stmt|;
name|int
name|len
decl_stmt|,
name|linenum
decl_stmt|,
name|i
decl_stmt|;
name|unitcount
operator|=
literal|0
expr_stmt|;
name|linenum
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|userfile
condition|)
block|{
name|unitfile
operator|=
name|fopen
argument_list|(
name|userfile
argument_list|,
literal|"rt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unitfile
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to open units file '%s'"
argument_list|,
name|userfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|unitfile
operator|=
name|fopen
argument_list|(
name|UNITSFILE
argument_list|,
literal|"rt"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|unitfile
condition|)
block|{
name|char
modifier|*
name|direc
decl_stmt|,
modifier|*
name|env
decl_stmt|;
name|char
name|filename
index|[
literal|1000
index|]
decl_stmt|;
name|env
operator|=
name|getenv
argument_list|(
literal|"PATH"
argument_list|)
expr_stmt|;
if|if
condition|(
name|env
condition|)
block|{
name|direc
operator|=
name|strtok
argument_list|(
name|env
argument_list|,
name|SEPARATOR
argument_list|)
expr_stmt|;
while|while
condition|(
name|direc
condition|)
block|{
name|snprintf
argument_list|(
name|filename
argument_list|,
sizeof|sizeof
argument_list|(
name|filename
argument_list|)
argument_list|,
literal|"%s/%s"
argument_list|,
name|direc
argument_list|,
name|UNITSFILE
argument_list|)
expr_stmt|;
name|unitfile
operator|=
name|fopen
argument_list|(
name|filename
argument_list|,
literal|"rt"
argument_list|)
expr_stmt|;
if|if
condition|(
name|unitfile
condition|)
break|break;
name|direc
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
name|SEPARATOR
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|!
name|unitfile
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't find units file '%s'"
argument_list|,
name|UNITSFILE
argument_list|)
expr_stmt|;
block|}
block|}
while|while
condition|(
operator|!
name|feof
argument_list|(
name|unitfile
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|line
argument_list|,
sizeof|sizeof
argument_list|(
name|line
argument_list|)
argument_list|,
name|unitfile
argument_list|)
condition|)
break|break;
name|linenum
operator|++
expr_stmt|;
name|lineptr
operator|=
name|line
expr_stmt|;
if|if
condition|(
operator|*
name|lineptr
operator|==
literal|'/'
condition|)
continue|continue;
name|lineptr
operator|+=
name|strspn
argument_list|(
name|lineptr
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|lineptr
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
name|lineptr
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|lineptr
argument_list|)
condition|)
continue|continue;
if|if
condition|(
name|lineptr
index|[
name|strlen
argument_list|(
name|lineptr
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* it's a prefix */
if|if
condition|(
name|prefixcount
operator|==
name|MAXPREFIXES
condition|)
block|{
name|warnx
argument_list|(
literal|"memory for prefixes exceeded in line %d"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lineptr
index|[
name|strlen
argument_list|(
name|lineptr
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
name|prefixtable
index|[
name|prefixcount
index|]
operator|.
name|prefixname
operator|=
name|dupstr
argument_list|(
name|lineptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prefixcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|prefixtable
index|[
name|i
index|]
operator|.
name|prefixname
argument_list|,
name|lineptr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"redefinition of prefix '%s' on line %d ignored"
argument_list|,
name|lineptr
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lineptr
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|lineptr
operator|+=
name|strspn
argument_list|(
name|lineptr
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
name|len
operator|=
name|strcspn
argument_list|(
name|lineptr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected end of prefix on line %d"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lineptr
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|prefixtable
index|[
name|prefixcount
operator|++
index|]
operator|.
name|prefixval
operator|=
name|dupstr
argument_list|(
name|lineptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* it's not a prefix */
if|if
condition|(
name|unitcount
operator|==
name|MAXUNITS
condition|)
block|{
name|warnx
argument_list|(
literal|"memory for units exceeded in line %d"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|unittable
index|[
name|unitcount
index|]
operator|.
name|uname
operator|=
name|dupstr
argument_list|(
name|lineptr
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unitcount
condition|;
name|i
operator|++
control|)
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|unittable
index|[
name|i
index|]
operator|.
name|uname
argument_list|,
name|lineptr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"redefinition of unit '%s' on line %d ignored"
argument_list|,
name|lineptr
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|lineptr
operator|+=
name|len
operator|+
literal|1
expr_stmt|;
name|lineptr
operator|+=
name|strspn
argument_list|(
name|lineptr
argument_list|,
literal|" \n\t"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|lineptr
argument_list|)
condition|)
block|{
name|warnx
argument_list|(
literal|"unexpected end of unit on line %d"
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|len
operator|=
name|strcspn
argument_list|(
name|lineptr
argument_list|,
literal|"\n\t"
argument_list|)
expr_stmt|;
name|lineptr
index|[
name|len
index|]
operator|=
literal|0
expr_stmt|;
name|unittable
index|[
name|unitcount
operator|++
index|]
operator|.
name|uval
operator|=
name|dupstr
argument_list|(
name|lineptr
argument_list|)
expr_stmt|;
block|}
block|}
name|fclose
argument_list|(
name|unitfile
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|initializeunit
parameter_list|(
name|struct
name|unittype
modifier|*
name|theunit
parameter_list|)
block|{
name|theunit
operator|->
name|factor
operator|=
literal|1.0
expr_stmt|;
name|theunit
operator|->
name|numerator
index|[
literal|0
index|]
operator|=
name|theunit
operator|->
name|denominator
index|[
literal|0
index|]
operator|=
name|NULL
expr_stmt|;
block|}
end_function

begin_function
name|int
name|addsubunit
parameter_list|(
name|char
modifier|*
name|product
index|[]
parameter_list|,
name|char
modifier|*
name|toadd
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
for|for
control|(
name|ptr
operator|=
name|product
init|;
operator|*
name|ptr
operator|&&
operator|*
name|ptr
operator|!=
name|NULLUNIT
condition|;
name|ptr
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|ptr
operator|>=
name|product
operator|+
name|MAXSUBUNITS
condition|)
block|{
name|warnx
argument_list|(
literal|"memory overflow in unit reduction"
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
operator|!
operator|*
name|ptr
condition|)
operator|*
operator|(
name|ptr
operator|+
literal|1
operator|)
operator|=
literal|0
expr_stmt|;
operator|*
name|ptr
operator|=
name|dupstr
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|showunit
parameter_list|(
name|struct
name|unittype
modifier|*
name|theunit
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|int
name|printedslash
decl_stmt|;
name|int
name|counter
init|=
literal|1
decl_stmt|;
name|printf
argument_list|(
literal|"\t%.8g"
argument_list|,
name|theunit
operator|->
name|factor
argument_list|)
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|theunit
operator|->
name|numerator
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|>
name|theunit
operator|->
name|numerator
operator|&&
operator|*
operator|*
name|ptr
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|ptr
argument_list|,
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
argument_list|)
condition|)
name|counter
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|counter
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|powerstring
argument_list|,
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
condition|)
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
name|counter
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|counter
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|powerstring
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|counter
operator|=
literal|1
expr_stmt|;
name|printedslash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|ptr
operator|=
name|theunit
operator|->
name|denominator
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
control|)
block|{
if|if
condition|(
name|ptr
operator|>
name|theunit
operator|->
name|denominator
operator|&&
operator|*
operator|*
name|ptr
operator|&&
operator|!
name|strcmp
argument_list|(
operator|*
name|ptr
argument_list|,
operator|*
operator|(
name|ptr
operator|-
literal|1
operator|)
argument_list|)
condition|)
name|counter
operator|++
expr_stmt|;
else|else
block|{
if|if
condition|(
name|counter
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|powerstring
argument_list|,
name|counter
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
operator|*
name|ptr
condition|)
block|{
if|if
condition|(
operator|!
name|printedslash
condition|)
name|printf
argument_list|(
literal|" /"
argument_list|)
expr_stmt|;
name|printedslash
operator|=
literal|1
expr_stmt|;
name|printf
argument_list|(
literal|" %s"
argument_list|,
operator|*
name|ptr
argument_list|)
expr_stmt|;
block|}
name|counter
operator|=
literal|1
expr_stmt|;
block|}
block|}
if|if
condition|(
name|counter
operator|>
literal|1
condition|)
name|printf
argument_list|(
literal|"%s%d"
argument_list|,
name|powerstring
argument_list|,
name|counter
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|zeroerror
parameter_list|(
name|void
parameter_list|)
block|{
name|warnx
argument_list|(
literal|"unit reduces to zero"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*    Adds the specified string to the unit.    Flip is 0 for adding normally, 1 for adding reciprocal.     Returns 0 for successful addition, nonzero on error. */
end_comment

begin_function
name|int
name|addunit
parameter_list|(
name|struct
name|unittype
modifier|*
name|theunit
parameter_list|,
name|char
modifier|*
name|toadd
parameter_list|,
name|int
name|flip
parameter_list|)
block|{
name|char
modifier|*
name|scratch
decl_stmt|,
modifier|*
name|savescr
decl_stmt|;
name|char
modifier|*
name|item
decl_stmt|;
name|char
modifier|*
name|divider
decl_stmt|,
modifier|*
name|slash
decl_stmt|;
name|int
name|doingtop
decl_stmt|;
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|toadd
argument_list|)
condition|)
return|return
literal|1
return|;
name|savescr
operator|=
name|scratch
operator|=
name|dupstr
argument_list|(
name|toadd
argument_list|)
expr_stmt|;
for|for
control|(
name|slash
operator|=
name|scratch
operator|+
literal|1
init|;
operator|*
name|slash
condition|;
name|slash
operator|++
control|)
if|if
condition|(
operator|*
name|slash
operator|==
literal|'-'
operator|&&
operator|(
name|tolower
argument_list|(
operator|*
operator|(
name|slash
operator|-
literal|1
operator|)
argument_list|)
operator|!=
literal|'e'
operator|||
operator|!
name|strchr
argument_list|(
literal|".0123456789"
argument_list|,
operator|*
operator|(
name|slash
operator|+
literal|1
operator|)
argument_list|)
operator|)
condition|)
operator|*
name|slash
operator|=
literal|' '
expr_stmt|;
name|slash
operator|=
name|strchr
argument_list|(
name|scratch
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|slash
condition|)
operator|*
name|slash
operator|=
literal|0
expr_stmt|;
name|doingtop
operator|=
literal|1
expr_stmt|;
do|do
block|{
name|item
operator|=
name|strtok
argument_list|(
name|scratch
argument_list|,
literal|" *\t\n/"
argument_list|)
expr_stmt|;
while|while
condition|(
name|item
condition|)
block|{
if|if
condition|(
name|strchr
argument_list|(
literal|"0123456789."
argument_list|,
operator|*
name|item
argument_list|)
condition|)
block|{
comment|/* item is a number */
name|double
name|num
decl_stmt|;
name|divider
operator|=
name|strchr
argument_list|(
name|item
argument_list|,
literal|'|'
argument_list|)
expr_stmt|;
if|if
condition|(
name|divider
condition|)
block|{
operator|*
name|divider
operator|=
literal|0
expr_stmt|;
name|num
operator|=
name|atof
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
block|{
name|zeroerror
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|doingtop
operator|^
name|flip
condition|)
name|theunit
operator|->
name|factor
operator|*=
name|num
expr_stmt|;
else|else
name|theunit
operator|->
name|factor
operator|/=
name|num
expr_stmt|;
name|num
operator|=
name|atof
argument_list|(
name|divider
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
block|{
name|zeroerror
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|doingtop
operator|^
name|flip
condition|)
name|theunit
operator|->
name|factor
operator|/=
name|num
expr_stmt|;
else|else
name|theunit
operator|->
name|factor
operator|*=
name|num
expr_stmt|;
block|}
else|else
block|{
name|num
operator|=
name|atof
argument_list|(
name|item
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|num
condition|)
block|{
name|zeroerror
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
if|if
condition|(
name|doingtop
operator|^
name|flip
condition|)
name|theunit
operator|->
name|factor
operator|*=
name|num
expr_stmt|;
else|else
name|theunit
operator|->
name|factor
operator|/=
name|num
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* item is not a number */
name|int
name|repeat
init|=
literal|1
decl_stmt|;
if|if
condition|(
name|strchr
argument_list|(
literal|"23456789"
argument_list|,
name|item
index|[
name|strlen
argument_list|(
name|item
argument_list|)
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|repeat
operator|=
name|item
index|[
name|strlen
argument_list|(
name|item
argument_list|)
operator|-
literal|1
index|]
operator|-
literal|'0'
expr_stmt|;
name|item
index|[
name|strlen
argument_list|(
name|item
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
block|}
for|for
control|(
init|;
name|repeat
condition|;
name|repeat
operator|--
control|)
if|if
condition|(
name|addsubunit
argument_list|(
name|doingtop
operator|^
name|flip
condition|?
name|theunit
operator|->
name|numerator
else|:
name|theunit
operator|->
name|denominator
argument_list|,
name|item
argument_list|)
condition|)
return|return
literal|1
return|;
block|}
name|item
operator|=
name|strtok
argument_list|(
name|NULL
argument_list|,
literal|" *\t/\n"
argument_list|)
expr_stmt|;
block|}
name|doingtop
operator|--
expr_stmt|;
if|if
condition|(
name|slash
condition|)
block|{
name|scratch
operator|=
name|slash
operator|+
literal|1
expr_stmt|;
block|}
else|else
name|doingtop
operator|--
expr_stmt|;
block|}
do|while
condition|(
name|doingtop
operator|>=
literal|0
condition|)
do|;
name|free
argument_list|(
name|savescr
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|compare
parameter_list|(
specifier|const
name|void
modifier|*
name|item1
parameter_list|,
specifier|const
name|void
modifier|*
name|item2
parameter_list|)
block|{
return|return
name|strcmp
argument_list|(
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|item1
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|item2
argument_list|)
return|;
block|}
end_function

begin_function
name|void
name|sortunit
parameter_list|(
name|struct
name|unittype
modifier|*
name|theunit
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|ptr
decl_stmt|;
name|unsigned
name|int
name|count
decl_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|ptr
operator|=
name|theunit
operator|->
name|numerator
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
operator|,
name|count
operator|++
control|)
empty_stmt|;
name|qsort
argument_list|(
name|theunit
operator|->
name|numerator
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|ptr
operator|=
name|theunit
operator|->
name|denominator
init|;
operator|*
name|ptr
condition|;
name|ptr
operator|++
operator|,
name|count
operator|++
control|)
empty_stmt|;
name|qsort
argument_list|(
name|theunit
operator|->
name|denominator
argument_list|,
name|count
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|cancelunit
parameter_list|(
name|struct
name|unittype
modifier|*
name|theunit
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|den
decl_stmt|,
modifier|*
modifier|*
name|num
decl_stmt|;
name|int
name|comp
decl_stmt|;
name|den
operator|=
name|theunit
operator|->
name|denominator
expr_stmt|;
name|num
operator|=
name|theunit
operator|->
name|numerator
expr_stmt|;
while|while
condition|(
operator|*
name|num
operator|&&
operator|*
name|den
condition|)
block|{
name|comp
operator|=
name|strcmp
argument_list|(
operator|*
name|den
argument_list|,
operator|*
name|num
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|comp
condition|)
block|{
comment|/*      if (*den!=NULLUNIT) free(*den);       if (*num!=NULLUNIT) free(*num);*/
operator|*
name|den
operator|++
operator|=
name|NULLUNIT
expr_stmt|;
operator|*
name|num
operator|++
operator|=
name|NULLUNIT
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|comp
operator|<
literal|0
condition|)
name|den
operator|++
expr_stmt|;
else|else
name|num
operator|++
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*    Looks up the definition for the specified unit.    Returns a pointer to the definition or a null pointer    if the specified unit does not appear in the units table. */
end_comment

begin_decl_stmt
specifier|static
name|char
name|buffer
index|[
literal|100
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* buffer for lookupunit answers with 				   prefixes */
end_comment

begin_function
name|char
modifier|*
name|lookupunit
parameter_list|(
specifier|const
name|char
modifier|*
name|unit
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|copy
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unitcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|unittable
index|[
name|i
index|]
operator|.
name|uname
argument_list|,
name|unit
argument_list|)
condition|)
return|return
name|unittable
index|[
name|i
index|]
operator|.
name|uval
return|;
block|}
if|if
condition|(
name|unit
index|[
name|strlen
argument_list|(
name|unit
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'^'
condition|)
block|{
name|copy
operator|=
name|dupstr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|copy
index|[
name|strlen
argument_list|(
name|copy
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unitcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|unittable
index|[
name|i
index|]
operator|.
name|uname
argument_list|,
name|copy
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|buffer
argument_list|,
name|copy
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|unit
index|[
name|strlen
argument_list|(
name|unit
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'s'
condition|)
block|{
name|copy
operator|=
name|dupstr
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|copy
index|[
name|strlen
argument_list|(
name|copy
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unitcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|unittable
index|[
name|i
index|]
operator|.
name|uname
argument_list|,
name|copy
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|buffer
argument_list|,
name|copy
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
if|if
condition|(
name|copy
index|[
name|strlen
argument_list|(
name|copy
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'e'
condition|)
block|{
name|copy
index|[
name|strlen
argument_list|(
name|copy
argument_list|)
operator|-
literal|1
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|unitcount
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|unittable
index|[
name|i
index|]
operator|.
name|uname
argument_list|,
name|copy
argument_list|)
condition|)
block|{
name|strlcpy
argument_list|(
name|buffer
argument_list|,
name|copy
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
name|free
argument_list|(
name|copy
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|prefixcount
condition|;
name|i
operator|++
control|)
block|{
name|size_t
name|len
init|=
name|strlen
argument_list|(
name|prefixtable
index|[
name|i
index|]
operator|.
name|prefixname
argument_list|)
decl_stmt|;
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|prefixtable
index|[
name|i
index|]
operator|.
name|prefixname
argument_list|,
name|unit
argument_list|,
name|len
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|strlen
argument_list|(
name|unit
operator|+
name|len
argument_list|)
operator|||
name|lookupunit
argument_list|(
name|unit
operator|+
name|len
argument_list|)
condition|)
block|{
name|snprintf
argument_list|(
name|buffer
argument_list|,
sizeof|sizeof
argument_list|(
name|buffer
argument_list|)
argument_list|,
literal|"%s %s"
argument_list|,
name|prefixtable
index|[
name|i
index|]
operator|.
name|prefixval
argument_list|,
name|unit
operator|+
name|len
argument_list|)
expr_stmt|;
return|return
name|buffer
return|;
block|}
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/*    reduces a product of symbolic units to primitive units.    The three low bits are used to return flags:       bit 0 (1) set on if reductions were performed without error.      bit 1 (2) set on if no reductions are performed.      bit 2 (4) set on if an unknown unit is discovered. */
end_comment

begin_define
define|#
directive|define
name|ERROR
value|4
end_define

begin_function
name|int
name|reduceproduct
parameter_list|(
name|struct
name|unittype
modifier|*
name|theunit
parameter_list|,
name|int
name|flip
parameter_list|)
block|{
name|char
modifier|*
name|toadd
decl_stmt|;
name|char
modifier|*
modifier|*
name|product
decl_stmt|;
name|int
name|didsomething
init|=
literal|2
decl_stmt|;
if|if
condition|(
name|flip
condition|)
name|product
operator|=
name|theunit
operator|->
name|denominator
expr_stmt|;
else|else
name|product
operator|=
name|theunit
operator|->
name|numerator
expr_stmt|;
for|for
control|(
init|;
operator|*
name|product
condition|;
name|product
operator|++
control|)
block|{
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|!
name|strlen
argument_list|(
operator|*
name|product
argument_list|)
condition|)
break|break;
name|toadd
operator|=
name|lookupunit
argument_list|(
operator|*
name|product
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|toadd
condition|)
block|{
name|printf
argument_list|(
literal|"unknown unit '%s'\n"
argument_list|,
operator|*
name|product
argument_list|)
expr_stmt|;
return|return
name|ERROR
return|;
block|}
if|if
condition|(
name|strchr
argument_list|(
name|toadd
argument_list|,
name|PRIMITIVECHAR
argument_list|)
condition|)
break|break;
name|didsomething
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|product
operator|!=
name|NULLUNIT
condition|)
block|{
name|free
argument_list|(
operator|*
name|product
argument_list|)
expr_stmt|;
operator|*
name|product
operator|=
name|NULLUNIT
expr_stmt|;
block|}
if|if
condition|(
name|addunit
argument_list|(
name|theunit
argument_list|,
name|toadd
argument_list|,
name|flip
argument_list|)
condition|)
return|return
name|ERROR
return|;
block|}
block|}
return|return
name|didsomething
return|;
block|}
end_function

begin_comment
comment|/*    Reduces numerator and denominator of the specified unit.    Returns 0 on success, or 1 on unknown unit error. */
end_comment

begin_function
name|int
name|reduceunit
parameter_list|(
name|struct
name|unittype
modifier|*
name|theunit
parameter_list|)
block|{
name|int
name|ret
decl_stmt|;
name|ret
operator|=
literal|1
expr_stmt|;
while|while
condition|(
name|ret
operator|&
literal|1
condition|)
block|{
name|ret
operator|=
name|reduceproduct
argument_list|(
name|theunit
argument_list|,
literal|0
argument_list|)
operator||
name|reduceproduct
argument_list|(
name|theunit
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ret
operator|&
literal|4
condition|)
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
name|int
name|compareproducts
parameter_list|(
name|char
modifier|*
modifier|*
name|one
parameter_list|,
name|char
modifier|*
modifier|*
name|two
parameter_list|)
block|{
while|while
condition|(
operator|*
name|one
operator|||
operator|*
name|two
condition|)
block|{
if|if
condition|(
operator|!
operator|*
name|one
operator|&&
operator|*
name|two
operator|!=
name|NULLUNIT
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|!
operator|*
name|two
operator|&&
operator|*
name|one
operator|!=
name|NULLUNIT
condition|)
return|return
literal|1
return|;
if|if
condition|(
operator|*
name|one
operator|==
name|NULLUNIT
condition|)
name|one
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|two
operator|==
name|NULLUNIT
condition|)
name|two
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
operator|*
name|one
argument_list|,
operator|*
name|two
argument_list|)
condition|)
return|return
literal|1
return|;
else|else
name|one
operator|++
operator|,
name|two
operator|++
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* Return zero if units are compatible, nonzero otherwise */
end_comment

begin_function
name|int
name|compareunits
parameter_list|(
name|struct
name|unittype
modifier|*
name|first
parameter_list|,
name|struct
name|unittype
modifier|*
name|second
parameter_list|)
block|{
return|return
name|compareproducts
argument_list|(
name|first
operator|->
name|numerator
argument_list|,
name|second
operator|->
name|numerator
argument_list|)
operator|||
name|compareproducts
argument_list|(
name|first
operator|->
name|denominator
argument_list|,
name|second
operator|->
name|denominator
argument_list|)
return|;
block|}
end_function

begin_function
name|int
name|completereduce
parameter_list|(
name|struct
name|unittype
modifier|*
name|unit
parameter_list|)
block|{
if|if
condition|(
name|reduceunit
argument_list|(
name|unit
argument_list|)
condition|)
return|return
literal|1
return|;
name|sortunit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
name|cancelunit
argument_list|(
name|unit
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|showanswer
parameter_list|(
name|struct
name|unittype
modifier|*
name|have
parameter_list|,
name|struct
name|unittype
modifier|*
name|want
parameter_list|)
block|{
if|if
condition|(
name|compareunits
argument_list|(
name|have
argument_list|,
name|want
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"conformability error\n"
argument_list|)
expr_stmt|;
name|showunit
argument_list|(
name|have
argument_list|)
expr_stmt|;
name|showunit
argument_list|(
name|want
argument_list|)
expr_stmt|;
block|}
else|else
name|printf
argument_list|(
literal|"\t* %.8g\n\t/ %.8g\n"
argument_list|,
name|have
operator|->
name|factor
operator|/
name|want
operator|->
name|factor
argument_list|,
name|want
operator|->
name|factor
operator|/
name|have
operator|->
name|factor
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: units [-f unitsfile] [-q] [-v] [from-unit to-unit]\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|struct
name|unittype
name|have
decl_stmt|,
name|want
decl_stmt|;
name|char
name|havestr
index|[
literal|81
index|]
decl_stmt|,
name|wantstr
index|[
literal|81
index|]
decl_stmt|;
name|int
name|optchar
decl_stmt|;
name|char
modifier|*
name|userfile
init|=
literal|0
decl_stmt|;
name|int
name|quiet
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|(
name|optchar
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"vqf:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|optchar
condition|)
block|{
case|case
literal|'f'
case|:
name|userfile
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|quiet
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n  units version %s  Copyright (c) 1993 by Adrian Mariano\n"
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"                    This program may be freely distributed\n"
argument_list|)
expr_stmt|;
name|usage
argument_list|()
expr_stmt|;
default|default:
name|usage
argument_list|()
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|optind
operator|!=
name|argc
operator|-
literal|2
operator|&&
name|optind
operator|!=
name|argc
condition|)
name|usage
argument_list|()
expr_stmt|;
name|readunits
argument_list|(
name|userfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|optind
operator|==
name|argc
operator|-
literal|2
condition|)
block|{
name|strlcpy
argument_list|(
name|havestr
argument_list|,
name|argv
index|[
name|optind
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|havestr
argument_list|)
argument_list|)
expr_stmt|;
name|strlcpy
argument_list|(
name|wantstr
argument_list|,
name|argv
index|[
name|optind
operator|+
literal|1
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|wantstr
argument_list|)
argument_list|)
expr_stmt|;
name|initializeunit
argument_list|(
operator|&
name|have
argument_list|)
expr_stmt|;
name|addunit
argument_list|(
operator|&
name|have
argument_list|,
name|havestr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|completereduce
argument_list|(
operator|&
name|have
argument_list|)
expr_stmt|;
name|initializeunit
argument_list|(
operator|&
name|want
argument_list|)
expr_stmt|;
name|addunit
argument_list|(
operator|&
name|want
argument_list|,
name|wantstr
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|completereduce
argument_list|(
operator|&
name|want
argument_list|)
expr_stmt|;
name|showanswer
argument_list|(
operator|&
name|have
argument_list|,
operator|&
name|want
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"%d units, %d prefixes\n"
argument_list|,
name|unitcount
argument_list|,
name|prefixcount
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
do|do
block|{
name|initializeunit
argument_list|(
operator|&
name|have
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"You have: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|havestr
argument_list|,
sizeof|sizeof
argument_list|(
name|havestr
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|addunit
argument_list|(
operator|&
name|have
argument_list|,
name|havestr
argument_list|,
literal|0
argument_list|)
operator|||
name|completereduce
argument_list|(
operator|&
name|have
argument_list|)
condition|)
do|;
do|do
block|{
name|initializeunit
argument_list|(
operator|&
name|want
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|quiet
condition|)
name|printf
argument_list|(
literal|"You want: "
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fgets
argument_list|(
name|wantstr
argument_list|,
sizeof|sizeof
argument_list|(
name|wantstr
argument_list|)
argument_list|,
name|stdin
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|quiet
condition|)
name|putchar
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
name|addunit
argument_list|(
operator|&
name|want
argument_list|,
name|wantstr
argument_list|,
literal|0
argument_list|)
operator|||
name|completereduce
argument_list|(
operator|&
name|want
argument_list|)
condition|)
do|;
name|showanswer
argument_list|(
operator|&
name|have
argument_list|,
operator|&
name|want
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

