begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ref2.c */
end_comment

begin_comment
comment|/* This is a totally rewritten version of ref.  This version looks for the  * desired function name in the "tags" file, and then reads the header out  * from the source file.  There is no longer any need for a "refs" file.  *  * Usage:	ref [-t] [-f file] [-c class] tag  * Options:	-t	   output tag info, not the description  *		-f file	   default filename for static functions  *		-c class   default class names for class functions  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|__STDC__
end_ifdef

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|cktagdir
name|P_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|getline
name|P_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|int
operator|,
name|FILE
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|lookup
name|P_
argument_list|(
operator|(
name|char
operator|*
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|find
name|P_
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
name|usage
name|P_
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|countcolons
name|P_
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|void
decl|main
name|P_
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This is the default path that is searched for tags */
end_comment

begin_if
if|#
directive|if
name|OSK
end_if

begin_define
define|#
directive|define
name|DEFTAGPATH
value|".:/dd/defs:/dd/defs/sys:/dd/usr/src/lib:../lib:/dd/usr/lib"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|ANY_UNIX
end_if

begin_define
define|#
directive|define
name|DEFTAGPATH
value|".:/usr/include:/usr/include/sys:/usr/src/lib:../lib:/usr/local/lib"
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|MSDOS
operator|||
name|TOS
end_if

begin_define
define|#
directive|define
name|DEFTAGPATH
value|".;C:\\include;C:\\include\\sys;C:\\lib;..\\lib"
end_define

begin_define
define|#
directive|define
name|SEP
value|';'
end_define

begin_else
else|#
directive|else
end_else

begin_if
if|#
directive|if
name|AMIGA
end_if

begin_define
define|#
directive|define
name|DEFTAGPATH
value|".;Include:;Include:sys"
end_define

begin_define
define|#
directive|define
name|SEP
value|';'
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* any other OS */
end_comment

begin_define
define|#
directive|define
name|DEFTAGPATH
value|"."
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|SEP
end_ifndef

begin_define
define|#
directive|define
name|SEP
value|':'
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* These variables reflect the command-line options given by the user. */
end_comment

begin_decl_stmt
name|int
name|taginfo
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean: give only the tag info? (not header?) */
end_comment

begin_decl_stmt
name|char
modifier|*
name|def_file
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default filename for static functions */
end_comment

begin_decl_stmt
name|char
modifier|*
name|def_class
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default classname for class members */
end_comment

begin_decl_stmt
name|int
name|colons
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* #colons in tag: 0=normal, 1=static, 2=member */
end_comment

begin_comment
comment|/* This function checks for a tag in the "tags" file of given directory.  * If the tag is found, then it returns a pointer to a static buffer which  * contains the filename, a tab character, and a linespec for finding the  * the tag.  If the tag is not found in the "tags" file, or if the "tags"  * file cannot be opened or doesn't exist, then this function returns NULL.  */
end_comment

begin_function
name|char
modifier|*
name|cktagdir
parameter_list|(
name|tag
parameter_list|,
name|dir
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* name of the tag to look for */
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* name of the directory to check */
block|{
name|char
name|buf
index|[
name|BLKSIZE
index|]
decl_stmt|;
specifier|static
name|char
name|found
index|[
name|BLKSIZE
index|]
decl_stmt|;
name|FILE
modifier|*
name|tfile
decl_stmt|;
name|int
name|len
decl_stmt|;
if|#
directive|if
name|AMIGA
if|if
condition|(
name|dir
index|[
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
index|]
operator|==
name|COLON
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%s"
argument_list|,
name|dir
argument_list|,
name|TAGS
argument_list|)
expr_stmt|;
comment|/* no slash after colon. */
else|else
endif|#
directive|endif
comment|/* construct the name of the "tags" file in this directory */
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%c%s"
argument_list|,
name|dir
argument_list|,
name|SLASH
argument_list|,
name|TAGS
argument_list|)
expr_stmt|;
comment|/* Try to open the tags file.  Return NULL if can't open */
if|#
directive|if
name|AMIGA
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
name|SLASH
condition|)
name|tfile
operator|=
name|fopen
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|tfile
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tfile
condition|)
block|{
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
comment|/* compute the length of the tagname once */
name|len
operator|=
name|strlen
argument_list|(
name|tag
argument_list|)
expr_stmt|;
comment|/* read lines until we get the one for this tag */
name|found
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
name|buf
argument_list|,
name|tfile
argument_list|)
condition|)
block|{
comment|/* is this the one we want? */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|tag
argument_list|,
name|len
argument_list|)
operator|&&
name|buf
index|[
name|len
index|]
operator|==
literal|'\t'
condition|)
block|{
comment|/* we've found a match -- remember it */
name|strcpy
argument_list|(
name|found
argument_list|,
name|buf
argument_list|)
expr_stmt|;
comment|/* if there is no default file, or this match is in 			 * the default file, then we've definitely found the 			 * one we want.  Break out of the loop now. 			 */
if|if
condition|(
operator|!
name|def_file
operator|||
operator|!
name|strncmp
argument_list|(
operator|&
name|buf
index|[
name|len
operator|+
literal|1
index|]
argument_list|,
name|def_file
argument_list|,
name|strlen
argument_list|(
name|def_file
argument_list|)
argument_list|)
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/* we're through reading */
name|fclose
argument_list|(
name|tfile
argument_list|)
expr_stmt|;
comment|/* if there's anything in found[], use it */
if|if
condition|(
name|found
index|[
literal|0
index|]
condition|)
block|{
return|return
operator|&
name|found
index|[
name|len
operator|+
literal|1
index|]
return|;
block|}
comment|/* else we didn't find it */
return|return
operator|(
name|char
operator|*
operator|)
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function reads a single textline from a binary file.  It returns  * the number of bytes read, or 0 at EOF.  */
end_comment

begin_function
name|int
name|getline
parameter_list|(
name|buf
parameter_list|,
name|limit
parameter_list|,
name|fp
parameter_list|)
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* buffer to read into */
name|int
name|limit
decl_stmt|;
comment|/* maximum characters to read */
name|FILE
modifier|*
name|fp
decl_stmt|;
comment|/* binary stream to read from */
block|{
name|int
name|bytes
decl_stmt|;
comment|/* number of bytes read so far */
name|int
name|ch
decl_stmt|;
comment|/* single character from file */
for|for
control|(
name|bytes
operator|=
literal|0
operator|,
name|ch
operator|=
literal|0
init|;
name|ch
operator|!=
literal|'\n'
operator|&&
operator|--
name|limit
operator|>
literal|0
operator|&&
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|fp
argument_list|)
operator|)
operator|!=
name|EOF
condition|;
name|bytes
operator|++
control|)
block|{
if|#
directive|if
name|MSDOS
operator|||
name|TOS
comment|/* since this is a binary file, we'll need to manually strip CR's */
if|if
condition|(
name|ch
operator|==
literal|'\r'
condition|)
block|{
continue|continue;
block|}
endif|#
directive|endif
operator|*
name|buf
operator|++
operator|=
name|ch
expr_stmt|;
block|}
operator|*
name|buf
operator|=
literal|'\0'
expr_stmt|;
return|return
name|bytes
return|;
block|}
end_function

begin_comment
comment|/* This function reads a source file, looking for a given tag.  If it finds  * the tag, then it displays it and returns TRUE.  Otherwise it returns FALSE.  * To display the tag, it attempts to output any introductory comment, the  * tag line itself, and any arguments.  Arguments are assumed to immediately  * follow the tag line, and start with whitespace.  Comments are assumed to  * start with lines that begin with "/*", "//", "(*", or "--", and end at the  * tag line or at a blank line.  */
end_comment

begin_function
name|int
name|lookup
parameter_list|(
name|dir
parameter_list|,
name|entry
parameter_list|)
name|char
modifier|*
name|dir
decl_stmt|;
comment|/* name of the directory that contains the source */
name|char
modifier|*
name|entry
decl_stmt|;
comment|/* source filename,<Tab>, linespec */
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* basename of source file */
name|char
name|buf
index|[
name|BLKSIZE
index|]
decl_stmt|;
comment|/* pathname of source file */
name|long
name|lnum
decl_stmt|;
comment|/* desired line number */
name|long
name|thislnum
decl_stmt|;
comment|/* current line number */
name|long
name|here
decl_stmt|;
comment|/* seek position where current line began */
name|long
name|comment
decl_stmt|;
comment|/* seek position of introductory comment, or -1L */
name|FILE
modifier|*
name|sfile
decl_stmt|;
comment|/* used for reading the source file */
name|int
name|len
decl_stmt|;
comment|/* length of string */
name|int
name|noargs
init|=
literal|0
decl_stmt|;
comment|/* boolean: don't show lines after tag line? */
name|char
modifier|*
name|ptr
decl_stmt|;
comment|/* construct the pathname of the source file */
name|name
operator|=
name|entry
expr_stmt|;
name|strcpy
argument_list|(
name|buf
argument_list|,
name|dir
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|buf
operator|+
name|strlen
argument_list|(
name|buf
argument_list|)
expr_stmt|;
if|#
directive|if
name|AMIGA
if|if
condition|(
name|ptr
index|[
operator|-
literal|1
index|]
operator|!=
name|COLON
condition|)
endif|#
directive|endif
operator|*
name|ptr
operator|++
operator|=
name|SLASH
expr_stmt|;
while|while
condition|(
operator|*
name|entry
operator|!=
literal|'\t'
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
operator|*
name|entry
operator|++
expr_stmt|;
block|}
operator|*
name|entry
operator|++
operator|=
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* searching for string or number? */
if|if
condition|(
operator|*
name|entry
operator|>=
literal|'0'
operator|&&
operator|*
name|entry
operator|<=
literal|'9'
condition|)
block|{
comment|/* given a specific line number */
name|lnum
operator|=
name|atol
argument_list|(
name|entry
argument_list|)
expr_stmt|;
name|entry
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
name|noargs
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
comment|/* given a string -- strip off "/^" and "$/\n" */
name|entry
operator|+=
literal|2
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|entry
argument_list|)
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|entry
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|entry
index|[
name|len
operator|-
literal|1
index|]
operator|=
literal|'\n'
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strchr
argument_list|(
name|entry
argument_list|,
literal|'('
argument_list|)
condition|)
block|{
name|noargs
operator|=
literal|1
expr_stmt|;
block|}
name|lnum
operator|=
literal|0L
expr_stmt|;
block|}
comment|/* Open the file.  Note that we open the file in binary mode even 	 * though we know it is a text file, because ftell() and fseek() 	 * don't work on text files. 	 */
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|sfile
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|AMIGA
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
name|SLASH
condition|)
name|sfile
operator|=
name|fopen
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sfile
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sfile
condition|)
block|{
comment|/* can't open the real source file.  Try "refs" instead */
if|#
directive|if
name|AMIGA
if|if
condition|(
name|dir
index|[
name|strlen
argument_list|(
name|dir
argument_list|)
operator|-
literal|1
index|]
operator|==
name|COLON
condition|)
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%srefs"
argument_list|,
name|dir
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%s%crefs"
argument_list|,
name|dir
argument_list|,
name|SLASH
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|sfile
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"rb"
argument_list|)
expr_stmt|;
else|#
directive|else
if|#
directive|if
name|AMIGA
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
name|SLASH
condition|)
name|sfile
operator|=
name|fopen
argument_list|(
operator|&
name|buf
index|[
literal|2
index|]
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|sfile
operator|=
name|fopen
argument_list|(
name|buf
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|sfile
condition|)
block|{
comment|/* failed! */
return|return
literal|0
return|;
block|}
name|name
operator|=
literal|"refs"
expr_stmt|;
block|}
comment|/* search the file */
for|for
control|(
name|comment
operator|=
operator|-
literal|1L
operator|,
name|thislnum
operator|=
literal|0
init|;
name|here
operator|=
name|ftell
argument_list|(
name|sfile
argument_list|)
operator|,
name|thislnum
operator|++
operator|,
name|getline
argument_list|(
name|buf
argument_list|,
name|BLKSIZE
argument_list|,
name|sfile
argument_list|)
operator|>
literal|0
condition|;
control|)
block|{
comment|/* Is this the start/end of a comment? */
if|if
condition|(
name|comment
operator|==
operator|-
literal|1L
condition|)
block|{
comment|/* starting a comment? */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'*'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'/'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'('
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'*'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|buf
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
name|comment
operator|=
name|here
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* ending a comment? */
if|if
condition|(
name|buf
index|[
literal|0
index|]
operator|==
literal|'\n'
operator|||
name|buf
index|[
literal|0
index|]
operator|==
literal|'#'
condition|)
block|{
name|comment
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
block|}
comment|/* is this the tag line? */
if|if
condition|(
name|lnum
operator|==
name|thislnum
operator|||
operator|(
name|entry
operator|&&
operator|!
name|strncmp
argument_list|(
name|buf
argument_list|,
name|entry
argument_list|,
name|len
argument_list|)
operator|)
condition|)
block|{
comment|/* display the filename& line number where found */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
condition|)
name|printf
argument_list|(
literal|"%s%c%s, line %ld:\n"
argument_list|,
name|dir
argument_list|,
name|SLASH
argument_list|,
name|name
argument_list|,
name|thislnum
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%s, line %ld:\n"
argument_list|,
name|name
argument_list|,
name|thislnum
argument_list|)
expr_stmt|;
comment|/* if there were introductory comments, show them */
if|if
condition|(
name|comment
operator|!=
operator|-
literal|1L
condition|)
block|{
name|fseek
argument_list|(
name|sfile
argument_list|,
name|comment
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|comment
operator|!=
name|here
condition|)
block|{
name|getline
argument_list|(
name|buf
argument_list|,
name|BLKSIZE
argument_list|,
name|sfile
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
name|comment
operator|=
name|ftell
argument_list|(
name|sfile
argument_list|)
expr_stmt|;
block|}
comment|/* re-fetch the tag line */
name|fgets
argument_list|(
name|buf
argument_list|,
name|BLKSIZE
argument_list|,
name|sfile
argument_list|)
expr_stmt|;
block|}
comment|/* show the tag line */
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
comment|/* are we expected to show argument lines? */
if|if
condition|(
operator|!
name|noargs
condition|)
block|{
comment|/* show any argument lines */
while|while
condition|(
name|getline
argument_list|(
name|buf
argument_list|,
name|BLKSIZE
argument_list|,
name|sfile
argument_list|)
operator|>
literal|0
operator|&&
name|buf
index|[
literal|0
index|]
operator|!=
literal|'#'
operator|&&
name|strchr
argument_list|(
name|buf
argument_list|,
literal|'{'
argument_list|)
operator|==
operator|(
name|char
operator|*
operator|)
literal|0
condition|)
block|{
name|fputs
argument_list|(
name|buf
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Done!  Close the file, and return TRUE */
name|fclose
argument_list|(
name|sfile
argument_list|)
expr_stmt|;
return|return
literal|1
return|;
block|}
block|}
comment|/* not found -- return FALSE */
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function searches through the entire search path for a given tag.  * If it finds the tag, then it displays the info and returns TRUE;  * otherwise it returns FALSE.  */
end_comment

begin_function
name|int
name|find
parameter_list|(
name|tag
parameter_list|)
name|char
modifier|*
name|tag
decl_stmt|;
comment|/* the tag to look up */
block|{
name|char
modifier|*
name|tagpath
decl_stmt|;
name|char
name|dir
index|[
literal|80
index|]
decl_stmt|;
name|char
modifier|*
name|ptr
decl_stmt|;
name|int
name|len
decl_stmt|;
if|if
condition|(
name|colons
operator|==
literal|1
condition|)
block|{
comment|/* looking for static function -- only look in current dir */
name|tagpath
operator|=
literal|"."
expr_stmt|;
block|}
else|else
block|{
comment|/* get the tagpath from the environment.  Default to DEFTAGPATH */
name|tagpath
operator|=
name|getenv
argument_list|(
literal|"TAGPATH"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|tagpath
condition|)
block|{
name|tagpath
operator|=
name|DEFTAGPATH
expr_stmt|;
block|}
block|}
comment|/* for each entry in the path... */
while|while
condition|(
operator|*
name|tagpath
condition|)
block|{
comment|/* Copy the entry into the dir[] buffer */
for|for
control|(
name|ptr
operator|=
name|dir
init|;
operator|*
name|tagpath
operator|&&
operator|*
name|tagpath
operator|!=
name|SEP
condition|;
name|tagpath
operator|++
control|)
block|{
operator|*
name|ptr
operator|++
operator|=
operator|*
name|tagpath
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tagpath
operator|==
name|SEP
condition|)
block|{
name|tagpath
operator|++
expr_stmt|;
block|}
comment|/* if the entry ended with "/tags", then strip that off */
name|len
operator|=
name|strlen
argument_list|(
name|TAGS
argument_list|)
expr_stmt|;
if|if
condition|(
operator|&
name|dir
index|[
name|len
index|]
operator|<
name|ptr
operator|&&
name|ptr
index|[
operator|-
name|len
operator|-
literal|1
index|]
operator|==
name|SLASH
operator|&&
operator|!
name|strncmp
argument_list|(
operator|&
name|ptr
index|[
operator|-
name|len
index|]
argument_list|,
name|TAGS
argument_list|,
name|len
argument_list|)
condition|)
block|{
name|ptr
operator|-=
name|len
operator|+
literal|1
expr_stmt|;
block|}
comment|/* if the entry is now an empty string, then assume "." */
if|if
condition|(
name|ptr
operator|==
name|dir
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
literal|'.'
expr_stmt|;
block|}
operator|*
name|ptr
operator|=
literal|'\0'
expr_stmt|;
comment|/* look for the tag in this path.  If found, then display it 		 * and exit. 		 */
name|ptr
operator|=
name|cktagdir
argument_list|(
name|tag
argument_list|,
name|dir
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
condition|)
block|{
comment|/* just supposed to display tag info? */
if|if
condition|(
name|taginfo
condition|)
block|{
comment|/* then do only that! */
if|if
condition|(
name|strcmp
argument_list|(
name|dir
argument_list|,
literal|"."
argument_list|)
condition|)
block|{
name|printf
argument_list|(
literal|"%s%c%s"
argument_list|,
name|dir
argument_list|,
name|SLASH
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* avoid leading "./" if possible */
name|fputs
argument_list|(
name|ptr
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
block|}
return|return
literal|1
return|;
block|}
else|else
block|{
comment|/* else look up the declaration of the thing */
return|return
name|lookup
argument_list|(
name|dir
argument_list|,
name|ptr
argument_list|)
return|;
block|}
block|}
block|}
comment|/* if we get here, then the tag wasn't found anywhere */
return|return
literal|0
return|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fputs
argument_list|(
literal|"usage: ref [-t] [-c class] [-f file] tag\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"   -t        output tag info, instead of the function header\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"   -f File   tag might be a static function in File\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fputs
argument_list|(
literal|"   -c Class  tag might be a member of class Class\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|countcolons
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
while|while
condition|(
operator|*
name|str
operator|!=
literal|':'
operator|&&
operator|*
name|str
condition|)
block|{
name|str
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|':'
condition|)
block|{
return|return
literal|0
return|;
block|}
elseif|else
if|if
condition|(
name|str
index|[
literal|1
index|]
operator|!=
literal|':'
condition|)
block|{
return|return
literal|1
return|;
block|}
return|return
literal|2
return|;
block|}
end_function

begin_function
name|void
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|char
name|def_tag
index|[
literal|100
index|]
decl_stmt|;
comment|/* used to build tag name with default file/class */
name|int
name|i
decl_stmt|;
comment|/* parse flags */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
operator|&&
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|1
index|]
condition|)
block|{
case|case
literal|'t'
case|:
name|taginfo
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|def_file
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
block|{
name|def_file
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'c'
case|:
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
condition|)
block|{
name|def_class
operator|=
operator|&
name|argv
index|[
name|i
index|]
index|[
literal|2
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|++
name|i
operator|<
name|argc
condition|)
block|{
name|def_class
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* if no tag was given, complain */
if|if
condition|(
name|i
operator|+
literal|1
operator|!=
name|argc
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
comment|/* does the tag have an explicit class or file? */
name|colons
operator|=
name|countcolons
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* if not, then maybe try some defaults */
if|if
condition|(
name|colons
operator|==
literal|0
condition|)
block|{
comment|/* try a static function in the file first */
if|if
condition|(
name|def_file
condition|)
block|{
name|sprintf
argument_list|(
name|def_tag
argument_list|,
literal|"%s:%s"
argument_list|,
name|def_file
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|colons
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
name|def_tag
argument_list|)
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* try a member function for a class */
if|if
condition|(
name|def_class
condition|)
block|{
name|sprintf
argument_list|(
name|def_tag
argument_list|,
literal|"%s::%s"
argument_list|,
name|def_class
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|colons
operator|=
literal|2
expr_stmt|;
if|if
condition|(
name|find
argument_list|(
name|def_tag
argument_list|)
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* oh, well */
name|colons
operator|=
literal|0
expr_stmt|;
block|}
comment|/* find the tag */
if|if
condition|(
name|find
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
condition|)
block|{
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* Give up.  If doing tag lookup then exit(0), else exit(1) */
name|exit
argument_list|(
operator|!
name|taginfo
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

end_unit

