begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$OpenBSD: util.c,v 1.36 2007/10/02 17:59:18 otto Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 James Howard and Dag-Erling CoÃ¯dan SmÃ¸rgrav  * Copyright (C) 2008 Gabor Kovesdan<gabor@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*  * XXX: This file is a speed up for grep to cover the defects of the  * regex library.  These optimizations should practically be implemented  * there keeping this code clean.  This is a future TODO, but for the  * meantime, we need to use this workaround.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_function_decl
specifier|static
specifier|inline
name|int
name|grep_cmp
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|inline
name|void
name|grep_revstr
parameter_list|(
name|unsigned
name|char
modifier|*
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|fgrepcomp
parameter_list|(
name|fastgrep_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
comment|/* Initialize. */
name|fg
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|fg
operator|->
name|bol
operator|=
name|false
expr_stmt|;
name|fg
operator|->
name|eol
operator|=
name|false
expr_stmt|;
name|fg
operator|->
name|reversed
operator|=
name|false
expr_stmt|;
name|fg
operator|->
name|pattern
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|grep_strdup
argument_list|(
name|pat
argument_list|)
expr_stmt|;
comment|/* Preprocess pattern. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|UCHAR_MAX
condition|;
name|i
operator|++
control|)
name|fg
operator|->
name|qsBc
index|[
name|i
index|]
operator|=
name|fg
operator|->
name|len
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|fg
operator|->
name|len
condition|;
name|i
operator|++
control|)
name|fg
operator|->
name|qsBc
index|[
name|fg
operator|->
name|pattern
index|[
name|i
index|]
index|]
operator|=
name|fg
operator|->
name|len
operator|-
name|i
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns: -1 on failure, 0 on success  */
end_comment

begin_function
name|int
name|fastcomp
parameter_list|(
name|fastgrep_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|char
modifier|*
name|pat
parameter_list|)
block|{
name|unsigned
name|int
name|i
decl_stmt|;
name|int
name|firstHalfDot
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|firstLastHalfDot
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|hasDot
init|=
literal|0
decl_stmt|;
name|int
name|lastHalfDot
init|=
literal|0
decl_stmt|;
name|int
name|shiftPatternLen
decl_stmt|;
comment|/* Initialize. */
name|fg
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|fg
operator|->
name|bol
operator|=
name|false
expr_stmt|;
name|fg
operator|->
name|eol
operator|=
name|false
expr_stmt|;
name|fg
operator|->
name|reversed
operator|=
name|false
expr_stmt|;
name|fg
operator|->
name|word
operator|=
name|wflag
expr_stmt|;
comment|/* Remove end-of-line character ('$'). */
if|if
condition|(
name|fg
operator|->
name|len
operator|>
literal|0
operator|&&
name|pat
index|[
name|fg
operator|->
name|len
operator|-
literal|1
index|]
operator|==
literal|'$'
condition|)
block|{
name|fg
operator|->
name|eol
operator|=
name|true
expr_stmt|;
name|fg
operator|->
name|len
operator|--
expr_stmt|;
block|}
comment|/* Remove beginning-of-line character ('^'). */
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
literal|'^'
condition|)
block|{
name|fg
operator|->
name|bol
operator|=
name|true
expr_stmt|;
name|fg
operator|->
name|len
operator|--
expr_stmt|;
name|pat
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|fg
operator|->
name|len
operator|>=
literal|14
operator|&&
name|memcmp
argument_list|(
name|pat
argument_list|,
literal|"[[:<:]]"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
operator|&&
name|memcmp
argument_list|(
name|pat
operator|+
name|fg
operator|->
name|len
operator|-
literal|7
argument_list|,
literal|"[[:>:]]"
argument_list|,
literal|7
argument_list|)
operator|==
literal|0
condition|)
block|{
name|fg
operator|->
name|len
operator|-=
literal|14
expr_stmt|;
name|pat
operator|+=
literal|7
expr_stmt|;
comment|/* Word boundary is handled separately in util.c */
name|fg
operator|->
name|word
operator|=
name|true
expr_stmt|;
block|}
comment|/* 	 * Copy pattern minus '^' and '$' characters as well as word 	 * match character classes at the beginning and ending of the 	 * string respectively. 	 */
name|fg
operator|->
name|pattern
operator|=
name|grep_malloc
argument_list|(
name|fg
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|fg
operator|->
name|pattern
argument_list|,
name|pat
argument_list|,
name|fg
operator|->
name|len
argument_list|)
expr_stmt|;
name|fg
operator|->
name|pattern
index|[
name|fg
operator|->
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* Look for ways to cheat...er...avoid the full regex engine. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|fg
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
comment|/* Can still cheat? */
if|if
condition|(
name|fg
operator|->
name|pattern
index|[
name|i
index|]
operator|==
literal|'.'
condition|)
block|{
name|hasDot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|fg
operator|->
name|len
operator|/
literal|2
condition|)
block|{
if|if
condition|(
name|firstHalfDot
operator|<
literal|0
condition|)
comment|/* Closest dot to the beginning */
name|firstHalfDot
operator|=
name|i
expr_stmt|;
block|}
else|else
block|{
comment|/* Closest dot to the end of the pattern. */
name|lastHalfDot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|firstLastHalfDot
operator|<
literal|0
condition|)
name|firstLastHalfDot
operator|=
name|i
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* Free memory and let others know this is empty. */
name|free
argument_list|(
name|fg
operator|->
name|pattern
argument_list|)
expr_stmt|;
name|fg
operator|->
name|pattern
operator|=
name|NULL
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * Determine if a reverse search would be faster based on the placement 	 * of the dots. 	 */
if|if
condition|(
operator|(
operator|!
operator|(
name|lflag
operator|||
name|cflag
operator|)
operator|)
operator|&&
operator|(
operator|(
operator|!
operator|(
name|fg
operator|->
name|bol
operator|||
name|fg
operator|->
name|eol
operator|)
operator|)
operator|&&
operator|(
operator|(
name|lastHalfDot
operator|)
operator|&&
operator|(
operator|(
name|firstHalfDot
operator|<
literal|0
operator|)
operator|||
operator|(
operator|(
name|fg
operator|->
name|len
operator|-
operator|(
name|lastHalfDot
operator|+
literal|1
operator|)
operator|)
operator|<
operator|(
name|size_t
operator|)
name|firstHalfDot
operator|)
operator|)
operator|)
operator|)
operator|&&
operator|!
name|oflag
operator|&&
operator|!
name|color
condition|)
block|{
name|fg
operator|->
name|reversed
operator|=
name|true
expr_stmt|;
name|hasDot
operator|=
name|fg
operator|->
name|len
operator|-
operator|(
name|firstHalfDot
operator|<
literal|0
condition|?
name|firstLastHalfDot
else|:
name|firstHalfDot
operator|)
operator|-
literal|1
expr_stmt|;
name|grep_revstr
argument_list|(
name|fg
operator|->
name|pattern
argument_list|,
name|fg
operator|->
name|len
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Normal Quick Search would require a shift based on the position the 	 * next character after the comparison is within the pattern.  With 	 * wildcards, the position of the last dot effects the maximum shift 	 * distance. 	 * The closer to the end the wild card is the slower the search.  A 	 * reverse version of this algorithm would be useful for wildcards near 	 * the end of the string. 	 * 	 * Examples: 	 * Pattern	Max shift 	 * -------	--------- 	 * this		5 	 * .his		4 	 * t.is		3 	 * th.s		2 	 * thi.		1 	 */
comment|/* Adjust the shift based on location of the last dot ('.'). */
name|shiftPatternLen
operator|=
name|fg
operator|->
name|len
operator|-
name|hasDot
expr_stmt|;
comment|/* Preprocess pattern. */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
operator|(
name|signed
operator|)
name|UCHAR_MAX
condition|;
name|i
operator|++
control|)
name|fg
operator|->
name|qsBc
index|[
name|i
index|]
operator|=
name|shiftPatternLen
expr_stmt|;
for|for
control|(
name|i
operator|=
name|hasDot
operator|+
literal|1
init|;
name|i
operator|<
name|fg
operator|->
name|len
condition|;
name|i
operator|++
control|)
block|{
name|fg
operator|->
name|qsBc
index|[
name|fg
operator|->
name|pattern
index|[
name|i
index|]
index|]
operator|=
name|fg
operator|->
name|len
operator|-
name|i
expr_stmt|;
block|}
comment|/* 	 * Put pattern back to normal after pre-processing to allow for easy 	 * comparisons later. 	 */
if|if
condition|(
name|fg
operator|->
name|reversed
condition|)
name|grep_revstr
argument_list|(
name|fg
operator|->
name|pattern
argument_list|,
name|fg
operator|->
name|len
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|int
name|grep_search
parameter_list|(
name|fastgrep_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|regmatch_t
modifier|*
name|pmatch
parameter_list|)
block|{
name|unsigned
name|int
name|j
decl_stmt|;
name|int
name|ret
init|=
name|REG_NOMATCH
decl_stmt|;
if|if
condition|(
name|pmatch
operator|->
name|rm_so
operator|==
operator|(
name|ssize_t
operator|)
name|len
condition|)
return|return
operator|(
name|ret
operator|)
return|;
if|if
condition|(
name|fg
operator|->
name|bol
operator|&&
name|pmatch
operator|->
name|rm_so
operator|!=
literal|0
condition|)
block|{
name|pmatch
operator|->
name|rm_so
operator|=
name|len
expr_stmt|;
name|pmatch
operator|->
name|rm_eo
operator|=
name|len
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
comment|/* No point in going farther if we do not have enough data. */
if|if
condition|(
name|len
operator|<
name|fg
operator|->
name|len
condition|)
return|return
operator|(
name|ret
operator|)
return|;
comment|/* Only try once at the beginning or ending of the line. */
if|if
condition|(
name|fg
operator|->
name|bol
operator|||
name|fg
operator|->
name|eol
condition|)
block|{
comment|/* Simple text comparison. */
comment|/* Verify data is>= pattern length before searching on it. */
if|if
condition|(
name|len
operator|>=
name|fg
operator|->
name|len
condition|)
block|{
comment|/* Determine where in data to start search at. */
name|j
operator|=
name|fg
operator|->
name|eol
condition|?
name|len
operator|-
name|fg
operator|->
name|len
else|:
literal|0
expr_stmt|;
if|if
condition|(
operator|!
operator|(
operator|(
name|fg
operator|->
name|bol
operator|&&
name|fg
operator|->
name|eol
operator|)
operator|&&
operator|(
name|len
operator|!=
name|fg
operator|->
name|len
operator|)
operator|)
condition|)
if|if
condition|(
name|grep_cmp
argument_list|(
name|fg
operator|->
name|pattern
argument_list|,
name|data
operator|+
name|j
argument_list|,
name|fg
operator|->
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pmatch
operator|->
name|rm_so
operator|=
name|j
expr_stmt|;
name|pmatch
operator|->
name|rm_eo
operator|=
name|j
operator|+
name|fg
operator|->
name|len
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|fg
operator|->
name|reversed
condition|)
block|{
comment|/* Quick Search algorithm. */
name|j
operator|=
name|len
expr_stmt|;
do|do
block|{
if|if
condition|(
name|grep_cmp
argument_list|(
name|fg
operator|->
name|pattern
argument_list|,
name|data
operator|+
name|j
operator|-
name|fg
operator|->
name|len
argument_list|,
name|fg
operator|->
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pmatch
operator|->
name|rm_so
operator|=
name|j
operator|-
name|fg
operator|->
name|len
expr_stmt|;
name|pmatch
operator|->
name|rm_eo
operator|=
name|j
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Shift if within bounds, otherwise, we are done. */
if|if
condition|(
name|j
operator|==
name|fg
operator|->
name|len
condition|)
break|break;
name|j
operator|-=
name|fg
operator|->
name|qsBc
index|[
name|data
index|[
name|j
operator|-
name|fg
operator|->
name|len
operator|-
literal|1
index|]
index|]
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|>=
name|fg
operator|->
name|len
condition|)
do|;
block|}
else|else
block|{
comment|/* Quick Search algorithm. */
name|j
operator|=
name|pmatch
operator|->
name|rm_so
expr_stmt|;
do|do
block|{
if|if
condition|(
name|grep_cmp
argument_list|(
name|fg
operator|->
name|pattern
argument_list|,
name|data
operator|+
name|j
argument_list|,
name|fg
operator|->
name|len
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|pmatch
operator|->
name|rm_so
operator|=
name|j
expr_stmt|;
name|pmatch
operator|->
name|rm_eo
operator|=
name|j
operator|+
name|fg
operator|->
name|len
expr_stmt|;
name|ret
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* Shift if within bounds, otherwise, we are done. */
if|if
condition|(
name|j
operator|+
name|fg
operator|->
name|len
operator|==
name|len
condition|)
break|break;
else|else
name|j
operator|+=
name|fg
operator|->
name|qsBc
index|[
name|data
index|[
name|j
operator|+
name|fg
operator|->
name|len
index|]
index|]
expr_stmt|;
block|}
do|while
condition|(
name|j
operator|<=
operator|(
name|len
operator|-
name|fg
operator|->
name|len
operator|)
condition|)
do|;
block|}
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Returns:	i>= 0 on failure (position that it failed)  *		-1 on success  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|grep_cmp
parameter_list|(
specifier|const
name|unsigned
name|char
modifier|*
name|pat
parameter_list|,
specifier|const
name|unsigned
name|char
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|size
decl_stmt|;
name|wchar_t
modifier|*
name|wdata
decl_stmt|,
modifier|*
name|wpat
decl_stmt|;
name|unsigned
name|int
name|i
decl_stmt|;
if|if
condition|(
name|iflag
condition|)
block|{
if|if
condition|(
operator|(
name|size
operator|=
name|mbstowcs
argument_list|(
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wdata
operator|=
name|grep_malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|wint_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbstowcs
argument_list|(
name|wdata
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|data
argument_list|,
name|size
argument_list|)
operator|==
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
if|if
condition|(
operator|(
name|size
operator|=
name|mbstowcs
argument_list|(
name|NULL
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|pat
argument_list|,
literal|0
argument_list|)
operator|)
operator|==
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|wpat
operator|=
name|grep_malloc
argument_list|(
name|size
operator|*
sizeof|sizeof
argument_list|(
name|wint_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|mbstowcs
argument_list|(
name|wpat
argument_list|,
operator|(
specifier|const
name|char
operator|*
operator|)
name|pat
argument_list|,
name|size
argument_list|)
operator|==
operator|(
operator|(
name|size_t
operator|)
operator|-
literal|1
operator|)
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|towlower
argument_list|(
name|wpat
index|[
name|i
index|]
argument_list|)
operator|==
name|towlower
argument_list|(
name|wdata
index|[
name|i
index|]
argument_list|)
operator|)
operator|||
operator|(
operator|(
name|grepbehave
operator|!=
name|GREP_FIXED
operator|)
operator|&&
name|wpat
index|[
name|i
index|]
operator|==
literal|L'
expr|.'
operator|)
condition|)
continue|continue;
name|free
argument_list|(
name|wpat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|wdata
argument_list|)
expr_stmt|;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|pat
index|[
name|i
index|]
operator|==
name|data
index|[
name|i
index|]
operator|)
operator|||
operator|(
operator|(
name|grepbehave
operator|!=
name|GREP_FIXED
operator|)
operator|&&
name|pat
index|[
name|i
index|]
operator|==
literal|'.'
operator|)
condition|)
continue|continue;
return|return
operator|(
name|i
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|inline
name|void
name|grep_revstr
parameter_list|(
name|unsigned
name|char
modifier|*
name|str
parameter_list|,
name|int
name|len
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|char
name|c
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
operator|/
literal|2
condition|;
name|i
operator|++
control|)
block|{
name|c
operator|=
name|str
index|[
name|i
index|]
expr_stmt|;
name|str
index|[
name|i
index|]
operator|=
name|str
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
expr_stmt|;
name|str
index|[
name|len
operator|-
name|i
operator|-
literal|1
index|]
operator|=
name|c
expr_stmt|;
block|}
block|}
end_function

end_unit

