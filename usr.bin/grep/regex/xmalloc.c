begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*   xmalloc.c - Simple malloc debugging library implementation    This software is released under a BSD-style license.   See the file LICENSE for details and copyright.  */
end_comment

begin_comment
comment|/*   TODO:    - red zones    - group dumps by source location */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<assert.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_define
define|#
directive|define
name|XMALLOC_INTERNAL
value|1
end_define

begin_include
include|#
directive|include
file|"xmalloc.h"
end_include

begin_escape
end_escape

begin_comment
comment|/*   Internal stuff. */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|hashTableItemRec
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|int
name|bytes
decl_stmt|;
specifier|const
name|char
modifier|*
name|file
decl_stmt|;
name|int
name|line
decl_stmt|;
specifier|const
name|char
modifier|*
name|func
decl_stmt|;
name|struct
name|hashTableItemRec
modifier|*
name|next
decl_stmt|;
block|}
name|hashTableItem
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|hashTableItem
modifier|*
modifier|*
name|table
decl_stmt|;
block|}
name|hashTable
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|xmalloc_peak
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xmalloc_current
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xmalloc_peak_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xmalloc_current_blocks
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|xmalloc_fail_after
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|TABLE_BITS
value|8
end_define

begin_define
define|#
directive|define
name|TABLE_MASK
value|((1<< TABLE_BITS) - 1)
end_define

begin_define
define|#
directive|define
name|TABLE_SIZE
value|(1<< TABLE_BITS)
end_define

begin_function
specifier|static
name|hashTable
modifier|*
name|hash_table_new
parameter_list|(
name|void
parameter_list|)
block|{
name|hashTable
modifier|*
name|tbl
decl_stmt|;
name|tbl
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|tbl
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
operator|!=
name|NULL
condition|)
block|{
name|tbl
operator|->
name|table
operator|=
name|calloc
argument_list|(
name|TABLE_SIZE
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|tbl
operator|->
name|table
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tbl
operator|->
name|table
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|tbl
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
block|}
return|return
name|tbl
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|hash_void_ptr
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|hash
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* I took this hash function just off the top of my head, I have      no idea whether it is bad or very bad. */
name|hash
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
operator|(
name|int
operator|)
sizeof|sizeof
argument_list|(
name|ptr
argument_list|)
operator|*
literal|8
operator|/
name|TABLE_BITS
condition|;
name|i
operator|++
control|)
block|{
name|hash
operator|^=
operator|(
name|unsigned
name|long
operator|)
name|ptr
operator|>>
name|i
operator|*
literal|8
expr_stmt|;
name|hash
operator|+=
name|i
operator|*
literal|17
expr_stmt|;
name|hash
operator|&=
name|TABLE_MASK
expr_stmt|;
block|}
return|return
name|hash
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_table_add
parameter_list|(
name|hashTable
modifier|*
name|tbl
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|int
name|bytes
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|hashTableItem
modifier|*
name|item
decl_stmt|,
modifier|*
name|new
decl_stmt|;
name|i
operator|=
name|hash_void_ptr
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|item
operator|=
name|tbl
operator|->
name|table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
while|while
condition|(
name|item
operator|->
name|next
operator|!=
name|NULL
condition|)
name|item
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|new
operator|=
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
operator|*
name|new
argument_list|)
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|new
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|new
operator|->
name|ptr
operator|=
name|ptr
expr_stmt|;
name|new
operator|->
name|bytes
operator|=
name|bytes
expr_stmt|;
name|new
operator|->
name|file
operator|=
name|file
expr_stmt|;
name|new
operator|->
name|line
operator|=
name|line
expr_stmt|;
name|new
operator|->
name|func
operator|=
name|func
expr_stmt|;
name|new
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|item
operator|!=
name|NULL
condition|)
name|item
operator|->
name|next
operator|=
name|new
expr_stmt|;
else|else
name|tbl
operator|->
name|table
index|[
name|i
index|]
operator|=
name|new
expr_stmt|;
name|xmalloc_current
operator|+=
name|bytes
expr_stmt|;
if|if
condition|(
name|xmalloc_current
operator|>
name|xmalloc_peak
condition|)
name|xmalloc_peak
operator|=
name|xmalloc_current
expr_stmt|;
name|xmalloc_current_blocks
operator|++
expr_stmt|;
if|if
condition|(
name|xmalloc_current_blocks
operator|>
name|xmalloc_peak_blocks
condition|)
name|xmalloc_peak_blocks
operator|=
name|xmalloc_current_blocks
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|hash_table_del
parameter_list|(
name|hashTable
modifier|*
name|tbl
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|hashTableItem
modifier|*
name|item
decl_stmt|,
modifier|*
name|prev
decl_stmt|;
name|i
operator|=
name|hash_void_ptr
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
name|item
operator|=
name|tbl
operator|->
name|table
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|item
operator|==
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"xfree: invalid ptr %p\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|prev
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
name|item
operator|->
name|ptr
operator|!=
name|ptr
condition|)
block|{
name|prev
operator|=
name|item
expr_stmt|;
name|item
operator|=
name|item
operator|->
name|next
expr_stmt|;
block|}
if|if
condition|(
name|item
operator|->
name|ptr
operator|!=
name|ptr
condition|)
block|{
name|printf
argument_list|(
literal|"xfree: invalid ptr %p\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
name|xmalloc_current
operator|-=
name|item
operator|->
name|bytes
expr_stmt|;
name|xmalloc_current_blocks
operator|--
expr_stmt|;
if|if
condition|(
name|prev
operator|!=
name|NULL
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tbl
operator|->
name|table
index|[
name|i
index|]
operator|=
name|item
operator|->
name|next
expr_stmt|;
name|free
argument_list|(
name|item
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|hashTable
modifier|*
name|xmalloc_table
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|xmalloc_init
parameter_list|(
name|void
parameter_list|)
block|{
if|if
condition|(
name|xmalloc_table
operator|==
name|NULL
condition|)
block|{
name|xmalloc_table
operator|=
name|hash_table_new
argument_list|()
expr_stmt|;
name|xmalloc_peak
operator|=
literal|0
expr_stmt|;
name|xmalloc_peak_blocks
operator|=
literal|0
expr_stmt|;
name|xmalloc_current
operator|=
literal|0
expr_stmt|;
name|xmalloc_current_blocks
operator|=
literal|0
expr_stmt|;
name|xmalloc_fail_after
operator|=
operator|-
literal|1
expr_stmt|;
block|}
name|assert
argument_list|(
name|xmalloc_table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|xmalloc_table
operator|->
name|table
operator|!=
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_escape
end_escape

begin_comment
comment|/*   Public API. */
end_comment

begin_function
name|void
name|xmalloc_configure
parameter_list|(
name|int
name|fail_after
parameter_list|)
block|{
name|xmalloc_init
argument_list|()
expr_stmt|;
name|xmalloc_fail_after
operator|=
name|fail_after
expr_stmt|;
block|}
end_function

begin_function
name|int
name|xmalloc_dump_leaks
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|num_leaks
init|=
literal|0
decl_stmt|;
name|int
name|leaked_bytes
init|=
literal|0
decl_stmt|;
name|hashTableItem
modifier|*
name|item
decl_stmt|;
name|xmalloc_init
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|TABLE_SIZE
condition|;
name|i
operator|++
control|)
block|{
name|item
operator|=
name|xmalloc_table
operator|->
name|table
index|[
name|i
index|]
expr_stmt|;
while|while
condition|(
name|item
operator|!=
name|NULL
condition|)
block|{
name|printf
argument_list|(
literal|"%s:%d: %s: %d bytes at %p not freed\n"
argument_list|,
name|item
operator|->
name|file
argument_list|,
name|item
operator|->
name|line
argument_list|,
name|item
operator|->
name|func
argument_list|,
name|item
operator|->
name|bytes
argument_list|,
name|item
operator|->
name|ptr
argument_list|)
expr_stmt|;
name|num_leaks
operator|++
expr_stmt|;
name|leaked_bytes
operator|+=
name|item
operator|->
name|bytes
expr_stmt|;
name|item
operator|=
name|item
operator|->
name|next
expr_stmt|;
block|}
block|}
if|if
condition|(
name|num_leaks
operator|==
literal|0
condition|)
name|printf
argument_list|(
literal|"No memory leaks.\n"
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"%d unfreed memory chuncks, total %d unfreed bytes.\n"
argument_list|,
name|num_leaks
argument_list|,
name|leaked_bytes
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"Peak memory consumption %d bytes (%.1f kB, %.1f MB) in %d blocks "
argument_list|,
name|xmalloc_peak
argument_list|,
operator|(
name|double
operator|)
name|xmalloc_peak
operator|/
literal|1024
argument_list|,
operator|(
name|double
operator|)
name|xmalloc_peak
operator|/
operator|(
literal|1024
operator|*
literal|1024
operator|)
argument_list|,
name|xmalloc_peak_blocks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(average "
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmalloc_peak_blocks
condition|)
name|printf
argument_list|(
literal|"%d"
argument_list|,
operator|(
operator|(
name|xmalloc_peak
operator|+
name|xmalloc_peak_blocks
operator|/
literal|2
operator|)
operator|/
name|xmalloc_peak_blocks
operator|)
argument_list|)
expr_stmt|;
else|else
name|printf
argument_list|(
literal|"N/A"
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|" bytes per block).\n"
argument_list|)
expr_stmt|;
return|return
name|num_leaks
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|xmalloc_impl
parameter_list|(
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|xmalloc_init
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmalloc_fail_after
operator|==
literal|0
condition|)
block|{
name|xmalloc_fail_after
operator|=
operator|-
literal|2
expr_stmt|;
if|#
directive|if
literal|0
block|printf("xmalloc: forced failure %s:%d: %s\n", file, line, func);
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|xmalloc_fail_after
operator|==
operator|-
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"xmalloc: called after failure from %s:%d: %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xmalloc_fail_after
operator|>
literal|0
condition|)
name|xmalloc_fail_after
operator|--
expr_stmt|;
name|ptr
operator|=
name|malloc
argument_list|(
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|hash_table_add
argument_list|(
name|xmalloc_table
argument_list|,
name|ptr
argument_list|,
operator|(
name|int
operator|)
name|size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
modifier|*
name|xcalloc_impl
parameter_list|(
name|size_t
name|nmemb
parameter_list|,
name|size_t
name|size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|void
modifier|*
name|ptr
decl_stmt|;
name|xmalloc_init
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmalloc_fail_after
operator|==
literal|0
condition|)
block|{
name|xmalloc_fail_after
operator|=
operator|-
literal|2
expr_stmt|;
if|#
directive|if
literal|0
block|printf("xcalloc: forced failure %s:%d: %s\n", file, line, func);
endif|#
directive|endif
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|xmalloc_fail_after
operator|==
operator|-
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"xcalloc: called after failure from %s:%d: %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xmalloc_fail_after
operator|>
literal|0
condition|)
name|xmalloc_fail_after
operator|--
expr_stmt|;
name|ptr
operator|=
name|calloc
argument_list|(
name|nmemb
argument_list|,
name|size
argument_list|)
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|hash_table_add
argument_list|(
name|xmalloc_table
argument_list|,
name|ptr
argument_list|,
call|(
name|int
call|)
argument_list|(
name|nmemb
operator|*
name|size
argument_list|)
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
return|return
name|ptr
return|;
block|}
end_function

begin_function
name|void
name|xfree_impl
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
comment|/*LINTED*/
operator|(
name|void
operator|)
operator|&
name|file
expr_stmt|;
comment|/*LINTED*/
operator|(
name|void
operator|)
operator|&
name|line
expr_stmt|;
comment|/*LINTED*/
operator|(
name|void
operator|)
operator|&
name|func
expr_stmt|;
name|xmalloc_init
argument_list|()
expr_stmt|;
if|if
condition|(
name|ptr
operator|!=
name|NULL
condition|)
name|hash_table_del
argument_list|(
name|xmalloc_table
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|ptr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
modifier|*
name|xrealloc_impl
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|new_size
parameter_list|,
specifier|const
name|char
modifier|*
name|file
parameter_list|,
name|int
name|line
parameter_list|,
specifier|const
name|char
modifier|*
name|func
parameter_list|)
block|{
name|void
modifier|*
name|new_ptr
decl_stmt|;
name|xmalloc_init
argument_list|()
expr_stmt|;
name|assert
argument_list|(
name|ptr
operator|!=
name|NULL
argument_list|)
expr_stmt|;
name|assert
argument_list|(
name|new_size
operator|>
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|xmalloc_fail_after
operator|==
literal|0
condition|)
block|{
name|xmalloc_fail_after
operator|=
operator|-
literal|2
expr_stmt|;
return|return
name|NULL
return|;
block|}
elseif|else
if|if
condition|(
name|xmalloc_fail_after
operator|==
operator|-
literal|2
condition|)
block|{
name|printf
argument_list|(
literal|"xrealloc: called after failure from %s:%d: %s\n"
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
name|assert
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|xmalloc_fail_after
operator|>
literal|0
condition|)
name|xmalloc_fail_after
operator|--
expr_stmt|;
name|new_ptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|new_size
argument_list|)
expr_stmt|;
if|if
condition|(
name|new_ptr
operator|!=
name|NULL
condition|)
block|{
name|hash_table_del
argument_list|(
name|xmalloc_table
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
name|hash_table_add
argument_list|(
name|xmalloc_table
argument_list|,
name|new_ptr
argument_list|,
operator|(
name|int
operator|)
name|new_size
argument_list|,
name|file
argument_list|,
name|line
argument_list|,
name|func
argument_list|)
expr_stmt|;
block|}
return|return
name|new_ptr
return|;
block|}
end_function

begin_comment
comment|/* EOF */
end_comment

end_unit

