begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 James Howard and Dag-Erling CoÃ¯dan SmÃ¸rgrav  * Copyright (C) 2008-2011 Gabor Kovesdan<gabor@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|"glue.h"
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<regex.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|TRE_WCHAR
end_ifdef

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"hashtable.h"
end_include

begin_include
include|#
directive|include
file|"tre-fastmatch.h"
end_include

begin_function_decl
specifier|static
name|int
name|fastcmp
parameter_list|(
specifier|const
name|fastmatch_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|tre_str_type_t
name|type
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Clean up if pattern compilation fails.  */
end_comment

begin_define
define|#
directive|define
name|FAIL_COMP
parameter_list|(
name|errcode
parameter_list|)
define|\
value|{									\     if (fg->pattern)							\       free(fg->pattern);						\     if (fg->wpattern)							\       free(fg->wpattern);						\     if (fg->qsBc_table)							\       hashtable_free(fg->qsBc_table);					\     fg = NULL;								\     return errcode;							\   }
end_define

begin_comment
comment|/*  * Skips n characters in the input string and assigns the start  * address to startptr. Note: as per IEEE Std 1003.1-2008  * matching is based on bit pattern not character representations  * so we can handle MB strings as byte sequences just like  * SB strings.  */
end_comment

begin_define
define|#
directive|define
name|SKIP_CHARS
parameter_list|(
name|n
parameter_list|)
define|\
value|switch (type)								\     {									\       case STR_WIDE:							\ 	startptr = str_wide + n;					\ 	break;								\       default:								\ 	startptr = str_byte + n;					\     }
end_define

begin_comment
comment|/*  * Converts the wide string pattern to SB/MB string and stores  * it in fg->pattern. Sets fg->len to the byte length of the  * converted string.  */
end_comment

begin_define
define|#
directive|define
name|STORE_MBS_PAT
define|\
value|{									\     size_t siz;								\ 									\     siz = wcstombs(NULL, fg->wpattern, 0);				\     if (siz == (size_t)-1)						\       return REG_BADPAT;						\     fg->len = siz;							\     fg->pattern = malloc(siz + 1);					\     if (fg->pattern == NULL)						\       return REG_ESPACE;						\     wcstombs(fg->pattern, fg->wpattern, siz);				\     fg->pattern[siz] = '\0';						\   }									\  #define CONV_MBS_PAT(src, dest, destsz)					\   {									\     destsz = wcstombs(NULL, src, 0);					\     if (destsz == (size_t)-1)						\       return REG_BADPAT;						\     dest = malloc(destsz + 1);						\     if (dest == NULL)							\       return REG_ESPACE;						\     wcstombs(dest, src, destsz);					\     dest[destsz] = '\0';						\   }									\  #define IS_OUT_OF_BOUNDS						\   ((!fg->reversed							\     ? ((type == STR_WIDE) ? ((j + fg->wlen)> len)			\ 			  : ((j + fg->len)> len))			\     : (j< 0)))
end_define

begin_comment
comment|/*  * Checks whether the new position after shifting in the input string  * is out of the bounds and break out from the loop if so.  */
end_comment

begin_define
define|#
directive|define
name|CHECKBOUNDS
define|\
value|if (IS_OUT_OF_BOUNDS)							\     break;
end_define

begin_comment
unit|\
comment|/*  * Shifts in the input string after a mismatch. The position of the  * mismatch is stored in the mismatch variable.  */
end_comment

begin_define
define|#
directive|define
name|SHIFT
define|\
value|CHECKBOUNDS;								\ 									\   {									\     int r = -1;								\     unsigned int bc = 0, gs = 0, ts;					\ 									\     switch (type)							\       {									\ 	case STR_WIDE:							\ 	  if (!fg->hasdot)						\ 	    {								\ 	      if (u != 0&& (unsigned)mismatch == fg->wlen - 1 - shift)	\ 		mismatch -= u;						\ 	      v = fg->wlen - 1 - mismatch;				\ 	      r = hashtable_get(fg->qsBc_table,				\&str_wide[!fg->reversed ? (size_t)j + fg->wlen		\ 			  : (size_t)j - 1],&bc);			\ 	      gs = fg->bmGs[mismatch];					\ 	    }								\ 	    bc = (r == HASH_OK) ? bc : fg->defBc;			\ 	    DPRINT(("tre_fast_match: mismatch on character" CHF ", "	\ 		    "BC %d, GS %d\n",					\ 		    ((const tre_char_t *)startptr)[mismatch + 1],	\ 		    bc, gs));						\             break;							\ 	default:							\ 	  if (!fg->hasdot)						\ 	    {								\ 	      if (u != 0&& (unsigned)mismatch == fg->len - 1 - shift)	\ 		mismatch -= u;						\ 	      v = fg->len - 1 - mismatch;				\ 	      gs = fg->sbmGs[mismatch];					\ 	    }								\ 	  bc = fg->qsBc[((const unsigned char *)str_byte)		\ 			[!fg->reversed ? (size_t)j + fg->len		\ 			 : (size_t)j - 1]];				\ 	  DPRINT(("tre_fast_match: mismatch on character %c, "		\ 		 "BC %d, GS %d\n",					\ 		 ((const unsigned char *)startptr)[mismatch + 1],	\ 		 bc, gs));						\       }									\     if (fg->hasdot)							\       shift = bc;							\     else								\       {									\ 	ts = (u>= v) ? (u - v) : 0;					\ 	shift = MAX(ts, bc);						\ 	shift = MAX(shift, gs);						\ 	if (shift == gs)						\ 	  u = MIN((type == STR_WIDE ? fg->wlen : fg->len) - shift, v);	\ 	else								\ 	  {								\ 	    if (ts< bc)						\ 	      shift = MAX(shift, u + 1);				\ 	    u = 0;							\ 	  }								\       }									\       DPRINT(("tre_fast_match: shifting %u characters\n", shift));	\       j = !fg->reversed ? j + shift : j - shift;			\   }
end_define

begin_comment
comment|/*  * Normal Quick Search would require a shift based on the position the  * next character after the comparison is within the pattern.  With  * wildcards, the position of the last dot effects the maximum shift  * distance.  * The closer to the end the wild card is the slower the search.  *  * Examples:  * Pattern    Max shift  * -------    ---------  * this               5  * .his               4  * t.is               3  * th.s               2  * thi.               1  */
end_comment

begin_comment
comment|/*  * Fills in the bad character shift array for SB/MB strings.  */
end_comment

begin_define
define|#
directive|define
name|FILL_QSBC
define|\
value|if (fg->reversed)							\     {									\       _FILL_QSBC_REVERSED						\     }									\   else									\     {									\       _FILL_QSBC							\     }
end_define

begin_define
define|#
directive|define
name|_FILL_QSBC
define|\
value|for (unsigned int i = 0; i<= UCHAR_MAX; i++)				\     fg->qsBc[i] = fg->len - hasdot;					\   for (unsigned int i = hasdot + 1; i< fg->len; i++)			\     {									\       fg->qsBc[(unsigned char)fg->pattern[i]] = fg->len - i;		\       DPRINT(("BC shift for char %c is %zu\n", fg->pattern[i],		\ 	     fg->len - i));						\       if (fg->icase)							\ 	{								\ 	  char c = islower((unsigned char)fg->pattern[i]) ?		\ 		   toupper((unsigned char)fg->pattern[i]) :		\ 		   tolower((unsigned char)fg->pattern[i]);		\ 	  fg->qsBc[(unsigned char)c] = fg->len - i;			\ 	  DPRINT(("BC shift for char %c is %zu\n", c, fg->len - i));	\ 	}								\     }
end_define

begin_define
define|#
directive|define
name|_FILL_QSBC_REVERSED
define|\
value|for (unsigned int i = 0; i<= UCHAR_MAX; i++)				\     fg->qsBc[i] = firstdot + 1;						\   for (int i = firstdot - 1; i>= 0; i--)				\     {									\       fg->qsBc[(unsigned char)fg->pattern[i]] = i + 1;			\       DPRINT(("Reverse BC shift for char %c is %d\n", fg->pattern[i],	\ 	     i + 1));							\       if (fg->icase)							\         {								\           char c = islower((unsigned char)fg->pattern[i]) ?		\ 		   toupper((unsigned char)fg->pattern[i]) :		\ 		   tolower((unsigned char)fg->pattern[i]);		\           fg->qsBc[(unsigned char)c] = i + 1;				\ 	  DPRINT(("Reverse BC shift for char %c is %d\n", c, i + 1));	\         }								\     }
end_define

begin_comment
comment|/*  * Fills in the bad character shifts into a hastable for wide strings.  * With wide characters it is not possible any more to use a normal  * array because there are too many characters and we could not  * provide enough memory. Fortunately, we only have to store distinct  * values for so many characters as the number of distinct characters  * in the pattern, so we can store them in a hashtable and store a  * default shift value for the rest.  */
end_comment

begin_define
define|#
directive|define
name|FILL_QSBC_WIDE
define|\
value|if (fg->reversed)							\     {									\       _FILL_QSBC_WIDE_REVERSED						\     }									\   else									\     {									\       _FILL_QSBC_WIDE							\     }
end_define

begin_define
define|#
directive|define
name|_FILL_QSBC_WIDE
define|\
comment|/* Adjust the shift based on location of the last dot ('.'). */
define|\
value|fg->defBc = fg->wlen - whasdot;					\ 									\
comment|/* Preprocess pattern. */
value|\   fg->qsBc_table = hashtable_init(fg->wlen * (fg->icase ? 8 : 4),	\ 				  sizeof(tre_char_t), sizeof(int));	\   if (!fg->qsBc_table)							\     FAIL_COMP(REG_ESPACE);						\   for (unsigned int i = whasdot + 1; i< fg->wlen; i++)			\     {									\       int k = fg->wlen - i;						\       int r;								\ 									\       r = hashtable_put(fg->qsBc_table,&fg->wpattern[i],&k);		\       if ((r == HASH_FAIL) || (r == HASH_FULL))				\ 	FAIL_COMP(REG_ESPACE);						\       DPRINT(("BC shift for wide char " CHF " is %d\n", fg->wpattern[i],\ 	     k));							\       if (fg->icase)							\ 	{								\ 	  tre_char_t wc = iswlower(fg->wpattern[i]) ?			\ 	    towupper(fg->wpattern[i]) : towlower(fg->wpattern[i]);	\ 	  r = hashtable_put(fg->qsBc_table,&wc,&k);			\ 	  if ((r == HASH_FAIL) || (r == HASH_FULL))			\ 	    FAIL_COMP(REG_ESPACE);					\ 	  DPRINT(("BC shift for wide char " CHF " is %d\n", wc, k));	\ 	}								\     }
end_define

begin_define
define|#
directive|define
name|_FILL_QSBC_WIDE_REVERSED
define|\
comment|/* Adjust the shift based on location of the last dot ('.'). */
define|\
value|fg->defBc = (size_t)wfirstdot;					\ 									\
comment|/* Preprocess pattern. */
value|\   fg->qsBc_table = hashtable_init(fg->wlen * (fg->icase ? 8 : 4),	\ 				  sizeof(tre_char_t), sizeof(int));	\   if (!fg->qsBc_table)							\     FAIL_COMP(REG_ESPACE);						\   for (int i = wfirstdot - 1; i>= 0; i--)				\     {									\       int k = i + 1;							\       int r;								\ 									\       r = hashtable_put(fg->qsBc_table,&fg->wpattern[i],&k);		\       if ((r == HASH_FAIL) || (r == HASH_FULL))				\ 	FAIL_COMP(REG_ESPACE);						\       DPRINT(("Reverse BC shift for wide char " CHF " is %d\n",		\ 	     fg->wpattern[i], k));					\       if (fg->icase)							\ 	{								\ 	  tre_char_t wc = iswlower(fg->wpattern[i]) ?			\ 	    towupper(fg->wpattern[i]) : towlower(fg->wpattern[i]);	\ 	  r = hashtable_put(fg->qsBc_table,&wc,&k);			\ 	  if ((r == HASH_FAIL) || (r == HASH_FULL))			\ 	    FAIL_COMP(REG_ESPACE);					\ 	  DPRINT(("Reverse BC shift for wide char " CHF " is %d\n", wc,	\ 		 k));							\ 	}								\     }
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|_GREP_DEBUG
end_ifdef

begin_define
define|#
directive|define
name|DPRINT_BMGS
parameter_list|(
name|len
parameter_list|,
name|fmt_str
parameter_list|,
name|sh
parameter_list|)
define|\
value|for (unsigned int i = 0; i< len; i++)				\     DPRINT((fmt_str, i, sh[i]));
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|DPRINT_BMGS
parameter_list|(
name|len
parameter_list|,
name|fmt_str
parameter_list|,
name|sh
parameter_list|)
define|\
value|do { } while(
comment|/*CONSTCOND*/
value|0)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Fills in the good suffix table for SB/MB strings.  */
end_comment

begin_define
define|#
directive|define
name|FILL_BMGS
define|\
value|if (fg->len> 0&& !fg->hasdot)					\     {									\       fg->sbmGs = malloc(fg->len * sizeof(*fg->sbmGs));			\       if (!fg->sbmGs)							\ 	return REG_ESPACE;						\       if (fg->len == 1)							\ 	fg->sbmGs[0] = 1;						\       else								\ 	_FILL_BMGS(fg->sbmGs, fg->pattern, fg->len, false);		\       DPRINT_BMGS(fg->len, "GS shift for pos %d is %d\n", fg->sbmGs);	\     }
end_define

begin_comment
comment|/*  * Fills in the good suffix table for wide strings.  */
end_comment

begin_define
define|#
directive|define
name|FILL_BMGS_WIDE
define|\
value|if (fg->wlen> 0&& !fg->hasdot)					\     {									\       fg->bmGs = malloc(fg->wlen * sizeof(*fg->bmGs));			\       if (!fg->bmGs)							\ 	return REG_ESPACE;						\       if (fg->wlen == 1)						\ 	fg->bmGs[0] = 1;						\       else								\ 	_FILL_BMGS(fg->bmGs, fg->wpattern, fg->wlen, true);		\       DPRINT_BMGS(fg->wlen, "GS shift (wide) for pos %d is %d\n",	\ 		  fg->bmGs);						\     }
end_define

begin_define
define|#
directive|define
name|_FILL_BMGS
parameter_list|(
name|arr
parameter_list|,
name|pat
parameter_list|,
name|plen
parameter_list|,
name|wide
parameter_list|)
define|\
value|{									\     char *p;								\     tre_char_t *wp;							\ 									\     if (wide)								\       {									\ 	if (fg->icase)							\ 	  {								\ 	    wp = malloc(plen * sizeof(tre_char_t));			\ 	    if (wp == NULL)						\ 	      return REG_ESPACE;					\ 	    for (unsigned int i = 0; i< plen; i++)			\ 	      wp[i] = towlower(pat[i]);					\ 	    _CALC_BMGS(arr, wp, plen);					\ 	    free(wp);							\ 	  }								\ 	else								\ 	  _CALC_BMGS(arr, pat, plen);					\       }									\     else								\       {									\ 	if (fg->icase)							\ 	  {								\ 	    p = malloc(plen);						\ 	    if (p == NULL)						\ 	      return REG_ESPACE;					\ 	    for (unsigned int i = 0; i< plen; i++)			\ 	      p[i] = tolower((unsigned char)pat[i]);                    \ 	    _CALC_BMGS(arr, p, plen);					\ 	    free(p);							\ 	  }								\ 	else								\ 	  _CALC_BMGS(arr, pat, plen);					\       }									\   }
end_define

begin_define
define|#
directive|define
name|_CALC_BMGS
parameter_list|(
name|arr
parameter_list|,
name|pat
parameter_list|,
name|plen
parameter_list|)
define|\
value|{									\     int f = 0, g;							\ 									\     int *suff = malloc(plen * sizeof(int));				\     if (suff == NULL)							\       return REG_ESPACE;						\ 									\     suff[plen - 1] = plen;						\     g = plen - 1;							\     for (int i = plen - 2; i>= 0; i--)					\       {									\ 	if (i> g&& suff[i + plen - 1 - f]< i - g)			\ 	  suff[i] = suff[i + plen - 1 - f];				\ 	else								\ 	  {								\ 	    if (i< g)							\ 	      g = i;							\ 	    f = i;							\ 	    while (g>= 0&& pat[g] == pat[g + plen - 1 - f])		\ 	      g--;							\ 	    suff[i] = f - g;						\ 	  }								\       }									\ 									\     for (unsigned int i = 0; i< plen; i++)				\       arr[i] = plen;							\     g = 0;								\     for (int i = plen - 1; i>= 0; i--)					\       if (suff[i] == i + 1)						\ 	for(; (unsigned long)g< plen - 1 - i; g++)			\ 	  if (arr[g] == plen)						\ 	    arr[g] = plen - 1 - i;					\     for (unsigned int i = 0; i<= plen - 2; i++)			\       arr[plen - 1 - suff[i]] = plen - 1 - i;				\ 									\     free(suff);							\   }
end_define

begin_comment
comment|/*  * Copies the pattern pat having length n to p and stores  * the size in l.  */
end_comment

begin_define
define|#
directive|define
name|SAVE_PATTERN
parameter_list|(
name|src
parameter_list|,
name|srclen
parameter_list|,
name|dst
parameter_list|,
name|dstlen
parameter_list|)
define|\
value|dstlen = srclen;							\   dst = malloc((dstlen + 1) * sizeof(tre_char_t));			\   if (dst == NULL)							\     return REG_ESPACE;							\   if (dstlen> 0)							\     memcpy(dst, src, dstlen * sizeof(tre_char_t));			\   dst[dstlen] = TRE_CHAR('\0');
end_define

begin_comment
comment|/*  * Initializes pattern compiling.  */
end_comment

begin_define
define|#
directive|define
name|INIT_COMP
define|\
comment|/* Initialize. */
define|\
value|memset(fg, 0, sizeof(*fg));						\   fg->icase = (cflags& REG_ICASE);					\   fg->word = (cflags& REG_WORD);					\   fg->newline = (cflags& REG_NEWLINE);					\   fg->nosub = (cflags& REG_NOSUB);					\ 									\
comment|/* Cannot handle REG_ICASE with MB string */
value|\   if (fg->icase&& (TRE_MB_CUR_MAX> 1)&& n> 0)			\     {									\       DPRINT(("Cannot use fast matcher for MBS with REG_ICASE\n"));	\       return REG_BADPAT;						\     }
end_define

begin_comment
comment|/*  * Checks whether we have a 0-length pattern that will match  * anything. If literal is set to false, the EOL anchor is also  * taken into account.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_MATCHALL
parameter_list|(
name|literal
parameter_list|)
define|\
value|if (!literal&& n == 1&& pat[0] == TRE_CHAR('$'))			\     {									\       n--;								\       fg->eol = true;							\     }									\ 									\   if (n == 0)								\     {									\       fg->matchall = true;						\       fg->pattern = malloc(sizeof(char));				\       if (!fg->pattern)							\ 	FAIL_COMP(REG_ESPACE);						\       fg->pattern[0] = '\0';						\       fg->wpattern = malloc(sizeof(tre_char_t));			\       if (!fg->wpattern)						\ 	FAIL_COMP(REG_ESPACE);						\       fg->wpattern[0] = TRE_CHAR('\0');					\       DPRINT(("Matching every input\n"));				\       return REG_OK;							\     }
end_define

begin_comment
comment|/*  * Returns: REG_OK on success, error code otherwise  */
end_comment

begin_function
name|int
name|tre_compile_literal
parameter_list|(
name|fastmatch_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|tre_char_t
modifier|*
name|pat
parameter_list|,
name|size_t
name|n
parameter_list|,
name|int
name|cflags
parameter_list|)
block|{
name|size_t
name|hasdot
init|=
literal|0
decl_stmt|,
name|whasdot
init|=
literal|0
decl_stmt|;
name|ssize_t
name|firstdot
init|=
operator|-
literal|1
decl_stmt|,
name|wfirstdot
init|=
operator|-
literal|1
decl_stmt|;
name|INIT_COMP
expr_stmt|;
name|CHECK_MATCHALL
argument_list|(
name|true
argument_list|)
expr_stmt|;
comment|/* Cannot handle word boundaries with MB string */
if|if
condition|(
name|fg
operator|->
name|word
operator|&&
operator|(
name|TRE_MB_CUR_MAX
operator|>
literal|1
operator|)
condition|)
return|return
name|REG_BADPAT
return|;
ifdef|#
directive|ifdef
name|TRE_WCHAR
name|SAVE_PATTERN
argument_list|(
name|pat
argument_list|,
name|n
argument_list|,
name|fg
operator|->
name|wpattern
argument_list|,
name|fg
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|STORE_MBS_PAT
expr_stmt|;
else|#
directive|else
name|SAVE_PATTERN
argument_list|(
name|pat
argument_list|,
name|n
argument_list|,
name|fg
operator|->
name|pattern
argument_list|,
name|fg
operator|->
name|len
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|DPRINT
argument_list|(
operator|(
literal|"tre_compile_literal: pattern: %s, len %zu, icase: %c, word: %c, "
literal|"newline %c\n"
operator|,
name|fg
operator|->
name|pattern
operator|,
name|fg
operator|->
name|len
operator|,
name|fg
operator|->
name|icase
condition|?
literal|'y'
else|:
literal|'n'
operator|,
name|fg
operator|->
name|word
condition|?
literal|'y'
else|:
literal|'n'
operator|,
name|fg
operator|->
name|newline
condition|?
literal|'y'
else|:
literal|'n'
operator|)
argument_list|)
expr_stmt|;
name|FILL_QSBC
expr_stmt|;
name|FILL_BMGS
expr_stmt|;
ifdef|#
directive|ifdef
name|TRE_WCHAR
name|FILL_QSBC_WIDE
expr_stmt|;
name|FILL_BMGS_WIDE
expr_stmt|;
endif|#
directive|endif
return|return
name|REG_OK
return|;
block|}
end_function

begin_comment
comment|/*  * Returns: REG_OK on success, error code otherwise  */
end_comment

begin_function
name|int
name|tre_compile_fast
parameter_list|(
name|fastmatch_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|tre_char_t
modifier|*
name|pat
parameter_list|,
name|size_t
name|n
parameter_list|,
name|int
name|cflags
parameter_list|)
block|{
name|tre_char_t
modifier|*
name|tmp
decl_stmt|;
name|size_t
name|pos
init|=
literal|0
decl_stmt|,
name|hasdot
init|=
literal|0
decl_stmt|,
name|whasdot
init|=
literal|0
decl_stmt|;
name|ssize_t
name|firstdot
init|=
operator|-
literal|1
decl_stmt|,
name|wfirstdot
init|=
operator|-
literal|1
decl_stmt|;
name|bool
name|escaped
init|=
name|false
decl_stmt|;
name|bool
modifier|*
name|_escmap
init|=
name|NULL
decl_stmt|;
name|INIT_COMP
expr_stmt|;
comment|/* Remove beginning-of-line character ('^'). */
if|if
condition|(
name|pat
index|[
literal|0
index|]
operator|==
name|TRE_CHAR
argument_list|(
literal|'^'
argument_list|)
condition|)
block|{
name|fg
operator|->
name|bol
operator|=
name|true
expr_stmt|;
name|n
operator|--
expr_stmt|;
name|pat
operator|++
expr_stmt|;
block|}
name|CHECK_MATCHALL
argument_list|(
name|false
argument_list|)
expr_stmt|;
comment|/* Handle word-boundary matching when GNU extensions are enabled */
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_GNU
operator|)
operator|&&
operator|(
name|n
operator|>=
literal|14
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|pat
argument_list|,
name|TRE_CHAR
argument_list|(
literal|"[[:<:]]"
argument_list|)
argument_list|,
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|tre_char_t
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
operator|&&
operator|(
name|memcmp
argument_list|(
name|pat
operator|+
name|n
operator|-
literal|7
argument_list|,
name|TRE_CHAR
argument_list|(
literal|"[[:>:]]"
argument_list|)
argument_list|,
literal|7
operator|*
sizeof|sizeof
argument_list|(
name|tre_char_t
argument_list|)
argument_list|)
operator|==
literal|0
operator|)
condition|)
block|{
name|n
operator|-=
literal|14
expr_stmt|;
name|pat
operator|+=
literal|7
expr_stmt|;
name|fg
operator|->
name|word
operator|=
name|true
expr_stmt|;
block|}
comment|/* Cannot handle word boundaries with MB string */
if|if
condition|(
name|fg
operator|->
name|word
operator|&&
operator|(
name|TRE_MB_CUR_MAX
operator|>
literal|1
operator|)
condition|)
return|return
name|REG_BADPAT
return|;
name|tmp
operator|=
name|malloc
argument_list|(
operator|(
name|n
operator|+
literal|1
operator|)
operator|*
sizeof|sizeof
argument_list|(
name|tre_char_t
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|tmp
operator|==
name|NULL
condition|)
return|return
name|REG_ESPACE
return|;
comment|/* Copies the char into the stored pattern and skips to the next char. */
define|#
directive|define
name|STORE_CHAR
define|\
value|do									\     {									\       tmp[pos++] = pat[i];						\       escaped = false;							\       continue;								\     } while (0)
comment|/* Traverse the input pattern for processing */
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
block|{
switch|switch
condition|(
name|pat
index|[
name|i
index|]
condition|)
block|{
case|case
name|TRE_CHAR
argument_list|(
literal|'\\'
argument_list|)
case|:
if|if
condition|(
name|escaped
condition|)
name|STORE_CHAR
expr_stmt|;
elseif|else
if|if
condition|(
name|i
operator|==
name|n
operator|-
literal|1
condition|)
goto|goto
name|badpat
goto|;
else|else
name|escaped
operator|=
name|true
expr_stmt|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'['
argument_list|)
case|:
if|if
condition|(
name|escaped
condition|)
name|STORE_CHAR
expr_stmt|;
else|else
goto|goto
name|badpat
goto|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'*'
argument_list|)
case|:
if|if
condition|(
name|escaped
operator|||
operator|(
operator|!
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
operator|)
condition|)
name|STORE_CHAR
expr_stmt|;
else|else
goto|goto
name|badpat
goto|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'+'
argument_list|)
case|:
case|case
name|TRE_CHAR
argument_list|(
literal|'?'
argument_list|)
case|:
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
goto|goto
name|badpat
goto|;
elseif|else
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|^
operator|!
name|escaped
condition|)
name|STORE_CHAR
expr_stmt|;
else|else
goto|goto
name|badpat
goto|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'.'
argument_list|)
case|:
if|if
condition|(
name|escaped
condition|)
block|{
if|if
condition|(
operator|!
name|_escmap
condition|)
name|_escmap
operator|=
name|calloc
argument_list|(
name|n
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|_escmap
condition|)
block|{
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
name|_escmap
index|[
name|i
index|]
operator|=
name|true
expr_stmt|;
name|STORE_CHAR
expr_stmt|;
block|}
else|else
block|{
name|whasdot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|wfirstdot
operator|==
operator|-
literal|1
condition|)
name|wfirstdot
operator|=
name|i
expr_stmt|;
name|STORE_CHAR
expr_stmt|;
block|}
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'^'
argument_list|)
case|:
name|STORE_CHAR
expr_stmt|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'$'
argument_list|)
case|:
if|if
condition|(
operator|!
name|escaped
operator|&&
operator|(
name|i
operator|==
name|n
operator|-
literal|1
operator|)
condition|)
name|fg
operator|->
name|eol
operator|=
name|true
expr_stmt|;
else|else
name|STORE_CHAR
expr_stmt|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'('
argument_list|)
case|:
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|^
name|escaped
condition|)
goto|goto
name|badpat
goto|;
else|else
name|STORE_CHAR
expr_stmt|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'{'
argument_list|)
case|:
if|if
condition|(
operator|!
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|^
name|escaped
condition|)
name|STORE_CHAR
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
name|STORE_CHAR
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|&&
operator|(
name|i
operator|==
literal|0
operator|)
condition|)
continue|continue;
else|else
goto|goto
name|badpat
goto|;
continue|continue;
case|case
name|TRE_CHAR
argument_list|(
literal|'|'
argument_list|)
case|:
if|if
condition|(
operator|(
name|cflags
operator|&
name|REG_EXTENDED
operator|)
operator|^
name|escaped
condition|)
goto|goto
name|badpat
goto|;
else|else
name|STORE_CHAR
expr_stmt|;
continue|continue;
default|default:
if|if
condition|(
name|escaped
condition|)
goto|goto
name|badpat
goto|;
else|else
name|STORE_CHAR
expr_stmt|;
continue|continue;
block|}
continue|continue;
name|badpat
label|:
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|"tre_compile_fast: compilation of pattern failed, falling"
literal|"back to NFA\n"
operator|)
argument_list|)
expr_stmt|;
return|return
name|REG_BADPAT
return|;
block|}
name|fg
operator|->
name|hasdot
operator|=
name|wfirstdot
operator|>
operator|-
literal|1
expr_stmt|;
comment|/*    * The pattern has been processed and copied to tmp as a literal string    * with escapes, anchors (^$) and the word boundary match character    * classes stripped out.    */
ifdef|#
directive|ifdef
name|TRE_WCHAR
name|SAVE_PATTERN
argument_list|(
name|tmp
argument_list|,
name|pos
argument_list|,
name|fg
operator|->
name|wpattern
argument_list|,
name|fg
operator|->
name|wlen
argument_list|)
expr_stmt|;
name|fg
operator|->
name|wescmap
operator|=
name|_escmap
expr_stmt|;
name|STORE_MBS_PAT
expr_stmt|;
comment|/*    * The position of dots and escaped dots is different in the MB string    * than in to the wide string so traverse the converted string, as well,    * to store these positions.    */
if|if
condition|(
name|fg
operator|->
name|hasdot
operator|||
operator|(
name|fg
operator|->
name|wescmap
operator|!=
name|NULL
operator|)
condition|)
block|{
if|if
condition|(
name|fg
operator|->
name|wescmap
operator|!=
name|NULL
condition|)
block|{
name|fg
operator|->
name|escmap
operator|=
name|calloc
argument_list|(
name|fg
operator|->
name|len
argument_list|,
sizeof|sizeof
argument_list|(
name|bool
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|escmap
operator|==
name|NULL
condition|)
block|{
name|tre_free_fast
argument_list|(
name|fg
argument_list|)
expr_stmt|;
return|return
name|REG_ESPACE
return|;
block|}
block|}
name|escaped
operator|=
name|false
expr_stmt|;
name|char
modifier|*
name|_checkpat
init|=
name|NULL
decl_stmt|;
name|size_t
name|_checklen
init|=
literal|0
decl_stmt|;
name|unsigned
name|int
name|escofs
init|=
literal|0
decl_stmt|;
comment|/*        * Make a copy here of the original pattern, because fg->pattern has        * already been stripped of all escape sequences in the above processing.        * This is necessary if we wish to later treat fg->escmap as an actual,        * functional replacement of fg->wescmap.        */
name|CONV_MBS_PAT
argument_list|(
name|pat
argument_list|,
name|_checkpat
argument_list|,
name|_checklen
argument_list|)
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|n
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|_checkpat
index|[
name|i
index|]
operator|==
literal|'\\'
condition|)
block|{
name|escaped
operator|=
operator|!
name|escaped
expr_stmt|;
if|if
condition|(
name|escaped
condition|)
operator|++
name|escofs
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_checkpat
index|[
name|i
index|]
operator|==
literal|'.'
operator|&&
name|fg
operator|->
name|escmap
operator|!=
name|NULL
operator|&&
name|escaped
condition|)
block|{
name|fg
operator|->
name|escmap
index|[
name|i
operator|-
name|escofs
index|]
operator|=
name|true
expr_stmt|;
name|escaped
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|_checkpat
index|[
name|i
index|]
operator|==
literal|'.'
operator|&&
operator|!
name|escaped
condition|)
block|{
name|hasdot
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|firstdot
operator|==
operator|-
literal|1
condition|)
name|firstdot
operator|=
name|i
expr_stmt|;
block|}
else|else
name|escaped
operator|=
name|false
expr_stmt|;
name|free
argument_list|(
name|_checkpat
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|SAVE_PATTERN
argument_list|(
name|tmp
argument_list|,
name|pos
argument_list|,
name|fg
operator|->
name|pattern
argument_list|,
name|fg
operator|->
name|len
argument_list|)
expr_stmt|;
name|fg
operator|->
name|escmap
operator|=
name|_escmap
expr_stmt|;
endif|#
directive|endif
name|free
argument_list|(
name|tmp
argument_list|)
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|"tre_compile_fast: pattern: %s, len %zu, bol %c, eol %c, "
literal|"icase: %c, word: %c, newline %c\n"
operator|,
name|fg
operator|->
name|pattern
operator|,
name|fg
operator|->
name|len
operator|,
name|fg
operator|->
name|bol
condition|?
literal|'y'
else|:
literal|'n'
operator|,
name|fg
operator|->
name|eol
condition|?
literal|'y'
else|:
literal|'n'
operator|,
name|fg
operator|->
name|icase
condition|?
literal|'y'
else|:
literal|'n'
operator|,
name|fg
operator|->
name|word
condition|?
literal|'y'
else|:
literal|'n'
operator|,
name|fg
operator|->
name|newline
condition|?
literal|'y'
else|:
literal|'n'
operator|)
argument_list|)
expr_stmt|;
comment|/* Check whether reverse QS algorithm is more efficient */
if|if
condition|(
operator|(
name|wfirstdot
operator|>
operator|-
literal|1
operator|)
operator|&&
operator|(
name|fg
operator|->
name|wlen
operator|-
name|whasdot
operator|+
literal|1
operator|<
operator|(
name|size_t
operator|)
name|wfirstdot
operator|)
operator|&&
name|fg
operator|->
name|nosub
condition|)
block|{
name|fg
operator|->
name|reversed
operator|=
name|true
expr_stmt|;
name|DPRINT
argument_list|(
operator|(
literal|"tre_compile_fast: using reverse QS algorithm\n"
operator|)
argument_list|)
expr_stmt|;
block|}
name|FILL_QSBC
expr_stmt|;
name|FILL_BMGS
expr_stmt|;
ifdef|#
directive|ifdef
name|TRE_WCHAR
name|FILL_QSBC_WIDE
expr_stmt|;
name|FILL_BMGS_WIDE
expr_stmt|;
endif|#
directive|endif
return|return
name|REG_OK
return|;
block|}
end_function

begin_define
define|#
directive|define
name|_SHIFT_ONE
define|\
value|{									\     shift = 1;								\     j = !fg->reversed ? j + shift : j - shift;				\     continue;								\   }
end_define

begin_define
define|#
directive|define
name|_BBOUND_COND
define|\
value|((type == STR_WIDE) ?							\     ((j == 0) || !(tre_isalnum(str_wide[j - 1]) ||			\       (str_wide[j - 1] == TRE_CHAR('_')))) :				\     ((j == 0) || !(tre_isalnum(str_byte[j - 1]) ||			\       (str_byte[j - 1] == '_'))))
end_define

begin_define
define|#
directive|define
name|_EBOUND_COND
define|\
value|((type == STR_WIDE) ?							\     ((j + fg->wlen == len) || !(tre_isalnum(str_wide[j + fg->wlen]) ||	\       (str_wide[j + fg->wlen] == TRE_CHAR('_')))) :			\     ((j + fg->len == len) || !(tre_isalnum(str_byte[j + fg->len]) ||	\       (str_byte[j + fg->len] == '_'))))
end_define

begin_comment
comment|/*  * Condition to check whether the match on position j is on a  * word boundary.  */
end_comment

begin_define
define|#
directive|define
name|IS_ON_WORD_BOUNDARY
define|\
value|(_BBOUND_COND&& _EBOUND_COND)
end_define

begin_comment
comment|/*  * Checks word boundary and shifts one if match is not on a  * boundary.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_WORD_BOUNDARY
define|\
value|if (!IS_ON_WORD_BOUNDARY)						\       _SHIFT_ONE;
end_define

begin_define
define|#
directive|define
name|_BOL_COND
define|\
value|((j == 0) || ((type == STR_WIDE) ? (str_wide[j - 1] == TRE_CHAR('\n'))\ 				   : (str_byte[j - 1] == '\n')))
end_define

begin_comment
comment|/*  * Checks BOL anchor and shifts one if match is not on a  * boundary.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_BOL_ANCHOR
define|\
value|if (!_BOL_COND)							\       _SHIFT_ONE;
end_define

begin_define
define|#
directive|define
name|_EOL_COND
define|\
value|((type == STR_WIDE)							\     ? ((j + fg->wlen == len) ||						\ 		(str_wide[j + fg->wlen] == TRE_CHAR('\n')))		\     : ((j + fg->len == len) || (str_byte[j + fg->wlen] == '\n')))
end_define

begin_comment
comment|/*  * Checks EOL anchor and shifts one if match is not on a  * boundary.  */
end_comment

begin_define
define|#
directive|define
name|CHECK_EOL_ANCHOR
define|\
value|if (!_EOL_COND)							\       _SHIFT_ONE;
end_define

begin_comment
comment|/*  * Executes matching of the precompiled pattern on the input string.  * Returns REG_OK or REG_NOMATCH depending on if we find a match or not.  */
end_comment

begin_function
name|int
name|tre_match_fast
parameter_list|(
specifier|const
name|fastmatch_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|size_t
name|len
parameter_list|,
name|tre_str_type_t
name|type
parameter_list|,
name|int
name|nmatch
parameter_list|,
name|regmatch_t
name|pmatch
index|[]
parameter_list|,
name|int
name|eflags
parameter_list|)
block|{
name|unsigned
name|int
name|shift
decl_stmt|,
name|u
init|=
literal|0
decl_stmt|,
name|v
init|=
literal|0
decl_stmt|;
name|ssize_t
name|j
init|=
literal|0
decl_stmt|;
name|int
name|ret
init|=
name|REG_NOMATCH
decl_stmt|;
name|int
name|mismatch
decl_stmt|;
specifier|const
name|char
modifier|*
name|str_byte
init|=
name|data
decl_stmt|;
specifier|const
name|void
modifier|*
name|startptr
init|=
name|NULL
decl_stmt|;
specifier|const
name|tre_char_t
modifier|*
name|str_wide
init|=
name|data
decl_stmt|;
comment|/* Calculate length if unspecified. */
if|if
condition|(
name|len
operator|==
operator|(
name|size_t
operator|)
operator|-
literal|1
condition|)
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STR_WIDE
case|:
name|len
operator|=
name|tre_strlen
argument_list|(
name|str_wide
argument_list|)
expr_stmt|;
break|break;
default|default:
name|len
operator|=
name|strlen
argument_list|(
name|str_byte
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* Shortcut for empty pattern */
if|if
condition|(
name|fg
operator|->
name|matchall
condition|)
block|{
if|if
condition|(
operator|!
name|fg
operator|->
name|nosub
operator|&&
name|nmatch
operator|>=
literal|1
condition|)
block|{
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
literal|0
expr_stmt|;
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|len
expr_stmt|;
block|}
if|if
condition|(
name|fg
operator|->
name|bol
operator|&&
name|fg
operator|->
name|eol
condition|)
return|return
operator|(
name|len
operator|==
literal|0
operator|)
condition|?
name|REG_OK
else|:
name|REG_NOMATCH
return|;
else|else
return|return
name|REG_OK
return|;
block|}
comment|/* No point in going farther if we do not have enough data. */
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STR_WIDE
case|:
if|if
condition|(
name|len
operator|<
name|fg
operator|->
name|wlen
condition|)
return|return
name|ret
return|;
name|shift
operator|=
name|fg
operator|->
name|wlen
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|len
operator|<
name|fg
operator|->
name|len
condition|)
return|return
name|ret
return|;
name|shift
operator|=
name|fg
operator|->
name|len
expr_stmt|;
block|}
comment|/*    * REG_NOTBOL means not anchoring ^ to the beginning of the line, so we    * can shift one because there can't be a match at the beginning.    */
if|if
condition|(
name|fg
operator|->
name|bol
operator|&&
operator|(
name|eflags
operator|&
name|REG_NOTBOL
operator|)
condition|)
name|j
operator|=
literal|1
expr_stmt|;
comment|/*    * Like above, we cannot have a match at the very end when anchoring to    * the end and REG_NOTEOL is specified.    */
if|if
condition|(
name|fg
operator|->
name|eol
operator|&&
operator|(
name|eflags
operator|&
name|REG_NOTEOL
operator|)
condition|)
name|len
operator|--
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|reversed
condition|)
name|j
operator|=
name|len
operator|-
operator|(
name|type
operator|==
name|STR_WIDE
condition|?
name|fg
operator|->
name|wlen
else|:
name|fg
operator|->
name|len
operator|)
expr_stmt|;
comment|/* Only try once at the beginning or ending of the line. */
if|if
condition|(
operator|(
name|fg
operator|->
name|bol
operator|||
name|fg
operator|->
name|eol
operator|)
operator|&&
operator|!
name|fg
operator|->
name|newline
operator|&&
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTBOL
operator|)
operator|&&
operator|!
operator|(
name|eflags
operator|&
name|REG_NOTEOL
operator|)
condition|)
block|{
comment|/* Simple text comparison. */
if|if
condition|(
operator|!
operator|(
operator|(
name|fg
operator|->
name|bol
operator|&&
name|fg
operator|->
name|eol
operator|)
operator|&&
operator|(
name|type
operator|==
name|STR_WIDE
condition|?
operator|(
name|len
operator|!=
name|fg
operator|->
name|wlen
operator|)
else|:
operator|(
name|len
operator|!=
name|fg
operator|->
name|len
operator|)
operator|)
operator|)
condition|)
block|{
comment|/* Determine where in data to start search at. */
name|j
operator|=
name|fg
operator|->
name|eol
condition|?
name|len
operator|-
operator|(
name|type
operator|==
name|STR_WIDE
condition|?
name|fg
operator|->
name|wlen
else|:
name|fg
operator|->
name|len
operator|)
else|:
literal|0
expr_stmt|;
name|SKIP_CHARS
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|mismatch
operator|=
name|fastcmp
argument_list|(
name|fg
argument_list|,
name|startptr
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mismatch
operator|==
name|REG_OK
condition|)
block|{
if|if
condition|(
name|fg
operator|->
name|word
operator|&&
operator|!
name|IS_ON_WORD_BOUNDARY
condition|)
return|return
name|ret
return|;
if|if
condition|(
operator|!
name|fg
operator|->
name|nosub
operator|&&
name|nmatch
operator|>=
literal|1
condition|)
block|{
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
name|j
expr_stmt|;
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|j
operator|+
operator|(
name|type
operator|==
name|STR_WIDE
condition|?
name|fg
operator|->
name|wlen
else|:
name|fg
operator|->
name|len
operator|)
expr_stmt|;
block|}
return|return
name|REG_OK
return|;
block|}
block|}
block|}
else|else
block|{
comment|/* Quick Search / Turbo Boyer-Moore algorithm. */
do|do
block|{
name|SKIP_CHARS
argument_list|(
name|j
argument_list|)
expr_stmt|;
name|mismatch
operator|=
name|fastcmp
argument_list|(
name|fg
argument_list|,
name|startptr
argument_list|,
name|type
argument_list|)
expr_stmt|;
if|if
condition|(
name|mismatch
operator|==
name|REG_OK
condition|)
block|{
if|if
condition|(
name|fg
operator|->
name|word
condition|)
name|CHECK_WORD_BOUNDARY
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|bol
condition|)
name|CHECK_BOL_ANCHOR
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|eol
condition|)
name|CHECK_EOL_ANCHOR
expr_stmt|;
if|if
condition|(
operator|!
name|fg
operator|->
name|nosub
operator|&&
name|nmatch
operator|>=
literal|1
condition|)
block|{
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_so
operator|=
name|j
expr_stmt|;
name|pmatch
index|[
literal|0
index|]
operator|.
name|rm_eo
operator|=
name|j
operator|+
operator|(
operator|(
name|type
operator|==
name|STR_WIDE
operator|)
condition|?
name|fg
operator|->
name|wlen
else|:
name|fg
operator|->
name|len
operator|)
expr_stmt|;
block|}
return|return
name|REG_OK
return|;
block|}
elseif|else
if|if
condition|(
name|mismatch
operator|>
literal|0
condition|)
return|return
name|mismatch
return|;
name|mismatch
operator|=
operator|-
name|mismatch
operator|-
literal|1
expr_stmt|;
name|SHIFT
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|IS_OUT_OF_BOUNDS
condition|)
do|;
block|}
return|return
name|ret
return|;
block|}
end_function

begin_comment
comment|/*  * Frees the resources that were allocated when the pattern was compiled.  */
end_comment

begin_function
name|void
name|tre_free_fast
parameter_list|(
name|fastmatch_t
modifier|*
name|fg
parameter_list|)
block|{
name|DPRINT
argument_list|(
operator|(
literal|"tre_fast_free: freeing structures for pattern %s\n"
operator|,
name|fg
operator|->
name|pattern
operator|)
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TRE_WCHAR
name|hashtable_free
argument_list|(
name|fg
operator|->
name|qsBc_table
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|fg
operator|->
name|hasdot
condition|)
name|free
argument_list|(
name|fg
operator|->
name|bmGs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|wescmap
condition|)
name|free
argument_list|(
name|fg
operator|->
name|wescmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fg
operator|->
name|wpattern
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
operator|!
name|fg
operator|->
name|hasdot
condition|)
name|free
argument_list|(
name|fg
operator|->
name|sbmGs
argument_list|)
expr_stmt|;
if|if
condition|(
name|fg
operator|->
name|escmap
condition|)
name|free
argument_list|(
name|fg
operator|->
name|escmap
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fg
operator|->
name|pattern
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Returns:	-(i + 1) on failure (position that it failed with minus sign)  *		error code on error  *		REG_OK on success  */
end_comment

begin_function
specifier|static
specifier|inline
name|int
name|fastcmp
parameter_list|(
specifier|const
name|fastmatch_t
modifier|*
name|fg
parameter_list|,
specifier|const
name|void
modifier|*
name|data
parameter_list|,
name|tre_str_type_t
name|type
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|str_byte
init|=
name|data
decl_stmt|;
specifier|const
name|char
modifier|*
name|pat_byte
init|=
name|fg
operator|->
name|pattern
decl_stmt|;
specifier|const
name|tre_char_t
modifier|*
name|str_wide
init|=
name|data
decl_stmt|;
specifier|const
name|tre_char_t
modifier|*
name|pat_wide
init|=
name|fg
operator|->
name|wpattern
decl_stmt|;
specifier|const
name|bool
modifier|*
name|escmap
init|=
operator|(
name|type
operator|==
name|STR_WIDE
operator|)
condition|?
name|fg
operator|->
name|wescmap
else|:
name|fg
operator|->
name|escmap
decl_stmt|;
name|size_t
name|len
init|=
operator|(
name|type
operator|==
name|STR_WIDE
operator|)
condition|?
name|fg
operator|->
name|wlen
else|:
name|fg
operator|->
name|len
decl_stmt|;
name|int
name|ret
init|=
name|REG_OK
decl_stmt|;
comment|/* Compare the pattern and the input char-by-char from the last position. */
for|for
control|(
name|int
name|i
init|=
name|len
operator|-
literal|1
init|;
name|i
operator|>=
literal|0
condition|;
name|i
operator|--
control|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STR_WIDE
case|:
comment|/* Check dot */
if|if
condition|(
name|fg
operator|->
name|hasdot
operator|&&
name|pat_wide
index|[
name|i
index|]
operator|==
name|TRE_CHAR
argument_list|(
literal|'.'
argument_list|)
operator|&&
operator|(
operator|!
name|escmap
operator|||
operator|!
name|escmap
index|[
name|i
index|]
operator|)
operator|&&
operator|(
operator|!
name|fg
operator|->
name|newline
operator|||
operator|(
name|str_wide
index|[
name|i
index|]
operator|!=
name|TRE_CHAR
argument_list|(
literal|'\n'
argument_list|)
operator|)
operator|)
condition|)
continue|continue;
comment|/* Compare */
if|if
condition|(
name|fg
operator|->
name|icase
condition|?
operator|(
name|towlower
argument_list|(
name|pat_wide
index|[
name|i
index|]
argument_list|)
operator|==
name|towlower
argument_list|(
name|str_wide
index|[
name|i
index|]
argument_list|)
operator|)
else|:
operator|(
name|pat_wide
index|[
name|i
index|]
operator|==
name|str_wide
index|[
name|i
index|]
operator|)
condition|)
continue|continue;
break|break;
default|default:
comment|/* Check dot */
if|if
condition|(
name|fg
operator|->
name|hasdot
operator|&&
name|pat_byte
index|[
name|i
index|]
operator|==
literal|'.'
operator|&&
operator|(
operator|!
name|escmap
operator|||
operator|!
name|escmap
index|[
name|i
index|]
operator|)
operator|&&
operator|(
operator|!
name|fg
operator|->
name|newline
operator|||
operator|(
name|str_byte
index|[
name|i
index|]
operator|!=
literal|'\n'
operator|)
operator|)
condition|)
continue|continue;
comment|/* Compare */
if|if
condition|(
name|fg
operator|->
name|icase
condition|?
operator|(
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|pat_byte
index|[
name|i
index|]
argument_list|)
operator|==
name|tolower
argument_list|(
operator|(
name|unsigned
name|char
operator|)
name|str_byte
index|[
name|i
index|]
argument_list|)
operator|)
else|:
operator|(
name|pat_byte
index|[
name|i
index|]
operator|==
name|str_byte
index|[
name|i
index|]
operator|)
condition|)
continue|continue;
block|}
name|DPRINT
argument_list|(
operator|(
literal|"fastcmp: mismatch at position %d\n"
operator|,
name|i
operator|)
argument_list|)
expr_stmt|;
name|ret
operator|=
operator|-
operator|(
name|i
operator|+
literal|1
operator|)
expr_stmt|;
break|break;
block|}
return|return
name|ret
return|;
block|}
end_function

end_unit

