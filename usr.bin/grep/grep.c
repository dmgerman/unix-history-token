begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*	$NetBSD: grep.c,v 1.6 2011/04/18 03:48:23 joerg Exp $	*/
end_comment

begin_comment
comment|/* 	$FreeBSD$	*/
end_comment

begin_comment
comment|/*	$OpenBSD: grep.c,v 1.42 2010/07/02 22:18:03 tedu Exp $	*/
end_comment

begin_comment
comment|/*-  * Copyright (c) 1999 James Howard and Dag-Erling CoÃ¯dan SmÃ¸rgrav  * Copyright (C) 2008-2009 Gabor Kovesdan<gabor@FreeBSD.org>  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<getopt.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<libgen.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdbool.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WITHOUT_FASTMATCH
end_ifndef

begin_include
include|#
directive|include
file|"fastmatch.h"
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|"grep.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|WITHOUT_NLS
end_ifndef

begin_include
include|#
directive|include
file|<nl_types.h>
end_include

begin_decl_stmt
name|nl_catd
name|catalog
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Default messags to use when NLS is disabled or no catalogue  * is found.  */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|errstr
index|[]
init|=
block|{
literal|""
block|,
comment|/* 1*/
literal|"(standard input)"
block|,
comment|/* 2*/
literal|"cannot read bzip2 compressed file"
block|,
comment|/* 3*/
literal|"unknown %s option"
block|,
comment|/* 4*/
literal|"usage: %s [-abcDEFGHhIiJLlmnOoPqRSsUVvwxZz] [-A num] [-B num] [-C[num]]\n"
block|,
comment|/* 5*/
literal|"\t[-e pattern] [-f file] [--binary-files=value] [--color=when]\n"
block|,
comment|/* 6*/
literal|"\t[--context[=num]] [--directories=action] [--label] [--line-buffered]\n"
block|,
comment|/* 7*/
literal|"\t[--null] [pattern] [file ...]\n"
block|,
comment|/* 8*/
literal|"Binary file %s matches\n"
block|,
comment|/* 9*/
literal|"%s (BSD grep) %s\n"
block|,
comment|/* 10*/
literal|"%s (BSD grep, GNU compatible) %s\n"
block|, }
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Flags passed to regcomp() and regexec() */
end_comment

begin_decl_stmt
name|int
name|cflags
init|=
name|REG_NOSUB
operator||
name|REG_NEWLINE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|eflags
init|=
name|REG_STARTEND
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* XXX TODO: Get rid of this flag.  * matchall is a gross hack that means that an empty pattern was passed to us.  * It is a necessary evil at the moment because our regex(3) implementation  * does not allow for empty patterns, as supported by POSIX's definition of  * grammar for BREs/EREs. When libregex becomes available, it would be wise  * to remove this and let regex(3) handle the dirty details of empty patterns.  */
end_comment

begin_decl_stmt
name|bool
name|matchall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Searching patterns */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|patterns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|pattern_sz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|pat
modifier|*
name|pattern
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|regex_t
modifier|*
name|r_pattern
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|WITHOUT_FASTMATCH
end_ifndef

begin_decl_stmt
name|fastmatch_t
modifier|*
name|fg_pattern
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Filename exclusion/inclusion patterns */
end_comment

begin_decl_stmt
name|unsigned
name|int
name|fpatterns
decl_stmt|,
name|dpatterns
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|int
name|fpattern_sz
decl_stmt|,
name|dpattern_sz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|epat
modifier|*
name|dpattern
decl_stmt|,
modifier|*
name|fpattern
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* For regex errors  */
end_comment

begin_decl_stmt
name|char
name|re_error
index|[
name|RE_ERROR_BUF
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Command-line flags */
end_comment

begin_decl_stmt
name|long
name|long
name|Aflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -A x: print x lines trailing each match */
end_comment

begin_decl_stmt
name|long
name|long
name|Bflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -B x: print x lines leading each match */
end_comment

begin_decl_stmt
name|bool
name|Hflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -H: always print file name */
end_comment

begin_decl_stmt
name|bool
name|Lflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -L: only show names of files with no matches */
end_comment

begin_decl_stmt
name|bool
name|bflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -b: show block numbers for each match */
end_comment

begin_decl_stmt
name|bool
name|cflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -c: only show a count of matching lines */
end_comment

begin_decl_stmt
name|bool
name|hflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -h: don't print filename headers */
end_comment

begin_decl_stmt
name|bool
name|iflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -i: ignore case */
end_comment

begin_decl_stmt
name|bool
name|lflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -l: only show names of files with matches */
end_comment

begin_decl_stmt
name|bool
name|mflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -m x: stop reading the files after x matches */
end_comment

begin_decl_stmt
name|long
name|long
name|mcount
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* count for -m */
end_comment

begin_decl_stmt
name|long
name|long
name|mlimit
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* requested value for -m */
end_comment

begin_decl_stmt
name|char
name|fileeol
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* indicator for eol */
end_comment

begin_decl_stmt
name|bool
name|nflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -n: show line numbers in front of matching lines */
end_comment

begin_decl_stmt
name|bool
name|oflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -o: print only matching part */
end_comment

begin_decl_stmt
name|bool
name|qflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -q: quiet mode (don't output anything) */
end_comment

begin_decl_stmt
name|bool
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s: silent mode (ignore errors) */
end_comment

begin_decl_stmt
name|bool
name|vflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -v: only show non-matching lines */
end_comment

begin_decl_stmt
name|bool
name|wflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -w: pattern must start and end on word boundaries */
end_comment

begin_decl_stmt
name|bool
name|xflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -x: pattern must match entire line */
end_comment

begin_decl_stmt
name|bool
name|lbflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --line-buffered */
end_comment

begin_decl_stmt
name|bool
name|nullflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --null */
end_comment

begin_decl_stmt
name|char
modifier|*
name|label
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --label */
end_comment

begin_decl_stmt
specifier|const
name|char
modifier|*
name|color
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --color */
end_comment

begin_decl_stmt
name|int
name|grepbehave
init|=
name|GREP_BASIC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -EFGP: type of the regex */
end_comment

begin_decl_stmt
name|int
name|binbehave
init|=
name|BINFILE_BIN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -aIU: handling of binary files */
end_comment

begin_decl_stmt
name|int
name|filebehave
init|=
name|FILE_STDIO
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -JZ: normal, gzip or bzip2 file */
end_comment

begin_decl_stmt
name|int
name|devbehave
init|=
name|DEV_READ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -D: handling of devices */
end_comment

begin_decl_stmt
name|int
name|dirbehave
init|=
name|DIR_READ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -dRr: handling of directories */
end_comment

begin_decl_stmt
name|int
name|linkbehave
init|=
name|LINK_READ
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -OpS: handling of symlinks */
end_comment

begin_decl_stmt
name|bool
name|dexclude
decl_stmt|,
name|dinclude
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --exclude-dir and --include-dir */
end_comment

begin_decl_stmt
name|bool
name|fexclude
decl_stmt|,
name|finclude
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* --exclude and --include */
end_comment

begin_enum
enum|enum
block|{
name|BIN_OPT
init|=
name|CHAR_MAX
operator|+
literal|1
block|,
name|COLOR_OPT
block|,
name|HELP_OPT
block|,
name|MMAP_OPT
block|,
name|LINEBUF_OPT
block|,
name|LABEL_OPT
block|,
name|NULL_OPT
block|,
name|R_EXCLUDE_OPT
block|,
name|R_INCLUDE_OPT
block|,
name|R_DEXCLUDE_OPT
block|,
name|R_DINCLUDE_OPT
block|}
enum|;
end_enum

begin_function_decl
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|init_color
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Housekeeping */
end_comment

begin_decl_stmt
name|bool
name|file_err
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file reading error */
end_comment

begin_comment
comment|/*  * Prints usage information and returns 2.  */
end_comment

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|getstr
argument_list|(
literal|4
argument_list|)
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|getstr
argument_list|(
literal|5
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|getstr
argument_list|(
literal|6
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s"
argument_list|,
name|getstr
argument_list|(
literal|7
argument_list|)
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|optstr
init|=
literal|"0123456789A:B:C:D:EFGHIJMLOPSRUVZabcd:e:f:hilm:nopqrsuvwxXyz"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|struct
name|option
name|long_options
index|[]
init|=
block|{
block|{
literal|"binary-files"
block|,
name|required_argument
block|,
name|NULL
block|,
name|BIN_OPT
block|}
block|,
block|{
literal|"help"
block|,
name|no_argument
block|,
name|NULL
block|,
name|HELP_OPT
block|}
block|,
block|{
literal|"mmap"
block|,
name|no_argument
block|,
name|NULL
block|,
name|MMAP_OPT
block|}
block|,
block|{
literal|"line-buffered"
block|,
name|no_argument
block|,
name|NULL
block|,
name|LINEBUF_OPT
block|}
block|,
block|{
literal|"label"
block|,
name|required_argument
block|,
name|NULL
block|,
name|LABEL_OPT
block|}
block|,
block|{
literal|"null"
block|,
name|no_argument
block|,
name|NULL
block|,
name|NULL_OPT
block|}
block|,
block|{
literal|"color"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|COLOR_OPT
block|}
block|,
block|{
literal|"colour"
block|,
name|optional_argument
block|,
name|NULL
block|,
name|COLOR_OPT
block|}
block|,
block|{
literal|"exclude"
block|,
name|required_argument
block|,
name|NULL
block|,
name|R_EXCLUDE_OPT
block|}
block|,
block|{
literal|"include"
block|,
name|required_argument
block|,
name|NULL
block|,
name|R_INCLUDE_OPT
block|}
block|,
block|{
literal|"exclude-dir"
block|,
name|required_argument
block|,
name|NULL
block|,
name|R_DEXCLUDE_OPT
block|}
block|,
block|{
literal|"include-dir"
block|,
name|required_argument
block|,
name|NULL
block|,
name|R_DINCLUDE_OPT
block|}
block|,
block|{
literal|"after-context"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'A'
block|}
block|,
block|{
literal|"text"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'a'
block|}
block|,
block|{
literal|"before-context"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'B'
block|}
block|,
block|{
literal|"byte-offset"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'b'
block|}
block|,
block|{
literal|"context"
block|,
name|optional_argument
block|,
name|NULL
block|,
literal|'C'
block|}
block|,
block|{
literal|"count"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'c'
block|}
block|,
block|{
literal|"devices"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'D'
block|}
block|,
block|{
literal|"directories"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'d'
block|}
block|,
block|{
literal|"extended-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'E'
block|}
block|,
block|{
literal|"regexp"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'e'
block|}
block|,
block|{
literal|"fixed-strings"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'F'
block|}
block|,
block|{
literal|"file"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'f'
block|}
block|,
block|{
literal|"basic-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'G'
block|}
block|,
block|{
literal|"no-filename"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'h'
block|}
block|,
block|{
literal|"with-filename"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'H'
block|}
block|,
block|{
literal|"ignore-case"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'i'
block|}
block|,
block|{
literal|"bz2decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'J'
block|}
block|,
block|{
literal|"files-with-matches"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'l'
block|}
block|,
block|{
literal|"files-without-match"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'L'
block|}
block|,
block|{
literal|"max-count"
block|,
name|required_argument
block|,
name|NULL
block|,
literal|'m'
block|}
block|,
block|{
literal|"lzma"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'M'
block|}
block|,
block|{
literal|"line-number"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'n'
block|}
block|,
block|{
literal|"only-matching"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'o'
block|}
block|,
block|{
literal|"quiet"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"silent"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'q'
block|}
block|,
block|{
literal|"recursive"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'r'
block|}
block|,
block|{
literal|"no-messages"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'s'
block|}
block|,
block|{
literal|"binary"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'U'
block|}
block|,
block|{
literal|"unix-byte-offsets"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'u'
block|}
block|,
block|{
literal|"invert-match"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'v'
block|}
block|,
block|{
literal|"version"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'V'
block|}
block|,
block|{
literal|"word-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'w'
block|}
block|,
block|{
literal|"line-regexp"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'x'
block|}
block|,
block|{
literal|"xz"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'X'
block|}
block|,
block|{
literal|"null-data"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'z'
block|}
block|,
block|{
literal|"decompress"
block|,
name|no_argument
block|,
name|NULL
block|,
literal|'Z'
block|}
block|,
block|{
name|NULL
block|,
name|no_argument
block|,
name|NULL
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Adds a searching pattern to the internal array.  */
end_comment

begin_function
specifier|static
name|void
name|add_pattern
parameter_list|(
name|char
modifier|*
name|pat
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
comment|/* Do not add further pattern is we already match everything */
if|if
condition|(
name|matchall
condition|)
return|return;
comment|/* Check if we can do a shortcut */
if|if
condition|(
name|len
operator|==
literal|0
condition|)
block|{
name|matchall
operator|=
name|true
expr_stmt|;
for|for
control|(
name|unsigned
name|int
name|i
init|=
literal|0
init|;
name|i
operator|<
name|patterns
condition|;
name|i
operator|++
control|)
block|{
name|free
argument_list|(
name|pattern
index|[
name|i
index|]
operator|.
name|pat
argument_list|)
expr_stmt|;
block|}
name|pattern
operator|=
name|grep_realloc
argument_list|(
name|pattern
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|pat
argument_list|)
argument_list|)
expr_stmt|;
name|pattern
index|[
literal|0
index|]
operator|.
name|pat
operator|=
name|NULL
expr_stmt|;
name|pattern
index|[
literal|0
index|]
operator|.
name|len
operator|=
literal|0
expr_stmt|;
name|patterns
operator|=
literal|1
expr_stmt|;
return|return;
block|}
comment|/* Increase size if necessary */
if|if
condition|(
name|patterns
operator|==
name|pattern_sz
condition|)
block|{
name|pattern_sz
operator|*=
literal|2
expr_stmt|;
name|pattern
operator|=
name|grep_realloc
argument_list|(
name|pattern
argument_list|,
operator|++
name|pattern_sz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|pat
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|len
operator|>
literal|0
operator|&&
name|pat
index|[
name|len
operator|-
literal|1
index|]
operator|==
literal|'\n'
condition|)
operator|--
name|len
expr_stmt|;
comment|/* pat may not be NUL-terminated */
name|pattern
index|[
name|patterns
index|]
operator|.
name|pat
operator|=
name|grep_malloc
argument_list|(
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|pattern
index|[
name|patterns
index|]
operator|.
name|pat
argument_list|,
name|pat
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pattern
index|[
name|patterns
index|]
operator|.
name|len
operator|=
name|len
expr_stmt|;
name|pattern
index|[
name|patterns
index|]
operator|.
name|pat
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|patterns
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adds a file include/exclude pattern to the internal array.  */
end_comment

begin_function
specifier|static
name|void
name|add_fpattern
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* Increase size if necessary */
if|if
condition|(
name|fpatterns
operator|==
name|fpattern_sz
condition|)
block|{
name|fpattern_sz
operator|*=
literal|2
expr_stmt|;
name|fpattern
operator|=
name|grep_realloc
argument_list|(
name|fpattern
argument_list|,
operator|++
name|fpattern_sz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|epat
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|fpattern
index|[
name|fpatterns
index|]
operator|.
name|pat
operator|=
name|grep_strdup
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|fpattern
index|[
name|fpatterns
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
operator|++
name|fpatterns
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Adds a directory include/exclude pattern to the internal array.  */
end_comment

begin_function
specifier|static
name|void
name|add_dpattern
parameter_list|(
specifier|const
name|char
modifier|*
name|pat
parameter_list|,
name|int
name|mode
parameter_list|)
block|{
comment|/* Increase size if necessary */
if|if
condition|(
name|dpatterns
operator|==
name|dpattern_sz
condition|)
block|{
name|dpattern_sz
operator|*=
literal|2
expr_stmt|;
name|dpattern
operator|=
name|grep_realloc
argument_list|(
name|dpattern
argument_list|,
operator|++
name|dpattern_sz
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|epat
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dpattern
index|[
name|dpatterns
index|]
operator|.
name|pat
operator|=
name|grep_strdup
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|dpattern
index|[
name|dpatterns
index|]
operator|.
name|mode
operator|=
name|mode
expr_stmt|;
operator|++
name|dpatterns
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * Reads searching patterns from a file and adds them with add_pattern().  */
end_comment

begin_function
specifier|static
name|void
name|read_patterns
parameter_list|(
specifier|const
name|char
modifier|*
name|fn
parameter_list|)
block|{
name|struct
name|stat
name|st
decl_stmt|;
name|FILE
modifier|*
name|f
decl_stmt|;
name|char
modifier|*
name|line
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|ssize_t
name|rlen
decl_stmt|;
if|if
condition|(
operator|(
name|f
operator|=
name|fopen
argument_list|(
name|fn
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|f
argument_list|)
argument_list|,
operator|&
name|st
argument_list|)
operator|==
operator|-
literal|1
operator|)
operator|||
operator|(
name|S_ISDIR
argument_list|(
name|st
operator|.
name|st_mode
argument_list|)
operator|)
condition|)
block|{
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
return|return;
block|}
name|len
operator|=
literal|0
expr_stmt|;
name|line
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|(
name|rlen
operator|=
name|getline
argument_list|(
operator|&
name|line
argument_list|,
operator|&
name|len
argument_list|,
name|f
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|line
index|[
literal|0
index|]
operator|==
literal|'\0'
condition|)
continue|continue;
name|add_pattern
argument_list|(
name|line
argument_list|,
name|line
index|[
literal|0
index|]
operator|==
literal|'\n'
condition|?
literal|0
else|:
operator|(
name|size_t
operator|)
name|rlen
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|line
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|f
argument_list|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|fn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|f
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
specifier|inline
specifier|const
name|char
modifier|*
name|init_color
parameter_list|(
specifier|const
name|char
modifier|*
name|d
parameter_list|)
block|{
name|char
modifier|*
name|c
decl_stmt|;
name|c
operator|=
name|getenv
argument_list|(
literal|"GREP_COLOR"
argument_list|)
expr_stmt|;
return|return
operator|(
name|c
operator|!=
name|NULL
operator|&&
name|c
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|?
name|c
else|:
name|d
operator|)
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
modifier|*
name|aargv
decl_stmt|,
modifier|*
modifier|*
name|eargv
decl_stmt|,
modifier|*
name|eopts
decl_stmt|;
name|char
modifier|*
name|ep
decl_stmt|;
specifier|const
name|char
modifier|*
name|pn
decl_stmt|;
name|long
name|long
name|l
decl_stmt|;
name|unsigned
name|int
name|aargc
decl_stmt|,
name|eargc
decl_stmt|,
name|i
decl_stmt|;
name|int
name|c
decl_stmt|,
name|lastc
decl_stmt|,
name|needpattern
decl_stmt|,
name|newarg
decl_stmt|,
name|prevoptind
decl_stmt|;
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|WITHOUT_NLS
name|catalog
operator|=
name|catopen
argument_list|(
literal|"grep"
argument_list|,
name|NL_CAT_LOCALE
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Check what is the program name of the binary.  In this 	   way we can have all the funcionalities in one binary 	   without the need of scripting and using ugly hacks. */
name|pn
operator|=
name|getprogname
argument_list|()
expr_stmt|;
if|if
condition|(
name|pn
index|[
literal|0
index|]
operator|==
literal|'b'
operator|&&
name|pn
index|[
literal|1
index|]
operator|==
literal|'z'
condition|)
block|{
name|filebehave
operator|=
name|FILE_BZIP
expr_stmt|;
name|pn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pn
index|[
literal|0
index|]
operator|==
literal|'x'
operator|&&
name|pn
index|[
literal|1
index|]
operator|==
literal|'z'
condition|)
block|{
name|filebehave
operator|=
name|FILE_XZ
expr_stmt|;
name|pn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pn
index|[
literal|0
index|]
operator|==
literal|'l'
operator|&&
name|pn
index|[
literal|1
index|]
operator|==
literal|'z'
condition|)
block|{
name|filebehave
operator|=
name|FILE_LZMA
expr_stmt|;
name|pn
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pn
index|[
literal|0
index|]
operator|==
literal|'r'
condition|)
block|{
name|dirbehave
operator|=
name|DIR_RECURSE
expr_stmt|;
name|Hflag
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pn
index|[
literal|0
index|]
operator|==
literal|'z'
condition|)
block|{
name|filebehave
operator|=
name|FILE_GZIP
expr_stmt|;
name|pn
operator|+=
literal|1
expr_stmt|;
block|}
switch|switch
condition|(
name|pn
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|grepbehave
operator|=
name|GREP_EXTENDED
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|grepbehave
operator|=
name|GREP_FIXED
expr_stmt|;
break|break;
block|}
name|lastc
operator|=
literal|'\0'
expr_stmt|;
name|newarg
operator|=
literal|1
expr_stmt|;
name|prevoptind
operator|=
literal|1
expr_stmt|;
name|needpattern
operator|=
literal|1
expr_stmt|;
name|fileeol
operator|=
literal|'\n'
expr_stmt|;
name|eopts
operator|=
name|getenv
argument_list|(
literal|"GREP_OPTIONS"
argument_list|)
expr_stmt|;
comment|/* support for extra arguments in GREP_OPTIONS */
name|eargc
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|eopts
operator|!=
name|NULL
operator|&&
name|eopts
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|char
modifier|*
name|str
decl_stmt|;
comment|/* make an estimation of how many extra arguments we have */
for|for
control|(
name|unsigned
name|int
name|j
init|=
literal|0
init|;
name|j
operator|<
name|strlen
argument_list|(
name|eopts
argument_list|)
condition|;
name|j
operator|++
control|)
if|if
condition|(
name|eopts
index|[
name|j
index|]
operator|==
literal|' '
condition|)
name|eargc
operator|++
expr_stmt|;
name|eargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|grep_malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
operator|*
operator|(
name|eargc
operator|+
literal|1
operator|)
argument_list|)
expr_stmt|;
name|eargc
operator|=
literal|0
expr_stmt|;
comment|/* parse extra arguments */
while|while
condition|(
operator|(
name|str
operator|=
name|strsep
argument_list|(
operator|&
name|eopts
argument_list|,
literal|" "
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
if|if
condition|(
name|str
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
name|eargv
index|[
name|eargc
operator|++
index|]
operator|=
name|grep_strdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|aargv
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|grep_calloc
argument_list|(
name|eargc
operator|+
name|argc
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
expr_stmt|;
name|aargv
index|[
literal|0
index|]
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|eargc
condition|;
name|i
operator|++
control|)
name|aargv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|eargv
index|[
name|i
index|]
expr_stmt|;
for|for
control|(
name|int
name|j
init|=
literal|1
init|;
name|j
operator|<
name|argc
condition|;
name|j
operator|++
operator|,
name|i
operator|++
control|)
name|aargv
index|[
name|i
operator|+
literal|1
index|]
operator|=
name|argv
index|[
name|j
index|]
expr_stmt|;
name|aargc
operator|=
name|eargc
operator|+
name|argc
expr_stmt|;
block|}
else|else
block|{
name|aargv
operator|=
name|argv
expr_stmt|;
name|aargc
operator|=
name|argc
expr_stmt|;
block|}
while|while
condition|(
operator|(
operator|(
name|c
operator|=
name|getopt_long
argument_list|(
name|aargc
argument_list|,
name|aargv
argument_list|,
name|optstr
argument_list|,
name|long_options
argument_list|,
name|NULL
argument_list|)
operator|)
operator|!=
operator|-
literal|1
operator|)
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'0'
case|:
case|case
literal|'1'
case|:
case|case
literal|'2'
case|:
case|case
literal|'3'
case|:
case|case
literal|'4'
case|:
case|case
literal|'5'
case|:
case|case
literal|'6'
case|:
case|case
literal|'7'
case|:
case|case
literal|'8'
case|:
case|case
literal|'9'
case|:
if|if
condition|(
name|newarg
operator|||
operator|!
name|isdigit
argument_list|(
name|lastc
argument_list|)
condition|)
name|Aflag
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|Aflag
operator|>
name|LLONG_MAX
operator|/
literal|10
operator|-
literal|1
condition|)
block|{
name|errno
operator|=
name|ERANGE
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
name|Aflag
operator|=
name|Bflag
operator|=
operator|(
name|Aflag
operator|*
literal|10
operator|)
operator|+
operator|(
name|c
operator|-
literal|'0'
operator|)
expr_stmt|;
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|optarg
operator|==
name|NULL
condition|)
block|{
name|Aflag
operator|=
name|Bflag
operator|=
literal|2
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
case|case
literal|'A'
case|:
comment|/* FALLTHROUGH */
case|case
literal|'B'
case|:
name|errno
operator|=
literal|0
expr_stmt|;
name|l
operator|=
name|strtoll
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|errno
operator|==
name|ERANGE
operator|||
name|errno
operator|==
name|EINVAL
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|<
literal|0
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
literal|"context argument must be non-negative"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|c
operator|==
literal|'A'
condition|)
name|Aflag
operator|=
name|l
expr_stmt|;
elseif|else
if|if
condition|(
name|c
operator|==
literal|'B'
condition|)
name|Bflag
operator|=
name|l
expr_stmt|;
else|else
name|Aflag
operator|=
name|Bflag
operator|=
name|l
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
name|binbehave
operator|=
name|BINFILE_TEXT
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|bflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|cflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'D'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"skip"
argument_list|)
operator|==
literal|0
condition|)
name|devbehave
operator|=
name|DEV_SKIP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
name|optarg
argument_list|,
literal|"read"
argument_list|)
operator|==
literal|0
condition|)
name|devbehave
operator|=
name|DEV_READ
expr_stmt|;
else|else
name|errx
argument_list|(
literal|2
argument_list|,
name|getstr
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"--devices"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"recurse"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|Hflag
operator|=
name|true
expr_stmt|;
name|dirbehave
operator|=
name|DIR_RECURSE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"skip"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|dirbehave
operator|=
name|DIR_SKIP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"read"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|dirbehave
operator|=
name|DIR_READ
expr_stmt|;
else|else
name|errx
argument_list|(
literal|2
argument_list|,
name|getstr
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"--directories"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'E'
case|:
name|grepbehave
operator|=
name|GREP_EXTENDED
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
block|{
name|char
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|string
init|=
name|optarg
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|string
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|add_pattern
argument_list|(
name|token
argument_list|,
name|strlen
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|needpattern
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|grepbehave
operator|=
name|GREP_FIXED
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|read_patterns
argument_list|(
name|optarg
argument_list|)
expr_stmt|;
name|needpattern
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|grepbehave
operator|=
name|GREP_BASIC
expr_stmt|;
break|break;
case|case
literal|'H'
case|:
name|Hflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|Hflag
operator|=
name|false
expr_stmt|;
name|hflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|binbehave
operator|=
name|BINFILE_SKIP
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
case|case
literal|'y'
case|:
name|iflag
operator|=
name|true
expr_stmt|;
name|cflags
operator||=
name|REG_ICASE
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
ifdef|#
directive|ifdef
name|WITHOUT_BZIP2
name|errno
operator|=
name|EOPNOTSUPP
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
literal|"bzip2 support was disabled at compile-time"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|filebehave
operator|=
name|FILE_BZIP
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|lflag
operator|=
name|false
expr_stmt|;
name|Lflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|Lflag
operator|=
name|false
expr_stmt|;
name|lflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|mflag
operator|=
name|true
expr_stmt|;
name|errno
operator|=
literal|0
expr_stmt|;
name|mlimit
operator|=
name|mcount
operator|=
name|strtoll
argument_list|(
name|optarg
argument_list|,
operator|&
name|ep
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|(
name|errno
operator|==
name|ERANGE
operator|)
operator|&&
operator|(
name|mcount
operator|==
name|LLONG_MAX
operator|)
operator|)
operator|||
operator|(
operator|(
name|errno
operator|==
name|EINVAL
operator|)
operator|&&
operator|(
name|mcount
operator|==
literal|0
operator|)
operator|)
condition|)
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|ep
index|[
literal|0
index|]
operator|!=
literal|'\0'
condition|)
block|{
name|errno
operator|=
name|EINVAL
expr_stmt|;
name|err
argument_list|(
literal|2
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'M'
case|:
name|filebehave
operator|=
name|FILE_LZMA
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|nflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|linkbehave
operator|=
name|LINK_EXPLICIT
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|oflag
operator|=
name|true
expr_stmt|;
name|cflags
operator|&=
operator|~
name|REG_NOSUB
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|linkbehave
operator|=
name|LINK_SKIP
expr_stmt|;
break|break;
case|case
literal|'q'
case|:
name|qflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
name|linkbehave
operator|=
name|LINK_READ
expr_stmt|;
break|break;
case|case
literal|'R'
case|:
case|case
literal|'r'
case|:
name|dirbehave
operator|=
name|DIR_RECURSE
expr_stmt|;
name|Hflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|sflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|binbehave
operator|=
name|BINFILE_BIN
expr_stmt|;
break|break;
case|case
literal|'u'
case|:
case|case
name|MMAP_OPT
case|:
name|filebehave
operator|=
name|FILE_MMAP
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
ifdef|#
directive|ifdef
name|WITH_GNU
name|printf
argument_list|(
name|getstr
argument_list|(
literal|10
argument_list|)
argument_list|,
name|getprogname
argument_list|()
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
else|#
directive|else
name|printf
argument_list|(
name|getstr
argument_list|(
literal|9
argument_list|)
argument_list|,
name|getprogname
argument_list|()
argument_list|,
name|VERSION
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'v'
case|:
name|vflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
name|wflag
operator|=
name|true
expr_stmt|;
name|cflags
operator|&=
operator|~
name|REG_NOSUB
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
name|xflag
operator|=
name|true
expr_stmt|;
name|cflags
operator|&=
operator|~
name|REG_NOSUB
expr_stmt|;
break|break;
case|case
literal|'X'
case|:
name|filebehave
operator|=
name|FILE_XZ
expr_stmt|;
break|break;
case|case
literal|'z'
case|:
name|fileeol
operator|=
literal|'\0'
expr_stmt|;
break|break;
case|case
literal|'Z'
case|:
name|filebehave
operator|=
name|FILE_GZIP
expr_stmt|;
break|break;
case|case
name|BIN_OPT
case|:
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"binary"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|binbehave
operator|=
name|BINFILE_BIN
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"without-match"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|binbehave
operator|=
name|BINFILE_SKIP
expr_stmt|;
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"text"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
name|binbehave
operator|=
name|BINFILE_TEXT
expr_stmt|;
else|else
name|errx
argument_list|(
literal|2
argument_list|,
name|getstr
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"--binary-files"
argument_list|)
expr_stmt|;
break|break;
case|case
name|COLOR_OPT
case|:
name|color
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|optarg
operator|==
name|NULL
operator|||
name|strcasecmp
argument_list|(
literal|"auto"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
literal|"tty"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
literal|"if-tty"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|term
decl_stmt|;
name|term
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|&&
name|term
operator|!=
name|NULL
operator|&&
name|strcasecmp
argument_list|(
name|term
argument_list|,
literal|"dumb"
argument_list|)
operator|!=
literal|0
condition|)
name|color
operator|=
name|init_color
argument_list|(
literal|"01;31"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"always"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
literal|"yes"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
operator|||
name|strcasecmp
argument_list|(
literal|"force"
argument_list|,
name|optarg
argument_list|)
operator|==
literal|0
condition|)
block|{
name|color
operator|=
name|init_color
argument_list|(
literal|"01;31"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcasecmp
argument_list|(
literal|"never"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
literal|"none"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
operator|&&
name|strcasecmp
argument_list|(
literal|"no"
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|)
name|errx
argument_list|(
literal|2
argument_list|,
name|getstr
argument_list|(
literal|3
argument_list|)
argument_list|,
literal|"--color"
argument_list|)
expr_stmt|;
name|cflags
operator|&=
operator|~
name|REG_NOSUB
expr_stmt|;
break|break;
case|case
name|LABEL_OPT
case|:
name|label
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
name|LINEBUF_OPT
case|:
name|lbflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|NULL_OPT
case|:
name|nullflag
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|R_INCLUDE_OPT
case|:
name|finclude
operator|=
name|true
expr_stmt|;
name|add_fpattern
argument_list|(
name|optarg
argument_list|,
name|INCL_PAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_EXCLUDE_OPT
case|:
name|fexclude
operator|=
name|true
expr_stmt|;
name|add_fpattern
argument_list|(
name|optarg
argument_list|,
name|EXCL_PAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_DINCLUDE_OPT
case|:
name|dinclude
operator|=
name|true
expr_stmt|;
name|add_dpattern
argument_list|(
name|optarg
argument_list|,
name|INCL_PAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|R_DEXCLUDE_OPT
case|:
name|dexclude
operator|=
name|true
expr_stmt|;
name|add_dpattern
argument_list|(
name|optarg
argument_list|,
name|EXCL_PAT
argument_list|)
expr_stmt|;
break|break;
case|case
name|HELP_OPT
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|lastc
operator|=
name|c
expr_stmt|;
name|newarg
operator|=
name|optind
operator|!=
name|prevoptind
expr_stmt|;
name|prevoptind
operator|=
name|optind
expr_stmt|;
block|}
name|aargc
operator|-=
name|optind
expr_stmt|;
name|aargv
operator|+=
name|optind
expr_stmt|;
comment|/* Empty pattern file matches nothing */
if|if
condition|(
operator|!
name|needpattern
operator|&&
operator|(
name|patterns
operator|==
literal|0
operator|)
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* Fail if we don't have any pattern */
if|if
condition|(
name|aargc
operator|==
literal|0
operator|&&
name|needpattern
condition|)
name|usage
argument_list|()
expr_stmt|;
comment|/* Process patterns from command line */
if|if
condition|(
name|aargc
operator|!=
literal|0
operator|&&
name|needpattern
condition|)
block|{
name|char
modifier|*
name|token
decl_stmt|;
name|char
modifier|*
name|string
init|=
operator|*
name|aargv
decl_stmt|;
while|while
condition|(
operator|(
name|token
operator|=
name|strsep
argument_list|(
operator|&
name|string
argument_list|,
literal|"\n"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
name|add_pattern
argument_list|(
name|token
argument_list|,
name|strlen
argument_list|(
name|token
argument_list|)
argument_list|)
expr_stmt|;
operator|--
name|aargc
expr_stmt|;
operator|++
name|aargv
expr_stmt|;
block|}
switch|switch
condition|(
name|grepbehave
condition|)
block|{
case|case
name|GREP_BASIC
case|:
break|break;
case|case
name|GREP_FIXED
case|:
if|#
directive|if
name|defined
argument_list|(
name|REG_NOSPEC
argument_list|)
name|cflags
operator||=
name|REG_NOSPEC
expr_stmt|;
elif|#
directive|elif
name|defined
argument_list|(
name|REG_LITERAL
argument_list|)
name|cflags
operator||=
name|REG_LITERAL
expr_stmt|;
else|#
directive|else
name|errx
argument_list|(
literal|2
argument_list|,
literal|"literal expressions not supported at compile time"
argument_list|)
expr_stmt|;
endif|#
directive|endif
break|break;
case|case
name|GREP_EXTENDED
case|:
name|cflags
operator||=
name|REG_EXTENDED
expr_stmt|;
break|break;
default|default:
comment|/* NOTREACHED */
name|usage
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|WITHOUT_FASTMATCH
name|fg_pattern
operator|=
name|grep_calloc
argument_list|(
name|patterns
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|fg_pattern
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|r_pattern
operator|=
name|grep_calloc
argument_list|(
name|patterns
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|r_pattern
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't process any patterns if we have a blank one */
if|if
condition|(
operator|!
name|matchall
condition|)
block|{
comment|/* Check if cheating is allowed (always is for fgrep). */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|patterns
condition|;
operator|++
name|i
control|)
block|{
ifndef|#
directive|ifndef
name|WITHOUT_FASTMATCH
comment|/* 			 * Attempt compilation with fastmatch regex and 			 * fallback to regex(3) if it fails. 			 */
if|if
condition|(
name|fastncomp
argument_list|(
operator|&
name|fg_pattern
index|[
name|i
index|]
argument_list|,
name|pattern
index|[
name|i
index|]
operator|.
name|pat
argument_list|,
name|pattern
index|[
name|i
index|]
operator|.
name|len
argument_list|,
name|cflags
argument_list|)
operator|==
literal|0
condition|)
continue|continue;
endif|#
directive|endif
name|c
operator|=
name|regcomp
argument_list|(
operator|&
name|r_pattern
index|[
name|i
index|]
argument_list|,
name|pattern
index|[
name|i
index|]
operator|.
name|pat
argument_list|,
name|cflags
argument_list|)
expr_stmt|;
if|if
condition|(
name|c
operator|!=
literal|0
condition|)
block|{
name|regerror
argument_list|(
name|c
argument_list|,
operator|&
name|r_pattern
index|[
name|i
index|]
argument_list|,
name|re_error
argument_list|,
name|RE_ERROR_BUF
argument_list|)
expr_stmt|;
name|errx
argument_list|(
literal|2
argument_list|,
literal|"%s"
argument_list|,
name|re_error
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|lbflag
condition|)
name|setlinebuf
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|aargc
operator|==
literal|0
operator|||
name|aargc
operator|==
literal|1
operator|)
operator|&&
operator|!
name|Hflag
condition|)
name|hflag
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|aargc
operator|==
literal|0
operator|&&
name|dirbehave
operator|!=
name|DIR_RECURSE
condition|)
name|exit
argument_list|(
operator|!
name|procfile
argument_list|(
literal|"-"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|dirbehave
operator|==
name|DIR_RECURSE
condition|)
name|c
operator|=
name|grep_tree
argument_list|(
name|aargv
argument_list|)
expr_stmt|;
else|else
for|for
control|(
name|c
operator|=
literal|0
init|;
name|aargc
operator|--
condition|;
operator|++
name|aargv
control|)
block|{
if|if
condition|(
operator|(
name|finclude
operator|||
name|fexclude
operator|)
operator|&&
operator|!
name|file_matching
argument_list|(
operator|*
name|aargv
argument_list|)
condition|)
continue|continue;
name|c
operator|+=
name|procfile
argument_list|(
operator|*
name|aargv
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|WITHOUT_NLS
name|catclose
argument_list|(
name|catalog
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Find out the correct return value according to the 	   results and the command line option. */
name|exit
argument_list|(
name|c
condition|?
operator|(
name|file_err
condition|?
operator|(
name|qflag
condition|?
literal|0
else|:
literal|2
operator|)
else|:
literal|0
operator|)
else|:
operator|(
name|file_err
condition|?
literal|2
else|:
literal|1
operator|)
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

