begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 2003 David O'Brien.  All rights reserved.  * Copyright (c) 2001 Jake Burkholder  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/capsicum.h>
end_include

begin_include
include|#
directive|include
file|<sys/elf32.h>
end_include

begin_include
include|#
directive|include
file|<sys/elf64.h>
end_include

begin_include
include|#
directive|include
file|<sys/endian.h>
end_include

begin_include
include|#
directive|include
file|<sys/mman.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<inttypes.h>
end_include

begin_include
include|#
directive|include
file|<stddef.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_define
define|#
directive|define
name|ED_DYN
value|(1<<0)
end_define

begin_define
define|#
directive|define
name|ED_EHDR
value|(1<<1)
end_define

begin_define
define|#
directive|define
name|ED_GOT
value|(1<<2)
end_define

begin_define
define|#
directive|define
name|ED_HASH
value|(1<<3)
end_define

begin_define
define|#
directive|define
name|ED_INTERP
value|(1<<4)
end_define

begin_define
define|#
directive|define
name|ED_NOTE
value|(1<<5)
end_define

begin_define
define|#
directive|define
name|ED_PHDR
value|(1<<6)
end_define

begin_define
define|#
directive|define
name|ED_REL
value|(1<<7)
end_define

begin_define
define|#
directive|define
name|ED_SHDR
value|(1<<8)
end_define

begin_define
define|#
directive|define
name|ED_SYMTAB
value|(1<<9)
end_define

begin_define
define|#
directive|define
name|ED_ALL
value|((1<<10)-1)
end_define

begin_define
define|#
directive|define
name|elf_get_addr
value|elf_get_quad
end_define

begin_define
define|#
directive|define
name|elf_get_off
value|elf_get_quad
end_define

begin_define
define|#
directive|define
name|elf_get_size
value|elf_get_quad
end_define

begin_enum
enum|enum
name|elf_member
block|{
name|D_TAG
init|=
literal|1
block|,
name|D_PTR
block|,
name|D_VAL
block|,
name|E_CLASS
block|,
name|E_DATA
block|,
name|E_OSABI
block|,
name|E_TYPE
block|,
name|E_MACHINE
block|,
name|E_VERSION
block|,
name|E_ENTRY
block|,
name|E_PHOFF
block|,
name|E_SHOFF
block|,
name|E_FLAGS
block|,
name|E_EHSIZE
block|,
name|E_PHENTSIZE
block|,
name|E_PHNUM
block|,
name|E_SHENTSIZE
block|,
name|E_SHNUM
block|,
name|E_SHSTRNDX
block|,
name|N_NAMESZ
block|,
name|N_DESCSZ
block|,
name|N_TYPE
block|,
name|P_TYPE
block|,
name|P_OFFSET
block|,
name|P_VADDR
block|,
name|P_PADDR
block|,
name|P_FILESZ
block|,
name|P_MEMSZ
block|,
name|P_FLAGS
block|,
name|P_ALIGN
block|,
name|SH_NAME
block|,
name|SH_TYPE
block|,
name|SH_FLAGS
block|,
name|SH_ADDR
block|,
name|SH_OFFSET
block|,
name|SH_SIZE
block|,
name|SH_LINK
block|,
name|SH_INFO
block|,
name|SH_ADDRALIGN
block|,
name|SH_ENTSIZE
block|,
name|ST_NAME
block|,
name|ST_VALUE
block|,
name|ST_SIZE
block|,
name|ST_INFO
block|,
name|ST_SHNDX
block|,
name|R_OFFSET
block|,
name|R_INFO
block|,
name|RA_OFFSET
block|,
name|RA_INFO
block|,
name|RA_ADDEND
block|}
enum|;
end_enum

begin_typedef
typedef|typedef
name|enum
name|elf_member
name|elf_member_t
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|int
name|elf32_offsets
index|[]
init|=
block|{
literal|0
block|,
name|offsetof
argument_list|(
name|Elf32_Dyn
argument_list|,
name|d_tag
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Dyn
argument_list|,
name|d_un
operator|.
name|d_ptr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Dyn
argument_list|,
name|d_un
operator|.
name|d_val
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_machine
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_version
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_entry
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_phoff
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_shoff
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_flags
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_ehsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_phentsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_phnum
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_shentsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_shnum
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_shstrndx
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf_Note
argument_list|,
name|n_namesz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf_Note
argument_list|,
name|n_descsz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf_Note
argument_list|,
name|n_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_vaddr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_paddr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_filesz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_memsz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_flags
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Phdr
argument_list|,
name|p_align
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_name
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_flags
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_addr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_size
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_link
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_info
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_addralign
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Shdr
argument_list|,
name|sh_entsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Sym
argument_list|,
name|st_name
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Sym
argument_list|,
name|st_value
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Sym
argument_list|,
name|st_size
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Sym
argument_list|,
name|st_info
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Sym
argument_list|,
name|st_shndx
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Rel
argument_list|,
name|r_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Rel
argument_list|,
name|r_info
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Rela
argument_list|,
name|r_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Rela
argument_list|,
name|r_info
argument_list|)
block|,
name|offsetof
argument_list|(
argument|Elf32_Rela
argument_list|,
argument|r_addend
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|elf64_offsets
index|[]
init|=
block|{
literal|0
block|,
name|offsetof
argument_list|(
name|Elf64_Dyn
argument_list|,
name|d_tag
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Dyn
argument_list|,
name|d_un
operator|.
name|d_ptr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Dyn
argument_list|,
name|d_un
operator|.
name|d_val
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_ident
index|[
name|EI_CLASS
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_ident
index|[
name|EI_DATA
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf32_Ehdr
argument_list|,
name|e_ident
index|[
name|EI_OSABI
index|]
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_machine
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_version
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_entry
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_phoff
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_shoff
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_flags
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_ehsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_phentsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_phnum
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_shentsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_shnum
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Ehdr
argument_list|,
name|e_shstrndx
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf_Note
argument_list|,
name|n_namesz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf_Note
argument_list|,
name|n_descsz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf_Note
argument_list|,
name|n_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_vaddr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_paddr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_filesz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_memsz
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_flags
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Phdr
argument_list|,
name|p_align
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_name
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_type
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_flags
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_addr
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_size
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_link
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_info
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_addralign
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Shdr
argument_list|,
name|sh_entsize
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Sym
argument_list|,
name|st_name
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Sym
argument_list|,
name|st_value
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Sym
argument_list|,
name|st_size
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Sym
argument_list|,
name|st_info
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Sym
argument_list|,
name|st_shndx
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Rel
argument_list|,
name|r_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Rel
argument_list|,
name|r_info
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Rela
argument_list|,
name|r_offset
argument_list|)
block|,
name|offsetof
argument_list|(
name|Elf64_Rela
argument_list|,
name|r_info
argument_list|)
block|,
name|offsetof
argument_list|(
argument|Elf64_Rela
argument_list|,
argument|r_addend
argument_list|)
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#tag_encodings */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|d_tags
parameter_list|(
name|u_int64_t
name|tag
parameter_list|)
block|{
specifier|static
name|char
name|unknown_tag
index|[
literal|48
index|]
decl_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DT_NULL
case|:
return|return
literal|"DT_NULL"
return|;
case|case
name|DT_NEEDED
case|:
return|return
literal|"DT_NEEDED"
return|;
case|case
name|DT_PLTRELSZ
case|:
return|return
literal|"DT_PLTRELSZ"
return|;
case|case
name|DT_PLTGOT
case|:
return|return
literal|"DT_PLTGOT"
return|;
case|case
name|DT_HASH
case|:
return|return
literal|"DT_HASH"
return|;
case|case
name|DT_STRTAB
case|:
return|return
literal|"DT_STRTAB"
return|;
case|case
name|DT_SYMTAB
case|:
return|return
literal|"DT_SYMTAB"
return|;
case|case
name|DT_RELA
case|:
return|return
literal|"DT_RELA"
return|;
case|case
name|DT_RELASZ
case|:
return|return
literal|"DT_RELASZ"
return|;
case|case
name|DT_RELAENT
case|:
return|return
literal|"DT_RELAENT"
return|;
case|case
name|DT_STRSZ
case|:
return|return
literal|"DT_STRSZ"
return|;
case|case
name|DT_SYMENT
case|:
return|return
literal|"DT_SYMENT"
return|;
case|case
name|DT_INIT
case|:
return|return
literal|"DT_INIT"
return|;
case|case
name|DT_FINI
case|:
return|return
literal|"DT_FINI"
return|;
case|case
name|DT_SONAME
case|:
return|return
literal|"DT_SONAME"
return|;
case|case
name|DT_RPATH
case|:
return|return
literal|"DT_RPATH"
return|;
case|case
name|DT_SYMBOLIC
case|:
return|return
literal|"DT_SYMBOLIC"
return|;
case|case
name|DT_REL
case|:
return|return
literal|"DT_REL"
return|;
case|case
name|DT_RELSZ
case|:
return|return
literal|"DT_RELSZ"
return|;
case|case
name|DT_RELENT
case|:
return|return
literal|"DT_RELENT"
return|;
case|case
name|DT_PLTREL
case|:
return|return
literal|"DT_PLTREL"
return|;
case|case
name|DT_DEBUG
case|:
return|return
literal|"DT_DEBUG"
return|;
case|case
name|DT_TEXTREL
case|:
return|return
literal|"DT_TEXTREL"
return|;
case|case
name|DT_JMPREL
case|:
return|return
literal|"DT_JMPREL"
return|;
case|case
name|DT_BIND_NOW
case|:
return|return
literal|"DT_BIND_NOW"
return|;
case|case
name|DT_INIT_ARRAY
case|:
return|return
literal|"DT_INIT_ARRAY"
return|;
case|case
name|DT_FINI_ARRAY
case|:
return|return
literal|"DT_FINI_ARRAY"
return|;
case|case
name|DT_INIT_ARRAYSZ
case|:
return|return
literal|"DT_INIT_ARRAYSZ"
return|;
case|case
name|DT_FINI_ARRAYSZ
case|:
return|return
literal|"DT_FINI_ARRAYSZ"
return|;
case|case
name|DT_RUNPATH
case|:
return|return
literal|"DT_RUNPATH"
return|;
case|case
name|DT_FLAGS
case|:
return|return
literal|"DT_FLAGS"
return|;
case|case
name|DT_PREINIT_ARRAY
case|:
return|return
literal|"DT_PREINIT_ARRAY"
return|;
comment|/* XXX DT_ENCODING */
case|case
name|DT_PREINIT_ARRAYSZ
case|:
return|return
literal|"DT_PREINIT_ARRAYSZ"
return|;
comment|/* 0x6000000D - 0x6ffff000 operating system-specific semantics */
case|case
literal|0x6ffffdf5
case|:
return|return
literal|"DT_GNU_PRELINKED"
return|;
case|case
literal|0x6ffffdf6
case|:
return|return
literal|"DT_GNU_CONFLICTSZ"
return|;
case|case
literal|0x6ffffdf7
case|:
return|return
literal|"DT_GNU_LIBLISTSZ"
return|;
case|case
literal|0x6ffffdf8
case|:
return|return
literal|"DT_SUNW_CHECKSUM"
return|;
case|case
name|DT_PLTPADSZ
case|:
return|return
literal|"DT_PLTPADSZ"
return|;
case|case
name|DT_MOVEENT
case|:
return|return
literal|"DT_MOVEENT"
return|;
case|case
name|DT_MOVESZ
case|:
return|return
literal|"DT_MOVESZ"
return|;
case|case
name|DT_FEATURE
case|:
return|return
literal|"DT_FEATURE"
return|;
case|case
name|DT_POSFLAG_1
case|:
return|return
literal|"DT_POSFLAG_1"
return|;
case|case
name|DT_SYMINSZ
case|:
return|return
literal|"DT_SYMINSZ"
return|;
case|case
name|DT_SYMINENT
case|:
return|return
literal|"DT_SYMINENT (DT_VALRNGHI)"
return|;
case|case
name|DT_ADDRRNGLO
case|:
return|return
literal|"DT_ADDRRNGLO"
return|;
case|case
name|DT_GNU_HASH
case|:
return|return
literal|"DT_GNU_HASH"
return|;
case|case
literal|0x6ffffef8
case|:
return|return
literal|"DT_GNU_CONFLICT"
return|;
case|case
literal|0x6ffffef9
case|:
return|return
literal|"DT_GNU_LIBLIST"
return|;
case|case
name|DT_CONFIG
case|:
return|return
literal|"DT_CONFIG"
return|;
case|case
name|DT_DEPAUDIT
case|:
return|return
literal|"DT_DEPAUDIT"
return|;
case|case
name|DT_AUDIT
case|:
return|return
literal|"DT_AUDIT"
return|;
case|case
name|DT_PLTPAD
case|:
return|return
literal|"DT_PLTPAD"
return|;
case|case
name|DT_MOVETAB
case|:
return|return
literal|"DT_MOVETAB"
return|;
case|case
name|DT_SYMINFO
case|:
return|return
literal|"DT_SYMINFO (DT_ADDRRNGHI)"
return|;
case|case
name|DT_RELACOUNT
case|:
return|return
literal|"DT_RELACOUNT"
return|;
case|case
name|DT_RELCOUNT
case|:
return|return
literal|"DT_RELCOUNT"
return|;
case|case
name|DT_FLAGS_1
case|:
return|return
literal|"DT_FLAGS_1"
return|;
case|case
name|DT_VERDEF
case|:
return|return
literal|"DT_VERDEF"
return|;
case|case
name|DT_VERDEFNUM
case|:
return|return
literal|"DT_VERDEFNUM"
return|;
case|case
name|DT_VERNEED
case|:
return|return
literal|"DT_VERNEED"
return|;
case|case
name|DT_VERNEEDNUM
case|:
return|return
literal|"DT_VERNEEDNUM"
return|;
case|case
literal|0x6ffffff0
case|:
return|return
literal|"DT_GNU_VERSYM"
return|;
comment|/* 0x70000000 - 0x7fffffff processor-specific semantics */
case|case
literal|0x70000000
case|:
return|return
literal|"DT_IA_64_PLT_RESERVE"
return|;
case|case
literal|0x7ffffffd
case|:
return|return
literal|"DT_SUNW_AUXILIARY"
return|;
case|case
literal|0x7ffffffe
case|:
return|return
literal|"DT_SUNW_USED"
return|;
case|case
literal|0x7fffffff
case|:
return|return
literal|"DT_SUNW_FILTER"
return|;
block|}
name|snprintf
argument_list|(
name|unknown_tag
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown_tag
argument_list|)
argument_list|,
literal|"ERROR: TAG NOT DEFINED -- tag 0x%jx"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|tag
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_tag
operator|)
return|;
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|e_machines
parameter_list|(
name|u_int
name|mach
parameter_list|)
block|{
specifier|static
name|char
name|machdesc
index|[
literal|64
index|]
decl_stmt|;
switch|switch
condition|(
name|mach
condition|)
block|{
case|case
name|EM_NONE
case|:
return|return
literal|"EM_NONE"
return|;
case|case
name|EM_M32
case|:
return|return
literal|"EM_M32"
return|;
case|case
name|EM_SPARC
case|:
return|return
literal|"EM_SPARC"
return|;
case|case
name|EM_386
case|:
return|return
literal|"EM_386"
return|;
case|case
name|EM_68K
case|:
return|return
literal|"EM_68K"
return|;
case|case
name|EM_88K
case|:
return|return
literal|"EM_88K"
return|;
case|case
name|EM_IAMCU
case|:
return|return
literal|"EM_IAMCU"
return|;
case|case
name|EM_860
case|:
return|return
literal|"EM_860"
return|;
case|case
name|EM_MIPS
case|:
return|return
literal|"EM_MIPS"
return|;
case|case
name|EM_PPC
case|:
return|return
literal|"EM_PPC"
return|;
case|case
name|EM_PPC64
case|:
return|return
literal|"EM_PPC64"
return|;
case|case
name|EM_ARM
case|:
return|return
literal|"EM_ARM"
return|;
case|case
name|EM_ALPHA
case|:
return|return
literal|"EM_ALPHA (legacy)"
return|;
case|case
name|EM_SPARCV9
case|:
return|return
literal|"EM_SPARCV9"
return|;
case|case
name|EM_IA_64
case|:
return|return
literal|"EM_IA_64"
return|;
case|case
name|EM_X86_64
case|:
return|return
literal|"EM_X86_64"
return|;
case|case
name|EM_AARCH64
case|:
return|return
literal|"EM_AARCH64"
return|;
case|case
name|EM_RISCV
case|:
return|return
literal|"EM_RISCV"
return|;
block|}
name|snprintf
argument_list|(
name|machdesc
argument_list|,
sizeof|sizeof
argument_list|(
name|machdesc
argument_list|)
argument_list|,
literal|"(unknown machine) -- type 0x%x"
argument_list|,
name|mach
argument_list|)
expr_stmt|;
return|return
operator|(
name|machdesc
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|e_types
index|[]
init|=
block|{
literal|"ET_NONE"
block|,
literal|"ET_REL"
block|,
literal|"ET_EXEC"
block|,
literal|"ET_DYN"
block|,
literal|"ET_CORE"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ei_versions
index|[]
init|=
block|{
literal|"EV_NONE"
block|,
literal|"EV_CURRENT"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ei_classes
index|[]
init|=
block|{
literal|"ELFCLASSNONE"
block|,
literal|"ELFCLASS32"
block|,
literal|"ELFCLASS64"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ei_data
index|[]
init|=
block|{
literal|"ELFDATANONE"
block|,
literal|"ELFDATA2LSB"
block|,
literal|"ELFDATA2MSB"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|ei_abis
index|[
literal|256
index|]
init|=
block|{
literal|"ELFOSABI_NONE"
block|,
literal|"ELFOSABI_HPUX"
block|,
literal|"ELFOSABI_NETBSD"
block|,
literal|"ELFOSABI_LINUX"
block|,
literal|"ELFOSABI_HURD"
block|,
literal|"ELFOSABI_86OPEN"
block|,
literal|"ELFOSABI_SOLARIS"
block|,
literal|"ELFOSABI_AIX"
block|,
literal|"ELFOSABI_IRIX"
block|,
literal|"ELFOSABI_FREEBSD"
block|,
literal|"ELFOSABI_TRU64"
block|,
literal|"ELFOSABI_MODESTO"
block|,
literal|"ELFOSABI_OPENBSD"
block|,
index|[
literal|255
index|]
operator|=
literal|"ELFOSABI_STANDALONE"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|p_types
index|[]
init|=
block|{
literal|"PT_NULL"
block|,
literal|"PT_LOAD"
block|,
literal|"PT_DYNAMIC"
block|,
literal|"PT_INTERP"
block|,
literal|"PT_NOTE"
block|,
literal|"PT_SHLIB"
block|,
literal|"PT_PHDR"
block|,
literal|"PT_TLS"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|p_flags
index|[]
init|=
block|{
literal|""
block|,
literal|"PF_X"
block|,
literal|"PF_W"
block|,
literal|"PF_X|PF_W"
block|,
literal|"PF_R"
block|,
literal|"PF_X|PF_R"
block|,
literal|"PF_W|PF_R"
block|,
literal|"PF_X|PF_W|PF_R"
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* http://www.sco.com/developers/gabi/latest/ch4.sheader.html#sh_type */
end_comment

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|sh_types
parameter_list|(
name|uint64_t
name|machine
parameter_list|,
name|uint64_t
name|sht
parameter_list|)
block|{
specifier|static
name|char
name|unknown_buf
index|[
literal|64
index|]
decl_stmt|;
if|if
condition|(
name|sht
operator|<
literal|0x60000000
condition|)
block|{
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
name|SHT_NULL
case|:
return|return
literal|"SHT_NULL"
return|;
case|case
name|SHT_PROGBITS
case|:
return|return
literal|"SHT_PROGBITS"
return|;
case|case
name|SHT_SYMTAB
case|:
return|return
literal|"SHT_SYMTAB"
return|;
case|case
name|SHT_STRTAB
case|:
return|return
literal|"SHT_STRTAB"
return|;
case|case
name|SHT_RELA
case|:
return|return
literal|"SHT_RELA"
return|;
case|case
name|SHT_HASH
case|:
return|return
literal|"SHT_HASH"
return|;
case|case
name|SHT_DYNAMIC
case|:
return|return
literal|"SHT_DYNAMIC"
return|;
case|case
name|SHT_NOTE
case|:
return|return
literal|"SHT_NOTE"
return|;
case|case
name|SHT_NOBITS
case|:
return|return
literal|"SHT_NOBITS"
return|;
case|case
name|SHT_REL
case|:
return|return
literal|"SHT_REL"
return|;
case|case
name|SHT_SHLIB
case|:
return|return
literal|"SHT_SHLIB"
return|;
case|case
name|SHT_DYNSYM
case|:
return|return
literal|"SHT_DYNSYM"
return|;
case|case
name|SHT_INIT_ARRAY
case|:
return|return
literal|"SHT_INIT_ARRAY"
return|;
case|case
name|SHT_FINI_ARRAY
case|:
return|return
literal|"SHT_FINI_ARRAY"
return|;
case|case
name|SHT_PREINIT_ARRAY
case|:
return|return
literal|"SHT_PREINIT_ARRAY"
return|;
case|case
name|SHT_GROUP
case|:
return|return
literal|"SHT_GROUP"
return|;
case|case
name|SHT_SYMTAB_SHNDX
case|:
return|return
literal|"SHT_SYMTAB_SHNDX"
return|;
block|}
name|snprintf
argument_list|(
name|unknown_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown_buf
argument_list|)
argument_list|,
literal|"ERROR: SHT %ju NOT DEFINED"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sht
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_buf
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sht
operator|<
literal|0x70000000
condition|)
block|{
comment|/* 0x60000000-0x6fffffff operating system-specific semantics */
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
literal|0x6ffffff0
case|:
return|return
literal|"XXX:VERSYM"
return|;
case|case
name|SHT_SUNW_dof
case|:
return|return
literal|"SHT_SUNW_dof"
return|;
case|case
name|SHT_GNU_HASH
case|:
return|return
literal|"SHT_GNU_HASH"
return|;
case|case
literal|0x6ffffff7
case|:
return|return
literal|"SHT_GNU_LIBLIST"
return|;
case|case
literal|0x6ffffffc
case|:
return|return
literal|"XXX:VERDEF"
return|;
case|case
name|SHT_SUNW_verdef
case|:
return|return
literal|"SHT_SUNW(GNU)_verdef"
return|;
case|case
name|SHT_SUNW_verneed
case|:
return|return
literal|"SHT_SUNW(GNU)_verneed"
return|;
case|case
name|SHT_SUNW_versym
case|:
return|return
literal|"SHT_SUNW(GNU)_versym"
return|;
block|}
name|snprintf
argument_list|(
name|unknown_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown_buf
argument_list|)
argument_list|,
literal|"ERROR: OS-SPECIFIC SHT 0x%jx NOT DEFINED"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sht
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_buf
operator|)
return|;
block|}
elseif|else
if|if
condition|(
name|sht
operator|<
literal|0x80000000
condition|)
block|{
comment|/* 0x70000000-0x7fffffff processor-specific semantics */
switch|switch
condition|(
name|machine
condition|)
block|{
case|case
name|EM_ARM
case|:
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
name|SHT_ARM_EXIDX
case|:
return|return
literal|"SHT_ARM_EXIDX"
return|;
case|case
name|SHT_ARM_PREEMPTMAP
case|:
return|return
literal|"SHT_ARM_PREEMPTMAP"
return|;
case|case
name|SHT_ARM_ATTRIBUTES
case|:
return|return
literal|"SHT_ARM_ATTRIBUTES"
return|;
case|case
name|SHT_ARM_DEBUGOVERLAY
case|:
return|return
literal|"SHT_ARM_DEBUGOVERLAY"
return|;
case|case
name|SHT_ARM_OVERLAYSECTION
case|:
return|return
literal|"SHT_ARM_OVERLAYSECTION"
return|;
block|}
break|break;
case|case
name|EM_IA_64
case|:
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
literal|0x70000000
case|:
return|return
literal|"SHT_IA_64_EXT"
return|;
case|case
literal|0x70000001
case|:
return|return
literal|"SHT_IA_64_UNWIND"
return|;
block|}
break|break;
case|case
name|EM_MIPS
case|:
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
name|SHT_MIPS_REGINFO
case|:
return|return
literal|"SHT_MIPS_REGINFO"
return|;
case|case
name|SHT_MIPS_OPTIONS
case|:
return|return
literal|"SHT_MIPS_OPTIONS"
return|;
case|case
name|SHT_MIPS_ABIFLAGS
case|:
return|return
literal|"SHT_MIPS_ABIFLAGS"
return|;
block|}
break|break;
block|}
switch|switch
condition|(
name|sht
condition|)
block|{
case|case
literal|0x7ffffffd
case|:
return|return
literal|"XXX:AUXILIARY"
return|;
case|case
literal|0x7fffffff
case|:
return|return
literal|"XXX:FILTER"
return|;
block|}
name|snprintf
argument_list|(
name|unknown_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown_buf
argument_list|)
argument_list|,
literal|"ERROR: PROCESSOR-SPECIFIC SHT 0x%jx NOT DEFINED"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sht
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_buf
operator|)
return|;
block|}
else|else
block|{
comment|/* 0x80000000-0xffffffff application programs */
name|snprintf
argument_list|(
name|unknown_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|unknown_buf
argument_list|)
argument_list|,
literal|"ERROR: SHT 0x%jx NOT DEFINED"
argument_list|,
operator|(
name|uintmax_t
operator|)
name|sht
argument_list|)
expr_stmt|;
return|return
operator|(
name|unknown_buf
operator|)
return|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|sh_flags
index|[]
init|=
block|{
literal|""
block|,
literal|"SHF_WRITE"
block|,
literal|"SHF_ALLOC"
block|,
literal|"SHF_WRITE|SHF_ALLOC"
block|,
literal|"SHF_EXECINSTR"
block|,
literal|"SHF_WRITE|SHF_EXECINSTR"
block|,
literal|"SHF_ALLOC|SHF_EXECINSTR"
block|,
literal|"SHF_WRITE|SHF_ALLOC|SHF_EXECINSTR"
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|st_type
parameter_list|(
name|unsigned
name|int
name|mach
parameter_list|,
name|unsigned
name|int
name|type
parameter_list|)
block|{
specifier|static
name|char
name|s_type
index|[
literal|32
index|]
decl_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|STT_NOTYPE
case|:
return|return
literal|"STT_NOTYPE"
return|;
case|case
name|STT_OBJECT
case|:
return|return
literal|"STT_OBJECT"
return|;
case|case
name|STT_FUNC
case|:
return|return
literal|"STT_FUNC"
return|;
case|case
name|STT_SECTION
case|:
return|return
literal|"STT_SECTION"
return|;
case|case
name|STT_FILE
case|:
return|return
literal|"STT_FILE"
return|;
case|case
name|STT_COMMON
case|:
return|return
literal|"STT_COMMON"
return|;
case|case
name|STT_TLS
case|:
return|return
literal|"STT_TLS"
return|;
case|case
literal|13
case|:
if|if
condition|(
name|mach
operator|==
name|EM_SPARCV9
condition|)
return|return
literal|"STT_SPARC_REGISTER"
return|;
break|break;
block|}
name|snprintf
argument_list|(
name|s_type
argument_list|,
sizeof|sizeof
argument_list|(
name|s_type
argument_list|)
argument_list|,
literal|"<unknown: %#x>"
argument_list|,
name|type
argument_list|)
expr_stmt|;
return|return
operator|(
name|s_type
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|st_bindings
index|[]
init|=
block|{
literal|"STB_LOCAL"
block|,
literal|"STB_GLOBAL"
block|,
literal|"STB_WEAK"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|dynstr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|shstrtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|strtab
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|out
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|u_int64_t
name|elf_get_byte
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int64_t
name|elf_get_quarter
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_int64_t elf_get_half(Elf32_Ehdr *e, void *base, elf_member_t member);
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|u_int64_t
name|elf_get_word
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|u_int64_t
name|elf_get_quad
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_ehdr
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_phdr
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_shdr
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_symtab
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_dynamic
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_rel
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|r
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_rela
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|ra
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_interp
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_got
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_hash
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|elf_print_note
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/*  * Helpers for ELF files with shnum or shstrndx values that don't fit in the  * ELF header.  If the values are too large then an escape value is used to  * indicate that the actual value is found in one of section 0's fields.  */
end_comment

begin_function
specifier|static
name|uint64_t
name|elf_get_shnum
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|uint64_t
name|shnum
decl_stmt|;
name|shnum
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_SHNUM
argument_list|)
expr_stmt|;
if|if
condition|(
name|shnum
operator|==
literal|0
condition|)
name|shnum
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sh
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
return|return
name|shnum
return|;
block|}
end_function

begin_function
specifier|static
name|uint64_t
name|elf_get_shstrndx
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|uint64_t
name|shstrndx
decl_stmt|;
name|shstrndx
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_SHSTRNDX
argument_list|)
expr_stmt|;
if|if
condition|(
name|shstrndx
operator|==
name|SHN_XINDEX
condition|)
name|shstrndx
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sh
argument_list|,
name|SH_LINK
argument_list|)
expr_stmt|;
return|return
name|shstrndx
return|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|ac
parameter_list|,
name|char
modifier|*
modifier|*
name|av
parameter_list|)
block|{
name|cap_rights_t
name|rights
decl_stmt|;
name|u_int64_t
name|phoff
decl_stmt|;
name|u_int64_t
name|shoff
decl_stmt|;
name|u_int64_t
name|phentsize
decl_stmt|;
name|u_int64_t
name|phnum
decl_stmt|;
name|u_int64_t
name|shentsize
decl_stmt|;
name|u_int64_t
name|shnum
decl_stmt|;
name|u_int64_t
name|shstrndx
decl_stmt|;
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|name
decl_stmt|;
name|u_int64_t
name|type
decl_stmt|;
name|struct
name|stat
name|sb
decl_stmt|;
name|unsigned
name|long
name|cmd
decl_stmt|;
name|u_int
name|flags
decl_stmt|;
name|Elf32_Ehdr
modifier|*
name|e
decl_stmt|;
name|void
modifier|*
name|p
decl_stmt|;
name|void
modifier|*
name|sh
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|fd
decl_stmt|;
name|int
name|ch
decl_stmt|;
name|int
name|i
decl_stmt|;
name|out
operator|=
name|stdout
expr_stmt|;
name|flags
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|ac
argument_list|,
name|av
argument_list|,
literal|"acdeiGhnprsw:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'a'
case|:
name|flags
operator|=
name|ED_ALL
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|flags
operator||=
name|ED_SHDR
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flags
operator||=
name|ED_DYN
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|flags
operator||=
name|ED_EHDR
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|flags
operator||=
name|ED_INTERP
expr_stmt|;
break|break;
case|case
literal|'G'
case|:
name|flags
operator||=
name|ED_GOT
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|flags
operator||=
name|ED_HASH
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
name|flags
operator||=
name|ED_NOTE
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
name|flags
operator||=
name|ED_PHDR
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|flags
operator||=
name|ED_REL
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
name|flags
operator||=
name|ED_SYMTAB
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
operator|(
name|out
operator|=
name|fopen
argument_list|(
name|optarg
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_FSTAT
argument_list|,
name|CAP_WRITE
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_rights_limit
argument_list|(
name|fileno
argument_list|(
name|out
argument_list|)
argument_list|,
operator|&
name|rights
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to limit rights for %s"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|ac
operator|-=
name|optind
expr_stmt|;
name|av
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|ac
operator|==
literal|0
operator|||
name|flags
operator|==
literal|0
condition|)
name|usage
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
operator|*
name|av
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
operator|||
name|fstat
argument_list|(
name|fd
argument_list|,
operator|&
name|sb
argument_list|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_MMAP_R
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_rights_limit
argument_list|(
name|fd
argument_list|,
operator|&
name|rights
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to limit rights for %s"
argument_list|,
operator|*
name|av
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|STDIN_FILENO
argument_list|)
expr_stmt|;
name|cap_rights_init
argument_list|(
operator|&
name|rights
argument_list|,
name|CAP_FSTAT
argument_list|,
name|CAP_IOCTL
argument_list|,
name|CAP_WRITE
argument_list|)
expr_stmt|;
name|cmd
operator|=
name|TIOCGETA
expr_stmt|;
comment|/* required by isatty(3) in printf(3) */
if|if
condition|(
operator|(
name|cap_rights_limit
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|rights
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
operator|)
operator|||
operator|(
name|cap_ioctls_limit
argument_list|(
name|STDOUT_FILENO
argument_list|,
operator|&
name|cmd
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
operator|)
operator|||
operator|(
name|cap_rights_limit
argument_list|(
name|STDERR_FILENO
argument_list|,
operator|&
name|rights
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
operator|)
operator|||
operator|(
name|cap_ioctls_limit
argument_list|(
name|STDERR_FILENO
argument_list|,
operator|&
name|cmd
argument_list|,
literal|1
argument_list|)
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
operator|)
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to limit rights for stdout/stderr"
argument_list|)
expr_stmt|;
if|if
condition|(
name|cap_enter
argument_list|()
operator|<
literal|0
operator|&&
name|errno
operator|!=
name|ENOSYS
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"unable to enter capability mode"
argument_list|)
expr_stmt|;
name|e
operator|=
name|mmap
argument_list|(
name|NULL
argument_list|,
name|sb
operator|.
name|st_size
argument_list|,
name|PROT_READ
argument_list|,
name|MAP_SHARED
argument_list|,
name|fd
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|e
operator|==
name|MAP_FAILED
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|IS_ELF
argument_list|(
operator|*
operator|(
name|Elf32_Ehdr
operator|*
operator|)
name|e
argument_list|)
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"not an elf file"
argument_list|)
expr_stmt|;
name|phoff
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHOFF
argument_list|)
expr_stmt|;
name|shoff
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_SHOFF
argument_list|)
expr_stmt|;
name|phentsize
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHENTSIZE
argument_list|)
expr_stmt|;
name|phnum
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHNUM
argument_list|)
expr_stmt|;
name|shentsize
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_SHENTSIZE
argument_list|)
expr_stmt|;
name|p
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|phoff
expr_stmt|;
if|if
condition|(
name|shoff
operator|>
literal|0
condition|)
block|{
name|sh
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|shoff
expr_stmt|;
name|shnum
operator|=
name|elf_get_shnum
argument_list|(
name|e
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|shstrndx
operator|=
name|elf_get_shstrndx
argument_list|(
name|e
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sh
operator|+
name|shstrndx
operator|*
name|shentsize
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|shstrtab
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
block|}
else|else
block|{
name|sh
operator|=
name|NULL
expr_stmt|;
name|shnum
operator|=
literal|0
expr_stmt|;
name|shstrndx
operator|=
literal|0
expr_stmt|;
name|shstrtab
operator|=
name|NULL
expr_stmt|;
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sh
operator|+
name|i
operator|*
name|shentsize
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
operator|(
name|char
operator|*
operator|)
name|sh
operator|+
name|i
operator|*
name|shentsize
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|shstrtab
operator|+
name|name
argument_list|,
literal|".strtab"
argument_list|)
operator|==
literal|0
condition|)
name|strtab
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|shstrtab
operator|+
name|name
argument_list|,
literal|".dynstr"
argument_list|)
operator|==
literal|0
condition|)
name|dynstr
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
block|}
if|if
condition|(
name|flags
operator|&
name|ED_EHDR
condition|)
name|elf_print_ehdr
argument_list|(
name|e
argument_list|,
name|sh
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ED_PHDR
condition|)
name|elf_print_phdr
argument_list|(
name|e
argument_list|,
name|p
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ED_SHDR
condition|)
name|elf_print_shdr
argument_list|(
name|e
argument_list|,
name|sh
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|phnum
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|i
operator|*
name|phentsize
expr_stmt|;
name|type
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_TYPE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|PT_INTERP
case|:
if|if
condition|(
name|flags
operator|&
name|ED_INTERP
condition|)
name|elf_print_interp
argument_list|(
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|PT_NULL
case|:
case|case
name|PT_LOAD
case|:
case|case
name|PT_DYNAMIC
case|:
case|case
name|PT_NOTE
case|:
case|case
name|PT_SHLIB
case|:
case|case
name|PT_PHDR
case|:
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|sh
operator|+
name|i
operator|*
name|shentsize
expr_stmt|;
name|type
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_TYPE
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|SHT_SYMTAB
case|:
if|if
condition|(
name|flags
operator|&
name|ED_SYMTAB
condition|)
name|elf_print_symtab
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|strtab
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_DYNAMIC
case|:
if|if
condition|(
name|flags
operator|&
name|ED_DYN
condition|)
name|elf_print_dynamic
argument_list|(
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_RELA
case|:
if|if
condition|(
name|flags
operator|&
name|ED_REL
condition|)
name|elf_print_rela
argument_list|(
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_REL
case|:
if|if
condition|(
name|flags
operator|&
name|ED_REL
condition|)
name|elf_print_rel
argument_list|(
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_NOTE
case|:
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ED_NOTE
operator|&&
name|strcmp
argument_list|(
name|shstrtab
operator|+
name|name
argument_list|,
literal|".note.ABI-tag"
argument_list|)
operator|==
literal|0
condition|)
name|elf_print_note
argument_list|(
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_DYNSYM
case|:
if|if
condition|(
name|flags
operator|&
name|ED_SYMTAB
condition|)
name|elf_print_symtab
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|dynstr
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_PROGBITS
case|:
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
if|if
condition|(
name|flags
operator|&
name|ED_GOT
operator|&&
name|strcmp
argument_list|(
name|shstrtab
operator|+
name|name
argument_list|,
literal|".got"
argument_list|)
operator|==
literal|0
condition|)
name|elf_print_got
argument_list|(
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_HASH
case|:
if|if
condition|(
name|flags
operator|&
name|ED_HASH
condition|)
name|elf_print_hash
argument_list|(
name|e
argument_list|,
name|v
argument_list|)
expr_stmt|;
break|break;
case|case
name|SHT_NULL
case|:
case|case
name|SHT_STRTAB
case|:
case|case
name|SHT_NOBITS
case|:
case|case
name|SHT_SHLIB
case|:
break|break;
block|}
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_ehdr
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|u_int64_t
name|class
decl_stmt|;
name|u_int64_t
name|data
decl_stmt|;
name|u_int64_t
name|osabi
decl_stmt|;
name|u_int64_t
name|type
decl_stmt|;
name|u_int64_t
name|machine
decl_stmt|;
name|u_int64_t
name|version
decl_stmt|;
name|u_int64_t
name|entry
decl_stmt|;
name|u_int64_t
name|phoff
decl_stmt|;
name|u_int64_t
name|shoff
decl_stmt|;
name|u_int64_t
name|flags
decl_stmt|;
name|u_int64_t
name|ehsize
decl_stmt|;
name|u_int64_t
name|phentsize
decl_stmt|;
name|u_int64_t
name|phnum
decl_stmt|;
name|u_int64_t
name|shentsize
decl_stmt|;
name|u_int64_t
name|shnum
decl_stmt|;
name|u_int64_t
name|shstrndx
decl_stmt|;
name|class
operator|=
name|elf_get_byte
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_CLASS
argument_list|)
expr_stmt|;
name|data
operator|=
name|elf_get_byte
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_DATA
argument_list|)
expr_stmt|;
name|osabi
operator|=
name|elf_get_byte
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_OSABI
argument_list|)
expr_stmt|;
name|type
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_TYPE
argument_list|)
expr_stmt|;
name|machine
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_MACHINE
argument_list|)
expr_stmt|;
name|version
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_VERSION
argument_list|)
expr_stmt|;
name|entry
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_ENTRY
argument_list|)
expr_stmt|;
name|phoff
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHOFF
argument_list|)
expr_stmt|;
name|shoff
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_SHOFF
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_FLAGS
argument_list|)
expr_stmt|;
name|ehsize
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_EHSIZE
argument_list|)
expr_stmt|;
name|phentsize
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHENTSIZE
argument_list|)
expr_stmt|;
name|phnum
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHNUM
argument_list|)
expr_stmt|;
name|shentsize
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_SHENTSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nelf header:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_ident: %s %s %s\n"
argument_list|,
name|ei_classes
index|[
name|class
index|]
argument_list|,
name|ei_data
index|[
name|data
index|]
argument_list|,
name|ei_abis
index|[
name|osabi
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_type: %s\n"
argument_list|,
name|e_types
index|[
name|type
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_machine: %s\n"
argument_list|,
name|e_machines
argument_list|(
name|machine
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_version: %s\n"
argument_list|,
name|ei_versions
index|[
name|version
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_entry: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|entry
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_phoff: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|phoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_shoff: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|shoff
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_flags: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|flags
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_ehsize: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|ehsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_phentsize: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|phentsize
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_phnum: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|phnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_shentsize: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|shentsize
argument_list|)
expr_stmt|;
if|if
condition|(
name|sh
operator|!=
name|NULL
condition|)
block|{
name|shnum
operator|=
name|elf_get_shnum
argument_list|(
name|e
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|shstrndx
operator|=
name|elf_get_shstrndx
argument_list|(
name|e
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_shnum: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|shnum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\te_shstrndx: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|shstrndx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_phdr
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|u_int64_t
name|phentsize
decl_stmt|;
name|u_int64_t
name|phnum
decl_stmt|;
name|u_int64_t
name|type
decl_stmt|;
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|vaddr
decl_stmt|;
name|u_int64_t
name|paddr
decl_stmt|;
name|u_int64_t
name|filesz
decl_stmt|;
name|u_int64_t
name|memsz
decl_stmt|;
name|u_int64_t
name|flags
decl_stmt|;
name|u_int64_t
name|align
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|phentsize
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHENTSIZE
argument_list|)
expr_stmt|;
name|phnum
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_PHNUM
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nprogram header:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|phnum
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|p
operator|+
name|i
operator|*
name|phentsize
expr_stmt|;
name|type
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_TYPE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_OFFSET
argument_list|)
expr_stmt|;
name|vaddr
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_VADDR
argument_list|)
expr_stmt|;
name|paddr
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_PADDR
argument_list|)
expr_stmt|;
name|filesz
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_FILESZ
argument_list|)
expr_stmt|;
name|memsz
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_MEMSZ
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_FLAGS
argument_list|)
expr_stmt|;
name|align
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|P_ALIGN
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_type: %s\n"
argument_list|,
name|p_types
index|[
name|type
operator|&
literal|0x7
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_offset: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_vaddr: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|vaddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_paddr: %#jx\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|paddr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_filesz: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|filesz
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_memsz: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|memsz
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_flags: %s\n"
argument_list|,
name|p_flags
index|[
name|flags
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tp_align: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|align
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_shdr
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|u_int64_t
name|shentsize
decl_stmt|;
name|u_int64_t
name|shnum
decl_stmt|;
name|u_int64_t
name|name
decl_stmt|;
name|u_int64_t
name|type
decl_stmt|;
name|u_int64_t
name|flags
decl_stmt|;
name|u_int64_t
name|addr
decl_stmt|;
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|u_int64_t
name|shlink
decl_stmt|;
name|u_int64_t
name|info
decl_stmt|;
name|u_int64_t
name|addralign
decl_stmt|;
name|u_int64_t
name|entsize
decl_stmt|;
name|u_int64_t
name|machine
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
if|if
condition|(
name|sh
operator|==
name|NULL
condition|)
block|{
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nNo section headers\n"
argument_list|)
expr_stmt|;
return|return;
block|}
name|machine
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_MACHINE
argument_list|)
expr_stmt|;
name|shentsize
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_SHENTSIZE
argument_list|)
expr_stmt|;
name|shnum
operator|=
name|elf_get_shnum
argument_list|(
name|e
argument_list|,
name|sh
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nsection header:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|shnum
condition|;
name|i
operator|++
control|)
block|{
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|sh
operator|+
name|i
operator|*
name|shentsize
expr_stmt|;
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
name|type
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_TYPE
argument_list|)
expr_stmt|;
name|flags
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_FLAGS
argument_list|)
expr_stmt|;
name|addr
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_ADDR
argument_list|)
expr_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
name|shlink
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_LINK
argument_list|)
expr_stmt|;
name|info
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_INFO
argument_list|)
expr_stmt|;
name|addralign
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_ADDRALIGN
argument_list|)
expr_stmt|;
name|entsize
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|v
argument_list|,
name|SH_ENTSIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_name: %s\n"
argument_list|,
name|shstrtab
operator|+
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_type: %s\n"
argument_list|,
name|sh_types
argument_list|(
name|machine
argument_list|,
name|type
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_flags: %s\n"
argument_list|,
name|sh_flags
index|[
name|flags
operator|&
literal|0x7
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_addr: %#jx\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_offset: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_size: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_link: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|shlink
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_info: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|info
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_addralign: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|addralign
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tsh_entsize: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|entsize
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_symtab
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|,
name|char
modifier|*
name|str
parameter_list|)
block|{
name|u_int64_t
name|machine
decl_stmt|;
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|entsize
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|u_int64_t
name|name
decl_stmt|;
name|u_int64_t
name|value
decl_stmt|;
name|u_int64_t
name|info
decl_stmt|;
name|u_int64_t
name|shndx
decl_stmt|;
name|void
modifier|*
name|st
decl_stmt|;
name|int
name|len
decl_stmt|;
name|int
name|i
decl_stmt|;
name|machine
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|e
argument_list|,
name|E_MACHINE
argument_list|)
expr_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|entsize
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_ENTSIZE
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
name|len
operator|=
name|size
operator|/
name|entsize
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nsymbol table (%s):\n"
argument_list|,
name|shstrtab
operator|+
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|len
condition|;
name|i
operator|++
control|)
block|{
name|st
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
operator|+
name|i
operator|*
name|entsize
expr_stmt|;
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|st
argument_list|,
name|ST_NAME
argument_list|)
expr_stmt|;
name|value
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|st
argument_list|,
name|ST_VALUE
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|st
argument_list|,
name|ST_SIZE
argument_list|)
expr_stmt|;
name|info
operator|=
name|elf_get_byte
argument_list|(
name|e
argument_list|,
name|st
argument_list|,
name|ST_INFO
argument_list|)
expr_stmt|;
name|shndx
operator|=
name|elf_get_quarter
argument_list|(
name|e
argument_list|,
name|st
argument_list|,
name|ST_SHNDX
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tst_name: %s\n"
argument_list|,
name|str
operator|+
name|name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tst_value: %#jx\n"
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tst_size: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|size
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tst_info: %s %s\n"
argument_list|,
name|st_type
argument_list|(
name|machine
argument_list|,
name|ELF32_ST_TYPE
argument_list|(
name|info
argument_list|)
argument_list|)
argument_list|,
name|st_bindings
index|[
name|ELF32_ST_BIND
argument_list|(
name|info
argument_list|)
index|]
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tst_shndx: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|shndx
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_dynamic
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|entsize
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|int64_t
name|tag
decl_stmt|;
name|u_int64_t
name|ptr
decl_stmt|;
name|u_int64_t
name|val
decl_stmt|;
name|void
modifier|*
name|d
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|entsize
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_ENTSIZE
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\ndynamic:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|size
operator|/
name|entsize
condition|;
name|i
operator|++
control|)
block|{
name|d
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
operator|+
name|i
operator|*
name|entsize
expr_stmt|;
name|tag
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|d
argument_list|,
name|D_TAG
argument_list|)
expr_stmt|;
name|ptr
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|d
argument_list|,
name|D_PTR
argument_list|)
expr_stmt|;
name|val
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|d
argument_list|,
name|D_VAL
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\td_tag: %s\n"
argument_list|,
name|d_tags
argument_list|(
name|tag
argument_list|)
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|tag
condition|)
block|{
case|case
name|DT_NEEDED
case|:
case|case
name|DT_SONAME
case|:
case|case
name|DT_RPATH
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\td_val: %s\n"
argument_list|,
name|dynstr
operator|+
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTRELSZ
case|:
case|case
name|DT_RELA
case|:
case|case
name|DT_RELASZ
case|:
case|case
name|DT_RELAENT
case|:
case|case
name|DT_STRSZ
case|:
case|case
name|DT_SYMENT
case|:
case|case
name|DT_RELSZ
case|:
case|case
name|DT_RELENT
case|:
case|case
name|DT_PLTREL
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\td_val: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|val
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_PLTGOT
case|:
case|case
name|DT_HASH
case|:
case|case
name|DT_STRTAB
case|:
case|case
name|DT_SYMTAB
case|:
case|case
name|DT_INIT
case|:
case|case
name|DT_FINI
case|:
case|case
name|DT_REL
case|:
case|case
name|DT_JMPREL
case|:
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\td_ptr: %#jx\n"
argument_list|,
name|ptr
argument_list|)
expr_stmt|;
break|break;
case|case
name|DT_NULL
case|:
case|case
name|DT_SYMBOLIC
case|:
case|case
name|DT_DEBUG
case|:
case|case
name|DT_TEXTREL
case|:
break|break;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_rela
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|entsize
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|u_int64_t
name|name
decl_stmt|;
name|u_int64_t
name|info
decl_stmt|;
name|int64_t
name|addend
decl_stmt|;
name|void
modifier|*
name|ra
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|entsize
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_ENTSIZE
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nrelocation with addend (%s):\n"
argument_list|,
name|shstrtab
operator|+
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|size
operator|/
name|entsize
condition|;
name|i
operator|++
control|)
block|{
name|ra
operator|=
operator|(
name|char
operator|*
operator|)
name|v
operator|+
name|i
operator|*
name|entsize
expr_stmt|;
name|offset
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|ra
argument_list|,
name|RA_OFFSET
argument_list|)
expr_stmt|;
name|info
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|ra
argument_list|,
name|RA_INFO
argument_list|)
expr_stmt|;
name|addend
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|ra
argument_list|,
name|RA_ADDEND
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tr_offset: %#jx\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tr_info: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|info
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tr_addend: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|addend
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_rel
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|entsize
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|u_int64_t
name|name
decl_stmt|;
name|u_int64_t
name|info
decl_stmt|;
name|void
modifier|*
name|r
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|entsize
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_ENTSIZE
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nrelocation (%s):\n"
argument_list|,
name|shstrtab
operator|+
name|name
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|size
operator|/
name|entsize
condition|;
name|i
operator|++
control|)
block|{
name|r
operator|=
operator|(
name|char
operator|*
operator|)
name|v
operator|+
name|i
operator|*
name|entsize
expr_stmt|;
name|offset
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
name|r
argument_list|,
name|R_OFFSET
argument_list|)
expr_stmt|;
name|info
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|r
argument_list|,
name|R_INFO
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tr_offset: %#jx\n"
argument_list|,
name|offset
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\tr_info: %jd\n"
argument_list|,
operator|(
name|intmax_t
operator|)
name|info
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_interp
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|p
parameter_list|)
block|{
name|u_int64_t
name|offset
decl_stmt|;
name|char
modifier|*
name|s
decl_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|p
argument_list|,
name|P_OFFSET
argument_list|)
expr_stmt|;
name|s
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\ninterp:\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\t%s\n"
argument_list|,
name|s
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_got
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|addralign
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|u_int64_t
name|addr
decl_stmt|;
name|void
modifier|*
name|v
decl_stmt|;
name|int
name|i
decl_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|addralign
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_ADDRALIGN
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
name|v
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nglobal offset table:\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
operator|(
name|u_int64_t
operator|)
name|i
operator|<
name|size
operator|/
name|addralign
condition|;
name|i
operator|++
control|)
block|{
name|addr
operator|=
name|elf_get_addr
argument_list|(
name|e
argument_list|,
operator|(
name|char
operator|*
operator|)
name|v
operator|+
name|i
operator|*
name|addralign
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"entry: %d\n"
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\t%#jx\n"
argument_list|,
name|addr
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|elf_print_hash
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
name|__unused
parameter_list|,
name|void
modifier|*
name|sh
name|__unused
parameter_list|)
block|{ }
end_function

begin_function
specifier|static
name|void
name|elf_print_note
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|sh
parameter_list|)
block|{
name|u_int64_t
name|offset
decl_stmt|;
name|u_int64_t
name|size
decl_stmt|;
name|u_int64_t
name|name
decl_stmt|;
name|u_int32_t
name|namesz
decl_stmt|;
name|u_int32_t
name|descsz
decl_stmt|;
name|u_int32_t
name|desc
decl_stmt|;
name|char
modifier|*
name|n
decl_stmt|,
modifier|*
name|s
decl_stmt|;
name|offset
operator|=
name|elf_get_off
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_OFFSET
argument_list|)
expr_stmt|;
name|size
operator|=
name|elf_get_size
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_SIZE
argument_list|)
expr_stmt|;
name|name
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|sh
argument_list|,
name|SH_NAME
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\nnote (%s):\n"
argument_list|,
name|shstrtab
operator|+
name|name
argument_list|)
expr_stmt|;
while|while
condition|(
name|n
operator|<
operator|(
operator|(
name|char
operator|*
operator|)
name|e
operator|+
name|offset
operator|+
name|size
operator|)
condition|)
block|{
name|namesz
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|n
argument_list|,
name|N_NAMESZ
argument_list|)
expr_stmt|;
name|descsz
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|n
argument_list|,
name|N_DESCSZ
argument_list|)
expr_stmt|;
name|s
operator|=
name|n
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
expr_stmt|;
name|desc
operator|=
name|elf_get_word
argument_list|(
name|e
argument_list|,
name|n
operator|+
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
operator|+
name|namesz
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|out
argument_list|,
literal|"\t%s %d\n"
argument_list|,
name|s
argument_list|,
name|desc
argument_list|)
expr_stmt|;
name|n
operator|+=
sizeof|sizeof
argument_list|(
name|Elf_Note
argument_list|)
operator|+
name|namesz
operator|+
name|descsz
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|u_int64_t
name|elf_get_byte
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
block|{
name|u_int64_t
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELFCLASS32
case|:
name|val
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|base
operator|)
index|[
name|elf32_offsets
index|[
name|member
index|]
index|]
expr_stmt|;
break|break;
case|case
name|ELFCLASS64
case|:
name|val
operator|=
operator|(
operator|(
name|uint8_t
operator|*
operator|)
name|base
operator|)
index|[
name|elf64_offsets
index|[
name|member
index|]
index|]
expr_stmt|;
break|break;
case|case
name|ELFCLASSNONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid class"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|u_int64_t
name|elf_get_quarter
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
block|{
name|u_int64_t
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELFCLASS32
case|:
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|elf32_offsets
index|[
name|member
index|]
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
name|val
operator|=
name|be16dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATA2LSB
case|:
name|val
operator|=
name|le16dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATANONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid data format"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFCLASS64
case|:
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|elf64_offsets
index|[
name|member
index|]
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
name|val
operator|=
name|be16dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATA2LSB
case|:
name|val
operator|=
name|le16dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATANONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid data format"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFCLASSNONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid class"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static u_int64_t elf_get_half(Elf32_Ehdr *e, void *base, elf_member_t member) { 	u_int64_t val;  	val = 0; 	switch (e->e_ident[EI_CLASS]) { 	case ELFCLASS32: 		base = (char *)base + elf32_offsets[member]; 		switch (e->e_ident[EI_DATA]) { 		case ELFDATA2MSB: 			val = be16dec(base); 			break; 		case ELFDATA2LSB: 			val = le16dec(base); 			break; 		case ELFDATANONE: 			errx(1, "invalid data format"); 		} 		break; 	case ELFCLASS64: 		base = (char *)base + elf64_offsets[member]; 		switch (e->e_ident[EI_DATA]) { 		case ELFDATA2MSB: 			val = be32dec(base); 			break; 		case ELFDATA2LSB: 			val = le32dec(base); 			break; 		case ELFDATANONE: 			errx(1, "invalid data format"); 		} 		break; 	case ELFCLASSNONE: 		errx(1, "invalid class"); 	}  	return val; }
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|u_int64_t
name|elf_get_word
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
block|{
name|u_int64_t
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELFCLASS32
case|:
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|elf32_offsets
index|[
name|member
index|]
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
name|val
operator|=
name|be32dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATA2LSB
case|:
name|val
operator|=
name|le32dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATANONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid data format"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFCLASS64
case|:
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|elf64_offsets
index|[
name|member
index|]
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
name|val
operator|=
name|be32dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATA2LSB
case|:
name|val
operator|=
name|le32dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATANONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid data format"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFCLASSNONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid class"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|u_int64_t
name|elf_get_quad
parameter_list|(
name|Elf32_Ehdr
modifier|*
name|e
parameter_list|,
name|void
modifier|*
name|base
parameter_list|,
name|elf_member_t
name|member
parameter_list|)
block|{
name|u_int64_t
name|val
decl_stmt|;
name|val
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_CLASS
index|]
condition|)
block|{
case|case
name|ELFCLASS32
case|:
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|elf32_offsets
index|[
name|member
index|]
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
name|val
operator|=
name|be32dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATA2LSB
case|:
name|val
operator|=
name|le32dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATANONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid data format"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFCLASS64
case|:
name|base
operator|=
operator|(
name|char
operator|*
operator|)
name|base
operator|+
name|elf64_offsets
index|[
name|member
index|]
expr_stmt|;
switch|switch
condition|(
name|e
operator|->
name|e_ident
index|[
name|EI_DATA
index|]
condition|)
block|{
case|case
name|ELFDATA2MSB
case|:
name|val
operator|=
name|be64dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATA2LSB
case|:
name|val
operator|=
name|le64dec
argument_list|(
name|base
argument_list|)
expr_stmt|;
break|break;
case|case
name|ELFDATANONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid data format"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ELFCLASSNONE
case|:
name|errx
argument_list|(
literal|1
argument_list|,
literal|"invalid class"
argument_list|)
expr_stmt|;
block|}
return|return
name|val
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: elfdump -a | -cdeGhinprs [-w file] file\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

