begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* cut.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains function which manipulate the cut buffers. */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_if
if|#
directive|if
name|TURBOC
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_comment
comment|/* needed for getpid */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_include
include|#
directive|include
file|<osbind.h>
end_include

begin_define
define|#
directive|define
name|rename
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|Frename(0,a,b)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|NANONS
value|9
end_define

begin_comment
comment|/* number of anonymous buffers */
end_comment

begin_struct
specifier|static
struct|struct
name|cutbuf
block|{
name|short
modifier|*
name|phys
decl_stmt|;
comment|/* pointer to an array of #s of BLKs containing text */
name|int
name|nblks
decl_stmt|;
comment|/* number of blocks in phys[] array */
name|int
name|start
decl_stmt|;
comment|/* offset into first block of start of cut */
name|int
name|end
decl_stmt|;
comment|/* offset into last block of end of cut */
name|int
name|tmpnum
decl_stmt|;
comment|/* ID number of the temp file */
name|char
name|lnmode
decl_stmt|;
comment|/* boolean: line-mode cut? (as opposed to char-mode) */
block|}
name|named
index|[
literal|27
index|]
struct|,
comment|/* cut buffers "a through "z and ". */
name|anon
index|[
name|NANONS
index|]
struct|;
end_struct

begin_comment
comment|/* anonymous cut buffers */
end_comment

begin_decl_stmt
specifier|static
name|char
name|cbname
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name chosen for next cut/paste operation */
end_comment

begin_decl_stmt
specifier|static
name|char
name|dotcb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cut buffer to use if "doingdot" is set */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_RECYCLE
end_ifndef

begin_comment
comment|/* This function builds a list of all blocks needed in the current tmp file  * for the contents of cut buffers.  * !!! WARNING: if you have more than ~450000 bytes of text in all of the  * cut buffers, then this will fail disastrously, because buffer overflow  * is *not* allowed for.  */
end_comment

begin_function
name|int
name|cutneeds
parameter_list|(
name|need
parameter_list|)
name|BLK
modifier|*
name|need
decl_stmt|;
comment|/* this is where we deposit the list */
block|{
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
comment|/* used to count through cut buffers */
name|int
name|i
decl_stmt|;
comment|/* used to count through blocks of a cut buffer */
name|int
name|n
decl_stmt|;
comment|/* total number of blocks in list */
name|n
operator|=
literal|0
expr_stmt|;
comment|/* first the named buffers... */
for|for
control|(
name|cb
operator|=
name|named
init|;
name|cb
operator|<
operator|&
name|named
index|[
literal|27
index|]
condition|;
name|cb
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|tmpnum
operator|!=
name|tmpnum
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|cb
operator|->
name|nblks
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|need
operator|->
name|n
index|[
name|n
operator|++
index|]
operator|=
name|cb
operator|->
name|phys
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* then the anonymous buffers */
for|for
control|(
name|cb
operator|=
name|anon
init|;
name|cb
operator|<
operator|&
name|anon
index|[
name|NANONS
index|]
condition|;
name|cb
operator|++
control|)
block|{
if|if
condition|(
name|cb
operator|->
name|tmpnum
operator|!=
name|tmpnum
condition|)
continue|continue;
for|for
control|(
name|i
operator|=
name|cb
operator|->
name|nblks
init|;
name|i
operator|--
operator|>
literal|0
condition|;
control|)
block|{
name|need
operator|->
name|n
index|[
name|n
operator|++
index|]
operator|=
name|cb
operator|->
name|phys
index|[
name|i
index|]
expr_stmt|;
block|}
block|}
comment|/* return the length of the list */
return|return
name|n
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_function
specifier|static
name|void
name|maybezap
parameter_list|(
name|num
parameter_list|)
name|int
name|num
decl_stmt|;
comment|/* the tmpnum of the temporary file to [maybe] delete */
block|{
name|char
name|cutfname
index|[
literal|80
index|]
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* if this is the current tmp file, then we'd better keep it! */
if|if
condition|(
name|tmpfd
operator|>=
literal|0
operator|&&
name|num
operator|==
name|tmpnum
condition|)
block|{
return|return;
block|}
comment|/* see if anybody else needs this tmp file */
for|for
control|(
name|i
operator|=
literal|27
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|named
index|[
name|i
index|]
operator|.
name|nblks
operator|>
literal|0
operator|&&
name|named
index|[
name|i
index|]
operator|.
name|tmpnum
operator|==
name|num
condition|)
block|{
break|break;
block|}
block|}
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
name|NANONS
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
if|if
condition|(
name|anon
index|[
name|i
index|]
operator|.
name|nblks
operator|>
literal|0
operator|&&
name|anon
index|[
name|i
index|]
operator|.
name|tmpnum
operator|==
name|num
condition|)
block|{
break|break;
block|}
block|}
block|}
comment|/* if nobody else needs it, then discard the tmp file */
if|if
condition|(
name|i
operator|<
literal|0
condition|)
block|{
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|strcpy
argument_list|(
name|cutfname
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|cutfname
argument_list|)
operator|)
operator|&&
operator|!
name|strchr
argument_list|(
literal|":/\\"
argument_list|,
name|cutfname
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cutfname
index|[
name|i
operator|++
index|]
operator|=
name|SLASH
expr_stmt|;
name|sprintf
argument_list|(
name|cutfname
operator|+
name|i
argument_list|,
name|TMPNAME
operator|+
literal|3
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|num
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|cutfname
argument_list|,
name|TMPNAME
argument_list|,
name|o_directory
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|num
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|unlink
argument_list|(
name|cutfname
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function frees a cut buffer.  If it was the last cut buffer that  * refered to an old temp file, then it will delete the temp file. */
end_comment

begin_function
specifier|static
name|void
name|cutfree
parameter_list|(
name|buf
parameter_list|)
name|struct
name|cutbuf
modifier|*
name|buf
decl_stmt|;
block|{
name|int
name|num
decl_stmt|;
comment|/* return immediately if the buffer is already empty */
if|if
condition|(
name|buf
operator|->
name|nblks
operator|<=
literal|0
condition|)
block|{
return|return;
block|}
comment|/* else free up stuff */
name|num
operator|=
name|buf
operator|->
name|tmpnum
expr_stmt|;
name|buf
operator|->
name|nblks
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG
if|if
condition|(
operator|!
name|buf
operator|->
name|phys
condition|)
name|msg
argument_list|(
literal|"cutfree() tried to free a NULL buf->phys pointer."
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|free
argument_list|(
operator|(
name|char
operator|*
operator|)
name|buf
operator|->
name|phys
argument_list|)
expr_stmt|;
comment|/* maybe delete the temp file */
name|maybezap
argument_list|(
name|num
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is called when we are about to abort a tmp file.  *  * To minimize the number of extra files lying around, only named cut buffers  * are preserved in a file switch; the anonymous buffers just go away.  */
end_comment

begin_function
name|void
name|cutswitch
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* mark the current temp file as being "obsolete", and close it.  */
name|storename
argument_list|(
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tmpfd
argument_list|)
expr_stmt|;
name|tmpfd
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* discard all anonymous cut buffers */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|NANONS
condition|;
name|i
operator|++
control|)
block|{
name|cutfree
argument_list|(
operator|&
name|anon
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* delete the temp file, if we don't really need it */
name|maybezap
argument_list|(
name|tmpnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function should be called just before termination of vi */
end_comment

begin_function
name|void
name|cutend
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
comment|/* free the anonymous buffers, if they aren't already free */
name|cutswitch
argument_list|()
expr_stmt|;
comment|/* free all named cut buffers, since they might be forcing an older 	 * tmp file to be retained. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|27
condition|;
name|i
operator|++
control|)
block|{
name|cutfree
argument_list|(
operator|&
name|named
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* delete the temp file */
name|maybezap
argument_list|(
name|tmpnum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function is used to select the cut buffer to be used next */
end_comment

begin_function
name|void
name|cutname
parameter_list|(
name|name
parameter_list|)
name|int
name|name
decl_stmt|;
comment|/* a single character */
block|{
name|cbname
operator|=
name|name
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function copies a selected segment of text to a cut buffer */
end_comment

begin_function
name|void
name|cut
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|)
name|MARK
name|from
decl_stmt|;
comment|/* start of text to cut */
name|MARK
name|to
decl_stmt|;
comment|/* end of text to cut */
block|{
name|int
name|first
decl_stmt|;
comment|/* logical number of first block in cut */
name|int
name|last
decl_stmt|;
comment|/* logical number of last block used in cut */
name|long
name|line
decl_stmt|;
comment|/* a line number */
name|int
name|lnmode
decl_stmt|;
comment|/* boolean: will this be a line-mode cut? */
name|MARK
name|delthru
decl_stmt|;
comment|/* end of text temporarily inserted for apnd */
name|REG
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|REG
name|long
name|l
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
name|REG
name|char
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|blkc
decl_stmt|;
comment|/* detect whether this must be a line-mode cut or char-mode cut */
if|if
condition|(
name|markidx
argument_list|(
name|from
argument_list|)
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
name|lnmode
operator|=
name|TRUE
expr_stmt|;
else|else
name|lnmode
operator|=
name|FALSE
expr_stmt|;
comment|/* by default, we don't "delthru" anything */
name|delthru
operator|=
name|MARK_UNSET
expr_stmt|;
comment|/* handle the "doingdot" quirks */
if|if
condition|(
name|doingdot
condition|)
block|{
if|if
condition|(
operator|!
name|cbname
condition|)
block|{
name|cbname
operator|=
name|dotcb
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cbname
operator|!=
literal|'.'
condition|)
block|{
name|dotcb
operator|=
name|cbname
expr_stmt|;
block|}
comment|/* decide which cut buffer to use */
if|if
condition|(
operator|!
name|cbname
condition|)
block|{
comment|/* free up the last anonymous cut buffer */
name|cutfree
argument_list|(
operator|&
name|anon
index|[
name|NANONS
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
comment|/* shift the anonymous cut buffers */
for|for
control|(
name|i
operator|=
name|NANONS
operator|-
literal|1
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|anon
index|[
name|i
index|]
operator|=
name|anon
index|[
name|i
operator|-
literal|1
index|]
expr_stmt|;
block|}
comment|/* use the first anonymous cut buffer */
name|cb
operator|=
name|anon
expr_stmt|;
name|cb
operator|->
name|nblks
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'a'
operator|&&
name|cbname
operator|<=
literal|'z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'a'
index|]
expr_stmt|;
name|cutfree
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'A'
operator|&&
name|cbname
operator|<=
literal|'Z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'A'
index|]
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|nblks
operator|>
literal|0
condition|)
block|{
comment|/* resolve linemode/charmode differences */
if|if
condition|(
operator|!
name|lnmode
operator|&&
name|cb
operator|->
name|lnmode
condition|)
block|{
name|from
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|to
argument_list|)
operator|!=
literal|0
operator|||
name|to
operator|==
name|from
condition|)
block|{
name|to
operator|=
name|to
operator|+
name|BLKSIZE
operator|-
name|markidx
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
name|lnmode
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* insert the old cut-buffer before the new text */
name|mark
index|[
literal|28
index|]
operator|=
name|to
expr_stmt|;
name|delthru
operator|=
name|paste
argument_list|(
name|from
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|delthru
operator|==
name|MARK_UNSET
condition|)
block|{
return|return;
block|}
name|delthru
operator|++
expr_stmt|;
name|to
operator|=
name|mark
index|[
literal|28
index|]
expr_stmt|;
block|}
name|cutfree
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
elseif|else
if|if
condition|(
name|cbname
operator|==
literal|'.'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
literal|26
index|]
expr_stmt|;
name|cutfree
argument_list|(
name|cb
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Invalid cut buffer name: \"%c"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
name|dotcb
operator|=
name|cbname
operator|=
literal|'\0'
expr_stmt|;
return|return;
block|}
name|cbname
operator|=
literal|'\0'
expr_stmt|;
name|cb
operator|->
name|tmpnum
operator|=
name|tmpnum
expr_stmt|;
comment|/* detect whether we're doing a line mode cut */
name|cb
operator|->
name|lnmode
operator|=
name|lnmode
expr_stmt|;
comment|/* ---------- */
comment|/* Reporting... */
if|if
condition|(
name|markidx
argument_list|(
name|from
argument_list|)
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|to
argument_list|)
operator|==
literal|0
condition|)
block|{
name|rptlines
operator|=
name|markline
argument_list|(
name|to
argument_list|)
operator|-
name|markline
argument_list|(
name|from
argument_list|)
expr_stmt|;
name|rptlabel
operator|=
literal|"yanked"
expr_stmt|;
block|}
comment|/* ---------- */
comment|/* make sure each block has a physical disk address */
name|blksync
argument_list|()
expr_stmt|;
comment|/* find the first block in the cut */
name|line
operator|=
name|markline
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
name|first
operator|=
literal|1
init|;
name|line
operator|>
name|lnum
index|[
name|first
index|]
condition|;
name|first
operator|++
control|)
block|{ 	}
comment|/* fetch text of the block containing that line */
name|blkc
operator|=
name|scan
operator|=
name|blkget
argument_list|(
name|first
argument_list|)
operator|->
name|c
expr_stmt|;
comment|/* find the mark in the block */
for|for
control|(
name|l
operator|=
name|lnum
index|[
name|first
operator|-
literal|1
index|]
init|;
operator|++
name|l
operator|<
name|line
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|scan
operator|++
operator|!=
literal|'\n'
condition|)
block|{ 		}
block|}
name|scan
operator|+=
name|markidx
argument_list|(
name|from
argument_list|)
expr_stmt|;
comment|/* remember the offset of the start */
name|cb
operator|->
name|start
operator|=
name|scan
operator|-
name|blkc
expr_stmt|;
comment|/* ---------- */
comment|/* find the last block in the cut */
name|line
operator|=
name|markline
argument_list|(
name|to
argument_list|)
expr_stmt|;
for|for
control|(
name|last
operator|=
name|first
init|;
name|line
operator|>
name|lnum
index|[
name|last
index|]
condition|;
name|last
operator|++
control|)
block|{ 	}
comment|/* fetch text of the block containing that line */
if|if
condition|(
name|last
operator|!=
name|first
condition|)
block|{
name|blkc
operator|=
name|scan
operator|=
name|blkget
argument_list|(
name|last
argument_list|)
operator|->
name|c
expr_stmt|;
block|}
else|else
block|{
name|scan
operator|=
name|blkc
expr_stmt|;
block|}
comment|/* find the mark in the block */
for|for
control|(
name|l
operator|=
name|lnum
index|[
name|last
operator|-
literal|1
index|]
init|;
operator|++
name|l
operator|<
name|line
condition|;
control|)
block|{
while|while
condition|(
operator|*
name|scan
operator|++
operator|!=
literal|'\n'
condition|)
block|{ 		}
block|}
if|if
condition|(
name|markline
argument_list|(
name|to
argument_list|)
operator|<=
name|nlines
condition|)
block|{
name|scan
operator|+=
name|markidx
argument_list|(
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* remember the offset of the end */
name|cb
operator|->
name|end
operator|=
name|scan
operator|-
name|blkc
expr_stmt|;
comment|/* ------- */
comment|/* remember the physical block numbers of all included blocks */
name|cb
operator|->
name|nblks
operator|=
name|last
operator|-
name|first
expr_stmt|;
if|if
condition|(
name|cb
operator|->
name|end
operator|>
literal|0
condition|)
block|{
name|cb
operator|->
name|nblks
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|lint
name|cb
operator|->
name|phys
operator|=
operator|(
name|short
operator|*
operator|)
literal|0
expr_stmt|;
else|#
directive|else
name|cb
operator|->
name|phys
operator|=
operator|(
name|short
operator|*
operator|)
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|cb
operator|->
name|nblks
operator|*
sizeof|sizeof
argument_list|(
name|short
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cb
operator|->
name|nblks
condition|;
name|i
operator|++
control|)
block|{
name|cb
operator|->
name|phys
index|[
name|i
index|]
operator|=
name|hdr
operator|.
name|n
index|[
name|first
operator|++
index|]
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* if we temporarily inserted text for appending, then delete that 	 * text now -- before the user sees it. 	 */
if|if
condition|(
name|delthru
condition|)
block|{
name|line
operator|=
name|rptlines
expr_stmt|;
name|delete
argument_list|(
name|from
argument_list|,
name|delthru
argument_list|)
expr_stmt|;
name|rptlines
operator|=
name|line
expr_stmt|;
name|rptlabel
operator|=
literal|"yanked"
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
block|}
end_function

begin_function
specifier|static
name|void
name|readcutblk
parameter_list|(
name|cb
parameter_list|,
name|blkno
parameter_list|)
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|int
name|blkno
decl_stmt|;
block|{
name|char
name|cutfname
index|[
literal|50
index|]
decl_stmt|;
comment|/* name of an old temp file */
name|int
name|fd
decl_stmt|;
comment|/* either tmpfd or the result of open() */
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|int
name|i
decl_stmt|;
endif|#
directive|endif
comment|/* decide which fd to use */
if|if
condition|(
name|cb
operator|->
name|tmpnum
operator|==
name|tmpnum
condition|)
block|{
name|fd
operator|=
name|tmpfd
expr_stmt|;
block|}
else|else
block|{
if|#
directive|if
name|MSDOS
operator|||
name|TOS
name|strcpy
argument_list|(
name|cutfname
argument_list|,
name|o_directory
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|i
operator|=
name|strlen
argument_list|(
name|cutfname
argument_list|)
operator|)
operator|&&
operator|!
name|strchr
argument_list|(
literal|":/\\"
argument_list|,
name|cutfname
index|[
name|i
operator|-
literal|1
index|]
argument_list|)
condition|)
name|cutfname
index|[
name|i
operator|++
index|]
operator|=
name|SLASH
expr_stmt|;
name|sprintf
argument_list|(
name|cutfname
operator|+
name|i
argument_list|,
name|TMPNAME
operator|+
literal|3
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|cb
operator|->
name|tmpnum
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|cutfname
argument_list|,
name|TMPNAME
argument_list|,
name|o_directory
argument_list|,
name|getpid
argument_list|()
argument_list|,
name|cb
operator|->
name|tmpnum
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|fd
operator|=
name|open
argument_list|(
name|cutfname
argument_list|,
name|O_RDONLY
argument_list|)
expr_stmt|;
block|}
comment|/* get the block */
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|long
operator|)
name|cb
operator|->
name|phys
index|[
name|blkno
index|]
operator|*
operator|(
name|long
operator|)
name|BLKSIZE
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
operator|(
name|unsigned
operator|)
name|BLKSIZE
argument_list|)
operator|!=
name|BLKSIZE
condition|)
block|{
name|msg
argument_list|(
literal|"Error reading back from tmp file for pasting!"
argument_list|)
expr_stmt|;
block|}
comment|/* close the fd, if it isn't tmpfd */
if|if
condition|(
name|fd
operator|!=
name|tmpfd
condition|)
block|{
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function inserts text from a cut buffer, and returns the MARK where  * insertion ended.  Return MARK_UNSET on errors.  */
end_comment

begin_function
name|MARK
name|paste
parameter_list|(
name|at
parameter_list|,
name|after
parameter_list|,
name|retend
parameter_list|)
name|MARK
name|at
decl_stmt|;
comment|/* where to insert the text */
name|int
name|after
decl_stmt|;
comment|/* boolean: insert after mark? (rather than before) */
name|int
name|retend
decl_stmt|;
comment|/* boolean: return end of text? (rather than start) */
block|{
name|REG
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
comment|/* handle the "doingdot" quirks */
if|if
condition|(
name|doingdot
condition|)
block|{
if|if
condition|(
operator|!
name|cbname
condition|)
block|{
if|if
condition|(
name|dotcb
operator|>=
literal|'1'
operator|&&
name|dotcb
operator|<
literal|'1'
operator|+
name|NANONS
operator|-
literal|1
condition|)
block|{
name|dotcb
operator|++
expr_stmt|;
block|}
name|cbname
operator|=
name|dotcb
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|cbname
operator|!=
literal|'.'
condition|)
block|{
name|dotcb
operator|=
name|cbname
expr_stmt|;
block|}
comment|/* decide which cut buffer to use */
if|if
condition|(
name|cbname
operator|>=
literal|'A'
operator|&&
name|cbname
operator|<=
literal|'Z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'A'
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'a'
operator|&&
name|cbname
operator|<=
literal|'z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|cbname
operator|-
literal|'a'
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|>=
literal|'1'
operator|&&
name|cbname
operator|<=
literal|'9'
condition|)
block|{
name|cb
operator|=
operator|&
name|anon
index|[
name|cbname
operator|-
literal|'1'
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|cbname
operator|==
literal|'.'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
literal|26
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|cbname
condition|)
block|{
name|cb
operator|=
name|anon
expr_stmt|;
block|}
else|else
block|{
name|msg
argument_list|(
literal|"Invalid cut buffer name: \"%c"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
name|cbname
operator|=
literal|'\0'
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
comment|/* make sure it isn't empty */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|cbname
condition|)
name|msg
argument_list|(
literal|"Cut buffer \"%c is empty"
argument_list|,
name|cbname
argument_list|)
expr_stmt|;
else|else
name|msg
argument_list|(
literal|"Cut buffer is empty"
argument_list|)
expr_stmt|;
name|cbname
operator|=
literal|'\0'
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
name|cbname
operator|=
literal|'\0'
expr_stmt|;
comment|/* adjust the insertion MARK for "after" and line-mode cuts */
if|if
condition|(
name|cb
operator|->
name|lnmode
condition|)
block|{
name|at
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|after
condition|)
block|{
name|at
operator|+=
name|BLKSIZE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|after
condition|)
block|{
comment|/* careful! if markidx(at) == 0 we might be pasting into an 		 * empty line -- so we can't blindly increment "at". 		 */
if|if
condition|(
name|markidx
argument_list|(
name|at
argument_list|)
operator|==
literal|0
condition|)
block|{
name|pfetch
argument_list|(
name|markline
argument_list|(
name|at
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|!=
literal|0
condition|)
block|{
name|at
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|at
operator|++
expr_stmt|;
block|}
block|}
comment|/* put a copy of the "at" mark in the mark[] array, so it stays in 	 * sync with changes made via add(). 	 */
name|mark
index|[
literal|27
index|]
operator|=
name|at
expr_stmt|;
comment|/* simple one-block paste? */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|==
literal|1
condition|)
block|{
comment|/* get the block */
name|readcutblk
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* isolate the text we need within it */
if|if
condition|(
name|cb
operator|->
name|end
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* insert it */
name|ChangeText
block|{
name|add
argument_list|(
name|at
argument_list|,
operator|&
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|start
index|]
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* multi-block paste */
name|ChangeText
block|{
name|i
operator|=
name|cb
operator|->
name|nblks
operator|-
literal|1
expr_stmt|;
comment|/* add text from the last block first */
if|if
condition|(
name|cb
operator|->
name|end
operator|>
literal|0
condition|)
block|{
name|readcutblk
argument_list|(
name|cb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
name|add
argument_list|(
name|at
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
comment|/* add intervening blocks */
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|readcutblk
argument_list|(
name|cb
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|at
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|i
operator|--
expr_stmt|;
block|}
comment|/* add text from the first cut block */
name|readcutblk
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|add
argument_list|(
name|at
argument_list|,
operator|&
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|start
index|]
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Reporting... */
name|rptlines
operator|=
name|markline
argument_list|(
name|mark
index|[
literal|27
index|]
argument_list|)
operator|-
name|markline
argument_list|(
name|at
argument_list|)
expr_stmt|;
name|rptlabel
operator|=
literal|"pasted"
expr_stmt|;
comment|/* return the mark at the beginning/end of inserted text */
if|if
condition|(
name|retend
condition|)
block|{
return|return
name|mark
index|[
literal|27
index|]
operator|-
literal|1L
return|;
block|}
return|return
name|at
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AT
end_ifndef

begin_comment
comment|/* This function copies characters from a cut buffer into a string.  * It returns the number of characters in the cut buffer.  If the cut  * buffer is too large to fit in the string (i.e. if cb2str() returns  * a number>= size) then the characters will not have been copied.  * It returns 0 if the cut buffer is empty, and -1 for invalid cut buffers.  */
end_comment

begin_function
name|int
name|cb2str
parameter_list|(
name|name
parameter_list|,
name|buf
parameter_list|,
name|size
parameter_list|)
name|int
name|name
decl_stmt|;
comment|/* the name of a cut-buffer to get: a-z only! */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* where to put the string */
name|unsigned
name|size
decl_stmt|;
comment|/* size of buf */
block|{
name|REG
name|struct
name|cutbuf
modifier|*
name|cb
decl_stmt|;
name|REG
name|char
modifier|*
name|src
decl_stmt|;
name|REG
name|char
modifier|*
name|dest
decl_stmt|;
comment|/* decide which cut buffer to use */
if|if
condition|(
name|name
operator|>=
literal|'a'
operator|&&
name|name
operator|<=
literal|'z'
condition|)
block|{
name|cb
operator|=
operator|&
name|named
index|[
name|name
operator|-
literal|'a'
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
comment|/* if the buffer is empty, return 0 */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|==
literal|0
condition|)
block|{
return|return
literal|0
return|;
block|}
comment|/* !!! if not a single-block cut, then fail */
if|if
condition|(
name|cb
operator|->
name|nblks
operator|!=
literal|1
condition|)
block|{
return|return
name|size
return|;
block|}
comment|/* if too big, return the size now, without doing anything */
if|if
condition|(
name|cb
operator|->
name|end
operator|-
name|cb
operator|->
name|start
operator|>=
name|size
condition|)
block|{
return|return
name|cb
operator|->
name|end
operator|-
name|cb
operator|->
name|start
return|;
block|}
comment|/* get the block */
name|readcutblk
argument_list|(
name|cb
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* isolate the string within that blk */
if|if
condition|(
name|cb
operator|->
name|start
operator|==
literal|0
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|cb
operator|->
name|end
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|dest
operator|=
name|tmpblk
operator|.
name|c
operator|,
name|src
operator|=
name|dest
operator|+
name|cb
operator|->
name|start
init|;
name|src
operator|<
name|tmpblk
operator|.
name|c
operator|+
name|cb
operator|->
name|end
condition|;
control|)
block|{
operator|*
name|dest
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
operator|*
name|dest
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* copy the string into the buffer */
if|if
condition|(
name|buf
operator|!=
name|tmpblk
operator|.
name|c
condition|)
block|{
name|strcpy
argument_list|(
name|buf
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
comment|/* return the length */
return|return
name|cb
operator|->
name|end
operator|-
name|cb
operator|->
name|start
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

end_unit

