begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* curses.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the functions& variables needed for a tiny subset of  * curses.  The principle advantage of this version of curses is its  * extreme speed.  Disadvantages are potentially larger code, few supported  * functions, limited compatibility with full curses, and only stdscr.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_if
if|#
directive|if
name|ANY_UNIX
end_if

begin_if
if|#
directive|if
name|UNIXV
operator|||
name|COH_386
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_include
include|#
directive|include
file|<termios.h>
end_include

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<termio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_S5WINSIZE
end_ifndef

begin_ifndef
ifndef|#
directive|ifndef
name|_SEQUENT_
end_ifndef

begin_include
include|#
directive|include
file|<sys/stream.h>
end_include

begin_comment
comment|/* winsize struct defined in one of these? */
end_comment

begin_include
include|#
directive|include
file|<sys/ptem.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_undef
undef|#
directive|undef
name|TIOCGWINSZ
end_undef

begin_comment
comment|/* we can't handle it correctly yet */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_include
include|#
directive|include
file|<sgtty.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_include
include|#
directive|include
file|<osbind.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|OSK
end_if

begin_include
include|#
directive|include
file|<sgstat.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|VMS
end_if

begin_decl_stmt
specifier|extern
name|int
name|VMS_read_raw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Set in initscr() */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|void
name|starttcap
parameter_list|()
function_decl|;
end_function_decl

begin_comment
comment|/* variables, publicly available& used in the macros */
end_comment

begin_decl_stmt
name|char
modifier|*
name|termtype
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* name of terminal entry */
end_comment

begin_decl_stmt
name|short
name|ospeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* speed of the tty, eg B2400 */
end_comment

begin_if
if|#
directive|if
name|OSK
end_if

begin_decl_stmt
name|char
name|PC_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad char */
end_comment

begin_decl_stmt
name|char
modifier|*
name|BC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backspace character string */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
name|PC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pad char */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|WINDOW
modifier|*
name|stdscr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* pointer into kbuf[] */
end_comment

begin_decl_stmt
name|WINDOW
name|kbuf
index|[
name|KBSIZ
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* a very large output buffer */
end_comment

begin_decl_stmt
name|int
name|LINES
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :li#: number of rows */
end_comment

begin_decl_stmt
name|int
name|COLS
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :co#: number of columns */
end_comment

begin_decl_stmt
name|int
name|AM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :am:  boolean: auto margins? */
end_comment

begin_decl_stmt
name|int
name|PT
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :pt:  boolean: physical tabs? */
end_comment

begin_decl_stmt
name|char
modifier|*
name|VB
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :vb=: visible bell */
end_comment

begin_decl_stmt
name|char
modifier|*
name|UP
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :up=: move cursor up */
end_comment

begin_decl_stmt
name|char
modifier|*
name|SO
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :so=: standout start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|SE
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :se=: standout end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|US
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :us=: underline start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|UE
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ue=: underline end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|MD
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :md=: bold start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ME
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :me=: bold end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|AS
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :as=: alternate (italic) start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|AE
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ae=: alternate (italic) end */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_VISIBLE
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|MV
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :mv=: "visible" selection start */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|CM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cm=: cursor movement */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CE
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ce=: clear to end of line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cd=: clear to end of screen */
end_comment

begin_decl_stmt
name|char
modifier|*
name|AL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :al=: add a line */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :dl=: delete a line */
end_comment

begin_if
if|#
directive|if
name|OSK
end_if

begin_decl_stmt
name|char
modifier|*
name|SR_
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :sr=: scroll reverse */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|SR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :sr=: scroll reverse */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|KS
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ks=: switch keypad to application mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KE
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ke=: switch keypad to system mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ku=: key sequence sent by up arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :kd=: key sequence sent by down arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KL
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :kl=: key sequence sent by left arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KR
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :kr=: key sequence sent by right arrow */
end_comment

begin_decl_stmt
name|char
modifier|*
name|HM
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :HM=: key sequence sent by the<Home> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|EN
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :EN=: key sequence sent by the<End> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|PU
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :PU=: key sequence sent by the<PgUp> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|PD
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :PD=: key sequence sent by the<PgDn> key */
end_comment

begin_decl_stmt
name|char
modifier|*
name|KI
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :kI=: key sequence sent by the<Insert> key */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_FKEY
end_ifndef

begin_decl_stmt
name|char
modifier|*
name|FKEY
index|[
name|NFKEYS
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :k0=: ... :k9=: sequences sent by function keys */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|IM
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :im=: insert mode start */
end_comment

begin_decl_stmt
name|char
modifier|*
name|IC
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ic=: insert the following character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|EI
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ei=: insert mode end */
end_comment

begin_decl_stmt
name|char
modifier|*
name|DC
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :dc=: delete a character */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TI
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :ti=: terminal init */
end_comment

begin_comment
comment|/* GB */
end_comment

begin_decl_stmt
name|char
modifier|*
name|TE
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :te=: terminal exit */
end_comment

begin_comment
comment|/* GB */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
end_ifndef

begin_if
if|#
directive|if
literal|1
end_if

begin_decl_stmt
name|char
modifier|*
name|CQ
init|=
operator|(
name|char
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cQ=: normal cursor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CX
init|=
operator|(
name|char
operator|*
operator|)
literal|1
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cX=: cursor used for EX command/entry */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CV
init|=
operator|(
name|char
operator|*
operator|)
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cV=: cursor used for VI command mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CI
init|=
operator|(
name|char
operator|*
operator|)
literal|3
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cI=: cursor used for VI input mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CR
init|=
operator|(
name|char
operator|*
operator|)
literal|4
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cR=: cursor used for VI replace mode */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
name|char
modifier|*
name|CQ
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cQ=: normal cursor */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CX
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cX=: cursor used for EX command/entry */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CV
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cV=: cursor used for VI command mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CI
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cI=: cursor used for VI input mode */
end_comment

begin_decl_stmt
name|char
modifier|*
name|CR
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* :cR=: cursor used for VI replace mode */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|char
modifier|*
name|aend
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end an attribute -- either UE or ME */
end_comment

begin_decl_stmt
name|char
name|ERASEKEY
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* backspace key taken from ioctl structure */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COLOR
end_ifndef

begin_decl_stmt
name|char
name|normalcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|SOcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|SEcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|UScolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|UEcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|MDcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|MEcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|AScolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|AEcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|NO_POPUP
end_ifndef

begin_decl_stmt
name|char
name|POPUPcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_VISIBLE
end_ifndef

begin_decl_stmt
name|char
name|VISIBLEcolor
index|[
literal|24
index|]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|ANY_UNIX
end_if

begin_if
if|#
directive|if
name|UNIXV
operator|||
name|COH_386
end_if

begin_ifdef
ifdef|#
directive|ifdef
name|TERMIOS
end_ifdef

begin_decl_stmt
specifier|static
name|struct
name|termios
name|oldtermio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original tty mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termios
name|newtermio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cbreak/noecho tty mode */
end_comment

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|termio
name|oldtermio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original tty mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|termio
name|newtermio
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cbreak/noecho tty mode */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|oldsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* original tty mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgttyb
name|newsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* cbreak/nl/noecho tty mode */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldint
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^C or DEL, the "intr" character */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|TIOCSLTC
end_ifdef

begin_decl_stmt
specifier|static
name|int
name|oldswitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^Z, the "suspend" character */
end_comment

begin_decl_stmt
specifier|static
name|int
name|olddswitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^Y, the "delayed suspend" char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|oldquote
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* ^V, the "quote next char" char */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|OSK
end_if

begin_decl_stmt
specifier|static
name|struct
name|sgbuf
name|oldsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* orginal tty mode */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|sgbuf
name|newsgttyb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* noecho tty mode */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
modifier|*
name|capbuf
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* capability string buffer */
end_comment

begin_comment
comment|/* Initialize the Curses package. */
end_comment

begin_function
name|void
name|initscr
parameter_list|()
block|{
comment|/* make sure TERM variable is set */
name|termtype
operator|=
name|getenv
argument_list|(
literal|"TERM"
argument_list|)
expr_stmt|;
if|#
directive|if
name|VMS
comment|/* VMS getenv() handles TERM as a environment setting.  Foreign  	 * terminal support can be implemented by setting the ELVIS_TERM 	 * logical or symbol to match a tinytcap entry. 	 */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|termtype
argument_list|,
literal|"unknown"
argument_list|)
condition|)
name|termtype
operator|=
name|getenv
argument_list|(
literal|"ELVIS_TERM"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS
comment|/* For MS-DOS, if TERM is unset we can default to "pcbios", or 	 * maybe "rainbow". 	 */
if|if
condition|(
operator|!
name|termtype
condition|)
block|{
ifdef|#
directive|ifdef
name|RAINBOW
if|if
condition|(
operator|*
operator|(
name|unsigned
name|char
name|far
operator|*
operator|)
operator|(
literal|0xffff000eL
operator|)
operator|==
literal|6
comment|/* Rainbow 100a */
operator|||
operator|*
operator|(
name|unsigned
name|char
name|far
operator|*
operator|)
operator|(
literal|0xffff000eL
operator|)
operator|==
literal|148
condition|)
comment|/* Rainbow 100b */
block|{
name|termtype
operator|=
literal|"rainbow"
expr_stmt|;
block|}
else|else
endif|#
directive|endif
name|termtype
operator|=
literal|"pcbios"
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|termtype
argument_list|,
literal|"pcbios"
argument_list|)
condition|)
else|#
directive|else
if|if
condition|(
operator|!
name|termtype
condition|)
endif|#
directive|endif
block|{
if|#
directive|if
name|ANY_UNIX
name|write
argument_list|(
literal|2
argument_list|,
literal|"Environment variable TERM must be set\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|38
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|OSK
name|writeln
argument_list|(
literal|2
argument_list|,
literal|"Environment variable TERM must be set\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|38
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|AMIGA
name|termtype
operator|=
name|TERMTYPE
expr_stmt|;
name|starttcap
argument_list|(
name|termtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS
name|starttcap
argument_list|(
literal|"pcbios"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|TOS
name|termtype
operator|=
literal|"vt52"
expr_stmt|;
name|starttcap
argument_list|(
name|termtype
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VMS
name|write
argument_list|(
literal|2
argument_list|,
literal|"UNKNOWN terminal: define ELVIS_TERM\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|36
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
if|#
directive|if
name|MSDOS
operator|*
name|o_pcbios
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
comment|/* start termcap stuff */
name|starttcap
argument_list|(
name|termtype
argument_list|)
expr_stmt|;
block|}
comment|/* create stdscr and curscr */
name|stdscr
operator|=
name|kbuf
expr_stmt|;
comment|/* change the terminal mode to cbreak/noecho */
if|#
directive|if
name|ANY_UNIX
if|#
directive|if
name|UNIXV
operator|||
name|COH_386
ifdef|#
directive|ifdef
name|TERMIOS
name|tcgetattr
argument_list|(
literal|2
argument_list|,
operator|&
name|oldtermio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCGETA
argument_list|,
operator|&
name|oldtermio
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETP
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|OSK
name|_gs_opt
argument_list|(
literal|0
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VMS
name|VMS_read_raw
operator|=
literal|1
expr_stmt|;
comment|/* cbreak/noecho */
name|vms_open_tty
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|resume_curses
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Shut down the Curses package. */
end_comment

begin_function
name|void
name|endwin
parameter_list|()
block|{
comment|/* change the terminal mode back the way it was */
name|suspend_curses
argument_list|()
expr_stmt|;
if|#
directive|if
name|AMIGA
name|amiclosewin
argument_list|()
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|curses_active
init|=
name|FALSE
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|int
name|oldcurs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Send any required termination strings.  Turn off "raw" mode. */
end_comment

begin_function
name|void
name|suspend_curses
parameter_list|()
block|{
if|#
directive|if
name|ANY_UNIX
operator|&&
operator|!
operator|(
name|UNIXV
operator|||
name|COH_386
operator|)
name|struct
name|tchars
name|tbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|struct
name|ltchars
name|ltbuf
decl_stmt|;
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
if|if
condition|(
name|has_CQ
condition|)
block|{
name|do_CQ
argument_list|()
expr_stmt|;
name|oldcurs
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|has_TE
condition|)
comment|/* GB */
block|{
name|do_TE
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|has_KE
condition|)
block|{
name|do_KE
argument_list|()
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_COLOR
name|quitcolor
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|refresh
argument_list|()
expr_stmt|;
comment|/* change the terminal mode back the way it was */
if|#
directive|if
name|ANY_UNIX
if|#
directive|if
operator|(
name|UNIXV
operator|||
name|COH_386
operator|)
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
literal|2
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|oldtermio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|oldtermio
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|tbuf
argument_list|)
expr_stmt|;
name|tbuf
operator|.
name|t_intrc
operator|=
name|oldint
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETC
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
name|ltbuf
operator|.
name|t_suspc
operator|=
name|oldswitch
expr_stmt|;
name|ltbuf
operator|.
name|t_dsuspc
operator|=
name|olddswitch
expr_stmt|;
name|ltbuf
operator|.
name|t_lnextc
operator|=
name|oldquote
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|OSK
name|_ss_opt
argument_list|(
literal|0
argument_list|,
operator|&
name|oldsgttyb
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|AMIGA
name|ttyshutdown
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS
name|raw_set_stdio
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VMS
name|VMS_read_raw
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
name|curses_active
operator|=
name|FALSE
expr_stmt|;
block|}
end_function

begin_comment
comment|/* put the terminal in RAW mode.  If "quietly" is FALSE, then ask the user  * to hit a key, and wait for keystroke before returning.  */
end_comment

begin_function
name|void
name|resume_curses
parameter_list|(
name|quietly
parameter_list|)
name|int
name|quietly
decl_stmt|;
block|{
if|if
condition|(
operator|!
name|curses_active
condition|)
block|{
comment|/* change the terminal mode to cbreak/noecho */
if|#
directive|if
name|ANY_UNIX
if|#
directive|if
name|UNIXV
operator|||
name|COH_386
name|ospeed
operator|=
operator|(
name|oldtermio
operator|.
name|c_cflag
operator|&
name|CBAUD
operator|)
expr_stmt|;
name|ERASEKEY
operator|=
name|oldtermio
operator|.
name|c_cc
index|[
name|VERASE
index|]
expr_stmt|;
name|newtermio
operator|=
name|oldtermio
expr_stmt|;
name|newtermio
operator|.
name|c_iflag
operator|&=
operator|(
name|IXON
operator||
name|IXOFF
operator||
name|IXANY
operator||
name|ISTRIP
operator||
name|IGNBRK
operator|)
expr_stmt|;
name|newtermio
operator|.
name|c_oflag
operator|&=
operator|~
name|OPOST
expr_stmt|;
name|newtermio
operator|.
name|c_lflag
operator|&=
name|ISIG
expr_stmt|;
name|newtermio
operator|.
name|c_cc
index|[
name|VINTR
index|]
operator|=
name|ctrl
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
comment|/* always use ^C for interrupts */
name|newtermio
operator|.
name|c_cc
index|[
name|VMIN
index|]
operator|=
literal|1
expr_stmt|;
name|newtermio
operator|.
name|c_cc
index|[
name|VTIME
index|]
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|VSWTCH
name|newtermio
operator|.
name|c_cc
index|[
name|VSWTCH
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|VSUSP
name|newtermio
operator|.
name|c_cc
index|[
name|VSUSP
index|]
operator|=
literal|0
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|TERMIOS
name|tcsetattr
argument_list|(
literal|2
argument_list|,
name|TCSADRAIN
argument_list|,
operator|&
name|newtermio
argument_list|)
expr_stmt|;
else|#
directive|else
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TCSETAW
argument_list|,
operator|&
name|newtermio
argument_list|)
expr_stmt|;
endif|#
directive|endif
else|#
directive|else
comment|/* BSD, V7, Coherent-286, or Minix */
name|struct
name|tchars
name|tbuf
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|struct
name|ltchars
name|ltbuf
decl_stmt|;
endif|#
directive|endif
name|ospeed
operator|=
name|oldsgttyb
operator|.
name|sg_ospeed
expr_stmt|;
name|ERASEKEY
operator|=
name|oldsgttyb
operator|.
name|sg_erase
expr_stmt|;
name|newsgttyb
operator|=
name|oldsgttyb
expr_stmt|;
name|newsgttyb
operator|.
name|sg_flags
operator||=
name|CBREAK
expr_stmt|;
name|newsgttyb
operator|.
name|sg_flags
operator|&=
operator|~
operator|(
name|CRMOD
operator||
name|ECHO
operator||
name|XTABS
operator|)
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETP
argument_list|,
operator|&
name|newsgttyb
argument_list|)
expr_stmt|;
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGETC
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|tbuf
argument_list|)
expr_stmt|;
name|oldint
operator|=
name|tbuf
operator|.
name|t_intrc
expr_stmt|;
name|tbuf
operator|.
name|t_intrc
operator|=
name|ctrl
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
comment|/* always use ^C for interrupts */
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSETC
argument_list|,
operator|(
expr|struct
name|sgttyb
operator|*
operator|)
operator|&
name|tbuf
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCSLTC
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
name|oldswitch
operator|=
name|ltbuf
operator|.
name|t_suspc
expr_stmt|;
name|ltbuf
operator|.
name|t_suspc
operator|=
literal|0
expr_stmt|;
comment|/* disable ^Z for elvis */
name|olddswitch
operator|=
name|ltbuf
operator|.
name|t_dsuspc
expr_stmt|;
name|ltbuf
operator|.
name|t_dsuspc
operator|=
literal|0
expr_stmt|;
comment|/* disable ^Y for elvis */
name|oldquote
operator|=
name|ltbuf
operator|.
name|t_lnextc
expr_stmt|;
name|ltbuf
operator|.
name|t_lnextc
operator|=
literal|0
expr_stmt|;
comment|/* disable ^V for elvis */
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCSLTC
argument_list|,
operator|&
name|ltbuf
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
if|#
directive|if
name|OSK
name|newsgttyb
operator|=
name|oldsgttyb
expr_stmt|;
name|newsgttyb
operator|.
name|sg_echo
operator|=
literal|0
expr_stmt|;
name|newsgttyb
operator|.
name|sg_eofch
operator|=
literal|0
expr_stmt|;
name|newsgttyb
operator|.
name|sg_kbach
operator|=
literal|0
expr_stmt|;
name|newsgttyb
operator|.
name|sg_kbich
operator|=
name|ctrl
argument_list|(
literal|'C'
argument_list|)
expr_stmt|;
name|_ss_opt
argument_list|(
literal|0
argument_list|,
operator|&
name|newsgttyb
argument_list|)
expr_stmt|;
name|ospeed
operator|=
name|oldsgttyb
operator|.
name|sg_baud
expr_stmt|;
name|ERASEKEY
operator|=
name|oldsgttyb
operator|.
name|sg_bspch
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|AMIGA
comment|/* turn on window resize and RAW */
name|ttysetup
argument_list|()
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|MSDOS
name|raw_set_stdio
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|#
directive|if
name|VMS
name|VMS_read_raw
operator|=
literal|1
expr_stmt|;
block|{
name|int
name|c
decl_stmt|;
name|read
argument_list|(
literal|0
argument_list|,
operator|&
name|c
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* Flush the tty buffer. */
block|}
name|ERASEKEY
operator|=
literal|'\177'
expr_stmt|;
comment|/* Accept<DEL> as<^H> for VMS */
endif|#
directive|endif
name|curses_active
operator|=
name|TRUE
expr_stmt|;
block|}
comment|/* If we're supposed to quit quietly, then we're done */
if|if
condition|(
name|quietly
condition|)
block|{
if|if
condition|(
name|has_TI
condition|)
comment|/* GB */
block|{
name|do_TI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|has_KS
condition|)
block|{
name|do_KS
argument_list|()
expr_stmt|;
block|}
return|return;
block|}
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|do_SO
argument_list|()
expr_stmt|;
if|#
directive|if
name|VMS
name|qaddstr
argument_list|(
literal|"\n[Press<RETURN> to continue]"
argument_list|)
expr_stmt|;
else|#
directive|else
name|qaddstr
argument_list|(
literal|"[Press<RETURN> to continue]"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|do_SE
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|ttyread
argument_list|(
name|kbuf
argument_list|,
literal|20
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* in RAW mode, so<20 is very likely */
if|if
condition|(
name|has_TI
condition|)
block|{
name|do_TI
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|kbuf
index|[
literal|0
index|]
operator|==
literal|':'
condition|)
block|{
name|mode
operator|=
name|MODE_COLON
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|mode
operator|=
name|MODE_VI
expr_stmt|;
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|exwrote
operator|=
name|FALSE
expr_stmt|;
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|trapint
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function fetches an optional string from termcap */
end_comment

begin_function
specifier|static
name|void
name|mayhave
parameter_list|(
name|T
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|T
decl_stmt|;
comment|/* where to store the returned pointer */
name|char
modifier|*
name|s
decl_stmt|;
comment|/* name of the capability */
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|val
operator|=
name|tgetstr
argument_list|(
name|s
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|val
condition|)
block|{
operator|*
name|T
operator|=
name|val
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function fetches a required string from termcap */
end_comment

begin_function
specifier|static
name|void
name|musthave
parameter_list|(
name|T
parameter_list|,
name|s
parameter_list|)
name|char
modifier|*
modifier|*
name|T
decl_stmt|;
comment|/* where to store the returned pointer */
name|char
modifier|*
name|s
decl_stmt|;
comment|/* name of the capability */
block|{
name|mayhave
argument_list|(
name|T
argument_list|,
name|s
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|T
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"This termcap entry lacks the :"
argument_list|,
operator|(
name|unsigned
operator|)
literal|30
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
name|s
argument_list|,
operator|(
name|unsigned
operator|)
literal|2
argument_list|)
expr_stmt|;
name|write
argument_list|(
literal|2
argument_list|,
literal|"=: capability\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|14
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function fetches a pair of strings from termcap.  If one of them is  * missing, then the other one is ignored.  */
end_comment

begin_function
specifier|static
name|void
name|pair
parameter_list|(
name|T
parameter_list|,
name|U
parameter_list|,
name|sT
parameter_list|,
name|sU
parameter_list|)
name|char
modifier|*
modifier|*
name|T
decl_stmt|;
comment|/* where to store the first pointer */
name|char
modifier|*
modifier|*
name|U
decl_stmt|;
comment|/* where to store the second pointer */
name|char
modifier|*
name|sT
decl_stmt|;
comment|/* name of the first capability */
name|char
modifier|*
name|sU
decl_stmt|;
comment|/* name of the second capability */
block|{
name|mayhave
argument_list|(
name|T
argument_list|,
name|sT
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
name|U
argument_list|,
name|sU
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
operator|*
name|T
operator|||
operator|!
operator|*
operator|*
name|U
condition|)
block|{
operator|*
name|T
operator|=
operator|*
name|U
operator|=
literal|""
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Read everything from termcap */
end_comment

begin_function
specifier|static
name|void
name|starttcap
parameter_list|(
name|term
parameter_list|)
name|char
modifier|*
name|term
decl_stmt|;
block|{
specifier|static
name|char
name|cbmem
index|[
literal|800
index|]
decl_stmt|;
comment|/* allocate memory for capbuf */
name|capbuf
operator|=
name|cbmem
expr_stmt|;
comment|/* get the termcap entry */
switch|switch
condition|(
name|tgetent
argument_list|(
name|kbuf
argument_list|,
name|term
argument_list|)
condition|)
block|{
case|case
operator|-
literal|1
case|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"Can't read /etc/termcap\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|24
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
case|case
literal|0
case|:
name|write
argument_list|(
literal|2
argument_list|,
literal|"Unrecognized TERM type\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|23
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|exit
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
comment|/* get strings */
name|musthave
argument_list|(
operator|&
name|UP
argument_list|,
literal|"up"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|VB
argument_list|,
literal|"vb"
argument_list|)
expr_stmt|;
name|musthave
argument_list|(
operator|&
name|CM
argument_list|,
literal|"cm"
argument_list|)
expr_stmt|;
name|pair
argument_list|(
operator|&
name|SO
argument_list|,
operator|&
name|SE
argument_list|,
literal|"so"
argument_list|,
literal|"se"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|TI
argument_list|,
literal|"ti"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|TE
argument_list|,
literal|"te"
argument_list|)
expr_stmt|;
if|if
condition|(
name|tgetnum
argument_list|(
literal|"ug"
argument_list|)
operator|<=
literal|0
condition|)
block|{
name|pair
argument_list|(
operator|&
name|US
argument_list|,
operator|&
name|UE
argument_list|,
literal|"us"
argument_list|,
literal|"ue"
argument_list|)
expr_stmt|;
name|pair
argument_list|(
operator|&
name|MD
argument_list|,
operator|&
name|ME
argument_list|,
literal|"md"
argument_list|,
literal|"me"
argument_list|)
expr_stmt|;
comment|/* get italics, or have it default to underline */
name|pair
argument_list|(
operator|&
name|AS
argument_list|,
operator|&
name|AE
argument_list|,
literal|"as"
argument_list|,
literal|"ae"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|AS
condition|)
block|{
name|AS
operator|=
name|US
expr_stmt|;
name|AE
operator|=
name|UE
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_VISIBLE
name|MV
operator|=
name|SO
expr_stmt|;
comment|/* by default */
name|mayhave
argument_list|(
operator|&
name|MV
argument_list|,
literal|"mv"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|mayhave
argument_list|(
operator|&
name|AL
argument_list|,
literal|"al"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|DL
argument_list|,
literal|"dl"
argument_list|)
expr_stmt|;
name|musthave
argument_list|(
operator|&
name|CE
argument_list|,
literal|"ce"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|CD
argument_list|,
literal|"cd"
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|mayhave
argument_list|(
operator|&
name|SR_
argument_list|,
literal|"sr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|mayhave
argument_list|(
operator|&
name|SR
argument_list|,
literal|"sr"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|pair
argument_list|(
operator|&
name|IM
argument_list|,
operator|&
name|EI
argument_list|,
literal|"im"
argument_list|,
literal|"ei"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|IC
argument_list|,
literal|"ic"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|DC
argument_list|,
literal|"dc"
argument_list|)
expr_stmt|;
comment|/* other termcap stuff */
name|AM
operator|=
operator|(
name|tgetflag
argument_list|(
literal|"am"
argument_list|)
operator|&&
operator|!
name|tgetflag
argument_list|(
literal|"xn"
argument_list|)
operator|)
expr_stmt|;
name|PT
operator|=
name|tgetflag
argument_list|(
literal|"pt"
argument_list|)
expr_stmt|;
if|#
directive|if
name|AMIGA
name|amiopenwin
argument_list|(
name|termtype
argument_list|)
expr_stmt|;
comment|/* Must run this before ttysetup(); */
name|ttysetup
argument_list|()
expr_stmt|;
comment|/* Must run this before getsize(0); */
endif|#
directive|endif
name|getsize
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/* Key sequences */
name|pair
argument_list|(
operator|&
name|KS
argument_list|,
operator|&
name|KE
argument_list|,
literal|"ks"
argument_list|,
literal|"ke"
argument_list|)
expr_stmt|;
comment|/* keypad enable/disable */
name|mayhave
argument_list|(
operator|&
name|KU
argument_list|,
literal|"ku"
argument_list|)
expr_stmt|;
comment|/* up */
name|mayhave
argument_list|(
operator|&
name|KD
argument_list|,
literal|"kd"
argument_list|)
expr_stmt|;
comment|/* down */
name|mayhave
argument_list|(
operator|&
name|KR
argument_list|,
literal|"kr"
argument_list|)
expr_stmt|;
comment|/* right */
name|mayhave
argument_list|(
operator|&
name|KL
argument_list|,
literal|"kl"
argument_list|)
expr_stmt|;
comment|/* left */
if|if
condition|(
name|KL
operator|&&
name|KL
index|[
literal|0
index|]
operator|==
literal|'\b'
operator|&&
operator|!
name|KL
index|[
literal|1
index|]
condition|)
block|{
comment|/* never use '\b' as a left arrow! */
name|KL
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
block|}
name|mayhave
argument_list|(
operator|&
name|PU
argument_list|,
literal|"kP"
argument_list|)
expr_stmt|;
comment|/* PgUp */
name|mayhave
argument_list|(
operator|&
name|PD
argument_list|,
literal|"kN"
argument_list|)
expr_stmt|;
comment|/* PgDn */
name|mayhave
argument_list|(
operator|&
name|HM
argument_list|,
literal|"kh"
argument_list|)
expr_stmt|;
comment|/* Home */
name|mayhave
argument_list|(
operator|&
name|EN
argument_list|,
literal|"kH"
argument_list|)
expr_stmt|;
comment|/* End */
name|mayhave
argument_list|(
operator|&
name|KI
argument_list|,
literal|"kI"
argument_list|)
expr_stmt|;
comment|/* Insert */
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
operator|!
name|PU
condition|)
name|mayhave
argument_list|(
operator|&
name|PU
argument_list|,
literal|"K2"
argument_list|)
expr_stmt|;
comment|/* "3x3 pad" names for PgUp, etc. */
if|if
condition|(
operator|!
name|PD
condition|)
name|mayhave
argument_list|(
operator|&
name|PD
argument_list|,
literal|"K5"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|HM
condition|)
name|mayhave
argument_list|(
operator|&
name|HM
argument_list|,
literal|"K1"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|EN
condition|)
name|mayhave
argument_list|(
operator|&
name|EN
argument_list|,
literal|"K4"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|PU
argument_list|,
literal|"PU"
argument_list|)
expr_stmt|;
comment|/* old XENIX names for PgUp, etc. */
name|mayhave
argument_list|(
operator|&
name|PD
argument_list|,
literal|"PD"
argument_list|)
expr_stmt|;
comment|/* (overrides others, if used.) */
name|mayhave
argument_list|(
operator|&
name|HM
argument_list|,
literal|"HM"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|EN
argument_list|,
literal|"EN"
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_FKEY
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|0
index|]
argument_list|,
literal|"k0"
argument_list|)
expr_stmt|;
comment|/* function key codes */
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|1
index|]
argument_list|,
literal|"k1"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|2
index|]
argument_list|,
literal|"k2"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|3
index|]
argument_list|,
literal|"k3"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|4
index|]
argument_list|,
literal|"k4"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|5
index|]
argument_list|,
literal|"k5"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|6
index|]
argument_list|,
literal|"k6"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|7
index|]
argument_list|,
literal|"k7"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|8
index|]
argument_list|,
literal|"k8"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|9
index|]
argument_list|,
literal|"k9"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_SHIFT_FKEY
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|10
index|]
argument_list|,
literal|"s0"
argument_list|)
expr_stmt|;
comment|/* shift function key codes */
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|11
index|]
argument_list|,
literal|"s1"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|12
index|]
argument_list|,
literal|"s2"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|13
index|]
argument_list|,
literal|"s3"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|14
index|]
argument_list|,
literal|"s4"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|15
index|]
argument_list|,
literal|"s5"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|16
index|]
argument_list|,
literal|"s6"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|17
index|]
argument_list|,
literal|"s7"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|18
index|]
argument_list|,
literal|"s8"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|19
index|]
argument_list|,
literal|"s9"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_CTRL_FKEY
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|20
index|]
argument_list|,
literal|"c0"
argument_list|)
expr_stmt|;
comment|/* control function key codes */
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|21
index|]
argument_list|,
literal|"c1"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|22
index|]
argument_list|,
literal|"c2"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|23
index|]
argument_list|,
literal|"c3"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|24
index|]
argument_list|,
literal|"c4"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|25
index|]
argument_list|,
literal|"c5"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|26
index|]
argument_list|,
literal|"c6"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|27
index|]
argument_list|,
literal|"c7"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|28
index|]
argument_list|,
literal|"c8"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|29
index|]
argument_list|,
literal|"c9"
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_ALT_FKEY
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|30
index|]
argument_list|,
literal|"a0"
argument_list|)
expr_stmt|;
comment|/* alt function key codes */
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|31
index|]
argument_list|,
literal|"a1"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|32
index|]
argument_list|,
literal|"a2"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|33
index|]
argument_list|,
literal|"a3"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|34
index|]
argument_list|,
literal|"a4"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|35
index|]
argument_list|,
literal|"a5"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|36
index|]
argument_list|,
literal|"a6"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|37
index|]
argument_list|,
literal|"a7"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|38
index|]
argument_list|,
literal|"a8"
argument_list|)
expr_stmt|;
name|mayhave
argument_list|(
operator|&
name|FKEY
index|[
literal|39
index|]
argument_list|,
literal|"a9"
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
comment|/* cursor shapes */
name|CQ
operator|=
name|tgetstr
argument_list|(
literal|"cQ"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_CQ
condition|)
block|{
name|CX
operator|=
name|tgetstr
argument_list|(
literal|"cX"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CX
condition|)
name|CX
operator|=
name|CQ
expr_stmt|;
name|CV
operator|=
name|tgetstr
argument_list|(
literal|"cV"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CV
condition|)
name|CV
operator|=
name|CQ
expr_stmt|;
name|CI
operator|=
name|tgetstr
argument_list|(
literal|"cI"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CI
condition|)
name|CI
operator|=
name|CQ
expr_stmt|;
name|CR
operator|=
name|tgetstr
argument_list|(
literal|"cR"
argument_list|,
operator|&
name|capbuf
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|CR
condition|)
name|CR
operator|=
name|CQ
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
else|else
block|{
name|CQ
operator|=
name|CV
operator|=
literal|""
expr_stmt|;
name|pair
argument_list|(
operator|&
name|CQ
argument_list|,
operator|&
name|CV
argument_list|,
literal|"ve"
argument_list|,
literal|"vs"
argument_list|)
expr_stmt|;
name|CX
operator|=
name|CI
operator|=
name|CR
operator|=
name|CQ
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* !CRUNCH */
endif|#
directive|endif
comment|/* !NO_CURSORSHAPE */
ifndef|#
directive|ifndef
name|NO_COLOR
name|strcpy
argument_list|(
name|SOcolor
argument_list|,
name|SO
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|SEcolor
argument_list|,
name|SE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|AScolor
argument_list|,
name|AS
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|AEcolor
argument_list|,
name|AE
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|MDcolor
argument_list|,
name|MD
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|MEcolor
argument_list|,
name|ME
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|UScolor
argument_list|,
name|US
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|UEcolor
argument_list|,
name|UE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_POPUP
name|strcpy
argument_list|(
name|POPUPcolor
argument_list|,
name|SO
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_VISIBLE
name|strcpy
argument_list|(
name|VISIBLEcolor
argument_list|,
name|MV
argument_list|)
expr_stmt|;
endif|#
directive|endif
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This function gets the window size.  It uses the TIOCGWINSZ ioctl call if  * your system has it, or tgetnum("li") and tgetnum("co") if it doesn't.  * This function is called once during initialization, and thereafter it is  * called whenever the SIGWINCH signal is sent to this process.  */
end_comment

begin_function
name|int
name|getsize
parameter_list|(
name|signo
parameter_list|)
name|int
name|signo
decl_stmt|;
block|{
name|int
name|lines
decl_stmt|;
name|int
name|cols
decl_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
name|struct
name|winsize
name|size
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|SIGWINCH
comment|/* reset the signal vector */
name|signal
argument_list|(
name|SIGWINCH
argument_list|,
operator|(
name|void
operator|*
operator|)
name|getsize
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* get the window size, one way or another. */
name|lines
operator|=
name|cols
operator|=
literal|0
expr_stmt|;
ifdef|#
directive|ifdef
name|TIOCGWINSZ
if|if
condition|(
name|ioctl
argument_list|(
literal|2
argument_list|,
name|TIOCGWINSZ
argument_list|,
operator|&
name|size
argument_list|)
operator|>=
literal|0
condition|)
block|{
name|lines
operator|=
name|size
operator|.
name|ws_row
expr_stmt|;
name|cols
operator|=
name|size
operator|.
name|ws_col
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|AMIGA
comment|/* Amiga gets window size by asking the console.device */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|TERMTYPE
argument_list|,
name|termtype
argument_list|)
condition|)
block|{
specifier|auto
name|long
name|len
decl_stmt|;
specifier|auto
name|char
name|buf
index|[
literal|30
index|]
decl_stmt|;
name|Write
argument_list|(
name|Output
argument_list|()
argument_list|,
literal|"\2330 q"
argument_list|,
literal|4
argument_list|)
expr_stmt|;
comment|/* Ask the console.device */
name|len
operator|=
name|Read
argument_list|(
name|Input
argument_list|()
argument_list|,
name|buf
argument_list|,
literal|29
argument_list|)
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\000'
expr_stmt|;
name|sscanf
argument_list|(
operator|&
name|buf
index|[
literal|5
index|]
argument_list|,
literal|"%d;%d"
argument_list|,
operator|&
name|lines
argument_list|,
operator|&
name|cols
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|(
name|lines
operator|==
literal|0
operator|||
name|cols
operator|==
literal|0
operator|)
operator|&&
name|signo
operator|==
literal|0
condition|)
block|{
name|LINES
operator|=
name|tgetnum
argument_list|(
literal|"li"
argument_list|)
expr_stmt|;
name|COLS
operator|=
name|tgetnum
argument_list|(
literal|"co"
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|MSDOS
ifdef|#
directive|ifdef
name|RAINBOW
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|termtype
argument_list|,
literal|"rainbow"
argument_list|)
condition|)
block|{
comment|/* Determine whether Rainbow is in 80-column or 132-column mode */
name|cols
operator|=
operator|*
operator|(
name|unsigned
name|char
name|far
operator|*
operator|)
literal|0xee000f57L
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|lines
operator|=
name|v_rows
argument_list|()
expr_stmt|;
name|cols
operator|=
name|v_cols
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
name|lines
operator|>=
literal|2
operator|&&
name|cols
operator|>=
literal|30
condition|)
block|{
name|LINES
operator|=
name|lines
expr_stmt|;
name|COLS
operator|=
name|cols
expr_stmt|;
block|}
comment|/* Make sure we got values that we can live with */
if|if
condition|(
name|LINES
operator|<
literal|2
operator|||
name|COLS
operator|<
literal|30
condition|)
block|{
name|write
argument_list|(
literal|2
argument_list|,
literal|"Screen too small\n"
argument_list|,
operator|(
name|unsigned
operator|)
literal|17
argument_list|)
expr_stmt|;
if|#
directive|if
name|OSK
name|write
argument_list|(
literal|2
argument_list|,
literal|"\l"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|2
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
name|AMIGA
if|if
condition|(
operator|*
name|o_lines
operator|!=
name|LINES
operator|||
operator|*
name|o_columns
operator|!=
name|COLS
condition|)
block|{
operator|*
name|o_lines
operator|=
name|LINES
expr_stmt|;
operator|*
name|o_columns
operator|=
name|COLS
expr_stmt|;
block|}
endif|#
directive|endif
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This is a function version of addch() -- it is used by tputs() */
end_comment

begin_function
name|int
name|faddch
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This function quickly adds a string to the output queue.  It does *NOT*  * convert \n into<CR><LF>.  */
end_comment

begin_function
name|void
name|qaddstr
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|REG
name|char
modifier|*
name|s_
decl_stmt|,
modifier|*
name|d_
decl_stmt|;
if|#
directive|if
name|MSDOS
if|if
condition|(
name|o_pcbios
index|[
literal|0
index|]
condition|)
block|{
while|while
condition|(
operator|*
name|str
condition|)
name|qaddch
argument_list|(
operator|*
name|str
operator|++
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
for|for
control|(
name|s_
operator|=
operator|(
name|str
operator|)
operator|,
name|d_
operator|=
name|stdscr
init|;
operator|*
name|d_
operator|++
operator|=
operator|*
name|s_
operator|++
condition|;
control|)
block|{ 	}
name|stdscr
operator|=
name|d_
operator|-
literal|1
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Output the ESC sequence needed to go into any video mode, if supported */
end_comment

begin_function
name|void
name|attrset
parameter_list|(
name|a
parameter_list|)
name|int
name|a
decl_stmt|;
block|{
name|do_aend
argument_list|()
expr_stmt|;
if|if
condition|(
name|a
operator|==
name|A_BOLD
condition|)
block|{
name|do_MD
argument_list|()
expr_stmt|;
name|aend
operator|=
name|ME
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|A_UNDERLINE
condition|)
block|{
name|do_US
argument_list|()
expr_stmt|;
name|aend
operator|=
name|UE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|a
operator|==
name|A_ALTCHARSET
condition|)
block|{
name|do_AS
argument_list|()
expr_stmt|;
name|aend
operator|=
name|AE
expr_stmt|;
block|}
else|else
block|{
name|aend
operator|=
literal|""
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Insert a single character into the display */
end_comment

begin_function
name|void
name|insch
parameter_list|(
name|ch
parameter_list|)
name|int
name|ch
decl_stmt|;
block|{
if|if
condition|(
name|has_IM
condition|)
name|do_IM
argument_list|()
expr_stmt|;
name|do_IC
argument_list|()
expr_stmt|;
name|qaddch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
if|if
condition|(
name|has_EI
condition|)
name|do_EI
argument_list|()
expr_stmt|;
block|}
end_function

begin_function
name|void
name|wrefresh
parameter_list|()
block|{
if|if
condition|(
name|stdscr
operator|!=
name|kbuf
condition|)
block|{
name|VOIDBIOS
argument_list|(
argument|;
argument_list|,
argument|ttywrite(kbuf, (unsigned)(stdscr - kbuf))
argument_list|)
empty_stmt|;
name|stdscr
operator|=
name|kbuf
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|wqrefresh
parameter_list|()
block|{
if|if
condition|(
name|stdscr
operator|-
name|kbuf
operator|>
literal|2000
condition|)
block|{
name|VOIDBIOS
argument_list|(
argument|stdscr = kbuf
argument_list|,
argument|{ 			ttywrite(kbuf, (unsigned)(stdscr - kbuf));  			stdscr = kbuf; 		}
argument_list|)
empty_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_COLOR
end_ifndef

begin_comment
comment|/* This function is called during termination.  It resets color modes */
end_comment

begin_function
name|int
name|ansiquit
parameter_list|()
block|{
comment|/* if ANSI terminal& colors were set, then reset the colors */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|UP
argument_list|,
literal|"\033[A"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|SOcolor
argument_list|,
name|SO
argument_list|)
condition|)
block|{
name|tputs
argument_list|(
literal|"\033[37;40m\033[m"
argument_list|,
literal|1
argument_list|,
name|faddch
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
return|return
literal|1
return|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_comment
comment|/* This sets the color strings that work for ANSI terminals.  If the TERMCAP  * doesn't look like an ANSI terminal, then it returns FALSE.  If the colors  * aren't understood, it also returns FALSE.  If all goes well, it returns TRUE  */
end_comment

begin_function
name|int
name|ansicolor
parameter_list|(
name|cmode
parameter_list|,
name|attrbyte
parameter_list|)
name|int
name|cmode
decl_stmt|;
comment|/* mode to set, e.g. A_NORMAL */
name|int
name|attrbyte
decl_stmt|;
comment|/* IBM PC attribute byte */
block|{
name|char
name|temp
index|[
literal|24
index|]
decl_stmt|;
comment|/* hold the new mode string */
comment|/* if not ANSI-ish, then fail */
if|if
condition|(
name|strcmp
argument_list|(
name|UP
argument_list|,
literal|"\033[A"
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|UP
argument_list|,
literal|"\033OA"
argument_list|)
condition|)
block|{
comment|/* Only give an error message if we're editing a file. 		 * (I.e., if we're *NOT* currently doing a ".exrc") 		 */
if|if
condition|(
name|tmpfd
operator|>=
literal|0
condition|)
name|msg
argument_list|(
literal|"Don't know how to set colors for this terminal"
argument_list|)
expr_stmt|;
return|return
name|FALSE
return|;
block|}
comment|/* construct the color string */
ifdef|#
directive|ifdef
name|MWC
comment|/* either Coherent-286 ("COHERENT"), or Coherent-386 ("M_SYSV") */
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033[m\033[3%cm\033[4%cm%s%s"
argument_list|,
literal|"04261537"
index|[
name|attrbyte
operator|&
literal|0x07
index|]
argument_list|,
literal|"04261537"
index|[
operator|(
name|attrbyte
operator|>>
literal|4
operator|)
operator|&
literal|0x07
index|]
argument_list|,
operator|(
name|attrbyte
operator|&
literal|0x08
operator|)
condition|?
literal|"\033[1m"
else|:
literal|""
argument_list|,
operator|(
name|attrbyte
operator|&
literal|0x80
operator|)
condition|?
literal|"\033[5m"
else|:
literal|""
argument_list|)
expr_stmt|;
else|#
directive|else
name|sprintf
argument_list|(
name|temp
argument_list|,
literal|"\033[m\033[3%c;4%c%s%sm"
argument_list|,
literal|"04261537"
index|[
name|attrbyte
operator|&
literal|0x07
index|]
argument_list|,
literal|"04261537"
index|[
operator|(
name|attrbyte
operator|>>
literal|4
operator|)
operator|&
literal|0x07
index|]
argument_list|,
operator|(
name|attrbyte
operator|&
literal|0x08
operator|)
condition|?
literal|";1"
else|:
literal|""
argument_list|,
operator|(
name|attrbyte
operator|&
literal|0x80
operator|)
condition|?
literal|";5"
else|:
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* stick it in the right place */
switch|switch
condition|(
name|cmode
condition|)
block|{
case|case
name|A_NORMAL
case|:
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|MEcolor
argument_list|,
name|normalcolor
argument_list|)
condition|)
name|strcpy
argument_list|(
name|MEcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|UEcolor
argument_list|,
name|normalcolor
argument_list|)
condition|)
name|strcpy
argument_list|(
name|UEcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|AEcolor
argument_list|,
name|normalcolor
argument_list|)
condition|)
name|strcpy
argument_list|(
name|AEcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|SEcolor
argument_list|,
name|normalcolor
argument_list|)
condition|)
name|strcpy
argument_list|(
name|SEcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|normalcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|tputs
argument_list|(
name|normalcolor
argument_list|,
literal|1
argument_list|,
name|faddch
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_BOLD
case|:
name|strcpy
argument_list|(
name|MDcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|MEcolor
argument_list|,
name|normalcolor
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_UNDERLINE
case|:
name|strcpy
argument_list|(
name|UScolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|UEcolor
argument_list|,
name|normalcolor
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_ALTCHARSET
case|:
name|strcpy
argument_list|(
name|AScolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|AEcolor
argument_list|,
name|normalcolor
argument_list|)
expr_stmt|;
break|break;
case|case
name|A_STANDOUT
case|:
name|strcpy
argument_list|(
name|SOcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|SEcolor
argument_list|,
name|normalcolor
argument_list|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_POPUP
case|case
name|A_POPUP
case|:
name|strcpy
argument_list|(
name|POPUPcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_VISIBLE
case|case
name|A_VISIBLE
case|:
name|strcpy
argument_list|(
name|VISIBLEcolor
argument_list|,
name|temp
argument_list|)
expr_stmt|;
break|break;
endif|#
directive|endif
block|}
return|return
name|TRUE
return|;
block|}
end_function

begin_comment
comment|/* This function outputs the ESC sequence needed to switch the screen back  * to "normal" mode.  On color terminals which haven't had their color set  * yet, this is one of the termcap strings; for color terminals that really  * have had colors defined, we just the "normal color" escape sequence.  */
end_comment

begin_function
name|int
name|endcolor
parameter_list|()
block|{
if|if
condition|(
name|aend
operator|==
name|ME
condition|)
name|tputs
argument_list|(
name|MEcolor
argument_list|,
literal|1
argument_list|,
name|faddch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aend
operator|==
name|UE
condition|)
name|tputs
argument_list|(
name|UEcolor
argument_list|,
literal|1
argument_list|,
name|faddch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aend
operator|==
name|AE
condition|)
name|tputs
argument_list|(
name|AEcolor
argument_list|,
literal|1
argument_list|,
name|faddch
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|aend
operator|==
name|SE
condition|)
name|tputs
argument_list|(
name|SEcolor
argument_list|,
literal|1
argument_list|,
name|faddch
argument_list|)
expr_stmt|;
name|aend
operator|=
literal|""
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_COLOR */
end_comment

end_unit

