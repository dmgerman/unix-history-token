begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* input.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the input() function, which implements vi's INPUT mode.  * It also contains the code that supports digraphs.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_struct
specifier|static
struct|struct
name|_DIG
block|{
name|struct
name|_DIG
modifier|*
name|next
decl_stmt|;
name|char
name|key1
decl_stmt|;
name|char
name|key2
decl_stmt|;
name|char
name|dig
decl_stmt|;
name|char
name|save
decl_stmt|;
block|}
modifier|*
name|digs
struct|;
end_struct

begin_function
name|char
name|digraph
parameter_list|(
name|key1
parameter_list|,
name|key2
parameter_list|)
name|int
name|key1
decl_stmt|;
comment|/* the underlying character */
name|int
name|key2
decl_stmt|;
comment|/* the second character */
block|{
name|int
name|newkey
decl_stmt|;
name|REG
name|struct
name|_DIG
modifier|*
name|dp
decl_stmt|;
comment|/* if digraphs are disabled, then just return the new char */
if|if
condition|(
operator|!
operator|*
name|o_digraph
condition|)
block|{
return|return
name|key2
return|;
block|}
comment|/* remember the new key, so we can return it if this isn't a digraph */
name|newkey
operator|=
name|key2
expr_stmt|;
comment|/* sort key1 and key2, so that their original order won't matter */
if|if
condition|(
name|key1
operator|>
name|key2
condition|)
block|{
name|key2
operator|=
name|key1
expr_stmt|;
name|key1
operator|=
name|newkey
expr_stmt|;
block|}
comment|/* scan through the digraph chart */
for|for
control|(
name|dp
operator|=
name|digs
init|;
name|dp
operator|&&
operator|(
name|dp
operator|->
name|key1
operator|!=
name|key1
operator|||
name|dp
operator|->
name|key2
operator|!=
name|key2
operator|)
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{ 	}
comment|/* if this combination isn't in there, just use the new key */
if|if
condition|(
operator|!
name|dp
condition|)
block|{
return|return
name|newkey
return|;
block|}
comment|/* else use the digraph key */
return|return
name|dp
operator|->
name|dig
return|;
block|}
end_function

begin_comment
comment|/* this function lists or defines digraphs */
end_comment

begin_function
name|void
name|do_digraph
parameter_list|(
name|bang
parameter_list|,
name|extra
parameter_list|)
name|int
name|bang
decl_stmt|;
name|char
name|extra
index|[]
decl_stmt|;
block|{
name|int
name|dig
decl_stmt|;
name|REG
name|struct
name|_DIG
modifier|*
name|dp
decl_stmt|;
name|struct
name|_DIG
modifier|*
name|prev
decl_stmt|;
specifier|static
name|int
name|user_defined
init|=
name|FALSE
decl_stmt|;
comment|/* boolean: are all later digraphs user-defined? */
name|char
name|listbuf
index|[
literal|8
index|]
decl_stmt|;
comment|/* if "extra" is NULL, then we've reached the end of the built-ins */
if|if
condition|(
operator|!
name|extra
condition|)
block|{
name|user_defined
operator|=
name|TRUE
expr_stmt|;
return|return;
block|}
comment|/* if no args, then display the existing digraphs */
if|if
condition|(
operator|*
name|extra
operator|<
literal|' '
condition|)
block|{
name|listbuf
index|[
literal|0
index|]
operator|=
name|listbuf
index|[
literal|1
index|]
operator|=
name|listbuf
index|[
literal|2
index|]
operator|=
name|listbuf
index|[
literal|5
index|]
operator|=
literal|' '
expr_stmt|;
name|listbuf
index|[
literal|7
index|]
operator|=
literal|'\0'
expr_stmt|;
for|for
control|(
name|dig
operator|=
literal|0
operator|,
name|dp
operator|=
name|digs
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|save
operator|||
name|bang
condition|)
block|{
name|dig
operator|+=
literal|7
expr_stmt|;
if|if
condition|(
name|dig
operator|>=
name|COLS
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
name|dig
operator|=
literal|7
expr_stmt|;
block|}
name|listbuf
index|[
literal|3
index|]
operator|=
name|dp
operator|->
name|key1
expr_stmt|;
name|listbuf
index|[
literal|4
index|]
operator|=
name|dp
operator|->
name|key2
expr_stmt|;
name|listbuf
index|[
literal|6
index|]
operator|=
name|dp
operator|->
name|dig
expr_stmt|;
name|qaddstr
argument_list|(
name|listbuf
argument_list|)
expr_stmt|;
block|}
block|}
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
return|return;
block|}
comment|/* make sure we have at least two characters */
if|if
condition|(
operator|!
name|extra
index|[
literal|1
index|]
condition|)
block|{
name|msg
argument_list|(
literal|"Digraphs must be composed of two characters"
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* sort key1 and key2, so that their original order won't matter */
if|if
condition|(
name|extra
index|[
literal|0
index|]
operator|>
name|extra
index|[
literal|1
index|]
condition|)
block|{
name|dig
operator|=
name|extra
index|[
literal|0
index|]
expr_stmt|;
name|extra
index|[
literal|0
index|]
operator|=
name|extra
index|[
literal|1
index|]
expr_stmt|;
name|extra
index|[
literal|1
index|]
operator|=
name|dig
expr_stmt|;
block|}
comment|/* locate the new digraph character */
for|for
control|(
name|dig
operator|=
literal|2
init|;
name|extra
index|[
name|dig
index|]
operator|==
literal|' '
operator|||
name|extra
index|[
name|dig
index|]
operator|==
literal|'\t'
condition|;
name|dig
operator|++
control|)
block|{ 	}
name|dig
operator|=
name|extra
index|[
name|dig
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|bang
operator|&&
name|dig
condition|)
block|{
name|dig
operator||=
literal|0x80
expr_stmt|;
block|}
comment|/* search for the digraph */
for|for
control|(
name|prev
operator|=
operator|(
expr|struct
name|_DIG
operator|*
operator|)
literal|0
operator|,
name|dp
operator|=
name|digs
init|;
name|dp
operator|&&
operator|(
name|dp
operator|->
name|key1
operator|!=
name|extra
index|[
literal|0
index|]
operator|||
name|dp
operator|->
name|key2
operator|!=
name|extra
index|[
literal|1
index|]
operator|)
condition|;
name|prev
operator|=
name|dp
operator|,
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{ 	}
comment|/* deleting the digraph? */
if|if
condition|(
operator|!
name|dig
condition|)
block|{
if|if
condition|(
operator|!
name|dp
condition|)
block|{
ifndef|#
directive|ifndef
name|CRUNCH
name|msg
argument_list|(
literal|"%c%c not a digraph"
argument_list|,
name|extra
index|[
literal|0
index|]
argument_list|,
name|extra
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|dp
operator|->
name|next
expr_stmt|;
else|else
name|digs
operator|=
name|dp
operator|->
name|next
expr_stmt|;
name|_free_
argument_list|(
name|dp
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* if necessary, create a new digraph struct for the new digraph */
if|if
condition|(
name|dig
operator|&&
operator|!
name|dp
condition|)
block|{
name|dp
operator|=
operator|(
expr|struct
name|_DIG
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
expr|*
name|dp
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|dp
condition|)
block|{
name|msg
argument_list|(
literal|"Out of space in the digraph table"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|prev
condition|)
name|prev
operator|->
name|next
operator|=
name|dp
expr_stmt|;
else|else
name|digs
operator|=
name|dp
expr_stmt|;
name|dp
operator|->
name|next
operator|=
operator|(
expr|struct
name|_DIG
operator|*
operator|)
literal|0
expr_stmt|;
block|}
comment|/* assign it the new digraph value */
name|dp
operator|->
name|key1
operator|=
name|extra
index|[
literal|0
index|]
expr_stmt|;
name|dp
operator|->
name|key2
operator|=
name|extra
index|[
literal|1
index|]
expr_stmt|;
name|dp
operator|->
name|dig
operator|=
name|dig
expr_stmt|;
name|dp
operator|->
name|save
operator|=
name|user_defined
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MKEXRC
end_ifndef

begin_function
name|void
name|savedigs
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
block|{
specifier|static
name|char
name|buf
index|[]
init|=
literal|"digraph! XX Y\n"
decl_stmt|;
name|REG
name|struct
name|_DIG
modifier|*
name|dp
decl_stmt|;
for|for
control|(
name|dp
operator|=
name|digs
init|;
name|dp
condition|;
name|dp
operator|=
name|dp
operator|->
name|next
control|)
block|{
if|if
condition|(
name|dp
operator|->
name|save
condition|)
block|{
name|buf
index|[
literal|9
index|]
operator|=
name|dp
operator|->
name|key1
expr_stmt|;
name|buf
index|[
literal|10
index|]
operator|=
name|dp
operator|->
name|key2
expr_stmt|;
name|buf
index|[
literal|12
index|]
operator|=
name|dp
operator|->
name|dig
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
literal|14
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function allows the user to replace an existing (possibly zero-length)  * chunk of text with typed-in text.  It returns the MARK of the last character  * that the user typed in.  */
end_comment

begin_function
name|MARK
name|input
parameter_list|(
name|from
parameter_list|,
name|to
parameter_list|,
name|when
parameter_list|,
name|delta
parameter_list|)
name|MARK
name|from
decl_stmt|;
comment|/* where to start inserting text */
name|MARK
name|to
decl_stmt|;
comment|/* extent of text to delete */
name|int
name|when
decl_stmt|;
comment|/* either WHEN_VIINP or WHEN_VIREP */
name|int
name|delta
decl_stmt|;
comment|/* 1 to take indent from lower line, -1 for upper, 0 for none */
block|{
name|char
name|key
index|[
literal|2
index|]
decl_stmt|;
comment|/* key char followed by '\0' char */
name|char
modifier|*
name|build
decl_stmt|;
comment|/* used in building a newline+indent string */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used while looking at the indent chars of a line */
name|MARK
name|m
decl_stmt|;
comment|/* some place in the text */
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
name|int
name|quit
init|=
name|FALSE
decl_stmt|;
comment|/* boolean: are we exiting after this? */
name|int
name|inchg
decl_stmt|;
comment|/* boolean: have we done a "beforedo()" yet? */
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
comment|/* if "from" and "to" are reversed, complain */
if|if
condition|(
name|from
operator|>
name|to
condition|)
block|{
name|msg
argument_list|(
literal|"ERROR: input(%ld:%d, %ld:%d)"
argument_list|,
name|markline
argument_list|(
name|from
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|from
argument_list|)
argument_list|,
name|markline
argument_list|(
name|to
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
endif|#
directive|endif
name|key
index|[
literal|1
index|]
operator|=
literal|0
expr_stmt|;
comment|/* if we're replacing text with new text, save the old stuff */
comment|/* (Alas, there is no easy way to save text for replace mode) */
if|if
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|cut
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* if doing a dot command, then reuse the previous text */
if|if
condition|(
name|doingdot
condition|)
block|{
name|ChangeText
block|{
comment|/* delete the text that's there now */
if|if
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|delete
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
comment|/* insert the previous text */
name|cutname
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|paste
argument_list|(
name|from
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
operator|+
literal|1L
expr_stmt|;
block|}
block|}
else|else
comment|/* interactive version */
block|{
comment|/* assume that whoever called this already did a beforedo() */
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
name|inchg
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
comment|/* if doing a change within the line... */
if|if
condition|(
name|from
operator|!=
name|to
operator|&&
name|markline
argument_list|(
name|from
argument_list|)
operator|==
name|markline
argument_list|(
name|to
argument_list|)
condition|)
block|{
comment|/* mark the end of the text with a "$" */
name|change
argument_list|(
name|to
operator|-
literal|1
argument_list|,
name|to
argument_list|,
literal|"$"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* delete the old text right off */
if|if
condition|(
name|from
operator|!=
name|to
condition|)
block|{
name|delete
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|from
expr_stmt|;
block|}
comment|/* handle autoindent of the first line, maybe */
name|cursor
operator|=
name|from
expr_stmt|;
name|m
operator|=
name|cursor
operator|+
name|MARK_AT_LINE
argument_list|(
name|delta
argument_list|)
expr_stmt|;
if|if
condition|(
name|delta
operator|!=
literal|0
operator|&&
operator|*
name|o_autoindent
operator|&&
name|markidx
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|&&
name|markline
argument_list|(
name|m
argument_list|)
operator|>=
literal|1L
operator|&&
name|markline
argument_list|(
name|m
argument_list|)
operator|<=
name|nlines
condition|)
block|{
comment|/* Only autoindent blank lines. */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
comment|/* Okay, we really want to autoindent */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|ptext
operator|,
name|build
operator|=
name|tmpblk
operator|.
name|c
init|;
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
condition|;
control|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|build
operator|>
name|tmpblk
operator|.
name|c
condition|)
block|{
operator|*
name|build
operator|=
literal|'\0'
expr_stmt|;
name|add
argument_list|(
name|cursor
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|cursor
operator|+=
call|(
name|int
call|)
argument_list|(
name|build
operator|-
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|to
condition|)
name|to
operator|=
name|cursor
expr_stmt|;
block|}
block|}
block|}
comment|/* repeatedly add characters from the user */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* Get a character */
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|msg
argument_list|(
literal|"cursor=%ld.%d, to=%ld.%d"
argument_list|,
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|cursor
argument_list|)
argument_list|,
name|markline
argument_list|(
name|to
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ABBR
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
name|build
operator|=
name|ptext
expr_stmt|;
if|if
condition|(
name|pline
operator|==
name|markline
argument_list|(
name|from
argument_list|)
condition|)
name|build
operator|+=
name|markidx
argument_list|(
name|from
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|ptext
operator|+
name|markidx
argument_list|(
name|cursor
argument_list|)
init|;
operator|--
name|scan
operator|>=
name|build
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|;
control|)
block|{ 			}
name|scan
operator|++
expr_stmt|;
name|key
index|[
literal|0
index|]
operator|=
name|getabkey
argument_list|(
name|when
argument_list|,
name|scan
argument_list|,
call|(
name|int
call|)
argument_list|(
name|ptext
operator|+
name|markidx
argument_list|(
name|cursor
argument_list|)
operator|-
name|scan
argument_list|)
argument_list|)
expr_stmt|;
else|#
directive|else
name|key
index|[
literal|0
index|]
operator|=
name|getkey
argument_list|(
name|when
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_VISIBLE
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|!=
name|ctrl
argument_list|(
literal|'O'
argument_list|)
operator|&&
name|V_from
operator|!=
name|MARK_UNSET
condition|)
block|{
name|msg
argument_list|(
literal|"Can't modify text during a selection"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|==
name|ctrl
argument_list|(
literal|'O'
argument_list|)
condition|)
block|{
if|if
condition|(
name|inchg
condition|)
block|{
if|if
condition|(
name|cursor
operator|<
name|to
condition|)
block|{
name|delete
argument_list|(
name|cursor
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|afterdo
argument_list|()
expr_stmt|;
name|inchg
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|key
index|[
literal|0
index|]
operator|!=
name|ctrl
argument_list|(
literal|'['
argument_list|)
condition|)
block|{
if|if
condition|(
operator|!
name|inchg
condition|)
block|{
name|beforedo
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|inchg
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* if wrapmargin is set& we're past the 			 * warpmargin, then change the last whitespace 			 * characters on line into a newline 			 */
if|if
condition|(
operator|*
name|o_wrapmargin
condition|)
block|{
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
name|idx2col
argument_list|(
name|cursor
argument_list|,
name|ptext
argument_list|,
name|TRUE
argument_list|)
operator|&&
name|plen
operator|>
name|COLS
operator|-
operator|(
operator|*
name|o_wrapmargin
operator|&
literal|0xff
operator|)
condition|)
block|{
name|build
operator|=
name|tmpblk
operator|.
name|c
expr_stmt|;
operator|*
name|build
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|*
name|o_autoindent
condition|)
block|{
comment|/* figure out indent for next line */
for|for
control|(
name|scan
operator|=
name|ptext
init|;
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
condition|;
control|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|build
operator|=
literal|'\0'
expr_stmt|;
name|scan
operator|=
name|ptext
operator|+
name|plen
expr_stmt|;
name|m
operator|=
name|cursor
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
while|while
condition|(
name|ptext
operator|<
name|scan
condition|)
block|{
name|scan
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|scan
operator|!=
literal|' '
operator|&&
operator|*
name|scan
operator|!=
literal|'\t'
condition|)
continue|continue;
comment|/*break up line, and we do autoindent if needed*/
name|change
argument_list|(
name|m
operator|+
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|ptext
argument_list|)
argument_list|,
name|m
operator|+
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|ptext
argument_list|)
operator|+
literal|1
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
comment|/* NOTE: for some reason, MSC 5.10 doesn't 						 * like for these lines to be combined!!! 						 */
name|cursor
operator|=
operator|(
name|cursor
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
expr_stmt|;
name|cursor
operator|+=
name|BLKSIZE
expr_stmt|;
name|cursor
operator|+=
name|strlen
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
operator|-
literal|1
expr_stmt|;
name|cursor
operator|+=
name|plen
operator|-
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|ptext
argument_list|)
operator|-
literal|1
expr_stmt|;
comment|/*remove trailing spaces on previous line*/
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|scan
operator|=
name|ptext
operator|+
name|plen
expr_stmt|;
while|while
condition|(
name|ptext
operator|<
name|scan
condition|)
block|{
name|scan
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|scan
operator|!=
literal|' '
operator|&&
operator|*
name|scan
operator|!=
literal|'\t'
condition|)
break|break;
block|}
name|delete
argument_list|(
name|m
operator|+
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|ptext
argument_list|)
operator|+
literal|1
argument_list|,
name|m
operator|+
name|plen
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
block|}
endif|#
directive|endif
comment|/* !CRUNCH */
comment|/* process it */
switch|switch
condition|(
operator|*
name|key
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
case|case
name|ctrl
argument_list|(
literal|'O'
argument_list|)
case|:
comment|/* special movement mapped keys */
operator|*
name|key
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
switch|switch
condition|(
operator|*
name|key
condition|)
block|{
case|case
literal|'h'
case|:
name|m
operator|=
name|m_left
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
case|case
literal|'k'
case|:
name|m
operator|=
name|m_updnto
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|,
operator|*
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|m
operator|=
name|cursor
operator|+
literal|1
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
case|case
literal|'b'
case|:
name|m
operator|=
name|m_bword
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|,
operator|*
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'W'
case|:
case|case
literal|'w'
case|:
name|m
operator|=
name|m_fword
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|,
operator|*
name|key
argument_list|,
literal|'\0'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'^'
case|:
name|m
operator|=
name|m_front
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'$'
case|:
name|m
operator|=
name|m_rear
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctrl
argument_list|(
literal|'B'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'F'
argument_list|)
case|:
name|m
operator|=
name|m_scroll
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|,
operator|*
name|key
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'x'
case|:
ifndef|#
directive|ifndef
name|NO_VISIBLE
if|if
condition|(
name|V_from
condition|)
name|beep
argument_list|()
expr_stmt|;
else|else
endif|#
directive|endif
name|ChangeText
block|{
name|m
operator|=
name|v_xchar
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|,
literal|'x'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|'i'
case|:
name|m
operator|=
name|to
operator|=
name|from
operator|=
name|cursor
expr_stmt|;
name|when
operator|=
name|WHEN_VIINP
operator|+
name|WHEN_VIREP
operator|-
name|when
expr_stmt|;
break|break;
case|case
literal|'K'
case|:
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
name|changes
operator|++
expr_stmt|;
comment|/*<- after this, we can alter ptext */
name|ptext
index|[
name|markidx
argument_list|(
name|cursor
argument_list|)
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|ptext
operator|+
name|markidx
argument_list|(
name|cursor
argument_list|)
operator|-
literal|1
init|;
name|scan
operator|>=
name|ptext
operator|&&
name|isalnum
argument_list|(
operator|*
name|scan
argument_list|)
condition|;
name|scan
operator|--
control|)
block|{ 					}
name|scan
operator|++
expr_stmt|;
name|m
operator|=
operator|(
operator|*
name|scan
condition|?
name|v_keyword
argument_list|(
name|scan
argument_list|,
name|cursor
argument_list|,
literal|0L
argument_list|)
else|:
name|cursor
operator|)
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_VISIBLE
case|case
literal|'v'
case|:
case|case
literal|'V'
case|:
if|if
condition|(
name|V_from
condition|)
name|V_from
operator|=
name|MARK_UNSET
expr_stmt|;
else|else
name|V_from
operator|=
name|cursor
expr_stmt|;
name|m
operator|=
name|from
operator|=
name|to
operator|=
name|cursor
expr_stmt|;
name|V_linemd
operator|=
operator|(
operator|*
name|key
operator|==
literal|'V'
operator|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
case|case
literal|'y'
case|:
case|case
literal|'\\'
case|:
comment|/* do nothing if unmarked */
if|if
condition|(
operator|!
name|V_from
condition|)
block|{
name|msg
argument_list|(
literal|"You must mark the text first"
argument_list|)
expr_stmt|;
name|beep
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* "from" must come before "to" */
if|if
condition|(
name|V_from
operator|<
name|cursor
condition|)
block|{
name|from
operator|=
name|V_from
expr_stmt|;
name|to
operator|=
name|cursor
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|cursor
expr_stmt|;
name|to
operator|=
name|V_from
expr_stmt|;
block|}
comment|/* we don't need V_from anymore */
name|V_from
operator|=
name|MARK_UNSET
expr_stmt|;
if|if
condition|(
name|V_linemd
condition|)
block|{
comment|/* adjust for line mode */
name|from
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|to
operator||=
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
else|else
block|{
comment|/* in character mode, we must 						 * worry about deleting the newline 						 * at the end of the last line 						 */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|to
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|to
argument_list|)
operator|==
name|plen
condition|)
name|to
operator||=
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
name|to
operator|++
expr_stmt|;
switch|switch
condition|(
operator|*
name|key
condition|)
block|{
case|case
literal|'y'
case|:
name|cut
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|ChangeText
block|{
name|cut
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|cursor
operator|=
name|from
expr_stmt|;
break|break;
ifndef|#
directive|ifndef
name|NO_POPUP
case|case
literal|'\\'
case|:
name|ChangeText
block|{
name|cursor
operator|=
name|v_popup
argument_list|(
name|from
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
block|}
name|m
operator|=
name|from
operator|=
name|to
operator|=
name|cursor
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
case|case
literal|'P'
case|:
name|V_from
operator|=
name|MARK_UNSET
expr_stmt|;
name|ChangeText
block|{
name|m
operator|=
name|paste
argument_list|(
name|cursor
argument_list|,
operator|(
operator|*
name|key
operator|==
literal|'p'
operator|)
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
break|break;
endif|#
directive|endif
comment|/* !NO_VISIBLE */
default|default:
name|m
operator|=
name|MARK_UNSET
expr_stmt|;
block|}
comment|/* adjust the moved cursor */
if|if
condition|(
name|m
operator|!=
name|cursor
condition|)
block|{
name|m
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|m
argument_list|,
operator|(
operator|*
name|key
operator|==
literal|'j'
operator|||
operator|*
name|key
operator|==
literal|'k'
condition|?
name|NCOL
operator||
name|FINL
else|:
name|FINL
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|&&
operator|(
operator|*
name|key
operator|==
literal|'$'
operator|||
operator|(
operator|*
name|key
operator|==
literal|'l'
operator|&&
name|m
operator|<=
name|cursor
operator|)
operator|)
condition|)
block|{
name|m
operator|++
expr_stmt|;
block|}
block|}
comment|/* if the cursor is reasonable, use it */
if|if
condition|(
name|m
operator|==
name|MARK_UNSET
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|from
operator|=
name|to
operator|=
name|cursor
operator|=
name|m
expr_stmt|;
block|}
break|break;
case|case
name|ctrl
argument_list|(
literal|'Z'
argument_list|)
case|:
if|if
condition|(
name|getkey
argument_list|(
literal|0
argument_list|)
operator|==
name|ctrl
argument_list|(
literal|'Z'
argument_list|)
condition|)
block|{
name|quit
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|BreakBreak
goto|;
block|}
break|break;
endif|#
directive|endif
case|case
name|ctrl
argument_list|(
literal|'['
argument_list|)
case|:
comment|/* if last line contains only whitespace, then remove whitespace */
if|if
condition|(
operator|*
name|o_autoindent
condition|)
block|{
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|ptext
init|;
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
condition|;
name|scan
operator|++
control|)
block|{ 					}
if|if
condition|(
name|scan
operator|>
name|ptext
operator|&&
operator|!
operator|*
name|scan
condition|)
block|{
name|cursor
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1L
operator|)
expr_stmt|;
if|if
condition|(
name|to
operator|<
name|cursor
operator|+
name|plen
condition|)
block|{
name|to
operator|=
name|cursor
operator|+
name|plen
expr_stmt|;
block|}
block|}
block|}
goto|goto
name|BreakBreak
goto|;
case|case
name|ctrl
argument_list|(
literal|'U'
argument_list|)
case|:
if|if
condition|(
name|markline
argument_list|(
name|cursor
argument_list|)
operator|==
name|markline
argument_list|(
name|from
argument_list|)
condition|)
block|{
name|cursor
operator|=
name|from
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
block|}
break|break;
case|case
name|ctrl
argument_list|(
literal|'D'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'T'
argument_list|)
case|:
if|if
condition|(
name|to
operator|>
name|cursor
condition|)
block|{
name|delete
argument_list|(
name|cursor
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
name|mark
index|[
literal|27
index|]
operator|=
name|cursor
expr_stmt|;
name|cmd_shift
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
operator|*
name|key
operator|==
name|ctrl
argument_list|(
literal|'D'
argument_list|)
condition|?
name|CMD_SHIFTL
else|:
name|CMD_SHIFTR
argument_list|,
name|TRUE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
if|if
condition|(
name|mark
index|[
literal|27
index|]
condition|)
block|{
name|cursor
operator|=
name|mark
index|[
literal|27
index|]
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|=
name|m_front
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
block|}
name|to
operator|=
name|cursor
expr_stmt|;
break|break;
case|case
literal|'\b'
case|:
if|if
condition|(
name|cursor
operator|<=
name|from
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markidx
argument_list|(
name|cursor
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cursor
operator|-=
name|BLKSIZE
expr_stmt|;
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
name|cursor
operator|+=
name|plen
expr_stmt|;
block|}
else|else
block|{
name|cursor
operator|--
expr_stmt|;
block|}
break|break;
case|case
name|ctrl
argument_list|(
literal|'W'
argument_list|)
case|:
name|m
operator|=
name|m_bword
argument_list|(
name|cursor
argument_list|,
literal|1L
argument_list|,
literal|'b'
argument_list|)
expr_stmt|;
if|if
condition|(
name|markline
argument_list|(
name|m
argument_list|)
operator|==
name|markline
argument_list|(
name|cursor
argument_list|)
operator|&&
name|m
operator|>=
name|from
condition|)
block|{
name|cursor
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|from
operator|>
name|cursor
condition|)
block|{
name|from
operator|=
name|cursor
expr_stmt|;
block|}
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
if|#
directive|if
name|OSK
case|case
literal|'\l'
case|:
else|#
directive|else
case|case
literal|'\r'
case|:
endif|#
directive|endif
name|build
operator|=
name|tmpblk
operator|.
name|c
expr_stmt|;
operator|*
name|build
operator|++
operator|=
literal|'\n'
expr_stmt|;
if|if
condition|(
operator|*
name|o_autoindent
condition|)
block|{
comment|/* figure out indent for next line */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|scan
operator|=
name|ptext
init|;
operator|*
name|scan
operator|==
literal|' '
operator|||
operator|*
name|scan
operator|==
literal|'\t'
condition|;
control|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
comment|/* remove indent from this line, if blank */
if|if
condition|(
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|ptext
argument_list|)
operator|>=
name|markidx
argument_list|(
name|cursor
argument_list|)
operator|&&
name|plen
operator|>
literal|0
condition|)
block|{
name|to
operator|=
name|cursor
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|delete
argument_list|(
name|cursor
argument_list|,
name|cursor
operator|+
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|ptext
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* advance "to" past whitespace at the cursor */
block|if (to>= cursor) 					{ 						for (scan = ptext + markidx(cursor), to = cursor; *scan == ' ' || *scan == '\t'; scan++, to++) 						{ 						} 					}
endif|#
directive|endif
block|}
operator|*
name|build
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|cursor
operator|>=
name|to
operator|&&
name|when
operator|!=
name|WHEN_VIREP
condition|)
block|{
name|add
argument_list|(
name|cursor
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|change
argument_list|(
name|cursor
argument_list|,
name|to
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|to
operator|=
name|cursor
operator|=
operator|(
name|cursor
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
operator|+
call|(
name|int
call|)
argument_list|(
name|build
operator|-
name|tmpblk
operator|.
name|c
argument_list|)
operator|-
literal|1
expr_stmt|;
break|break;
case|case
name|ctrl
argument_list|(
literal|'A'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'P'
argument_list|)
case|:
if|if
condition|(
name|cursor
operator|<
name|to
condition|)
block|{
name|delete
argument_list|(
name|cursor
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|key
operator|==
name|ctrl
argument_list|(
literal|'A'
argument_list|)
condition|)
block|{
name|cutname
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
block|}
name|m
operator|=
name|paste
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|MARK_UNSET
condition|)
block|{
name|to
operator|=
name|cursor
operator|=
name|m
operator|+
literal|1L
expr_stmt|;
block|}
break|break;
case|case
name|ctrl
argument_list|(
literal|'V'
argument_list|)
case|:
if|if
condition|(
name|cursor
operator|>=
name|to
operator|&&
name|when
operator|!=
name|WHEN_VIREP
condition|)
block|{
name|add
argument_list|(
name|cursor
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|change
argument_list|(
name|cursor
argument_list|,
name|to
argument_list|,
literal|"^"
argument_list|)
expr_stmt|;
name|to
operator|=
name|cursor
operator|+
literal|1
expr_stmt|;
block|}
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
operator|*
name|key
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|key
operator|==
literal|'\n'
condition|)
block|{
comment|/* '\n' too hard to handle */
if|#
directive|if
name|OSK
operator|*
name|key
operator|=
literal|'\l'
expr_stmt|;
else|#
directive|else
operator|*
name|key
operator|=
literal|'\r'
expr_stmt|;
endif|#
directive|endif
block|}
name|change
argument_list|(
name|cursor
argument_list|,
name|cursor
operator|+
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
if|if
condition|(
name|cursor
operator|>
name|to
condition|)
block|{
name|to
operator|=
name|cursor
expr_stmt|;
block|}
break|break;
case|case
name|ctrl
argument_list|(
literal|'L'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'R'
argument_list|)
case|:
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|cursor
operator|>=
name|to
operator|&&
name|when
operator|!=
name|WHEN_VIREP
condition|)
block|{
name|add
argument_list|(
name|cursor
argument_list|,
name|key
argument_list|)
expr_stmt|;
name|cursor
operator|++
expr_stmt|;
name|to
operator|=
name|cursor
expr_stmt|;
block|}
else|else
block|{
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|cursor
argument_list|)
operator|==
name|plen
condition|)
block|{
name|add
argument_list|(
name|cursor
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
ifndef|#
directive|ifndef
name|NO_DIGRAPH
operator|*
name|key
operator|=
name|digraph
argument_list|(
name|ptext
index|[
name|markidx
argument_list|(
name|cursor
argument_list|)
index|]
argument_list|,
operator|*
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|change
argument_list|(
name|cursor
argument_list|,
name|cursor
operator|+
literal|1
argument_list|,
name|key
argument_list|)
expr_stmt|;
block|}
name|cursor
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_SHOWMATCH
comment|/* show matching "({[" if necessary */
if|if
condition|(
operator|*
name|o_showmatch
operator|&&
name|strchr
argument_list|(
literal|")}]"
argument_list|,
operator|*
name|key
argument_list|)
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|m
operator|=
name|m_match
argument_list|(
name|cursor
operator|-
literal|1
argument_list|,
literal|0L
argument_list|)
expr_stmt|;
if|if
condition|(
name|markline
argument_list|(
name|m
argument_list|)
operator|>=
name|topline
operator|&&
name|markline
argument_list|(
name|m
argument_list|)
operator|<=
name|botline
condition|)
block|{
name|redraw
argument_list|(
name|m
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|sleep
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
endif|#
directive|endif
block|}
comment|/* end switch(*key) */
block|}
comment|/* end for(;;) */
name|BreakBreak
label|:
empty_stmt|;
comment|/* delete any excess characters */
if|if
condition|(
name|cursor
operator|<
name|to
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/* if we aren't in the middle of a change, start one! */
if|if
condition|(
operator|!
name|inchg
condition|)
block|{
name|beforedo
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|inchg
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
name|delete
argument_list|(
name|cursor
argument_list|,
name|to
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* end if doingdot else */
comment|/* put the new text into a cut buffer for possible reuse */
if|if
condition|(
operator|!
name|doingdot
condition|)
block|{
name|blksync
argument_list|()
expr_stmt|;
name|cutname
argument_list|(
literal|'.'
argument_list|)
expr_stmt|;
name|cut
argument_list|(
name|from
argument_list|,
name|cursor
argument_list|)
expr_stmt|;
block|}
comment|/* move to last char that we inputted, unless it was newline */
if|if
condition|(
name|markidx
argument_list|(
name|cursor
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|cursor
operator|--
expr_stmt|;
block|}
name|redraw
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|quit
condition|)
block|{
comment|/* if this is a nested "do", then cut it short */
name|abortdo
argument_list|()
expr_stmt|;
comment|/* exit, unless we can't write out the file */
name|cursor
operator|=
name|v_xit
argument_list|(
name|cursor
argument_list|,
literal|0L
argument_list|,
literal|'Z'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|rptlines
operator|=
literal|0L
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

end_unit

