begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* redraw.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains functions that draw text on the screen.  The major entry  * points are:  *	redrawrange()	- called from modify.c to give hints about what parts  *			  of the screen need to be redrawn.  *	redraw()	- redraws the screen (or part of it) and positions  *			  the cursor where it belongs.  *	idx2col()	- converts a markidx() value to a logical column number.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|CRUNCH
end_ifdef

begin_define
define|#
directive|define
name|NEAR
value|LINES
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|NEAR
value|(*o_nearscroll&0xff)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This variable contains the line number that smartdrawtext() knows best */
end_comment

begin_decl_stmt
specifier|static
name|long
name|smartlno
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This function remembers where changes were made, so that the screen can be  * redraw in a more efficient manner.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|redrawafter
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line# of first line that must be redrawn */
end_comment

begin_decl_stmt
specifier|static
name|long
name|preredraw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line# of last line changed, before change */
end_comment

begin_decl_stmt
specifier|static
name|long
name|postredraw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line# of last line changed, after change */
end_comment

begin_decl_stmt
specifier|static
name|int
name|mustredraw
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean: anything forcing a screen update? */
end_comment

begin_function
name|void
name|redrawrange
parameter_list|(
name|after
parameter_list|,
name|pre
parameter_list|,
name|post
parameter_list|)
name|long
name|after
decl_stmt|;
comment|/* lower bound of redrawafter */
name|long
name|pre
decl_stmt|;
comment|/* upper bound of preredraw */
name|long
name|post
decl_stmt|;
comment|/* upper bound of postredraw */
block|{
if|if
condition|(
name|after
operator|==
name|redrawafter
condition|)
block|{
comment|/* multiple insertions/deletions at the same place -- combine 		 * them 		 */
name|preredraw
operator|-=
operator|(
name|post
operator|-
name|pre
operator|)
expr_stmt|;
if|if
condition|(
name|postredraw
operator|<
name|post
condition|)
block|{
name|preredraw
operator|+=
operator|(
name|post
operator|-
name|postredraw
operator|)
expr_stmt|;
name|postredraw
operator|=
name|post
expr_stmt|;
block|}
if|if
condition|(
name|redrawafter
operator|>
name|preredraw
condition|)
block|{
name|redrawafter
operator|=
name|preredraw
expr_stmt|;
block|}
if|if
condition|(
name|redrawafter
operator|<
literal|1L
condition|)
block|{
name|redrawafter
operator|=
literal|0L
expr_stmt|;
name|preredraw
operator|=
name|postredraw
operator|=
name|INFINITY
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|postredraw
operator|>
literal|0L
condition|)
block|{
comment|/* multiple changes in different places -- redraw everything 		 * after "after". 		 */
name|postredraw
operator|=
name|preredraw
operator|=
name|INFINITY
expr_stmt|;
if|if
condition|(
name|after
operator|<
name|redrawafter
condition|)
name|redrawafter
operator|=
name|after
expr_stmt|;
block|}
else|else
block|{
comment|/* first change */
name|redrawafter
operator|=
name|after
expr_stmt|;
name|preredraw
operator|=
name|pre
expr_stmt|;
name|postredraw
operator|=
name|post
expr_stmt|;
block|}
name|mustredraw
operator|=
name|TRUE
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_CHARATTR
end_ifndef

begin_comment
comment|/* see if a given line uses character attribute strings */
end_comment

begin_function
specifier|static
name|int
name|hasattr
parameter_list|(
name|lno
parameter_list|,
name|text
parameter_list|)
name|long
name|lno
decl_stmt|;
comment|/* the line# of the cursor */
name|REG
name|char
modifier|*
name|text
decl_stmt|;
comment|/* the text of the line, from fetchline */
block|{
specifier|static
name|long
name|plno
decl_stmt|;
comment|/* previous line number */
specifier|static
name|long
name|chgs
decl_stmt|;
comment|/* previous value of changes counter */
specifier|static
name|int
name|panswer
decl_stmt|;
comment|/* previous answer */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* if charattr is off, then the answer is "no, it doesn't" */
if|if
condition|(
operator|!
operator|*
name|o_charattr
condition|)
block|{
name|chgs
operator|=
literal|0
expr_stmt|;
comment|/*<- forces us to check if charattr is later set */
return|return
name|FALSE
return|;
block|}
comment|/* if we already know the answer, return it... */
if|if
condition|(
name|lno
operator|==
name|plno
operator|&&
name|chgs
operator|==
name|changes
condition|)
block|{
return|return
name|panswer
return|;
block|}
comment|/* get the line& look for "\fX" */
if|if
condition|(
operator|!
name|text
index|[
literal|0
index|]
operator|||
operator|!
name|text
index|[
literal|1
index|]
operator|||
operator|!
name|text
index|[
literal|2
index|]
condition|)
block|{
name|panswer
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|scan
operator|=
name|text
init|;
name|scan
index|[
literal|2
index|]
operator|&&
operator|!
operator|(
name|scan
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|scan
index|[
literal|1
index|]
operator|==
literal|'f'
operator|)
condition|;
name|scan
operator|++
control|)
block|{ 		}
name|panswer
operator|=
operator|(
name|scan
index|[
literal|2
index|]
operator|!=
literal|'\0'
operator|)
expr_stmt|;
block|}
comment|/* save the results */
name|plno
operator|=
name|lno
expr_stmt|;
name|chgs
operator|=
name|changes
expr_stmt|;
comment|/* return the results */
return|return
name|panswer
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_VISIBLE
end_ifndef

begin_comment
comment|/* This function checks to make sure that the correct lines are shown in  * reverse-video.  This is used to handle the "v" and "V" commands.  */
end_comment

begin_decl_stmt
specifier|static
name|long
name|vizlow
decl_stmt|,
name|vizhigh
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the starting and ending lines */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vizleft
decl_stmt|,
name|vizright
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starting& ending indicies */
end_comment

begin_decl_stmt
specifier|static
name|int
name|vizchange
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean: must use stupid drawtext? */
end_comment

begin_function
specifier|static
name|void
name|setviz
parameter_list|(
name|curs
parameter_list|)
name|MARK
name|curs
decl_stmt|;
block|{
name|long
name|newlow
decl_stmt|,
name|newhigh
decl_stmt|;
name|long
name|extra
init|=
literal|0L
decl_stmt|;
comment|/* for now, assume the worst... */
name|vizchange
operator|=
name|TRUE
expr_stmt|;
comment|/* set newlow& newhigh according to V_from and cursor */
if|if
condition|(
operator|!
name|V_from
condition|)
block|{
comment|/* no lines should have reverse-video */
if|if
condition|(
name|vizlow
condition|)
block|{
name|redrawrange
argument_list|(
name|vizlow
argument_list|,
name|vizhigh
operator|+
literal|1L
argument_list|,
name|vizhigh
operator|+
literal|1L
argument_list|)
expr_stmt|;
name|vizlow
operator|=
name|vizhigh
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|vizchange
operator|=
name|FALSE
expr_stmt|;
block|}
return|return;
block|}
comment|/* figure out which lines *SHOULD* have hilites */
if|if
condition|(
name|V_from
operator|<
name|curs
condition|)
block|{
name|newlow
operator|=
name|markline
argument_list|(
name|V_from
argument_list|)
expr_stmt|;
name|newhigh
operator|=
name|markline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
name|vizleft
operator|=
name|markidx
argument_list|(
name|V_from
argument_list|)
expr_stmt|;
name|vizright
operator|=
name|markidx
argument_list|(
name|curs
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
else|else
block|{
name|newlow
operator|=
name|markline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
name|newhigh
operator|=
name|markline
argument_list|(
name|V_from
argument_list|)
expr_stmt|;
name|vizleft
operator|=
name|markidx
argument_list|(
name|curs
argument_list|)
expr_stmt|;
name|vizright
operator|=
name|markidx
argument_list|(
name|V_from
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
comment|/* adjust for line-mode hiliting */
if|if
condition|(
name|V_linemd
condition|)
block|{
name|vizleft
operator|=
literal|0
expr_stmt|;
name|vizright
operator|=
name|BLKSIZE
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|extra
operator|=
literal|1L
expr_stmt|;
block|}
comment|/* arrange for the necessary lines to be redrawn */
if|if
condition|(
name|vizlow
operator|==
literal|0L
condition|)
block|{
comment|/* just starting to redraw */
name|redrawrange
argument_list|(
name|newlow
argument_list|,
name|newhigh
argument_list|,
name|newhigh
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Were new lines added/removed at the front? */
if|if
condition|(
name|newlow
operator|!=
name|vizlow
condition|)
block|{
if|if
condition|(
name|newlow
operator|<
name|vizlow
condition|)
name|redrawrange
argument_list|(
name|newlow
argument_list|,
name|vizlow
operator|+
name|extra
argument_list|,
name|vizlow
operator|+
name|extra
argument_list|)
expr_stmt|;
else|else
name|redrawrange
argument_list|(
name|vizlow
argument_list|,
name|newlow
operator|+
name|extra
argument_list|,
name|newlow
operator|+
name|extra
argument_list|)
expr_stmt|;
block|}
comment|/* Were new lines added/removed at the back? */
if|if
condition|(
name|newhigh
operator|!=
name|vizhigh
condition|)
block|{
if|if
condition|(
name|newhigh
operator|<
name|vizhigh
condition|)
name|redrawrange
argument_list|(
name|newhigh
operator|+
literal|1L
operator|-
name|extra
argument_list|,
name|vizhigh
operator|+
literal|1L
argument_list|,
name|vizhigh
operator|+
literal|1L
argument_list|)
expr_stmt|;
else|else
name|redrawrange
argument_list|(
name|vizhigh
operator|+
literal|1L
operator|-
name|extra
argument_list|,
name|newhigh
argument_list|,
name|newhigh
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* remember which lines will contain hilighted text now */
name|vizlow
operator|=
name|newlow
expr_stmt|;
name|vizhigh
operator|=
name|newhigh
expr_stmt|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* !NO_VISIBLE */
end_comment

begin_comment
comment|/* This function converts a MARK to a column number.  It doesn't automatically  * adjust for leftcol; that must be done by the calling function  */
end_comment

begin_function
name|int
name|idx2col
parameter_list|(
name|curs
parameter_list|,
name|text
parameter_list|,
name|inputting
parameter_list|)
name|MARK
name|curs
decl_stmt|;
comment|/* the line#& index# of the cursor */
name|REG
name|char
modifier|*
name|text
decl_stmt|;
comment|/* the text of the line, from fetchline */
name|int
name|inputting
decl_stmt|;
comment|/* boolean: called from input() ? */
block|{
specifier|static
name|MARK
name|pcursor
decl_stmt|;
comment|/* previous cursor, for possible shortcut */
specifier|static
name|MARK
name|pcol
decl_stmt|;
comment|/* column number for pcol */
specifier|static
name|long
name|chgs
decl_stmt|;
comment|/* previous value of changes counter */
name|REG
name|int
name|col
decl_stmt|;
comment|/* used to count column numbers */
name|REG
name|int
name|idx
decl_stmt|;
comment|/* used to count down the index */
name|REG
name|int
name|i
decl_stmt|;
comment|/* for now, assume we have to start counting at the left edge */
name|col
operator|=
literal|0
expr_stmt|;
name|idx
operator|=
name|markidx
argument_list|(
name|curs
argument_list|)
expr_stmt|;
comment|/* if the file hasn't changed& line number is the same& it has no 	 * embedded character attribute strings, can we do shortcuts? 	 */
if|if
condition|(
name|chgs
operator|==
name|changes
operator|&&
operator|!
operator|(
operator|(
name|curs
operator|^
name|pcursor
operator|)
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
ifndef|#
directive|ifndef
name|NO_CHARATTR
operator|&&
operator|!
name|hasattr
argument_list|(
name|markline
argument_list|(
name|curs
argument_list|)
argument_list|,
name|text
argument_list|)
endif|#
directive|endif
condition|)
block|{
comment|/* no movement? */
if|if
condition|(
name|curs
operator|==
name|pcursor
condition|)
block|{
comment|/* return the column of the char; for tabs, return its last column */
if|if
condition|(
name|text
index|[
name|idx
index|]
operator|==
literal|'\t'
operator|&&
operator|!
name|inputting
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
return|return
name|pcol
operator|+
operator|*
name|o_tabstop
operator|-
operator|(
name|pcol
operator|%
operator|*
name|o_tabstop
operator|)
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|pcol
return|;
block|}
block|}
comment|/* movement to right? */
if|if
condition|(
name|curs
operator|>
name|pcursor
condition|)
block|{
comment|/* start counting from previous place */
name|col
operator|=
name|pcol
expr_stmt|;
name|idx
operator|=
name|markidx
argument_list|(
name|curs
argument_list|)
operator|-
name|markidx
argument_list|(
name|pcursor
argument_list|)
expr_stmt|;
name|text
operator|+=
name|markidx
argument_list|(
name|pcursor
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* count over to the char after the idx position */
while|while
condition|(
name|idx
operator|>
literal|0
operator|&&
operator|(
name|i
operator|=
operator|*
name|text
operator|)
condition|)
comment|/* yes, ASSIGNMENT! */
block|{
if|if
condition|(
name|i
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|col
operator|+=
operator|*
name|o_tabstop
expr_stmt|;
name|col
operator|-=
name|col
operator|%
operator|*
name|o_tabstop
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|'\0'
operator|&&
name|i
operator|<
literal|' '
operator|||
name|i
operator|==
literal|'\177'
condition|)
block|{
name|col
operator|+=
literal|2
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_CHARATTR
elseif|else
if|if
condition|(
name|i
operator|==
literal|'\\'
operator|&&
name|text
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|text
index|[
literal|2
index|]
operator|&&
operator|*
name|o_charattr
condition|)
block|{
name|text
operator|+=
literal|2
expr_stmt|;
comment|/* plus one more at bottom of loop */
name|idx
operator|-=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|col
operator|++
expr_stmt|;
block|}
name|text
operator|++
expr_stmt|;
name|idx
operator|--
expr_stmt|;
block|}
comment|/* save stuff to speed next call */
name|pcursor
operator|=
name|curs
expr_stmt|;
name|pcol
operator|=
name|col
expr_stmt|;
name|chgs
operator|=
name|changes
expr_stmt|;
comment|/* return the column of the char; for tabs, return its last column */
if|if
condition|(
operator|*
name|text
operator|==
literal|'\t'
operator|&&
operator|!
name|inputting
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
return|return
name|col
operator|+
operator|*
name|o_tabstop
operator|-
operator|(
name|col
operator|%
operator|*
name|o_tabstop
operator|)
operator|-
literal|1
return|;
block|}
else|else
block|{
return|return
name|col
return|;
block|}
block|}
end_function

begin_comment
comment|/* This function is similar to idx2col except that it takes care of sideways  * scrolling - for the given line, at least.  */
end_comment

begin_function
name|int
name|mark2phys
parameter_list|(
name|m
parameter_list|,
name|text
parameter_list|,
name|inputting
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* a mark to convert */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* the line that m refers to */
name|int
name|inputting
decl_stmt|;
comment|/* boolean: caled from input() ? */
block|{
name|int
name|i
decl_stmt|;
name|i
operator|=
name|idx2col
argument_list|(
name|m
argument_list|,
name|text
argument_list|,
name|inputting
argument_list|)
expr_stmt|;
while|while
condition|(
name|i
operator|<
name|leftcol
condition|)
block|{
name|leftcol
operator|-=
operator|*
name|o_sidescroll
expr_stmt|;
name|mustredraw
operator|=
name|TRUE
expr_stmt|;
name|redrawrange
argument_list|(
literal|1L
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
name|rightcol
condition|)
block|{
name|leftcol
operator|+=
operator|*
name|o_sidescroll
expr_stmt|;
name|mustredraw
operator|=
name|TRUE
expr_stmt|;
name|redrawrange
argument_list|(
literal|1L
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
block|}
name|physrow
operator|=
name|markline
argument_list|(
name|m
argument_list|)
operator|-
name|topline
expr_stmt|;
name|physcol
operator|=
name|i
operator|-
name|leftcol
expr_stmt|;
if|if
condition|(
operator|*
name|o_number
condition|)
name|physcol
operator|+=
literal|8
expr_stmt|;
return|return
name|physcol
return|;
block|}
end_function

begin_comment
comment|/* This function draws a single line of text on the screen.  The screen's  * cursor is assumed to be located at the leftmost column of the appropriate  * row.  */
end_comment

begin_function
specifier|static
name|void
name|drawtext
parameter_list|(
name|text
parameter_list|,
name|lno
parameter_list|,
name|clr
parameter_list|)
name|REG
name|char
modifier|*
name|text
decl_stmt|;
comment|/* the text to draw */
name|long
name|lno
decl_stmt|;
comment|/* the number of the line to draw */
name|int
name|clr
decl_stmt|;
comment|/* boolean: do a clrtoeol? */
block|{
name|REG
name|int
name|col
decl_stmt|;
comment|/* column number */
name|REG
name|int
name|i
decl_stmt|;
name|REG
name|int
name|tabstop
decl_stmt|;
comment|/* *o_tabstop */
name|REG
name|int
name|limitcol
decl_stmt|;
comment|/* leftcol or leftcol + COLS */
name|int
name|abnormal
decl_stmt|;
comment|/* boolean: charattr != A_NORMAL? */
ifndef|#
directive|ifndef
name|NO_VISIBLE
name|int
name|rev
decl_stmt|;
comment|/* boolean: standout mode, too? */
name|int
name|idx
init|=
literal|0
decl_stmt|;
endif|#
directive|endif
name|char
name|numstr
index|[
literal|9
index|]
decl_stmt|;
comment|/* show the line number, if necessary */
if|if
condition|(
operator|*
name|o_number
condition|)
block|{
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%6ld  "
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|numstr
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_SENTENCE
comment|/* if we're hiding format lines, and this is one of them, then hide it */
if|if
condition|(
operator|*
name|o_hideformat
operator|&&
operator|*
name|text
operator|==
literal|'.'
condition|)
block|{
name|clrtoeol
argument_list|()
expr_stmt|;
if|#
directive|if
name|OSK
name|qaddch
argument_list|(
literal|'\l'
argument_list|)
expr_stmt|;
else|#
directive|else
name|qaddch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
endif|#
directive|endif
comment|/* move some things into registers... */
name|limitcol
operator|=
name|leftcol
expr_stmt|;
name|tabstop
operator|=
operator|*
name|o_tabstop
expr_stmt|;
name|abnormal
operator|=
name|FALSE
expr_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
name|clr
condition|)
name|clrtoeol
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* skip stuff that was scrolled off left edge */
for|for
control|(
name|col
operator|=
literal|0
init|;
operator|(
name|i
operator|=
operator|*
name|text
operator|)
operator|&&
name|col
operator|<
name|limitcol
condition|;
comment|/* yes, ASSIGNMENT! */
name|text
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|NO_VISIBLE
name|idx
operator|++
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|i
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|col
operator|=
name|col
operator|+
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|' '
operator|||
name|i
operator|==
literal|'\177'
condition|)
block|{
name|col
operator|+=
literal|2
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_CHARATTR
elseif|else
if|if
condition|(
name|i
operator|==
literal|'\\'
operator|&&
name|text
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|text
index|[
literal|2
index|]
operator|&&
operator|*
name|o_charattr
condition|)
block|{
name|text
operator|+=
literal|2
expr_stmt|;
comment|/* plus one more as part of "for" loop */
comment|/* since this attribute might carry over, we need it */
switch|switch
condition|(
operator|*
name|text
condition|)
block|{
case|case
literal|'R'
case|:
case|case
literal|'P'
case|:
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|attrset
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|attrset
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|attrset
argument_list|(
name|A_ALTCHARSET
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
else|else
block|{
name|col
operator|++
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/* Should we start hiliting at the first char of this line? */
if|if
condition|(
operator|(
name|lno
operator|>
name|vizlow
operator|&&
name|lno
operator|<=
name|vizhigh
operator|||
name|lno
operator|==
name|vizlow
operator|&&
name|vizleft
operator|<
name|idx
operator|)
operator|&&
operator|!
operator|(
name|lno
operator|==
name|vizhigh
operator|&&
name|vizright
operator|<
name|idx
operator|)
condition|)
block|{
name|do_VISIBLE
argument_list|()
expr_stmt|;
name|rev
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* adjust for control char that was partially visible */
while|while
condition|(
name|col
operator|>
name|limitcol
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|limitcol
operator|++
expr_stmt|;
block|}
comment|/* now for the visible characters */
name|limitcol
operator|=
name|leftcol
operator|+
name|COLS
expr_stmt|;
if|if
condition|(
operator|*
name|o_number
condition|)
name|limitcol
operator|-=
literal|8
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|=
operator|*
name|text
operator|)
operator|&&
name|col
operator|<
name|limitcol
condition|;
name|text
operator|++
control|)
block|{
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/* maybe turn hilite on/off in the middle of the line */
if|if
condition|(
name|lno
operator|==
name|vizlow
operator|&&
name|vizleft
operator|==
name|idx
condition|)
block|{
name|do_VISIBLE
argument_list|()
expr_stmt|;
name|rev
operator|=
name|TRUE
expr_stmt|;
block|}
if|if
condition|(
name|lno
operator|==
name|vizhigh
operator|&&
name|vizright
operator|==
name|idx
condition|)
block|{
name|do_SE
argument_list|()
expr_stmt|;
name|rev
operator|=
name|FALSE
expr_stmt|;
block|}
name|idx
operator|++
expr_stmt|;
comment|/* if hiliting, never emit physical tabs */
if|if
condition|(
name|rev
operator|&&
name|i
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|i
operator|=
name|col
operator|+
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
expr_stmt|;
do|do
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|col
operator|<
name|i
operator|&&
name|col
operator|<
name|limitcol
condition|)
do|;
block|}
elseif|else
endif|#
directive|endif
comment|/* !NO_VISIBLE */
if|if
condition|(
name|i
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|i
operator|=
name|col
operator|+
name|tabstop
operator|-
operator|(
name|col
operator|%
name|tabstop
operator|)
expr_stmt|;
if|if
condition|(
name|i
operator|<
name|limitcol
condition|)
block|{
ifdef|#
directive|ifdef
name|CRUNCH
if|if
condition|(
operator|!
name|clr
operator|&&
name|has_PT
operator|&&
operator|!
operator|(
operator|(
name|i
operator|-
name|leftcol
operator|)
operator|&
literal|7
operator|)
condition|)
else|#
directive|else
if|if
condition|(
name|has_PT
operator|&&
operator|!
operator|(
operator|(
name|i
operator|-
name|leftcol
operator|)
operator|&
literal|7
operator|)
condition|)
endif|#
directive|endif
block|{
do|do
block|{
name|qaddch
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|8
expr_stmt|;
comment|/* not exact! */
block|}
do|while
condition|(
name|col
operator|<
name|i
condition|)
do|;
name|col
operator|=
name|i
expr_stmt|;
comment|/* NOW it is exact */
block|}
else|else
block|{
do|do
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
do|while
condition|(
name|col
operator|<
name|i
operator|&&
name|col
operator|<
name|limitcol
condition|)
do|;
block|}
block|}
else|else
comment|/* tab ending after screen? next line! */
block|{
ifdef|#
directive|ifdef
name|CRUNCH
comment|/* needed at least when scrolling the screen right  -nox */
if|if
condition|(
name|clr
operator|&&
name|col
operator|<
name|limitcol
condition|)
name|clrtoeol
argument_list|()
expr_stmt|;
endif|#
directive|endif
name|col
operator|=
name|limitcol
expr_stmt|;
if|if
condition|(
name|has_AM
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
comment|/* GB */
block|}
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|' '
operator|||
name|i
operator|==
literal|'\177'
condition|)
block|{
name|col
operator|+=
literal|2
expr_stmt|;
name|qaddch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
if|if
condition|(
name|col
operator|<=
name|limitcol
condition|)
block|{
name|qaddch
argument_list|(
name|i
operator|^
literal|'@'
argument_list|)
expr_stmt|;
block|}
block|}
ifndef|#
directive|ifndef
name|NO_CHARATTR
elseif|else
if|if
condition|(
name|i
operator|==
literal|'\\'
operator|&&
name|text
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|text
index|[
literal|2
index|]
operator|&&
operator|*
name|o_charattr
condition|)
block|{
name|text
operator|+=
literal|2
expr_stmt|;
comment|/* plus one more as part of "for" loop */
switch|switch
condition|(
operator|*
name|text
condition|)
block|{
case|case
literal|'R'
case|:
case|case
literal|'P'
case|:
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|FALSE
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|attrset
argument_list|(
name|A_BOLD
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'U'
case|:
name|attrset
argument_list|(
name|A_UNDERLINE
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|attrset
argument_list|(
name|A_ALTCHARSET
argument_list|)
expr_stmt|;
name|abnormal
operator|=
name|TRUE
expr_stmt|;
break|break;
block|}
block|}
endif|#
directive|endif
else|else
block|{
name|col
operator|++
expr_stmt|;
name|qaddch
argument_list|(
name|i
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* get ready for the next line */
ifndef|#
directive|ifndef
name|NO_CHARATTR
if|if
condition|(
name|abnormal
condition|)
block|{
name|attrset
argument_list|(
name|A_NORMAL
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|*
name|o_list
operator|&&
name|col
operator|<
name|limitcol
condition|)
block|{
name|qaddch
argument_list|(
literal|'$'
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/* did we hilite this whole line?  If so, STOP! */
if|if
condition|(
name|rev
condition|)
block|{
name|do_SE
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CRUNCH
if|if
condition|(
name|clr
operator|&&
name|col
operator|<
name|limitcol
condition|)
block|{
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
if|if
condition|(
operator|!
name|has_AM
operator|||
name|col
operator|<
name|limitcol
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|wqrefresh
argument_list|()
expr_stmt|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|CRUNCH
end_ifndef

begin_function
specifier|static
name|void
name|nudgecursor
parameter_list|(
name|same
parameter_list|,
name|scan
parameter_list|,
name|new
parameter_list|,
name|lno
parameter_list|)
name|int
name|same
decl_stmt|;
comment|/* number of chars to be skipped over */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* where the same chars end */
name|char
modifier|*
name|new
decl_stmt|;
comment|/* where the visible part of the line starts */
name|long
name|lno
decl_stmt|;
comment|/* line number of this line */
block|{
name|int
name|col
decl_stmt|;
if|if
condition|(
name|same
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|same
operator|<
literal|5
condition|)
block|{
comment|/* move the cursor by overwriting */
while|while
condition|(
name|same
operator|>
literal|0
condition|)
block|{
name|qaddch
argument_list|(
name|scan
index|[
operator|-
name|same
index|]
argument_list|)
expr_stmt|;
name|same
operator|--
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* move the cursor by calling move() */
name|col
operator|=
call|(
name|int
call|)
argument_list|(
name|scan
operator|-
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|o_number
condition|)
name|col
operator|+=
literal|8
expr_stmt|;
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lno
operator|-
name|topline
argument_list|)
argument_list|,
name|col
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not CRUNCH */
end_comment

begin_comment
comment|/* This function draws a single line of text on the screen, possibly with  * some cursor optimization.  The cursor is repositioned before drawing  * begins, so its position before doesn't really matter.  */
end_comment

begin_function
specifier|static
name|void
name|smartdrawtext
parameter_list|(
name|text
parameter_list|,
name|lno
parameter_list|,
name|showit
parameter_list|)
name|REG
name|char
modifier|*
name|text
decl_stmt|;
comment|/* the text to draw */
name|long
name|lno
decl_stmt|;
comment|/* line number of the text */
name|int
name|showit
decl_stmt|;
comment|/* boolean: output line? (else just remember it) */
block|{
ifdef|#
directive|ifdef
name|CRUNCH
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lno
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|showit
condition|)
block|{
name|drawtext
argument_list|(
name|text
argument_list|,
name|lno
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
comment|/* not CRUNCH */
specifier|static
name|char
name|old
index|[
literal|256
index|]
decl_stmt|;
comment|/* how the line looked last time */
name|char
name|new
index|[
literal|256
index|]
decl_stmt|;
comment|/* how it looks now */
name|char
modifier|*
name|build
decl_stmt|;
comment|/* used to put chars into new[] */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used for moving thru new[] or old[] */
name|char
modifier|*
name|end
decl_stmt|;
comment|/* last non-blank changed char */
name|char
modifier|*
name|shift
decl_stmt|;
comment|/* used to insert/delete chars */
name|int
name|same
decl_stmt|;
comment|/* length of a run of unchanged chars */
name|int
name|limitcol
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
name|numstr
index|[
literal|9
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_CHARATTR
comment|/* if this line has attributes, do it the dumb way instead */
if|if
condition|(
name|hasattr
argument_list|(
name|lno
argument_list|,
name|text
argument_list|)
condition|)
block|{
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lno
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawtext
argument_list|(
name|text
argument_list|,
name|lno
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SENTENCE
comment|/* if this line is a format line,& we're hiding format lines, then 	 * let the dumb drawtext() function handle it 	 */
if|if
condition|(
operator|*
name|o_hideformat
operator|&&
operator|*
name|text
operator|==
literal|'.'
condition|)
block|{
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lno
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawtext
argument_list|(
name|text
argument_list|,
name|lno
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_VISIBLE
if|if
condition|(
name|vizchange
condition|)
block|{
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lno
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|drawtext
argument_list|(
name|text
argument_list|,
name|lno
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|smartlno
operator|=
literal|0L
expr_stmt|;
return|return;
block|}
endif|#
directive|endif
comment|/* skip stuff that was scrolled off left edge */
name|limitcol
operator|=
name|leftcol
expr_stmt|;
for|for
control|(
name|col
operator|=
literal|0
init|;
operator|(
name|i
operator|=
operator|*
name|text
operator|)
operator|&&
name|col
operator|<
name|limitcol
condition|;
comment|/* yes, ASSIGNMENT! */
name|text
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|col
operator|=
name|col
operator|+
operator|*
name|o_tabstop
operator|-
operator|(
name|col
operator|%
operator|*
name|o_tabstop
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|' '
operator|||
name|i
operator|==
literal|'\177'
condition|)
block|{
name|col
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|col
operator|++
expr_stmt|;
block|}
block|}
comment|/* adjust for control char that was partially visible */
name|build
operator|=
name|new
expr_stmt|;
while|while
condition|(
name|col
operator|>
name|limitcol
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|' '
expr_stmt|;
name|limitcol
operator|++
expr_stmt|;
block|}
comment|/* now for the visible characters */
name|limitcol
operator|=
name|leftcol
operator|+
name|COLS
expr_stmt|;
if|if
condition|(
operator|*
name|o_number
condition|)
name|limitcol
operator|-=
literal|8
expr_stmt|;
for|for
control|(
init|;
operator|(
name|i
operator|=
operator|*
name|text
operator|)
operator|&&
name|col
operator|<
name|limitcol
condition|;
name|text
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|i
operator|=
name|col
operator|+
operator|*
name|o_tabstop
operator|-
operator|(
name|col
operator|%
operator|*
name|o_tabstop
operator|)
expr_stmt|;
while|while
condition|(
name|col
operator|<
name|i
operator|&&
name|col
operator|<
name|limitcol
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|' '
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|i
operator|>=
literal|0
operator|&&
name|i
operator|<
literal|' '
operator|||
name|i
operator|==
literal|'\177'
condition|)
block|{
name|col
operator|+=
literal|2
expr_stmt|;
operator|*
name|build
operator|++
operator|=
literal|'^'
expr_stmt|;
if|if
condition|(
name|col
operator|<=
name|limitcol
condition|)
block|{
operator|*
name|build
operator|++
operator|=
operator|(
name|i
operator|^
literal|'@'
operator|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|col
operator|++
expr_stmt|;
operator|*
name|build
operator|++
operator|=
name|i
expr_stmt|;
block|}
block|}
if|if
condition|(
name|col
operator|<
name|limitcol
operator|&&
operator|*
name|o_list
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|'$'
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
name|end
operator|=
name|build
expr_stmt|;
while|while
condition|(
name|col
operator|<
name|limitcol
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|' '
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
comment|/* if we're just supposed to remember this line, then remember it */
if|if
condition|(
operator|!
name|showit
condition|)
block|{
name|smartlno
operator|=
name|lno
expr_stmt|;
name|strncpy
argument_list|(
name|old
argument_list|,
name|new
argument_list|,
name|COLS
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* locate the last non-blank character */
while|while
condition|(
name|end
operator|>
name|new
operator|&&
name|end
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
block|{
name|end
operator|--
expr_stmt|;
block|}
comment|/* can we optimize the displaying of this line? */
if|if
condition|(
name|lno
operator|!=
name|smartlno
condition|)
block|{
comment|/* nope, can't optimize - different line */
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lno
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* show the line number, if necessary */
if|if
condition|(
operator|*
name|o_number
condition|)
block|{
name|sprintf
argument_list|(
name|numstr
argument_list|,
literal|"%6ld  "
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|numstr
argument_list|)
expr_stmt|;
block|}
comment|/* show the new line */
for|for
control|(
name|scan
operator|=
name|new
operator|,
name|build
operator|=
name|old
init|;
name|scan
operator|<
name|end
condition|;
control|)
block|{
name|qaddch
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|end
operator|<
name|new
operator|+
name|COLS
operator|-
operator|(
operator|*
name|o_number
condition|?
literal|8
else|:
literal|0
operator|)
condition|)
block|{
name|clrtoeol
argument_list|()
expr_stmt|;
while|while
condition|(
name|build
operator|<
name|old
operator|+
name|COLS
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
name|smartlno
operator|=
name|lno
expr_stmt|;
return|return;
block|}
comment|/* skip any initial unchanged characters */
for|for
control|(
name|scan
operator|=
name|new
operator|,
name|build
operator|=
name|old
init|;
name|scan
operator|<
name|end
operator|&&
operator|*
name|scan
operator|==
operator|*
name|build
condition|;
name|scan
operator|++
operator|,
name|build
operator|++
control|)
block|{ 	}
name|i
operator|=
operator|(
name|scan
operator|-
name|new
operator|)
expr_stmt|;
if|if
condition|(
operator|*
name|o_number
condition|)
name|i
operator|+=
literal|8
expr_stmt|;
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|lno
operator|-
name|topline
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* The in-between characters must be changed */
name|same
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|scan
operator|<
name|end
condition|)
block|{
comment|/* is this character a match? */
if|if
condition|(
name|scan
index|[
literal|0
index|]
operator|==
name|build
index|[
literal|0
index|]
condition|)
block|{
name|same
operator|++
expr_stmt|;
block|}
elseif|else
comment|/* do we want to insert? */
if|if
condition|(
name|scan
operator|<
name|end
operator|-
literal|1
operator|&&
name|scan
index|[
literal|1
index|]
operator|==
name|build
index|[
literal|0
index|]
operator|&&
operator|(
name|has_IC
operator|||
name|has_IM
operator|)
condition|)
block|{
name|nudgecursor
argument_list|(
name|same
argument_list|,
name|scan
argument_list|,
name|new
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|same
operator|=
literal|0
expr_stmt|;
name|insch
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
for|for
control|(
name|shift
operator|=
name|old
operator|+
name|COLS
init|;
operator|--
name|shift
operator|>
name|build
condition|;
control|)
block|{
name|shift
index|[
literal|0
index|]
operator|=
name|shift
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
operator|*
name|build
operator|=
operator|*
name|scan
expr_stmt|;
block|}
elseif|else
comment|/* do we want to delete? */
if|if
condition|(
name|build
operator|<
name|old
operator|+
name|COLS
operator|-
literal|1
operator|&&
name|scan
index|[
literal|0
index|]
operator|==
name|build
index|[
literal|1
index|]
operator|&&
name|has_DC
condition|)
block|{
name|nudgecursor
argument_list|(
name|same
argument_list|,
name|scan
argument_list|,
name|new
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|same
operator|=
literal|0
expr_stmt|;
name|delch
argument_list|()
expr_stmt|;
name|same
operator|++
expr_stmt|;
for|for
control|(
name|shift
operator|=
name|build
init|;
name|shift
operator|<
name|old
operator|+
name|COLS
operator|-
literal|1
condition|;
name|shift
operator|++
control|)
block|{
name|shift
index|[
literal|0
index|]
operator|=
name|shift
index|[
literal|1
index|]
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|o_number
condition|)
name|shift
operator|-=
literal|8
expr_stmt|;
operator|*
name|shift
operator|=
literal|' '
expr_stmt|;
block|}
else|else
comment|/* we must overwrite */
block|{
name|nudgecursor
argument_list|(
name|same
argument_list|,
name|scan
argument_list|,
name|new
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|same
operator|=
literal|0
expr_stmt|;
name|addch
argument_list|(
operator|*
name|scan
argument_list|)
expr_stmt|;
operator|*
name|build
operator|=
operator|*
name|scan
expr_stmt|;
block|}
name|build
operator|++
expr_stmt|;
name|scan
operator|++
expr_stmt|;
block|}
comment|/* maybe clear to EOL */
name|end
operator|=
name|old
operator|+
name|COLS
operator|-
operator|(
operator|*
name|o_number
condition|?
literal|8
else|:
literal|0
operator|)
expr_stmt|;
while|while
condition|(
name|build
operator|<
name|end
operator|&&
operator|*
name|build
operator|==
literal|' '
condition|)
block|{
name|build
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|build
operator|<
name|end
condition|)
block|{
name|nudgecursor
argument_list|(
name|same
argument_list|,
name|scan
argument_list|,
name|new
argument_list|,
name|lno
argument_list|)
expr_stmt|;
name|same
operator|=
literal|0
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
while|while
condition|(
name|build
operator|<
name|old
operator|+
name|COLS
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* not CRUNCH */
block|}
end_function

begin_comment
comment|/* This function is used in visual mode for drawing the screen (or just parts  * of the screen, if that's all thats needed).  It also takes care of  * scrolling.  */
end_comment

begin_function
name|void
name|redraw
parameter_list|(
name|curs
parameter_list|,
name|inputting
parameter_list|)
name|MARK
name|curs
decl_stmt|;
comment|/* where to leave the screen's cursor */
name|int
name|inputting
decl_stmt|;
comment|/* boolean: being called from input() ? */
block|{
name|char
modifier|*
name|text
decl_stmt|;
comment|/* a line of text to display */
specifier|static
name|long
name|chgs
decl_stmt|;
comment|/* previous changes level */
name|long
name|l
decl_stmt|;
name|int
name|i
decl_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
specifier|static
name|long
name|showtop
decl_stmt|;
comment|/* top line in window */
specifier|static
name|long
name|showbottom
decl_stmt|;
comment|/* bottom line in window */
endif|#
directive|endif
comment|/* if curs == MARK_UNSET, then we should reset internal vars */
if|if
condition|(
name|curs
operator|==
name|MARK_UNSET
condition|)
block|{
if|if
condition|(
name|topline
operator|<
literal|1
operator|||
name|topline
operator|>
name|nlines
condition|)
block|{
name|topline
operator|=
literal|1L
expr_stmt|;
block|}
else|else
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
name|leftcol
operator|=
literal|0
expr_stmt|;
name|mustredraw
operator|=
name|TRUE
expr_stmt|;
name|redrawafter
operator|=
name|INFINITY
expr_stmt|;
name|preredraw
operator|=
literal|0L
expr_stmt|;
name|postredraw
operator|=
literal|0L
expr_stmt|;
name|chgs
operator|=
literal|0
expr_stmt|;
name|smartlno
operator|=
literal|0L
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_VISIBLE
name|vizlow
operator|=
name|vizhigh
operator|=
literal|0L
expr_stmt|;
name|vizchange
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
name|showtop
operator|=
literal|0
expr_stmt|;
name|showbottom
operator|=
name|INFINITY
expr_stmt|;
endif|#
directive|endif
return|return;
block|}
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/* adjustments to hilited area may force extra lines to be redrawn. */
name|setviz
argument_list|(
name|curs
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* figure out which column the cursor will be in */
name|l
operator|=
name|markline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
name|text
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|mark2phys
argument_list|(
name|curs
argument_list|,
name|text
argument_list|,
name|inputting
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_COLOR
name|fixcolor
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* adjust topline, if necessary, to get the cursor on the screen */
if|if
condition|(
name|l
operator|>=
name|topline
operator|&&
name|l
operator|<=
name|botline
condition|)
block|{
comment|/* it is on the screen already */
comment|/* if the file was changed but !mustredraw, then redraw line */
if|if
condition|(
operator|!
name|mustredraw
operator|&&
operator|(
name|chgs
operator|!=
name|changes
ifndef|#
directive|ifndef
name|NO_VISIBLE
operator|||
name|V_from
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
operator|||
name|l
operator|<
name|showtop
operator|||
name|l
operator|>
name|showbottom
endif|#
directive|endif
operator|)
condition|)
block|{
name|smartdrawtext
argument_list|(
name|text
argument_list|,
name|l
argument_list|,
operator|(
name|chgs
operator|!=
name|changes
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|l
operator|<
name|topline
operator|&&
name|l
operator|>=
name|topline
operator|-
name|NEAR
operator|&&
operator|(
name|has_SR
operator|||
name|has_AL
operator|)
condition|)
block|{
comment|/* near top - scroll down */
if|if
condition|(
operator|!
name|mustredraw
condition|)
block|{
name|move
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
while|while
condition|(
name|l
operator|<
name|topline
condition|)
block|{
name|topline
operator|--
expr_stmt|;
if|if
condition|(
name|has_SR
condition|)
block|{
name|do_SR
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|insertln
argument_list|()
expr_stmt|;
block|}
name|text
operator|=
name|fetchline
argument_list|(
name|topline
argument_list|)
expr_stmt|;
name|drawtext
argument_list|(
name|text
argument_list|,
name|topline
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|do_UP
argument_list|()
expr_stmt|;
block|}
comment|/* blank out the last line */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|topline
operator|=
name|l
expr_stmt|;
name|redrawrange
argument_list|(
literal|0L
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|l
operator|>
name|topline
operator|&&
name|l
operator|<=
name|botline
operator|+
name|NEAR
condition|)
block|{
comment|/* near bottom -- scroll up */
if|if
condition|(
operator|!
name|mustredraw
condition|)
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
while|while
condition|(
name|l
operator|>
name|botline
condition|)
block|{
name|topline
operator|++
expr_stmt|;
comment|/*<-- also adjusts botline */
name|text
operator|=
name|fetchline
argument_list|(
name|botline
argument_list|)
expr_stmt|;
name|drawtext
argument_list|(
name|text
argument_list|,
name|botline
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
name|showbottom
operator|=
name|l
expr_stmt|;
endif|#
directive|endif
block|}
else|else
block|{
name|topline
operator|=
name|l
operator|-
operator|(
name|LINES
operator|-
literal|2
operator|)
expr_stmt|;
name|redrawrange
argument_list|(
literal|0L
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* distant line - center it& force a redraw */
name|topline
operator|=
name|l
operator|-
operator|(
name|LINES
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|topline
operator|<
literal|1
condition|)
block|{
name|topline
operator|=
literal|1
expr_stmt|;
block|}
name|redrawrange
argument_list|(
literal|0L
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
name|smartlno
operator|=
literal|0L
expr_stmt|;
name|changes
operator|++
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* make sure the current line is included in the "window" */
if|if
condition|(
name|l
operator|<
name|showtop
condition|)
block|{
name|redrawrange
argument_list|(
name|l
argument_list|,
name|showtop
argument_list|,
name|showtop
argument_list|)
expr_stmt|;
name|showtop
operator|=
name|l
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
name|showbottom
condition|)
block|{
name|redrawrange
argument_list|(
name|showbottom
argument_list|,
name|l
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|showbottom
operator|=
name|l
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Now... do we really have to redraw? */
if|if
condition|(
name|mustredraw
condition|)
block|{
comment|/* If redrawfter (and friends) aren't set, assume we should 		 * redraw everything. 		 */
if|if
condition|(
name|redrawafter
operator|==
name|INFINITY
condition|)
block|{
name|redrawafter
operator|=
literal|0L
expr_stmt|;
name|preredraw
operator|=
name|postredraw
operator|=
name|INFINITY
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* shrink the window, if possible */
if|if
condition|(
name|showtop
operator|<
name|topline
condition|)
block|{
name|showtop
operator|=
name|topline
expr_stmt|;
block|}
if|if
condition|(
name|showbottom
operator|>
name|botline
condition|)
block|{
name|showbottom
operator|=
name|botline
expr_stmt|;
block|}
if|if
condition|(
name|postredraw
operator|==
name|INFINITY
condition|)
block|{
comment|/* these will be set to more reasonable values later */
name|showtop
operator|=
name|INFINITY
expr_stmt|;
name|showbottom
operator|=
literal|0L
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* adjust smartlno to correspond with inserted/deleted lines */
if|if
condition|(
name|smartlno
operator|>=
name|redrawafter
condition|)
block|{
if|if
condition|(
name|smartlno
operator|<
name|preredraw
operator|&&
name|postredraw
operator|!=
name|preredraw
condition|)
comment|/*!!!*/
block|{
name|smartlno
operator|=
literal|0L
expr_stmt|;
block|}
else|else
block|{
name|smartlno
operator|+=
operator|(
name|postredraw
operator|-
name|preredraw
operator|)
expr_stmt|;
block|}
block|}
comment|/* should we insert some lines into the screen? */
if|if
condition|(
name|preredraw
operator|<
name|postredraw
operator|&&
name|preredraw
operator|<=
name|botline
condition|)
block|{
comment|/* lines were inserted into the file */
comment|/* decide where insertion should start */
if|if
condition|(
name|preredraw
operator|<
name|topline
condition|)
block|{
name|l
operator|=
name|topline
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|preredraw
expr_stmt|;
block|}
comment|/* insert the lines... maybe */
if|if
condition|(
name|l
operator|+
name|postredraw
operator|-
name|preredraw
operator|>
name|botline
operator|||
operator|!
name|has_AL
operator|||
operator|*
name|o_number
condition|)
block|{
comment|/* Whoa!  a whole screen full - just redraw */
name|preredraw
operator|=
name|postredraw
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
block|{
comment|/* really insert 'em */
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|l
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|postredraw
operator|-
name|preredraw
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
name|insertln
argument_list|()
expr_stmt|;
block|}
comment|/* NOTE: the contents of those lines will be 				 * drawn as part of the regular redraw loop. 				 */
comment|/* clear the last line */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* do we want to delete some lines from the screen? */
if|if
condition|(
name|preredraw
operator|>
name|postredraw
operator|&&
name|postredraw
operator|<=
name|botline
condition|)
block|{
if|if
condition|(
name|preredraw
operator|>
name|botline
operator|||
operator|!
name|has_DL
operator|||
operator|*
name|o_number
condition|)
block|{
name|postredraw
operator|=
name|preredraw
operator|=
name|INFINITY
expr_stmt|;
block|}
else|else
comment|/* we'd best delete some lines from the screen */
block|{
comment|/* clear the last line, so it doesn't look 				 * ugly as it gets pulled up into the screen 				 */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* delete the lines */
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|postredraw
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|postredraw
init|;
name|l
operator|<
name|preredraw
operator|&&
name|l
operator|<=
name|botline
condition|;
name|l
operator|++
control|)
block|{
name|deleteln
argument_list|()
expr_stmt|;
block|}
comment|/* draw the lines that are now newly visible 				 * at the bottom of the screen 				 */
name|i
operator|=
name|LINES
operator|-
literal|1
operator|+
operator|(
name|postredraw
operator|-
name|preredraw
operator|)
expr_stmt|;
name|move
argument_list|(
name|i
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|l
operator|=
name|topline
operator|+
name|i
init|;
name|l
operator|<=
name|botline
condition|;
name|l
operator|++
control|)
block|{
comment|/* clear this line */
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* draw the line, or ~ for non-lines */
if|if
condition|(
name|l
operator|<=
name|nlines
condition|)
block|{
name|text
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|drawtext
argument_list|(
name|text
argument_list|,
name|l
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|addstr
argument_list|(
literal|"~\n"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* redraw the current line */
name|l
operator|=
name|markline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
name|pfetch
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|smartdrawtext
argument_list|(
name|ptext
argument_list|,
name|l
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* decide which lines must be in the "window" around the cursor */
name|l
operator|=
name|markline
argument_list|(
name|curs
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|o_window
operator|&
literal|0xff
operator|)
operator|+
literal|1
operator|==
name|LINES
condition|)
block|{
name|showtop
operator|=
literal|1
expr_stmt|;
name|showbottom
operator|=
name|INFINITY
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|l
operator|<
name|showtop
operator|||
name|l
operator|>
name|showbottom
condition|)
block|{
name|l
operator|-=
operator|(
operator|*
name|o_window
operator|&
literal|0xff
operator|)
operator|/
literal|2
expr_stmt|;
if|if
condition|(
name|l
operator|<
name|topline
condition|)
block|{
name|l
operator|=
name|topline
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<
name|showtop
condition|)
block|{
name|showtop
operator|=
name|l
expr_stmt|;
block|}
name|l
operator|+=
operator|(
operator|*
name|o_window
operator|&
literal|0xff
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
name|l
operator|>
name|botline
condition|)
block|{
name|showtop
operator|=
name|showtop
operator|-
name|l
operator|+
name|botline
expr_stmt|;
name|l
operator|=
name|botline
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|>
name|showbottom
condition|)
block|{
name|showbottom
operator|=
name|l
expr_stmt|;
block|}
block|}
endif|#
directive|endif
comment|/* decide where we should start redrawing from */
if|if
condition|(
name|redrawafter
operator|<
name|topline
condition|)
block|{
name|l
operator|=
name|topline
expr_stmt|;
block|}
else|else
block|{
name|l
operator|=
name|redrawafter
expr_stmt|;
block|}
if|if
condition|(
name|l
operator|<=
name|botline
operator|&&
name|l
operator|<
name|postredraw
operator|&&
operator|(
name|l
operator|!=
name|smartlno
operator|||
name|botline
operator|!=
name|smartlno
operator|)
condition|)
block|{
comment|/* draw the other lines */
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|l
operator|-
name|topline
argument_list|)
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
init|;
name|l
operator|<=
name|botline
operator|&&
name|l
operator|<
name|postredraw
condition|;
name|l
operator|++
control|)
block|{
comment|/* we already drew the current line, so skip it now */
if|if
condition|(
name|l
operator|==
name|smartlno
condition|)
block|{
if|#
directive|if
name|OSK
name|qaddch
argument_list|(
literal|'\l'
argument_list|)
expr_stmt|;
else|#
directive|else
name|qaddch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
endif|#
directive|endif
continue|continue;
block|}
comment|/* draw the line, or ~ for non-lines */
if|if
condition|(
name|l
operator|>
name|nlines
condition|)
block|{
name|qaddch
argument_list|(
literal|'~'
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
elseif|else
if|if
condition|(
name|l
operator|<
name|showtop
operator|||
name|l
operator|>
name|showbottom
condition|)
block|{
name|qaddch
argument_list|(
literal|'@'
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
else|else
block|{
name|text
operator|=
name|fetchline
argument_list|(
name|l
argument_list|)
expr_stmt|;
name|drawtext
argument_list|(
name|text
argument_list|,
name|l
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|mustredraw
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* force total (non-partial) redraw next time if not set */
name|redrawafter
operator|=
name|INFINITY
expr_stmt|;
name|preredraw
operator|=
literal|0L
expr_stmt|;
name|postredraw
operator|=
literal|0L
expr_stmt|;
comment|/* move the cursor to where it belongs */
name|move
argument_list|(
call|(
name|int
call|)
argument_list|(
name|markline
argument_list|(
name|curs
argument_list|)
operator|-
name|topline
argument_list|)
argument_list|,
name|physcol
argument_list|)
expr_stmt|;
name|wqrefresh
argument_list|()
expr_stmt|;
name|chgs
operator|=
name|changes
expr_stmt|;
block|}
end_function

end_unit

