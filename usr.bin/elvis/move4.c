begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* move4.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains movement functions which are screen-relative */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/* This moves the cursor to a particular row on the screen */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|m_row
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* the cursor position */
name|long
name|cnt
decl_stmt|;
comment|/* the row we'll move to */
name|int
name|key
decl_stmt|;
comment|/* the keystroke of this move - H/L/M */
block|{
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* calculate destination line based on key */
name|cnt
operator|--
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'H'
case|:
name|cnt
operator|=
name|topline
operator|+
name|cnt
expr_stmt|;
break|break;
case|case
literal|'M'
case|:
name|cnt
operator|=
name|topline
operator|+
operator|(
name|LINES
operator|-
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|cnt
operator|=
name|botline
operator|-
name|cnt
expr_stmt|;
break|break;
block|}
comment|/* return the mark of the destination line */
return|return
name|MARK_AT_LINE
argument_list|(
name|cnt
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This function repositions the current line to show on a given row */
end_comment

begin_function
name|MARK
name|m_z
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* the cursor */
name|long
name|cnt
decl_stmt|;
comment|/* the line number we're repositioning */
name|int
name|key
decl_stmt|;
comment|/* key struck after the z */
block|{
name|long
name|newtop
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* Which line are we talking about? */
if|if
condition|(
name|cnt
operator|<
literal|0
operator|||
name|cnt
operator|>
name|nlines
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
if|if
condition|(
name|cnt
condition|)
block|{
name|m
operator|=
name|MARK_AT_LINE
argument_list|(
name|cnt
argument_list|)
expr_stmt|;
name|newtop
operator|=
name|cnt
expr_stmt|;
block|}
else|else
block|{
name|newtop
operator|=
name|markline
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* allow a "window size" number to be entered */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|key
operator|>=
literal|'0'
operator|&&
name|key
operator|<=
literal|'9'
condition|;
name|key
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
control|)
block|{
name|i
operator|=
name|i
operator|*
literal|10
operator|+
name|key
operator|-
literal|'0'
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|i
operator|<=
name|LINES
operator|-
literal|1
condition|)
block|{
operator|*
name|o_window
operator|=
name|i
expr_stmt|;
name|wset
operator|=
name|TRUE
expr_stmt|;
block|}
else|#
directive|else
comment|/* the number is ignored if -DCRUNCH */
endif|#
directive|endif
comment|/* figure out which line will have to be at the top of the screen */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'\n'
case|:
if|#
directive|if
name|OSK
case|case
literal|'\l'
case|:
else|#
directive|else
case|case
literal|'\r'
case|:
endif|#
directive|endif
case|case
literal|'+'
case|:
break|break;
case|case
literal|'.'
case|:
case|case
literal|'z'
case|:
name|newtop
operator|-=
name|LINES
operator|/
literal|2
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|newtop
operator|-=
name|LINES
operator|-
literal|1
expr_stmt|;
break|break;
default|default:
return|return
name|MARK_UNSET
return|;
block|}
comment|/* make the new topline take effect */
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|newtop
operator|>=
literal|1
condition|)
block|{
name|topline
operator|=
name|newtop
expr_stmt|;
block|}
else|else
block|{
name|topline
operator|=
literal|1L
expr_stmt|;
block|}
name|redrawrange
argument_list|(
literal|0L
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
comment|/* The cursor doesn't move */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function scrolls the screen.  It does this by calling redraw() with  * an off-screen line as the argument.  It will move the cursor if necessary  * so that the cursor is on the new screen.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|m_scroll
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* the cursor position */
name|long
name|cnt
decl_stmt|;
comment|/* for some keys: the number of lines to scroll */
name|int
name|key
decl_stmt|;
comment|/* keystroke that causes this movement */
block|{
name|MARK
name|tmp
decl_stmt|;
comment|/* a temporary mark, used as arg to redraw() */
ifndef|#
directive|ifndef
name|CRUNCH
name|int
name|savenearscroll
decl_stmt|;
name|savenearscroll
operator|=
operator|*
name|o_nearscroll
expr_stmt|;
operator|*
name|o_nearscroll
operator|=
name|LINES
expr_stmt|;
endif|#
directive|endif
comment|/* adjust cnt, and maybe *o_scroll, depending of key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|ctrl
argument_list|(
literal|'F'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'B'
argument_list|)
case|:
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|redrawrange
argument_list|(
literal|0L
argument_list|,
name|INFINITY
argument_list|,
name|INFINITY
argument_list|)
expr_stmt|;
comment|/* force complete redraw */
name|cnt
operator|=
name|cnt
operator|*
operator|(
name|LINES
operator|-
literal|1
operator|)
operator|-
literal|2
expr_stmt|;
comment|/* keeps two old lines on screen */
break|break;
case|case
name|ctrl
argument_list|(
literal|'E'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'Y'
argument_list|)
case|:
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
break|break;
case|case
name|ctrl
argument_list|(
literal|'U'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'D'
argument_list|)
case|:
if|if
condition|(
name|cnt
operator|==
literal|0
condition|)
comment|/* default */
block|{
name|cnt
operator|=
operator|*
name|o_scroll
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|cnt
operator|>
name|LINES
operator|-
literal|1
condition|)
block|{
name|cnt
operator|=
name|LINES
operator|-
literal|1
expr_stmt|;
block|}
operator|*
name|o_scroll
operator|=
name|cnt
expr_stmt|;
block|}
break|break;
block|}
comment|/* scroll up or down, depending on key */
switch|switch
condition|(
name|key
condition|)
block|{
case|case
name|ctrl
argument_list|(
literal|'B'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'Y'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'U'
argument_list|)
case|:
name|cnt
operator|=
name|topline
operator|-
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|1L
condition|)
block|{
name|cnt
operator|=
literal|1L
expr_stmt|;
name|m
operator|=
name|MARK_FIRST
expr_stmt|;
block|}
name|tmp
operator|=
name|MARK_AT_LINE
argument_list|(
name|cnt
argument_list|)
operator|+
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|redraw
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|markline
argument_list|(
name|m
argument_list|)
operator|>
name|botline
condition|)
block|{
name|m
operator|=
name|MARK_AT_LINE
argument_list|(
name|botline
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
name|ctrl
argument_list|(
literal|'F'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'E'
argument_list|)
case|:
case|case
name|ctrl
argument_list|(
literal|'D'
argument_list|)
case|:
name|cnt
operator|=
name|botline
operator|+
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|>
name|nlines
condition|)
block|{
name|cnt
operator|=
name|nlines
expr_stmt|;
name|m
operator|=
name|MARK_LAST
expr_stmt|;
block|}
name|tmp
operator|=
name|MARK_AT_LINE
argument_list|(
name|cnt
argument_list|)
operator|+
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|redraw
argument_list|(
name|tmp
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
if|if
condition|(
name|markline
argument_list|(
name|m
argument_list|)
operator|<
name|topline
condition|)
block|{
name|m
operator|=
name|MARK_AT_LINE
argument_list|(
name|topline
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
operator|*
name|o_nearscroll
operator|=
name|savenearscroll
expr_stmt|;
endif|#
directive|endif
return|return
name|m
return|;
block|}
end_function

end_unit

