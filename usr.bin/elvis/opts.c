begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* opts.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the code that manages the run-time options -- The   * values that can be modified via the "set" command.  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_ifndef
ifndef|#
directive|ifndef
name|NULL
end_ifndef

begin_define
define|#
directive|define
name|NULL
value|(char *)0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* maximum width to permit for strings, including ="" */
end_comment

begin_define
define|#
directive|define
name|MAXWIDTH
value|20
end_define

begin_comment
comment|/* These are the default values of all options */
end_comment

begin_decl_stmt
name|char
name|o_autoindent
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_autoprint
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_autotab
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_autowrite
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_columns
index|[
literal|3
index|]
init|=
block|{
literal|80
block|,
literal|32
block|,
operator|~
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_directory
index|[
literal|30
index|]
init|=
name|TMPDIR
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_edcompatible
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_equalprg
index|[
literal|80
index|]
init|=
block|{
literal|"fmt"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_errorbells
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_exrefresh
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_ignorecase
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_keytime
index|[
literal|3
index|]
init|=
block|{
literal|2
block|,
literal|0
block|,
literal|50
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_keywordprg
index|[
literal|80
index|]
init|=
block|{
name|KEYWORDPRG
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_lines
index|[
literal|3
index|]
init|=
block|{
literal|25
block|,
literal|2
block|,
literal|96
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_list
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_number
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_readonly
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_remap
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_report
index|[
literal|3
index|]
init|=
block|{
literal|5
block|,
literal|1
block|,
literal|127
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_scroll
index|[
literal|3
index|]
init|=
block|{
literal|12
block|,
literal|1
block|,
literal|127
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_shell
index|[
literal|60
index|]
init|=
name|SHELL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_shiftwidth
index|[
literal|3
index|]
init|=
block|{
literal|8
block|,
literal|1
block|,
operator|~
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_sidescroll
index|[
literal|3
index|]
init|=
block|{
literal|8
block|,
literal|1
block|,
literal|40
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_sync
index|[
literal|1
index|]
init|=
block|{
name|NEEDSYNC
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_tabstop
index|[
literal|3
index|]
init|=
block|{
literal|8
block|,
literal|1
block|,
literal|40
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_term
index|[
literal|30
index|]
init|=
literal|"?"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_flash
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_warn
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_wrapscan
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|CRUNCH
end_ifndef

begin_decl_stmt
name|char
name|o_beautify
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_exrc
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_mesg
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_more
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_nearscroll
index|[
literal|3
index|]
init|=
block|{
literal|15
block|,
literal|0
block|,
operator|~
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_novice
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_prompt
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_taglength
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|30
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_tags
index|[
literal|256
index|]
init|=
block|{
literal|"tags"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_terse
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_window
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|1
block|,
literal|24
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_wrapmargin
index|[
literal|3
index|]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|~
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_writeany
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRLIST
end_ifndef

begin_decl_stmt
name|char
name|o_cc
index|[
literal|30
index|]
init|=
block|{
name|CC_COMMAND
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_make
index|[
literal|30
index|]
init|=
block|{
name|MAKE_COMMAND
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_CHARATTR
end_ifndef

begin_decl_stmt
name|char
name|o_charattr
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_DIGRAPH
end_ifndef

begin_decl_stmt
name|char
name|o_digraph
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_flipcase
index|[
literal|80
index|]
ifdef|#
directive|ifdef
name|CS_IBMPC
init|=
block|{
literal|"\207\200\201\232\202\220\204\216\206\217\221\222\224\231\244\245"
block|}
endif|#
directive|endif
ifdef|#
directive|ifdef
name|CS_LATIN1
comment|/* initialized by initopts() */
endif|#
directive|endif
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SENTENCE
end_ifndef

begin_decl_stmt
name|char
name|o_hideformat
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
end_ifndef

begin_decl_stmt
name|char
name|o_inputmode
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_ruler
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MAGIC
end_ifndef

begin_decl_stmt
name|char
name|o_magic
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MODELINES
end_ifndef

begin_decl_stmt
name|char
name|o_modelines
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SENTENCE
end_ifndef

begin_decl_stmt
name|char
name|o_paragraphs
index|[
literal|30
index|]
init|=
literal|"PPppIPLPQP"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|o_sections
index|[
literal|30
index|]
init|=
literal|"NHSHSSSEse"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_decl_stmt
name|char
name|o_pcbios
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SHOWMATCH
end_ifndef

begin_decl_stmt
name|char
name|o_showmatch
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SHOWMODE
end_ifndef

begin_decl_stmt
name|char
name|o_smd
index|[
literal|1
index|]
init|=
block|{
name|FALSE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_TAGSTACK
end_ifndef

begin_decl_stmt
name|char
name|o_tagstack
index|[
literal|1
index|]
init|=
block|{
name|TRUE
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* The following describes the names& types of all options */
end_comment

begin_define
define|#
directive|define
name|BOOL
value|0
end_define

begin_define
define|#
directive|define
name|NUM
value|1
end_define

begin_define
define|#
directive|define
name|STR
value|2
end_define

begin_define
define|#
directive|define
name|SET
value|0x01
end_define

begin_comment
comment|/* this option has had its value altered */
end_comment

begin_define
define|#
directive|define
name|CANSET
value|0x02
end_define

begin_comment
comment|/* this option can be set at any time */
end_comment

begin_define
define|#
directive|define
name|RCSET
value|0x06
end_define

begin_comment
comment|/* this option can be set in a .exrc file only */
end_comment

begin_define
define|#
directive|define
name|NOSAVE
value|0x0a
end_define

begin_comment
comment|/* this option should never be saved by mkexrc */
end_comment

begin_define
define|#
directive|define
name|WSET
value|0x20
end_define

begin_comment
comment|/* is this the "window" size option? */
end_comment

begin_define
define|#
directive|define
name|MR
value|0x40
end_define

begin_comment
comment|/* does this option affect the way text is displayed? */
end_comment

begin_struct
struct|struct
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of an option */
name|char
modifier|*
name|nm
decl_stmt|;
comment|/* short name of an option */
name|char
name|type
decl_stmt|;
comment|/* type of an option */
name|char
name|flags
decl_stmt|;
comment|/* boolean: has this option been set? */
name|char
modifier|*
name|value
decl_stmt|;
comment|/* value */
block|}
name|opts
index|[]
init|=
block|{
comment|/* name			type	flags		value */
block|{
literal|"autoindent"
block|,
literal|"ai"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_autoindent
block|}
block|,
block|{
literal|"autoprint"
block|,
literal|"ap"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_autoprint
block|}
block|,
block|{
literal|"autotab"
block|,
literal|"at"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_autotab
block|}
block|,
block|{
literal|"autowrite"
block|,
literal|"aw"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_autowrite
block|}
block|,
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"beautify"
block|,
literal|"bf"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_beautify
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
block|{
literal|"cc"
block|,
literal|"cc"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_cc
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CHARATTR
block|{
literal|"charattr"
block|,
literal|"ca"
block|,
name|BOOL
block|,
name|CANSET
operator||
name|MR
block|,
name|o_charattr
block|}
block|,
endif|#
directive|endif
block|{
literal|"columns"
block|,
literal|"co"
block|,
name|NUM
block|,
name|SET
operator||
name|NOSAVE
operator||
name|MR
block|,
name|o_columns
block|}
block|,
ifndef|#
directive|ifndef
name|NO_DIGRAPH
block|{
literal|"digraph"
block|,
literal|"dig"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_digraph
block|}
block|,
endif|#
directive|endif
block|{
literal|"directory"
block|,
literal|"dir"
block|,
name|STR
block|,
name|RCSET
block|,
name|o_directory
block|}
block|,
block|{
literal|"edcompatible"
block|,
literal|"ed"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_edcompatible
block|}
block|,
block|{
literal|"equalprg"
block|,
literal|"ep"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_equalprg
block|}
block|,
block|{
literal|"errorbells"
block|,
literal|"eb"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_errorbells
block|}
block|,
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"exrc"
block|,
literal|"exrc"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_exrc
block|}
block|,
endif|#
directive|endif
block|{
literal|"exrefresh"
block|,
literal|"er"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_exrefresh
block|}
block|,
block|{
literal|"flash"
block|,
literal|"vbell"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_flash
block|}
block|,
ifndef|#
directive|ifndef
name|NO_DIGRAPH
block|{
literal|"flipcase"
block|,
literal|"fc"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_flipcase
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SENTENCE
block|{
literal|"hideformat"
block|,
literal|"hf"
block|,
name|BOOL
block|,
name|CANSET
operator||
name|MR
block|,
name|o_hideformat
block|}
block|,
endif|#
directive|endif
block|{
literal|"ignorecase"
block|,
literal|"ic"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_ignorecase
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
block|{
literal|"inputmode"
block|,
literal|"im"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_inputmode
block|}
block|,
endif|#
directive|endif
block|{
literal|"keytime"
block|,
literal|"kt"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_keytime
block|}
block|,
block|{
literal|"keywordprg"
block|,
literal|"kp"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_keywordprg
block|}
block|,
block|{
literal|"lines"
block|,
literal|"ls"
block|,
name|NUM
block|,
name|SET
operator||
name|NOSAVE
operator||
name|MR
block|,
name|o_lines
block|}
block|,
block|{
literal|"list"
block|,
literal|"li"
block|,
name|BOOL
block|,
name|CANSET
operator||
name|MR
block|,
name|o_list
block|}
block|,
ifndef|#
directive|ifndef
name|NO_MAGIC
block|{
literal|"magic"
block|,
literal|"ma"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_magic
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
block|{
literal|"make"
block|,
literal|"mk"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_make
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"mesg"
block|,
literal|"me"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_mesg
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_MODELINES
block|{
literal|"modelines"
block|,
literal|"ml"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_modelines
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"more"
block|,
literal|"mo"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_more
block|}
block|,
block|{
literal|"nearscroll"
block|,
literal|"ns"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_nearscroll
block|}
block|,
block|{
literal|"novice"
block|,
literal|"nov"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_novice
block|}
block|,
endif|#
directive|endif
block|{
literal|"number"
block|,
literal|"nu"
block|,
name|BOOL
block|,
name|CANSET
operator||
name|MR
block|,
name|o_number
block|}
block|,
ifndef|#
directive|ifndef
name|NO_SENTENCE
block|{
literal|"paragraphs"
block|,
literal|"para"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_paragraphs
block|}
block|,
endif|#
directive|endif
if|#
directive|if
name|MSDOS
block|{
literal|"pcbios"
block|,
literal|"pc"
block|,
name|BOOL
block|,
name|SET
operator||
name|NOSAVE
block|,
name|o_pcbios
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"prompt"
block|,
literal|"pr"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_prompt
block|}
block|,
endif|#
directive|endif
block|{
literal|"readonly"
block|,
literal|"ro"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_readonly
block|}
block|,
block|{
literal|"remap"
block|,
literal|"remap"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_remap
block|}
block|,
block|{
literal|"report"
block|,
literal|"re"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_report
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
block|{
literal|"ruler"
block|,
literal|"ru"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_ruler
block|}
block|,
endif|#
directive|endif
block|{
literal|"scroll"
block|,
literal|"sc"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_scroll
block|}
block|,
ifndef|#
directive|ifndef
name|NO_SENTENCE
block|{
literal|"sections"
block|,
literal|"sect"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_sections
block|}
block|,
endif|#
directive|endif
block|{
literal|"shell"
block|,
literal|"sh"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_shell
block|}
block|,
ifndef|#
directive|ifndef
name|NO_SHOWMATCH
block|{
literal|"showmatch"
block|,
literal|"sm"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_showmatch
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SHOWMODE
block|{
literal|"showmode"
block|,
literal|"smd"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_smd
block|}
block|,
endif|#
directive|endif
block|{
literal|"shiftwidth"
block|,
literal|"sw"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_shiftwidth
block|}
block|,
block|{
literal|"sidescroll"
block|,
literal|"ss"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_sidescroll
block|}
block|,
block|{
literal|"sync"
block|,
literal|"sy"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_sync
block|}
block|,
block|{
literal|"tabstop"
block|,
literal|"ts"
block|,
name|NUM
block|,
name|CANSET
operator||
name|MR
block|,
name|o_tabstop
block|}
block|,
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"taglength"
block|,
literal|"tl"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_taglength
block|}
block|,
block|{
literal|"tags"
block|,
literal|"tag"
block|,
name|STR
block|,
name|CANSET
block|,
name|o_tags
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_TAGSTACK
block|{
literal|"tagstack"
block|,
literal|"tgs"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_tagstack
block|}
block|,
endif|#
directive|endif
block|{
literal|"term"
block|,
literal|"te"
block|,
name|STR
block|,
name|SET
block|,
name|o_term
block|}
block|,
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"terse"
block|,
literal|"tr"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_terse
block|}
block|,
block|{
literal|"timeout"
block|,
literal|"to"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_keytime
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"window"
block|,
literal|"wi"
block|,
name|NUM
block|,
name|CANSET
operator||
name|MR
operator||
name|WSET
block|,
name|o_window
block|}
block|,
block|{
literal|"wrapmargin"
block|,
literal|"wm"
block|,
name|NUM
block|,
name|CANSET
block|,
name|o_wrapmargin
block|}
block|,
endif|#
directive|endif
block|{
literal|"wrapscan"
block|,
literal|"ws"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_wrapscan
block|}
block|,
ifndef|#
directive|ifndef
name|CRUNCH
block|{
literal|"writeany"
block|,
literal|"wr"
block|,
name|BOOL
block|,
name|CANSET
block|,
name|o_writeany
block|}
block|,
endif|#
directive|endif
block|{
name|NULL
block|,
name|NULL
block|,
literal|0
block|,
name|CANSET
block|,
name|NULL
block|}
block|}
struct|;
end_struct

begin_comment
comment|/* This function initializes certain options from environment variables, etc. */
end_comment

begin_function
name|void
name|initopts
parameter_list|()
block|{
name|char
modifier|*
name|val
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* set some stuff from environment variables */
if|#
directive|if
name|MSDOS
if|if
condition|(
name|val
operator|=
name|getenv
argument_list|(
literal|"COMSPEC"
argument_list|)
condition|)
comment|/* yes, ASSIGNMENT! */
else|#
directive|else
if|if
condition|(
name|val
operator|=
name|getenv
argument_list|(
literal|"SHELL"
argument_list|)
condition|)
comment|/* yes, ASSIGNMENT! */
endif|#
directive|endif
block|{
name|strcpy
argument_list|(
name|o_shell
argument_list|,
name|val
argument_list|)
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|o_term
argument_list|,
name|termtype
argument_list|)
expr_stmt|;
if|#
directive|if
name|MSDOS
if|if
condition|(
name|strcmp
argument_list|(
name|termtype
argument_list|,
literal|"pcbios"
argument_list|)
condition|)
block|{
name|o_pcbios
index|[
literal|0
index|]
operator|=
name|FALSE
expr_stmt|;
block|}
else|else
block|{
name|o_pcbios
index|[
literal|0
index|]
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
if|#
directive|if
name|AMIGA
operator|||
name|MSDOS
operator|||
name|TOS
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"TMP"
argument_list|)
operator|)
comment|/* yes, ASSIGNMENT! */
operator|||
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"TEMP"
argument_list|)
operator|)
condition|)
name|strcpy
argument_list|(
name|o_directory
argument_list|,
name|val
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"LINES"
argument_list|)
operator|)
operator|&&
name|atoi
argument_list|(
name|val
argument_list|)
operator|>
literal|4
condition|)
comment|/* yes, ASSIGNMENT! */
block|{
name|LINES
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|val
operator|=
name|getenv
argument_list|(
literal|"COLUMNS"
argument_list|)
operator|)
operator|&&
name|atoi
argument_list|(
name|val
argument_list|)
operator|>
literal|30
condition|)
comment|/* yes, ASSIGNMENT! */
block|{
name|COLS
operator|=
name|atoi
argument_list|(
name|val
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|o_lines
operator|=
name|LINES
expr_stmt|;
operator|*
name|o_columns
operator|=
name|COLS
expr_stmt|;
operator|*
name|o_scroll
operator|=
name|LINES
operator|/
literal|2
operator|-
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
name|o_window
index|[
literal|0
index|]
operator|==
literal|0
condition|)
block|{
name|o_window
index|[
literal|0
index|]
operator|=
name|o_window
index|[
literal|2
index|]
operator|=
operator|*
name|o_lines
expr_stmt|;
block|}
operator|*
name|o_nearscroll
operator|=
operator|*
name|o_lines
expr_stmt|;
endif|#
directive|endif
comment|/* disable the flash option if we don't know how to do a flash */
if|if
condition|(
operator|!
name|has_VB
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|!=
name|o_flash
condition|;
name|i
operator|++
control|)
block|{ 		}
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&=
operator|~
name|CANSET
expr_stmt|;
operator|*
name|o_flash
operator|=
name|FALSE
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_DIGRAPH
ifdef|#
directive|ifdef
name|CS_LATIN1
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|val
operator|=
name|o_flipcase
init|;
name|i
operator|<
literal|32
condition|;
name|i
operator|++
control|)
block|{
comment|/* leave out the multiply/divide symbols */
if|if
condition|(
name|i
operator|==
literal|23
condition|)
continue|continue;
comment|/* add lower/uppercase pair */
operator|*
name|val
operator|++
operator|=
name|i
operator|+
literal|0xe0
expr_stmt|;
operator|*
name|val
operator|++
operator|=
name|i
operator|+
literal|0xc0
expr_stmt|;
block|}
operator|*
name|val
operator|=
literal|'\0'
expr_stmt|;
endif|#
directive|endif
comment|/* CS_LATIN1 */
comment|/* initialize the ctype package */
name|_ct_init
argument_list|(
name|o_flipcase
argument_list|)
expr_stmt|;
else|#
directive|else
name|_ct_init
argument_list|(
literal|""
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_DIGRAPH */
block|}
end_function

begin_comment
comment|/* This function lists the current values of all options */
end_comment

begin_function
name|void
name|dumpopts
parameter_list|(
name|all
parameter_list|)
name|int
name|all
decl_stmt|;
comment|/* boolean: dump all options, or just set ones? */
block|{
ifndef|#
directive|ifndef
name|NO_OPTCOLS
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|;
name|char
name|nbuf
index|[
literal|4
index|]
decl_stmt|;
comment|/* used for converting numbers to ASCII */
name|int
name|widths
index|[
literal|5
index|]
decl_stmt|;
comment|/* width of each column, including gap */
name|int
name|ncols
decl_stmt|;
comment|/* number of columns */
name|int
name|nrows
decl_stmt|;
comment|/* number of options per column */
name|int
name|nset
decl_stmt|;
comment|/* number of options to be output */
name|int
name|width
decl_stmt|;
comment|/* width of a particular option */
name|int
name|todump
index|[
literal|60
index|]
decl_stmt|;
comment|/* indicies of options to be dumped */
comment|/* step 1: count the number of set options */
for|for
control|(
name|nset
operator|=
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|all
operator|||
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SET
operator|)
condition|)
block|{
name|todump
index|[
name|nset
operator|++
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
comment|/* step two: try to use as many columns as possible */
for|for
control|(
name|ncols
operator|=
operator|(
name|nset
operator|>
literal|5
condition|?
literal|5
else|:
name|nset
operator|)
init|;
name|ncols
operator|>
literal|1
condition|;
name|ncols
operator|--
control|)
block|{
comment|/* how many would go in this column? */
name|nrows
operator|=
operator|(
name|nset
operator|+
name|ncols
operator|-
literal|1
operator|)
operator|/
name|ncols
expr_stmt|;
comment|/* figure out the width of each column */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|widths
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|k
operator|=
name|nrows
operator|*
name|i
init|;
name|j
operator|<
name|nrows
operator|&&
name|k
operator|<
name|nset
condition|;
name|j
operator|++
operator|,
name|k
operator|++
control|)
block|{
comment|/* figure out the width of a particular option */
switch|switch
condition|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
condition|)
name|width
operator|=
literal|2
expr_stmt|;
else|else
name|width
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|width
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|MAXWIDTH
condition|)
name|width
operator|=
name|MAXWIDTH
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|width
operator|=
literal|4
expr_stmt|;
break|break;
block|}
name|width
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
comment|/* if this is the widest so far, widen col */
if|if
condition|(
name|width
operator|>
name|widths
index|[
name|i
index|]
condition|)
block|{
name|widths
index|[
name|i
index|]
operator|=
name|width
expr_stmt|;
block|}
block|}
block|}
comment|/* if the total width is narrow enough, then use it */
for|for
control|(
name|width
operator|=
operator|-
literal|2
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|ncols
condition|;
name|i
operator|++
control|)
block|{
name|width
operator|+=
name|widths
index|[
name|i
index|]
operator|+
literal|2
expr_stmt|;
block|}
if|if
condition|(
name|width
operator|<
name|COLS
operator|-
literal|1
condition|)
block|{
break|break;
block|}
block|}
comment|/* step 3: output the columns */
name|nrows
operator|=
operator|(
name|nset
operator|+
name|ncols
operator|-
literal|1
operator|)
operator|/
name|ncols
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nrows
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|ncols
condition|;
name|j
operator|++
control|)
block|{
comment|/* if we hit the end of the options, quit */
name|k
operator|=
name|i
operator|+
name|j
operator|*
name|nrows
expr_stmt|;
if|if
condition|(
name|k
operator|>=
name|nset
condition|)
block|{
break|break;
block|}
comment|/* output this option's value */
name|width
operator|=
literal|0
expr_stmt|;
switch|switch
condition|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
condition|)
block|{
name|qaddch
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
name|width
operator|=
literal|2
expr_stmt|;
block|}
name|qaddstr
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|width
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%-3d"
argument_list|,
name|UCHAR
argument_list|(
operator|*
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|width
operator|=
literal|4
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|qaddstr
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|width
operator|=
literal|3
operator|+
name|strlen
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|>
name|MAXWIDTH
condition|)
block|{
name|width
operator|=
name|MAXWIDTH
expr_stmt|;
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
operator|+
name|MAXWIDTH
operator|-
literal|6
argument_list|,
literal|"..."
argument_list|)
expr_stmt|;
block|}
name|qaddstr
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|width
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|todump
index|[
name|k
index|]
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* pad the field to the correct size */
if|if
condition|(
name|k
operator|+
name|nrows
operator|<=
name|nset
condition|)
block|{
while|while
condition|(
name|width
operator|<
name|widths
index|[
name|j
index|]
operator|+
literal|2
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|width
operator|++
expr_stmt|;
block|}
block|}
block|}
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
else|#
directive|else
name|int
name|i
decl_stmt|;
name|int
name|col
decl_stmt|;
name|char
name|nbuf
index|[
literal|4
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|col
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
comment|/* if not set and not all, ignore this option */
if|if
condition|(
operator|!
name|all
operator|&&
operator|!
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|SET
operator|)
condition|)
block|{
continue|continue;
block|}
comment|/* align this option in one of the columns */
if|if
condition|(
name|col
operator|>
literal|52
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|col
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|col
operator|>
literal|26
condition|)
block|{
while|while
condition|(
name|col
operator|<
literal|52
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|col
operator|>
literal|0
condition|)
block|{
while|while
condition|(
name|col
operator|<
literal|26
condition|)
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|col
operator|++
expr_stmt|;
block|}
block|}
switch|switch
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
name|qaddch
argument_list|(
literal|'n'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'o'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|2
expr_stmt|;
block|}
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|col
operator|+=
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|sprintf
argument_list|(
name|nbuf
argument_list|,
literal|"%-3d"
argument_list|,
name|UCHAR
argument_list|(
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|nbuf
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|4
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'='
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'"'
argument_list|)
expr_stmt|;
name|col
operator|+=
literal|3
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|+
name|strlen
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|exrefresh
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|>
literal|0
condition|)
block|{
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MKEXRC
end_ifndef

begin_comment
comment|/* This function saves the current configuration of options to a file */
end_comment

begin_function
name|void
name|saveopts
parameter_list|(
name|fd
parameter_list|)
name|int
name|fd
decl_stmt|;
comment|/* file descriptor to write to */
block|{
name|int
name|i
decl_stmt|;
name|char
name|buf
index|[
literal|256
index|]
decl_stmt|,
modifier|*
name|pos
decl_stmt|;
comment|/* write each set options */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|;
name|i
operator|++
control|)
block|{
comment|/* if unset or unsettable, ignore this option */
if|if
condition|(
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
operator|(
name|SET
operator||
name|CANSET
operator||
name|NOSAVE
operator|)
operator|)
operator|!=
operator|(
name|SET
operator||
name|CANSET
operator|)
condition|)
block|{
continue|continue;
block|}
name|strcpy
argument_list|(
name|buf
argument_list|,
literal|"set "
argument_list|)
expr_stmt|;
name|pos
operator|=
operator|&
name|buf
index|[
literal|4
index|]
expr_stmt|;
switch|switch
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
if|if
condition|(
operator|!
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
condition|)
block|{
operator|*
name|pos
operator|++
operator|=
literal|'n'
expr_stmt|;
operator|*
name|pos
operator|++
operator|=
literal|'o'
expr_stmt|;
block|}
name|strcpy
argument_list|(
name|pos
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|pos
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|sprintf
argument_list|(
name|pos
argument_list|,
literal|"%s=%-3d\n"
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|&
literal|0xff
argument_list|)
expr_stmt|;
break|break;
case|case
name|STR
case|:
name|sprintf
argument_list|(
name|pos
argument_list|,
literal|"%s=\"%s\"\n"
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|)
expr_stmt|;
break|break;
block|}
name|twrite
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|unsigned
operator|)
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function changes the values of one or more options. */
end_comment

begin_function
name|void
name|setopts
parameter_list|(
name|assignments
parameter_list|)
name|char
modifier|*
name|assignments
decl_stmt|;
comment|/* a string containing option assignments */
block|{
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of variable in assignments */
name|char
modifier|*
name|value
decl_stmt|;
comment|/* value of the variable */
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* used for moving through strings */
name|char
modifier|*
name|build
decl_stmt|;
comment|/* used for copying chars from "scan" */
name|char
modifier|*
name|prefix
decl_stmt|;
comment|/* pointer to "neg" or "no" at front of a boolean */
name|int
name|quote
decl_stmt|;
comment|/* boolean: inside '"' quotes? */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* reset the upper limit of "window" option to lines-1 */
operator|*
name|o_window
operator|=
operator|*
name|o_lines
operator|-
literal|1
expr_stmt|;
endif|#
directive|endif
comment|/* for each assignment... */
for|for
control|(
name|name
operator|=
name|assignments
init|;
operator|*
name|name
condition|;
control|)
block|{
comment|/* skip whitespace */
if|if
condition|(
operator|*
name|name
operator|==
literal|' '
operator|||
operator|*
name|name
operator|==
literal|'\t'
condition|)
block|{
name|name
operator|++
expr_stmt|;
continue|continue;
block|}
comment|/* after the name, find the value (if any) */
for|for
control|(
name|scan
operator|=
name|name
init|;
name|isalnum
argument_list|(
operator|*
name|scan
argument_list|)
condition|;
name|scan
operator|++
control|)
block|{ 		}
if|if
condition|(
operator|*
name|scan
operator|==
literal|'='
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
name|value
operator|=
name|build
operator|=
name|scan
expr_stmt|;
for|for
control|(
name|quote
operator|=
name|FALSE
init|;
operator|*
name|scan
operator|&&
operator|(
name|quote
operator|||
operator|!
name|isspace
argument_list|(
operator|*
name|scan
argument_list|)
operator|)
condition|;
name|scan
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|scan
operator|==
literal|'"'
condition|)
block|{
name|quote
operator|=
operator|!
name|quote
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\\'
operator|&&
name|scan
index|[
literal|1
index|]
condition|)
block|{
operator|*
name|build
operator|++
operator|=
operator|*
operator|++
name|scan
expr_stmt|;
block|}
else|else
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|scan
expr_stmt|;
block|}
block|}
if|if
condition|(
operator|*
name|scan
condition|)
name|scan
operator|++
expr_stmt|;
operator|*
name|build
operator|=
literal|'\0'
expr_stmt|;
block|}
else|else
comment|/* no "=" so it is probably boolean... */
block|{
if|if
condition|(
operator|*
name|scan
condition|)
block|{
operator|*
name|scan
operator|++
operator|=
literal|'\0'
expr_stmt|;
block|}
name|value
operator|=
name|NULL
expr_stmt|;
name|prefix
operator|=
name|name
expr_stmt|;
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"novice"
argument_list|)
condition|)
comment|/* don't check for a "no" prefix */
empty_stmt|;
elseif|else
endif|#
directive|endif
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|prefix
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
name|name
operator|+=
literal|2
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
index|[
literal|0
index|]
operator|==
literal|'n'
operator|&&
name|prefix
index|[
literal|1
index|]
operator|==
literal|'e'
operator|&&
name|prefix
index|[
literal|2
index|]
operator|==
literal|'g'
condition|)
name|name
operator|+=
literal|3
expr_stmt|;
block|}
comment|/* find the variable */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|opts
index|[
name|i
index|]
operator|.
name|name
operator|&&
name|strcmp
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|name
argument_list|)
operator|&&
name|strcmp
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|nm
argument_list|,
name|name
argument_list|)
condition|;
name|i
operator|++
control|)
block|{ 		}
comment|/* change the variable */
if|if
condition|(
operator|!
name|opts
index|[
name|i
index|]
operator|.
name|name
condition|)
block|{
comment|/* only complain about unknown options if we're editing 			 * a file;  i.e., if we're not executing the .exrc now. 			 */
if|if
condition|(
name|tmpfd
operator|>=
literal|0
condition|)
name|msg
argument_list|(
literal|"invalid option name \"%s\""
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|CANSET
operator|)
operator|!=
name|CANSET
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" can't be altered"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|RCSET
operator|)
operator|!=
name|CANSET
operator|&&
name|nlines
operator|>=
literal|1L
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" can only be set in a %s file"
argument_list|,
name|name
argument_list|,
name|EXRC
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|value
condition|)
block|{
switch|switch
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
condition|)
block|{
case|case
name|BOOL
case|:
name|msg
argument_list|(
literal|"option \"[no]%s\" is boolean"
argument_list|,
name|name
argument_list|)
expr_stmt|;
break|break;
case|case
name|NUM
case|:
name|j
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
literal|0
operator|&&
operator|*
name|value
operator|!=
literal|'0'
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" must have a numeric value"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|j
operator|<
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|1
index|]
operator|||
name|j
operator|>
operator|(
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|2
index|]
operator|&
literal|0xff
operator|)
condition|)
block|{
name|msg
argument_list|(
literal|"option \"%s\" must have a value between %d and %d"
argument_list|,
name|name
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|1
index|]
argument_list|,
name|opts
index|[
name|i
index|]
operator|.
name|value
index|[
literal|2
index|]
operator|&
literal|0xff
argument_list|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|=
name|atoi
argument_list|(
name|value
argument_list|)
expr_stmt|;
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|SET
expr_stmt|;
block|}
break|break;
case|case
name|STR
case|:
name|strcpy
argument_list|(
name|opts
index|[
name|i
index|]
operator|.
name|value
argument_list|,
name|value
argument_list|)
expr_stmt|;
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|SET
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|MR
condition|)
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|WSET
condition|)
block|{
name|wset
operator|=
name|TRUE
expr_stmt|;
block|}
endif|#
directive|endif
block|}
else|else
comment|/* valid option, no value */
block|{
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|type
operator|==
name|BOOL
condition|)
block|{
if|if
condition|(
name|prefix
operator|==
name|name
condition|)
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|=
name|TRUE
expr_stmt|;
elseif|else
if|if
condition|(
name|prefix
index|[
literal|1
index|]
operator|==
literal|'o'
condition|)
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|=
name|FALSE
expr_stmt|;
else|else
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
operator|=
operator|!
operator|*
name|opts
index|[
name|i
index|]
operator|.
name|value
expr_stmt|;
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator||=
name|SET
expr_stmt|;
if|if
condition|(
name|opts
index|[
name|i
index|]
operator|.
name|flags
operator|&
name|MR
condition|)
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|msg
argument_list|(
literal|"option \"%s\" must be given a value"
argument_list|,
name|name
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* move on to the next option */
name|name
operator|=
name|scan
expr_stmt|;
block|}
comment|/* special processing ... */
ifndef|#
directive|ifndef
name|CRUNCH
comment|/* if "novice" is set, then ":set report=1 showmode nomagic" */
if|if
condition|(
operator|*
name|o_novice
condition|)
block|{
operator|*
name|o_report
operator|=
literal|1
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_SHOWMODE
operator|*
name|o_smd
operator|=
name|TRUE
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_MAGIC
operator|*
name|o_magic
operator|=
name|FALSE
expr_stmt|;
endif|#
directive|endif
block|}
endif|#
directive|endif
comment|/* if "readonly" then set the READONLY flag for this file */
if|if
condition|(
operator|*
name|o_readonly
condition|)
block|{
name|setflag
argument_list|(
name|file
argument_list|,
name|READONLY
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_DIGRAPH
comment|/* re-initialize the ctype package */
name|_ct_init
argument_list|(
name|o_flipcase
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* not NO_DIGRAPH */
comment|/* copy o_lines and o_columns into LINES and COLS */
name|LINES
operator|=
operator|(
operator|*
name|o_lines
operator|&
literal|255
operator|)
expr_stmt|;
name|COLS
operator|=
operator|(
operator|*
name|o_columns
operator|&
literal|255
operator|)
expr_stmt|;
block|}
end_function

end_unit

