begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* tio.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains terminal I/O functions */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_comment
comment|/* This function reads in a line from the terminal. */
end_comment

begin_function
name|int
name|vgets
parameter_list|(
name|prompt
parameter_list|,
name|buf
parameter_list|,
name|bsize
parameter_list|)
name|char
name|prompt
decl_stmt|;
comment|/* the prompt character, or '\0' for none */
name|char
modifier|*
name|buf
decl_stmt|;
comment|/* buffer into which the string is read */
name|int
name|bsize
decl_stmt|;
comment|/* size of the buffer */
block|{
name|int
name|len
decl_stmt|;
comment|/* how much we've read so far */
name|int
name|ch
decl_stmt|;
comment|/* a character from the user */
name|int
name|quoted
decl_stmt|;
comment|/* is the next char quoted? */
name|int
name|tab
decl_stmt|;
comment|/* column position of cursor */
name|char
name|widths
index|[
literal|132
index|]
decl_stmt|;
comment|/* widths of characters */
name|int
name|word
decl_stmt|;
comment|/* index of first letter of word */
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|int
name|erased
decl_stmt|;
comment|/* 0, or first char of a digraph */
endif|#
directive|endif
comment|/* show the prompt */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|tab
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|prompt
condition|)
block|{
name|addch
argument_list|(
name|prompt
argument_list|)
expr_stmt|;
name|tab
operator|=
literal|1
expr_stmt|;
block|}
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* read in the line */
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|erased
operator|=
endif|#
directive|endif
name|quoted
operator|=
name|len
operator|=
literal|0
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|NO_ABBR
if|if
condition|(
name|quoted
operator|||
name|mode
operator|==
name|MODE_EX
condition|)
block|{
name|ch
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* maybe expand an abbreviation while getting key */
for|for
control|(
name|word
operator|=
name|len
init|;
operator|--
name|word
operator|>=
literal|0
operator|&&
name|isalnum
argument_list|(
name|buf
index|[
name|word
index|]
argument_list|)
condition|;
control|)
block|{ 			}
name|word
operator|++
expr_stmt|;
name|ch
operator|=
name|getabkey
argument_list|(
name|WHEN_EX
argument_list|,
operator|&
name|buf
index|[
name|word
index|]
argument_list|,
name|len
operator|-
name|word
argument_list|)
expr_stmt|;
block|}
else|#
directive|else
name|ch
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|ch
operator|==
name|ctrl
argument_list|(
literal|'O'
argument_list|)
condition|)
block|{
name|ch
operator|=
name|getkey
argument_list|(
name|quoted
condition|?
literal|0
else|:
name|WHEN_EX
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* some special conversions */
if|if
condition|(
name|ch
operator|==
name|ctrl
argument_list|(
literal|'D'
argument_list|)
operator|&&
name|len
operator|==
literal|0
condition|)
name|ch
operator|=
name|ctrl
argument_list|(
literal|'['
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DIGRAPH
if|if
condition|(
operator|*
name|o_digraph
operator|&&
name|erased
operator|!=
literal|0
operator|&&
name|ch
operator|!=
literal|'\b'
condition|)
block|{
name|ch
operator|=
name|digraph
argument_list|(
name|erased
argument_list|,
name|ch
argument_list|)
expr_stmt|;
name|erased
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* inhibit detection of special chars (except ^J) after a ^V */
if|if
condition|(
name|quoted
operator|&&
name|ch
operator|!=
literal|'\n'
condition|)
block|{
name|ch
operator||=
literal|256
expr_stmt|;
block|}
comment|/* process the character */
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
name|ctrl
argument_list|(
literal|'V'
argument_list|)
case|:
name|qaddch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
name|quoted
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
name|ctrl
argument_list|(
literal|'['
argument_list|)
case|:
return|return
operator|-
literal|1
return|;
case|case
literal|'\n'
case|:
if|#
directive|if
name|OSK
case|case
literal|'\l'
case|:
else|#
directive|else
case|case
literal|'\r'
case|:
endif|#
directive|endif
name|clrtoeol
argument_list|()
expr_stmt|;
goto|goto
name|BreakBreak
goto|;
case|case
literal|'\b'
case|:
if|if
condition|(
name|len
operator|>
literal|0
condition|)
block|{
name|len
operator|--
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_DIGRAPH
name|erased
operator|=
name|buf
index|[
name|len
index|]
expr_stmt|;
endif|#
directive|endif
for|for
control|(
name|ch
operator|=
name|widths
index|[
name|len
index|]
init|;
name|ch
operator|>
literal|0
condition|;
name|ch
operator|--
control|)
name|addch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_EX
condition|)
block|{
name|clrtoeol
argument_list|()
expr_stmt|;
block|}
name|tab
operator|-=
name|widths
index|[
name|len
index|]
expr_stmt|;
block|}
else|else
block|{
return|return
operator|-
literal|1
return|;
block|}
break|break;
default|default:
comment|/* strip off quotation bit */
if|if
condition|(
name|ch
operator|&
literal|256
condition|)
block|{
name|ch
operator|&=
operator|~
literal|256
expr_stmt|;
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|'\b'
argument_list|)
expr_stmt|;
block|}
comment|/* add& echo the char */
if|if
condition|(
name|len
operator|<
name|bsize
operator|-
literal|1
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\t'
operator|&&
operator|!
name|quoted
condition|)
block|{
name|widths
index|[
name|len
index|]
operator|=
operator|*
name|o_tabstop
operator|-
operator|(
name|tab
operator|%
operator|*
name|o_tabstop
operator|)
expr_stmt|;
name|addstr
argument_list|(
literal|"        "
operator|+
literal|8
operator|-
name|widths
index|[
name|len
index|]
argument_list|)
expr_stmt|;
name|tab
operator|+=
name|widths
index|[
name|len
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|>
literal|0
operator|&&
name|ch
operator|<
literal|' '
condition|)
comment|/*> 0 by GB */
block|{
name|addch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|addch
argument_list|(
name|ch
operator|+
literal|'@'
argument_list|)
expr_stmt|;
name|widths
index|[
name|len
index|]
operator|=
literal|2
expr_stmt|;
name|tab
operator|+=
literal|2
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ch
operator|==
literal|'\177'
condition|)
block|{
name|addch
argument_list|(
literal|'^'
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'?'
argument_list|)
expr_stmt|;
name|widths
index|[
name|len
index|]
operator|=
literal|2
expr_stmt|;
name|tab
operator|+=
literal|2
expr_stmt|;
block|}
else|else
block|{
name|addch
argument_list|(
name|ch
argument_list|)
expr_stmt|;
name|widths
index|[
name|len
index|]
operator|=
literal|1
expr_stmt|;
name|tab
operator|++
expr_stmt|;
block|}
name|buf
index|[
name|len
operator|++
index|]
operator|=
name|ch
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
name|quoted
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
name|BreakBreak
label|:
name|refresh
argument_list|()
expr_stmt|;
name|buf
index|[
name|len
index|]
operator|=
literal|'\0'
expr_stmt|;
return|return
name|len
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|manymsgs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* This variable keeps msgs from overwriting each other */
end_comment

begin_decl_stmt
specifier|static
name|char
name|pmsg
index|[
literal|80
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* previous message (waiting to be displayed) */
end_comment

begin_function
specifier|static
name|int
name|showmsg
parameter_list|()
block|{
comment|/* if there is no message to show, then don't */
if|if
condition|(
operator|!
name|manymsgs
condition|)
return|return
name|FALSE
return|;
comment|/* display the message */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|pmsg
condition|)
block|{
name|standout
argument_list|()
expr_stmt|;
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|pmsg
argument_list|)
expr_stmt|;
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
block|}
name|clrtoeol
argument_list|()
expr_stmt|;
name|manymsgs
operator|=
name|FALSE
expr_stmt|;
return|return
name|TRUE
return|;
block|}
end_function

begin_function
name|void
name|endmsgs
parameter_list|()
block|{
if|if
condition|(
name|manymsgs
condition|)
block|{
name|showmsg
argument_list|()
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Write a message in an appropriate way.  This should really be a varargs  * function, but there is no such thing as vwprintw.  Hack!!!  *  * In MODE_EX or MODE_COLON, the message is written immediately, with a  * newline at the end.  *  * In MODE_VI, the message is stored in a character buffer.  It is not  * displayed until getkey() is called.  msg() will call getkey() itself,  * if necessary, to prevent messages from being lost.  *  * msg("")		- clears the message line  * msg("%s %d", ...)	- does a printf onto the message line  */
end_comment

begin_comment
comment|/*VARARGS1*/
end_comment

begin_function
name|void
name|msg
parameter_list|(
name|fmt
parameter_list|,
name|arg1
parameter_list|,
name|arg2
parameter_list|,
name|arg3
parameter_list|,
name|arg4
parameter_list|,
name|arg5
parameter_list|,
name|arg6
parameter_list|,
name|arg7
parameter_list|)
name|char
modifier|*
name|fmt
decl_stmt|;
name|long
name|arg1
decl_stmt|,
name|arg2
decl_stmt|,
name|arg3
decl_stmt|,
name|arg4
decl_stmt|,
name|arg5
decl_stmt|,
name|arg6
decl_stmt|,
name|arg7
decl_stmt|;
block|{
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
condition|)
block|{
name|sprintf
argument_list|(
name|pmsg
argument_list|,
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|pmsg
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* wait for keypress between consecutive msgs */
if|if
condition|(
name|manymsgs
condition|)
block|{
name|getkey
argument_list|(
name|WHEN_MSG
argument_list|)
expr_stmt|;
block|}
comment|/* real message */
name|sprintf
argument_list|(
name|pmsg
argument_list|,
name|fmt
argument_list|,
name|arg1
argument_list|,
name|arg2
argument_list|,
name|arg3
argument_list|,
name|arg4
argument_list|,
name|arg5
argument_list|,
name|arg6
argument_list|,
name|arg7
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|fmt
condition|)
block|{
name|manymsgs
operator|=
name|TRUE
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function calls refresh() if the option exrefresh is set */
end_comment

begin_function
name|void
name|exrefresh
parameter_list|()
block|{
name|char
modifier|*
name|scan
decl_stmt|;
comment|/* If this ex command wrote ANYTHING set exwrote so vi's  :  command 	 * can tell that it must wait for a user keystroke before redrawing. 	 */
for|for
control|(
name|scan
operator|=
name|kbuf
init|;
name|scan
operator|<
name|stdscr
condition|;
name|scan
operator|++
control|)
if|if
condition|(
operator|*
name|scan
operator|==
literal|'\n'
condition|)
name|exwrote
operator|=
name|TRUE
expr_stmt|;
comment|/* now we do the refresh thing */
if|if
condition|(
operator|*
name|o_exrefresh
condition|)
block|{
name|refresh
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|wqrefresh
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
condition|)
block|{
name|manymsgs
operator|=
name|FALSE
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This structure is used to store maps and abbreviations.  The distinction  * between them is that maps are stored in the list referenced by the "maps"  * pointer, while abbreviations are referenced by the "abbrs" pointer.  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_map
block|{
name|struct
name|_map
modifier|*
name|next
decl_stmt|;
comment|/* another abbreviation */
name|short
name|len
decl_stmt|;
comment|/* length of the "rawin" characters */
name|short
name|flags
decl_stmt|;
comment|/* various flags */
name|char
modifier|*
name|label
decl_stmt|;
comment|/* label of the map/abbr, or NULL */
name|char
modifier|*
name|rawin
decl_stmt|;
comment|/* the "rawin" characters */
name|char
modifier|*
name|cooked
decl_stmt|;
comment|/* the "cooked" characters */
block|}
name|MAP
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|char
name|keybuf
index|[
name|KEYBUFSIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cend
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* end of input characters */
end_comment

begin_decl_stmt
specifier|static
name|int
name|user
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* from user through end are chars typed by user */
end_comment

begin_decl_stmt
specifier|static
name|int
name|next
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* index of the next character to be returned */
end_comment

begin_decl_stmt
specifier|static
name|MAP
modifier|*
name|match
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the matching map, found by countmatch() */
end_comment

begin_decl_stmt
specifier|static
name|MAP
modifier|*
name|maps
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the map table */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ABBR
end_ifndef

begin_decl_stmt
specifier|static
name|MAP
modifier|*
name|abbrs
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* the abbreviation table */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ring the terminal's bell */
end_comment

begin_function
name|void
name|beep
parameter_list|()
block|{
comment|/* do a visible/audible bell */
if|if
condition|(
operator|*
name|o_flash
condition|)
block|{
name|do_VB
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|o_errorbells
condition|)
block|{
name|ttywrite
argument_list|(
literal|"\007"
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* discard any buffered input, and abort macros */
name|next
operator|=
name|user
operator|=
name|cend
expr_stmt|;
block|}
end_function

begin_comment
comment|/* This function replaces a "rawin" character sequence with the "cooked" version,  * by modifying the internal type-ahead buffer.  */
end_comment

begin_function
name|void
name|execmap
parameter_list|(
name|rawlen
parameter_list|,
name|cookedstr
parameter_list|,
name|visual
parameter_list|)
name|int
name|rawlen
decl_stmt|;
comment|/* length of rawin text -- string to delete */
name|char
modifier|*
name|cookedstr
decl_stmt|;
comment|/* the cooked text -- string to insert */
name|int
name|visual
decl_stmt|;
comment|/* boolean -- chars to be executed in visual mode? */
block|{
name|int
name|cookedlen
decl_stmt|;
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* find the length of the cooked string */
name|cookedlen
operator|=
name|strlen
argument_list|(
name|cookedstr
argument_list|)
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|visual
condition|)
block|{
name|cookedlen
operator|*=
literal|2
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* if too big to fit in type-ahead buffer, then don't do it */
if|if
condition|(
name|cookedlen
operator|+
operator|(
name|cend
operator|-
name|next
operator|)
operator|-
name|rawlen
operator|>
name|KEYBUFSIZE
condition|)
block|{
return|return;
block|}
comment|/* shift to make room for cookedstr at the front of keybuf */
name|src
operator|=
operator|&
name|keybuf
index|[
name|next
operator|+
name|rawlen
index|]
expr_stmt|;
name|dst
operator|=
operator|&
name|keybuf
index|[
name|cookedlen
index|]
expr_stmt|;
name|i
operator|=
name|cend
operator|-
operator|(
name|next
operator|+
name|rawlen
operator|)
expr_stmt|;
if|if
condition|(
name|src
operator|>=
name|dst
condition|)
block|{
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
block|}
else|else
block|{
name|src
operator|+=
name|i
expr_stmt|;
name|dst
operator|+=
name|i
expr_stmt|;
while|while
condition|(
name|i
operator|--
operator|>
literal|0
condition|)
block|{
operator|*
operator|--
name|dst
operator|=
operator|*
operator|--
name|src
expr_stmt|;
block|}
block|}
comment|/* insert cookedstr, and adjust offsets */
name|cend
operator|+=
name|cookedlen
operator|-
name|rawlen
operator|-
name|next
expr_stmt|;
name|user
operator|+=
name|cookedlen
operator|-
name|rawlen
operator|-
name|next
expr_stmt|;
name|next
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|dst
operator|=
name|keybuf
operator|,
name|src
operator|=
name|cookedstr
init|;
operator|*
name|src
condition|;
control|)
block|{
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|visual
condition|)
block|{
operator|*
name|dst
operator|++
operator|=
name|ctrl
argument_list|(
literal|'O'
argument_list|)
expr_stmt|;
name|cookedlen
operator|--
expr_stmt|;
block|}
endif|#
directive|endif
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
block|}
ifdef|#
directive|ifdef
name|DEBUG2
block|{
include|#
directive|include
file|<stdio.h>
name|FILE
modifier|*
name|debout
decl_stmt|;
name|int
name|i
decl_stmt|;
name|debout
operator|=
name|fopen
argument_list|(
literal|"debug.out"
argument_list|,
literal|"a"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|debout
argument_list|,
literal|"After execmap(%d, \"%s\", %d)...\n"
argument_list|,
name|rawlen
argument_list|,
name|cookedstr
argument_list|,
name|visual
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|cend
condition|;
name|i
operator|++
control|)
block|{
if|if
condition|(
name|i
operator|==
name|next
condition|)
name|fprintf
argument_list|(
name|debout
argument_list|,
literal|"(next)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|user
condition|)
name|fprintf
argument_list|(
name|debout
argument_list|,
literal|"(user)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|UCHAR
argument_list|(
name|keybuf
index|[
name|i
index|]
argument_list|)
operator|<
literal|' '
condition|)
name|fprintf
argument_list|(
name|debout
argument_list|,
literal|"^%c"
argument_list|,
name|keybuf
index|[
name|i
index|]
operator|^
literal|'@'
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|debout
argument_list|,
literal|"%c"
argument_list|,
name|keybuf
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|debout
argument_list|,
literal|"(end)\n"
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|debout
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* This function calls ttyread().  If necessary, it will also redraw the screen,  * change the cursor shape, display the mode, and update the ruler.  If the  * number of characters read is 0, and we didn't time-out, then it exits because  * we've apparently reached the end of an EX script.  */
end_comment

begin_function
specifier|static
name|int
name|fillkeybuf
parameter_list|(
name|when
parameter_list|,
name|timeout
parameter_list|)
name|int
name|when
decl_stmt|;
comment|/* mixture of WHEN_XXX flags */
name|int
name|timeout
decl_stmt|;
comment|/* timeout in 1/10 second increments, or 0 */
block|{
name|int
name|nkeys
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_SHOWMODE
specifier|static
name|int
name|oldwhen
decl_stmt|;
comment|/* "when" from last time */
specifier|static
name|int
name|oldleft
decl_stmt|;
specifier|static
name|long
name|oldtop
decl_stmt|;
specifier|static
name|long
name|oldnlines
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
specifier|static
name|int
name|oldcurs
decl_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|watch
argument_list|()
expr_stmt|;
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_CURSORSHAPE
comment|/* make sure the cursor is the right shape */
if|if
condition|(
name|has_CQ
condition|)
block|{
if|if
condition|(
name|when
operator|!=
name|oldcurs
condition|)
block|{
switch|switch
condition|(
name|when
condition|)
block|{
case|case
name|WHEN_EX
case|:
name|do_CX
argument_list|()
expr_stmt|;
break|break;
case|case
name|WHEN_VICMD
case|:
name|do_CV
argument_list|()
expr_stmt|;
break|break;
case|case
name|WHEN_VIINP
case|:
name|do_CI
argument_list|()
expr_stmt|;
break|break;
case|case
name|WHEN_VIREP
case|:
name|do_CR
argument_list|()
expr_stmt|;
break|break;
block|}
name|oldcurs
operator|=
name|when
expr_stmt|;
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_SHOWMODE
comment|/* if "showmode" then say which mode we're in */
if|if
condition|(
operator|*
name|o_smd
operator|&&
operator|(
name|when
operator|&
name|WHENMASK
operator|)
condition|)
block|{
comment|/* redraw the screen before we check to see whether the 		 * "showmode" message needs to be redrawn. 		 */
name|redraw
argument_list|(
name|cursor
argument_list|,
operator|!
operator|(
name|when
operator|&
name|WHEN_VICMD
operator|)
argument_list|)
expr_stmt|;
comment|/* now the "topline" test should be valid */
if|if
condition|(
name|when
operator|!=
name|oldwhen
operator|||
name|topline
operator|!=
name|oldtop
operator|||
name|leftcol
operator|!=
name|oldleft
operator|||
name|nlines
operator|!=
name|oldnlines
condition|)
block|{
name|oldwhen
operator|=
name|when
expr_stmt|;
name|oldtop
operator|=
name|topline
expr_stmt|;
name|oldleft
operator|=
name|leftcol
expr_stmt|;
name|oldnlines
operator|=
name|nlines
expr_stmt|;
if|if
condition|(
name|when
operator|&
name|WHEN_VICMD
condition|)
name|str
operator|=
literal|"Command"
expr_stmt|;
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_VIINP
condition|)
name|str
operator|=
literal|" Input "
expr_stmt|;
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_VIREP
condition|)
name|str
operator|=
literal|"Replace"
expr_stmt|;
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_REP1
condition|)
name|str
operator|=
literal|" Rep 1 "
expr_stmt|;
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_CUT
condition|)
name|str
operator|=
literal|"BufName"
expr_stmt|;
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_MARK
condition|)
name|str
operator|=
literal|"Mark AZ"
expr_stmt|;
elseif|else
if|if
condition|(
name|when
operator|&
name|WHEN_CHAR
condition|)
name|str
operator|=
literal|"Dest Ch"
expr_stmt|;
else|else
name|str
operator|=
operator|(
name|char
operator|*
operator|)
literal|0
expr_stmt|;
if|if
condition|(
name|str
condition|)
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|10
argument_list|)
expr_stmt|;
name|standout
argument_list|()
expr_stmt|;
name|qaddstr
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|standend
argument_list|()
expr_stmt|;
block|}
block|}
block|}
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/* maybe display the ruler */
if|if
condition|(
operator|*
name|o_ruler
operator|&&
operator|(
name|when
operator|&
operator|(
name|WHEN_VICMD
operator||
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
condition|)
block|{
name|char
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|redraw
argument_list|(
name|cursor
argument_list|,
operator|!
operator|(
name|when
operator|&
name|WHEN_VICMD
operator|)
argument_list|)
expr_stmt|;
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%7ld,%-4d"
argument_list|,
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|,
literal|1
operator|+
name|idx2col
argument_list|(
name|cursor
argument_list|,
name|ptext
argument_list|,
name|when
operator|&
operator|(
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
argument_list|)
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
name|COLS
operator|-
literal|22
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
name|buf
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* redraw, so the cursor is in the right place */
if|if
condition|(
name|when
operator|&
name|WHENMASK
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
operator|!
operator|(
name|when
operator|&
operator|(
name|WHENMASK
operator|&
operator|~
operator|(
name|WHEN_VIREP
operator||
name|WHEN_VIINP
operator|)
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Okay, now we can finally read the rawin keystrokes */
name|refresh
argument_list|()
expr_stmt|;
name|nkeys
operator|=
name|ttyread
argument_list|(
name|keybuf
operator|+
name|cend
argument_list|,
sizeof|sizeof
name|keybuf
operator|-
name|cend
argument_list|,
name|timeout
argument_list|)
expr_stmt|;
comment|/* if nkeys == 0 then we've reached EOF of an ex script. */
if|if
condition|(
name|nkeys
operator|==
literal|0
operator|&&
name|timeout
operator|==
literal|0
condition|)
block|{
name|tmpabort
argument_list|(
name|TRUE
argument_list|)
expr_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|cend
operator|+=
name|nkeys
expr_stmt|;
name|user
operator|+=
name|nkeys
expr_stmt|;
return|return
name|nkeys
return|;
block|}
end_function

begin_comment
comment|/* This function counts the number of maps that could match the characters  * between&keybuf[next] and&keybuf[cend], including incomplete matches.  * The longest comlete match is remembered via the "match" variable.  */
end_comment

begin_function
specifier|static
name|int
name|countmatch
parameter_list|(
name|when
parameter_list|)
name|int
name|when
decl_stmt|;
comment|/* mixture of WHEN_XXX flags */
block|{
name|MAP
modifier|*
name|map
decl_stmt|;
name|int
name|count
decl_stmt|;
comment|/* clear the "match" variable */
name|match
operator|=
operator|(
name|MAP
operator|*
operator|)
literal|0
expr_stmt|;
comment|/* check every map */
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|map
operator|=
name|maps
init|;
name|map
condition|;
name|map
operator|=
name|map
operator|->
name|next
control|)
block|{
comment|/* can't match if wrong mode */
if|if
condition|(
operator|(
name|map
operator|->
name|flags
operator|&
name|when
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* would this be a complete match? */
if|if
condition|(
name|map
operator|->
name|len
operator|<=
name|cend
operator|-
name|next
condition|)
block|{
comment|/* Yes, it would be.  Now does it really match? */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|map
operator|->
name|rawin
argument_list|,
operator|&
name|keybuf
index|[
name|next
index|]
argument_list|,
name|map
operator|->
name|len
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
comment|/* if this is the longest complete match, 				 * then remember it. 				 */
if|if
condition|(
operator|!
name|match
operator|||
name|match
operator|->
name|len
operator|<
name|map
operator|->
name|len
condition|)
block|{
name|match
operator|=
name|map
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* No, it wouldn't.  But check for partial match */
if|if
condition|(
operator|!
name|strncmp
argument_list|(
name|map
operator|->
name|rawin
argument_list|,
operator|&
name|keybuf
index|[
name|next
index|]
argument_list|,
name|cend
operator|-
name|next
argument_list|)
condition|)
block|{
name|count
operator|++
expr_stmt|;
block|}
block|}
block|}
return|return
name|count
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ABBR
end_ifndef

begin_comment
comment|/* This function checks to see whether a word is an abbreviation.  If it is,  * then an appropriate number of backspoace characters is inserted into the  * type-ahead buffer, followed by the expanded form of the abbreviation.  */
end_comment

begin_function
specifier|static
name|void
name|expandabbr
parameter_list|(
name|word
parameter_list|,
name|wlen
parameter_list|)
name|char
modifier|*
name|word
decl_stmt|;
name|int
name|wlen
decl_stmt|;
block|{
name|MAP
modifier|*
name|abbr
decl_stmt|;
comment|/* if the next character wouldn't end the word, then don't expand */
if|if
condition|(
name|isalnum
argument_list|(
name|keybuf
index|[
name|next
index|]
argument_list|)
operator|||
name|keybuf
index|[
name|next
index|]
operator|==
name|ctrl
argument_list|(
literal|'V'
argument_list|)
condition|)
block|{
return|return;
block|}
comment|/* find the abbreviation, if any */
for|for
control|(
name|abbr
operator|=
name|abbrs
init|;
name|abbr
operator|&&
operator|(
name|abbr
operator|->
name|len
operator|!=
name|wlen
operator|||
name|strncmp
argument_list|(
name|abbr
operator|->
name|rawin
argument_list|,
name|word
argument_list|,
name|wlen
argument_list|)
operator|)
condition|;
name|abbr
operator|=
name|abbr
operator|->
name|next
control|)
block|{ 	}
comment|/* If an abbreviation was found, then expand it by inserting the long 	 * version into the type-ahead buffer, and then inserting (in front of 	 * the long version) enough backspaces to erase to the short version. 	 */
if|if
condition|(
name|abbr
condition|)
block|{
name|execmap
argument_list|(
literal|0
argument_list|,
name|abbr
operator|->
name|cooked
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
while|while
condition|(
name|wlen
operator|>
literal|15
condition|)
block|{
name|execmap
argument_list|(
literal|0
argument_list|,
literal|"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|wlen
operator|-=
literal|15
expr_stmt|;
block|}
if|if
condition|(
name|wlen
operator|>
literal|0
condition|)
block|{
name|execmap
argument_list|(
literal|0
argument_list|,
literal|"\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
operator|+
literal|15
operator|-
name|wlen
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function calls getabkey() without attempting to expand abbreviations */
end_comment

begin_function
name|int
name|getkey
parameter_list|(
name|when
parameter_list|)
name|int
name|when
decl_stmt|;
comment|/* mixture of WHEN_XXX flags */
block|{
return|return
name|getabkey
argument_list|(
name|when
argument_list|,
literal|""
argument_list|,
literal|0
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* This is it.  This function returns keystrokes one-at-a-time, after mapping  * and abbreviations have been taken into account.  */
end_comment

begin_function
name|int
name|getabkey
parameter_list|(
name|when
parameter_list|,
name|word
parameter_list|,
name|wlen
parameter_list|)
name|int
name|when
decl_stmt|;
comment|/* mixture of WHEN_XXX flags */
name|char
modifier|*
name|word
decl_stmt|;
comment|/* a word that may need to be expanded as an abbr */
name|int
name|wlen
decl_stmt|;
comment|/* length of "word" -- since "word" might not have \0 */
block|{
name|int
name|matches
decl_stmt|;
comment|/* if this key is needed for delay between multiple error messages, 	 * then reset the manymsgs flag and abort any mapped key sequence. 	 */
if|if
condition|(
name|showmsg
argument_list|()
condition|)
block|{
if|if
condition|(
name|when
operator|==
name|WHEN_MSG
condition|)
block|{
ifndef|#
directive|ifndef
name|CRUNCH
if|if
condition|(
operator|!
operator|*
name|o_more
condition|)
block|{
name|refresh
argument_list|()
expr_stmt|;
return|return
literal|' '
return|;
block|}
endif|#
directive|endif
name|qaddstr
argument_list|(
literal|"[More...]"
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|execmap
argument_list|(
name|user
argument_list|,
literal|""
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
comment|/* periodically check for screwed up internal tables */
name|watch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* if buffer empty, read some characters without timeout */
if|if
condition|(
name|next
operator|>=
name|cend
condition|)
block|{
name|next
operator|=
name|user
operator|=
name|cend
operator|=
literal|0
expr_stmt|;
name|fillkeybuf
argument_list|(
name|when
argument_list|,
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* try to map the key, unless already mapped and not ":set noremap" */
if|if
condition|(
name|next
operator|>=
name|user
operator|||
operator|*
name|o_remap
condition|)
block|{
do|do
block|{
do|do
block|{
name|matches
operator|=
name|countmatch
argument_list|(
name|when
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|matches
operator|>
literal|1
operator|&&
name|fillkeybuf
argument_list|(
name|when
argument_list|,
operator|*
name|o_keytime
argument_list|)
operator|>
literal|0
condition|)
do|;
if|if
condition|(
name|matches
operator|==
literal|1
condition|)
block|{
name|execmap
argument_list|(
name|match
operator|->
name|len
argument_list|,
name|match
operator|->
name|cooked
argument_list|,
operator|(
name|match
operator|->
name|flags
operator|&
name|WHEN_INMV
operator|)
operator|!=
literal|0
operator|&&
operator|(
name|when
operator|&
operator|(
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
operator|!=
literal|0
argument_list|)
expr_stmt|;
block|}
block|}
do|while
condition|(
operator|*
name|o_remap
operator|&&
name|matches
operator|==
literal|1
condition|)
do|;
block|}
ifndef|#
directive|ifndef
name|NO_ABBR
comment|/* try to expand an abbreviation, except in visual command mode */
if|if
condition|(
name|wlen
operator|>
literal|0
operator|&&
operator|(
name|mode
operator|&
operator|(
name|WHEN_EX
operator||
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
operator|!=
literal|0
condition|)
block|{
name|expandabbr
argument_list|(
name|word
argument_list|,
name|wlen
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* ERASEKEY should always be mapped to '\b'. */
if|if
condition|(
name|keybuf
index|[
name|next
index|]
operator|==
name|ERASEKEY
condition|)
block|{
name|keybuf
index|[
name|next
index|]
operator|=
literal|'\b'
expr_stmt|;
block|}
comment|/* return the next key */
return|return
name|keybuf
index|[
name|next
operator|++
index|]
return|;
block|}
end_function

begin_comment
comment|/* This function maps or unmaps a key */
end_comment

begin_function
name|void
name|mapkey
parameter_list|(
name|rawin
parameter_list|,
name|cooked
parameter_list|,
name|when
parameter_list|,
name|name
parameter_list|)
name|char
modifier|*
name|rawin
decl_stmt|;
comment|/* the input key sequence, before mapping */
name|char
modifier|*
name|cooked
decl_stmt|;
comment|/* after mapping -- or NULL to remove map */
name|short
name|when
decl_stmt|;
comment|/* bitmap of when mapping should happen */
name|char
modifier|*
name|name
decl_stmt|;
comment|/* name of the key, NULL for no name, "abbr" for abbr */
block|{
name|MAP
modifier|*
modifier|*
name|head
decl_stmt|;
comment|/* head of list of maps or abbreviations */
name|MAP
modifier|*
name|scan
decl_stmt|;
comment|/* used for scanning through the list */
name|MAP
modifier|*
name|prev
decl_stmt|;
comment|/* used during deletions */
comment|/* Is this a map or an abbreviation?  Choose the right list. */
ifndef|#
directive|ifndef
name|NO_ABBR
name|head
operator|=
operator|(
operator|(
operator|!
name|name
operator|||
name|strcmp
argument_list|(
name|name
argument_list|,
literal|"abbr"
argument_list|)
operator|)
condition|?
operator|&
name|maps
else|:
operator|&
name|abbrs
operator|)
expr_stmt|;
else|#
directive|else
name|head
operator|=
operator|&
name|maps
expr_stmt|;
endif|#
directive|endif
comment|/* try to find the map in the list */
for|for
control|(
name|scan
operator|=
operator|*
name|head
operator|,
name|prev
operator|=
operator|(
name|MAP
operator|*
operator|)
literal|0
init|;
name|scan
operator|&&
operator|(
name|strcmp
argument_list|(
name|rawin
argument_list|,
name|scan
operator|->
name|rawin
argument_list|)
operator|||
operator|!
operator|(
name|scan
operator|->
name|flags
operator|&
name|when
operator|&
operator|(
name|WHEN_EX
operator||
name|WHEN_VICMD
operator||
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
operator|)
condition|;
name|prev
operator|=
name|scan
operator|,
name|scan
operator|=
name|scan
operator|->
name|next
control|)
block|{ 	}
comment|/* trying to map? (not unmap) */
if|if
condition|(
name|cooked
operator|&&
operator|*
name|cooked
condition|)
block|{
comment|/* if map starts with "visual ", then mark it as a visual map */
if|if
condition|(
name|head
operator|==
operator|&
name|maps
operator|&&
operator|!
name|strncmp
argument_list|(
name|cooked
argument_list|,
literal|"visual "
argument_list|,
literal|7
argument_list|)
condition|)
block|{
name|cooked
operator|+=
literal|7
expr_stmt|;
name|when
operator||=
name|WHEN_INMV
expr_stmt|;
block|}
comment|/* "visual" maps always work in input mode */
if|if
condition|(
name|when
operator|&
name|WHEN_INMV
condition|)
block|{
name|when
operator||=
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator||
name|WHEN_POPUP
expr_stmt|;
block|}
comment|/* if not already in the list, then allocate a new structure */
if|if
condition|(
operator|!
name|scan
condition|)
block|{
name|scan
operator|=
operator|(
name|MAP
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|MAP
argument_list|)
argument_list|)
expr_stmt|;
name|scan
operator|->
name|len
operator|=
name|strlen
argument_list|(
name|rawin
argument_list|)
expr_stmt|;
name|scan
operator|->
name|rawin
operator|=
name|malloc
argument_list|(
name|scan
operator|->
name|len
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scan
operator|->
name|rawin
argument_list|,
name|rawin
argument_list|)
expr_stmt|;
name|scan
operator|->
name|flags
operator|=
name|when
expr_stmt|;
name|scan
operator|->
name|label
operator|=
name|name
expr_stmt|;
if|if
condition|(
operator|*
name|head
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|scan
expr_stmt|;
block|}
else|else
block|{
operator|*
name|head
operator|=
name|scan
expr_stmt|;
block|}
name|scan
operator|->
name|next
operator|=
operator|(
name|MAP
operator|*
operator|)
literal|0
expr_stmt|;
block|}
else|else
comment|/* recycle old structure */
block|{
name|free
argument_list|(
name|scan
operator|->
name|cooked
argument_list|)
expr_stmt|;
block|}
name|scan
operator|->
name|cooked
operator|=
name|malloc
argument_list|(
name|strlen
argument_list|(
name|cooked
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|scan
operator|->
name|cooked
argument_list|,
name|cooked
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* unmapping */
block|{
comment|/* if nothing to unmap, then exit silently */
if|if
condition|(
operator|!
name|scan
condition|)
block|{
return|return;
block|}
comment|/* unlink the structure from the list */
if|if
condition|(
name|prev
condition|)
block|{
name|prev
operator|->
name|next
operator|=
name|scan
operator|->
name|next
expr_stmt|;
block|}
else|else
block|{
operator|*
name|head
operator|=
name|scan
operator|->
name|next
expr_stmt|;
block|}
comment|/* free it, and the strings that it refers to */
name|free
argument_list|(
name|scan
operator|->
name|rawin
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scan
operator|->
name|cooked
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|scan
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* This function returns a printable version of a string.  It uses tmpblk.c */
end_comment

begin_function
name|char
modifier|*
name|printable
parameter_list|(
name|str
parameter_list|)
name|char
modifier|*
name|str
decl_stmt|;
comment|/* the string to convert */
block|{
name|char
modifier|*
name|build
decl_stmt|;
comment|/* used for building the string */
for|for
control|(
name|build
operator|=
name|tmpblk
operator|.
name|c
init|;
operator|*
name|str
condition|;
name|str
operator|++
control|)
block|{
if|#
directive|if
name|AMIGA
if|if
condition|(
operator|*
name|str
operator|==
literal|'\233'
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|'<'
expr_stmt|;
operator|*
name|build
operator|++
operator|=
literal|'C'
expr_stmt|;
operator|*
name|build
operator|++
operator|=
literal|'S'
expr_stmt|;
operator|*
name|build
operator|++
operator|=
literal|'I'
expr_stmt|;
operator|*
name|build
operator|++
operator|=
literal|'>'
expr_stmt|;
block|}
elseif|else
endif|#
directive|endif
if|if
condition|(
name|UCHAR
argument_list|(
operator|*
name|str
argument_list|)
operator|<
literal|' '
operator|||
operator|*
name|str
operator|==
literal|'\177'
condition|)
block|{
operator|*
name|build
operator|++
operator|=
literal|'^'
expr_stmt|;
operator|*
name|build
operator|++
operator|=
operator|*
name|str
operator|^
literal|'@'
expr_stmt|;
block|}
else|else
block|{
operator|*
name|build
operator|++
operator|=
operator|*
name|str
expr_stmt|;
block|}
block|}
operator|*
name|build
operator|=
literal|'\0'
expr_stmt|;
return|return
name|tmpblk
operator|.
name|c
return|;
block|}
end_function

begin_comment
comment|/* This function displays the contents of either the map table or the  * abbreviation table.  User commands call this function as follows:  *	:map	dumpkey(WHEN_VICMD, FALSE);  *	:map!	dumpkey(WHEN_VIREP|WHEN_VIINP, FALSE);  *	:abbr	dumpkey(WHEN_VIINP|WHEN_VIREP, TRUE);  *	:abbr!	dumpkey(WHEN_EX|WHEN_VIINP|WHEN_VIREP, TRUE);  */
end_comment

begin_function
name|void
name|dumpkey
parameter_list|(
name|when
parameter_list|,
name|abbr
parameter_list|)
name|int
name|when
decl_stmt|;
comment|/* WHEN_XXXX of mappings to be dumped */
name|int
name|abbr
decl_stmt|;
comment|/* boolean: dump abbreviations instead of maps? */
block|{
name|MAP
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|len
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_ABBR
for|for
control|(
name|scan
operator|=
operator|(
name|abbr
condition|?
name|abbrs
else|:
name|maps
operator|)
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
else|#
directive|else
for|for
control|(
name|scan
operator|=
name|maps
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
endif|#
directive|endif
block|{
comment|/* skip entries that don't match "when" */
if|if
condition|(
operator|(
name|scan
operator|->
name|flags
operator|&
name|when
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* dump the key label, if any */
if|if
condition|(
operator|!
name|abbr
condition|)
block|{
name|len
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|scan
operator|->
name|label
condition|)
block|{
name|qaddstr
argument_list|(
name|scan
operator|->
name|label
argument_list|)
expr_stmt|;
name|len
operator|-=
name|strlen
argument_list|(
name|scan
operator|->
name|label
argument_list|)
expr_stmt|;
block|}
do|do
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|--
operator|>
literal|0
condition|)
do|;
block|}
comment|/* dump the rawin version */
name|str
operator|=
name|printable
argument_list|(
name|scan
operator|->
name|rawin
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|str
argument_list|)
expr_stmt|;
do|do
block|{
name|qaddch
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|len
operator|++
operator|<
literal|8
condition|)
do|;
comment|/* dump the mapped version */
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
operator|(
name|scan
operator|->
name|flags
operator|&
name|WHEN_INMV
operator|)
operator|&&
operator|(
name|when
operator|&
operator|(
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
condition|)
block|{
name|qaddstr
argument_list|(
literal|"visual "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|str
operator|=
name|printable
argument_list|(
name|scan
operator|->
name|cooked
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|str
argument_list|)
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_MKEXRC
end_ifndef

begin_expr_stmt
specifier|static
name|safequote
argument_list|(
argument|str
argument_list|)
name|char
operator|*
name|str
expr_stmt|;
end_expr_stmt

begin_block
block|{
name|char
modifier|*
name|build
decl_stmt|;
name|build
operator|=
name|tmpblk
operator|.
name|c
operator|+
name|strlen
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|str
condition|)
block|{
if|if
condition|(
operator|*
name|str
operator|<=
literal|' '
operator|&&
operator|*
name|str
operator|>=
literal|1
operator|||
operator|*
name|str
operator|==
literal|'|'
condition|)
block|{
operator|*
name|build
operator|++
operator|=
name|ctrl
argument_list|(
literal|'V'
argument_list|)
expr_stmt|;
block|}
operator|*
name|build
operator|++
operator|=
operator|*
name|str
operator|++
expr_stmt|;
block|}
operator|*
name|build
operator|=
literal|'\0'
expr_stmt|;
block|}
end_block

begin_comment
comment|/* This function saves the contents of either the map table or the  * abbreviation table into a file.  Both the "bang" and "no bang" versions  * are saved.  *	:map	dumpkey(WHEN_VICMD, FALSE);  *	:map!	dumpkey(WHEN_VIREP|WHEN_VIINP, FALSE);  *	:abbr	dumpkey(WHEN_VIINP|WHEN_VIREP, TRUE);  *	:abbr!	dumpkey(WHEN_EX|WHEN_VIINP|WHEN_VIREP, TRUE);  */
end_comment

begin_macro
name|savemaps
argument_list|(
argument|fd
argument_list|,
argument|abbr
argument_list|)
end_macro

begin_decl_stmt
name|int
name|fd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* file descriptor of an open file to write to */
end_comment

begin_decl_stmt
name|int
name|abbr
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* boolean: do abbr table? (else do map table) */
end_comment

begin_block
block|{
name|MAP
modifier|*
name|scan
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|bang
decl_stmt|;
name|int
name|when
decl_stmt|;
name|int
name|len
decl_stmt|;
ifndef|#
directive|ifndef
name|NO_ABBR
for|for
control|(
name|scan
operator|=
operator|(
name|abbr
condition|?
name|abbrs
else|:
name|maps
operator|)
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
else|#
directive|else
for|for
control|(
name|scan
operator|=
name|maps
init|;
name|scan
condition|;
name|scan
operator|=
name|scan
operator|->
name|next
control|)
endif|#
directive|endif
block|{
comment|/* skip maps that have labels, except for function keys */
if|if
condition|(
name|scan
operator|->
name|label
operator|&&
operator|*
name|scan
operator|->
name|label
operator|!=
literal|'#'
condition|)
block|{
continue|continue;
block|}
for|for
control|(
name|bang
operator|=
literal|0
init|;
name|bang
operator|<
literal|2
condition|;
name|bang
operator|++
control|)
block|{
comment|/* decide which "when" flags we want */
ifndef|#
directive|ifndef
name|NO_ABBR
if|if
condition|(
name|abbr
condition|)
name|when
operator|=
operator|(
name|bang
condition|?
name|WHEN_EX
operator||
name|WHEN_VIINP
operator||
name|WHEN_VIREP
else|:
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
expr_stmt|;
else|else
endif|#
directive|endif
name|when
operator|=
operator|(
name|bang
condition|?
name|WHEN_VIREP
operator||
name|WHEN_VIINP
else|:
name|WHEN_VICMD
operator|)
expr_stmt|;
comment|/* skip entries that don't match "when" */
if|if
condition|(
operator|(
name|scan
operator|->
name|flags
operator|&
name|when
operator|)
operator|==
literal|0
condition|)
block|{
continue|continue;
block|}
comment|/* write a "map" or "abbr" command name */
ifndef|#
directive|ifndef
name|NO_ABBR
if|if
condition|(
name|abbr
condition|)
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"abbr"
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"map"
argument_list|)
expr_stmt|;
comment|/* maybe write a bang.  Definitely write a space */
if|if
condition|(
name|bang
condition|)
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"! "
argument_list|)
expr_stmt|;
else|else
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* write the rawin version */
ifndef|#
directive|ifndef
name|NO_FKEY
if|if
condition|(
name|scan
operator|->
name|label
condition|)
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|scan
operator|->
name|label
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|safequote
argument_list|(
name|scan
operator|->
name|rawin
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|" "
argument_list|)
expr_stmt|;
comment|/* dump the mapped version */
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
operator|(
name|scan
operator|->
name|flags
operator|&
name|WHEN_INMV
operator|)
operator|&&
operator|(
name|when
operator|&
operator|(
name|WHEN_VIINP
operator||
name|WHEN_VIREP
operator|)
operator|)
condition|)
block|{
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"visual "
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|safequote
argument_list|(
name|scan
operator|->
name|cooked
argument_list|)
expr_stmt|;
name|strcat
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|twrite
argument_list|(
name|fd
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|strlen
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

