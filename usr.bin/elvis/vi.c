begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vi.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_comment
comment|/* This array describes what each key does */
end_comment

begin_define
define|#
directive|define
name|NO_FUNC
value|(MARK (*)())0
end_define

begin_define
define|#
directive|define
name|NO_ARGS
value|0
end_define

begin_define
define|#
directive|define
name|CURSOR
value|1
end_define

begin_define
define|#
directive|define
name|CURSOR_CNT_KEY
value|2
end_define

begin_define
define|#
directive|define
name|CURSOR_MOVED
value|3
end_define

begin_define
define|#
directive|define
name|CURSOR_EOL
value|4
end_define

begin_define
define|#
directive|define
name|ZERO
value|5
end_define

begin_define
define|#
directive|define
name|DIGIT
value|6
end_define

begin_define
define|#
directive|define
name|CURSOR_TEXT
value|7
end_define

begin_define
define|#
directive|define
name|KEYWORD
value|8
end_define

begin_define
define|#
directive|define
name|ARGSMASK
value|0x0f
end_define

begin_define
define|#
directive|define
name|C_C_K_REP1
value|(CURSOR_CNT_KEY | 0x10)
end_define

begin_define
define|#
directive|define
name|C_C_K_CUT
value|(CURSOR_CNT_KEY | 0x20)
end_define

begin_define
define|#
directive|define
name|C_C_K_MARK
value|(CURSOR_CNT_KEY | 0x30)
end_define

begin_define
define|#
directive|define
name|C_C_K_CHAR
value|(CURSOR_CNT_KEY | 0x40)
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|NO_SHOWMODE
end_ifndef

begin_decl_stmt
specifier|static
name|int
name|keymodes
index|[]
init|=
block|{
literal|0
block|,
name|WHEN_REP1
block|,
name|WHEN_CUT
block|,
name|WHEN_MARK
block|,
name|WHEN_CHAR
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|KEYMODE
parameter_list|(
name|args
parameter_list|)
value|(keymodes[(args)>> 4])
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|KEYMODE
parameter_list|(
name|args
parameter_list|)
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
specifier|static
struct|struct
name|keystru
block|{
name|MARK
function_decl|(
modifier|*
name|func
function_decl|)
parameter_list|()
function_decl|;
comment|/* the function to run */
name|uchar
name|args
decl_stmt|;
comment|/* description of the args needed */
ifndef|#
directive|ifndef
name|NO_VISIBLE
name|short
name|flags
decl_stmt|;
else|#
directive|else
name|uchar
name|flags
decl_stmt|;
comment|/* other stuff */
endif|#
directive|endif
block|}
name|vikeys
index|[]
init|=
block|{
comment|/* NUL not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/* ^A  find cursor word */
block|{
name|m_wsrch
block|,
name|KEYWORD
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/* ^A  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/* ^B  page backward	*/
block|{
name|m_scroll
block|,
name|CURSOR
block|,
name|FRNT
operator||
name|VIZ
block|}
block|,
comment|/* ^C  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^D  scroll dn 1/2page*/
block|{
name|m_scroll
block|,
name|CURSOR
block|,
name|NCOL
operator||
name|VIZ
block|}
block|,
comment|/* ^E  scroll up	*/
block|{
name|m_scroll
block|,
name|CURSOR
block|,
name|NCOL
operator||
name|VIZ
block|}
block|,
comment|/* ^F  page forward	*/
block|{
name|m_scroll
block|,
name|CURSOR
block|,
name|FRNT
operator||
name|VIZ
block|}
block|,
comment|/* ^G  show file status	*/
block|{
name|v_status
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^H  move left, like h*/
block|{
name|m_left
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/* ^I  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^J  move down	*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/* ^K  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^L  redraw screen	*/
block|{
name|v_redraw
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
operator||
name|VIZ
block|}
block|,
comment|/* ^M  mv front next ln */
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/* ^N  move down	*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
operator||
name|NCOL
block|}
block|,
comment|/* ^O  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^P  move up		*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
operator||
name|NCOL
block|}
block|,
comment|/* ^Q  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^R  redraw screen	*/
block|{
name|v_redraw
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
operator||
name|VIZ
block|}
block|,
comment|/* ^S  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
ifndef|#
directive|ifndef
name|NO_TAGSTACK
comment|/* ^T  pop tagstack	*/
block|{
name|v_pop
block|,
name|CURSOR
block|,
name|NO_FLAGS
block|}
block|,
else|#
directive|else
comment|/* ^T  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/* ^U  scroll up 1/2page*/
block|{
name|m_scroll
block|,
name|CURSOR
block|,
name|NCOL
operator||
name|VIZ
block|}
block|,
comment|/* ^V  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^W  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^X  move to phys col	*/
block|{
name|m_tocol
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
comment|/* ^Y  scroll down	*/
block|{
name|m_scroll
block|,
name|CURSOR
block|,
name|NCOL
operator||
name|VIZ
block|}
block|,
ifdef|#
directive|ifdef
name|SIGTSTP
comment|/* ^Z  suspend elvis	*/
block|{
name|v_suspend
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
else|#
directive|else
comment|/* ^Z  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/* ESC not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^\  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^]  keyword is tag	*/
block|{
name|v_tag
block|,
name|KEYWORD
block|,
name|NO_FLAGS
block|}
block|,
comment|/* ^^  previous file	*/
block|{
name|v_switch
block|,
name|CURSOR
block|,
name|FRNT
block|}
block|,
comment|/* ^_  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/* SPC move right,like l*/
block|{
name|m_right
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*  !  run thru filter	*/
block|{
name|v_filter
block|,
name|CURSOR_MOVED
block|,
name|FRNT
operator||
name|LNMD
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*  "  select cut buffer*/
block|{
name|v_selcut
block|,
name|C_C_K_CUT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/*  #  increment number	*/
block|{
name|v_increment
block|,
name|KEYWORD
block|,
name|SDOT
block|}
block|,
else|#
directive|else
comment|/*  #  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  $  move to rear	*/
block|{
name|m_rear
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*  %  move to match	*/
block|{
name|m_match
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*&  repeat subst	*/
block|{
name|v_again
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|NCOL
operator||
name|LNMD
operator||
name|INCL
block|}
block|,
comment|/*  '  move to a mark	*/
block|{
name|m_tomark
block|,
name|C_C_K_MARK
block|,
name|MVMT
operator||
name|FRNT
operator||
name|NREL
operator||
name|LNMD
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
ifndef|#
directive|ifndef
name|NO_SENTENCE
comment|/*  (  mv back sentence	*/
block|{
name|m_sentence
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/*  )  mv fwd sentence	*/
block|{
name|m_sentence
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  (  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  )  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
ifndef|#
directive|ifndef
name|NO_ERRLIST
comment|/*  *  errlist		*/
block|{
name|v_errlist
block|,
name|CURSOR
block|,
name|FRNT
operator||
name|NREL
block|}
block|,
else|#
directive|else
comment|/*  *  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  +  mv front next ln */
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  ,  reverse [fFtT] cmd*/
block|{
name|m__ch
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  ,  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  -  mv front prev ln	*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/*  .  special...	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  /  forward search	*/
block|{
name|m_fsrch
block|,
name|CURSOR_TEXT
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
comment|/*  0  part of count?	*/
block|{
name|NO_FUNC
block|,
name|ZERO
block|,
name|MVMT
operator||
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  1  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  2  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  3  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  4  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  5  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  6  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  7  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  8  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  9  part of count	*/
block|{
name|NO_FUNC
block|,
name|DIGIT
block|,
name|PTMV
operator||
name|VIZ
block|}
block|,
comment|/*  :  run single EX cmd*/
block|{
name|v_1ex
block|,
name|CURSOR_TEXT
block|,
name|NO_FLAGS
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  ;  repeat [fFtT] cmd*/
block|{
name|m__ch
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  ;  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
operator||
name|VIZ
block|}
block|,
endif|#
directive|endif
comment|/*<  shift text left	*/
block|{
name|v_lshift
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*  =  preset filter	*/
block|{
name|v_reformat
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*>  shift text right	*/
block|{
name|v_rshift
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|FRNT
operator||
name|LNMD
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*  ?  backward search	*/
block|{
name|m_bsrch
block|,
name|CURSOR_TEXT
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
ifndef|#
directive|ifndef
name|NO_AT
comment|/*  @  execute a cutbuf */
block|{
name|v_at
block|,
name|C_C_K_CUT
block|,
name|NO_FLAGS
block|}
block|,
else|#
directive|else
comment|/*  @  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  A  append at EOL	*/
block|{
name|v_insert
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  B  move back Word	*/
block|{
name|m_bword
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/*  C  change to EOL	*/
block|{
name|v_change
block|,
name|CURSOR_EOL
block|,
name|SDOT
block|}
block|,
comment|/*  D  delete to EOL	*/
block|{
name|v_delete
block|,
name|CURSOR_EOL
block|,
name|SDOT
block|}
block|,
comment|/*  E  move end of Word	*/
block|{
name|m_eword
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  F  move bk to char	*/
block|{
name|m_Fch
block|,
name|C_C_K_CHAR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  F  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  G  move to line #	*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|NREL
operator||
name|LNMD
operator||
name|FRNT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*  H  move to row	*/
block|{
name|m_row
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|FRNT
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/*  I  insert at front	*/
block|{
name|v_insert
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  J  join lines	*/
block|{
name|v_join
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
comment|/*  K  look up keyword	*/
block|{
name|v_keyword
block|,
name|KEYWORD
block|,
name|NO_FLAGS
block|}
block|,
else|#
directive|else
comment|/*  K  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  L  move to last row	*/
block|{
name|m_row
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|FRNT
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/*  M  move to mid row	*/
block|{
name|m_row
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|FRNT
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/*  N  reverse prev srch*/
block|{
name|m_nsrch
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
comment|/*  O  insert above line*/
block|{
name|v_insert
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  P  paste before	*/
block|{
name|v_paste
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  Q  quit to EX mode	*/
block|{
name|v_quit
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  R  overtype		*/
block|{
name|v_overtype
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  S  change line	*/
block|{
name|v_change
block|,
name|CURSOR_MOVED
block|,
name|SDOT
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  T  move bk to char	*/
block|{
name|m_Tch
block|,
name|C_C_K_CHAR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  T  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  U  undo whole line	*/
block|{
name|v_undoline
block|,
name|CURSOR
block|,
name|FRNT
block|}
block|,
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/*  V  start visible	*/
block|{
name|v_start
block|,
name|CURSOR
block|,
name|INCL
operator||
name|LNMD
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  V  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  W  move forward Word*/
block|{
name|m_fword
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|NWRP
operator||
name|VIZ
block|}
block|,
comment|/*  X  delete to left	*/
block|{
name|v_xchar
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  Y  yank text	*/
block|{
name|v_yank
block|,
name|CURSOR_MOVED
block|,
name|NCOL
block|}
block|,
comment|/*  Z  save file& exit	*/
block|{
name|v_xit
block|,
name|CURSOR_CNT_KEY
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  [  move back section*/
block|{
name|m_paragraph
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
ifndef|#
directive|ifndef
name|NO_POPUP
comment|/*  \  pop-up menu	*/
block|{
name|v_popup
block|,
name|CURSOR_MOVED
block|,
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  \  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  ]  move fwd section */
block|{
name|m_paragraph
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
comment|/*  ^  move to front	*/
block|{
name|m_front
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/*  _  current line	*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|LNMD
operator||
name|FRNT
operator||
name|INCL
block|}
block|,
comment|/*  `  move to mark	*/
block|{
name|m_tomark
block|,
name|C_C_K_MARK
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
comment|/*  a  append at cursor	*/
block|{
name|v_insert
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  b  move back word	*/
block|{
name|m_bword
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/*  c  change text	*/
block|{
name|v_change
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|VIZ
block|}
block|,
comment|/*  d  delete op	*/
block|{
name|v_delete
block|,
name|CURSOR_MOVED
block|,
name|SDOT
operator||
name|VIZ
block|}
block|,
comment|/*  e  move end word	*/
block|{
name|m_eword
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  f  move fwd for char*/
block|{
name|m_fch
block|,
name|C_C_K_CHAR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  f  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  g  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  h  move left	*/
block|{
name|m_left
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/*  i  insert at cursor	*/
block|{
name|v_insert
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  j  move down	*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|NCOL
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/*  k  move up		*/
block|{
name|m_updnto
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|NCOL
operator||
name|LNMD
operator||
name|VIZ
operator||
name|INCL
block|}
block|,
comment|/*  l  move right	*/
block|{
name|m_right
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
comment|/*  m  define a mark	*/
block|{
name|v_mark
block|,
name|C_C_K_MARK
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  n  repeat prev srch	*/
block|{
name|m_nsrch
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
comment|/*  o  insert below line*/
block|{
name|v_insert
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  p  paste after	*/
block|{
name|v_paste
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  q  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
comment|/*  r  replace chars	*/
block|{
name|v_replace
block|,
name|C_C_K_REP1
block|,
name|SDOT
block|}
block|,
comment|/*  s  subst N chars	*/
block|{
name|v_subst
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
ifndef|#
directive|ifndef
name|NO_CHARSEARCH
comment|/*  t  move fwd to char	*/
block|{
name|m_tch
block|,
name|C_C_K_CHAR
block|,
name|MVMT
operator||
name|INCL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  t  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  u  undo		*/
block|{
name|v_undo
block|,
name|CURSOR
block|,
name|NO_FLAGS
block|}
block|,
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/*  v  start visible	*/
block|{
name|v_start
block|,
name|CURSOR
block|,
name|INCL
operator||
name|VIZ
block|}
block|,
else|#
directive|else
comment|/*  v  not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|,
endif|#
directive|endif
comment|/*  w  move fwd word	*/
block|{
name|m_fword
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|INCL
operator||
name|NWRP
operator||
name|VIZ
block|}
block|,
comment|/*  x  delete character	*/
block|{
name|v_xchar
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/*  y  yank text	*/
block|{
name|v_yank
block|,
name|CURSOR_MOVED
block|,
name|NCOL
operator||
name|VIZ
block|}
block|,
comment|/*  z  adjust scrn row	*/
block|{
name|m_z
block|,
name|CURSOR_CNT_KEY
block|,
name|NCOL
operator||
name|VIZ
block|}
block|,
comment|/*  {  back paragraph	*/
block|{
name|m_paragraph
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/*  |  move to column	*/
block|{
name|m_tocol
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|NREL
operator||
name|VIZ
block|}
block|,
comment|/*  }  fwd paragraph	*/
block|{
name|m_paragraph
block|,
name|CURSOR
block|,
name|MVMT
operator||
name|VIZ
block|}
block|,
comment|/*  ~  upper/lowercase	*/
block|{
name|v_ulcase
block|,
name|CURSOR
block|,
name|SDOT
block|}
block|,
comment|/* DEL not defined	*/
block|{
name|NO_FUNC
block|,
name|NO_ARGS
block|,
name|NO_FLAGS
block|}
block|}
struct|;
end_struct

begin_function
name|void
name|vi
parameter_list|()
block|{
name|REG
name|int
name|key
decl_stmt|;
comment|/* keystroke from user */
name|long
name|count
decl_stmt|;
comment|/* numeric argument to some functions */
name|REG
name|struct
name|keystru
modifier|*
name|keyptr
decl_stmt|;
comment|/* pointer to vikeys[] element */
name|MARK
name|tcurs
decl_stmt|;
comment|/* temporary cursor */
name|int
name|prevkey
decl_stmt|;
comment|/* previous key, if d/c/y/</>/! */
name|MARK
name|range
decl_stmt|;
comment|/* start of range for d/c/y/</>/! */
name|char
name|text
index|[
literal|132
index|]
decl_stmt|;
name|int
name|dotkey
decl_stmt|;
comment|/* last "key" of a change */
name|int
name|dotpkey
decl_stmt|;
comment|/* last "prevkey" of a change */
name|int
name|dotkey2
decl_stmt|;
comment|/* last extra "getkey()" of a change */
name|int
name|dotcnt
decl_stmt|;
comment|/* last "count" of a change */
name|int
name|firstkey
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
comment|/* tell the redraw() function to start from scratch */
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|lint
comment|/* lint says that "range" might be used before it is set.  This 	 * can't really happen due to the way "range" and "prevkey" are used, 	 * but lint doesn't know that.  This line is here ONLY to keep lint 	 * happy. 	 */
name|range
operator|=
literal|0L
expr_stmt|;
endif|#
directive|endif
comment|/* safeguard against '.' with no previous command */
name|dotkey
operator|=
name|dotpkey
operator|=
name|dotkey2
operator|=
name|dotcnt
operator|=
literal|0
expr_stmt|;
comment|/* go immediately into insert mode, if ":set inputmode" */
name|firstkey
operator|=
literal|0
expr_stmt|;
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
operator|*
name|o_inputmode
condition|)
block|{
name|firstkey
operator|=
literal|'i'
expr_stmt|;
block|}
endif|#
directive|endif
comment|/* Repeatedly handle VI commands */
for|for
control|(
name|count
operator|=
literal|0
operator|,
name|prevkey
operator|=
literal|'\0'
init|;
name|mode
operator|==
name|MODE_VI
condition|;
control|)
block|{
comment|/* if we've moved off the undoable line, then we can't undo it at all */
if|if
condition|(
name|markline
argument_list|(
name|cursor
argument_list|)
operator|!=
name|U_line
condition|)
block|{
name|U_line
operator|=
literal|0L
expr_stmt|;
block|}
comment|/* report any changes from the previous command */
if|if
condition|(
name|rptlines
operator|>=
operator|*
name|o_report
condition|)
block|{
name|redraw
argument_list|(
name|cursor
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
name|msg
argument_list|(
literal|"%ld line%s %s"
argument_list|,
name|rptlines
argument_list|,
operator|(
name|rptlines
operator|==
literal|1
condition|?
literal|""
else|:
literal|"s"
operator|)
argument_list|,
name|rptlabel
argument_list|)
expr_stmt|;
block|}
name|rptlines
operator|=
literal|0L
expr_stmt|;
comment|/* get the next command key.  It must be ASCII */
if|if
condition|(
name|firstkey
condition|)
block|{
name|key
operator|=
name|firstkey
expr_stmt|;
name|firstkey
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
do|do
block|{
name|key
operator|=
name|getkey
argument_list|(
name|WHEN_VICMD
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|key
operator|<
literal|0
operator|||
name|key
operator|>
literal|127
condition|)
do|;
block|}
ifdef|#
directive|ifdef
name|DEBUG2
name|debout
argument_list|(
literal|"\nkey='%c'\n"
argument_list|,
name|key
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* Convert a doubled-up operator such as "dd" into "d_" */
if|if
condition|(
name|prevkey
operator|&&
name|key
operator|==
name|prevkey
condition|)
block|{
name|key
operator|=
literal|'_'
expr_stmt|;
block|}
comment|/* look up the structure describing this command */
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
comment|/* '&' and uppercase operators always act like doubled */
if|if
condition|(
operator|!
name|prevkey
operator|&&
name|keyptr
operator|->
name|args
operator|==
name|CURSOR_MOVED
operator|&&
operator|(
name|key
operator|==
literal|'&'
operator|||
name|isupper
argument_list|(
name|key
argument_list|)
operator|)
condition|)
block|{
name|range
operator|=
name|cursor
expr_stmt|;
name|prevkey
operator|=
name|key
expr_stmt|;
name|key
operator|=
literal|'_'
expr_stmt|;
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/* if we're in the middle of a v/V command, reject commands 		 * that aren't operators or movement commands 		 */
if|if
condition|(
name|V_from
operator|&&
operator|!
operator|(
name|keyptr
operator|->
name|flags
operator|&
name|VIZ
operator|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|prevkey
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
endif|#
directive|endif
comment|/* if we're in the middle of a d/c/y/</>/! command, reject 		 * anything but movement. 		 */
if|if
condition|(
name|prevkey
operator|&&
operator|!
operator|(
name|keyptr
operator|->
name|flags
operator|&
operator|(
name|MVMT
operator||
name|PTMV
operator|)
operator|)
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
name|prevkey
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* set the "dot" variables, if we're supposed to */
if|if
condition|(
operator|(
operator|(
name|keyptr
operator|->
name|flags
operator|&
name|SDOT
operator|)
operator|||
operator|(
name|prevkey
operator|&&
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
operator|&
name|SDOT
operator|)
operator|)
ifndef|#
directive|ifndef
name|NO_VISIBLE
operator|&&
operator|!
name|V_from
endif|#
directive|endif
condition|)
block|{
name|dotkey
operator|=
name|key
expr_stmt|;
name|dotpkey
operator|=
name|prevkey
expr_stmt|;
name|dotkey2
operator|=
literal|'\0'
expr_stmt|;
name|dotcnt
operator|=
name|count
expr_stmt|;
comment|/* remember the line before any changes are made */
if|if
condition|(
name|U_line
operator|!=
name|markline
argument_list|(
name|cursor
argument_list|)
condition|)
block|{
name|U_line
operator|=
name|markline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|U_text
argument_list|,
name|fetchline
argument_list|(
name|U_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if this is "." then set other vars from the "dot" vars */
if|if
condition|(
name|key
operator|==
literal|'.'
condition|)
block|{
name|key
operator|=
name|dotkey
expr_stmt|;
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
name|prevkey
operator|=
name|dotpkey
expr_stmt|;
if|if
condition|(
name|prevkey
condition|)
block|{
name|range
operator|=
name|cursor
expr_stmt|;
block|}
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|count
operator|=
name|dotcnt
expr_stmt|;
block|}
name|doingdot
operator|=
name|TRUE
expr_stmt|;
comment|/* remember the line before any changes are made */
if|if
condition|(
name|U_line
operator|!=
name|markline
argument_list|(
name|cursor
argument_list|)
condition|)
block|{
name|U_line
operator|=
name|markline
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
name|strcpy
argument_list|(
name|U_text
argument_list|,
name|fetchline
argument_list|(
name|U_line
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|doingdot
operator|=
name|FALSE
expr_stmt|;
block|}
comment|/* process the key as a command */
name|tcurs
operator|=
name|cursor
expr_stmt|;
name|force_flags
operator|=
name|NO_FLAGS
expr_stmt|;
switch|switch
condition|(
name|keyptr
operator|->
name|args
operator|&
name|ARGSMASK
condition|)
block|{
case|case
name|ZERO
case|:
if|if
condition|(
name|count
operator|==
literal|0
condition|)
block|{
name|tcurs
operator|=
name|cursor
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
comment|/* else fall through& treat like other digits... */
case|case
name|DIGIT
case|:
name|count
operator|=
name|count
operator|*
literal|10
operator|+
name|key
operator|-
literal|'0'
expr_stmt|;
break|break;
case|case
name|KEYWORD
case|:
comment|/* if not on a keyword, fail */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|markidx
argument_list|(
name|cursor
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|isalnum
argument_list|(
name|ptext
index|[
name|key
index|]
argument_list|)
condition|)
block|{
name|tcurs
operator|=
name|MARK_UNSET
expr_stmt|;
break|break;
block|}
comment|/* find the start of the keyword */
while|while
condition|(
name|key
operator|>
literal|0
operator|&&
name|isalnum
argument_list|(
name|ptext
index|[
name|key
operator|-
literal|1
index|]
argument_list|)
condition|)
block|{
name|key
operator|--
expr_stmt|;
block|}
name|tcurs
operator|=
operator|(
name|cursor
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|key
expr_stmt|;
comment|/* copy it into a buffer, and NUL-terminate it */
name|i
operator|=
literal|0
expr_stmt|;
do|do
block|{
name|text
index|[
name|i
operator|++
index|]
operator|=
name|ptext
index|[
name|key
operator|++
index|]
expr_stmt|;
block|}
do|while
condition|(
name|isalnum
argument_list|(
name|ptext
index|[
name|key
index|]
argument_list|)
condition|)
do|;
name|text
index|[
name|i
index|]
operator|=
literal|'\0'
expr_stmt|;
comment|/* call the function */
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|text
argument_list|,
name|tcurs
argument_list|,
name|count
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|NO_ARGS
case|:
if|if
condition|(
name|keyptr
operator|->
name|func
condition|)
block|{
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|beep
argument_list|()
expr_stmt|;
block|}
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR
case|:
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|count
argument_list|,
name|key
argument_list|,
name|prevkey
argument_list|)
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR_CNT_KEY
case|:
if|if
condition|(
name|doingdot
condition|)
block|{
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|count
argument_list|,
name|dotkey2
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* get a key */
name|i
operator|=
name|getkey
argument_list|(
name|KEYMODE
argument_list|(
name|keyptr
operator|->
name|args
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
literal|'\033'
condition|)
comment|/* ESC */
block|{
name|count
operator|=
literal|0
expr_stmt|;
name|tcurs
operator|=
name|MARK_UNSET
expr_stmt|;
break|break;
comment|/* exit from "case CURSOR_CNT_KEY" */
block|}
elseif|else
if|if
condition|(
name|i
operator|==
name|ctrl
argument_list|(
literal|'V'
argument_list|)
condition|)
block|{
name|i
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* if part of an SDOT command, remember it */
if|if
condition|(
name|keyptr
operator|->
name|flags
operator|&
name|SDOT
operator|||
operator|(
name|prevkey
operator|&&
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
operator|&
name|SDOT
operator|)
condition|)
block|{
name|dotkey2
operator|=
name|i
expr_stmt|;
block|}
comment|/* do it */
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|count
argument_list|,
name|i
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|keyptr
operator|->
name|args
operator|!=
name|C_C_K_CUT
condition|)
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
case|case
name|CURSOR_MOVED
case|:
ifndef|#
directive|ifndef
name|NO_VISIBLE
if|if
condition|(
name|V_from
condition|)
block|{
name|range
operator|=
name|cursor
expr_stmt|;
name|tcurs
operator|=
name|V_from
expr_stmt|;
name|count
operator|=
literal|0L
expr_stmt|;
name|prevkey
operator|=
name|key
expr_stmt|;
name|key
operator|=
operator|(
name|V_linemd
condition|?
literal|'V'
else|:
literal|'v'
operator|)
expr_stmt|;
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
block|}
else|else
endif|#
directive|endif
block|{
name|prevkey
operator|=
name|key
expr_stmt|;
name|range
operator|=
name|cursor
expr_stmt|;
name|force_flags
operator|=
name|LNMD
operator||
name|INCL
expr_stmt|;
block|}
break|break;
case|case
name|CURSOR_EOL
case|:
name|prevkey
operator|=
name|key
expr_stmt|;
comment|/* a zero-length line needs special treatment */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|==
literal|0
condition|)
block|{
comment|/* act on a zero-length section of text */
name|range
operator|=
name|tcurs
operator|=
name|cursor
expr_stmt|;
name|key
operator|=
literal|'0'
expr_stmt|;
block|}
else|else
block|{
comment|/* act like CURSOR_MOVED with '$' movement */
name|range
operator|=
name|cursor
expr_stmt|;
name|tcurs
operator|=
name|m_rear
argument_list|(
name|cursor
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
name|key
operator|=
literal|'$'
expr_stmt|;
block|}
name|count
operator|=
literal|0L
expr_stmt|;
name|keyptr
operator|=
operator|&
name|vikeys
index|[
name|key
index|]
expr_stmt|;
break|break;
case|case
name|CURSOR_TEXT
case|:
do|do
block|{
name|text
index|[
literal|0
index|]
operator|=
name|key
expr_stmt|;
name|text
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|doingdot
operator|||
name|vgets
argument_list|(
name|key
argument_list|,
name|text
operator|+
literal|1
argument_list|,
sizeof|sizeof
name|text
operator|-
literal|1
argument_list|)
operator|>=
literal|0
condition|)
block|{
comment|/* reassure user that<CR> was hit */
name|qaddch
argument_list|(
literal|'\r'
argument_list|)
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
comment|/* call the function with the text */
name|tcurs
operator|=
call|(
modifier|*
name|keyptr
operator|->
name|func
call|)
argument_list|(
name|cursor
argument_list|,
name|text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|exwrote
operator|||
name|mode
operator|==
name|MODE_COLON
condition|)
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
name|mode
operator|=
name|MODE_VI
expr_stmt|;
block|}
block|}
do|while
condition|(
name|mode
operator|==
name|MODE_COLON
condition|)
do|;
name|count
operator|=
literal|0L
expr_stmt|;
break|break;
block|}
comment|/* if that command took us out of vi mode, then exit the loop 		 * NOW, without tweaking the cursor or anything.  This is very 		 * important when mode == MODE_QUIT. 		 */
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
condition|)
block|{
break|break;
block|}
comment|/* now move the cursor, as appropriate */
if|if
condition|(
name|prevkey
operator|&&
operator|(
operator|(
name|keyptr
operator|->
name|flags
operator|&
name|MVMT
operator|)
ifndef|#
directive|ifndef
name|NO_VISIBLE
operator|||
name|V_from
endif|#
directive|endif
operator|)
operator|&&
name|count
operator|==
literal|0L
condition|)
block|{
comment|/* movements used as targets are less strict */
name|tcurs
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|tcurs
argument_list|,
call|(
name|int
call|)
argument_list|(
name|keyptr
operator|->
name|flags
operator||
name|force_flags
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|keyptr
operator|->
name|args
operator|==
name|CURSOR_MOVED
condition|)
block|{
comment|/* the< and> keys have FRNT, 			 * but it shouldn't be applied yet 			 */
name|tcurs
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|tcurs
argument_list|,
name|FINL
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tcurs
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|tcurs
argument_list|,
call|(
name|int
call|)
argument_list|(
name|keyptr
operator|->
name|flags
operator||
name|force_flags
operator||
name|FINL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* was that the end of a d/c/y/</>/! command? */
if|if
condition|(
name|prevkey
operator|&&
operator|(
operator|(
name|keyptr
operator|->
name|flags
operator|&
name|MVMT
operator|)
ifndef|#
directive|ifndef
name|NO_VISIBLE
operator|||
name|V_from
endif|#
directive|endif
operator|)
operator|&&
name|count
operator|==
literal|0L
condition|)
block|{
ifndef|#
directive|ifndef
name|NO_VISIBLE
comment|/* turn off the hilight */
name|V_from
operator|=
literal|0L
expr_stmt|;
endif|#
directive|endif
comment|/* if the movement command failed, cancel operation */
if|if
condition|(
name|tcurs
operator|==
name|MARK_UNSET
condition|)
block|{
name|prevkey
operator|=
literal|0
expr_stmt|;
name|count
operator|=
literal|0
expr_stmt|;
continue|continue;
block|}
comment|/* make sure range=front and tcurs=rear.  Either way, 			 * leave cursor=range since that's where we started. 			 */
name|cursor
operator|=
name|range
expr_stmt|;
if|if
condition|(
name|tcurs
operator|<
name|range
condition|)
block|{
name|range
operator|=
name|tcurs
expr_stmt|;
name|tcurs
operator|=
name|cursor
expr_stmt|;
block|}
comment|/* The 'w' and 'W' destinations should never take us 			 * to the front of a line.  Instead, they should take 			 * us only to the end of the preceding line. 			 */
if|if
condition|(
operator|(
name|keyptr
operator|->
name|flags
operator|&
name|NWRP
operator|)
operator|==
name|NWRP
operator|&&
name|markline
argument_list|(
name|range
argument_list|)
operator|<
name|markline
argument_list|(
name|tcurs
argument_list|)
operator|&&
operator|(
name|markline
argument_list|(
name|tcurs
argument_list|)
operator|>
name|nlines
operator|||
name|tcurs
operator|==
name|m_front
argument_list|(
name|tcurs
argument_list|,
literal|0L
argument_list|)
operator|)
condition|)
block|{
name|tcurs
operator|=
operator|(
name|tcurs
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|-
name|BLKSIZE
expr_stmt|;
name|pfetch
argument_list|(
name|markline
argument_list|(
name|tcurs
argument_list|)
argument_list|)
expr_stmt|;
name|tcurs
operator|+=
name|plen
expr_stmt|;
block|}
comment|/* adjust for line mode& inclusion of last char/line */
name|i
operator|=
operator|(
name|keyptr
operator|->
name|flags
operator||
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
operator|)
expr_stmt|;
switch|switch
condition|(
operator|(
name|i
operator||
name|force_flags
operator|)
operator|&
operator|(
name|INCL
operator||
name|LNMD
operator|)
condition|)
block|{
case|case
name|INCL
case|:
name|tcurs
operator|++
expr_stmt|;
break|break;
case|case
name|INCL
operator||
name|LNMD
case|:
name|tcurs
operator|+=
name|BLKSIZE
expr_stmt|;
comment|/* fall through... */
case|case
name|LNMD
case|:
name|range
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|tcurs
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
break|break;
block|}
comment|/* run the function */
name|tcurs
operator|=
operator|(
operator|*
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|func
operator|)
operator|(
name|range
operator|,
name|tcurs
operator|)
expr_stmt|;
if|if
condition|(
name|mode
operator|==
name|MODE_VI
condition|)
block|{
operator|(
name|void
operator|)
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|FINL
argument_list|)
expr_stmt|;
name|cursor
operator|=
name|adjmove
argument_list|(
name|cursor
argument_list|,
name|tcurs
argument_list|,
call|(
name|int
call|)
argument_list|(
name|vikeys
index|[
name|prevkey
index|]
operator|.
name|flags
operator||
name|FINL
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* cleanup */
name|prevkey
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|!
name|prevkey
condition|)
block|{
if|if
condition|(
name|tcurs
operator|!=
name|MARK_UNSET
condition|)
name|cursor
operator|=
name|tcurs
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* This function adjusts the MARK value that they return; here we make sure  * it isn't past the end of the line, and that the column hasn't been  * *accidentally* changed.  */
end_comment

begin_function
name|MARK
name|adjmove
parameter_list|(
name|old
parameter_list|,
name|new
parameter_list|,
name|flags
parameter_list|)
name|MARK
name|old
decl_stmt|;
comment|/* the cursor position before the command */
name|REG
name|MARK
name|new
decl_stmt|;
comment|/* the cursor position after the command */
name|int
name|flags
decl_stmt|;
comment|/* various flags regarding cursor mvmt */
block|{
specifier|static
name|int
name|colno
decl_stmt|;
comment|/* the column number that we want */
name|REG
name|char
modifier|*
name|text
decl_stmt|;
comment|/* used to scan through the line's text */
name|REG
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|DEBUG2
name|debout
argument_list|(
literal|"adjmove(%ld.%d, %ld.%d, 0x%x)\n"
argument_list|,
name|markline
argument_list|(
name|old
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|old
argument_list|)
argument_list|,
name|markline
argument_list|(
name|new
argument_list|)
argument_list|,
name|markidx
argument_list|(
name|new
argument_list|)
argument_list|,
name|flags
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|DEBUG
name|watch
argument_list|()
expr_stmt|;
endif|#
directive|endif
comment|/* if the command failed, bag it! */
if|if
condition|(
name|new
operator|==
name|MARK_UNSET
condition|)
block|{
if|if
condition|(
name|flags
operator|&
name|FINL
condition|)
block|{
name|beep
argument_list|()
expr_stmt|;
return|return
name|old
return|;
block|}
return|return
name|new
return|;
block|}
comment|/* if this is a non-relative movement, set the '' mark */
if|if
condition|(
name|flags
operator|&
name|NREL
condition|)
block|{
name|mark
index|[
literal|26
index|]
operator|=
name|old
expr_stmt|;
block|}
comment|/* make sure it isn't past the end of the file */
if|if
condition|(
name|markline
argument_list|(
name|new
argument_list|)
operator|<
literal|1
condition|)
block|{
name|new
operator|=
name|MARK_FIRST
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|markline
argument_list|(
name|new
argument_list|)
operator|>
name|nlines
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FINL
operator|)
condition|)
block|{
return|return
name|MARK_EOF
return|;
block|}
name|new
operator|=
name|MARK_LAST
expr_stmt|;
block|}
comment|/* fetch the new line */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|new
argument_list|)
argument_list|)
expr_stmt|;
comment|/* move to the front, if we're supposed to */
if|if
condition|(
name|flags
operator|&
name|FRNT
condition|)
block|{
name|new
operator|=
name|m_front
argument_list|(
name|new
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
block|}
comment|/* change the column#, or change the mark to suit the column# */
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|NCOL
operator|)
condition|)
block|{
comment|/* change the column# */
name|i
operator|=
name|markidx
argument_list|(
name|new
argument_list|)
expr_stmt|;
if|if
condition|(
name|i
operator|==
name|BLKSIZE
operator|-
literal|1
condition|)
block|{
name|new
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|new
operator|+=
name|plen
operator|-
literal|1
expr_stmt|;
block|}
name|colno
operator|=
name|BLKSIZE
operator|*
literal|8
expr_stmt|;
comment|/* one heck of a big colno */
block|}
elseif|else
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|i
operator|>=
name|plen
condition|)
block|{
name|new
operator|=
operator|(
name|new
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
operator|-
literal|1
expr_stmt|;
block|}
name|colno
operator|=
name|idx2col
argument_list|(
name|new
argument_list|,
name|ptext
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|new
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|colno
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* adjust the mark to get as close as possible to column# */
for|for
control|(
name|i
operator|=
literal|0
operator|,
name|text
operator|=
name|ptext
init|;
name|i
operator|<=
name|colno
operator|&&
operator|*
name|text
condition|;
name|text
operator|++
control|)
block|{
if|if
condition|(
operator|*
name|text
operator|==
literal|'\t'
operator|&&
operator|!
operator|*
name|o_list
condition|)
block|{
name|i
operator|+=
operator|*
name|o_tabstop
operator|-
operator|(
name|i
operator|%
operator|*
name|o_tabstop
operator|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|UCHAR
argument_list|(
operator|*
name|text
argument_list|)
operator|<
literal|' '
operator|||
operator|*
name|text
operator|==
literal|127
condition|)
block|{
name|i
operator|+=
literal|2
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|NO_CHARATTR
elseif|else
if|if
condition|(
operator|*
name|o_charattr
operator|&&
name|text
index|[
literal|0
index|]
operator|==
literal|'\\'
operator|&&
name|text
index|[
literal|1
index|]
operator|==
literal|'f'
operator|&&
name|text
index|[
literal|2
index|]
condition|)
block|{
name|text
operator|+=
literal|2
expr_stmt|;
comment|/* plus one more in "for()" stmt */
block|}
endif|#
directive|endif
else|else
block|{
name|i
operator|++
expr_stmt|;
block|}
block|}
if|if
condition|(
name|text
operator|>
name|ptext
condition|)
block|{
name|text
operator|--
expr_stmt|;
block|}
name|new
operator|=
operator|(
name|new
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
call|(
name|int
call|)
argument_list|(
name|text
operator|-
name|ptext
argument_list|)
expr_stmt|;
block|}
return|return
name|new
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|DEBUG
end_ifdef

begin_macro
name|watch
argument_list|()
end_macro

begin_block
block|{
specifier|static
name|wasset
expr_stmt|;
if|if
condition|(
operator|*
name|origname
condition|)
block|{
name|wasset
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|wasset
condition|)
block|{
name|mode
operator|=
name|MODE_EX
expr_stmt|;
name|msg
argument_list|(
literal|"origname was clobbered"
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|wasset
operator|&&
name|nlines
operator|==
literal|0
condition|)
block|{
name|mode
operator|=
name|MODE_EX
expr_stmt|;
name|msg
argument_list|(
literal|"nlines=0"
argument_list|)
expr_stmt|;
name|endwin
argument_list|()
expr_stmt|;
name|abort
argument_list|()
expr_stmt|;
block|}
block|}
end_block

begin_endif
endif|#
directive|endif
end_endif

end_unit

