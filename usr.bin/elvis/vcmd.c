begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* vcmd.c */
end_comment

begin_comment
comment|/* Author:  *	Steve Kirkendall  *	14407 SW Teal Blvd. #C  *	Beaverton, OR 97005  *	kirkenda@cs.pdx.edu  */
end_comment

begin_comment
comment|/* This file contains the functions that handle VI commands */
end_comment

begin_include
include|#
directive|include
file|"config.h"
end_include

begin_include
include|#
directive|include
file|"ctype.h"
end_include

begin_include
include|#
directive|include
file|"vi.h"
end_include

begin_if
if|#
directive|if
name|MSDOS
end_if

begin_include
include|#
directive|include
file|<process.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|TOS
end_if

begin_include
include|#
directive|include
file|<osbind.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_if
if|#
directive|if
name|OSK
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function puts the editor in EX mode */
end_comment

begin_function
name|MARK
name|v_quit
parameter_list|()
block|{
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE_EX
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function causes the screen to be redrawn */
end_comment

begin_function
name|MARK
name|v_redraw
parameter_list|()
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function executes a string of EX commands, and waits for a user keystroke  * before returning to the VI screen.  If that keystroke is another ':', then  * another EX command is read and executed.  */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_1ex
parameter_list|(
name|m
parameter_list|,
name|text
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* the current line */
name|char
modifier|*
name|text
decl_stmt|;
comment|/* the first command to execute */
block|{
comment|/* run the command.  be careful about modes& output */
name|exwrote
operator|=
operator|(
name|mode
operator|==
name|MODE_COLON
operator|)
expr_stmt|;
name|doexcmd
argument_list|(
name|text
argument_list|)
expr_stmt|;
name|exrefresh
argument_list|()
expr_stmt|;
comment|/* if mode is no longer MODE_VI, then we should quit right away! */
if|if
condition|(
name|mode
operator|!=
name|MODE_VI
operator|&&
name|mode
operator|!=
name|MODE_COLON
condition|)
return|return
name|cursor
return|;
comment|/* The command did some output.  Wait for a keystoke. */
if|if
condition|(
name|exwrote
condition|)
block|{
name|mode
operator|=
name|MODE_VI
expr_stmt|;
name|msg
argument_list|(
literal|"[Hit<RETURN> to continue]"
argument_list|)
expr_stmt|;
if|if
condition|(
name|getkey
argument_list|(
literal|0
argument_list|)
operator|==
literal|':'
condition|)
block|{
name|mode
operator|=
name|MODE_COLON
expr_stmt|;
name|addch
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
else|else
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function undoes the last change */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_undo
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* (ignored) */
block|{
if|if
condition|(
name|undo
argument_list|()
condition|)
block|{
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function deletes the character(s) that the cursor is on */
end_comment

begin_function
name|MARK
name|v_xchar
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|cmd
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to start deletions */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to delete */
name|int
name|cmd
decl_stmt|;
comment|/* either 'x' or 'X' */
block|{
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* for 'X', adjust so chars are deleted *BEFORE* cursor */
if|if
condition|(
name|cmd
operator|==
literal|'X'
condition|)
block|{
if|if
condition|(
name|markidx
argument_list|(
name|m
argument_list|)
operator|<
name|cnt
condition|)
return|return
name|MARK_UNSET
return|;
name|m
operator|-=
name|cnt
expr_stmt|;
block|}
comment|/* make sure we don't try to delete more thars than there are */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|m
operator|+
name|cnt
argument_list|)
operator|>
name|plen
condition|)
block|{
name|cnt
operator|=
name|plen
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|cnt
operator|==
literal|0L
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* do it */
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function defines a mark */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_mark
parameter_list|(
name|m
parameter_list|,
name|count
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where the mark will be */
name|long
name|count
decl_stmt|;
comment|/* (ignored) */
name|int
name|key
decl_stmt|;
comment|/* the ASCII label of the mark */
block|{
if|if
condition|(
name|key
operator|<
literal|'a'
operator|||
name|key
operator|>
literal|'z'
condition|)
block|{
name|msg
argument_list|(
literal|"Marks must be from a to z"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mark
index|[
name|key
operator|-
literal|'a'
index|]
operator|=
name|m
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function toggles upper& lower case letters */
end_comment

begin_function
name|MARK
name|v_ulcase
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to make the change */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to flip */
block|{
name|REG
name|char
modifier|*
name|pos
decl_stmt|;
name|REG
name|int
name|j
decl_stmt|;
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* fetch the current version of the line */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
comment|/* for each position in the line */
for|for
control|(
name|j
operator|=
literal|0
operator|,
name|pos
operator|=
operator|&
name|ptext
index|[
name|markidx
argument_list|(
name|m
argument_list|)
index|]
init|;
name|j
operator|<
name|cnt
operator|&&
operator|*
name|pos
condition|;
name|j
operator|++
operator|,
name|pos
operator|++
control|)
block|{
if|if
condition|(
name|isupper
argument_list|(
operator|*
name|pos
argument_list|)
condition|)
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
name|tolower
argument_list|(
operator|*
name|pos
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
name|toupper
argument_list|(
operator|*
name|pos
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* if the new text is different from the old, then change it */
if|if
condition|(
name|strncmp
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
operator|&
name|ptext
index|[
name|markidx
argument_list|(
name|m
argument_list|)
index|]
argument_list|,
name|j
argument_list|)
condition|)
block|{
name|ChangeText
block|{
name|tmpblk
operator|.
name|c
index|[
name|j
index|]
operator|=
literal|'\0'
expr_stmt|;
name|change
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|j
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
block|}
return|return
name|m
operator|+
name|j
return|;
block|}
end_function

begin_function
name|MARK
name|v_replace
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* first char to be replaced */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to replace */
name|int
name|key
decl_stmt|;
comment|/* what to replace them with */
block|{
name|REG
name|char
modifier|*
name|text
decl_stmt|;
name|REG
name|int
name|i
decl_stmt|;
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* map ^M to '\n' */
if|if
condition|(
name|key
operator|==
literal|'\r'
condition|)
block|{
name|key
operator|=
literal|'\n'
expr_stmt|;
block|}
comment|/* make sure the resulting line isn't too long */
if|if
condition|(
name|cnt
operator|>
name|BLKSIZE
operator|-
literal|2
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
condition|)
block|{
name|cnt
operator|=
name|BLKSIZE
operator|-
literal|2
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* build a string of the desired character with the desired length */
for|for
control|(
name|text
operator|=
name|tmpblk
operator|.
name|c
operator|,
name|i
operator|=
name|cnt
init|;
name|i
operator|>
literal|0
condition|;
name|i
operator|--
control|)
block|{
operator|*
name|text
operator|++
operator|=
name|key
expr_stmt|;
block|}
operator|*
name|text
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure cnt doesn't extend past EOL */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|key
operator|=
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
if|if
condition|(
name|key
operator|+
name|cnt
operator|>
name|plen
condition|)
block|{
name|cnt
operator|=
name|plen
operator|-
name|key
expr_stmt|;
block|}
comment|/* do the replacement */
name|ChangeText
block|{
name|change
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|tmpblk
operator|.
name|c
operator|==
literal|'\n'
condition|)
block|{
return|return
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|cnt
operator|*
name|BLKSIZE
return|;
block|}
else|else
block|{
return|return
name|m
operator|+
name|cnt
operator|-
literal|1
return|;
block|}
block|}
end_function

begin_function
name|MARK
name|v_overtype
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to start overtyping */
block|{
name|MARK
name|end
decl_stmt|;
comment|/* end of a substitution */
specifier|static
name|long
name|width
decl_stmt|;
comment|/* width of a single-line replace */
comment|/* the "doingdot" version of replace is really a substitution */
if|if
condition|(
name|doingdot
condition|)
block|{
comment|/* was the last one really repeatable? */
if|if
condition|(
name|width
operator|<
literal|0
condition|)
block|{
name|msg
argument_list|(
literal|"Can't repeat a multi-line overtype command"
argument_list|)
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
comment|/* replacing nothing by nothing?  Don't bother */
if|if
condition|(
name|width
operator|==
literal|0
condition|)
block|{
return|return
name|m
return|;
block|}
comment|/* replace some chars by repeated text */
return|return
name|v_subst
argument_list|(
name|m
argument_list|,
name|width
argument_list|)
return|;
block|}
comment|/* Normally, we input starting here, in replace mode */
name|ChangeText
block|{
name|end
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|WHEN_VIREP
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
comment|/* if we ended on the same line we started on, then this 	 * overtype is repeatable via the dot key. 	 */
if|if
condition|(
name|markline
argument_list|(
name|end
argument_list|)
operator|==
name|markline
argument_list|(
name|m
argument_list|)
operator|&&
name|end
operator|>=
name|m
operator|-
literal|1L
condition|)
block|{
name|width
operator|=
name|end
operator|-
name|m
operator|+
literal|1L
expr_stmt|;
block|}
else|else
comment|/* it isn't repeatable */
block|{
name|width
operator|=
operator|-
literal|1L
expr_stmt|;
block|}
return|return
name|end
return|;
block|}
end_function

begin_comment
comment|/* This function selects which cut buffer to use */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_selcut
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
name|int
name|key
decl_stmt|;
block|{
name|cutname
argument_list|(
name|key
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function pastes text from a cut buffer */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_paste
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|cmd
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to paste the text */
name|long
name|cnt
decl_stmt|;
comment|/* (ignored) */
name|int
name|cmd
decl_stmt|;
comment|/* either 'p' or 'P' */
block|{
name|MARK
name|dest
decl_stmt|;
name|ChangeText
block|{
comment|/* paste the text, and find out where it ends */
name|dest
operator|=
name|paste
argument_list|(
name|m
argument_list|,
name|cmd
operator|==
literal|'p'
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
comment|/* was that a line-mode paste? */
if|if
condition|(
name|dest
operator|&&
name|markline
argument_list|(
name|dest
argument_list|)
operator|!=
name|markline
argument_list|(
name|m
argument_list|)
condition|)
block|{
comment|/* line-mode pastes leave the cursor at the front 			 * of the first pasted line. 			 */
name|dest
operator|=
name|m
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
literal|'p'
condition|)
block|{
name|dest
operator|+=
name|BLKSIZE
expr_stmt|;
block|}
name|force_flags
operator||=
name|FRNT
expr_stmt|;
block|}
block|}
return|return
name|dest
return|;
block|}
end_function

begin_comment
comment|/* This function yanks text into a cut buffer */
end_comment

begin_function
name|MARK
name|v_yank
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of text to yank */
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function deletes a range of text */
end_comment

begin_function
name|MARK
name|v_delete
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of text to delete */
block|{
comment|/* illegal to try and delete nothing */
if|if
condition|(
name|n
operator|<=
name|m
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* Do it */
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|delete
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This starts input mode without deleting anything */
end_comment

begin_function
name|MARK
name|v_insert
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where to start (sort of) */
name|long
name|cnt
decl_stmt|;
comment|/* repeat how many times? */
name|int
name|key
decl_stmt|;
comment|/* what command is this for? {a,A,i,I,o,O} */
block|{
name|int
name|wasdot
decl_stmt|;
name|long
name|reps
decl_stmt|;
name|int
name|above
decl_stmt|;
comment|/* boolean: new line going above old line? */
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|ChangeText
block|{
comment|/* tweak the insertion point, based on command key */
name|above
operator|=
name|FALSE
expr_stmt|;
switch|switch
condition|(
name|key
condition|)
block|{
case|case
literal|'i'
case|:
break|break;
case|case
literal|'a'
case|:
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|plen
operator|>
literal|0
condition|)
block|{
name|m
operator|++
expr_stmt|;
block|}
break|break;
case|case
literal|'I'
case|:
name|m
operator|=
name|m_front
argument_list|(
name|m
argument_list|,
literal|1L
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
expr_stmt|;
break|break;
case|case
literal|'O'
case|:
name|m
operator|&=
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
expr_stmt|;
name|add
argument_list|(
name|m
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|above
operator|=
name|TRUE
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
name|m
operator|=
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|BLKSIZE
expr_stmt|;
name|add
argument_list|(
name|m
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* insert the same text once or more */
for|for
control|(
name|reps
operator|=
name|cnt
operator|,
name|wasdot
operator|=
name|doingdot
init|;
name|reps
operator|>
literal|0
condition|;
name|reps
operator|--
operator|,
name|doingdot
operator|=
name|TRUE
control|)
block|{
name|m
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|WHEN_VIINP
argument_list|,
name|above
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|markidx
argument_list|(
name|m
argument_list|)
operator|>
literal|0
condition|)
block|{
name|m
operator|--
expr_stmt|;
block|}
name|doingdot
operator|=
name|wasdot
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|CRUNCH
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
if|if
condition|(
name|key
operator|==
literal|'i'
operator|&&
operator|*
name|o_inputmode
operator|&&
name|mode
operator|==
name|MODE_VI
condition|)
block|{
name|msg
argument_list|(
literal|"Now in command mode!  To return to input mode, hit<i>"
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
endif|#
directive|endif
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This starts input mode with some text deleted */
end_comment

begin_function
name|MARK
name|v_change
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* the range of text to change */
block|{
name|int
name|lnmode
decl_stmt|;
comment|/* is this a line-mode change? */
comment|/* swap them if they're in reverse order */
if|if
condition|(
name|m
operator|>
name|n
condition|)
block|{
name|MARK
name|tmp
decl_stmt|;
name|tmp
operator|=
name|m
expr_stmt|;
name|m
operator|=
name|n
expr_stmt|;
name|n
operator|=
name|tmp
expr_stmt|;
block|}
comment|/* for line mode, retain the last newline char */
name|lnmode
operator|=
operator|(
name|markidx
argument_list|(
name|m
argument_list|)
operator|==
literal|0
operator|&&
name|markidx
argument_list|(
name|n
argument_list|)
operator|==
literal|0
operator|&&
name|m
operator|!=
name|n
operator|)
expr_stmt|;
if|if
condition|(
name|lnmode
condition|)
block|{
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
name|pfetch
argument_list|(
name|markline
argument_list|(
name|n
argument_list|)
argument_list|)
expr_stmt|;
name|n
operator|=
operator|(
name|n
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
expr_stmt|;
block|}
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|m
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|WHEN_VIINP
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function replaces a given number of characters with input */
end_comment

begin_function
name|MARK
name|v_subst
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where substitutions start */
name|long
name|cnt
decl_stmt|;
comment|/* number of chars to replace */
block|{
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* make sure we don't try replacing past EOL */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|markidx
argument_list|(
name|m
argument_list|)
operator|+
name|cnt
operator|>
name|plen
condition|)
block|{
name|cnt
operator|=
name|plen
operator|-
name|markidx
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Go for it! */
name|ChangeText
block|{
name|cut
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|)
expr_stmt|;
name|m
operator|=
name|input
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|cnt
argument_list|,
name|WHEN_VIINP
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This calls the ex "join" command to join some lines together */
end_comment

begin_function
name|MARK
name|v_join
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* the first line to be joined */
name|long
name|cnt
decl_stmt|;
comment|/* number of other lines to join */
block|{
name|MARK
name|joint
decl_stmt|;
comment|/* where the lines were joined */
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* figure out where the joint will be */
name|pfetch
argument_list|(
name|markline
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|joint
operator|=
operator|(
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
operator|)
operator|+
name|plen
expr_stmt|;
comment|/* join the lines */
name|cmd_join
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|MARK_AT_LINE
argument_list|(
name|cnt
argument_list|)
argument_list|,
name|CMD_JOIN
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* the cursor should be left at the joint */
return|return
name|joint
return|;
block|}
end_function

begin_comment
comment|/* This calls the ex "<" command to shift some lines left */
end_comment

begin_function
name|MARK
name|v_lshift
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
block|{
comment|/* adjust for inclusive endmarks in ex */
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
name|cmd_shift
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|CMD_SHIFTL
argument_list|,
name|FALSE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This calls the ex ">" command to shift some lines right */
end_comment

begin_function
name|MARK
name|v_rshift
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
block|{
comment|/* adjust for inclusive endmarks in ex */
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
name|cmd_shift
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|CMD_SHIFTR
argument_list|,
name|FALSE
argument_list|,
operator|(
name|char
operator|*
operator|)
literal|0
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This filters some lines through a preset program, to reformat them */
end_comment

begin_function
name|MARK
name|v_reformat
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
block|{
comment|/* adjust for inclusive endmarks in ex */
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
comment|/* run the filter command */
name|filter
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|o_equalprg
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This runs some lines through a filter program */
end_comment

begin_function
name|MARK
name|v_filter
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* range of lines to shift */
block|{
name|char
name|cmdln
index|[
literal|150
index|]
decl_stmt|;
comment|/* a shell command line */
comment|/* adjust for inclusive endmarks in ex */
name|n
operator|-=
name|BLKSIZE
expr_stmt|;
if|if
condition|(
name|vgets
argument_list|(
literal|'!'
argument_list|,
name|cmdln
argument_list|,
sizeof|sizeof
argument_list|(
name|cmdln
argument_list|)
argument_list|)
operator|>
literal|0
condition|)
block|{
name|filter
argument_list|(
name|m
argument_list|,
name|n
argument_list|,
name|cmdln
argument_list|,
name|TRUE
argument_list|)
expr_stmt|;
block|}
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function runs the ex "file" command to show the file's status */
end_comment

begin_function
name|MARK
name|v_status
parameter_list|()
block|{
name|cmd_file
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|CMD_FILE
argument_list|,
literal|0
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function runs the ":&" command to repeat the previous :s// */
end_comment

begin_function
name|MARK
name|v_again
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
block|{
name|cmd_substitute
argument_list|(
name|m
argument_list|,
name|n
operator|-
name|BLKSIZE
argument_list|,
name|CMD_SUBAGAIN
argument_list|,
name|TRUE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function switches to the previous file, if possible */
end_comment

begin_function
name|MARK
name|v_switch
parameter_list|()
block|{
if|if
condition|(
operator|!
operator|*
name|prevorig
condition|)
name|msg
argument_list|(
literal|"No previous file"
argument_list|)
expr_stmt|;
else|else
block|{
name|strcpy
argument_list|(
name|tmpblk
operator|.
name|c
argument_list|,
name|prevorig
argument_list|)
expr_stmt|;
name|cmd_edit
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|CMD_EDIT
argument_list|,
literal|0
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|)
expr_stmt|;
block|}
return|return
name|cursor
return|;
block|}
end_function

begin_comment
comment|/* This function does a tag search on a keyword */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_tag
parameter_list|(
name|keyword
parameter_list|,
name|m
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|keyword
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
block|{
comment|/* move the cursor to the start of the tag name, where m is */
name|cursor
operator|=
name|m
expr_stmt|;
comment|/* perform the tag search */
name|cmd_tag
argument_list|(
name|cursor
argument_list|,
name|cursor
argument_list|,
name|CMD_TAG
argument_list|,
literal|0
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_EXTENSIONS
end_ifndef

begin_comment
comment|/* This function looks up a keyword by calling the helpprog program */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_keyword
parameter_list|(
name|keyword
parameter_list|,
name|m
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|keyword
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
block|{
name|int
name|waswarn
decl_stmt|;
name|char
name|cmdline
index|[
literal|130
index|]
decl_stmt|;
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|addstr
argument_list|(
literal|"---------------------------------------------------------\n"
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
name|refresh
argument_list|()
expr_stmt|;
name|sprintf
argument_list|(
name|cmdline
argument_list|,
literal|"%s %s"
argument_list|,
name|o_keywordprg
argument_list|,
name|keyword
argument_list|)
expr_stmt|;
name|waswarn
operator|=
operator|*
name|o_warn
expr_stmt|;
operator|*
name|o_warn
operator|=
name|FALSE
expr_stmt|;
name|suspend_curses
argument_list|()
expr_stmt|;
if|if
condition|(
name|system
argument_list|(
name|cmdline
argument_list|)
condition|)
block|{
name|addstr
argument_list|(
literal|"<<< failed>>>\n"
argument_list|)
expr_stmt|;
block|}
name|resume_curses
argument_list|(
name|FALSE
argument_list|)
expr_stmt|;
name|mode
operator|=
name|MODE_VI
expr_stmt|;
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
operator|*
name|o_warn
operator|=
name|waswarn
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_function
name|MARK
name|v_increment
parameter_list|(
name|keyword
parameter_list|,
name|m
parameter_list|,
name|cnt
parameter_list|)
name|char
modifier|*
name|keyword
decl_stmt|;
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
block|{
specifier|static
name|sign
expr_stmt|;
name|char
name|newval
index|[
literal|12
index|]
decl_stmt|;
name|long
name|atol
parameter_list|()
function_decl|;
name|DEFAULT
argument_list|(
literal|1
argument_list|)
expr_stmt|;
comment|/* get one more keystroke, unless doingdot */
if|if
condition|(
operator|!
name|doingdot
condition|)
block|{
name|sign
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
comment|/* adjust the number, based on that second keystroke */
switch|switch
condition|(
name|sign
condition|)
block|{
case|case
literal|'+'
case|:
case|case
literal|'#'
case|:
name|cnt
operator|=
name|atol
argument_list|(
name|keyword
argument_list|)
operator|+
name|cnt
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
name|cnt
operator|=
name|atol
argument_list|(
name|keyword
argument_list|)
operator|-
name|cnt
expr_stmt|;
break|break;
case|case
literal|'='
case|:
break|break;
default|default:
return|return
name|MARK_UNSET
return|;
block|}
name|sprintf
argument_list|(
name|newval
argument_list|,
literal|"%ld"
argument_list|,
name|cnt
argument_list|)
expr_stmt|;
name|ChangeText
block|{
name|change
argument_list|(
name|m
argument_list|,
name|m
operator|+
name|strlen
argument_list|(
name|keyword
argument_list|)
argument_list|,
name|newval
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* This function acts like the EX command "xit" */
end_comment

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_xit
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* ignored */
name|long
name|cnt
decl_stmt|;
comment|/* ignored */
name|int
name|key
decl_stmt|;
comment|/* must be a second 'Z' */
block|{
comment|/* if second char wasn't 'Z', fail */
if|if
condition|(
name|key
operator|!=
literal|'Z'
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* move the cursor to the bottom of the screen */
name|move
argument_list|(
name|LINES
operator|-
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|clrtoeol
argument_list|()
expr_stmt|;
comment|/* do the xit command */
name|cmd_xit
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|CMD_XIT
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
comment|/* return the cursor */
return|return
name|m
return|;
block|}
end_function

begin_comment
comment|/* This function undoes changes to a single line, if possible */
end_comment

begin_function
name|MARK
name|v_undoline
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* where we hope to undo the change */
block|{
comment|/* make sure we have the right line in the buffer */
if|if
condition|(
name|markline
argument_list|(
name|m
argument_list|)
operator|!=
name|U_line
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
comment|/* fix it */
name|ChangeText
block|{
name|strcat
argument_list|(
name|U_text
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
name|change
argument_list|(
name|MARK_AT_LINE
argument_list|(
name|U_line
argument_list|)
argument_list|,
name|MARK_AT_LINE
argument_list|(
name|U_line
operator|+
literal|1
argument_list|)
argument_list|,
name|U_text
argument_list|)
expr_stmt|;
block|}
comment|/* nothing in the buffer anymore */
name|U_line
operator|=
operator|-
literal|1L
expr_stmt|;
comment|/* return, with the cursor at the front of the line */
return|return
name|m
operator|&
operator|~
operator|(
name|BLKSIZE
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_ifndef
ifndef|#
directive|ifndef
name|NO_ERRLIST
end_ifndef

begin_function
name|MARK
name|v_errlist
parameter_list|(
name|m
parameter_list|)
name|MARK
name|m
decl_stmt|;
block|{
name|cmd_errlist
argument_list|(
name|m
argument_list|,
name|m
argument_list|,
name|CMD_ERRLIST
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_AT
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_at
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|key
parameter_list|)
name|MARK
name|m
decl_stmt|;
name|long
name|cnt
decl_stmt|;
name|int
name|key
decl_stmt|;
block|{
name|int
name|size
decl_stmt|;
name|size
operator|=
name|cb2str
argument_list|(
name|key
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|BLKSIZE
argument_list|)
expr_stmt|;
if|if
condition|(
name|size
operator|<=
literal|0
operator|||
name|size
operator|==
name|BLKSIZE
condition|)
block|{
return|return
name|MARK_UNSET
return|;
block|}
name|execmap
argument_list|(
literal|0
argument_list|,
name|tmpblk
operator|.
name|c
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|cursor
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|SIGTSTP
end_ifdef

begin_function
name|MARK
name|v_suspend
parameter_list|()
block|{
name|cmd_suspend
argument_list|(
name|MARK_UNSET
argument_list|,
name|MARK_UNSET
argument_list|,
name|CMD_SUSPEND
argument_list|,
name|FALSE
argument_list|,
literal|""
argument_list|)
expr_stmt|;
return|return
name|MARK_UNSET
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_VISIBLE
end_ifndef

begin_comment
comment|/*ARGSUSED*/
end_comment

begin_function
name|MARK
name|v_start
parameter_list|(
name|m
parameter_list|,
name|cnt
parameter_list|,
name|cmd
parameter_list|)
name|MARK
name|m
decl_stmt|;
comment|/* starting point for a v or V command */
name|long
name|cnt
decl_stmt|;
comment|/* ignored */
name|int
name|cmd
decl_stmt|;
comment|/* either 'v' or 'V' */
block|{
if|if
condition|(
name|V_from
condition|)
block|{
name|V_from
operator|=
name|MARK_UNSET
expr_stmt|;
block|}
else|else
block|{
name|V_from
operator|=
name|m
expr_stmt|;
name|V_linemd
operator|=
name|isupper
argument_list|(
name|cmd
argument_list|)
expr_stmt|;
block|}
return|return
name|m
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|NO_POPUP
end_ifndef

begin_define
define|#
directive|define
name|MENU_HEIGHT
value|11
end_define

begin_define
define|#
directive|define
name|MENU_WIDTH
value|23
end_define

begin_function
name|MARK
name|v_popup
parameter_list|(
name|m
parameter_list|,
name|n
parameter_list|)
name|MARK
name|m
decl_stmt|,
name|n
decl_stmt|;
comment|/* the range of text to change */
block|{
name|int
name|i
decl_stmt|;
name|int
name|y
decl_stmt|,
name|x
decl_stmt|;
comment|/* position where the window will pop up at */
name|int
name|key
decl_stmt|;
comment|/* keystroke from the user */
name|int
name|sel
decl_stmt|;
comment|/* index of the selected operation */
specifier|static
name|int
name|dfltsel
decl_stmt|;
comment|/* default value of sel */
specifier|static
name|char
modifier|*
name|labels
index|[
literal|11
index|]
init|=
block|{
literal|"ESC cancel!         "
block|,
literal|" d  delete (cut)    "
block|,
literal|" y  yank (copy)     "
block|,
literal|" p  paste after     "
block|,
literal|" P  paste before    "
block|,
literal|">  more indented   "
block|,
literal|"<  less indented   "
block|,
literal|" =  reformat        "
block|,
literal|" !  external filter "
block|,
literal|" ZZ save& exit     "
block|,
literal|" u  undo previous   "
block|}
decl_stmt|;
comment|/* try to position the menu near the cursor */
name|x
operator|=
name|physcol
operator|-
operator|(
name|MENU_WIDTH
operator|/
literal|2
operator|)
expr_stmt|;
if|if
condition|(
name|x
operator|<
literal|0
condition|)
name|x
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|x
operator|+
name|MENU_WIDTH
operator|+
literal|2
operator|>
name|COLS
condition|)
name|x
operator|=
name|COLS
operator|-
name|MENU_WIDTH
operator|-
literal|2
expr_stmt|;
if|if
condition|(
name|markline
argument_list|(
name|cursor
argument_list|)
operator|<
name|topline
operator|||
name|markline
argument_list|(
name|cursor
argument_list|)
operator|>
name|botline
condition|)
name|y
operator|=
literal|0
expr_stmt|;
elseif|else
if|if
condition|(
name|markline
argument_list|(
name|cursor
argument_list|)
operator|+
literal|1L
operator|+
name|MENU_HEIGHT
operator|>
name|botline
condition|)
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
operator|-
name|topline
argument_list|)
operator|-
name|MENU_HEIGHT
expr_stmt|;
else|else
name|y
operator|=
call|(
name|int
call|)
argument_list|(
name|markline
argument_list|(
name|cursor
argument_list|)
operator|-
name|topline
argument_list|)
operator|+
literal|1L
expr_stmt|;
comment|/* draw the menu */
for|for
control|(
name|sel
operator|=
literal|0
init|;
name|sel
operator|<
name|MENU_HEIGHT
condition|;
name|sel
operator|++
control|)
block|{
name|move
argument_list|(
name|y
operator|+
name|sel
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|do_POPUP
argument_list|()
expr_stmt|;
if|if
condition|(
name|sel
operator|==
name|dfltsel
condition|)
name|qaddstr
argument_list|(
literal|"-->"
argument_list|)
expr_stmt|;
else|else
name|qaddstr
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|labels
index|[
name|sel
index|]
argument_list|)
expr_stmt|;
name|do_SE
argument_list|()
expr_stmt|;
block|}
comment|/* get a selection */
name|move
argument_list|(
name|y
operator|+
name|dfltsel
argument_list|,
name|x
operator|+
literal|4
argument_list|)
expr_stmt|;
for|for
control|(
name|sel
operator|=
name|dfltsel
init|;
operator|(
name|key
operator|=
name|getkey
argument_list|(
name|WHEN_POPUP
argument_list|)
operator|)
operator|!=
literal|'\\'
operator|&&
name|key
operator|!=
literal|'\r'
condition|;
control|)
block|{
comment|/* erase the selection arrow */
name|move
argument_list|(
name|y
operator|+
name|sel
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|do_POPUP
argument_list|()
expr_stmt|;
name|qaddstr
argument_list|(
literal|"   "
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|labels
index|[
name|sel
index|]
argument_list|)
expr_stmt|;
name|do_SE
argument_list|()
expr_stmt|;
comment|/* process the user's keystroke */
if|if
condition|(
name|key
operator|==
literal|'j'
operator|&&
name|sel
operator|<
name|MENU_HEIGHT
operator|-
literal|1
condition|)
block|{
name|sel
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|'k'
operator|&&
name|sel
operator|>
literal|0
condition|)
block|{
name|sel
operator|--
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|key
operator|==
literal|'\033'
condition|)
block|{
name|sel
operator|=
literal|0
expr_stmt|;
break|break;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|MENU_HEIGHT
operator|&&
name|labels
index|[
name|i
index|]
index|[
literal|1
index|]
operator|!=
name|key
condition|;
name|i
operator|++
control|)
block|{ 			}
if|if
condition|(
name|i
operator|<
name|MENU_HEIGHT
condition|)
block|{
name|sel
operator|=
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* redraw the arrow, possibly in a new place */
name|move
argument_list|(
name|y
operator|+
name|sel
argument_list|,
name|x
argument_list|)
expr_stmt|;
name|do_POPUP
argument_list|()
expr_stmt|;
name|qaddstr
argument_list|(
literal|"-->"
argument_list|)
expr_stmt|;
name|qaddstr
argument_list|(
name|labels
index|[
name|sel
index|]
argument_list|)
expr_stmt|;
name|do_SE
argument_list|()
expr_stmt|;
name|move
argument_list|(
name|y
operator|+
name|sel
argument_list|,
name|x
operator|+
literal|4
argument_list|)
expr_stmt|;
block|}
comment|/* in most cases, the default selection is "paste after" */
name|dfltsel
operator|=
literal|3
expr_stmt|;
comment|/* perform the appropriate action */
switch|switch
condition|(
name|sel
condition|)
block|{
case|case
literal|0
case|:
name|m
operator|=
name|cursor
expr_stmt|;
name|dfltsel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|1
case|:
comment|/* delete (cut) */
name|m
operator|=
name|v_delete
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|2
case|:
comment|/* yank (copy) */
name|m
operator|=
name|v_yank
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
break|break;
case|case
literal|3
case|:
comment|/* paste after */
name|m
operator|=
name|v_paste
argument_list|(
name|n
argument_list|,
literal|1L
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
break|break;
case|case
literal|4
case|:
comment|/* paste before */
name|m
operator|=
name|v_paste
argument_list|(
name|m
argument_list|,
literal|1L
argument_list|,
literal|'P'
argument_list|)
expr_stmt|;
name|dfltsel
operator|=
literal|4
expr_stmt|;
break|break;
case|case
literal|5
case|:
comment|/* more indented */
name|m
operator|=
name|v_rshift
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dfltsel
operator|=
literal|5
expr_stmt|;
break|break;
case|case
literal|6
case|:
comment|/* less indented */
name|m
operator|=
name|v_lshift
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dfltsel
operator|=
literal|6
expr_stmt|;
break|break;
case|case
literal|7
case|:
comment|/* reformat */
name|m
operator|=
name|v_reformat
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dfltsel
operator|=
literal|7
expr_stmt|;
break|break;
case|case
literal|8
case|:
comment|/* external filter */
name|m
operator|=
name|v_filter
argument_list|(
name|m
argument_list|,
name|n
argument_list|)
expr_stmt|;
name|dfltsel
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|9
case|:
comment|/* save& exit */
comment|/* get confirmation first */
do|do
block|{
name|key
operator|=
name|getkey
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
do|while
condition|(
name|key
operator|!=
literal|'\\'
operator|&&
name|key
operator|!=
literal|'Z'
operator|&&
name|key
operator|!=
literal|'\r'
comment|/* good */
operator|&&
name|key
operator|!=
literal|'\033'
condition|)
do|;
comment|/* bad  */
if|if
condition|(
name|key
operator|!=
literal|'\033'
condition|)
block|{
name|m
operator|=
name|v_xit
argument_list|(
name|m
argument_list|,
literal|0L
argument_list|,
literal|'Z'
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
comment|/* undo previous */
name|m
operator|=
name|v_undo
argument_list|(
name|m
argument_list|)
expr_stmt|;
name|dfltsel
operator|=
literal|9
expr_stmt|;
break|break;
block|}
comment|/* arrange for the menu to be erased (except that "chg from kbd" 	 * already erased it, and "save& exit" doesn't care) 	 */
if|if
condition|(
name|sel
operator|!=
literal|5
operator|&&
name|sel
operator|!=
literal|9
condition|)
name|redraw
argument_list|(
name|MARK_UNSET
argument_list|,
name|FALSE
argument_list|)
expr_stmt|;
return|return
name|m
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* undef NO_POPUP */
end_comment

end_unit

