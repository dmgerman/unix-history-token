begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * top - a top users display for Unix  *  * SYNOPSIS:  For FreeBSD-2.x and later  *  * DESCRIPTION:  * Originally written for BSD4.4 system by Christos Zoulas.  * Ported to FreeBSD 2.x by Steven Wallace&& Wolfram Schneider  * Order support hacked in from top-3.5beta6/machine/m_aix41.c  *   by Monte Mitzelfelt (for latest top see http://www.groupsys.com/topinfo/)  *  * This is the machine-dependent module for FreeBSD 2.2  * Works for:  *	FreeBSD 2.2.x, 3.x, 4.x, and probably FreeBSD 2.1.x  *  * LIBS: -lkvm  *  * AUTHOR:  Christos Zoulas<christos@ee.cornell.edu>  *          Steven Wallace<swallace@freebsd.org>  *          Wolfram Schneider<wosch@FreeBSD.org>  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_comment
comment|/* Swap */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<osreldate.h>
end_include

begin_comment
comment|/* for changes in kernel structures */
end_comment

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|check_nlist
name|__P
argument_list|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getkval
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|printable
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swapmode
name|__P
argument_list|(
operator|(
name|int
operator|*
name|retavail
operator|,
name|int
operator|*
name|retfree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|smpmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|namelength
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmdlength
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* get_process_info passes back a handle.  This is what it looks like: */
end_comment

begin_struct
struct|struct
name|handle
block|{
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|next_proc
decl_stmt|;
comment|/* points to next valid proc pointer */
name|int
name|remaining
decl_stmt|;
comment|/* number of pointers remaining */
block|}
struct|;
end_struct

begin_comment
comment|/* declarations for load_avg */
end_comment

begin_include
include|#
directive|include
file|"loadavg.h"
end_include

begin_define
define|#
directive|define
name|PP
parameter_list|(
name|pp
parameter_list|,
name|field
parameter_list|)
value|((pp)->kp_proc . field)
end_define

begin_define
define|#
directive|define
name|EP
parameter_list|(
name|pp
parameter_list|,
name|field
parameter_list|)
value|((pp)->kp_eproc . field)
end_define

begin_define
define|#
directive|define
name|VP
parameter_list|(
name|pp
parameter_list|,
name|field
parameter_list|)
value|((pp)->kp_eproc.e_vm . field)
end_define

begin_comment
comment|/* define what weighted cpu is.  */
end_comment

begin_define
define|#
directive|define
name|weighted_cpu
parameter_list|(
name|pct
parameter_list|,
name|pp
parameter_list|)
value|(PP((pp), p_swtime) == 0 ? 0.0 : \ 			 ((pct) / (1.0 - exp(PP((pp), p_swtime) * logcpu))))
end_define

begin_comment
comment|/* what we consider to be process size: */
end_comment

begin_define
define|#
directive|define
name|PROCSIZE
parameter_list|(
name|pp
parameter_list|)
value|(VP((pp), vm_map.size) / 1024)
end_define

begin_comment
comment|/* definitions for indices in the nlist array */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nlst
index|[]
init|=
block|{
define|#
directive|define
name|X_CCPU
value|0
block|{
literal|"_ccpu"
block|}
block|,
define|#
directive|define
name|X_CP_TIME
value|1
block|{
literal|"_cp_time"
block|}
block|,
define|#
directive|define
name|X_AVENRUN
value|2
block|{
literal|"_averunnable"
block|}
block|,
define|#
directive|define
name|X_BUFSPACE
value|3
block|{
literal|"_bufspace"
block|}
block|,
comment|/* K in buffer cache */
define|#
directive|define
name|X_CNT
value|4
block|{
literal|"_cnt"
block|}
block|,
comment|/* struct vmmeter cnt */
comment|/* Last pid */
define|#
directive|define
name|X_LASTPID
value|5
block|{
literal|"_nextpid"
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  These definitions control the format of the per-process area  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|smp_header
index|[]
init|=
literal|"  PID %-*.*s PRI NICE  SIZE    RES STATE  C   TIME   WCPU    CPU COMMAND"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|smp_Proc_format
define|\
value|"%5d %-*.*s %3d %3d%7s %6s %-6.6s %1x%7s %5.2f%% %5.2f%% %.*s"
end_define

begin_decl_stmt
specifier|static
name|char
name|up_header
index|[]
init|=
literal|"  PID %-*.*s PRI NICE  SIZE    RES STATE    TIME   WCPU    CPU COMMAND"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|up_Proc_format
define|\
value|"%5d %-*.*s %3d %3d%7s %6s %-6.6s%.0d%7s %5.2f%% %5.2f%% %.*s"
end_define

begin_comment
comment|/* process state names for the "STATE" column of the display */
end_comment

begin_comment
comment|/* the extra nulls in the string "run" are for adding a slash and    the processor number when needed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|state_abbrev
index|[]
init|=
block|{
literal|""
block|,
literal|"START"
block|,
literal|"RUN\0\0\0"
block|,
literal|"SLEEP"
block|,
literal|"STOP"
block|,
literal|"ZOMB"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kvm_t
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* values that we stash away in _init and use in later routines */
end_comment

begin_decl_stmt
specifier|static
name|double
name|logcpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are retrieved from the kernel in _init */
end_comment

begin_decl_stmt
specifier|static
name|load_avg
name|ccpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are offsets obtained via nlist and used in the get_ functions */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cp_time_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|avenrun_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|lastpid_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|lastpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cnt_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|bufspace_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for calculating cpu state percentages */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cp_time
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cp_old
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cp_diff
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the process states */
end_comment

begin_decl_stmt
name|int
name|process_states
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|procstatenames
index|[]
init|=
block|{
literal|""
block|,
literal|" starting, "
block|,
literal|" running, "
block|,
literal|" sleeping, "
block|,
literal|" stopped, "
block|,
literal|" zombie, "
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the cpu states */
end_comment

begin_decl_stmt
name|int
name|cpu_states
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cpustatenames
index|[]
init|=
block|{
literal|"user"
block|,
literal|"nice"
block|,
literal|"system"
block|,
literal|"interrupt"
block|,
literal|"idle"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the memory statistics */
end_comment

begin_decl_stmt
name|int
name|memory_stats
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|memorynames
index|[]
init|=
block|{
literal|"K Active, "
block|,
literal|"K Inact, "
block|,
literal|"K Wired, "
block|,
literal|"K Cache, "
block|,
literal|"K Buf, "
block|,
literal|"K Free"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap_stats
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|swapnames
index|[]
init|=
block|{
comment|/*   0           1            2           3            4       5 */
literal|"K Total, "
block|,
literal|"K Used, "
block|,
literal|"K Free, "
block|,
literal|"% Inuse, "
block|,
literal|"K In, "
block|,
literal|"K Out"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for keeping track of the proc array */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|onproc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pref_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|pbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|pref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for getting the memory statistics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pageshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log base 2 of the pagesize */
end_comment

begin_comment
comment|/* define pagetok in terms of pageshift */
end_comment

begin_define
define|#
directive|define
name|pagetok
parameter_list|(
name|size
parameter_list|)
value|((size)<< pageshift)
end_define

begin_comment
comment|/* useful externals */
end_comment

begin_function_decl
name|long
name|percentages
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ORDER
end_ifdef

begin_comment
comment|/* sorting orders. first is default */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ordernames
index|[]
init|=
block|{
literal|"cpu"
block|,
literal|"size"
block|,
literal|"res"
block|,
literal|"time"
block|,
literal|"pri"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function
name|int
name|machine_init
parameter_list|(
name|statics
parameter_list|)
name|struct
name|statics
modifier|*
name|statics
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|pagesize
decl_stmt|;
name|size_t
name|modelen
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|modelen
operator|=
sizeof|sizeof
argument_list|(
name|smpmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sysctlbyname
argument_list|(
literal|"machdep.smp_active"
argument_list|,
operator|&
name|smpmode
argument_list|,
operator|&
name|modelen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|&&
name|sysctlbyname
argument_list|(
literal|"smp.smp_active"
argument_list|,
operator|&
name|smpmode
argument_list|,
operator|&
name|modelen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|<
literal|0
operator|)
operator|||
name|modelen
operator|!=
sizeof|sizeof
argument_list|(
name|smpmode
argument_list|)
condition|)
name|smpmode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
operator|>
name|namelength
condition|)
name|namelength
operator|=
name|strlen
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|namelength
operator|<
literal|8
condition|)
name|namelength
operator|=
literal|8
expr_stmt|;
if|if
condition|(
name|smpmode
operator|&&
name|namelength
operator|>
literal|13
condition|)
name|namelength
operator|=
literal|13
expr_stmt|;
elseif|else
if|if
condition|(
name|namelength
operator|>
literal|15
condition|)
name|namelength
operator|=
literal|15
expr_stmt|;
if|if
condition|(
operator|(
name|kd
operator|=
name|kvm_open
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|O_RDONLY
argument_list|,
literal|"kvm_open"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* get the list of symbols we want to access in the kernel */
operator|(
name|void
operator|)
name|kvm_nlist
argument_list|(
name|kd
argument_list|,
name|nlst
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlst
index|[
literal|0
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: nlist failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure they were all found */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|check_nlist
argument_list|(
name|nlst
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|nlst
index|[
name|X_CCPU
index|]
operator|.
name|n_value
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|ccpu
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ccpu
argument_list|)
argument_list|,
name|nlst
index|[
name|X_CCPU
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
comment|/* stash away certain offsets for later use */
name|cp_time_offset
operator|=
name|nlst
index|[
name|X_CP_TIME
index|]
operator|.
name|n_value
expr_stmt|;
name|avenrun_offset
operator|=
name|nlst
index|[
name|X_AVENRUN
index|]
operator|.
name|n_value
expr_stmt|;
name|lastpid_offset
operator|=
name|nlst
index|[
name|X_LASTPID
index|]
operator|.
name|n_value
expr_stmt|;
name|cnt_offset
operator|=
name|nlst
index|[
name|X_CNT
index|]
operator|.
name|n_value
expr_stmt|;
name|bufspace_offset
operator|=
name|nlst
index|[
name|X_BUFSPACE
index|]
operator|.
name|n_value
expr_stmt|;
comment|/* this is used in calculating WCPU -- calculate it ahead of time */
name|logcpu
operator|=
name|log
argument_list|(
name|loaddouble
argument_list|(
name|ccpu
argument_list|)
argument_list|)
expr_stmt|;
name|pbase
operator|=
name|NULL
expr_stmt|;
name|pref
operator|=
name|NULL
expr_stmt|;
name|nproc
operator|=
literal|0
expr_stmt|;
name|onproc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* get the page size with "getpagesize" and calculate pageshift from it */
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|pageshift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pagesize
operator|>
literal|1
condition|)
block|{
name|pageshift
operator|++
expr_stmt|;
name|pagesize
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* we only need the amount of log(2)1024 for our conversion */
name|pageshift
operator|-=
name|LOG1024
expr_stmt|;
comment|/* fill in the statics information */
name|statics
operator|->
name|procstate_names
operator|=
name|procstatenames
expr_stmt|;
name|statics
operator|->
name|cpustate_names
operator|=
name|cpustatenames
expr_stmt|;
name|statics
operator|->
name|memory_names
operator|=
name|memorynames
expr_stmt|;
name|statics
operator|->
name|swap_names
operator|=
name|swapnames
expr_stmt|;
ifdef|#
directive|ifdef
name|ORDER
name|statics
operator|->
name|order_names
operator|=
name|ordernames
expr_stmt|;
endif|#
directive|endif
comment|/* all done! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|format_header
parameter_list|(
name|uname_field
parameter_list|)
specifier|register
name|char
modifier|*
name|uname_field
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
specifier|static
name|char
name|Header
index|[
literal|128
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
argument_list|,
name|smpmode
condition|?
name|smp_header
else|:
name|up_header
argument_list|,
name|namelength
argument_list|,
name|namelength
argument_list|,
name|uname_field
argument_list|)
expr_stmt|;
name|cmdlength
operator|=
literal|80
operator|-
name|strlen
argument_list|(
name|Header
argument_list|)
operator|+
literal|6
expr_stmt|;
return|return
name|Header
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|swappgsin
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swappgsout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|timeout
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|get_system_info
parameter_list|(
name|si
parameter_list|)
name|struct
name|system_info
modifier|*
name|si
decl_stmt|;
block|{
name|long
name|total
decl_stmt|;
name|load_avg
name|avenrun
index|[
literal|3
index|]
decl_stmt|;
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timeval
name|boottime
decl_stmt|;
name|size_t
name|bt_size
decl_stmt|;
comment|/* get the cp_time array */
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|cp_time_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
name|cp_time
argument_list|,
sizeof|sizeof
argument_list|(
name|cp_time
argument_list|)
argument_list|,
name|nlst
index|[
name|X_CP_TIME
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|avenrun_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
name|avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
argument_list|,
name|nlst
index|[
name|X_AVENRUN
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|lastpid_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|lastpid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|lastpid
argument_list|)
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
comment|/* convert load averages to doubles */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|double
modifier|*
name|infoloadp
decl_stmt|;
name|load_avg
modifier|*
name|avenrunp
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|loadavg
name|sysload
decl_stmt|;
name|int
name|size
decl_stmt|;
name|getkerninfo
argument_list|(
name|KINFO_LOADAVG
argument_list|,
operator|&
name|sysload
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|infoloadp
operator|=
name|si
operator|->
name|load_avg
expr_stmt|;
name|avenrunp
operator|=
name|avenrun
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|notyet
operator|*
name|infoloadp
operator|++
operator|=
operator|(
operator|(
name|double
operator|)
name|sysload
operator|.
name|ldavg
index|[
name|i
index|]
operator|)
operator|/
name|sysload
operator|.
name|fscale
expr_stmt|;
endif|#
directive|endif
operator|*
name|infoloadp
operator|++
operator|=
name|loaddouble
argument_list|(
operator|*
name|avenrunp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* convert cp_time counts to percentages */
name|total
operator|=
name|percentages
argument_list|(
name|CPUSTATES
argument_list|,
name|cpu_states
argument_list|,
name|cp_time
argument_list|,
name|cp_old
argument_list|,
name|cp_diff
argument_list|)
expr_stmt|;
comment|/* sum memory& swap statistics */
block|{
name|struct
name|vmmeter
name|sum
decl_stmt|;
specifier|static
name|unsigned
name|int
name|swap_delay
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|swapavail
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|swapfree
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufspace
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|cnt_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|sum
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|,
literal|"_cnt"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|bufspace_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|bufspace
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bufspace
argument_list|)
argument_list|,
literal|"_bufspace"
argument_list|)
expr_stmt|;
comment|/* convert memory stats to Kbytes */
name|memory_stats
index|[
literal|0
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_active_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|1
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_inactive_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|2
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_wire_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|3
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_cache_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|4
index|]
operator|=
name|bufspace
operator|/
literal|1024
expr_stmt|;
name|memory_stats
index|[
literal|5
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|6
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* first interval */
if|if
condition|(
name|swappgsin
operator|<
literal|0
condition|)
block|{
name|swap_stats
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|swap_stats
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* compute differences between old and new swap statistic */
else|else
block|{
name|swap_stats
index|[
literal|4
index|]
operator|=
name|pagetok
argument_list|(
operator|(
operator|(
name|sum
operator|.
name|v_swappgsin
operator|-
name|swappgsin
operator|)
operator|)
argument_list|)
expr_stmt|;
name|swap_stats
index|[
literal|5
index|]
operator|=
name|pagetok
argument_list|(
operator|(
operator|(
name|sum
operator|.
name|v_swappgsout
operator|-
name|swappgsout
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|swappgsin
operator|=
name|sum
operator|.
name|v_swappgsin
expr_stmt|;
name|swappgsout
operator|=
name|sum
operator|.
name|v_swappgsout
expr_stmt|;
comment|/* call CPU heavy swapmode() only for changes */
if|if
condition|(
name|swap_stats
index|[
literal|4
index|]
operator|>
literal|0
operator|||
name|swap_stats
index|[
literal|5
index|]
operator|>
literal|0
operator|||
name|swap_delay
operator|==
literal|0
condition|)
block|{
name|swap_stats
index|[
literal|3
index|]
operator|=
name|swapmode
argument_list|(
operator|&
name|swapavail
argument_list|,
operator|&
name|swapfree
argument_list|)
expr_stmt|;
name|swap_stats
index|[
literal|0
index|]
operator|=
name|swapavail
expr_stmt|;
name|swap_stats
index|[
literal|1
index|]
operator|=
name|swapavail
operator|-
name|swapfree
expr_stmt|;
name|swap_stats
index|[
literal|2
index|]
operator|=
name|swapfree
expr_stmt|;
block|}
name|swap_delay
operator|=
literal|1
expr_stmt|;
name|swap_stats
index|[
literal|6
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* set arrays and strings */
name|si
operator|->
name|cpustates
operator|=
name|cpu_states
expr_stmt|;
name|si
operator|->
name|memory
operator|=
name|memory_stats
expr_stmt|;
name|si
operator|->
name|swap
operator|=
name|swap_stats
expr_stmt|;
if|if
condition|(
name|lastpid
operator|>
literal|0
condition|)
block|{
name|si
operator|->
name|last_pid
operator|=
name|lastpid
expr_stmt|;
block|}
else|else
block|{
name|si
operator|->
name|last_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/*      * Print how long system has been up.      * (Found by looking getting "boottime" from the kernel)      */
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_BOOTTIME
expr_stmt|;
name|bt_size
operator|=
sizeof|sizeof
argument_list|(
name|boottime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|boottime
argument_list|,
operator|&
name|bt_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|boottime
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
block|{
name|si
operator|->
name|boottime
operator|=
name|boottime
expr_stmt|;
block|}
else|else
block|{
name|si
operator|->
name|boottime
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|handle
name|handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|get_process_info
argument_list|(
name|si
argument_list|,
name|sel
argument_list|,
name|compare
argument_list|)
decl|struct
name|system_info
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|process_select
modifier|*
name|sel
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|total_procs
decl_stmt|;
specifier|register
name|int
name|active_procs
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|prefp
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
comment|/* these are copied out of sel for speed */
name|int
name|show_idle
decl_stmt|;
name|int
name|show_self
decl_stmt|;
name|int
name|show_system
decl_stmt|;
name|int
name|show_uid
decl_stmt|;
name|int
name|show_command
decl_stmt|;
name|pbase
operator|=
name|kvm_getprocs
argument_list|(
name|kd
argument_list|,
name|KERN_PROC_ALL
argument_list|,
literal|0
argument_list|,
operator|&
name|nproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nproc
operator|>
name|onproc
condition|)
name|pref
operator|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|pref
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
operator|*
argument_list|)
operator|*
operator|(
name|onproc
operator|=
name|nproc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pref
operator|==
name|NULL
operator|||
name|pbase
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: Out of memory.\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
comment|/* get a pointer to the states summary array */
name|si
operator|->
name|procstates
operator|=
name|process_states
expr_stmt|;
comment|/* set up flags which define what we are going to select */
name|show_idle
operator|=
name|sel
operator|->
name|idle
expr_stmt|;
name|show_self
operator|=
name|sel
operator|->
name|self
expr_stmt|;
name|show_system
operator|=
name|sel
operator|->
name|system
expr_stmt|;
name|show_uid
operator|=
name|sel
operator|->
name|uid
operator|!=
operator|-
literal|1
expr_stmt|;
name|show_command
operator|=
name|sel
operator|->
name|command
operator|!=
name|NULL
expr_stmt|;
comment|/* count up process states and get pointers to interesting procs */
name|total_procs
operator|=
literal|0
expr_stmt|;
name|active_procs
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|process_states
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|process_states
argument_list|)
argument_list|)
expr_stmt|;
name|prefp
operator|=
name|pref
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pbase
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nproc
condition|;
name|pp
operator|++
operator|,
name|i
operator|++
control|)
block|{
comment|/* 	 *  Place pointers to each valid proc structure in pref[]. 	 *  Process slots that are actually in use have a non-zero 	 *  status field.  Processes with P_SYSTEM set are system 	 *  processes---these get ignored unless show_sysprocs is set. 	 */
if|if
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|show_self
operator|!=
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pid
argument_list|)
operator|)
operator|&&
operator|(
name|show_system
operator|||
operator|(
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_flag
argument_list|)
operator|&
name|P_SYSTEM
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|total_procs
operator|++
expr_stmt|;
name|process_states
index|[
operator|(
name|unsigned
name|char
operator|)
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
operator|!=
name|SZOMB
operator|)
operator|&&
operator|(
name|show_idle
operator|||
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pctcpu
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
operator|==
name|SRUN
operator|)
operator|)
operator|&&
operator|(
operator|!
name|show_uid
operator|||
name|EP
argument_list|(
name|pp
argument_list|,
name|e_pcred
operator|.
name|p_ruid
argument_list|)
operator|==
operator|(
name|uid_t
operator|)
name|sel
operator|->
name|uid
operator|)
condition|)
block|{
operator|*
name|prefp
operator|++
operator|=
name|pp
expr_stmt|;
name|active_procs
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* if requested, sort the "interesting" processes */
if|if
condition|(
name|compare
operator|!=
name|NULL
condition|)
block|{
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pref
argument_list|,
name|active_procs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
operator|*
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
block|}
comment|/* remember active and total counts */
name|si
operator|->
name|p_total
operator|=
name|total_procs
expr_stmt|;
name|si
operator|->
name|p_active
operator|=
name|pref_len
operator|=
name|active_procs
expr_stmt|;
comment|/* pass back a handle */
name|handle
operator|.
name|next_proc
operator|=
name|pref
expr_stmt|;
name|handle
operator|.
name|remaining
operator|=
name|active_procs
expr_stmt|;
return|return
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|handle
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|fmt
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static area where result is built */
end_comment

begin_function
name|char
modifier|*
name|format_next_process
parameter_list|(
name|handle
parameter_list|,
name|get_userid
parameter_list|)
name|caddr_t
name|handle
decl_stmt|;
function|char *
parameter_list|(
function|*get_userid
end_function

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|long
name|cputime
decl_stmt|;
specifier|register
name|double
name|pct
decl_stmt|;
name|struct
name|handle
modifier|*
name|hp
decl_stmt|;
name|char
name|status
index|[
literal|16
index|]
decl_stmt|;
name|int
name|state
decl_stmt|;
comment|/* find and remember the next proc structure */
name|hp
operator|=
operator|(
expr|struct
name|handle
operator|*
operator|)
name|handle
expr_stmt|;
name|pp
operator|=
operator|*
operator|(
name|hp
operator|->
name|next_proc
operator|++
operator|)
expr_stmt|;
name|hp
operator|->
name|remaining
operator|--
expr_stmt|;
comment|/* get the process's command name */
if|if
condition|(
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_flag
argument_list|)
operator|&
name|P_INMEM
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Print swapped processes as<pname> 	 */
name|char
modifier|*
name|comm
init|=
name|PP
argument_list|(
name|pp
argument_list|,
name|p_comm
argument_list|)
decl_stmt|;
define|#
directive|define
name|COMSIZ
value|sizeof(PP(pp, p_comm))
name|char
name|buf
index|[
name|COMSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|comm
argument_list|,
name|COMSIZ
argument_list|)
expr_stmt|;
name|comm
index|[
literal|0
index|]
operator|=
literal|'<'
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|&
name|comm
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|COMSIZ
operator|-
literal|2
argument_list|)
expr_stmt|;
name|comm
index|[
name|COMSIZ
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|comm
argument_list|,
literal|">"
argument_list|,
name|COMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|comm
index|[
name|COMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/*      * Convert the process's runtime from microseconds to seconds.  This      * time includes the interrupt time although that is not wanted here.      * ps(1) is similarly sloppy.      */
name|cputime
operator|=
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_runtime
argument_list|)
operator|+
literal|500000
operator|)
operator|/
literal|1000000
expr_stmt|;
comment|/* calculate the base for cpu percentages */
name|pct
operator|=
name|pctdouble
argument_list|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pctcpu
argument_list|)
argument_list|)
expr_stmt|;
comment|/* generate "STATE" field */
switch|switch
condition|(
name|state
operator|=
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
condition|)
block|{
case|case
name|SRUN
case|:
if|if
condition|(
name|smpmode
operator|&&
name|PP
argument_list|(
name|pp
argument_list|,
name|p_oncpu
argument_list|)
operator|!=
literal|0xff
condition|)
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"CPU%d"
argument_list|,
name|PP
argument_list|(
name|pp
argument_list|,
name|p_oncpu
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"RUN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSLEEP
case|:
if|if
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_wmesg
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"%.6s"
argument_list|,
name|EP
argument_list|(
name|pp
argument_list|,
name|e_wmesg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
if|if
condition|(
name|state
operator|>=
literal|0
operator|&&
name|state
operator|<
sizeof|sizeof
argument_list|(
name|state_abbrev
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|state_abbrev
argument_list|)
condition|)
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"%.6s"
argument_list|,
name|state_abbrev
index|[
operator|(
name|unsigned
name|char
operator|)
name|state
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"?%5d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* format this entry */
name|sprintf
argument_list|(
name|fmt
argument_list|,
name|smpmode
condition|?
name|smp_Proc_format
else|:
name|up_Proc_format
argument_list|,
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pid
argument_list|)
argument_list|,
name|namelength
argument_list|,
name|namelength
argument_list|,
call|(
modifier|*
name|get_userid
call|)
argument_list|(
name|EP
argument_list|(
name|pp
argument_list|,
name|e_pcred
operator|.
name|p_ruid
argument_list|)
argument_list|)
argument_list|,
name|PP
argument_list|(
name|pp
argument_list|,
name|p_priority
argument_list|)
operator|-
name|PZERO
argument_list|,
comment|/* 	     * normal time      -> nice value -20 - +20  	     * real time 0 - 31 -> nice value -52 - -21 	     * idle time 0 - 31 -> nice value +21 - +52 	     */
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|type
argument_list|)
operator|==
name|RTP_PRIO_NORMAL
condition|?
name|PP
argument_list|(
name|pp
argument_list|,
name|p_nice
argument_list|)
operator|-
name|NZERO
else|:
operator|(
name|RTP_PRIO_IS_REALTIME
argument_list|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|type
argument_list|)
argument_list|)
condition|?
operator|(
name|PRIO_MIN
operator|-
literal|1
operator|-
name|RTP_PRIO_MAX
operator|+
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|prio
argument_list|)
operator|)
else|:
operator|(
name|PRIO_MAX
operator|+
literal|1
operator|+
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|prio
argument_list|)
operator|)
operator|)
operator|)
argument_list|,
name|format_k2
argument_list|(
name|PROCSIZE
argument_list|(
name|pp
argument_list|)
argument_list|)
argument_list|,
name|format_k2
argument_list|(
name|pagetok
argument_list|(
name|VP
argument_list|(
name|pp
argument_list|,
name|vm_rssize
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|status
argument_list|,
name|smpmode
condition|?
name|PP
argument_list|(
name|pp
argument_list|,
name|p_lastcpu
argument_list|)
else|:
literal|0
argument_list|,
name|format_time
argument_list|(
name|cputime
argument_list|)
argument_list|,
literal|100.0
operator|*
name|weighted_cpu
argument_list|(
name|pct
argument_list|,
name|pp
argument_list|)
argument_list|,
literal|100.0
operator|*
name|pct
argument_list|,
name|cmdlength
argument_list|,
name|printable
argument_list|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_comm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return the result */
return|return
operator|(
name|fmt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * check_nlist(nlst) - checks the nlist to see if any symbols were not  *		found.  For every symbol that was not found, a one-line  *		message is printed to stderr.  The routine returns the  *		number of symbols NOT found.  */
end_comment

begin_function
specifier|static
name|int
name|check_nlist
parameter_list|(
name|nlst
parameter_list|)
specifier|register
name|struct
name|nlist
modifier|*
name|nlst
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* check to see if we got ALL the symbols we requested */
comment|/* this will write one line to stderr for every symbol not found */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nlst
operator|->
name|n_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nlst
operator|->
name|n_type
operator|==
literal|0
condition|)
block|{
comment|/* this one wasn't found */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kernel: no symbol named `%s'\n"
argument_list|,
name|nlst
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|nlst
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.  *	"offset" is the byte offset into the kernel for the desired value,  *  	"ptr" points to a buffer into which the value is retrieved,  *  	"size" is the size of the buffer (and the object to retrieve),  *  	"refstr" is a reference string used when printing error meessages,  *	    if "refstr" starts with a '!', then a failure on read will not  *  	    be fatal (this may seem like a silly way to do things, but I  *  	    really didn't want the overhead of another argument).  *  	  */
end_comment

begin_function
specifier|static
name|int
name|getkval
parameter_list|(
name|offset
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|,
name|refstr
parameter_list|)
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|refstr
decl_stmt|;
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|kd
argument_list|,
name|offset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
operator|*
name|refstr
operator|==
literal|'!'
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: kvm_read for %s: %s\n"
argument_list|,
name|refstr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* comparison routines for qsort */
end_comment

begin_comment
comment|/*  *  proc_compare - comparison function for "qsort"  *	Compares the resource consumption of two processes using five  *  	distinct keys.  The keys (in descending order of importance) are:  *  	percent cpu, cpu ticks, state, resident set size, total virtual  *  	memory usage.  The process states are ordered as follows (from least  *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The  *  	array declaration below maps a process state index into a number  *  	that reflects this ordering.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|sorted_state
index|[]
init|=
block|{
literal|0
block|,
comment|/* not used		*/
literal|3
block|,
comment|/* sleep		*/
literal|1
block|,
comment|/* ABANDONED (WAIT)	*/
literal|6
block|,
comment|/* run			*/
literal|5
block|,
comment|/* start		*/
literal|2
block|,
comment|/* zombie		*/
literal|4
comment|/* stop			*/
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ORDERKEY_PCTCPU
define|\
value|if (lresult = (long) PP(p2, p_pctcpu) - (long) PP(p1, p_pctcpu), \      (result = lresult> 0 ? 1 : lresult< 0 ? -1 : 0) == 0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_CPTICKS
define|\
value|if ((result = PP(p2, p_runtime)> PP(p1, p_runtime) ? 1 : \                 PP(p2, p_runtime)< PP(p1, p_runtime) ? -1 : 0) == 0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_STATE
define|\
value|if ((result = sorted_state[(unsigned char) PP(p2, p_stat)] - \                 sorted_state[(unsigned char) PP(p1, p_stat)]) == 0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_PRIO
define|\
value|if ((result = PP(p2, p_priority) - PP(p1, p_priority)) == 0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_RSSIZE
define|\
value|if ((result = VP(p2, vm_rssize) - VP(p1, vm_rssize)) == 0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_MEM
define|\
value|if ( (result = PROCSIZE(p2) - PROCSIZE(p1)) == 0 )
end_define

begin_comment
comment|/* compare_cpu - the comparison function for sorting by cpu percentage */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|ORDER
name|compare_cpu
parameter_list|(
name|pp1
parameter_list|,
name|pp2
parameter_list|)
else|#
directive|else
function|proc_compare
parameter_list|(
name|pp1
parameter_list|,
name|pp2
parameter_list|)
endif|#
directive|endif
name|struct
name|proc
modifier|*
modifier|*
name|pp1
decl_stmt|;
name|struct
name|proc
modifier|*
modifier|*
name|pp2
decl_stmt|;
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|pctcpu
name|lresult
decl_stmt|;
comment|/* remove one level of indirection */
name|p1
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp2
expr_stmt|;
name|ORDERKEY_PCTCPU
name|ORDERKEY_CPTICKS
name|ORDERKEY_STATE
name|ORDERKEY_PRIO
name|ORDERKEY_RSSIZE
name|ORDERKEY_MEM
decl_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ORDER
end_ifdef

begin_comment
comment|/* compare routines */
end_comment

begin_decl_stmt
name|int
name|compare_size
argument_list|()
decl_stmt|,
name|compare_res
argument_list|()
decl_stmt|,
name|compare_time
argument_list|()
decl_stmt|,
name|compare_prio
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|proc_compares
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|compare_cpu
operator|,
function_decl|compare_size
operator|,
function_decl|compare_res
operator|,
function_decl|compare_time
operator|,
function_decl|compare_prio
operator|,
function_decl|NULL
end_function_decl

begin_comment
unit|};
comment|/* compare_size - the comparison function for sorting by total memory usage */
end_comment

begin_function
name|int
name|compare_size
parameter_list|(
name|pp1
parameter_list|,
name|pp2
parameter_list|)
name|struct
name|proc
modifier|*
modifier|*
name|pp1
decl_stmt|;
name|struct
name|proc
modifier|*
modifier|*
name|pp2
decl_stmt|;
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|pctcpu
name|lresult
decl_stmt|;
comment|/* remove one level of indirection */
name|p1
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp2
expr_stmt|;
name|ORDERKEY_MEM
name|ORDERKEY_RSSIZE
name|ORDERKEY_PCTCPU
name|ORDERKEY_CPTICKS
name|ORDERKEY_STATE
name|ORDERKEY_PRIO
decl_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_res - the comparison function for sorting by resident set size */
end_comment

begin_function
name|int
name|compare_res
parameter_list|(
name|pp1
parameter_list|,
name|pp2
parameter_list|)
name|struct
name|proc
modifier|*
modifier|*
name|pp1
decl_stmt|;
name|struct
name|proc
modifier|*
modifier|*
name|pp2
decl_stmt|;
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|pctcpu
name|lresult
decl_stmt|;
comment|/* remove one level of indirection */
name|p1
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp2
expr_stmt|;
name|ORDERKEY_RSSIZE
name|ORDERKEY_MEM
name|ORDERKEY_PCTCPU
name|ORDERKEY_CPTICKS
name|ORDERKEY_STATE
name|ORDERKEY_PRIO
decl_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_time - the comparison function for sorting by total cpu time */
end_comment

begin_function
name|int
name|compare_time
parameter_list|(
name|pp1
parameter_list|,
name|pp2
parameter_list|)
name|struct
name|proc
modifier|*
modifier|*
name|pp1
decl_stmt|;
name|struct
name|proc
modifier|*
modifier|*
name|pp2
decl_stmt|;
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|pctcpu
name|lresult
decl_stmt|;
comment|/* remove one level of indirection */
name|p1
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp2
expr_stmt|;
name|ORDERKEY_CPTICKS
name|ORDERKEY_PCTCPU
name|ORDERKEY_STATE
name|ORDERKEY_PRIO
name|ORDERKEY_RSSIZE
name|ORDERKEY_MEM
decl_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_prio - the comparison function for sorting by cpu percentage */
end_comment

begin_function
name|int
name|compare_prio
parameter_list|(
name|pp1
parameter_list|,
name|pp2
parameter_list|)
name|struct
name|proc
modifier|*
modifier|*
name|pp1
decl_stmt|;
name|struct
name|proc
modifier|*
modifier|*
name|pp2
decl_stmt|;
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|pctcpu
name|lresult
decl_stmt|;
comment|/* remove one level of indirection */
name|p1
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp2
expr_stmt|;
name|ORDERKEY_PRIO
name|ORDERKEY_CPTICKS
name|ORDERKEY_PCTCPU
name|ORDERKEY_STATE
name|ORDERKEY_RSSIZE
name|ORDERKEY_MEM
decl_stmt|;
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * proc_owner(pid) - returns the uid that owns process "pid", or -1 if  *		the process does not exist.  *		It is EXTREMLY IMPORTANT that this function work correctly.  *		If top runs setuid root (as in SVR4), then this function  *		is the only thing that stands in the way of a serious  *		security problem.  It validates requests for the "kill"  *		and "renice" commands.  */
end_comment

begin_function
name|int
name|proc_owner
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|prefp
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
name|prefp
operator|=
name|pref
expr_stmt|;
name|cnt
operator|=
name|pref_len
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
name|pp
operator|=
operator|*
name|prefp
operator|++
expr_stmt|;
if|if
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pid
argument_list|)
operator|==
operator|(
name|pid_t
operator|)
name|pid
condition|)
block|{
return|return
operator|(
operator|(
name|int
operator|)
name|EP
argument_list|(
name|pp
argument_list|,
name|e_pcred
operator|.
name|p_ruid
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * swapmode is based on a program called swapinfo written  * by Kevin Lahey<kml@rokkaku.atl.ga.us>.  */
end_comment

begin_define
define|#
directive|define
name|SVAR
parameter_list|(
name|var
parameter_list|)
value|__STRING(var)
end_define

begin_comment
comment|/* to force expansion */
end_comment

begin_define
define|#
directive|define
name|KGET
parameter_list|(
name|idx
parameter_list|,
name|var
parameter_list|)
define|\
value|KGET1(idx,&var, sizeof(var), SVAR(var))
end_define

begin_define
define|#
directive|define
name|KGET1
parameter_list|(
name|idx
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|,
name|msg
parameter_list|)
define|\
value|KGET2(nlst[idx].n_value, p, s, msg)
end_define

begin_define
define|#
directive|define
name|KGET2
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|,
name|msg
parameter_list|)
define|\
value|if (kvm_read(kd, (u_long)(addr), p, s) != s) {		        \ 		warnx("cannot read %s: %s", msg, kvm_geterr(kd));       \ 		return (0);                                             \        }
end_define

begin_define
define|#
directive|define
name|KGETRET
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|,
name|msg
parameter_list|)
define|\
value|if (kvm_read(kd, (u_long)(addr), p, s) != s) {			\ 		warnx("cannot read %s: %s", msg, kvm_geterr(kd));	\ 		return (0);						\ 	}
end_define

begin_function
name|int
name|swapmode
parameter_list|(
name|retavail
parameter_list|,
name|retfree
parameter_list|)
name|int
modifier|*
name|retavail
decl_stmt|;
name|int
modifier|*
name|retfree
decl_stmt|;
block|{
name|int
name|n
decl_stmt|;
name|int
name|pagesize
init|=
name|getpagesize
argument_list|()
decl_stmt|;
name|struct
name|kvm_swap
name|swapary
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|retavail
operator|=
literal|0
expr_stmt|;
operator|*
name|retfree
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|CONVERT
parameter_list|(
name|v
parameter_list|)
value|((quad_t)(v) * pagesize / 1024)
name|n
operator|=
name|kvm_getswapinfo
argument_list|(
name|kd
argument_list|,
name|swapary
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|retavail
operator|=
name|CONVERT
argument_list|(
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
argument_list|)
expr_stmt|;
operator|*
name|retfree
operator|=
name|CONVERT
argument_list|(
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
operator|-
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_used
argument_list|)
expr_stmt|;
name|n
operator|=
call|(
name|int
call|)
argument_list|(
operator|(
name|double
operator|)
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_used
operator|*
literal|100.0
operator|/
operator|(
name|double
operator|)
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

