begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * top - a top users display for Unix  *  * SYNOPSIS:  For FreeBSD-2.x and later  *  * DESCRIPTION:  * Originally written for BSD4.4 system by Christos Zoulas.  * Ported to FreeBSD 2.x by Steven Wallace&& Wolfram Schneider  * Order support hacked in from top-3.5beta6/machine/m_aix41.c  *   by Monte Mitzelfelt (for latest top see http://www.groupsys.com/topinfo/)  *  * This is the machine-dependent module for FreeBSD 2.2  * Works for:  *	FreeBSD 2.2.x, 3.x, 4.x, and probably FreeBSD 2.1.x  *  * LIBS: -lkvm  *  * AUTHOR:  Christos Zoulas<christos@ee.cornell.edu>  *          Steven Wallace<swallace@freebsd.org>  *          Wolfram Schneider<wosch@FreeBSD.org>  *          Thomas Moestl<tmoestl@gmx.net>  *  * $FreeBSD$  */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<paths.h>
end_include

begin_include
include|#
directive|include
file|<pwd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<strings.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<vis.h>
end_include

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_include
include|#
directive|include
file|"screen.h"
end_include

begin_include
include|#
directive|include
file|"utils.h"
end_include

begin_define
define|#
directive|define
name|GETSYSCTL
parameter_list|(
name|name
parameter_list|,
name|var
parameter_list|)
value|getsysctl(name,&(var), sizeof(var))
end_define

begin_define
define|#
directive|define
name|SMPUNAMELEN
value|13
end_define

begin_define
define|#
directive|define
name|UPUNAMELEN
value|15
end_define

begin_decl_stmt
specifier|extern
name|struct
name|process_select
name|ps
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|extern
name|char
modifier|*
name|printable
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
specifier|static
name|int
name|smpmode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|enum
name|displaymodes
name|displaymode
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|namelength
init|=
literal|8
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|cmdlengthdelta
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Prototypes for top internals */
end_comment

begin_function_decl
name|void
name|quit
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* get_process_info passes back a handle.  This is what it looks like: */
end_comment

begin_struct
struct|struct
name|handle
block|{
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|next_proc
decl_stmt|;
comment|/* points to next valid proc pointer */
name|int
name|remaining
decl_stmt|;
comment|/* number of pointers remaining */
block|}
struct|;
end_struct

begin_comment
comment|/* declarations for load_avg */
end_comment

begin_include
include|#
directive|include
file|"loadavg.h"
end_include

begin_comment
comment|/* define what weighted cpu is.  */
end_comment

begin_define
define|#
directive|define
name|weighted_cpu
parameter_list|(
name|pct
parameter_list|,
name|pp
parameter_list|)
value|((pp)->ki_swtime == 0 ? 0.0 : \ 			 ((pct) / (1.0 - exp((pp)->ki_swtime * logcpu))))
end_define

begin_comment
comment|/* what we consider to be process size: */
end_comment

begin_define
define|#
directive|define
name|PROCSIZE
parameter_list|(
name|pp
parameter_list|)
value|((pp)->ki_size / 1024)
end_define

begin_define
define|#
directive|define
name|RU
parameter_list|(
name|pp
parameter_list|)
value|(&(pp)->ki_rusage)
end_define

begin_define
define|#
directive|define
name|RUTOT
parameter_list|(
name|pp
parameter_list|)
define|\
value|(RU(pp)->ru_inblock + RU(pp)->ru_oublock + RU(pp)->ru_majflt)
end_define

begin_comment
comment|/* definitions for indices in the nlist array */
end_comment

begin_comment
comment|/*  *  These definitions control the format of the per-process area  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|io_header
index|[]
init|=
literal|"  PID%s %-*.*s   VCSW  IVCSW   READ  WRITE  FAULT  TOTAL PERCENT COMMAND"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|io_Proc_format
define|\
value|"%5d%s %-*.*s %6ld %6ld %6ld %6ld %6ld %6ld %6.2f%% %.*s"
end_define

begin_decl_stmt
specifier|static
name|char
name|smp_header_thr
index|[]
init|=
literal|"  PID%s %-*.*s  THR PRI NICE   SIZE    RES STATE  C   TIME %6s COMMAND"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|smp_header
index|[]
init|=
literal|"  PID%s %-*.*s "
literal|"PRI NICE   SIZE    RES STATE  C   TIME %6s COMMAND"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|smp_Proc_format
define|\
value|"%5d%s %-*.*s %s%3d %4s%7s %6s %-6.6s %1x%7s %5.2f%% %.*s"
end_define

begin_decl_stmt
specifier|static
name|char
name|up_header_thr
index|[]
init|=
literal|"  PID%s %-*.*s  THR PRI NICE   SIZE    RES STATE    TIME %6s COMMAND"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|up_header
index|[]
init|=
literal|"  PID%s %-*.*s "
literal|"PRI NICE   SIZE    RES STATE    TIME %6s COMMAND"
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|up_Proc_format
define|\
value|"%5d%s %-*.*s %s%3d %4s%7s %6s %-6.6s%.0d%7s %5.2f%% %.*s"
end_define

begin_comment
comment|/* process state names for the "STATE" column of the display */
end_comment

begin_comment
comment|/* the extra nulls in the string "run" are for adding a slash and    the processor number when needed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|state_abbrev
index|[]
init|=
block|{
literal|""
block|,
literal|"START"
block|,
literal|"RUN\0\0\0"
block|,
literal|"SLEEP"
block|,
literal|"STOP"
block|,
literal|"ZOMB"
block|,
literal|"WAIT"
block|,
literal|"LOCK"
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kvm_t
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* values that we stash away in _init and use in later routines */
end_comment

begin_decl_stmt
specifier|static
name|double
name|logcpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are retrieved from the kernel in _init */
end_comment

begin_decl_stmt
specifier|static
name|load_avg
name|ccpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are used in the get_ functions */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lastpid
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for calculating cpu state percentages */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cp_time
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cp_old
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cp_diff
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the process states */
end_comment

begin_decl_stmt
name|int
name|process_states
index|[
literal|8
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|procstatenames
index|[]
init|=
block|{
literal|""
block|,
literal|" starting, "
block|,
literal|" running, "
block|,
literal|" sleeping, "
block|,
literal|" stopped, "
block|,
literal|" zombie, "
block|,
literal|" waiting, "
block|,
literal|" lock, "
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the cpu states */
end_comment

begin_decl_stmt
name|int
name|cpu_states
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cpustatenames
index|[]
init|=
block|{
literal|"user"
block|,
literal|"nice"
block|,
literal|"system"
block|,
literal|"interrupt"
block|,
literal|"idle"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the memory statistics */
end_comment

begin_decl_stmt
name|int
name|memory_stats
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|memorynames
index|[]
init|=
block|{
literal|"K Active, "
block|,
literal|"K Inact, "
block|,
literal|"K Wired, "
block|,
literal|"K Cache, "
block|,
literal|"K Buf, "
block|,
literal|"K Free"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap_stats
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|swapnames
index|[]
init|=
block|{
literal|"K Total, "
block|,
literal|"K Used, "
block|,
literal|"K Free, "
block|,
literal|"% Inuse, "
block|,
literal|"K In, "
block|,
literal|"K Out"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for keeping track of the proc array */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|onproc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pref_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|pbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|pref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|previous_procs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|previous_pref
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|previous_proc_count
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|previous_proc_count_max
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* total number of io operations */
end_comment

begin_decl_stmt
specifier|static
name|long
name|total_inblock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|total_oublock
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|total_majflt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for getting the memory statistics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pageshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log base 2 of the pagesize */
end_comment

begin_comment
comment|/* define pagetok in terms of pageshift */
end_comment

begin_define
define|#
directive|define
name|pagetok
parameter_list|(
name|size
parameter_list|)
value|((size)<< pageshift)
end_define

begin_comment
comment|/* useful externals */
end_comment

begin_function_decl
name|long
name|percentages
parameter_list|()
function_decl|;
end_function_decl

begin_ifdef
ifdef|#
directive|ifdef
name|ORDER
end_ifdef

begin_comment
comment|/*  * Sorting orders.  The first element is the default.  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|ordernames
index|[]
init|=
block|{
literal|"cpu"
block|,
literal|"size"
block|,
literal|"res"
block|,
literal|"time"
block|,
literal|"pri"
block|,
literal|"threads"
block|,
literal|"total"
block|,
literal|"read"
block|,
literal|"write"
block|,
literal|"fault"
block|,
literal|"vcsw"
block|,
literal|"ivcsw"
block|,
literal|"jid"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|static
name|int
name|compare_jid
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|compare_pid
parameter_list|(
specifier|const
name|void
modifier|*
name|a
parameter_list|,
specifier|const
name|void
modifier|*
name|b
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
specifier|const
name|char
modifier|*
name|format_nice
parameter_list|(
specifier|const
name|struct
name|kinfo_proc
modifier|*
name|pp
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|getsysctl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|int
name|swapmode
parameter_list|(
name|int
modifier|*
name|retavail
parameter_list|,
name|int
modifier|*
name|retfree
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|machine_init
parameter_list|(
name|struct
name|statics
modifier|*
name|statics
parameter_list|)
block|{
name|int
name|pagesize
decl_stmt|;
name|size_t
name|modelen
decl_stmt|;
name|struct
name|passwd
modifier|*
name|pw
decl_stmt|;
name|modelen
operator|=
sizeof|sizeof
argument_list|(
name|smpmode
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sysctlbyname
argument_list|(
literal|"machdep.smp_active"
argument_list|,
operator|&
name|smpmode
argument_list|,
operator|&
name|modelen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|&&
name|sysctlbyname
argument_list|(
literal|"kern.smp.active"
argument_list|,
operator|&
name|smpmode
argument_list|,
operator|&
name|modelen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
literal|0
operator|)
operator|||
name|modelen
operator|!=
sizeof|sizeof
argument_list|(
name|smpmode
argument_list|)
condition|)
name|smpmode
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|(
name|pw
operator|=
name|getpwent
argument_list|()
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|strlen
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
operator|>
name|namelength
condition|)
name|namelength
operator|=
name|strlen
argument_list|(
name|pw
operator|->
name|pw_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|smpmode
operator|&&
name|namelength
operator|>
name|SMPUNAMELEN
condition|)
name|namelength
operator|=
name|SMPUNAMELEN
expr_stmt|;
elseif|else
if|if
condition|(
name|namelength
operator|>
name|UPUNAMELEN
condition|)
name|namelength
operator|=
name|UPUNAMELEN
expr_stmt|;
name|kd
operator|=
name|kvm_open
argument_list|(
name|NULL
argument_list|,
name|_PATH_DEVNULL
argument_list|,
name|NULL
argument_list|,
name|O_RDONLY
argument_list|,
literal|"kvm_open"
argument_list|)
expr_stmt|;
if|if
condition|(
name|kd
operator|==
name|NULL
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
name|GETSYSCTL
argument_list|(
literal|"kern.ccpu"
argument_list|,
name|ccpu
argument_list|)
expr_stmt|;
comment|/* this is used in calculating WCPU -- calculate it ahead of time */
name|logcpu
operator|=
name|log
argument_list|(
name|loaddouble
argument_list|(
name|ccpu
argument_list|)
argument_list|)
expr_stmt|;
name|pbase
operator|=
name|NULL
expr_stmt|;
name|pref
operator|=
name|NULL
expr_stmt|;
name|nproc
operator|=
literal|0
expr_stmt|;
name|onproc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* get the page size and calculate pageshift from it */
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|pageshift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pagesize
operator|>
literal|1
condition|)
block|{
name|pageshift
operator|++
expr_stmt|;
name|pagesize
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* we only need the amount of log(2)1024 for our conversion */
name|pageshift
operator|-=
name|LOG1024
expr_stmt|;
comment|/* fill in the statics information */
name|statics
operator|->
name|procstate_names
operator|=
name|procstatenames
expr_stmt|;
name|statics
operator|->
name|cpustate_names
operator|=
name|cpustatenames
expr_stmt|;
name|statics
operator|->
name|memory_names
operator|=
name|memorynames
expr_stmt|;
name|statics
operator|->
name|swap_names
operator|=
name|swapnames
expr_stmt|;
ifdef|#
directive|ifdef
name|ORDER
name|statics
operator|->
name|order_names
operator|=
name|ordernames
expr_stmt|;
endif|#
directive|endif
comment|/* all done! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|format_header
parameter_list|(
name|char
modifier|*
name|uname_field
parameter_list|)
block|{
specifier|static
name|char
name|Header
index|[
literal|128
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|prehead
decl_stmt|;
switch|switch
condition|(
name|displaymode
condition|)
block|{
case|case
name|DISP_CPU
case|:
comment|/* 		 * The logic of picking the right header format seems reverse 		 * here because we only want to display a THR column when 		 * "thread mode" is off (and threads are not listed as 		 * separate lines). 		 */
name|prehead
operator|=
name|smpmode
condition|?
operator|(
name|ps
operator|.
name|thread
condition|?
name|smp_header
else|:
name|smp_header_thr
operator|)
else|:
operator|(
name|ps
operator|.
name|thread
condition|?
name|up_header
else|:
name|up_header_thr
operator|)
expr_stmt|;
name|snprintf
argument_list|(
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
argument_list|,
name|prehead
argument_list|,
name|ps
operator|.
name|jail
condition|?
literal|" JID"
else|:
literal|""
argument_list|,
name|namelength
argument_list|,
name|namelength
argument_list|,
name|uname_field
argument_list|,
name|ps
operator|.
name|wcpu
condition|?
literal|"WCPU"
else|:
literal|"CPU"
argument_list|)
expr_stmt|;
break|break;
case|case
name|DISP_IO
case|:
name|prehead
operator|=
name|io_header
expr_stmt|;
name|snprintf
argument_list|(
name|Header
argument_list|,
sizeof|sizeof
argument_list|(
name|Header
argument_list|)
argument_list|,
name|prehead
argument_list|,
name|ps
operator|.
name|jail
condition|?
literal|" JID"
else|:
literal|""
argument_list|,
name|namelength
argument_list|,
name|namelength
argument_list|,
name|uname_field
argument_list|)
expr_stmt|;
break|break;
block|}
name|cmdlengthdelta
operator|=
name|strlen
argument_list|(
name|Header
argument_list|)
operator|-
literal|7
expr_stmt|;
return|return
operator|(
name|Header
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|swappgsin
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swappgsout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|timeout
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|get_system_info
parameter_list|(
name|struct
name|system_info
modifier|*
name|si
parameter_list|)
block|{
name|long
name|total
decl_stmt|;
name|struct
name|loadavg
name|sysload
decl_stmt|;
name|int
name|mib
index|[
literal|2
index|]
decl_stmt|;
name|struct
name|timeval
name|boottime
decl_stmt|;
name|size_t
name|bt_size
decl_stmt|;
name|int
name|i
decl_stmt|;
comment|/* get the cp_time array */
name|GETSYSCTL
argument_list|(
literal|"kern.cp_time"
argument_list|,
name|cp_time
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.loadavg"
argument_list|,
name|sysload
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"kern.lastpid"
argument_list|,
name|lastpid
argument_list|)
expr_stmt|;
comment|/* convert load averages to doubles */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
name|si
operator|->
name|load_avg
index|[
name|i
index|]
operator|=
operator|(
name|double
operator|)
name|sysload
operator|.
name|ldavg
index|[
name|i
index|]
operator|/
name|sysload
operator|.
name|fscale
expr_stmt|;
comment|/* convert cp_time counts to percentages */
name|total
operator|=
name|percentages
argument_list|(
name|CPUSTATES
argument_list|,
name|cpu_states
argument_list|,
name|cp_time
argument_list|,
name|cp_old
argument_list|,
name|cp_diff
argument_list|)
expr_stmt|;
comment|/* sum memory& swap statistics */
block|{
specifier|static
name|unsigned
name|int
name|swap_delay
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|swapavail
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|swapfree
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufspace
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|nspgsin
decl_stmt|,
name|nspgsout
decl_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vfs.bufspace"
argument_list|,
name|bufspace
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.stats.vm.v_active_count"
argument_list|,
name|memory_stats
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.stats.vm.v_inactive_count"
argument_list|,
name|memory_stats
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.stats.vm.v_wire_count"
argument_list|,
name|memory_stats
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.stats.vm.v_cache_count"
argument_list|,
name|memory_stats
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.stats.vm.v_free_count"
argument_list|,
name|memory_stats
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.stats.vm.v_swappgsin"
argument_list|,
name|nspgsin
argument_list|)
expr_stmt|;
name|GETSYSCTL
argument_list|(
literal|"vm.stats.vm.v_swappgsout"
argument_list|,
name|nspgsout
argument_list|)
expr_stmt|;
comment|/* convert memory stats to Kbytes */
name|memory_stats
index|[
literal|0
index|]
operator|=
name|pagetok
argument_list|(
name|memory_stats
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|1
index|]
operator|=
name|pagetok
argument_list|(
name|memory_stats
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|2
index|]
operator|=
name|pagetok
argument_list|(
name|memory_stats
index|[
literal|2
index|]
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|3
index|]
operator|=
name|pagetok
argument_list|(
name|memory_stats
index|[
literal|3
index|]
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|4
index|]
operator|=
name|bufspace
operator|/
literal|1024
expr_stmt|;
name|memory_stats
index|[
literal|5
index|]
operator|=
name|pagetok
argument_list|(
name|memory_stats
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|6
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* first interval */
if|if
condition|(
name|swappgsin
operator|<
literal|0
condition|)
block|{
name|swap_stats
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|swap_stats
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* compute differences between old and new swap statistic */
else|else
block|{
name|swap_stats
index|[
literal|4
index|]
operator|=
name|pagetok
argument_list|(
operator|(
operator|(
name|nspgsin
operator|-
name|swappgsin
operator|)
operator|)
argument_list|)
expr_stmt|;
name|swap_stats
index|[
literal|5
index|]
operator|=
name|pagetok
argument_list|(
operator|(
operator|(
name|nspgsout
operator|-
name|swappgsout
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|swappgsin
operator|=
name|nspgsin
expr_stmt|;
name|swappgsout
operator|=
name|nspgsout
expr_stmt|;
comment|/* call CPU heavy swapmode() only for changes */
if|if
condition|(
name|swap_stats
index|[
literal|4
index|]
operator|>
literal|0
operator|||
name|swap_stats
index|[
literal|5
index|]
operator|>
literal|0
operator|||
name|swap_delay
operator|==
literal|0
condition|)
block|{
name|swap_stats
index|[
literal|3
index|]
operator|=
name|swapmode
argument_list|(
operator|&
name|swapavail
argument_list|,
operator|&
name|swapfree
argument_list|)
expr_stmt|;
name|swap_stats
index|[
literal|0
index|]
operator|=
name|swapavail
expr_stmt|;
name|swap_stats
index|[
literal|1
index|]
operator|=
name|swapavail
operator|-
name|swapfree
expr_stmt|;
name|swap_stats
index|[
literal|2
index|]
operator|=
name|swapfree
expr_stmt|;
block|}
name|swap_delay
operator|=
literal|1
expr_stmt|;
name|swap_stats
index|[
literal|6
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* set arrays and strings */
name|si
operator|->
name|cpustates
operator|=
name|cpu_states
expr_stmt|;
name|si
operator|->
name|memory
operator|=
name|memory_stats
expr_stmt|;
name|si
operator|->
name|swap
operator|=
name|swap_stats
expr_stmt|;
if|if
condition|(
name|lastpid
operator|>
literal|0
condition|)
block|{
name|si
operator|->
name|last_pid
operator|=
name|lastpid
expr_stmt|;
block|}
else|else
block|{
name|si
operator|->
name|last_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* 	 * Print how long system has been up. 	 * (Found by looking getting "boottime" from the kernel) 	 */
name|mib
index|[
literal|0
index|]
operator|=
name|CTL_KERN
expr_stmt|;
name|mib
index|[
literal|1
index|]
operator|=
name|KERN_BOOTTIME
expr_stmt|;
name|bt_size
operator|=
sizeof|sizeof
argument_list|(
name|boottime
argument_list|)
expr_stmt|;
if|if
condition|(
name|sysctl
argument_list|(
name|mib
argument_list|,
literal|2
argument_list|,
operator|&
name|boottime
argument_list|,
operator|&
name|bt_size
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|!=
operator|-
literal|1
operator|&&
name|boottime
operator|.
name|tv_sec
operator|!=
literal|0
condition|)
block|{
name|si
operator|->
name|boottime
operator|=
name|boottime
expr_stmt|;
block|}
else|else
block|{
name|si
operator|->
name|boottime
operator|.
name|tv_sec
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_define
define|#
directive|define
name|NOPROC
value|((void *)-1)
end_define

begin_comment
comment|/*  * We need to compare data from the old process entry with the new  * process entry.  * To facilitate doing this quickly we stash a pointer in the kinfo_proc  * structure to cache the mapping.  We also use a negative cache pointer  * of NOPROC to avoid duplicate lookups.  * XXX: this could be done when the actual processes are fetched, we do  * it here out of laziness.  */
end_comment

begin_function
specifier|const
name|struct
name|kinfo_proc
modifier|*
name|get_old_proc
parameter_list|(
name|struct
name|kinfo_proc
modifier|*
name|pp
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|oldpp
decl_stmt|,
modifier|*
name|oldp
decl_stmt|;
comment|/* 	 * If this is the first fetch of the kinfo_procs then we don't have 	 * any previous entries. 	 */
if|if
condition|(
name|previous_proc_count
operator|==
literal|0
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* negative cache? */
if|if
condition|(
name|pp
operator|->
name|ki_udata
operator|==
name|NOPROC
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* cached? */
if|if
condition|(
name|pp
operator|->
name|ki_udata
operator|!=
name|NULL
condition|)
return|return
operator|(
name|pp
operator|->
name|ki_udata
operator|)
return|;
comment|/* 	 * Not cached, 	 * 1) look up based on pid. 	 * 2) compare process start. 	 * If we fail here, then setup a negative cache entry, otherwise 	 * cache it. 	 */
name|oldpp
operator|=
name|bsearch
argument_list|(
operator|&
name|pp
argument_list|,
name|previous_pref
argument_list|,
name|previous_proc_count
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|previous_pref
argument_list|)
argument_list|,
name|compare_pid
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldpp
operator|==
name|NULL
condition|)
block|{
name|pp
operator|->
name|ki_udata
operator|=
name|NOPROC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|oldp
operator|=
operator|*
name|oldpp
expr_stmt|;
if|if
condition|(
name|bcmp
argument_list|(
operator|&
name|oldp
operator|->
name|ki_start
argument_list|,
operator|&
name|pp
operator|->
name|ki_start
argument_list|,
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ki_start
argument_list|)
argument_list|)
operator|!=
literal|0
condition|)
block|{
name|pp
operator|->
name|ki_udata
operator|=
name|NOPROC
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|pp
operator|->
name|ki_udata
operator|=
name|oldp
expr_stmt|;
return|return
operator|(
name|oldp
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the total amount of IO done in blocks in/out and faults.  * store the values individually in the pointers passed in.  */
end_comment

begin_function
name|long
name|get_io_stats
parameter_list|(
name|struct
name|kinfo_proc
modifier|*
name|pp
parameter_list|,
name|long
modifier|*
name|inp
parameter_list|,
name|long
modifier|*
name|oup
parameter_list|,
name|long
modifier|*
name|flp
parameter_list|,
name|long
modifier|*
name|vcsw
parameter_list|,
name|long
modifier|*
name|ivcsw
parameter_list|)
block|{
specifier|const
name|struct
name|kinfo_proc
modifier|*
name|oldp
decl_stmt|;
specifier|static
name|struct
name|kinfo_proc
name|dummy
decl_stmt|;
name|long
name|ret
decl_stmt|;
name|oldp
operator|=
name|get_old_proc
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldp
operator|==
name|NULL
condition|)
block|{
name|bzero
argument_list|(
operator|&
name|dummy
argument_list|,
sizeof|sizeof
argument_list|(
name|dummy
argument_list|)
argument_list|)
expr_stmt|;
name|oldp
operator|=
operator|&
name|dummy
expr_stmt|;
block|}
operator|*
name|inp
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_inblock
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_inblock
expr_stmt|;
operator|*
name|oup
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_oublock
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_oublock
expr_stmt|;
operator|*
name|flp
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_majflt
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_majflt
expr_stmt|;
operator|*
name|vcsw
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_nvcsw
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_nvcsw
expr_stmt|;
operator|*
name|ivcsw
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_nivcsw
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_nivcsw
expr_stmt|;
name|ret
operator|=
operator|(
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_inblock
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_inblock
operator|)
operator|+
operator|(
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_oublock
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_oublock
operator|)
operator|+
operator|(
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_majflt
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_majflt
operator|)
expr_stmt|;
return|return
operator|(
name|ret
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Return the total number of block in/out and faults by a process.  */
end_comment

begin_function
name|long
name|get_io_total
parameter_list|(
name|struct
name|kinfo_proc
modifier|*
name|pp
parameter_list|)
block|{
name|long
name|dummy
decl_stmt|;
return|return
operator|(
name|get_io_stats
argument_list|(
name|pp
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|handle
name|handle
decl_stmt|;
end_decl_stmt

begin_function
name|caddr_t
name|get_process_info
parameter_list|(
name|struct
name|system_info
modifier|*
name|si
parameter_list|,
name|struct
name|process_select
modifier|*
name|sel
parameter_list|,
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|(
specifier|const
name|void
modifier|*
parameter_list|,
specifier|const
name|void
modifier|*
parameter_list|)
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|int
name|total_procs
decl_stmt|;
name|long
name|p_io
decl_stmt|;
name|long
name|p_inblock
decl_stmt|,
name|p_oublock
decl_stmt|,
name|p_majflt
decl_stmt|,
name|p_vcsw
decl_stmt|,
name|p_ivcsw
decl_stmt|;
name|int
name|active_procs
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|prefp
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|prev_pp
init|=
name|NULL
decl_stmt|;
comment|/* these are copied out of sel for speed */
name|int
name|show_idle
decl_stmt|;
name|int
name|show_self
decl_stmt|;
name|int
name|show_system
decl_stmt|;
name|int
name|show_uid
decl_stmt|;
name|int
name|show_command
decl_stmt|;
comment|/* 	 * Save the previous process info. 	 */
if|if
condition|(
name|previous_proc_count_max
operator|<
name|nproc
condition|)
block|{
name|free
argument_list|(
name|previous_procs
argument_list|)
expr_stmt|;
name|previous_procs
operator|=
name|malloc
argument_list|(
name|nproc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|previous_procs
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|previous_pref
argument_list|)
expr_stmt|;
name|previous_pref
operator|=
name|malloc
argument_list|(
name|nproc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|previous_pref
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|previous_procs
operator|==
name|NULL
operator|||
name|previous_pref
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: Out of memory.\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
name|previous_proc_count_max
operator|=
name|nproc
expr_stmt|;
block|}
if|if
condition|(
name|nproc
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nproc
condition|;
name|i
operator|++
control|)
name|previous_pref
index|[
name|i
index|]
operator|=
operator|&
name|previous_procs
index|[
name|i
index|]
expr_stmt|;
name|bcopy
argument_list|(
name|pbase
argument_list|,
name|previous_procs
argument_list|,
name|nproc
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|previous_procs
argument_list|)
argument_list|)
expr_stmt|;
name|qsort
argument_list|(
name|previous_pref
argument_list|,
name|nproc
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|previous_pref
argument_list|)
argument_list|,
name|compare_pid
argument_list|)
expr_stmt|;
block|}
name|previous_proc_count
operator|=
name|nproc
expr_stmt|;
name|pbase
operator|=
name|kvm_getprocs
argument_list|(
name|kd
argument_list|,
name|KERN_PROC_ALL
argument_list|,
literal|0
argument_list|,
operator|&
name|nproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nproc
operator|>
name|onproc
condition|)
name|pref
operator|=
name|realloc
argument_list|(
name|pref
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pref
argument_list|)
operator|*
operator|(
name|onproc
operator|=
name|nproc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pref
operator|==
name|NULL
operator|||
name|pbase
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: Out of memory.\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
comment|/* get a pointer to the states summary array */
name|si
operator|->
name|procstates
operator|=
name|process_states
expr_stmt|;
comment|/* set up flags which define what we are going to select */
name|show_idle
operator|=
name|sel
operator|->
name|idle
expr_stmt|;
name|show_self
operator|=
name|sel
operator|->
name|self
operator|==
operator|-
literal|1
expr_stmt|;
name|show_system
operator|=
name|sel
operator|->
name|system
expr_stmt|;
name|show_uid
operator|=
name|sel
operator|->
name|uid
operator|!=
operator|-
literal|1
expr_stmt|;
name|show_command
operator|=
name|sel
operator|->
name|command
operator|!=
name|NULL
expr_stmt|;
comment|/* count up process states and get pointers to interesting procs */
name|total_procs
operator|=
literal|0
expr_stmt|;
name|active_procs
operator|=
literal|0
expr_stmt|;
name|total_inblock
operator|=
literal|0
expr_stmt|;
name|total_oublock
operator|=
literal|0
expr_stmt|;
name|total_majflt
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|process_states
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|process_states
argument_list|)
argument_list|)
expr_stmt|;
name|prefp
operator|=
name|pref
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pbase
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nproc
condition|;
name|pp
operator|++
operator|,
name|i
operator|++
control|)
block|{
if|if
condition|(
name|pp
operator|->
name|ki_stat
operator|==
literal|0
condition|)
comment|/* not in use */
continue|continue;
if|if
condition|(
operator|!
name|show_self
operator|&&
name|pp
operator|->
name|ki_pid
operator|==
name|sel
operator|->
name|self
condition|)
comment|/* skip self */
continue|continue;
if|if
condition|(
operator|!
name|show_system
operator|&&
operator|(
name|pp
operator|->
name|ki_flag
operator|&
name|P_SYSTEM
operator|)
condition|)
comment|/* skip system process */
continue|continue;
name|p_io
operator|=
name|get_io_stats
argument_list|(
name|pp
argument_list|,
operator|&
name|p_inblock
argument_list|,
operator|&
name|p_oublock
argument_list|,
operator|&
name|p_majflt
argument_list|,
operator|&
name|p_vcsw
argument_list|,
operator|&
name|p_ivcsw
argument_list|)
expr_stmt|;
name|total_inblock
operator|+=
name|p_inblock
expr_stmt|;
name|total_oublock
operator|+=
name|p_oublock
expr_stmt|;
name|total_majflt
operator|+=
name|p_majflt
expr_stmt|;
name|total_procs
operator|++
expr_stmt|;
name|process_states
index|[
name|pp
operator|->
name|ki_stat
index|]
operator|++
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ki_stat
operator|==
name|SZOMB
condition|)
comment|/* skip zombies */
continue|continue;
if|if
condition|(
name|displaymode
operator|==
name|DISP_CPU
operator|&&
operator|!
name|show_idle
operator|&&
operator|(
name|pp
operator|->
name|ki_pctcpu
operator|==
literal|0
operator|||
name|pp
operator|->
name|ki_stat
operator|==
name|SSTOP
operator|||
name|pp
operator|->
name|ki_stat
operator|==
name|SIDL
operator|)
condition|)
comment|/* skip idle or non-running processes */
continue|continue;
if|if
condition|(
name|displaymode
operator|==
name|DISP_IO
operator|&&
operator|!
name|show_idle
operator|&&
name|p_io
operator|==
literal|0
condition|)
comment|/* skip processes that aren't doing I/O */
continue|continue;
if|if
condition|(
name|show_uid
operator|&&
name|pp
operator|->
name|ki_ruid
operator|!=
operator|(
name|uid_t
operator|)
name|sel
operator|->
name|uid
condition|)
comment|/* skip proc. that don't belong to the selected UID */
continue|continue;
comment|/* 		 * When not showing threads, take the first thread 		 * for output and add the fields that we can from 		 * the rest of the process's threads rather than 		 * using the system's mostly-broken KERN_PROC_PROC. 		 */
if|if
condition|(
name|sel
operator|->
name|thread
operator|||
name|prev_pp
operator|==
name|NULL
operator|||
name|prev_pp
operator|->
name|ki_pid
operator|!=
name|pp
operator|->
name|ki_pid
condition|)
block|{
operator|*
name|prefp
operator|++
operator|=
name|pp
expr_stmt|;
name|active_procs
operator|++
expr_stmt|;
name|prev_pp
operator|=
name|pp
expr_stmt|;
block|}
else|else
block|{
name|prev_pp
operator|->
name|ki_pctcpu
operator|+=
name|pp
operator|->
name|ki_pctcpu
expr_stmt|;
block|}
block|}
comment|/* if requested, sort the "interesting" processes */
if|if
condition|(
name|compare
operator|!=
name|NULL
condition|)
name|qsort
argument_list|(
name|pref
argument_list|,
name|active_procs
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|pref
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
comment|/* remember active and total counts */
name|si
operator|->
name|p_total
operator|=
name|total_procs
expr_stmt|;
name|si
operator|->
name|p_active
operator|=
name|pref_len
operator|=
name|active_procs
expr_stmt|;
comment|/* pass back a handle */
name|handle
operator|.
name|next_proc
operator|=
name|pref
expr_stmt|;
name|handle
operator|.
name|remaining
operator|=
name|active_procs
expr_stmt|;
return|return
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|handle
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|char
name|fmt
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static area where result is built */
end_comment

begin_function
name|char
modifier|*
name|format_next_process
parameter_list|(
name|caddr_t
name|handle
parameter_list|,
name|char
modifier|*
function_decl|(
modifier|*
name|get_userid
function_decl|)
parameter_list|(
name|int
parameter_list|)
parameter_list|,
name|int
name|flags
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
specifier|const
name|struct
name|kinfo_proc
modifier|*
name|oldp
decl_stmt|;
name|long
name|cputime
decl_stmt|;
name|double
name|pct
decl_stmt|;
name|struct
name|handle
modifier|*
name|hp
decl_stmt|;
name|char
name|status
index|[
literal|16
index|]
decl_stmt|;
name|int
name|state
decl_stmt|;
name|struct
name|rusage
name|ru
decl_stmt|,
modifier|*
name|rup
decl_stmt|;
name|long
name|p_tot
decl_stmt|,
name|s_tot
decl_stmt|;
name|char
modifier|*
name|proc_fmt
decl_stmt|,
name|thr_buf
index|[
literal|6
index|]
decl_stmt|,
name|jid_buf
index|[
literal|6
index|]
decl_stmt|;
name|char
modifier|*
name|cmdbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
modifier|*
name|args
decl_stmt|;
comment|/* find and remember the next proc structure */
name|hp
operator|=
operator|(
expr|struct
name|handle
operator|*
operator|)
name|handle
expr_stmt|;
name|pp
operator|=
operator|*
operator|(
name|hp
operator|->
name|next_proc
operator|++
operator|)
expr_stmt|;
name|hp
operator|->
name|remaining
operator|--
expr_stmt|;
comment|/* get the process's command name */
if|if
condition|(
operator|(
name|pp
operator|->
name|ki_sflag
operator|&
name|PS_INMEM
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 		 * Print swapped processes as<pname> 		 */
name|size_t
name|len
decl_stmt|;
name|len
operator|=
name|strlen
argument_list|(
name|pp
operator|->
name|ki_comm
argument_list|)
expr_stmt|;
if|if
condition|(
name|len
operator|>
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ki_comm
argument_list|)
operator|-
literal|3
condition|)
name|len
operator|=
sizeof|sizeof
argument_list|(
name|pp
operator|->
name|ki_comm
argument_list|)
operator|-
literal|3
expr_stmt|;
name|memmove
argument_list|(
name|pp
operator|->
name|ki_comm
operator|+
literal|1
argument_list|,
name|pp
operator|->
name|ki_comm
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|pp
operator|->
name|ki_comm
index|[
literal|0
index|]
operator|=
literal|'<'
expr_stmt|;
name|pp
operator|->
name|ki_comm
index|[
name|len
operator|+
literal|1
index|]
operator|=
literal|'>'
expr_stmt|;
name|pp
operator|->
name|ki_comm
index|[
name|len
operator|+
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
comment|/* 	 * Convert the process's runtime from microseconds to seconds.  This 	 * time includes the interrupt time although that is not wanted here. 	 * ps(1) is similarly sloppy. 	 */
name|cputime
operator|=
operator|(
name|pp
operator|->
name|ki_runtime
operator|+
literal|500000
operator|)
operator|/
literal|1000000
expr_stmt|;
comment|/* calculate the base for cpu percentages */
name|pct
operator|=
name|pctdouble
argument_list|(
name|pp
operator|->
name|ki_pctcpu
argument_list|)
expr_stmt|;
comment|/* generate "STATE" field */
switch|switch
condition|(
name|state
operator|=
name|pp
operator|->
name|ki_stat
condition|)
block|{
case|case
name|SRUN
case|:
if|if
condition|(
name|smpmode
operator|&&
name|pp
operator|->
name|ki_oncpu
operator|!=
literal|0xff
condition|)
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"CPU%d"
argument_list|,
name|pp
operator|->
name|ki_oncpu
argument_list|)
expr_stmt|;
else|else
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"RUN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SLOCK
case|:
if|if
condition|(
name|pp
operator|->
name|ki_kiflag
operator|&
name|KI_LOCKBLOCK
condition|)
block|{
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"*%.6s"
argument_list|,
name|pp
operator|->
name|ki_lockname
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
case|case
name|SSLEEP
case|:
if|if
condition|(
name|pp
operator|->
name|ki_wmesg
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"%.6s"
argument_list|,
name|pp
operator|->
name|ki_wmesg
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* FALLTHROUGH */
default|default:
if|if
condition|(
name|state
operator|>=
literal|0
operator|&&
name|state
operator|<
sizeof|sizeof
argument_list|(
name|state_abbrev
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
operator|*
name|state_abbrev
argument_list|)
condition|)
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"%.6s"
argument_list|,
name|state_abbrev
index|[
name|state
index|]
argument_list|)
expr_stmt|;
else|else
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"?%5d"
argument_list|,
name|state
argument_list|)
expr_stmt|;
break|break;
block|}
name|cmdbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|cmdlengthdelta
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmdbuf
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc(%d)"
argument_list|,
name|cmdlengthdelta
operator|+
literal|1
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
if|if
condition|(
operator|!
operator|(
name|flags
operator|&
name|FMT_SHOWARGS
operator|)
condition|)
block|{
name|snprintf
argument_list|(
name|cmdbuf
argument_list|,
name|cmdlengthdelta
argument_list|,
literal|"%s"
argument_list|,
name|pp
operator|->
name|ki_comm
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|pp
operator|->
name|ki_args
operator|==
name|NULL
operator|||
operator|(
name|args
operator|=
name|kvm_getargv
argument_list|(
name|kd
argument_list|,
name|pp
argument_list|,
name|cmdlengthdelta
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|!
operator|(
operator|*
name|args
operator|)
condition|)
name|snprintf
argument_list|(
name|cmdbuf
argument_list|,
name|cmdlengthdelta
argument_list|,
literal|"[%s]"
argument_list|,
name|pp
operator|->
name|ki_comm
argument_list|)
expr_stmt|;
else|else
block|{
name|char
modifier|*
name|src
decl_stmt|,
modifier|*
name|dst
decl_stmt|,
modifier|*
name|argbuf
decl_stmt|;
name|char
modifier|*
name|cmd
decl_stmt|;
name|size_t
name|argbuflen
decl_stmt|;
name|size_t
name|len
decl_stmt|;
name|argbuflen
operator|=
name|cmdlengthdelta
operator|*
literal|4
expr_stmt|;
name|argbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|argbuflen
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|argbuf
operator|==
name|NULL
condition|)
block|{
name|warn
argument_list|(
literal|"malloc(%d)"
argument_list|,
name|argbuflen
operator|+
literal|1
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
name|NULL
return|;
block|}
name|dst
operator|=
name|argbuf
expr_stmt|;
comment|/* Extract cmd name from argv */
name|cmd
operator|=
name|strrchr
argument_list|(
operator|*
name|args
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
if|if
condition|(
name|cmd
operator|==
name|NULL
condition|)
name|cmd
operator|=
operator|*
name|args
expr_stmt|;
else|else
name|cmd
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|(
name|src
operator|=
operator|*
name|args
operator|++
operator|)
operator|!=
name|NULL
condition|;
control|)
block|{
if|if
condition|(
operator|*
name|src
operator|==
literal|'\0'
condition|)
continue|continue;
name|len
operator|=
operator|(
name|argbuflen
operator|-
operator|(
name|dst
operator|-
name|argbuf
operator|)
operator|-
literal|1
operator|)
operator|/
literal|4
expr_stmt|;
name|strvisx
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|strlen
argument_list|(
name|src
argument_list|)
operator|<
name|len
condition|?
name|strlen
argument_list|(
name|src
argument_list|)
else|:
name|len
argument_list|,
name|VIS_NL
operator||
name|VIS_CSTYLE
argument_list|)
expr_stmt|;
while|while
condition|(
operator|*
name|dst
operator|!=
literal|'\0'
condition|)
name|dst
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|argbuflen
operator|-
operator|(
name|dst
operator|-
name|argbuf
operator|)
operator|-
literal|1
operator|)
operator|/
literal|4
operator|>
literal|0
condition|)
operator|*
name|dst
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add delimiting space */
block|}
if|if
condition|(
name|dst
operator|!=
name|argbuf
operator|&&
name|dst
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
condition|)
name|dst
operator|--
expr_stmt|;
operator|*
name|dst
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|cmd
argument_list|,
name|pp
operator|->
name|ki_comm
argument_list|)
operator|!=
literal|0
condition|)
name|snprintf
argument_list|(
name|cmdbuf
argument_list|,
name|cmdlengthdelta
argument_list|,
literal|"%s (%s)"
argument_list|,
name|argbuf
argument_list|, \
name|pp
operator|->
name|ki_comm
argument_list|)
expr_stmt|;
else|else
name|strlcpy
argument_list|(
name|cmdbuf
argument_list|,
name|argbuf
argument_list|,
name|cmdlengthdelta
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|argbuf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ps
operator|.
name|jail
operator|==
literal|0
condition|)
name|jid_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|jid_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|jid_buf
argument_list|)
argument_list|,
literal|" %*d"
argument_list|,
sizeof|sizeof
argument_list|(
name|jid_buf
argument_list|)
operator|-
literal|3
argument_list|,
name|pp
operator|->
name|ki_jid
argument_list|)
expr_stmt|;
if|if
condition|(
name|displaymode
operator|==
name|DISP_IO
condition|)
block|{
name|oldp
operator|=
name|get_old_proc
argument_list|(
name|pp
argument_list|)
expr_stmt|;
if|if
condition|(
name|oldp
operator|!=
name|NULL
condition|)
block|{
name|ru
operator|.
name|ru_inblock
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_inblock
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_inblock
expr_stmt|;
name|ru
operator|.
name|ru_oublock
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_oublock
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_oublock
expr_stmt|;
name|ru
operator|.
name|ru_majflt
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_majflt
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_majflt
expr_stmt|;
name|ru
operator|.
name|ru_nvcsw
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_nvcsw
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_nvcsw
expr_stmt|;
name|ru
operator|.
name|ru_nivcsw
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
operator|->
name|ru_nivcsw
operator|-
name|RU
argument_list|(
name|oldp
argument_list|)
operator|->
name|ru_nivcsw
expr_stmt|;
name|rup
operator|=
operator|&
name|ru
expr_stmt|;
block|}
else|else
block|{
name|rup
operator|=
name|RU
argument_list|(
name|pp
argument_list|)
expr_stmt|;
block|}
name|p_tot
operator|=
name|rup
operator|->
name|ru_inblock
operator|+
name|rup
operator|->
name|ru_oublock
operator|+
name|rup
operator|->
name|ru_majflt
expr_stmt|;
name|s_tot
operator|=
name|total_inblock
operator|+
name|total_oublock
operator|+
name|total_majflt
expr_stmt|;
name|sprintf
argument_list|(
name|fmt
argument_list|,
name|io_Proc_format
argument_list|,
name|pp
operator|->
name|ki_pid
argument_list|,
name|jid_buf
argument_list|,
name|namelength
argument_list|,
name|namelength
argument_list|,
call|(
modifier|*
name|get_userid
call|)
argument_list|(
name|pp
operator|->
name|ki_ruid
argument_list|)
argument_list|,
name|rup
operator|->
name|ru_nvcsw
argument_list|,
name|rup
operator|->
name|ru_nivcsw
argument_list|,
name|rup
operator|->
name|ru_inblock
argument_list|,
name|rup
operator|->
name|ru_oublock
argument_list|,
name|rup
operator|->
name|ru_majflt
argument_list|,
name|p_tot
argument_list|,
name|s_tot
operator|==
literal|0
condition|?
literal|0.0
else|:
operator|(
name|p_tot
operator|*
literal|100.0
operator|/
name|s_tot
operator|)
argument_list|,
name|screen_width
operator|>
name|cmdlengthdelta
condition|?
name|screen_width
operator|-
name|cmdlengthdelta
else|:
literal|0
argument_list|,
name|printable
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|fmt
operator|)
return|;
block|}
comment|/* format this entry */
name|proc_fmt
operator|=
name|smpmode
condition|?
name|smp_Proc_format
else|:
name|up_Proc_format
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|thread
operator|!=
literal|0
condition|)
name|thr_buf
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|snprintf
argument_list|(
name|thr_buf
argument_list|,
sizeof|sizeof
argument_list|(
name|thr_buf
argument_list|)
argument_list|,
literal|"%*d "
argument_list|,
sizeof|sizeof
argument_list|(
name|thr_buf
argument_list|)
operator|-
literal|2
argument_list|,
name|pp
operator|->
name|ki_numthreads
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|fmt
argument_list|,
name|proc_fmt
argument_list|,
name|pp
operator|->
name|ki_pid
argument_list|,
name|jid_buf
argument_list|,
name|namelength
argument_list|,
name|namelength
argument_list|,
call|(
modifier|*
name|get_userid
call|)
argument_list|(
name|pp
operator|->
name|ki_ruid
argument_list|)
argument_list|,
name|thr_buf
argument_list|,
name|pp
operator|->
name|ki_pri
operator|.
name|pri_level
operator|-
name|PZERO
argument_list|,
name|format_nice
argument_list|(
name|pp
argument_list|)
argument_list|,
name|format_k2
argument_list|(
name|PROCSIZE
argument_list|(
name|pp
argument_list|)
argument_list|)
argument_list|,
name|format_k2
argument_list|(
name|pagetok
argument_list|(
name|pp
operator|->
name|ki_rssize
argument_list|)
argument_list|)
argument_list|,
name|status
argument_list|,
name|smpmode
condition|?
name|pp
operator|->
name|ki_lastcpu
else|:
literal|0
argument_list|,
name|format_time
argument_list|(
name|cputime
argument_list|)
argument_list|,
name|ps
operator|.
name|wcpu
condition|?
literal|100.0
operator|*
name|weighted_cpu
argument_list|(
name|pct
argument_list|,
name|pp
argument_list|)
else|:
literal|100.0
operator|*
name|pct
argument_list|,
name|screen_width
operator|>
name|cmdlengthdelta
condition|?
name|screen_width
operator|-
name|cmdlengthdelta
else|:
literal|0
argument_list|,
name|printable
argument_list|(
name|cmdbuf
argument_list|)
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|cmdbuf
argument_list|)
expr_stmt|;
comment|/* return the result */
return|return
operator|(
name|fmt
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|getsysctl
parameter_list|(
specifier|const
name|char
modifier|*
name|name
parameter_list|,
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|len
parameter_list|)
block|{
name|size_t
name|nlen
init|=
name|len
decl_stmt|;
if|if
condition|(
name|sysctlbyname
argument_list|(
name|name
argument_list|,
name|ptr
argument_list|,
operator|&
name|nlen
argument_list|,
name|NULL
argument_list|,
literal|0
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: sysctl(%s...) failed: %s\n"
argument_list|,
name|name
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|nlen
operator|!=
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: sysctl(%s...) expected %lu, got %lu\n"
argument_list|,
name|name
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|len
argument_list|,
operator|(
name|unsigned
name|long
operator|)
name|nlen
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
specifier|const
name|char
modifier|*
name|format_nice
parameter_list|(
specifier|const
name|struct
name|kinfo_proc
modifier|*
name|pp
parameter_list|)
block|{
specifier|const
name|char
modifier|*
name|fifo
decl_stmt|,
modifier|*
name|kthread
decl_stmt|;
name|int
name|rtpri
decl_stmt|;
specifier|static
name|char
name|nicebuf
index|[
literal|4
operator|+
literal|1
index|]
decl_stmt|;
name|fifo
operator|=
name|PRI_NEED_RR
argument_list|(
name|pp
operator|->
name|ki_pri
operator|.
name|pri_class
argument_list|)
condition|?
literal|""
else|:
literal|"F"
expr_stmt|;
name|kthread
operator|=
operator|(
name|pp
operator|->
name|ki_flag
operator|&
name|P_KTHREAD
operator|)
condition|?
literal|"k"
else|:
literal|""
expr_stmt|;
switch|switch
condition|(
name|PRI_BASE
argument_list|(
name|pp
operator|->
name|ki_pri
operator|.
name|pri_class
argument_list|)
condition|)
block|{
case|case
name|PRI_ITHD
case|:
return|return
operator|(
literal|"-"
operator|)
return|;
case|case
name|PRI_REALTIME
case|:
name|rtpri
operator|=
name|pp
operator|->
name|ki_pri
operator|.
name|pri_level
operator|-
name|PRI_MIN_REALTIME
expr_stmt|;
name|snprintf
argument_list|(
name|nicebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nicebuf
argument_list|)
argument_list|,
literal|"%sr%d%s"
argument_list|,
name|kthread
argument_list|,
name|rtpri
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRI_TIMESHARE
case|:
if|if
condition|(
name|pp
operator|->
name|ki_flag
operator|&
name|P_KTHREAD
condition|)
return|return
operator|(
literal|"-"
operator|)
return|;
name|snprintf
argument_list|(
name|nicebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nicebuf
argument_list|)
argument_list|,
literal|"%d"
argument_list|,
name|pp
operator|->
name|ki_nice
operator|-
name|NZERO
argument_list|)
expr_stmt|;
break|break;
case|case
name|PRI_IDLE
case|:
name|rtpri
operator|=
name|pp
operator|->
name|ki_pri
operator|.
name|pri_level
operator|-
name|PRI_MIN_IDLE
expr_stmt|;
name|snprintf
argument_list|(
name|nicebuf
argument_list|,
sizeof|sizeof
argument_list|(
name|nicebuf
argument_list|)
argument_list|,
literal|"%si%d%s"
argument_list|,
name|kthread
argument_list|,
name|rtpri
argument_list|,
name|fifo
argument_list|)
expr_stmt|;
break|break;
default|default:
return|return
operator|(
literal|"?"
operator|)
return|;
block|}
return|return
operator|(
name|nicebuf
operator|)
return|;
block|}
end_function

begin_comment
comment|/* comparison routines for qsort */
end_comment

begin_function
specifier|static
name|int
name|compare_pid
parameter_list|(
specifier|const
name|void
modifier|*
name|p1
parameter_list|,
specifier|const
name|void
modifier|*
name|p2
parameter_list|)
block|{
specifier|const
name|struct
name|kinfo_proc
modifier|*
specifier|const
modifier|*
name|pp1
init|=
name|p1
decl_stmt|;
specifier|const
name|struct
name|kinfo_proc
modifier|*
specifier|const
modifier|*
name|pp2
init|=
name|p2
decl_stmt|;
if|if
condition|(
operator|(
operator|*
name|pp2
operator|)
operator|->
name|ki_pid
operator|<
literal|0
operator|||
operator|(
operator|*
name|pp1
operator|)
operator|->
name|ki_pid
operator|<
literal|0
condition|)
name|abort
argument_list|()
expr_stmt|;
return|return
operator|(
operator|(
operator|*
name|pp1
operator|)
operator|->
name|ki_pid
operator|-
operator|(
operator|*
name|pp2
operator|)
operator|->
name|ki_pid
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  proc_compare - comparison function for "qsort"  *	Compares the resource consumption of two processes using five  *	distinct keys.  The keys (in descending order of importance) are:  *	percent cpu, cpu ticks, state, resident set size, total virtual  *	memory usage.  The process states are ordered as follows (from least  *	to most important):  WAIT, zombie, sleep, stop, start, run.  The  *	array declaration below maps a process state index into a number  *	that reflects this ordering.  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sorted_state
index|[]
init|=
block|{
literal|0
block|,
comment|/* not used		*/
literal|3
block|,
comment|/* sleep		*/
literal|1
block|,
comment|/* ABANDONED (WAIT)	*/
literal|6
block|,
comment|/* run			*/
literal|5
block|,
comment|/* start		*/
literal|2
block|,
comment|/* zombie		*/
literal|4
comment|/* stop			*/
block|}
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|ORDERKEY_PCTCPU
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	long diff; \ 	if (ps.wcpu) \ 		diff = floor(1.0E6 * weighted_cpu(pctdouble((b)->ki_pctcpu), \ 		    (b))) - \ 		    floor(1.0E6 * weighted_cpu(pctdouble((a)->ki_pctcpu), \ 		    (a))); \ 	else \ 		diff = (long)(b)->ki_pctcpu - (long)(a)->ki_pctcpu; \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_CPTICKS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	int64_t diff = (int64_t)(b)->ki_runtime - (int64_t)(a)->ki_runtime; \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_STATE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	int diff = sorted_state[(b)->ki_stat] - sorted_state[(a)->ki_stat]; \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_PRIO
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	int diff = (int)(b)->ki_pri.pri_level - (int)(a)->ki_pri.pri_level; \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_THREADS
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	int diff = (int)(b)->ki_numthreads - (int)(a)->ki_numthreads; \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_RSSIZE
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	long diff = (long)(b)->ki_rssize - (long)(a)->ki_rssize; \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_MEM
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	long diff = (long)PROCSIZE((b)) - (long)PROCSIZE((a)); \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_define
define|#
directive|define
name|ORDERKEY_JID
parameter_list|(
name|a
parameter_list|,
name|b
parameter_list|)
value|do { \ 	int diff = (int)(b)->ki_jid - (int)(a)->ki_jid; \ 	if (diff != 0) \ 		return (diff> 0 ? 1 : -1); \ } while (0)
end_define

begin_comment
comment|/* compare_cpu - the comparison function for sorting by cpu percentage */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|ORDER
name|compare_cpu
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
else|#
directive|else
function|proc_compare
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|ORDERKEY_PCTCPU
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_CPTICKS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_STATE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PRIO
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_RSSIZE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_MEM
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ORDER
end_ifdef

begin_comment
comment|/* "cpu" compare routines */
end_comment

begin_decl_stmt
name|int
name|compare_size
argument_list|()
decl_stmt|,
name|compare_res
argument_list|()
decl_stmt|,
name|compare_time
argument_list|()
decl_stmt|,
name|compare_prio
argument_list|()
decl_stmt|,
name|compare_threads
argument_list|()
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * "io" compare routines.  Context switches aren't i/o, but are displayed  * on the "io" display.  */
end_comment

begin_decl_stmt
name|int
name|compare_iototal
argument_list|()
decl_stmt|,
name|compare_ioread
argument_list|()
decl_stmt|,
name|compare_iowrite
argument_list|()
decl_stmt|,
name|compare_iofault
argument_list|()
decl_stmt|,
name|compare_vcsw
argument_list|()
decl_stmt|,
name|compare_ivcsw
argument_list|()
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compares
index|[]
function_decl|)
parameter_list|()
init|=
block|{
name|compare_cpu
operator|,
function_decl|compare_size
operator|,
function_decl|compare_res
operator|,
function_decl|compare_time
operator|,
function_decl|compare_prio
operator|,
function_decl|compare_threads
operator|,
function_decl|compare_iototal
operator|,
function_decl|compare_ioread
operator|,
function_decl|compare_iowrite
operator|,
function_decl|compare_iofault
operator|,
function_decl|compare_vcsw
operator|,
function_decl|compare_ivcsw
operator|,
function_decl|compare_jid
operator|,
function_decl|NULL
end_function_decl

begin_comment
unit|};
comment|/* compare_size - the comparison function for sorting by total memory usage */
end_comment

begin_function
name|int
name|compare_size
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|ORDERKEY_MEM
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_RSSIZE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PCTCPU
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_CPTICKS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_STATE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PRIO
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_res - the comparison function for sorting by resident set size */
end_comment

begin_function
name|int
name|compare_res
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|ORDERKEY_RSSIZE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_MEM
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PCTCPU
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_CPTICKS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_STATE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PRIO
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_time - the comparison function for sorting by total cpu time */
end_comment

begin_function
name|int
name|compare_time
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|ORDERKEY_CPTICKS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PCTCPU
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_STATE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PRIO
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_RSSIZE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_MEM
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_prio - the comparison function for sorting by priority */
end_comment

begin_function
name|int
name|compare_prio
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|ORDERKEY_PRIO
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_CPTICKS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PCTCPU
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_STATE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_RSSIZE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_MEM
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_threads - the comparison function for sorting by threads */
end_comment

begin_function
name|int
name|compare_threads
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|ORDERKEY_THREADS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PCTCPU
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_CPTICKS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_STATE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PRIO
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_RSSIZE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_MEM
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/* compare_jid - the comparison function for sorting by jid */
end_comment

begin_function
specifier|static
name|int
name|compare_jid
parameter_list|(
specifier|const
name|void
modifier|*
name|arg1
parameter_list|,
specifier|const
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|ORDERKEY_JID
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PCTCPU
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_CPTICKS
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_STATE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_PRIO
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_RSSIZE
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
name|ORDERKEY_MEM
argument_list|(
name|p1
argument_list|,
name|p2
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ORDER */
end_comment

begin_comment
comment|/* assorted comparison functions for sorting by i/o */
end_comment

begin_function
name|int
ifdef|#
directive|ifdef
name|ORDER
name|compare_iototal
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
else|#
directive|else
function|io_compare
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
endif|#
directive|endif
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
return|return
operator|(
name|get_io_total
argument_list|(
name|p2
argument_list|)
operator|-
name|get_io_total
argument_list|(
name|p1
argument_list|)
operator|)
return|;
block|}
end_function

begin_ifdef
ifdef|#
directive|ifdef
name|ORDER
end_ifdef

begin_function
name|int
name|compare_ioread
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|long
name|dummy
decl_stmt|,
name|inp1
decl_stmt|,
name|inp2
decl_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p1
argument_list|,
operator|&
name|inp1
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p2
argument_list|,
operator|&
name|inp2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
return|return
operator|(
name|inp2
operator|-
name|inp1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|compare_iowrite
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|long
name|dummy
decl_stmt|,
name|oup1
decl_stmt|,
name|oup2
decl_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p1
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|oup1
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|oup2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
return|return
operator|(
name|oup2
operator|-
name|oup1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|compare_iofault
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|long
name|dummy
decl_stmt|,
name|flp1
decl_stmt|,
name|flp2
decl_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p1
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|flp1
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|flp2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
return|return
operator|(
name|flp2
operator|-
name|flp1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|compare_vcsw
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|long
name|dummy
decl_stmt|,
name|flp1
decl_stmt|,
name|flp2
decl_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p1
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|flp1
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|flp2
argument_list|,
operator|&
name|dummy
argument_list|)
expr_stmt|;
return|return
operator|(
name|flp2
operator|-
name|flp1
operator|)
return|;
block|}
end_function

begin_function
name|int
name|compare_ivcsw
parameter_list|(
name|void
modifier|*
name|arg1
parameter_list|,
name|void
modifier|*
name|arg2
parameter_list|)
block|{
name|struct
name|kinfo_proc
modifier|*
name|p1
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg1
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|p2
init|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|arg2
decl_stmt|;
name|long
name|dummy
decl_stmt|,
name|flp1
decl_stmt|,
name|flp2
decl_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p1
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|flp1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|get_io_stats
argument_list|(
name|p2
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|dummy
argument_list|,
operator|&
name|flp2
argument_list|)
expr_stmt|;
return|return
operator|(
name|flp2
operator|-
name|flp1
operator|)
return|;
block|}
end_function

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* ORDER */
end_comment

begin_comment
comment|/*  * proc_owner(pid) - returns the uid that owns process "pid", or -1 if  *		the process does not exist.  *		It is EXTREMLY IMPORTANT that this function work correctly.  *		If top runs setuid root (as in SVR4), then this function  *		is the only thing that stands in the way of a serious  *		security problem.  It validates requests for the "kill"  *		and "renice" commands.  */
end_comment

begin_function
name|int
name|proc_owner
parameter_list|(
name|int
name|pid
parameter_list|)
block|{
name|int
name|cnt
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|prefp
decl_stmt|;
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
name|prefp
operator|=
name|pref
expr_stmt|;
name|cnt
operator|=
name|pref_len
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
name|pp
operator|=
operator|*
name|prefp
operator|++
expr_stmt|;
if|if
condition|(
name|pp
operator|->
name|ki_pid
operator|==
operator|(
name|pid_t
operator|)
name|pid
condition|)
return|return
operator|(
operator|(
name|int
operator|)
name|pp
operator|->
name|ki_ruid
operator|)
return|;
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|int
name|swapmode
parameter_list|(
name|int
modifier|*
name|retavail
parameter_list|,
name|int
modifier|*
name|retfree
parameter_list|)
block|{
name|int
name|n
decl_stmt|;
name|int
name|pagesize
init|=
name|getpagesize
argument_list|()
decl_stmt|;
name|struct
name|kvm_swap
name|swapary
index|[
literal|1
index|]
decl_stmt|;
operator|*
name|retavail
operator|=
literal|0
expr_stmt|;
operator|*
name|retfree
operator|=
literal|0
expr_stmt|;
define|#
directive|define
name|CONVERT
parameter_list|(
name|v
parameter_list|)
value|((quad_t)(v) * pagesize / 1024)
name|n
operator|=
name|kvm_getswapinfo
argument_list|(
name|kd
argument_list|,
name|swapary
argument_list|,
literal|1
argument_list|,
literal|0
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
operator|||
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
operator|==
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
operator|*
name|retavail
operator|=
name|CONVERT
argument_list|(
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
argument_list|)
expr_stmt|;
operator|*
name|retfree
operator|=
name|CONVERT
argument_list|(
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
operator|-
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_used
argument_list|)
expr_stmt|;
name|n
operator|=
call|(
name|int
call|)
argument_list|(
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_used
operator|*
literal|100.0
operator|/
name|swapary
index|[
literal|0
index|]
operator|.
name|ksw_total
argument_list|)
expr_stmt|;
return|return
operator|(
name|n
operator|)
return|;
block|}
end_function

end_unit

