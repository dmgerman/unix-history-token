begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * top - a top users display for Unix  *  * SYNOPSIS:  For FreeBSD-2.x system  *  * DESCRIPTION:  * Originally written for BSD4.4 system by Christos Zoulas.  * Ported to FreeBSD 2.x by Steven Wallace&& Wolfram Schneider  *  * This is the machine-dependent module for FreeBSD 2.2  * Works for:  *	FreeBSD 2.2, and probably FreeBSD 2.1.x  *  * LIBS: -lkvm  *  * AUTHOR:  Christos Zoulas<christos@ee.cornell.edu>  *          Steven Wallace<swallace@freebsd.org>  *          Wolfram Schneider<wosch@FreeBSD.org>  *  * $Id: machine.c,v 1.3.2.2 1997/09/27 21:30:16 wosch Exp $  */
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/signal.h>
end_include

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|"os.h"
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<nlist.h>
end_include

begin_include
include|#
directive|include
file|<math.h>
end_include

begin_include
include|#
directive|include
file|<kvm.h>
end_include

begin_include
include|#
directive|include
file|<sys/errno.h>
end_include

begin_include
include|#
directive|include
file|<sys/sysctl.h>
end_include

begin_include
include|#
directive|include
file|<sys/dkstat.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/proc.h>
end_include

begin_include
include|#
directive|include
file|<sys/user.h>
end_include

begin_include
include|#
directive|include
file|<sys/vmmeter.h>
end_include

begin_include
include|#
directive|include
file|<sys/resource.h>
end_include

begin_include
include|#
directive|include
file|<sys/rtprio.h>
end_include

begin_comment
comment|/* Swap */
end_comment

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<sys/rlist.h>
end_include

begin_include
include|#
directive|include
file|<sys/conf.h>
end_include

begin_include
include|#
directive|include
file|<osreldate.h>
end_include

begin_comment
comment|/* for changes in kernel structures */
end_comment

begin_include
include|#
directive|include
file|"top.h"
end_include

begin_include
include|#
directive|include
file|"machine.h"
end_include

begin_decl_stmt
specifier|static
name|int
name|check_nlist
name|__P
argument_list|(
operator|(
expr|struct
name|nlist
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|getkval
name|__P
argument_list|(
operator|(
name|unsigned
name|long
operator|,
name|int
operator|*
operator|,
name|int
operator|,
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|char
modifier|*
name|printable
name|__P
argument_list|(
operator|(
name|char
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swapmode
name|__P
argument_list|(
operator|(
name|int
operator|*
name|retavail
operator|,
name|int
operator|*
name|retfree
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* get_process_info passes back a handle.  This is what it looks like: */
end_comment

begin_struct
struct|struct
name|handle
block|{
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|next_proc
decl_stmt|;
comment|/* points to next valid proc pointer */
name|int
name|remaining
decl_stmt|;
comment|/* number of pointers remaining */
block|}
struct|;
end_struct

begin_comment
comment|/* declarations for load_avg */
end_comment

begin_include
include|#
directive|include
file|"loadavg.h"
end_include

begin_define
define|#
directive|define
name|PP
parameter_list|(
name|pp
parameter_list|,
name|field
parameter_list|)
value|((pp)->kp_proc . field)
end_define

begin_define
define|#
directive|define
name|EP
parameter_list|(
name|pp
parameter_list|,
name|field
parameter_list|)
value|((pp)->kp_eproc . field)
end_define

begin_define
define|#
directive|define
name|VP
parameter_list|(
name|pp
parameter_list|,
name|field
parameter_list|)
value|((pp)->kp_eproc.e_vm . field)
end_define

begin_comment
comment|/* define what weighted cpu is.  */
end_comment

begin_define
define|#
directive|define
name|weighted_cpu
parameter_list|(
name|pct
parameter_list|,
name|pp
parameter_list|)
value|(PP((pp), p_swtime) == 0 ? 0.0 : \ 			 ((pct) / (1.0 - exp(PP((pp), p_swtime) * logcpu))))
end_define

begin_comment
comment|/* what we consider to be process size: */
end_comment

begin_define
define|#
directive|define
name|PROCSIZE
parameter_list|(
name|pp
parameter_list|)
value|(VP((pp), vm_tsize) + VP((pp), vm_dsize) + VP((pp), vm_ssize))
end_define

begin_comment
comment|/* definitions for indices in the nlist array */
end_comment

begin_decl_stmt
specifier|static
name|struct
name|nlist
name|nlst
index|[]
init|=
block|{
define|#
directive|define
name|X_CCPU
value|0
block|{
literal|"_ccpu"
block|}
block|,
comment|/* 0 */
define|#
directive|define
name|X_CP_TIME
value|1
block|{
literal|"_cp_time"
block|}
block|,
comment|/* 1 */
define|#
directive|define
name|X_HZ
value|2
block|{
literal|"_hz"
block|}
block|,
comment|/* 2 */
define|#
directive|define
name|X_STATHZ
value|3
block|{
literal|"_stathz"
block|}
block|,
comment|/* 3 */
define|#
directive|define
name|X_AVENRUN
value|4
block|{
literal|"_averunnable"
block|}
block|,
comment|/* 4 */
comment|/* Swap */
define|#
directive|define
name|VM_SWAPLIST
value|5
block|{
literal|"_swaplist"
block|}
block|,
comment|/* list of free swap areas */
define|#
directive|define
name|VM_SWDEVT
value|6
block|{
literal|"_swdevt"
block|}
block|,
comment|/* list of swap devices and sizes */
define|#
directive|define
name|VM_NSWAP
value|7
block|{
literal|"_nswap"
block|}
block|,
comment|/* size of largest swap device */
define|#
directive|define
name|VM_NSWDEV
value|8
block|{
literal|"_nswdev"
block|}
block|,
comment|/* number of swap devices */
define|#
directive|define
name|VM_DMMAX
value|9
block|{
literal|"_dmmax"
block|}
block|,
comment|/* maximum size of a swap block */
define|#
directive|define
name|X_BUFSPACE
value|10
block|{
literal|"_bufspace"
block|}
block|,
comment|/* K in buffer cache */
define|#
directive|define
name|X_CNT
value|11
block|{
literal|"_cnt"
block|}
block|,
comment|/* struct vmmeter cnt */
comment|/* Last pid */
define|#
directive|define
name|X_LASTPID
value|12
block|{
literal|"_nextpid"
block|}
block|,
block|{
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  *  These definitions control the format of the per-process area  */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|P_IDLEPROC
end_ifdef

begin_comment
comment|/* FreeBSD SMP kernel */
end_comment

begin_decl_stmt
specifier|static
name|char
name|header
index|[]
init|=
literal|"  PID X        PRI NICE SIZE   RES STATE C   TIME   WCPU    CPU COMMAND"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0123456   -- field to fill in starts at header+6 */
end_comment

begin_define
define|#
directive|define
name|UNAME_START
value|6
end_define

begin_define
define|#
directive|define
name|Proc_format
define|\
value|"%5d %-8.8s%3d%3d%7s %6s %-6.6s%1x%7s %5.2f%% %5.2f%% %.14s"
end_define

begin_else
else|#
directive|else
end_else

begin_comment
comment|/* Standard kernel */
end_comment

begin_decl_stmt
specifier|static
name|char
name|header
index|[]
init|=
literal|"  PID X        PRI NICE SIZE    RES STATE    TIME   WCPU    CPU COMMAND"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* 0123456   -- field to fill in starts at header+6 */
end_comment

begin_define
define|#
directive|define
name|UNAME_START
value|6
end_define

begin_define
define|#
directive|define
name|Proc_format
define|\
value|"%5d %-8.8s%3d %3d%7s %6s %-6.6s%7s %5.2f%% %5.2f%% %.14s"
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* process state names for the "STATE" column of the display */
end_comment

begin_comment
comment|/* the extra nulls in the string "run" are for adding a slash and    the processor number when needed */
end_comment

begin_decl_stmt
name|char
modifier|*
name|state_abbrev
index|[]
init|=
block|{
literal|""
block|,
literal|"START"
block|,
literal|"RUN\0\0\0"
block|,
literal|"SLEEP"
block|,
literal|"STOP"
block|,
literal|"ZOMB"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|kvm_t
modifier|*
name|kd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* values that we stash away in _init and use in later routines */
end_comment

begin_decl_stmt
specifier|static
name|double
name|logcpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are retrieved from the kernel in _init */
end_comment

begin_decl_stmt
specifier|static
name|long
name|hz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|load_avg
name|ccpu
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are offsets obtained via nlist and used in the get_ functions */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cp_time_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|avenrun_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|lastpid_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|lastpid
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|cnt_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|unsigned
name|long
name|bufspace_offset
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for calculating cpu state percentages */
end_comment

begin_decl_stmt
specifier|static
name|long
name|cp_time
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cp_old
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|cp_diff
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the process states */
end_comment

begin_decl_stmt
name|int
name|process_states
index|[
literal|6
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|procstatenames
index|[]
init|=
block|{
literal|""
block|,
literal|" starting, "
block|,
literal|" running, "
block|,
literal|" sleeping, "
block|,
literal|" stopped, "
block|,
literal|" zombie, "
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the cpu states */
end_comment

begin_decl_stmt
name|int
name|cpu_states
index|[
name|CPUSTATES
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|cpustatenames
index|[]
init|=
block|{
literal|"user"
block|,
literal|"nice"
block|,
literal|"system"
block|,
literal|"interrupt"
block|,
literal|"idle"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for detailing the memory statistics */
end_comment

begin_decl_stmt
name|int
name|memory_stats
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|memorynames
index|[]
init|=
block|{
literal|"K Active, "
block|,
literal|"K Inact, "
block|,
literal|"K Wired, "
block|,
literal|"K Cache, "
block|,
literal|"K Buf, "
block|,
literal|"K Free"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|swap_stats
index|[
literal|7
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|swapnames
index|[]
init|=
block|{
comment|/*   0           1            2           3            4       5 */
literal|"K Total, "
block|,
literal|"K Used, "
block|,
literal|"K Free, "
block|,
literal|"% Inuse, "
block|,
literal|"K In, "
block|,
literal|"K Out"
block|,
name|NULL
block|}
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for keeping track of the proc array */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nproc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|onproc
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|pref_len
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
name|pbase
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|pref
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these are for getting the memory statistics */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pageshift
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* log base 2 of the pagesize */
end_comment

begin_comment
comment|/* define pagetok in terms of pageshift */
end_comment

begin_define
define|#
directive|define
name|pagetok
parameter_list|(
name|size
parameter_list|)
value|((size)<< pageshift)
end_define

begin_comment
comment|/* useful externals */
end_comment

begin_function_decl
name|long
name|percentages
parameter_list|()
function_decl|;
end_function_decl

begin_function
name|int
name|machine_init
parameter_list|(
name|statics
parameter_list|)
name|struct
name|statics
modifier|*
name|statics
decl_stmt|;
block|{
specifier|register
name|int
name|i
init|=
literal|0
decl_stmt|;
specifier|register
name|int
name|pagesize
decl_stmt|;
if|if
condition|(
operator|(
name|kd
operator|=
name|kvm_open
argument_list|(
name|NULL
argument_list|,
name|NULL
argument_list|,
name|NULL
argument_list|,
name|O_RDONLY
argument_list|,
literal|"kvm_open"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
comment|/* get the list of symbols we want to access in the kernel */
operator|(
name|void
operator|)
name|kvm_nlist
argument_list|(
name|kd
argument_list|,
name|nlst
argument_list|)
expr_stmt|;
if|if
condition|(
name|nlst
index|[
literal|0
index|]
operator|.
name|n_type
operator|==
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: nlist failed\n"
argument_list|)
expr_stmt|;
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* make sure they were all found */
if|if
condition|(
name|i
operator|>
literal|0
operator|&&
name|check_nlist
argument_list|(
name|nlst
argument_list|)
operator|>
literal|0
condition|)
block|{
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
comment|/* get the symbol values out of kmem */
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|nlst
index|[
name|X_STATHZ
index|]
operator|.
name|n_value
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|hz
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|hz
argument_list|)
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|hz
condition|)
block|{
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|nlst
index|[
name|X_HZ
index|]
operator|.
name|n_value
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|hz
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|hz
argument_list|)
argument_list|,
name|nlst
index|[
name|X_HZ
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
block|}
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|nlst
index|[
name|X_CCPU
index|]
operator|.
name|n_value
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|ccpu
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|ccpu
argument_list|)
argument_list|,
name|nlst
index|[
name|X_CCPU
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
comment|/* stash away certain offsets for later use */
name|cp_time_offset
operator|=
name|nlst
index|[
name|X_CP_TIME
index|]
operator|.
name|n_value
expr_stmt|;
name|avenrun_offset
operator|=
name|nlst
index|[
name|X_AVENRUN
index|]
operator|.
name|n_value
expr_stmt|;
name|lastpid_offset
operator|=
name|nlst
index|[
name|X_LASTPID
index|]
operator|.
name|n_value
expr_stmt|;
name|cnt_offset
operator|=
name|nlst
index|[
name|X_CNT
index|]
operator|.
name|n_value
expr_stmt|;
name|bufspace_offset
operator|=
name|nlst
index|[
name|X_BUFSPACE
index|]
operator|.
name|n_value
expr_stmt|;
comment|/* this is used in calculating WCPU -- calculate it ahead of time */
name|logcpu
operator|=
name|log
argument_list|(
name|loaddouble
argument_list|(
name|ccpu
argument_list|)
argument_list|)
expr_stmt|;
name|pbase
operator|=
name|NULL
expr_stmt|;
name|pref
operator|=
name|NULL
expr_stmt|;
name|nproc
operator|=
literal|0
expr_stmt|;
name|onproc
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* get the page size with "getpagesize" and calculate pageshift from it */
name|pagesize
operator|=
name|getpagesize
argument_list|()
expr_stmt|;
name|pageshift
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|pagesize
operator|>
literal|1
condition|)
block|{
name|pageshift
operator|++
expr_stmt|;
name|pagesize
operator|>>=
literal|1
expr_stmt|;
block|}
comment|/* we only need the amount of log(2)1024 for our conversion */
name|pageshift
operator|-=
name|LOG1024
expr_stmt|;
comment|/* fill in the statics information */
name|statics
operator|->
name|procstate_names
operator|=
name|procstatenames
expr_stmt|;
name|statics
operator|->
name|cpustate_names
operator|=
name|cpustatenames
expr_stmt|;
name|statics
operator|->
name|memory_names
operator|=
name|memorynames
expr_stmt|;
name|statics
operator|->
name|swap_names
operator|=
name|swapnames
expr_stmt|;
comment|/* all done! */
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
name|char
modifier|*
name|format_header
parameter_list|(
name|uname_field
parameter_list|)
specifier|register
name|char
modifier|*
name|uname_field
decl_stmt|;
block|{
specifier|register
name|char
modifier|*
name|ptr
decl_stmt|;
name|ptr
operator|=
name|header
operator|+
name|UNAME_START
expr_stmt|;
while|while
condition|(
operator|*
name|uname_field
operator|!=
literal|'\0'
condition|)
block|{
operator|*
name|ptr
operator|++
operator|=
operator|*
name|uname_field
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|header
operator|)
return|;
block|}
end_function

begin_decl_stmt
specifier|static
name|int
name|swappgsin
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|swappgsout
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|extern
name|struct
name|timeval
name|timeout
decl_stmt|;
end_decl_stmt

begin_function
name|void
name|get_system_info
parameter_list|(
name|si
parameter_list|)
name|struct
name|system_info
modifier|*
name|si
decl_stmt|;
block|{
name|long
name|total
decl_stmt|;
name|load_avg
name|avenrun
index|[
literal|3
index|]
decl_stmt|;
comment|/* get the cp_time array */
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|cp_time_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
name|cp_time
argument_list|,
sizeof|sizeof
argument_list|(
name|cp_time
argument_list|)
argument_list|,
name|nlst
index|[
name|X_CP_TIME
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|avenrun_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
name|avenrun
argument_list|,
sizeof|sizeof
argument_list|(
name|avenrun
argument_list|)
argument_list|,
name|nlst
index|[
name|X_AVENRUN
index|]
operator|.
name|n_name
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|lastpid_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|lastpid
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|lastpid
argument_list|)
argument_list|,
literal|"!"
argument_list|)
expr_stmt|;
comment|/* convert load averages to doubles */
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|double
modifier|*
name|infoloadp
decl_stmt|;
name|load_avg
modifier|*
name|avenrunp
decl_stmt|;
ifdef|#
directive|ifdef
name|notyet
name|struct
name|loadavg
name|sysload
decl_stmt|;
name|int
name|size
decl_stmt|;
name|getkerninfo
argument_list|(
name|KINFO_LOADAVG
argument_list|,
operator|&
name|sysload
argument_list|,
operator|&
name|size
argument_list|,
literal|0
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|infoloadp
operator|=
name|si
operator|->
name|load_avg
expr_stmt|;
name|avenrunp
operator|=
name|avenrun
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
name|i
operator|++
control|)
block|{
ifdef|#
directive|ifdef
name|notyet
operator|*
name|infoloadp
operator|++
operator|=
operator|(
operator|(
name|double
operator|)
name|sysload
operator|.
name|ldavg
index|[
name|i
index|]
operator|)
operator|/
name|sysload
operator|.
name|fscale
expr_stmt|;
endif|#
directive|endif
operator|*
name|infoloadp
operator|++
operator|=
name|loaddouble
argument_list|(
operator|*
name|avenrunp
operator|++
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* convert cp_time counts to percentages */
name|total
operator|=
name|percentages
argument_list|(
name|CPUSTATES
argument_list|,
name|cpu_states
argument_list|,
name|cp_time
argument_list|,
name|cp_old
argument_list|,
name|cp_diff
argument_list|)
expr_stmt|;
comment|/* sum memory& swap statistics */
block|{
name|struct
name|vmmeter
name|sum
decl_stmt|;
specifier|static
name|unsigned
name|int
name|swap_delay
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|swapavail
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|swapfree
init|=
literal|0
decl_stmt|;
specifier|static
name|int
name|bufspace
init|=
literal|0
decl_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|cnt_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|sum
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|sum
argument_list|)
argument_list|,
literal|"_cnt"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|getkval
argument_list|(
name|bufspace_offset
argument_list|,
operator|(
name|int
operator|*
operator|)
operator|(
operator|&
name|bufspace
operator|)
argument_list|,
sizeof|sizeof
argument_list|(
name|bufspace
argument_list|)
argument_list|,
literal|"_bufspace"
argument_list|)
expr_stmt|;
comment|/* convert memory stats to Kbytes */
name|memory_stats
index|[
literal|0
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_active_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|1
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_inactive_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|2
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_wire_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|3
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_cache_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|4
index|]
operator|=
name|bufspace
operator|/
literal|1024
expr_stmt|;
name|memory_stats
index|[
literal|5
index|]
operator|=
name|pagetok
argument_list|(
name|sum
operator|.
name|v_free_count
argument_list|)
expr_stmt|;
name|memory_stats
index|[
literal|6
index|]
operator|=
operator|-
literal|1
expr_stmt|;
comment|/* first interval */
if|if
condition|(
name|swappgsin
operator|<
literal|0
condition|)
block|{
name|swap_stats
index|[
literal|4
index|]
operator|=
literal|0
expr_stmt|;
name|swap_stats
index|[
literal|5
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* compute differences between old and new swap statistic */
else|else
block|{
name|swap_stats
index|[
literal|4
index|]
operator|=
name|pagetok
argument_list|(
operator|(
operator|(
name|sum
operator|.
name|v_swappgsin
operator|-
name|swappgsin
operator|)
operator|)
argument_list|)
expr_stmt|;
name|swap_stats
index|[
literal|5
index|]
operator|=
name|pagetok
argument_list|(
operator|(
operator|(
name|sum
operator|.
name|v_swappgsout
operator|-
name|swappgsout
operator|)
operator|)
argument_list|)
expr_stmt|;
block|}
name|swappgsin
operator|=
name|sum
operator|.
name|v_swappgsin
expr_stmt|;
name|swappgsout
operator|=
name|sum
operator|.
name|v_swappgsout
expr_stmt|;
comment|/* call CPU heavy swapmode() only for changes */
if|if
condition|(
name|swap_stats
index|[
literal|4
index|]
operator|>
literal|0
operator|||
name|swap_stats
index|[
literal|5
index|]
operator|>
literal|0
operator|||
name|swap_delay
operator|==
literal|0
condition|)
block|{
name|swap_stats
index|[
literal|3
index|]
operator|=
name|swapmode
argument_list|(
operator|&
name|swapavail
argument_list|,
operator|&
name|swapfree
argument_list|)
expr_stmt|;
name|swap_stats
index|[
literal|0
index|]
operator|=
name|swapavail
expr_stmt|;
name|swap_stats
index|[
literal|1
index|]
operator|=
name|swapavail
operator|-
name|swapfree
expr_stmt|;
name|swap_stats
index|[
literal|2
index|]
operator|=
name|swapfree
expr_stmt|;
block|}
name|swap_delay
operator|=
literal|1
expr_stmt|;
name|swap_stats
index|[
literal|6
index|]
operator|=
operator|-
literal|1
expr_stmt|;
block|}
comment|/* set arrays and strings */
name|si
operator|->
name|cpustates
operator|=
name|cpu_states
expr_stmt|;
name|si
operator|->
name|memory
operator|=
name|memory_stats
expr_stmt|;
name|si
operator|->
name|swap
operator|=
name|swap_stats
expr_stmt|;
if|if
condition|(
name|lastpid
operator|>
literal|0
condition|)
block|{
name|si
operator|->
name|last_pid
operator|=
name|lastpid
expr_stmt|;
block|}
else|else
block|{
name|si
operator|->
name|last_pid
operator|=
operator|-
literal|1
expr_stmt|;
block|}
block|}
end_function

begin_decl_stmt
specifier|static
name|struct
name|handle
name|handle
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|caddr_t
name|get_process_info
argument_list|(
name|si
argument_list|,
name|sel
argument_list|,
name|compare
argument_list|)
decl|struct
name|system_info
modifier|*
name|si
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|struct
name|process_select
modifier|*
name|sel
decl_stmt|;
end_decl_stmt

begin_function_decl
name|int
function_decl|(
modifier|*
name|compare
function_decl|)
parameter_list|()
function_decl|;
end_function_decl

begin_block
block|{
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|int
name|total_procs
decl_stmt|;
specifier|register
name|int
name|active_procs
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|prefp
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
comment|/* these are copied out of sel for speed */
name|int
name|show_idle
decl_stmt|;
name|int
name|show_system
decl_stmt|;
name|int
name|show_uid
decl_stmt|;
name|int
name|show_command
decl_stmt|;
name|pbase
operator|=
name|kvm_getprocs
argument_list|(
name|kd
argument_list|,
name|KERN_PROC_ALL
argument_list|,
literal|0
argument_list|,
operator|&
name|nproc
argument_list|)
expr_stmt|;
if|if
condition|(
name|nproc
operator|>
name|onproc
condition|)
name|pref
operator|=
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|realloc
argument_list|(
name|pref
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
operator|*
argument_list|)
operator|*
operator|(
name|onproc
operator|=
name|nproc
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|pref
operator|==
name|NULL
operator|||
name|pbase
operator|==
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: Out of memory.\n"
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
comment|/* get a pointer to the states summary array */
name|si
operator|->
name|procstates
operator|=
name|process_states
expr_stmt|;
comment|/* set up flags which define what we are going to select */
name|show_idle
operator|=
name|sel
operator|->
name|idle
expr_stmt|;
name|show_system
operator|=
name|sel
operator|->
name|system
expr_stmt|;
name|show_uid
operator|=
name|sel
operator|->
name|uid
operator|!=
operator|-
literal|1
expr_stmt|;
name|show_command
operator|=
name|sel
operator|->
name|command
operator|!=
name|NULL
expr_stmt|;
comment|/* count up process states and get pointers to interesting procs */
name|total_procs
operator|=
literal|0
expr_stmt|;
name|active_procs
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
operator|(
name|char
operator|*
operator|)
name|process_states
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|process_states
argument_list|)
argument_list|)
expr_stmt|;
name|prefp
operator|=
name|pref
expr_stmt|;
for|for
control|(
name|pp
operator|=
name|pbase
operator|,
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nproc
condition|;
name|pp
operator|++
operator|,
name|i
operator|++
control|)
block|{
comment|/* 	 *  Place pointers to each valid proc structure in pref[]. 	 *  Process slots that are actually in use have a non-zero 	 *  status field.  Processes with P_SYSTEM set are system 	 *  processes---these get ignored unless show_sysprocs is set. 	 */
if|if
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
operator|!=
literal|0
operator|&&
operator|(
name|show_system
operator|||
operator|(
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_flag
argument_list|)
operator|&
name|P_SYSTEM
operator|)
operator|==
literal|0
operator|)
operator|)
condition|)
block|{
name|total_procs
operator|++
expr_stmt|;
name|process_states
index|[
operator|(
name|unsigned
name|char
operator|)
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
index|]
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
operator|!=
name|SZOMB
operator|)
operator|&&
operator|(
name|show_idle
operator|||
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pctcpu
argument_list|)
operator|!=
literal|0
operator|)
operator|||
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
operator|==
name|SRUN
operator|)
operator|)
operator|&&
operator|(
operator|!
name|show_uid
operator|||
name|EP
argument_list|(
name|pp
argument_list|,
name|e_pcred
operator|.
name|p_ruid
argument_list|)
operator|==
operator|(
name|uid_t
operator|)
name|sel
operator|->
name|uid
operator|)
condition|)
block|{
operator|*
name|prefp
operator|++
operator|=
name|pp
expr_stmt|;
name|active_procs
operator|++
expr_stmt|;
block|}
block|}
block|}
comment|/* if requested, sort the "interesting" processes */
if|if
condition|(
name|compare
operator|!=
name|NULL
condition|)
block|{
name|qsort
argument_list|(
operator|(
name|char
operator|*
operator|)
name|pref
argument_list|,
name|active_procs
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|kinfo_proc
operator|*
argument_list|)
argument_list|,
name|compare
argument_list|)
expr_stmt|;
block|}
comment|/* remember active and total counts */
name|si
operator|->
name|p_total
operator|=
name|total_procs
expr_stmt|;
name|si
operator|->
name|p_active
operator|=
name|pref_len
operator|=
name|active_procs
expr_stmt|;
comment|/* pass back a handle */
name|handle
operator|.
name|next_proc
operator|=
name|pref
expr_stmt|;
name|handle
operator|.
name|remaining
operator|=
name|active_procs
expr_stmt|;
return|return
operator|(
operator|(
name|caddr_t
operator|)
operator|&
name|handle
operator|)
return|;
block|}
end_block

begin_decl_stmt
name|char
name|fmt
index|[
literal|128
index|]
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* static area where result is built */
end_comment

begin_function
name|char
modifier|*
name|format_next_process
parameter_list|(
name|handle
parameter_list|,
name|get_userid
parameter_list|)
name|caddr_t
name|handle
decl_stmt|;
function|char *
parameter_list|(
function|*get_userid
end_function

begin_expr_stmt
unit|)
operator|(
operator|)
expr_stmt|;
end_expr_stmt

begin_block
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
specifier|register
name|long
name|cputime
decl_stmt|;
specifier|register
name|double
name|pct
decl_stmt|;
name|struct
name|handle
modifier|*
name|hp
decl_stmt|;
name|char
name|status
index|[
literal|16
index|]
decl_stmt|;
comment|/* find and remember the next proc structure */
name|hp
operator|=
operator|(
expr|struct
name|handle
operator|*
operator|)
name|handle
expr_stmt|;
name|pp
operator|=
operator|*
operator|(
name|hp
operator|->
name|next_proc
operator|++
operator|)
expr_stmt|;
name|hp
operator|->
name|remaining
operator|--
expr_stmt|;
comment|/* get the process's user struct and set cputime */
if|if
condition|(
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_flag
argument_list|)
operator|&
name|P_INMEM
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* 	 * Print swapped processes as<pname> 	 */
name|char
modifier|*
name|comm
init|=
name|PP
argument_list|(
name|pp
argument_list|,
name|p_comm
argument_list|)
decl_stmt|;
define|#
directive|define
name|COMSIZ
value|sizeof(PP(pp, p_comm))
name|char
name|buf
index|[
name|COMSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
name|buf
argument_list|,
name|comm
argument_list|,
name|COMSIZ
argument_list|)
expr_stmt|;
name|comm
index|[
literal|0
index|]
operator|=
literal|'<'
expr_stmt|;
operator|(
name|void
operator|)
name|strncpy
argument_list|(
operator|&
name|comm
index|[
literal|1
index|]
argument_list|,
name|buf
argument_list|,
name|COMSIZ
operator|-
literal|2
argument_list|)
expr_stmt|;
name|comm
index|[
name|COMSIZ
operator|-
literal|2
index|]
operator|=
literal|'\0'
expr_stmt|;
operator|(
name|void
operator|)
name|strncat
argument_list|(
name|comm
argument_list|,
literal|">"
argument_list|,
name|COMSIZ
operator|-
literal|1
argument_list|)
expr_stmt|;
name|comm
index|[
name|COMSIZ
operator|-
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
if|#
directive|if
literal|0
comment|/* This does not produce the correct results */
block|cputime = PP(pp, p_uticks) + PP(pp, p_sticks) + PP(pp, p_iticks);
endif|#
directive|endif
name|cputime
operator|=
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtime
argument_list|)
operator|.
name|tv_sec
expr_stmt|;
comment|/* This does not count interrupts */
comment|/* calculate the base for cpu percentages */
name|pct
operator|=
name|pctdouble
argument_list|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pctcpu
argument_list|)
argument_list|)
expr_stmt|;
comment|/* generate "STATE" field */
switch|switch
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
condition|)
block|{
case|case
name|SRUN
case|:
ifdef|#
directive|ifdef
name|P_IDLEPROC
comment|/* FreeBSD SMP kernel */
if|if
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_oncpu
argument_list|)
operator|>=
literal|0
condition|)
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"CPU%d"
argument_list|,
name|PP
argument_list|(
name|pp
argument_list|,
name|p_oncpu
argument_list|)
argument_list|)
expr_stmt|;
else|else
endif|#
directive|endif
name|strcpy
argument_list|(
name|status
argument_list|,
literal|"RUN"
argument_list|)
expr_stmt|;
break|break;
case|case
name|SSLEEP
case|:
if|if
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_wmesg
argument_list|)
operator|!=
name|NULL
condition|)
block|{
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"%.6s"
argument_list|,
name|EP
argument_list|(
name|pp
argument_list|,
name|e_wmesg
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* fall through */
default|default:
name|sprintf
argument_list|(
name|status
argument_list|,
literal|"%.6s"
argument_list|,
name|state_abbrev
index|[
operator|(
name|unsigned
name|char
operator|)
name|PP
argument_list|(
name|pp
argument_list|,
name|p_stat
argument_list|)
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
comment|/* format this entry */
name|sprintf
argument_list|(
name|fmt
argument_list|,
name|Proc_format
argument_list|,
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pid
argument_list|)
argument_list|,
call|(
modifier|*
name|get_userid
call|)
argument_list|(
name|EP
argument_list|(
name|pp
argument_list|,
name|e_pcred
operator|.
name|p_ruid
argument_list|)
argument_list|)
argument_list|,
name|PP
argument_list|(
name|pp
argument_list|,
name|p_priority
argument_list|)
operator|-
name|PZERO
argument_list|,
comment|/* 	     * normal time      -> nice value -20 - +20  	     * real time 0 - 31 -> nice value -52 - -21 	     * idle time 0 - 31 -> nice value +21 - +52              */
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|type
argument_list|)
operator|==
name|RTP_PRIO_NORMAL
condition|?
name|PP
argument_list|(
name|pp
argument_list|,
name|p_nice
argument_list|)
operator|-
name|NZERO
else|:
operator|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|type
argument_list|)
operator|==
name|RTP_PRIO_REALTIME
condition|?
operator|(
name|PRIO_MIN
operator|-
literal|1
operator|-
name|RTP_PRIO_MAX
operator|+
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|prio
argument_list|)
operator|)
else|:
operator|(
name|PRIO_MAX
operator|+
literal|1
operator|+
name|PP
argument_list|(
name|pp
argument_list|,
name|p_rtprio
operator|.
name|prio
argument_list|)
operator|)
operator|)
operator|)
argument_list|,
name|format_k2
argument_list|(
name|pagetok
argument_list|(
name|PROCSIZE
argument_list|(
name|pp
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|format_k2
argument_list|(
name|pagetok
argument_list|(
name|VP
argument_list|(
name|pp
argument_list|,
name|vm_rssize
argument_list|)
argument_list|)
argument_list|)
argument_list|,
name|status
argument_list|,
ifdef|#
directive|ifdef
name|P_IDLEPROC
comment|/* FreeBSD SMP kernel */
name|PP
argument_list|(
name|pp
argument_list|,
name|p_lastcpu
argument_list|)
argument_list|,
endif|#
directive|endif
name|format_time
argument_list|(
name|cputime
argument_list|)
argument_list|,
literal|10000.0
operator|*
name|weighted_cpu
argument_list|(
name|pct
argument_list|,
name|pp
argument_list|)
operator|/
name|hz
argument_list|,
literal|10000.0
operator|*
name|pct
operator|/
name|hz
argument_list|,
name|printable
argument_list|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_comm
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
comment|/* return the result */
return|return
operator|(
name|fmt
operator|)
return|;
block|}
end_block

begin_comment
comment|/*  * check_nlist(nlst) - checks the nlist to see if any symbols were not  *		found.  For every symbol that was not found, a one-line  *		message is printed to stderr.  The routine returns the  *		number of symbols NOT found.  */
end_comment

begin_function
specifier|static
name|int
name|check_nlist
parameter_list|(
name|nlst
parameter_list|)
specifier|register
name|struct
name|nlist
modifier|*
name|nlst
decl_stmt|;
block|{
specifier|register
name|int
name|i
decl_stmt|;
comment|/* check to see if we got ALL the symbols we requested */
comment|/* this will write one line to stderr for every symbol not found */
name|i
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|nlst
operator|->
name|n_name
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|nlst
operator|->
name|n_type
operator|==
literal|0
condition|)
block|{
comment|/* this one wasn't found */
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"kernel: no symbol named `%s'\n"
argument_list|,
name|nlst
operator|->
name|n_name
argument_list|)
expr_stmt|;
name|i
operator|=
literal|1
expr_stmt|;
block|}
name|nlst
operator|++
expr_stmt|;
block|}
return|return
operator|(
name|i
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  *  getkval(offset, ptr, size, refstr) - get a value out of the kernel.  *	"offset" is the byte offset into the kernel for the desired value,  *  	"ptr" points to a buffer into which the value is retrieved,  *  	"size" is the size of the buffer (and the object to retrieve),  *  	"refstr" is a reference string used when printing error meessages,  *	    if "refstr" starts with a '!', then a failure on read will not  *  	    be fatal (this may seem like a silly way to do things, but I  *  	    really didn't want the overhead of another argument).  *  	  */
end_comment

begin_function
specifier|static
name|int
name|getkval
parameter_list|(
name|offset
parameter_list|,
name|ptr
parameter_list|,
name|size
parameter_list|,
name|refstr
parameter_list|)
name|unsigned
name|long
name|offset
decl_stmt|;
name|int
modifier|*
name|ptr
decl_stmt|;
name|int
name|size
decl_stmt|;
name|char
modifier|*
name|refstr
decl_stmt|;
block|{
if|if
condition|(
name|kvm_read
argument_list|(
name|kd
argument_list|,
name|offset
argument_list|,
operator|(
name|char
operator|*
operator|)
name|ptr
argument_list|,
name|size
argument_list|)
operator|!=
name|size
condition|)
block|{
if|if
condition|(
operator|*
name|refstr
operator|==
literal|'!'
condition|)
block|{
return|return
operator|(
literal|0
operator|)
return|;
block|}
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"top: kvm_read for %s: %s\n"
argument_list|,
name|refstr
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|quit
argument_list|(
literal|23
argument_list|)
expr_stmt|;
block|}
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/* comparison routine for qsort */
end_comment

begin_comment
comment|/*  *  proc_compare - comparison function for "qsort"  *	Compares the resource consumption of two processes using five  *  	distinct keys.  The keys (in descending order of importance) are:  *  	percent cpu, cpu ticks, state, resident set size, total virtual  *  	memory usage.  The process states are ordered as follows (from least  *  	to most important):  WAIT, zombie, sleep, stop, start, run.  The  *  	array declaration below maps a process state index into a number  *  	that reflects this ordering.  */
end_comment

begin_decl_stmt
specifier|static
name|unsigned
name|char
name|sorted_state
index|[]
init|=
block|{
literal|0
block|,
comment|/* not used		*/
literal|3
block|,
comment|/* sleep		*/
literal|1
block|,
comment|/* ABANDONED (WAIT)	*/
literal|6
block|,
comment|/* run			*/
literal|5
block|,
comment|/* start		*/
literal|2
block|,
comment|/* zombie		*/
literal|4
comment|/* stop			*/
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|proc_compare
parameter_list|(
name|pp1
parameter_list|,
name|pp2
parameter_list|)
name|struct
name|proc
modifier|*
modifier|*
name|pp1
decl_stmt|;
name|struct
name|proc
modifier|*
modifier|*
name|pp2
decl_stmt|;
block|{
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p1
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|p2
decl_stmt|;
specifier|register
name|int
name|result
decl_stmt|;
specifier|register
name|pctcpu
name|lresult
decl_stmt|;
comment|/* remove one level of indirection */
name|p1
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp1
expr_stmt|;
name|p2
operator|=
operator|*
operator|(
expr|struct
name|kinfo_proc
operator|*
operator|*
operator|)
name|pp2
expr_stmt|;
comment|/* compare percent cpu (pctcpu) */
if|if
condition|(
operator|(
name|lresult
operator|=
name|PP
argument_list|(
name|p2
argument_list|,
name|p_pctcpu
argument_list|)
operator|-
name|PP
argument_list|(
name|p1
argument_list|,
name|p_pctcpu
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* use lifetime CPU usage to break the tie */
if|if
condition|(
operator|(
name|result
operator|=
name|PP
argument_list|(
name|p2
argument_list|,
name|p_rtime
argument_list|)
operator|.
name|tv_sec
operator|-
name|PP
argument_list|(
name|p1
argument_list|,
name|p_rtime
argument_list|)
operator|.
name|tv_sec
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* use process state to break the tie */
if|if
condition|(
operator|(
name|result
operator|=
name|sorted_state
index|[
operator|(
name|unsigned
name|char
operator|)
name|PP
argument_list|(
name|p2
argument_list|,
name|p_stat
argument_list|)
index|]
operator|-
name|sorted_state
index|[
operator|(
name|unsigned
name|char
operator|)
name|PP
argument_list|(
name|p1
argument_list|,
name|p_stat
argument_list|)
index|]
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* use priority to break the tie */
if|if
condition|(
operator|(
name|result
operator|=
name|PP
argument_list|(
name|p2
argument_list|,
name|p_priority
argument_list|)
operator|-
name|PP
argument_list|(
name|p1
argument_list|,
name|p_priority
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* use resident set size (rssize) to break the tie */
if|if
condition|(
operator|(
name|result
operator|=
name|VP
argument_list|(
name|p2
argument_list|,
name|vm_rssize
argument_list|)
operator|-
name|VP
argument_list|(
name|p1
argument_list|,
name|vm_rssize
argument_list|)
operator|)
operator|==
literal|0
condition|)
block|{
comment|/* use total memory to break the tie */
name|result
operator|=
name|PROCSIZE
argument_list|(
name|p2
argument_list|)
operator|-
name|PROCSIZE
argument_list|(
name|p1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
else|else
block|{
name|result
operator|=
name|lresult
operator|<
literal|0
condition|?
operator|-
literal|1
else|:
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|result
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * proc_owner(pid) - returns the uid that owns process "pid", or -1 if  *		the process does not exist.  *		It is EXTREMLY IMPORTANT that this function work correctly.  *		If top runs setuid root (as in SVR4), then this function  *		is the only thing that stands in the way of a serious  *		security problem.  It validates requests for the "kill"  *		and "renice" commands.  */
end_comment

begin_function
name|int
name|proc_owner
parameter_list|(
name|pid
parameter_list|)
name|int
name|pid
decl_stmt|;
block|{
specifier|register
name|int
name|cnt
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
modifier|*
name|prefp
decl_stmt|;
specifier|register
name|struct
name|kinfo_proc
modifier|*
name|pp
decl_stmt|;
name|prefp
operator|=
name|pref
expr_stmt|;
name|cnt
operator|=
name|pref_len
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
name|pp
operator|=
operator|*
name|prefp
operator|++
expr_stmt|;
if|if
condition|(
name|PP
argument_list|(
name|pp
argument_list|,
name|p_pid
argument_list|)
operator|==
operator|(
name|pid_t
operator|)
name|pid
condition|)
block|{
return|return
operator|(
operator|(
name|int
operator|)
name|EP
argument_list|(
name|pp
argument_list|,
name|e_pcred
operator|.
name|p_ruid
argument_list|)
operator|)
return|;
block|}
block|}
return|return
operator|(
operator|-
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * swapmode is based on a program called swapinfo written  * by Kevin Lahey<kml@rokkaku.atl.ga.us>.  */
end_comment

begin_define
define|#
directive|define
name|SVAR
parameter_list|(
name|var
parameter_list|)
value|__STRING(var)
end_define

begin_comment
comment|/* to force expansion */
end_comment

begin_define
define|#
directive|define
name|KGET
parameter_list|(
name|idx
parameter_list|,
name|var
parameter_list|)
define|\
value|KGET1(idx,&var, sizeof(var), SVAR(var))
end_define

begin_define
define|#
directive|define
name|KGET1
parameter_list|(
name|idx
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|,
name|msg
parameter_list|)
define|\
value|KGET2(nlst[idx].n_value, p, s, msg)
end_define

begin_define
define|#
directive|define
name|KGET2
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|,
name|msg
parameter_list|)
define|\
value|if (kvm_read(kd, (u_long)(addr), p, s) != s) {		        \ 		warnx("cannot read %s: %s", msg, kvm_geterr(kd));       \ 		return (0);                                             \        }
end_define

begin_define
define|#
directive|define
name|KGETRET
parameter_list|(
name|addr
parameter_list|,
name|p
parameter_list|,
name|s
parameter_list|,
name|msg
parameter_list|)
define|\
value|if (kvm_read(kd, (u_long)(addr), p, s) != s) {			\ 		warnx("cannot read %s: %s", msg, kvm_geterr(kd));	\ 		return (0);						\ 	}
end_define

begin_function
name|int
name|swapmode
parameter_list|(
name|retavail
parameter_list|,
name|retfree
parameter_list|)
name|int
modifier|*
name|retavail
decl_stmt|;
name|int
modifier|*
name|retfree
decl_stmt|;
block|{
name|char
modifier|*
name|header
decl_stmt|;
name|int
name|hlen
decl_stmt|,
name|nswap
decl_stmt|,
name|nswdev
decl_stmt|,
name|dmmax
decl_stmt|;
name|int
name|i
decl_stmt|,
name|div
decl_stmt|,
name|avail
decl_stmt|,
name|nfree
decl_stmt|,
name|npfree
decl_stmt|,
name|used
decl_stmt|;
name|struct
name|swdevt
modifier|*
name|sw
decl_stmt|;
name|long
name|blocksize
decl_stmt|,
modifier|*
name|perdev
decl_stmt|;
name|u_long
name|ptr
decl_stmt|;
name|struct
name|rlist
name|head
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|220000
name|struct
name|rlisthdr
name|swaplist
decl_stmt|;
else|#
directive|else
name|struct
name|rlist
modifier|*
name|swaplist
decl_stmt|;
endif|#
directive|endif
name|struct
name|rlist
modifier|*
name|swapptr
decl_stmt|;
comment|/* 	 * Counter for error messages. If we reach the limit, 	 * stop reading information from swap devices and 	 * return zero. This prevent endless 'bad address' 	 * messages. 	 */
specifier|static
name|warning
operator|=
literal|10
expr_stmt|;
if|if
condition|(
name|warning
operator|<=
literal|0
condition|)
block|{
comment|/* a single warning */
if|if
condition|(
operator|!
name|warning
condition|)
block|{
name|warning
operator|--
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Too much errors, stop reading swap devices ...\n"
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|sleep
argument_list|(
literal|3
argument_list|)
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|warning
operator|--
expr_stmt|;
comment|/* decrease counter, see end of function */
name|KGET
argument_list|(
name|VM_NSWAP
argument_list|,
name|nswap
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nswap
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"No swap space available\n"
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|KGET
argument_list|(
name|VM_NSWDEV
argument_list|,
name|nswdev
argument_list|)
expr_stmt|;
name|KGET
argument_list|(
name|VM_DMMAX
argument_list|,
name|dmmax
argument_list|)
expr_stmt|;
name|KGET1
argument_list|(
name|VM_SWAPLIST
argument_list|,
operator|&
name|swaplist
argument_list|,
sizeof|sizeof
argument_list|(
name|swaplist
argument_list|)
argument_list|,
literal|"swaplist"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|sw
operator|=
operator|(
expr|struct
name|swdevt
operator|*
operator|)
name|malloc
argument_list|(
name|nswdev
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sw
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
operator|||
operator|(
name|perdev
operator|=
operator|(
name|long
operator|*
operator|)
name|malloc
argument_list|(
name|nswdev
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|perdev
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"malloc"
argument_list|)
expr_stmt|;
name|KGET1
argument_list|(
name|VM_SWDEVT
argument_list|,
operator|&
name|ptr
argument_list|,
sizeof|sizeof
name|ptr
argument_list|,
literal|"swdevt"
argument_list|)
expr_stmt|;
name|KGET2
argument_list|(
name|ptr
argument_list|,
name|sw
argument_list|,
name|nswdev
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|sw
argument_list|)
argument_list|,
literal|"*swdevt"
argument_list|)
expr_stmt|;
comment|/* Count up swap space. */
name|nfree
operator|=
literal|0
expr_stmt|;
name|memset
argument_list|(
name|perdev
argument_list|,
literal|0
argument_list|,
name|nswdev
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|perdev
argument_list|)
argument_list|)
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|220000
name|swapptr
operator|=
name|swaplist
operator|.
name|rlh_list
expr_stmt|;
while|while
condition|(
name|swapptr
condition|)
block|{
else|#
directive|else
while|while
condition|(
name|swaplist
condition|)
block|{
endif|#
directive|endif
name|int
name|top
decl_stmt|,
name|bottom
decl_stmt|,
name|next_block
decl_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|220000
name|KGET2
argument_list|(
name|swapptr
argument_list|,
operator|&
name|head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rlist
argument_list|)
argument_list|,
literal|"swapptr"
argument_list|)
expr_stmt|;
else|#
directive|else
name|KGET2
argument_list|(
name|swaplist
argument_list|,
operator|&
name|head
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|rlist
argument_list|)
argument_list|,
literal|"swaplist"
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|top
operator|=
name|head
operator|.
name|rl_end
expr_stmt|;
name|bottom
operator|=
name|head
operator|.
name|rl_start
expr_stmt|;
name|nfree
operator|+=
name|top
operator|-
name|bottom
operator|+
literal|1
expr_stmt|;
comment|/* 		 * Swap space is split up among the configured disks. 		 * 		 * For interleaved swap devices, the first dmmax blocks 		 * of swap space some from the first disk, the next dmmax 		 * blocks from the next, and so on up to nswap blocks. 		 * 		 * The list of free space joins adjacent free blocks, 		 * ignoring device boundries.  If we want to keep track 		 * of this information per device, we'll just have to 		 * extract it ourselves. 		 */
while|while
condition|(
name|top
operator|/
name|dmmax
operator|!=
name|bottom
operator|/
name|dmmax
condition|)
block|{
name|next_block
operator|=
operator|(
operator|(
name|bottom
operator|+
name|dmmax
operator|)
operator|/
name|dmmax
operator|)
expr_stmt|;
name|perdev
index|[
operator|(
name|bottom
operator|/
name|dmmax
operator|)
operator|%
name|nswdev
index|]
operator|+=
name|next_block
operator|*
name|dmmax
operator|-
name|bottom
expr_stmt|;
name|bottom
operator|=
name|next_block
operator|*
name|dmmax
expr_stmt|;
block|}
name|perdev
index|[
operator|(
name|bottom
operator|/
name|dmmax
operator|)
operator|%
name|nswdev
index|]
operator|+=
name|top
operator|-
name|bottom
operator|+
literal|1
expr_stmt|;
if|#
directive|if
name|__FreeBSD_version
operator|>=
literal|220000
name|swapptr
operator|=
name|head
operator|.
name|rl_next
expr_stmt|;
else|#
directive|else
name|swaplist
operator|=
name|head
operator|.
name|rl_next
expr_stmt|;
endif|#
directive|endif
block|}
name|header
operator|=
name|getbsize
argument_list|(
operator|&
name|hlen
argument_list|,
operator|&
name|blocksize
argument_list|)
expr_stmt|;
name|div
operator|=
name|blocksize
operator|/
literal|512
expr_stmt|;
name|avail
operator|=
name|npfree
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|nswdev
condition|;
name|i
operator|++
control|)
block|{
name|int
name|xsize
decl_stmt|,
name|xfree
decl_stmt|;
comment|/* 		 * Don't report statistics for partitions which have not 		 * yet been activated via swapon(8). 		 */
name|xsize
operator|=
name|sw
index|[
name|i
index|]
operator|.
name|sw_nblks
expr_stmt|;
name|xfree
operator|=
name|perdev
index|[
name|i
index|]
expr_stmt|;
name|used
operator|=
name|xsize
operator|-
name|xfree
expr_stmt|;
name|npfree
operator|++
expr_stmt|;
name|avail
operator|+=
name|xsize
expr_stmt|;
block|}
comment|/*  	 * If only one partition has been set up via swapon(8), we don't 	 * need to bother with totals. 	 */
operator|*
name|retavail
operator|=
name|avail
operator|/
literal|2
expr_stmt|;
operator|*
name|retfree
operator|=
name|nfree
operator|/
literal|2
expr_stmt|;
name|used
operator|=
name|avail
operator|-
name|nfree
expr_stmt|;
name|free
argument_list|(
name|sw
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|perdev
argument_list|)
expr_stmt|;
comment|/* increase counter, no errors occurs */
name|warning
operator|++
expr_stmt|;
return|return
call|(
name|int
call|)
argument_list|(
operator|(
operator|(
name|double
operator|)
name|used
operator|/
operator|(
name|double
operator|)
name|avail
operator|*
literal|100.0
operator|)
operator|+
literal|0.5
argument_list|)
return|;
block|}
end_function

end_unit

