begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that Alfalfa's name not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  If you make any modifications, bugfixes or other changes to this software we'd appreciate it if you could send a copy to us so we can keep things up-to-date.  Many thanks. 				Kee Hinckley 				Alfalfa Software, Inc. 				267 Allston St., #3 				Cambridge, MA 02139  USA 				nazgul@alfalfa.com  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"msgcat.h"
end_include

begin_include
include|#
directive|include
file|"gencat.h"
end_include

begin_decl_stmt
specifier|static
name|char
modifier|*
name|curline
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|void
name|warning
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|warnx
argument_list|(
literal|"%s on line %ld\n%s"
argument_list|,
name|msg
argument_list|,
name|lineno
argument_list|,
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
block|{
name|char
modifier|*
name|tptr
decl_stmt|;
for|for
control|(
name|tptr
operator|=
name|curline
init|;
name|tptr
operator|<
name|cptr
condition|;
operator|++
name|tptr
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"^\n"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|error
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|corrupt
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
name|NULL
argument_list|,
literal|"corrupt message catalog"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|nomem
parameter_list|(
name|void
parameter_list|)
block|{
name|error
argument_list|(
name|NULL
argument_list|,
literal|"out of memory"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getline
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
specifier|static
name|size_t
name|curlen
init|=
name|BUFSIZ
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|bptr
init|=
name|buf
decl_stmt|,
modifier|*
name|bend
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|cend
decl_stmt|;
name|long
name|buflen
decl_stmt|;
if|if
condition|(
operator|!
name|curline
condition|)
block|{
name|curline
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|curline
condition|)
name|nomem
argument_list|()
expr_stmt|;
block|}
operator|++
name|lineno
expr_stmt|;
name|cptr
operator|=
name|curline
expr_stmt|;
name|cend
operator|=
name|curline
operator|+
name|curlen
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
for|for
control|(
init|;
name|bptr
operator|<
name|bend
operator|&&
name|cptr
operator|<
name|cend
condition|;
operator|++
name|cptr
operator|,
operator|++
name|bptr
control|)
block|{
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|bptr
expr_stmt|;
return|return
operator|(
name|curline
operator|)
return|;
block|}
else|else
operator|*
name|cptr
operator|=
operator|*
name|bptr
expr_stmt|;
block|}
if|if
condition|(
name|bptr
operator|==
name|bend
condition|)
block|{
name|buflen
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cptr
operator|>
name|curline
condition|)
block|{
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|curline
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bend
operator|=
name|buf
operator|+
name|buflen
expr_stmt|;
name|bptr
operator|=
name|buf
expr_stmt|;
block|}
if|if
condition|(
name|cptr
operator|==
name|cend
condition|)
block|{
name|cptr
operator|=
name|curline
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|curline
argument_list|,
name|curlen
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|cend
operator|=
name|curline
operator|+
name|curlen
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|token
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|)
block|{
specifier|static
name|char
name|tok
index|[
name|MAXTOKEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
modifier|*
name|tptr
init|=
name|tok
decl_stmt|;
while|while
condition|(
operator|*
name|cptr
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
operator|++
name|cptr
expr_stmt|;
while|while
condition|(
operator|*
name|cptr
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
operator|*
name|tptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|tok
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|wskip
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|cptr
operator|||
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"expected a space"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cptr
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
operator|++
name|cptr
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|cskip
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|cptr
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"wasn't expecting a space"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cptr
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
operator|++
name|cptr
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|getmsg
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|cptr
parameter_list|,
name|char
name|quote
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
specifier|static
name|size_t
name|msglen
init|=
literal|0
decl_stmt|;
name|size_t
name|clen
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|tptr
decl_stmt|;
name|int
name|needq
decl_stmt|;
if|if
condition|(
name|quote
operator|&&
operator|*
name|cptr
operator|==
name|quote
condition|)
block|{
name|needq
operator|=
name|TRUE
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
else|else
name|needq
operator|=
name|FALSE
expr_stmt|;
name|clen
operator|=
name|strlen
argument_list|(
name|cptr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|clen
operator|>
name|msglen
condition|)
block|{
if|if
condition|(
name|msglen
condition|)
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|msg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|clen
expr_stmt|;
block|}
name|tptr
operator|=
name|msg
expr_stmt|;
while|while
condition|(
operator|*
name|cptr
condition|)
block|{
if|if
condition|(
name|quote
operator|&&
operator|*
name|cptr
operator|==
name|quote
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|cptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|tmp
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|tmp
argument_list|)
operator|||
operator|*
name|wskip
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"unexpected quote character, ignoring"
argument_list|)
expr_stmt|;
operator|*
name|tptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
switch|switch
condition|(
operator|*
name|cptr
condition|)
block|{
case|case
literal|'\0'
case|:
name|cptr
operator|=
name|getline
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cptr
condition|)
name|error
argument_list|(
name|NULL
argument_list|,
literal|"premature end of file"
argument_list|)
expr_stmt|;
name|msglen
operator|+=
name|strlen
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|i
operator|=
name|tptr
operator|-
name|msg
expr_stmt|;
name|msg
operator|=
operator|(
name|char
operator|*
operator|)
name|realloc
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|tptr
operator|=
name|msg
operator|+
name|i
expr_stmt|;
break|break;
define|#
directive|define
name|CASEOF
parameter_list|(
name|CS
parameter_list|,
name|CH
parameter_list|)
define|\
value|case CS:			\ 		*tptr++ = CH;		\ 		++cptr;			\ 		break;
name|CASEOF
argument_list|(
literal|'n'
argument_list|,
literal|'\n'
argument_list|)
name|CASEOF
argument_list|(
literal|'t'
argument_list|,
literal|'\t'
argument_list|)
name|CASEOF
argument_list|(
literal|'v'
argument_list|,
literal|'\v'
argument_list|)
name|CASEOF
argument_list|(
literal|'b'
argument_list|,
literal|'\b'
argument_list|)
name|CASEOF
argument_list|(
literal|'r'
argument_list|,
literal|'\r'
argument_list|)
name|CASEOF
argument_list|(
literal|'f'
argument_list|,
literal|'\f'
argument_list|)
name|CASEOF
argument_list|(
literal|'"'
argument_list|,
literal|'"'
argument_list|)
name|CASEOF
argument_list|(
literal|'\''
argument_list|,
literal|'\''
argument_list|)
name|CASEOF
argument_list|(
literal|'\\'
argument_list|,
literal|'\\'
argument_list|)
default|default:
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
operator|*
name|tptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|cptr
operator|>
literal|'7'
condition|)
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"octal number greater than 7?!"
argument_list|)
expr_stmt|;
operator|*
name|tptr
operator|*=
literal|8
expr_stmt|;
operator|*
name|tptr
operator|+=
operator|(
operator|*
name|cptr
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
operator|++
name|tptr
expr_stmt|;
block|}
else|else
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"unrecognized escape sequence"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
operator|*
name|tptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|msg
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|char
modifier|*
name|dupstr
parameter_list|(
specifier|const
name|char
modifier|*
name|ostr
parameter_list|)
block|{
name|char
modifier|*
name|nstr
decl_stmt|;
name|nstr
operator|=
name|strdup
argument_list|(
name|ostr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|nstr
condition|)
name|error
argument_list|(
name|NULL
argument_list|,
literal|"unable to allocate storage"
argument_list|)
expr_stmt|;
return|return
operator|(
name|nstr
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * The Global Stuff  */
end_comment

begin_typedef
typedef|typedef
struct|struct
name|_msgT
block|{
name|long
name|msgId
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|char
modifier|*
name|hconst
decl_stmt|;
name|long
name|offset
decl_stmt|;
name|struct
name|_msgT
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
block|}
name|msgT
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
name|_setT
block|{
name|long
name|setId
decl_stmt|;
name|char
modifier|*
name|hconst
decl_stmt|;
name|msgT
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
name|struct
name|_setT
modifier|*
name|prev
decl_stmt|,
modifier|*
name|next
decl_stmt|;
block|}
name|setT
typedef|;
end_typedef

begin_typedef
typedef|typedef
struct|struct
block|{
name|setT
modifier|*
name|first
decl_stmt|,
modifier|*
name|last
decl_stmt|;
block|}
name|catT
typedef|;
end_typedef

begin_decl_stmt
specifier|static
name|setT
modifier|*
name|curSet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|catT
modifier|*
name|cat
decl_stmt|;
end_decl_stmt

begin_comment
comment|/*  * Find the current byte order.  There are of course some others, but  * this will do for now.  Note that all we care about is "long".  */
end_comment

begin_function
name|long
name|MCGetByteOrder
parameter_list|(
name|void
parameter_list|)
block|{
name|long
name|l
init|=
literal|0x00010203
decl_stmt|;
name|char
modifier|*
name|cptr
init|=
operator|(
name|char
operator|*
operator|)
operator|&
name|l
decl_stmt|;
if|if
condition|(
name|cptr
index|[
literal|0
index|]
operator|==
literal|0
operator|&&
name|cptr
index|[
literal|1
index|]
operator|==
literal|1
operator|&&
name|cptr
index|[
literal|2
index|]
operator|==
literal|2
operator|&&
name|cptr
index|[
literal|3
index|]
operator|==
literal|3
condition|)
return|return
name|MC68KByteOrder
return|;
else|else
return|return
name|MCn86ByteOrder
return|;
block|}
end_function

begin_function
name|void
name|MCParse
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|int
name|setid
decl_stmt|,
name|msgid
init|=
literal|0
decl_stmt|;
name|char
name|hconst
index|[
name|MAXTOKEN
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|quote
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|!
name|cat
condition|)
block|{
name|cat
operator|=
operator|(
name|catT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|catT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cat
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|cat
argument_list|,
sizeof|sizeof
argument_list|(
name|catT
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|hconst
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|(
name|cptr
operator|=
name|getline
argument_list|(
name|fd
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'$'
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cptr
argument_list|,
literal|"set"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cptr
operator|+=
literal|3
expr_stmt|;
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|setid
operator|=
name|atoi
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|cskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
condition|)
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'#'
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|MCAddSet
argument_list|(
name|setid
argument_list|,
name|token
argument_list|(
name|cptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|MCAddSet
argument_list|(
name|setid
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|msgid
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cptr
argument_list|,
literal|"delset"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cptr
operator|+=
literal|6
expr_stmt|;
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|setid
operator|=
name|atoi
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|MCDelSet
argument_list|(
name|setid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cptr
argument_list|,
literal|"quote"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cptr
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
else|else
name|quote
operator|=
operator|*
name|cptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'#'
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
name|strcpy
argument_list|(
name|hconst
argument_list|,
name|token
argument_list|(
name|cptr
argument_list|)
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cptr
condition|)
block|{
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
condition|)
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"unrecognized line"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
operator|||
operator|*
name|cptr
operator|==
literal|'#'
condition|)
block|{
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'#'
condition|)
block|{
operator|++
name|msgid
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
block|{
name|MCAddMsg
argument_list|(
name|msgid
argument_list|,
literal|""
argument_list|,
name|hconst
argument_list|)
expr_stmt|;
name|hconst
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"expected a space"
argument_list|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
block|{
name|MCAddMsg
argument_list|(
name|msgid
argument_list|,
literal|""
argument_list|,
name|hconst
argument_list|)
expr_stmt|;
name|hconst
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
continue|continue;
block|}
block|}
else|else
block|{
name|msgid
operator|=
name|atoi
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|cskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
comment|/* if (*cptr) ++cptr; */
block|}
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
name|MCDelMsg
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
else|else
block|{
name|str
operator|=
name|getmsg
argument_list|(
name|fd
argument_list|,
name|cptr
argument_list|,
name|quote
argument_list|)
expr_stmt|;
name|MCAddMsg
argument_list|(
name|msgid
argument_list|,
name|str
argument_list|,
name|hconst
argument_list|)
expr_stmt|;
name|hconst
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
block|}
block|}
block|}
end_function

begin_function
name|void
name|MCReadCat
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|MCHeaderT
name|mcHead
decl_stmt|;
name|MCMsgT
name|mcMsg
decl_stmt|;
name|MCSetT
name|mcSet
decl_stmt|;
name|msgT
modifier|*
name|msg
decl_stmt|;
name|setT
modifier|*
name|set
decl_stmt|;
name|int
name|i
decl_stmt|;
name|char
modifier|*
name|data
decl_stmt|;
name|cat
operator|=
operator|(
name|catT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|catT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cat
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|cat
argument_list|,
sizeof|sizeof
argument_list|(
name|catT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|mcHead
argument_list|,
sizeof|sizeof
argument_list|(
name|mcHead
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|mcHead
argument_list|)
condition|)
name|corrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|mcHead
operator|.
name|magic
argument_list|,
name|MCMagic
argument_list|,
name|MCMagicLen
argument_list|)
operator|!=
literal|0
condition|)
name|corrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|mcHead
operator|.
name|majorVer
operator|!=
name|MCMajorVer
condition|)
name|error
argument_list|(
name|NULL
argument_list|,
literal|"unrecognized catalog version"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|mcHead
operator|.
name|flags
operator|&
name|MCGetByteOrder
argument_list|()
operator|)
operator|==
literal|0
condition|)
name|error
argument_list|(
name|NULL
argument_list|,
literal|"wrong byte order"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|mcHead
operator|.
name|firstSet
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|corrupt
argument_list|()
expr_stmt|;
while|while
condition|(
name|TRUE
condition|)
block|{
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|mcSet
argument_list|,
sizeof|sizeof
argument_list|(
name|mcSet
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|mcSet
argument_list|)
condition|)
name|corrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|mcSet
operator|.
name|invalid
condition|)
continue|continue;
name|set
operator|=
operator|(
name|setT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|setT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|set
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|set
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cat
operator|->
name|first
condition|)
block|{
name|cat
operator|->
name|last
operator|->
name|next
operator|=
name|set
expr_stmt|;
name|set
operator|->
name|prev
operator|=
name|cat
operator|->
name|last
expr_stmt|;
name|cat
operator|->
name|last
operator|=
name|set
expr_stmt|;
block|}
else|else
name|cat
operator|->
name|first
operator|=
name|cat
operator|->
name|last
operator|=
name|set
expr_stmt|;
name|set
operator|->
name|setId
operator|=
name|mcSet
operator|.
name|setId
expr_stmt|;
comment|/* Get the data */
if|if
condition|(
name|mcSet
operator|.
name|dataLen
condition|)
block|{
name|data
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|size_t
operator|)
name|mcSet
operator|.
name|dataLen
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|data
condition|)
name|nomem
argument_list|()
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|mcSet
operator|.
name|data
operator|.
name|off
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|corrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
name|data
argument_list|,
operator|(
name|size_t
operator|)
name|mcSet
operator|.
name|dataLen
argument_list|)
operator|!=
name|mcSet
operator|.
name|dataLen
condition|)
name|corrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|mcSet
operator|.
name|u
operator|.
name|firstMsg
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|corrupt
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|mcSet
operator|.
name|numMsgs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|read
argument_list|(
name|fd
argument_list|,
operator|&
name|mcMsg
argument_list|,
sizeof|sizeof
argument_list|(
name|mcMsg
argument_list|)
argument_list|)
operator|!=
sizeof|sizeof
argument_list|(
name|mcMsg
argument_list|)
condition|)
name|corrupt
argument_list|()
expr_stmt|;
if|if
condition|(
name|mcMsg
operator|.
name|invalid
condition|)
block|{
operator|--
name|i
expr_stmt|;
continue|continue;
block|}
name|msg
operator|=
operator|(
name|msgT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|msgT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|msg
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|first
condition|)
block|{
name|set
operator|->
name|last
operator|->
name|next
operator|=
name|msg
expr_stmt|;
name|msg
operator|->
name|prev
operator|=
name|set
operator|->
name|last
expr_stmt|;
name|set
operator|->
name|last
operator|=
name|msg
expr_stmt|;
block|}
else|else
name|set
operator|->
name|first
operator|=
name|set
operator|->
name|last
operator|=
name|msg
expr_stmt|;
name|msg
operator|->
name|msgId
operator|=
name|mcMsg
operator|.
name|msgId
expr_stmt|;
name|msg
operator|->
name|str
operator|=
name|dupstr
argument_list|(
operator|(
name|char
operator|*
operator|)
operator|(
name|data
operator|+
name|mcMsg
operator|.
name|msg
operator|.
name|off
operator|)
argument_list|)
expr_stmt|;
block|}
name|free
argument_list|(
name|data
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|mcSet
operator|.
name|nextSet
condition|)
break|break;
if|if
condition|(
name|lseek
argument_list|(
name|fd
argument_list|,
name|mcSet
operator|.
name|nextSet
argument_list|,
name|L_SET
argument_list|)
operator|==
operator|-
literal|1
condition|)
name|corrupt
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_function
specifier|static
name|void
name|printS
parameter_list|(
name|int
name|fd
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|write
argument_list|(
name|fd
argument_list|,
name|str
argument_list|,
name|strlen
argument_list|(
name|str
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printL
parameter_list|(
name|int
name|fd
parameter_list|,
name|long
name|l
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%ld"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|printLX
parameter_list|(
name|int
name|fd
parameter_list|,
name|long
name|l
parameter_list|)
block|{
name|char
name|buf
index|[
literal|32
index|]
decl_stmt|;
name|sprintf
argument_list|(
name|buf
argument_list|,
literal|"%lx"
argument_list|,
name|l
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|strlen
argument_list|(
name|buf
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
specifier|static
name|void
name|genconst
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|type
parameter_list|,
name|char
modifier|*
name|setConst
parameter_list|,
name|char
modifier|*
name|msgConst
parameter_list|,
name|long
name|val
parameter_list|)
block|{
switch|switch
condition|(
name|type
condition|)
block|{
case|case
name|MCLangC
case|:
if|if
condition|(
operator|!
name|msgConst
condition|)
block|{
name|printS
argument_list|(
name|fd
argument_list|,
literal|"\n#define "
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
name|setConst
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"Set"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printS
argument_list|(
name|fd
argument_list|,
literal|"#define "
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
name|setConst
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
name|msgConst
argument_list|)
expr_stmt|;
block|}
name|printS
argument_list|(
name|fd
argument_list|,
literal|"\t0x"
argument_list|)
expr_stmt|;
name|printLX
argument_list|(
name|fd
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
break|break;
case|case
name|MCLangCPlusPlus
case|:
case|case
name|MCLangANSIC
case|:
if|if
condition|(
operator|!
name|msgConst
condition|)
block|{
name|printS
argument_list|(
name|fd
argument_list|,
literal|"\nconst long "
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
name|setConst
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"Set"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|printS
argument_list|(
name|fd
argument_list|,
literal|"const long "
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
name|setConst
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
name|msgConst
argument_list|)
expr_stmt|;
block|}
name|printS
argument_list|(
name|fd
argument_list|,
literal|"\t= "
argument_list|)
expr_stmt|;
name|printL
argument_list|(
name|fd
argument_list|,
name|val
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|";\n"
argument_list|)
expr_stmt|;
break|break;
default|default:
name|error
argument_list|(
name|NULL
argument_list|,
literal|"not a recognized (programming) language type"
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|MCWriteConst
parameter_list|(
name|int
name|fd
parameter_list|,
name|int
name|type
parameter_list|,
name|int
name|orConsts
parameter_list|)
block|{
name|msgT
modifier|*
name|msg
decl_stmt|;
name|setT
modifier|*
name|set
decl_stmt|;
name|long
name|id
decl_stmt|;
if|if
condition|(
name|orConsts
operator|&&
operator|(
name|type
operator|==
name|MCLangC
operator|||
name|type
operator|==
name|MCLangCPlusPlus
operator|||
name|type
operator|==
name|MCLangANSIC
operator|)
condition|)
block|{
name|printS
argument_list|(
name|fd
argument_list|,
literal|"/* Use these Macros to compose and decompose setId's and msgId's */\n"
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"#ifndef MCMakeId\n"
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"# define MCMakeId(s,m)\t(unsigned long)(((unsigned short)s<<(sizeof(short)*8))\\\n"
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"\t\t\t\t\t|(unsigned short)m)\n"
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"# define MCSetId(id)\t(unsigned int) (id>> (sizeof(short) * 8))\n"
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"# define MCMsgId(id)\t(unsigned int) ((id<< (sizeof(short) * 8))\\\n"
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"\t\t\t\t\t>> (sizeof(short) * 8))\n"
argument_list|)
expr_stmt|;
name|printS
argument_list|(
name|fd
argument_list|,
literal|"#endif\n"
argument_list|)
expr_stmt|;
block|}
for|for
control|(
name|set
operator|=
name|cat
operator|->
name|first
init|;
name|set
condition|;
name|set
operator|=
name|set
operator|->
name|next
control|)
block|{
if|if
condition|(
name|set
operator|->
name|hconst
condition|)
name|genconst
argument_list|(
name|fd
argument_list|,
name|type
argument_list|,
name|set
operator|->
name|hconst
argument_list|,
name|NULL
argument_list|,
name|set
operator|->
name|setId
argument_list|)
expr_stmt|;
for|for
control|(
name|msg
operator|=
name|set
operator|->
name|first
init|;
name|msg
condition|;
name|msg
operator|=
name|msg
operator|->
name|next
control|)
block|{
if|if
condition|(
name|msg
operator|->
name|hconst
condition|)
block|{
if|if
condition|(
name|orConsts
condition|)
name|id
operator|=
name|MCMakeId
argument_list|(
name|set
operator|->
name|setId
argument_list|,
name|msg
operator|->
name|msgId
argument_list|)
expr_stmt|;
else|else
name|id
operator|=
name|msg
operator|->
name|msgId
expr_stmt|;
name|genconst
argument_list|(
name|fd
argument_list|,
name|type
argument_list|,
name|set
operator|->
name|hconst
argument_list|,
name|msg
operator|->
name|hconst
argument_list|,
name|id
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
operator|->
name|hconst
argument_list|)
expr_stmt|;
name|msg
operator|->
name|hconst
operator|=
name|NULL
expr_stmt|;
block|}
block|}
if|if
condition|(
name|set
operator|->
name|hconst
condition|)
block|{
name|free
argument_list|(
name|set
operator|->
name|hconst
argument_list|)
expr_stmt|;
name|set
operator|->
name|hconst
operator|=
name|NULL
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|MCWriteCat
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|MCHeaderT
name|mcHead
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|setT
modifier|*
name|set
decl_stmt|;
name|msgT
modifier|*
name|msg
decl_stmt|;
name|MCSetT
name|mcSet
decl_stmt|;
name|MCMsgT
name|mcMsg
decl_stmt|;
name|off_t
name|pos
decl_stmt|;
name|bcopy
argument_list|(
name|MCMagic
argument_list|,
name|mcHead
operator|.
name|magic
argument_list|,
name|MCMagicLen
argument_list|)
expr_stmt|;
name|mcHead
operator|.
name|majorVer
operator|=
name|MCMajorVer
expr_stmt|;
name|mcHead
operator|.
name|minorVer
operator|=
name|MCMinorVer
expr_stmt|;
name|mcHead
operator|.
name|flags
operator|=
name|MCGetByteOrder
argument_list|()
expr_stmt|;
name|mcHead
operator|.
name|firstSet
operator|=
literal|0
expr_stmt|;
comment|/* We'll be back to set this in a minute */
for|for
control|(
name|cnt
operator|=
literal|0
operator|,
name|set
operator|=
name|cat
operator|->
name|first
init|;
name|set
condition|;
name|set
operator|=
name|set
operator|->
name|next
control|)
operator|++
name|cnt
expr_stmt|;
name|mcHead
operator|.
name|numSets
operator|=
name|cnt
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|mcHead
argument_list|,
sizeof|sizeof
argument_list|(
name|mcHead
argument_list|)
argument_list|)
expr_stmt|;
name|mcHead
operator|.
name|firstSet
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|mcHead
argument_list|,
sizeof|sizeof
argument_list|(
name|mcHead
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|set
operator|=
name|cat
operator|->
name|first
init|;
name|set
condition|;
name|set
operator|=
name|set
operator|->
name|next
control|)
block|{
name|bzero
argument_list|(
operator|&
name|mcSet
argument_list|,
sizeof|sizeof
argument_list|(
name|mcSet
argument_list|)
argument_list|)
expr_stmt|;
name|mcSet
operator|.
name|setId
operator|=
name|set
operator|->
name|setId
expr_stmt|;
name|mcSet
operator|.
name|invalid
operator|=
name|FALSE
expr_stmt|;
comment|/* The rest we'll have to come back and change in a moment */
name|pos
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|mcSet
argument_list|,
sizeof|sizeof
argument_list|(
name|mcSet
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Now write all the string data */
name|mcSet
operator|.
name|data
operator|.
name|off
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msg
operator|=
name|set
operator|->
name|first
init|;
name|msg
condition|;
name|msg
operator|=
name|msg
operator|->
name|next
control|)
block|{
name|msg
operator|->
name|offset
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_INCR
argument_list|)
operator|-
name|mcSet
operator|.
name|data
operator|.
name|off
expr_stmt|;
name|mcSet
operator|.
name|dataLen
operator|+=
name|write
argument_list|(
name|fd
argument_list|,
name|msg
operator|->
name|str
argument_list|,
name|strlen
argument_list|(
name|msg
operator|->
name|str
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
operator|++
name|cnt
expr_stmt|;
block|}
name|mcSet
operator|.
name|u
operator|.
name|firstMsg
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|mcSet
operator|.
name|numMsgs
operator|=
name|cnt
expr_stmt|;
comment|/* Now write the message headers */
for|for
control|(
name|msg
operator|=
name|set
operator|->
name|first
init|;
name|msg
condition|;
name|msg
operator|=
name|msg
operator|->
name|next
control|)
block|{
name|mcMsg
operator|.
name|msgId
operator|=
name|msg
operator|->
name|msgId
expr_stmt|;
name|mcMsg
operator|.
name|msg
operator|.
name|off
operator|=
name|msg
operator|->
name|offset
expr_stmt|;
name|mcMsg
operator|.
name|invalid
operator|=
name|FALSE
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|mcMsg
argument_list|,
sizeof|sizeof
argument_list|(
name|mcMsg
argument_list|)
argument_list|)
expr_stmt|;
block|}
comment|/* Go back and fix things up */
if|if
condition|(
name|set
operator|==
name|cat
operator|->
name|last
condition|)
block|{
name|mcSet
operator|.
name|nextSet
operator|=
literal|0
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|mcSet
argument_list|,
sizeof|sizeof
argument_list|(
name|mcSet
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|mcSet
operator|.
name|nextSet
operator|=
name|lseek
argument_list|(
name|fd
argument_list|,
operator|(
name|off_t
operator|)
literal|0L
argument_list|,
name|L_INCR
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|pos
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
name|write
argument_list|(
name|fd
argument_list|,
operator|&
name|mcSet
argument_list|,
sizeof|sizeof
argument_list|(
name|mcSet
argument_list|)
argument_list|)
expr_stmt|;
name|lseek
argument_list|(
name|fd
argument_list|,
name|mcSet
operator|.
name|nextSet
argument_list|,
name|L_SET
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_function
name|void
name|MCAddSet
parameter_list|(
name|int
name|setId
parameter_list|,
name|char
modifier|*
name|hconst
parameter_list|)
block|{
name|setT
modifier|*
name|set
decl_stmt|;
if|if
condition|(
name|setId
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|NULL
argument_list|,
literal|"setId's must be greater than zero"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hconst
operator|&&
operator|!
operator|*
name|hconst
condition|)
name|hconst
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|set
operator|=
name|cat
operator|->
name|first
init|;
name|set
condition|;
name|set
operator|=
name|set
operator|->
name|next
control|)
block|{
if|if
condition|(
name|set
operator|->
name|setId
operator|==
name|setId
condition|)
block|{
if|if
condition|(
name|set
operator|->
name|hconst
operator|&&
name|hconst
condition|)
name|free
argument_list|(
name|set
operator|->
name|hconst
argument_list|)
expr_stmt|;
name|set
operator|->
name|hconst
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|set
operator|->
name|setId
operator|>
name|setId
condition|)
block|{
name|setT
modifier|*
name|newSet
decl_stmt|;
name|newSet
operator|=
operator|(
name|setT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|setT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newSet
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|newSet
argument_list|,
sizeof|sizeof
argument_list|(
name|setT
argument_list|)
argument_list|)
expr_stmt|;
name|newSet
operator|->
name|prev
operator|=
name|set
operator|->
name|prev
expr_stmt|;
name|newSet
operator|->
name|next
operator|=
name|set
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|prev
condition|)
name|set
operator|->
name|prev
operator|->
name|next
operator|=
name|newSet
expr_stmt|;
else|else
name|cat
operator|->
name|first
operator|=
name|newSet
expr_stmt|;
name|set
operator|->
name|prev
operator|=
name|newSet
expr_stmt|;
name|set
operator|=
name|newSet
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|set
condition|)
block|{
name|set
operator|=
operator|(
name|setT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|setT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|set
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|set
argument_list|,
sizeof|sizeof
argument_list|(
name|setT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|cat
operator|->
name|first
condition|)
block|{
name|set
operator|->
name|prev
operator|=
name|cat
operator|->
name|last
expr_stmt|;
name|set
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cat
operator|->
name|last
operator|->
name|next
operator|=
name|set
expr_stmt|;
name|cat
operator|->
name|last
operator|=
name|set
expr_stmt|;
block|}
else|else
block|{
name|set
operator|->
name|prev
operator|=
name|set
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|cat
operator|->
name|first
operator|=
name|cat
operator|->
name|last
operator|=
name|set
expr_stmt|;
block|}
block|}
name|set
operator|->
name|setId
operator|=
name|setId
expr_stmt|;
if|if
condition|(
name|hconst
condition|)
name|set
operator|->
name|hconst
operator|=
name|dupstr
argument_list|(
name|hconst
argument_list|)
expr_stmt|;
name|curSet
operator|=
name|set
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MCAddMsg
parameter_list|(
name|int
name|msgId
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|,
name|char
modifier|*
name|hconst
parameter_list|)
block|{
name|msgT
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|curSet
condition|)
name|error
argument_list|(
name|NULL
argument_list|,
literal|"can't specify a message when no set exists"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgId
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
name|NULL
argument_list|,
literal|"msgId's must be greater than zero"
argument_list|)
expr_stmt|;
return|return;
block|}
if|if
condition|(
name|hconst
operator|&&
operator|!
operator|*
name|hconst
condition|)
name|hconst
operator|=
name|NULL
expr_stmt|;
for|for
control|(
name|msg
operator|=
name|curSet
operator|->
name|first
init|;
name|msg
condition|;
name|msg
operator|=
name|msg
operator|->
name|next
control|)
block|{
if|if
condition|(
name|msg
operator|->
name|msgId
operator|==
name|msgId
condition|)
block|{
if|if
condition|(
name|msg
operator|->
name|hconst
operator|&&
name|hconst
condition|)
name|free
argument_list|(
name|msg
operator|->
name|hconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|str
condition|)
name|free
argument_list|(
name|msg
operator|->
name|str
argument_list|)
expr_stmt|;
name|msg
operator|->
name|hconst
operator|=
name|msg
operator|->
name|str
operator|=
name|NULL
expr_stmt|;
break|break;
block|}
elseif|else
if|if
condition|(
name|msg
operator|->
name|msgId
operator|>
name|msgId
condition|)
block|{
name|msgT
modifier|*
name|newMsg
decl_stmt|;
name|newMsg
operator|=
operator|(
name|msgT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|msgT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|newMsg
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|newMsg
argument_list|,
sizeof|sizeof
argument_list|(
name|msgT
argument_list|)
argument_list|)
expr_stmt|;
name|newMsg
operator|->
name|prev
operator|=
name|msg
operator|->
name|prev
expr_stmt|;
name|newMsg
operator|->
name|next
operator|=
name|msg
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|prev
condition|)
name|msg
operator|->
name|prev
operator|->
name|next
operator|=
name|newMsg
expr_stmt|;
else|else
name|curSet
operator|->
name|first
operator|=
name|newMsg
expr_stmt|;
name|msg
operator|->
name|prev
operator|=
name|newMsg
expr_stmt|;
name|msg
operator|=
name|newMsg
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
operator|!
name|msg
condition|)
block|{
name|msg
operator|=
operator|(
name|msgT
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|msgT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|msg
condition|)
name|nomem
argument_list|()
expr_stmt|;
name|bzero
argument_list|(
name|msg
argument_list|,
sizeof|sizeof
argument_list|(
name|msgT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|curSet
operator|->
name|first
condition|)
block|{
name|msg
operator|->
name|prev
operator|=
name|curSet
operator|->
name|last
expr_stmt|;
name|msg
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curSet
operator|->
name|last
operator|->
name|next
operator|=
name|msg
expr_stmt|;
name|curSet
operator|->
name|last
operator|=
name|msg
expr_stmt|;
block|}
else|else
block|{
name|msg
operator|->
name|prev
operator|=
name|msg
operator|->
name|next
operator|=
name|NULL
expr_stmt|;
name|curSet
operator|->
name|first
operator|=
name|curSet
operator|->
name|last
operator|=
name|msg
expr_stmt|;
block|}
block|}
name|msg
operator|->
name|msgId
operator|=
name|msgId
expr_stmt|;
if|if
condition|(
name|hconst
condition|)
name|msg
operator|->
name|hconst
operator|=
name|dupstr
argument_list|(
name|hconst
argument_list|)
expr_stmt|;
name|msg
operator|->
name|str
operator|=
name|dupstr
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MCDelSet
parameter_list|(
name|int
name|setId
parameter_list|)
block|{
name|setT
modifier|*
name|set
decl_stmt|;
name|msgT
modifier|*
name|msg
decl_stmt|;
for|for
control|(
name|set
operator|=
name|cat
operator|->
name|first
init|;
name|set
condition|;
name|set
operator|=
name|set
operator|->
name|next
control|)
block|{
if|if
condition|(
name|set
operator|->
name|setId
operator|==
name|setId
condition|)
block|{
for|for
control|(
name|msg
operator|=
name|set
operator|->
name|first
init|;
name|msg
condition|;
name|msg
operator|=
name|msg
operator|->
name|next
control|)
block|{
if|if
condition|(
name|msg
operator|->
name|hconst
condition|)
name|free
argument_list|(
name|msg
operator|->
name|hconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|str
condition|)
name|free
argument_list|(
name|msg
operator|->
name|str
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|set
operator|->
name|hconst
condition|)
name|free
argument_list|(
name|set
operator|->
name|hconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|prev
condition|)
name|set
operator|->
name|prev
operator|->
name|next
operator|=
name|set
operator|->
name|next
expr_stmt|;
else|else
name|cat
operator|->
name|first
operator|=
name|set
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|set
operator|->
name|next
condition|)
name|set
operator|->
name|next
operator|->
name|prev
operator|=
name|set
operator|->
name|prev
expr_stmt|;
else|else
name|cat
operator|->
name|last
operator|=
name|set
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|set
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|set
operator|->
name|setId
operator|>
name|setId
condition|)
break|break;
block|}
name|warning
argument_list|(
name|NULL
argument_list|,
literal|"specified set doesn't exist"
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|MCDelMsg
parameter_list|(
name|int
name|msgId
parameter_list|)
block|{
name|msgT
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|curSet
condition|)
name|error
argument_list|(
name|NULL
argument_list|,
literal|"you can't delete a message before defining the set"
argument_list|)
expr_stmt|;
for|for
control|(
name|msg
operator|=
name|curSet
operator|->
name|first
init|;
name|msg
condition|;
name|msg
operator|=
name|msg
operator|->
name|next
control|)
block|{
if|if
condition|(
name|msg
operator|->
name|msgId
operator|==
name|msgId
condition|)
block|{
if|if
condition|(
name|msg
operator|->
name|hconst
condition|)
name|free
argument_list|(
name|msg
operator|->
name|hconst
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|str
condition|)
name|free
argument_list|(
name|msg
operator|->
name|str
argument_list|)
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|prev
condition|)
name|msg
operator|->
name|prev
operator|->
name|next
operator|=
name|msg
operator|->
name|next
expr_stmt|;
else|else
name|curSet
operator|->
name|first
operator|=
name|msg
operator|->
name|next
expr_stmt|;
if|if
condition|(
name|msg
operator|->
name|next
condition|)
name|msg
operator|->
name|next
operator|->
name|prev
operator|=
name|msg
operator|->
name|prev
expr_stmt|;
else|else
name|curSet
operator|->
name|last
operator|=
name|msg
operator|->
name|prev
expr_stmt|;
name|free
argument_list|(
name|msg
argument_list|)
expr_stmt|;
return|return;
block|}
elseif|else
if|if
condition|(
name|msg
operator|->
name|msgId
operator|>
name|msgId
condition|)
break|break;
block|}
name|warning
argument_list|(
name|NULL
argument_list|,
literal|"specified msg doesn't exist"
argument_list|)
expr_stmt|;
block|}
end_function

begin_if
if|#
directive|if
literal|0
end_if

begin_comment
comment|/* this function is unsed and looks like debug thing */
end_comment

begin_endif
unit|void MCDumpcat(fp) FILE  *fp; {     msgT	*msg;     setT	*set;      if (!cat) 	errx(1, "no catalog open");      for (set = cat->first; set; set = set->next) { 	fprintf(fp, "$set %ld", set->setId); 	if (set->hconst) 	    fprintf(fp, " # %s", set->hconst); 	fprintf(fp, "\n\n");  	for (msg = set->first; msg; msg = msg->next) { 	    if (msg->hconst) 		fprintf(fp, "# %s\n", msg->hconst); 	    fprintf(fp, "%ld\t%s\n", msg->msgId, msg->str); 	} 	fprintf(fp, "\n");     }  }
endif|#
directive|endif
end_endif

begin_comment
comment|/* 0 */
end_comment

end_unit

