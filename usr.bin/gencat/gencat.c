begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that Alfalfa's name not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  If you make any modifications, bugfixes or other changes to this software we'd appreciate it if you could send a copy to us so we can keep things up-to-date.  Many thanks. 				Kee Hinckley 				Alfalfa Software, Inc. 				267 Allston St., #3 				Cambridge, MA 02139  USA 				nazgul@alfalfa.com  ******************************************************************/
end_comment

begin_comment
comment|/* Edit History  01/18/91   3 hamilton	#if not reparsed 01/12/91   2 schulert	conditionally use prototypes 12/23/90   2 hamilton	Fix fd == NULL to fd< 0 11/03/90   1 hamilton	Alphalpha->Alfalfa& OmegaMail->Poste 08/13/90   1 schulert	move from ua to omu */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_ifdef
ifdef|#
directive|ifdef
name|SYSV
end_ifdef

begin_include
include|#
directive|include
file|<sys/fcntl.h>
end_include

begin_define
define|#
directive|define
name|L_SET
value|SEEK_SET
end_define

begin_define
define|#
directive|define
name|L_INCR
value|SEEK_CUR
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|"gencat.h"
end_include

begin_comment
comment|/*  * The spec says the syntax is "gencat catfile msgfile...".  * We extend it to:  * 	gencat [-lang C|C++|ANSIC] catfile msgfile [-h<header-file>]...  * Flags are order dependant, we'll take whatever lang was most recently chosen  * and use it to generate the next header file.  The header files are generated  * at the point in the command line they are listed.  Thus the sequence:  *	gencat -lang C foo.cat foo.mcs -h foo.h -lang C++ bar.mcs -h bar.H  * will put constants from foo.mcs into foo.h and constants from bar.mcs into  * bar.h.  Constants are not saved in the catalog file, so nothing will come  * from that, even if things have been defined before.  The constants in foo.h  * will be in C syntax, in bar.H in C++ syntax.  */
end_comment

begin_if
if|#
directive|if
name|ANSI_C
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_define
define|#
directive|define
name|P_
parameter_list|(
name|x
parameter_list|)
value|x
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|P_
parameter_list|(
name|x
parameter_list|)
end_define

begin_comment
comment|/**/
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|void
name|writeIfChanged
name|P_
argument_list|(
operator|(
name|char
operator|*
name|fname
operator|,
name|int
name|lang
operator|,
name|int
name|orConsts
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_undef
undef|#
directive|undef
name|P_
end_undef

begin_function
name|void
name|usage
parameter_list|()
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Use: gencat [-new] [-or] [-lang C|C++|ANSIC]\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"            catfile msgfile [-h<header-file>]...\n"
argument_list|)
expr_stmt|;
block|}
end_function

begin_decl_stmt
name|void
decl|main
argument_list|(
if|#
directive|if
name|ANSI_C
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
name|int
name|argc
argument_list|,
name|char
operator|*
name|argv
index|[]
argument_list|)
else|#
directive|else
name|argc
decl_stmt|,
name|argv
decl_stmt|) int argc;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|argv
index|[]
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|int
name|ofd
decl_stmt|,
name|ifd
decl_stmt|,
name|i
decl_stmt|;
name|FILE
modifier|*
name|fptr
decl_stmt|;
name|char
modifier|*
name|catfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|input
init|=
name|NULL
decl_stmt|;
name|int
name|lang
init|=
name|MCLangC
decl_stmt|;
name|int
name|new
init|=
name|False
decl_stmt|;
name|int
name|orConsts
init|=
name|False
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
condition|)
name|lang
operator|=
name|MCLangC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"C++"
argument_list|)
operator|==
literal|0
condition|)
name|lang
operator|=
name|MCLangCPlusPlus
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"ANSIC"
argument_list|)
operator|==
literal|0
condition|)
name|lang
operator|=
name|MCLangANSIC
expr_stmt|;
else|else
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unrecognized language: %s\n"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|input
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Can't write to a header before reading something.\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
operator|++
name|i
expr_stmt|;
name|writeIfChanged
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|lang
argument_list|,
name|orConsts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-new"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|catfile
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: You must specify -new before the catalog file name\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|new
operator|=
name|True
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-or"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|orConsts
operator|=
operator|~
name|orConsts
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|catfile
condition|)
block|{
name|catfile
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to create a new %s.\n"
argument_list|,
name|catfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to create %s.\n"
argument_list|,
name|catfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|MCReadCat
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to truncate %s.\n"
argument_list|,
name|catfile
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
name|input
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
name|input
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to read %s\n"
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|MCParse
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|catfile
condition|)
block|{
name|MCWriteCat
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_block

begin_decl_stmt
specifier|static
name|void
name|writeIfChanged
argument_list|(
if|#
directive|if
name|ANSI_C
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
name|char
operator|*
name|fname
argument_list|,
name|int
name|lang
argument_list|,
name|int
name|orConsts
argument_list|)
else|#
directive|else
name|fname
decl_stmt|,
name|lang
decl_stmt|,
name|orConsts
decl_stmt|) char *fname;
end_decl_stmt

begin_decl_stmt
name|int
name|lang
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|orConsts
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_block
block|{
name|char
name|tmpname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|tfd
decl_stmt|;
name|int
name|diff
init|=
name|False
decl_stmt|;
name|int
name|c
decl_stmt|,
name|len
decl_stmt|,
name|tlen
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
comment|/* If it doesn't exist, just create it */
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to create header file %s.\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|MCWriteConst
argument_list|(
name|fd
argument_list|,
name|lang
argument_list|,
name|orConsts
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it does exist, create a temp file for now */
name|sprintf
argument_list|(
name|tmpname
argument_list|,
literal|"/tmp/gencat.%d"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfd
operator|=
name|open
argument_list|(
name|tmpname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to open temporary file: %s\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
comment|/* Write to the temp file and rewind */
name|MCWriteConst
argument_list|(
name|tfd
argument_list|,
name|lang
argument_list|,
name|orConsts
argument_list|)
expr_stmt|;
comment|/* Open the real header file */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to read header file: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Backup to the start of the temp file */
if|if
condition|(
name|lseek
argument_list|(
name|tfd
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to seek in tempfile: %s\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Now compare them */
while|while
condition|(
operator|(
name|tlen
operator|=
name|read
argument_list|(
name|tfd
argument_list|,
name|tbuf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|!=
name|tlen
condition|)
block|{
name|diff
operator|=
name|True
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|cptr
operator|=
name|buf
operator|,
name|tptr
operator|=
name|tbuf
init|;
name|cptr
operator|<
name|buf
operator|+
name|len
condition|;
operator|++
name|cptr
operator|,
operator|++
name|tptr
control|)
block|{
if|if
condition|(
operator|*
name|tptr
operator|!=
operator|*
name|cptr
condition|)
block|{
name|diff
operator|=
name|True
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|diff
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|tfd
argument_list|,
literal|0L
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to seek in tempfile: %s\n"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Unable to truncate header file: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|tfd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
operator|!=
name|len
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"gencat: Error writing to header file: %s\n"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
block|}
end_block

end_unit

