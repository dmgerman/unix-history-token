begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*********************************************************** Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that Alfalfa's name not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  If you make any modifications, bugfixes or other changes to this software we'd appreciate it if you could send a copy to us so we can keep things up-to-date.  Many thanks. 				Kee Hinckley 				Alfalfa Software, Inc. 				267 Allston St., #3 				Cambridge, MA 02139  USA 				nazgul@alfalfa.com  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/file.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"gencat.h"
end_include

begin_comment
comment|/*  * The spec says the syntax is "gencat catfile msgfile...".  * We extend it to:  * 	gencat [-lang C|C++|ANSIC] catfile msgfile [-h<header-file>]...  * Flags are order dependent, we'll take whatever lang was most recently chosen  * and use it to generate the next header file.  The header files are generated  * at the point in the command line they are listed.  Thus the sequence:  *	gencat -lang C foo.cat foo.mcs -h foo.h -lang C++ bar.mcs -h bar.H  * will put constants from foo.mcs into foo.h and constants from bar.mcs into  * bar.h.  Constants are not saved in the catalog file, so nothing will come  * from that, even if things have been defined before.  The constants in foo.h  * will be in C syntax, in bar.H in C++ syntax.  */
end_comment

begin_function_decl
specifier|static
name|void
name|writeIfChanged
parameter_list|(
name|char
modifier|*
parameter_list|,
name|int
parameter_list|,
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: gencat [-new] [-or] [-lang C|C++|ANSIC]\n"
literal|"              catfile msgfile [-h<header-file>]...\n"
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ofd
decl_stmt|,
name|ifd
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|catfile
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|input
init|=
name|NULL
decl_stmt|;
name|int
name|lang
init|=
name|MCLangC
decl_stmt|;
name|int
name|new
init|=
name|FALSE
decl_stmt|;
name|int
name|orConsts
init|=
name|FALSE
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|==
literal|'-'
condition|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-lang"
argument_list|)
operator|==
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
condition|)
name|lang
operator|=
name|MCLangC
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"C++"
argument_list|)
operator|==
literal|0
condition|)
name|lang
operator|=
name|MCLangCPlusPlus
expr_stmt|;
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"ANSIC"
argument_list|)
operator|==
literal|0
condition|)
name|lang
operator|=
name|MCLangANSIC
expr_stmt|;
else|else
block|{
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unrecognized language: %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-h"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
operator|!
name|input
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"can't write to a header before reading something"
argument_list|)
expr_stmt|;
operator|++
name|i
expr_stmt|;
name|writeIfChanged
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
name|lang
argument_list|,
name|orConsts
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-new"
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|catfile
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"you must specify -new before the catalog file name"
argument_list|)
expr_stmt|;
name|new
operator|=
name|TRUE
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-or"
argument_list|)
operator|==
literal|0
condition|)
block|{
name|orConsts
operator|=
operator|~
name|orConsts
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
operator|!
name|catfile
condition|)
block|{
name|catfile
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|new
condition|)
block|{
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to create a new %s"
argument_list|,
name|catfile
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to create %s"
argument_list|,
name|catfile
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|MCReadCat
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to truncate %s"
argument_list|,
name|catfile
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|input
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
name|input
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to read %s"
argument_list|,
name|input
argument_list|)
expr_stmt|;
name|MCParse
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
block|}
block|}
block|}
if|if
condition|(
name|catfile
condition|)
block|{
name|MCWriteCat
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|usage
argument_list|()
expr_stmt|;
block|}
return|return
literal|0
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|writeIfChanged
parameter_list|(
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|lang
parameter_list|,
name|int
name|orConsts
parameter_list|)
block|{
name|char
name|tmpname
index|[
literal|32
index|]
decl_stmt|;
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
name|tbuf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|tptr
decl_stmt|;
name|int
name|fd
decl_stmt|,
name|tfd
decl_stmt|;
name|int
name|diff
init|=
name|FALSE
decl_stmt|;
name|int
name|len
decl_stmt|,
name|tlen
decl_stmt|;
name|struct
name|stat
name|sbuf
decl_stmt|;
comment|/* If it doesn't exist, just create it */
if|if
condition|(
name|stat
argument_list|(
name|fname
argument_list|,
operator|&
name|sbuf
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_WRONLY
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to create header file %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
name|MCWriteConst
argument_list|(
name|fd
argument_list|,
name|lang
argument_list|,
name|orConsts
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it does exist, create a temp file for now */
name|sprintf
argument_list|(
name|tmpname
argument_list|,
literal|"/tmp/gencat.%d"
argument_list|,
operator|(
name|int
operator|)
name|getpid
argument_list|()
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|tfd
operator|=
name|open
argument_list|(
name|tmpname
argument_list|,
name|O_RDWR
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to open temporary file: %s"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|unlink
argument_list|(
name|tmpname
argument_list|)
expr_stmt|;
comment|/* Write to the temp file and rewind */
name|MCWriteConst
argument_list|(
name|tfd
argument_list|,
name|lang
argument_list|,
name|orConsts
argument_list|)
expr_stmt|;
comment|/* Open the real header file */
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to read header file: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
comment|/* Backup to the start of the temp file */
if|if
condition|(
name|lseek
argument_list|(
name|tfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to seek in tempfile: %s"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
comment|/* Now compare them */
while|while
condition|(
operator|(
name|tlen
operator|=
name|read
argument_list|(
name|tfd
argument_list|,
name|tbuf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|!=
name|tlen
condition|)
block|{
name|diff
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
for|for
control|(
name|cptr
operator|=
name|buf
operator|,
name|tptr
operator|=
name|tbuf
init|;
name|cptr
operator|<
name|buf
operator|+
name|len
condition|;
operator|++
name|cptr
operator|,
operator|++
name|tptr
control|)
block|{
if|if
condition|(
operator|*
name|tptr
operator|!=
operator|*
name|cptr
condition|)
block|{
name|diff
operator|=
name|TRUE
expr_stmt|;
goto|goto
name|done
goto|;
block|}
block|}
block|}
name|done
label|:
if|if
condition|(
name|diff
condition|)
block|{
if|if
condition|(
name|lseek
argument_list|(
name|tfd
argument_list|,
operator|(
name|off_t
operator|)
literal|0
argument_list|,
name|L_SET
argument_list|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to seek in tempfile: %s"
argument_list|,
name|tmpname
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fd
operator|=
name|open
argument_list|(
name|fname
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unable to truncate header file: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|len
operator|=
name|read
argument_list|(
name|tfd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
operator|)
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|write
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
operator|(
name|size_t
operator|)
name|len
argument_list|)
operator|!=
name|len
condition|)
name|warnx
argument_list|(
literal|"error writing to header file: %s"
argument_list|,
name|fname
argument_list|)
expr_stmt|;
block|}
block|}
name|close
argument_list|(
name|fd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|tfd
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

