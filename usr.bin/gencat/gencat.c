begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* ex:ts=4  */
end_comment

begin_comment
comment|/*	$NetBSD: gencat.c,v 1.18 2003/10/27 00:12:43 lukem Exp $	*/
end_comment

begin_comment
comment|/*  * Copyright (c) 1996 The NetBSD Foundation, Inc.  * All rights reserved.  *  * This code is derived from software contributed to The NetBSD Foundation  * by J.T. Conklin.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *        This product includes software developed by the NetBSD   *	  Foundation, Inc. and its contributors.  * 4. Neither the name of The NetBSD Foundation nor the names of its   *    contributors may be used to endorse or promote products derived   *    from this software without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS  * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED  * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS   * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR  * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF  * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS  * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN  * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)  * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE  * POSSIBILITY OF SUCH DAMAGE.  */
end_comment

begin_comment
comment|/*********************************************************** Copyright 1990, by Alfalfa Software Incorporated, Cambridge, Massachusetts.                          All Rights Reserved  Permission to use, copy, modify, and distribute this software and its documentation for any purpose and without fee is hereby granted, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation, and that Alfalfa's name not be used in advertising or publicity pertaining to distribution of the software without specific, written prior permission.  ALPHALPHA DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO EVENT SHALL ALPHALPHA BE LIABLE FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.  If you make any modifications, bugfixes or other changes to this software we'd appreciate it if you could send a copy to us so we can keep things up-to-date.  Many thanks. 				Kee Hinckley 				Alfalfa Software, Inc. 				267 Allston St., #3 				Cambridge, MA 02139  USA 				nazgul@alfalfa.com  ******************************************************************/
end_comment

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_define
define|#
directive|define
name|_NLS_PRIVATE
end_define

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/queue.h>
end_include

begin_include
include|#
directive|include
file|<arpa/inet.h>
end_include

begin_comment
comment|/* for htonl() */
end_comment

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<limits.h>
end_include

begin_include
include|#
directive|include
file|<nl_types.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_struct
struct|struct
name|_msgT
block|{
name|long
name|msgId
decl_stmt|;
name|char
modifier|*
name|str
decl_stmt|;
name|LIST_ENTRY
argument_list|(
argument|_msgT
argument_list|)
name|entries
expr_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|_setT
block|{
name|long
name|setId
decl_stmt|;
name|LIST_HEAD
argument_list|(
argument|msghead
argument_list|,
argument|_msgT
argument_list|)
name|msghead
expr_stmt|;
name|LIST_ENTRY
argument_list|(
argument|_setT
argument_list|)
name|entries
expr_stmt|;
block|}
struct|;
end_struct

begin_macro
name|LIST_HEAD
argument_list|(
argument|sethead
argument_list|,
argument|_setT
argument_list|)
end_macro

begin_expr_stmt
name|sethead
expr_stmt|;
end_expr_stmt

begin_decl_stmt
specifier|static
name|struct
name|_setT
modifier|*
name|curSet
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|curline
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|long
name|lineno
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_function_decl
specifier|static
name|char
modifier|*
name|cskip
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getline
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|getmsg
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|,
name|char
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|wskip
parameter_list|(
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|char
modifier|*
name|xstrdup
parameter_list|(
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
parameter_list|,
name|size_t
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MCParse
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MCReadCat
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MCWriteCat
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MCDelMsg
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MCAddMsg
parameter_list|(
name|int
parameter_list|,
specifier|const
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MCAddSet
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|MCDelSet
parameter_list|(
name|int
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|main
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"usage: %s catfile msgfile ...\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
name|int
name|ofd
decl_stmt|,
name|ifd
decl_stmt|;
name|char
modifier|*
name|catfile
init|=
name|NULL
decl_stmt|;
name|int
name|c
decl_stmt|;
define|#
directive|define
name|DEPRECATEDMSG
value|1
ifdef|#
directive|ifdef
name|DEPRECATEDMSG
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"new"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
else|#
directive|else
while|while
condition|(
operator|(
name|c
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|""
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
endif|#
directive|endif
switch|switch
condition|(
name|c
condition|)
block|{
ifdef|#
directive|ifdef
name|DEPRECATEDMSG
case|case
literal|'n'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"WARNING: Usage of \"-new\" argument is deprecated.\n"
argument_list|)
expr_stmt|;
case|case
literal|'e'
case|:
case|case
literal|'w'
case|:
break|break;
endif|#
directive|endif
case|case
literal|'?'
case|:
default|default:
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
if|if
condition|(
name|argc
operator|<
literal|2
condition|)
block|{
name|usage
argument_list|()
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|catfile
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
for|for
control|(
init|;
operator|*
name|argv
condition|;
name|argv
operator|++
control|)
block|{
if|if
condition|(
operator|(
name|ifd
operator|=
name|open
argument_list|(
operator|*
name|argv
argument_list|,
name|O_RDONLY
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unable to read %s"
argument_list|,
operator|*
name|argv
argument_list|)
expr_stmt|;
name|MCParse
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|ifd
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|ofd
operator|=
name|open
argument_list|(
name|catfile
argument_list|,
name|O_WRONLY
operator||
name|O_TRUNC
operator||
name|O_CREAT
argument_list|,
literal|0666
argument_list|)
operator|)
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"Unable to create a new %s"
argument_list|,
name|catfile
argument_list|)
expr_stmt|;
name|MCWriteCat
argument_list|(
name|ofd
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
name|warning
parameter_list|(
specifier|const
name|char
modifier|*
name|cptr
parameter_list|,
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: %s on line %ld\n"
argument_list|,
name|getprogname
argument_list|()
argument_list|,
name|msg
argument_list|,
name|lineno
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s\n"
argument_list|,
name|curline
argument_list|)
expr_stmt|;
if|if
condition|(
name|cptr
condition|)
block|{
name|char
modifier|*
name|tptr
decl_stmt|;
for|for
control|(
name|tptr
operator|=
name|curline
init|;
name|tptr
operator|<
name|cptr
condition|;
operator|++
name|tptr
control|)
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"^\n"
argument_list|)
expr_stmt|;
block|}
block|}
define|#
directive|define
name|CORRUPT
parameter_list|()
value|{ error("corrupt message catalog"); }
define|#
directive|define
name|NOMEM
parameter_list|()
value|{ error("out of memory"); }
specifier|static
name|void
name|error
parameter_list|(
specifier|const
name|char
modifier|*
name|msg
parameter_list|)
block|{
name|warning
argument_list|(
name|NULL
argument_list|,
name|msg
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
specifier|static
name|void
modifier|*
name|xmalloc
parameter_list|(
name|size_t
name|len
parameter_list|)
block|{
name|void
modifier|*
name|p
decl_stmt|;
if|if
condition|(
operator|(
name|p
operator|=
name|malloc
argument_list|(
name|len
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|NOMEM
argument_list|()
expr_stmt|;
return|return
operator|(
name|p
operator|)
return|;
block|}
specifier|static
name|void
modifier|*
name|xrealloc
parameter_list|(
name|void
modifier|*
name|ptr
parameter_list|,
name|size_t
name|size
parameter_list|)
block|{
if|if
condition|(
operator|(
name|ptr
operator|=
name|realloc
argument_list|(
name|ptr
argument_list|,
name|size
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|NOMEM
argument_list|()
expr_stmt|;
return|return
operator|(
name|ptr
operator|)
return|;
block|}
specifier|static
name|char
modifier|*
name|xstrdup
parameter_list|(
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|char
modifier|*
name|nstr
decl_stmt|;
if|if
condition|(
operator|(
name|nstr
operator|=
name|strdup
argument_list|(
name|str
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|NOMEM
argument_list|()
expr_stmt|;
return|return
operator|(
name|nstr
operator|)
return|;
block|}
specifier|static
name|char
modifier|*
name|getline
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
specifier|static
name|long
name|curlen
init|=
name|BUFSIZ
decl_stmt|;
specifier|static
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|,
modifier|*
name|bptr
init|=
name|buf
decl_stmt|,
modifier|*
name|bend
init|=
name|buf
decl_stmt|;
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|cend
decl_stmt|;
name|long
name|buflen
decl_stmt|;
if|if
condition|(
operator|!
name|curline
condition|)
block|{
name|curline
operator|=
name|xmalloc
argument_list|(
name|curlen
argument_list|)
expr_stmt|;
block|}
operator|++
name|lineno
expr_stmt|;
name|cptr
operator|=
name|curline
expr_stmt|;
name|cend
operator|=
name|curline
operator|+
name|curlen
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
for|for
control|(
init|;
name|bptr
operator|<
name|bend
operator|&&
name|cptr
operator|<
name|cend
condition|;
operator|++
name|cptr
operator|,
operator|++
name|bptr
control|)
block|{
if|if
condition|(
operator|*
name|bptr
operator|==
literal|'\n'
condition|)
block|{
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
operator|++
name|bptr
expr_stmt|;
return|return
operator|(
name|curline
operator|)
return|;
block|}
else|else
operator|*
name|cptr
operator|=
operator|*
name|bptr
expr_stmt|;
block|}
if|if
condition|(
name|cptr
operator|==
name|cend
condition|)
block|{
name|cptr
operator|=
name|curline
operator|=
name|xrealloc
argument_list|(
name|curline
argument_list|,
name|curlen
operator|*=
literal|2
argument_list|)
expr_stmt|;
name|cend
operator|=
name|curline
operator|+
name|curlen
expr_stmt|;
block|}
if|if
condition|(
name|bptr
operator|==
name|bend
condition|)
block|{
name|buflen
operator|=
name|read
argument_list|(
name|fd
argument_list|,
name|buf
argument_list|,
name|BUFSIZ
argument_list|)
expr_stmt|;
if|if
condition|(
name|buflen
operator|<=
literal|0
condition|)
block|{
if|if
condition|(
name|cptr
operator|>
name|curline
condition|)
block|{
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|curline
operator|)
return|;
block|}
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|bend
operator|=
name|buf
operator|+
name|buflen
expr_stmt|;
name|bptr
operator|=
name|buf
expr_stmt|;
block|}
block|}
block|}
specifier|static
name|char
modifier|*
name|wskip
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|cptr
operator|||
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"expected a space"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cptr
operator|&&
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
operator|++
name|cptr
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
specifier|static
name|char
modifier|*
name|cskip
parameter_list|(
name|char
modifier|*
name|cptr
parameter_list|)
block|{
if|if
condition|(
operator|!
operator|*
name|cptr
operator|||
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"wasn't expecting a space"
argument_list|)
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
while|while
condition|(
operator|*
name|cptr
operator|&&
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
operator|++
name|cptr
expr_stmt|;
return|return
operator|(
name|cptr
operator|)
return|;
block|}
specifier|static
name|char
modifier|*
name|getmsg
parameter_list|(
name|int
name|fd
parameter_list|,
name|char
modifier|*
name|cptr
parameter_list|,
name|char
name|quote
parameter_list|)
block|{
specifier|static
name|char
modifier|*
name|msg
init|=
name|NULL
decl_stmt|;
specifier|static
name|long
name|msglen
init|=
literal|0
decl_stmt|;
name|long
name|clen
decl_stmt|,
name|i
decl_stmt|;
name|char
modifier|*
name|tptr
decl_stmt|;
if|if
condition|(
name|quote
operator|&&
operator|*
name|cptr
operator|==
name|quote
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
block|}
name|clen
operator|=
name|strlen
argument_list|(
name|cptr
argument_list|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|clen
operator|>
name|msglen
condition|)
block|{
if|if
condition|(
name|msglen
condition|)
name|msg
operator|=
name|xrealloc
argument_list|(
name|msg
argument_list|,
name|clen
argument_list|)
expr_stmt|;
else|else
name|msg
operator|=
name|xmalloc
argument_list|(
name|clen
argument_list|)
expr_stmt|;
name|msglen
operator|=
name|clen
expr_stmt|;
block|}
name|tptr
operator|=
name|msg
expr_stmt|;
while|while
condition|(
operator|*
name|cptr
condition|)
block|{
if|if
condition|(
name|quote
operator|&&
operator|*
name|cptr
operator|==
name|quote
condition|)
block|{
name|char
modifier|*
name|tmp
decl_stmt|;
name|tmp
operator|=
name|cptr
operator|+
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|tmp
operator|&&
operator|(
operator|!
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|tmp
argument_list|)
operator|||
operator|*
name|wskip
argument_list|(
name|tmp
argument_list|)
operator|)
condition|)
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"unexpected quote character, ignoring"
argument_list|)
expr_stmt|;
operator|*
name|tptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
block|}
else|else
block|{
operator|*
name|cptr
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'\\'
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
switch|switch
condition|(
operator|*
name|cptr
condition|)
block|{
case|case
literal|'\0'
case|:
name|cptr
operator|=
name|getline
argument_list|(
name|fd
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|cptr
condition|)
name|error
argument_list|(
literal|"premature end of file"
argument_list|)
expr_stmt|;
name|msglen
operator|+=
name|strlen
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|i
operator|=
name|tptr
operator|-
name|msg
expr_stmt|;
name|msg
operator|=
name|xrealloc
argument_list|(
name|msg
argument_list|,
name|msglen
argument_list|)
expr_stmt|;
name|tptr
operator|=
name|msg
operator|+
name|i
expr_stmt|;
break|break;
define|#
directive|define
name|CASEOF
parameter_list|(
name|CS
parameter_list|,
name|CH
parameter_list|)
define|\
value|case CS:		\ 				*tptr++ = CH;	\ 				++cptr;		\ 				break;		\  				CASEOF('n', '\n');
name|CASEOF
argument_list|(
literal|'t'
argument_list|,
literal|'\t'
argument_list|)
expr_stmt|;
name|CASEOF
argument_list|(
literal|'v'
argument_list|,
literal|'\v'
argument_list|)
expr_stmt|;
name|CASEOF
argument_list|(
literal|'b'
argument_list|,
literal|'\b'
argument_list|)
expr_stmt|;
name|CASEOF
argument_list|(
literal|'r'
argument_list|,
literal|'\r'
argument_list|)
expr_stmt|;
name|CASEOF
argument_list|(
literal|'f'
argument_list|,
literal|'\f'
argument_list|)
expr_stmt|;
name|CASEOF
argument_list|(
literal|'"'
argument_list|,
literal|'"'
argument_list|)
expr_stmt|;
name|CASEOF
argument_list|(
literal|'\\'
argument_list|,
literal|'\\'
argument_list|)
expr_stmt|;
default|default:
if|if
condition|(
name|quote
operator|&&
operator|*
name|cptr
operator|==
name|quote
condition|)
block|{
operator|*
name|tptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
operator|*
name|tptr
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
literal|3
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
break|break;
if|if
condition|(
operator|*
name|cptr
operator|>
literal|'7'
condition|)
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"octal number greater than 7?!"
argument_list|)
expr_stmt|;
operator|*
name|tptr
operator|*=
literal|8
expr_stmt|;
operator|*
name|tptr
operator|+=
operator|(
operator|*
name|cptr
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|++
name|cptr
expr_stmt|;
block|}
block|}
else|else
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"unrecognized escape sequence"
argument_list|)
expr_stmt|;
block|}
break|break;
block|}
block|}
else|else
block|{
operator|*
name|tptr
operator|++
operator|=
operator|*
name|cptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|tptr
operator|=
literal|'\0'
expr_stmt|;
return|return
operator|(
name|msg
operator|)
return|;
block|}
name|void
name|MCParse
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|char
modifier|*
name|cptr
decl_stmt|,
modifier|*
name|str
decl_stmt|;
name|int
name|setid
decl_stmt|,
name|msgid
init|=
literal|0
decl_stmt|;
name|char
name|quote
init|=
literal|0
decl_stmt|;
comment|/* XXX: init sethead? */
while|while
condition|(
operator|(
name|cptr
operator|=
name|getline
argument_list|(
name|fd
argument_list|)
operator|)
condition|)
block|{
if|if
condition|(
operator|*
name|cptr
operator|==
literal|'$'
condition|)
block|{
operator|++
name|cptr
expr_stmt|;
if|if
condition|(
name|strncmp
argument_list|(
name|cptr
argument_list|,
literal|"set"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cptr
operator|+=
literal|3
expr_stmt|;
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|setid
operator|=
name|atoi
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|MCAddSet
argument_list|(
name|setid
argument_list|)
expr_stmt|;
name|msgid
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cptr
argument_list|,
literal|"delset"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cptr
operator|+=
literal|6
expr_stmt|;
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|setid
operator|=
name|atoi
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|MCDelSet
argument_list|(
name|setid
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|cptr
argument_list|,
literal|"quote"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
block|{
name|cptr
operator|+=
literal|5
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
else|else
block|{
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
else|else
name|quote
operator|=
operator|*
name|cptr
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|isspace
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|cptr
condition|)
block|{
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|*
name|cptr
condition|)
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"unrecognized line"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
comment|/* 			 * First check for (and eat) empty lines.... 			 */
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
continue|continue;
comment|/* 			 * We have a digit? Start of a message. Else, 			 * syntax error. 			 */
if|if
condition|(
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|cptr
argument_list|)
condition|)
block|{
name|msgid
operator|=
name|atoi
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|cskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
name|cptr
operator|=
name|wskip
argument_list|(
name|cptr
argument_list|)
expr_stmt|;
comment|/* if (*cptr) ++cptr; */
block|}
else|else
block|{
name|warning
argument_list|(
name|cptr
argument_list|,
literal|"neither blank line nor start of a message id"
argument_list|)
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * If we have a message ID, but no message, 			 * then this means "delete this message id 			 * from the catalog". 			 */
if|if
condition|(
operator|!
operator|*
name|cptr
condition|)
block|{
name|MCDelMsg
argument_list|(
name|msgid
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|str
operator|=
name|getmsg
argument_list|(
name|fd
argument_list|,
name|cptr
argument_list|,
name|quote
argument_list|)
expr_stmt|;
name|MCAddMsg
argument_list|(
name|msgid
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
name|void
name|MCReadCat
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|fd
operator|=
literal|0
expr_stmt|;
if|#
directive|if
literal|0
block|MCHeaderT mcHead; 	MCMsgT  mcMsg; 	MCSetT  mcSet; 	msgT   *msg; 	setT   *set; 	int     i; 	char   *data;
comment|/* XXX init sethead? */
block|if (read(fd,&mcHead, sizeof(mcHead)) != sizeof(mcHead)) 		CORRUPT(); 	if (strncmp(mcHead.magic, MCMagic, MCMagicLen) != 0) 		CORRUPT(); 	if (mcHead.majorVer != MCMajorVer) 		error("unrecognized catalog version"); 	if ((mcHead.flags& MCGetByteOrder()) == 0) 		error("wrong byte order");  	if (lseek(fd, mcHead.firstSet, SEEK_SET) == -1) 		CORRUPT();  	for (;;) { 		if (read(fd,&mcSet, sizeof(mcSet)) != sizeof(mcSet)) 			CORRUPT(); 		if (mcSet.invalid) 			continue;  		set = xmalloc(sizeof(setT)); 		memset(set, '\0', sizeof(*set)); 		if (cat->first) { 			cat->last->next = set; 			set->prev = cat->last; 			cat->last = set; 		} else 			cat->first = cat->last = set;  		set->setId = mcSet.setId;
comment|/* Get the data */
block|if (mcSet.dataLen) { 			data = xmalloc(mcSet.dataLen); 			if (lseek(fd, mcSet.data.off, SEEK_SET) == -1) 				CORRUPT(); 			if (read(fd, data, mcSet.dataLen) != mcSet.dataLen) 				CORRUPT(); 			if (lseek(fd, mcSet.u.firstMsg, SEEK_SET) == -1) 				CORRUPT();  			for (i = 0; i< mcSet.numMsgs; ++i) { 				if (read(fd,&mcMsg, sizeof(mcMsg)) != sizeof(mcMsg)) 					CORRUPT(); 				if (mcMsg.invalid) { 					--i; 					continue; 				} 				msg = xmalloc(sizeof(msgT)); 				memset(msg, '\0', sizeof(*msg)); 				if (set->first) { 					set->last->next = msg; 					msg->prev = set->last; 					set->last = msg; 				} else 					set->first = set->last = msg;  				msg->msgId = mcMsg.msgId; 				msg->str = xstrdup((char *) (data + mcMsg.msg.off)); 			} 			free(data); 		} 		if (!mcSet.nextSet) 			break; 		if (lseek(fd, mcSet.nextSet, SEEK_SET) == -1) 			CORRUPT(); 	}
endif|#
directive|endif
block|}
comment|/*  * Write message catalog.  *  * The message catalog is first converted from its internal to its  * external representation in a chunk of memory allocated for this  * purpose.  Then the completed catalog is written.  This approach  * avoids additional housekeeping variables and/or a lot of seeks  * that would otherwise be required.  */
name|void
name|MCWriteCat
parameter_list|(
name|int
name|fd
parameter_list|)
block|{
name|int
name|nsets
decl_stmt|;
comment|/* number of sets */
name|int
name|nmsgs
decl_stmt|;
comment|/* number of msgs */
name|int
name|string_size
decl_stmt|;
comment|/* total size of string pool */
name|int
name|msgcat_size
decl_stmt|;
comment|/* total size of message catalog */
name|void
modifier|*
name|msgcat
decl_stmt|;
comment|/* message catalog data */
name|struct
name|_nls_cat_hdr
modifier|*
name|cat_hdr
decl_stmt|;
name|struct
name|_nls_set_hdr
modifier|*
name|set_hdr
decl_stmt|;
name|struct
name|_nls_msg_hdr
modifier|*
name|msg_hdr
decl_stmt|;
name|char
modifier|*
name|strings
decl_stmt|;
name|struct
name|_setT
modifier|*
name|set
decl_stmt|;
name|struct
name|_msgT
modifier|*
name|msg
decl_stmt|;
name|int
name|msg_index
decl_stmt|;
name|int
name|msg_offset
decl_stmt|;
comment|/* determine number of sets, number of messages, and size of the 	 * string pool */
name|nsets
operator|=
literal|0
expr_stmt|;
name|nmsgs
operator|=
literal|0
expr_stmt|;
name|string_size
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|set
operator|=
name|sethead
operator|.
name|lh_first
init|;
name|set
operator|!=
name|NULL
condition|;
name|set
operator|=
name|set
operator|->
name|entries
operator|.
name|le_next
control|)
block|{
name|nsets
operator|++
expr_stmt|;
for|for
control|(
name|msg
operator|=
name|set
operator|->
name|msghead
operator|.
name|lh_first
init|;
name|msg
operator|!=
name|NULL
condition|;
name|msg
operator|=
name|msg
operator|->
name|entries
operator|.
name|le_next
control|)
block|{
name|nmsgs
operator|++
expr_stmt|;
name|string_size
operator|+=
name|strlen
argument_list|(
name|msg
operator|->
name|str
argument_list|)
operator|+
literal|1
expr_stmt|;
block|}
block|}
ifdef|#
directive|ifdef
name|DEBUG
name|printf
argument_list|(
literal|"number of sets: %d\n"
argument_list|,
name|nsets
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"number of msgs: %d\n"
argument_list|,
name|nmsgs
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"string pool size: %d\n"
argument_list|,
name|string_size
argument_list|)
expr_stmt|;
endif|#
directive|endif
comment|/* determine size and then allocate buffer for constructing external 	 * message catalog representation */
name|msgcat_size
operator|=
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
operator|+
operator|(
name|nsets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_set_hdr
argument_list|)
operator|)
operator|+
operator|(
name|nmsgs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_msg_hdr
argument_list|)
operator|)
operator|+
name|string_size
expr_stmt|;
name|msgcat
operator|=
name|xmalloc
argument_list|(
name|msgcat_size
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|msgcat
argument_list|,
literal|'\0'
argument_list|,
name|msgcat_size
argument_list|)
expr_stmt|;
comment|/* fill in msg catalog header */
name|cat_hdr
operator|=
operator|(
expr|struct
name|_nls_cat_hdr
operator|*
operator|)
name|msgcat
expr_stmt|;
name|cat_hdr
operator|->
name|__magic
operator|=
name|htonl
argument_list|(
name|_NLS_MAGIC
argument_list|)
expr_stmt|;
name|cat_hdr
operator|->
name|__nsets
operator|=
name|htonl
argument_list|(
name|nsets
argument_list|)
expr_stmt|;
name|cat_hdr
operator|->
name|__mem
operator|=
name|htonl
argument_list|(
name|msgcat_size
operator|-
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|cat_hdr
operator|->
name|__msg_hdr_offset
operator|=
name|htonl
argument_list|(
name|nsets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_set_hdr
argument_list|)
argument_list|)
expr_stmt|;
name|cat_hdr
operator|->
name|__msg_txt_offset
operator|=
name|htonl
argument_list|(
name|nsets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_set_hdr
argument_list|)
operator|+
name|nmsgs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_msg_hdr
argument_list|)
argument_list|)
expr_stmt|;
comment|/* compute offsets for set& msg header tables and string pool */
name|set_hdr
operator|=
operator|(
expr|struct
name|_nls_set_hdr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|msgcat
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
operator|)
expr_stmt|;
name|msg_hdr
operator|=
operator|(
expr|struct
name|_nls_msg_hdr
operator|*
operator|)
operator|(
name|void
operator|*
operator|)
operator|(
operator|(
name|char
operator|*
operator|)
name|msgcat
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
operator|+
name|nsets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_set_hdr
argument_list|)
operator|)
expr_stmt|;
name|strings
operator|=
operator|(
name|char
operator|*
operator|)
name|msgcat
operator|+
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_cat_hdr
argument_list|)
operator|+
name|nsets
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_set_hdr
argument_list|)
operator|+
name|nmsgs
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|_nls_msg_hdr
argument_list|)
expr_stmt|;
name|msg_index
operator|=
literal|0
expr_stmt|;
name|msg_offset
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|set
operator|=
name|sethead
operator|.
name|lh_first
init|;
name|set
operator|!=
name|NULL
condition|;
name|set
operator|=
name|set
operator|->
name|entries
operator|.
name|le_next
control|)
block|{
name|nmsgs
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|msg
operator|=
name|set
operator|->
name|msghead
operator|.
name|lh_first
init|;
name|msg
operator|!=
name|NULL
condition|;
name|msg
operator|=
name|msg
operator|->
name|entries
operator|.
name|le_next
control|)
block|{
name|int
name|msg_len
init|=
name|strlen
argument_list|(
name|msg
operator|->
name|str
argument_list|)
operator|+
literal|1
decl_stmt|;
name|msg_hdr
operator|->
name|__msgno
operator|=
name|htonl
argument_list|(
name|msg
operator|->
name|msgId
argument_list|)
expr_stmt|;
name|msg_hdr
operator|->
name|__msglen
operator|=
name|htonl
argument_list|(
name|msg_len
argument_list|)
expr_stmt|;
name|msg_hdr
operator|->
name|__offset
operator|=
name|htonl
argument_list|(
name|msg_offset
argument_list|)
expr_stmt|;
name|memcpy
argument_list|(
name|strings
argument_list|,
name|msg
operator|->
name|str
argument_list|,
name|msg_len
argument_list|)
expr_stmt|;
name|strings
operator|+=
name|msg_len
expr_stmt|;
name|msg_offset
operator|+=
name|msg_len
expr_stmt|;
name|nmsgs
operator|++
expr_stmt|;
name|msg_hdr
operator|++
expr_stmt|;
block|}
name|set_hdr
operator|->
name|__setno
operator|=
name|htonl
argument_list|(
name|set
operator|->
name|setId
argument_list|)
expr_stmt|;
name|set_hdr
operator|->
name|__nmsgs
operator|=
name|htonl
argument_list|(
name|nmsgs
argument_list|)
expr_stmt|;
name|set_hdr
operator|->
name|__index
operator|=
name|htonl
argument_list|(
name|msg_index
argument_list|)
expr_stmt|;
name|msg_index
operator|+=
name|nmsgs
expr_stmt|;
name|set_hdr
operator|++
expr_stmt|;
block|}
comment|/* write out catalog.  XXX: should this be done in small chunks? */
name|write
argument_list|(
name|fd
argument_list|,
name|msgcat
argument_list|,
name|msgcat_size
argument_list|)
expr_stmt|;
block|}
name|void
name|MCAddSet
parameter_list|(
name|int
name|setId
parameter_list|)
block|{
name|struct
name|_setT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
name|setId
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"setId's must be greater than zero"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|setId
operator|>
name|NL_SETMAX
condition|)
block|{
name|error
argument_list|(
literal|"setId exceeds limit"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|p
operator|=
name|sethead
operator|.
name|lh_first
expr_stmt|;
name|q
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|setId
operator|<
name|setId
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|entries
operator|.
name|le_next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|setId
operator|==
name|setId
condition|)
block|{
empty_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_setT
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_setT
argument_list|)
argument_list|)
expr_stmt|;
name|LIST_INIT
argument_list|(
operator|&
name|p
operator|->
name|msghead
argument_list|)
expr_stmt|;
name|p
operator|->
name|setId
operator|=
name|setId
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|sethead
argument_list|,
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
name|curSet
operator|=
name|p
expr_stmt|;
block|}
name|void
name|MCAddMsg
parameter_list|(
name|int
name|msgId
parameter_list|,
specifier|const
name|char
modifier|*
name|str
parameter_list|)
block|{
name|struct
name|_msgT
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
if|if
condition|(
operator|!
name|curSet
condition|)
name|error
argument_list|(
literal|"can't specify a message when no set exists"
argument_list|)
expr_stmt|;
if|if
condition|(
name|msgId
operator|<=
literal|0
condition|)
block|{
name|error
argument_list|(
literal|"msgId's must be greater than zero"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
if|if
condition|(
name|msgId
operator|>
name|NL_MSGMAX
condition|)
block|{
name|error
argument_list|(
literal|"msgID exceeds limit"
argument_list|)
expr_stmt|;
comment|/* NOTREACHED */
block|}
name|p
operator|=
name|curSet
operator|->
name|msghead
operator|.
name|lh_first
expr_stmt|;
name|q
operator|=
name|NULL
expr_stmt|;
for|for
control|(
init|;
name|p
operator|!=
name|NULL
operator|&&
name|p
operator|->
name|msgId
operator|<
name|msgId
condition|;
name|q
operator|=
name|p
operator|,
name|p
operator|=
name|p
operator|->
name|entries
operator|.
name|le_next
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|&&
name|p
operator|->
name|msgId
operator|==
name|msgId
condition|)
block|{
name|free
argument_list|(
name|p
operator|->
name|str
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|p
operator|=
name|xmalloc
argument_list|(
sizeof|sizeof
argument_list|(
expr|struct
name|_msgT
argument_list|)
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|p
argument_list|,
literal|'\0'
argument_list|,
sizeof|sizeof
argument_list|(
expr|struct
name|_msgT
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|q
operator|==
name|NULL
condition|)
block|{
name|LIST_INSERT_HEAD
argument_list|(
operator|&
name|curSet
operator|->
name|msghead
argument_list|,
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|LIST_INSERT_AFTER
argument_list|(
name|q
argument_list|,
name|p
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
block|}
name|p
operator|->
name|msgId
operator|=
name|msgId
expr_stmt|;
name|p
operator|->
name|str
operator|=
name|xstrdup
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
name|void
name|MCDelSet
parameter_list|(
name|int
name|setId
parameter_list|)
block|{
name|struct
name|_setT
modifier|*
name|set
decl_stmt|;
name|struct
name|_msgT
modifier|*
name|msg
decl_stmt|;
name|set
operator|=
name|sethead
operator|.
name|lh_first
expr_stmt|;
for|for
control|(
init|;
name|set
operator|!=
name|NULL
operator|&&
name|set
operator|->
name|setId
operator|<
name|setId
condition|;
name|set
operator|=
name|set
operator|->
name|entries
operator|.
name|le_next
control|)
empty_stmt|;
if|if
condition|(
name|set
operator|&&
name|set
operator|->
name|setId
operator|==
name|setId
condition|)
block|{
name|msg
operator|=
name|set
operator|->
name|msghead
operator|.
name|lh_first
expr_stmt|;
while|while
condition|(
name|msg
condition|)
block|{
name|free
argument_list|(
name|msg
operator|->
name|str
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|msg
argument_list|,
name|entries
argument_list|)
expr_stmt|;
block|}
name|LIST_REMOVE
argument_list|(
name|set
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return;
block|}
name|warning
argument_list|(
name|NULL
argument_list|,
literal|"specified set doesn't exist"
argument_list|)
expr_stmt|;
block|}
name|void
name|MCDelMsg
parameter_list|(
name|int
name|msgId
parameter_list|)
block|{
name|struct
name|_msgT
modifier|*
name|msg
decl_stmt|;
if|if
condition|(
operator|!
name|curSet
condition|)
name|error
argument_list|(
literal|"you can't delete a message before defining the set"
argument_list|)
expr_stmt|;
name|msg
operator|=
name|curSet
operator|->
name|msghead
operator|.
name|lh_first
expr_stmt|;
for|for
control|(
init|;
name|msg
operator|!=
name|NULL
operator|&&
name|msg
operator|->
name|msgId
operator|<
name|msgId
condition|;
name|msg
operator|=
name|msg
operator|->
name|entries
operator|.
name|le_next
control|)
empty_stmt|;
if|if
condition|(
name|msg
operator|&&
name|msg
operator|->
name|msgId
operator|==
name|msgId
condition|)
block|{
name|free
argument_list|(
name|msg
operator|->
name|str
argument_list|)
expr_stmt|;
name|LIST_REMOVE
argument_list|(
name|msg
argument_list|,
name|entries
argument_list|)
expr_stmt|;
return|return;
block|}
name|warning
argument_list|(
name|NULL
argument_list|,
literal|"specified msg doesn't exist"
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

