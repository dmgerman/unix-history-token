begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1997 Wolfgang Helbig  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  *  * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<calendar.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sysexits.h>
end_include

begin_include
include|#
directive|include
file|<time.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<wchar.h>
end_include

begin_include
include|#
directive|include
file|<wctype.h>
end_include

begin_include
include|#
directive|include
file|<term.h>
end_include

begin_undef
undef|#
directive|undef
name|lines
end_undef

begin_comment
comment|/* term.h defines this */
end_comment

begin_comment
comment|/* Width of one month with backward compatibility and in regular mode*/
end_comment

begin_define
define|#
directive|define
name|MONTH_WIDTH_B_J
value|27
end_define

begin_define
define|#
directive|define
name|MONTH_WIDTH_B
value|20
end_define

begin_define
define|#
directive|define
name|MONTH_WIDTH_R_J
value|24
end_define

begin_define
define|#
directive|define
name|MONTH_WIDTH_R
value|18
end_define

begin_define
define|#
directive|define
name|MAX_WIDTH
value|64
end_define

begin_typedef
typedef|typedef
name|struct
name|date
name|date
typedef|;
end_typedef

begin_struct
struct|struct
name|monthlines
block|{
name|wchar_t
name|name
index|[
name|MAX_WIDTH
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|lines
index|[
literal|7
index|]
index|[
name|MAX_WIDTH
operator|+
literal|1
index|]
decl_stmt|;
name|char
name|weeks
index|[
name|MAX_WIDTH
operator|+
literal|1
index|]
decl_stmt|;
name|unsigned
name|int
name|extralen
index|[
literal|7
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_struct
struct|struct
name|weekdays
block|{
name|wchar_t
name|names
index|[
literal|7
index|]
index|[
literal|4
index|]
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/* The switches from Julian to Gregorian in some countries */
end_comment

begin_struct
specifier|static
struct|struct
name|djswitch
block|{
specifier|const
name|char
modifier|*
name|cc
decl_stmt|;
comment|/* Country code according to ISO 3166 */
specifier|const
name|char
modifier|*
name|nm
decl_stmt|;
comment|/* Name of country */
name|date
name|dt
decl_stmt|;
comment|/* Last day of Julian calendar */
block|}
name|switches
index|[]
init|=
block|{
block|{
literal|"AL"
block|,
literal|"Albania"
block|,
block|{
literal|1912
block|,
literal|11
block|,
literal|30
block|}
block|}
block|,
block|{
literal|"AT"
block|,
literal|"Austria"
block|,
block|{
literal|1583
block|,
literal|10
block|,
literal|5
block|}
block|}
block|,
block|{
literal|"AU"
block|,
literal|"Australia"
block|,
block|{
literal|1752
block|,
literal|9
block|,
literal|2
block|}
block|}
block|,
block|{
literal|"BE"
block|,
literal|"Belgium"
block|,
block|{
literal|1582
block|,
literal|12
block|,
literal|14
block|}
block|}
block|,
block|{
literal|"BG"
block|,
literal|"Bulgaria"
block|,
block|{
literal|1916
block|,
literal|3
block|,
literal|18
block|}
block|}
block|,
block|{
literal|"CA"
block|,
literal|"Canada"
block|,
block|{
literal|1752
block|,
literal|9
block|,
literal|2
block|}
block|}
block|,
block|{
literal|"CH"
block|,
literal|"Switzerland"
block|,
block|{
literal|1655
block|,
literal|2
block|,
literal|28
block|}
block|}
block|,
block|{
literal|"CN"
block|,
literal|"China"
block|,
block|{
literal|1911
block|,
literal|12
block|,
literal|18
block|}
block|}
block|,
block|{
literal|"CZ"
block|,
literal|"Czech Republic"
block|,
block|{
literal|1584
block|,
literal|1
block|,
literal|6
block|}
block|}
block|,
block|{
literal|"DE"
block|,
literal|"Germany"
block|,
block|{
literal|1700
block|,
literal|2
block|,
literal|18
block|}
block|}
block|,
block|{
literal|"DK"
block|,
literal|"Denmark"
block|,
block|{
literal|1700
block|,
literal|2
block|,
literal|18
block|}
block|}
block|,
block|{
literal|"ES"
block|,
literal|"Spain"
block|,
block|{
literal|1582
block|,
literal|10
block|,
literal|4
block|}
block|}
block|,
block|{
literal|"FI"
block|,
literal|"Finland"
block|,
block|{
literal|1753
block|,
literal|2
block|,
literal|17
block|}
block|}
block|,
block|{
literal|"FR"
block|,
literal|"France"
block|,
block|{
literal|1582
block|,
literal|12
block|,
literal|9
block|}
block|}
block|,
block|{
literal|"GB"
block|,
literal|"United Kingdom"
block|,
block|{
literal|1752
block|,
literal|9
block|,
literal|2
block|}
block|}
block|,
block|{
literal|"GR"
block|,
literal|"Greece"
block|,
block|{
literal|1924
block|,
literal|3
block|,
literal|9
block|}
block|}
block|,
block|{
literal|"HU"
block|,
literal|"Hungary"
block|,
block|{
literal|1587
block|,
literal|10
block|,
literal|21
block|}
block|}
block|,
block|{
literal|"IS"
block|,
literal|"Iceland"
block|,
block|{
literal|1700
block|,
literal|11
block|,
literal|16
block|}
block|}
block|,
block|{
literal|"IT"
block|,
literal|"Italy"
block|,
block|{
literal|1582
block|,
literal|10
block|,
literal|4
block|}
block|}
block|,
block|{
literal|"JP"
block|,
literal|"Japan"
block|,
block|{
literal|1918
block|,
literal|12
block|,
literal|18
block|}
block|}
block|,
block|{
literal|"LI"
block|,
literal|"Lithuania"
block|,
block|{
literal|1918
block|,
literal|2
block|,
literal|1
block|}
block|}
block|,
block|{
literal|"LN"
block|,
literal|"Latin"
block|,
block|{
literal|9999
block|,
literal|05
block|,
literal|31
block|}
block|}
block|,
block|{
literal|"LU"
block|,
literal|"Luxembourg"
block|,
block|{
literal|1582
block|,
literal|12
block|,
literal|14
block|}
block|}
block|,
block|{
literal|"LV"
block|,
literal|"Latvia"
block|,
block|{
literal|1918
block|,
literal|2
block|,
literal|1
block|}
block|}
block|,
block|{
literal|"NL"
block|,
literal|"Netherlands"
block|,
block|{
literal|1582
block|,
literal|12
block|,
literal|14
block|}
block|}
block|,
block|{
literal|"NO"
block|,
literal|"Norway"
block|,
block|{
literal|1700
block|,
literal|2
block|,
literal|18
block|}
block|}
block|,
block|{
literal|"PL"
block|,
literal|"Poland"
block|,
block|{
literal|1582
block|,
literal|10
block|,
literal|4
block|}
block|}
block|,
block|{
literal|"PT"
block|,
literal|"Portugal"
block|,
block|{
literal|1582
block|,
literal|10
block|,
literal|4
block|}
block|}
block|,
block|{
literal|"RO"
block|,
literal|"Romania"
block|,
block|{
literal|1919
block|,
literal|3
block|,
literal|31
block|}
block|}
block|,
block|{
literal|"RU"
block|,
literal|"Russia"
block|,
block|{
literal|1918
block|,
literal|1
block|,
literal|31
block|}
block|}
block|,
block|{
literal|"SI"
block|,
literal|"Slovenia"
block|,
block|{
literal|1919
block|,
literal|3
block|,
literal|4
block|}
block|}
block|,
block|{
literal|"SW"
block|,
literal|"Sweden"
block|,
block|{
literal|1753
block|,
literal|2
block|,
literal|17
block|}
block|}
block|,
block|{
literal|"TR"
block|,
literal|"Turkey"
block|,
block|{
literal|1926
block|,
literal|12
block|,
literal|18
block|}
block|}
block|,
block|{
literal|"US"
block|,
literal|"United States"
block|,
block|{
literal|1752
block|,
literal|9
block|,
literal|2
block|}
block|}
block|,
block|{
literal|"YU"
block|,
literal|"Yugoslavia"
block|,
block|{
literal|1919
block|,
literal|3
block|,
literal|4
block|}
block|}
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|djswitch
modifier|*
name|dftswitch
init|=
name|switches
operator|+
sizeof|sizeof
argument_list|(
name|switches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|djswitch
argument_list|)
operator|-
literal|2
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* default switch (should be "US") */
end_comment

begin_comment
comment|/* Table used to print day of month and week numbers */
end_comment

begin_decl_stmt
name|char
name|daystr
index|[]
init|=
literal|"     1  2  3  4  5  6  7  8  9 10 11 12 13 14 15"
literal|" 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31"
literal|" 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47"
literal|" 48 49 50 51 52 53"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Table used to print day of year and week numbers */
end_comment

begin_decl_stmt
name|char
name|jdaystr
index|[]
init|=
literal|"       1   2   3   4   5   6   7   8   9"
literal|"  10  11  12  13  14  15  16  17  18  19"
literal|"  20  21  22  23  24  25  26  27  28  29"
literal|"  30  31  32  33  34  35  36  37  38  39"
literal|"  40  41  42  43  44  45  46  47  48  49"
literal|"  50  51  52  53  54  55  56  57  58  59"
literal|"  60  61  62  63  64  65  66  67  68  69"
literal|"  70  71  72  73  74  75  76  77  78  79"
literal|"  80  81  82  83  84  85  86  87  88  89"
literal|"  90  91  92  93  94  95  96  97  98  99"
literal|" 100 101 102 103 104 105 106 107 108 109"
literal|" 110 111 112 113 114 115 116 117 118 119"
literal|" 120 121 122 123 124 125 126 127 128 129"
literal|" 130 131 132 133 134 135 136 137 138 139"
literal|" 140 141 142 143 144 145 146 147 148 149"
literal|" 150 151 152 153 154 155 156 157 158 159"
literal|" 160 161 162 163 164 165 166 167 168 169"
literal|" 170 171 172 173 174 175 176 177 178 179"
literal|" 180 181 182 183 184 185 186 187 188 189"
literal|" 190 191 192 193 194 195 196 197 198 199"
literal|" 200 201 202 203 204 205 206 207 208 209"
literal|" 210 211 212 213 214 215 216 217 218 219"
literal|" 220 221 222 223 224 225 226 227 228 229"
literal|" 230 231 232 233 234 235 236 237 238 239"
literal|" 240 241 242 243 244 245 246 247 248 249"
literal|" 250 251 252 253 254 255 256 257 258 259"
literal|" 260 261 262 263 264 265 266 267 268 269"
literal|" 270 271 272 273 274 275 276 277 278 279"
literal|" 280 281 282 283 284 285 286 287 288 289"
literal|" 290 291 292 293 294 295 296 297 298 299"
literal|" 300 301 302 303 304 305 306 307 308 309"
literal|" 310 311 312 313 314 315 316 317 318 319"
literal|" 320 321 322 323 324 325 326 327 328 329"
literal|" 330 331 332 333 334 335 336 337 338 339"
literal|" 340 341 342 343 344 345 346 347 348 349"
literal|" 350 351 352 353 354 355 356 357 358 359"
literal|" 360 361 362 363 364 365 366"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|flag_nohighlight
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user doesn't want a highlighted today */
end_comment

begin_decl_stmt
name|int
name|flag_weeks
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user wants number of week */
end_comment

begin_decl_stmt
name|int
name|nswitch
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* user defined switch date */
end_comment

begin_decl_stmt
name|int
name|nswitchb
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* switch date for backward compatibility */
end_comment

begin_decl_stmt
name|int
name|today
decl_stmt|;
end_decl_stmt

begin_function_decl
name|char
modifier|*
name|center
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|t
parameter_list|,
name|int
name|w
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|wchar_t
modifier|*
name|wcenter
parameter_list|(
name|wchar_t
modifier|*
name|s
parameter_list|,
name|wchar_t
modifier|*
name|t
parameter_list|,
name|int
name|w
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mkmonthr
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|struct
name|monthlines
modifier|*
name|monthl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mkmonthb
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|month
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|struct
name|monthlines
modifier|*
name|monthl
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|mkweekdays
parameter_list|(
name|struct
name|weekdays
modifier|*
name|wds
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|parsemonth
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|y
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|printcc
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|printeaster
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|julian
parameter_list|,
name|int
name|orthodox
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|firstday
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|date
modifier|*
name|sdater
parameter_list|(
name|int
name|ndays
parameter_list|,
name|struct
name|date
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|date
modifier|*
name|sdateb
parameter_list|(
name|int
name|ndays
parameter_list|,
name|struct
name|date
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sndaysr
parameter_list|(
name|struct
name|date
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|int
name|sndaysb
parameter_list|(
name|struct
name|date
modifier|*
name|d
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|monthranger
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|before
parameter_list|,
name|int
name|after
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|monthrangeb
parameter_list|(
name|int
name|year
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|before
parameter_list|,
name|int
name|after
parameter_list|)
function_decl|;
end_function_decl

begin_function_decl
name|void
name|highlight
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|extraletters
parameter_list|)
function_decl|;
end_function_decl

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|struct
name|djswitch
modifier|*
name|p
decl_stmt|,
modifier|*
name|q
decl_stmt|;
comment|/* to search user defined switch date */
name|date
name|never
init|=
block|{
literal|10000
block|,
literal|1
block|,
literal|1
block|}
decl_stmt|;
comment|/* outside valid range of dates */
name|date
name|ukswitch
init|=
block|{
literal|1752
block|,
literal|9
block|,
literal|2
block|}
decl_stmt|;
comment|/* switch date for Great Britain */
name|date
name|dt
decl_stmt|;
name|int
name|ch
decl_stmt|;
comment|/* holds the option character */
name|int
name|m
init|=
literal|0
decl_stmt|;
comment|/* month */
name|int
name|y
init|=
literal|0
decl_stmt|;
comment|/* year */
name|int
name|flag_backward
init|=
literal|0
decl_stmt|;
comment|/* user called cal--backward compat. */
name|int
name|flag_hole_year
init|=
literal|0
decl_stmt|;
comment|/* user wants the whole year */
name|int
name|flag_julian_cal
init|=
literal|0
decl_stmt|;
comment|/* user wants Julian Calendar */
name|int
name|flag_julian_day
init|=
literal|0
decl_stmt|;
comment|/* user wants the Julian day 					 * numbers */
name|int
name|flag_orthodox
init|=
literal|0
decl_stmt|;
comment|/* use wants Orthodox easter */
name|int
name|flag_easter
init|=
literal|0
decl_stmt|;
comment|/* use wants easter date */
name|char
modifier|*
name|cp
decl_stmt|;
comment|/* character pointer */
name|char
modifier|*
name|flag_month
init|=
name|NULL
decl_stmt|;
comment|/* requested month as string */
name|char
modifier|*
name|flag_highlightdate
init|=
name|NULL
decl_stmt|;
name|int
name|before
decl_stmt|,
name|after
decl_stmt|;
specifier|const
name|char
modifier|*
name|locale
decl_stmt|;
comment|/* locale to get country code */
name|flag_nohighlight
operator|=
literal|0
expr_stmt|;
name|flag_weeks
operator|=
literal|0
expr_stmt|;
comment|/* 	 * Use locale to determine the country code, 	 * and use the country code to determine the default 	 * switchdate and date format from the switches table. 	 */
if|if
condition|(
name|setlocale
argument_list|(
name|LC_ALL
argument_list|,
literal|""
argument_list|)
operator|==
name|NULL
condition|)
name|warn
argument_list|(
literal|"setlocale"
argument_list|)
expr_stmt|;
name|locale
operator|=
name|setlocale
argument_list|(
name|LC_TIME
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|locale
operator|==
name|NULL
operator|||
name|strcmp
argument_list|(
name|locale
argument_list|,
literal|"C"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|locale
argument_list|,
literal|"POSIX"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|locale
argument_list|,
literal|"ASCII"
argument_list|)
operator|==
literal|0
operator|||
name|strcmp
argument_list|(
name|locale
argument_list|,
literal|"US-ASCII"
argument_list|)
operator|==
literal|0
condition|)
name|locale
operator|=
literal|"_US"
expr_stmt|;
name|q
operator|=
name|switches
operator|+
sizeof|sizeof
argument_list|(
name|switches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|djswitch
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|switches
init|;
name|p
operator|!=
name|q
condition|;
name|p
operator|++
control|)
if|if
condition|(
operator|(
name|cp
operator|=
name|strstr
argument_list|(
name|locale
argument_list|,
name|p
operator|->
name|cc
argument_list|)
operator|)
operator|!=
name|NULL
operator|&&
operator|*
operator|(
name|cp
operator|-
literal|1
operator|)
operator|==
literal|'_'
condition|)
break|break;
if|if
condition|(
name|p
operator|==
name|q
condition|)
block|{
name|nswitch
operator|=
name|ndaysj
argument_list|(
operator|&
name|dftswitch
operator|->
name|dt
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|nswitch
operator|=
name|ndaysj
argument_list|(
operator|&
name|p
operator|->
name|dt
argument_list|)
expr_stmt|;
name|dftswitch
operator|=
name|p
expr_stmt|;
block|}
comment|/* 	 * Get the filename portion of argv[0] and set flag_backward if 	 * this program is called "cal". 	 */
name|cp
operator|=
name|strrchr
argument_list|(
name|argv
index|[
literal|0
index|]
argument_list|,
literal|'/'
argument_list|)
expr_stmt|;
name|cp
operator|=
operator|(
name|cp
operator|==
name|NULL
operator|)
condition|?
name|argv
index|[
literal|0
index|]
else|:
name|cp
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
literal|"cal"
argument_list|,
name|cp
argument_list|)
operator|==
literal|0
condition|)
name|flag_backward
operator|=
literal|1
expr_stmt|;
comment|/* Set the switch date to United Kingdom if backwards compatible */
if|if
condition|(
name|flag_backward
condition|)
name|nswitchb
operator|=
name|ndaysj
argument_list|(
operator|&
name|ukswitch
argument_list|)
expr_stmt|;
name|before
operator|=
name|after
operator|=
operator|-
literal|1
expr_stmt|;
while|while
condition|(
operator|(
name|ch
operator|=
name|getopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"A:B:3Jbd:ehjm:ops:wy"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
switch|switch
condition|(
name|ch
condition|)
block|{
case|case
literal|'3'
case|:
name|before
operator|=
name|after
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'A'
case|:
name|after
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|after
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Argument to -A must be positive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|before
operator|=
name|strtol
argument_list|(
name|optarg
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
operator|<
literal|0
condition|)
name|errx
argument_list|(
literal|1
argument_list|,
literal|"Argument to -B must be positive"
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'J'
case|:
if|if
condition|(
name|flag_backward
condition|)
name|usage
argument_list|()
expr_stmt|;
name|nswitch
operator|=
name|ndaysj
argument_list|(
operator|&
name|never
argument_list|)
expr_stmt|;
name|flag_julian_cal
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|flag_backward
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
name|flag_highlightdate
operator|=
name|optarg
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|flag_nohighlight
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
if|if
condition|(
name|flag_backward
condition|)
name|usage
argument_list|()
expr_stmt|;
name|flag_easter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'j'
case|:
name|flag_julian_day
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|flag_month
operator|=
name|optarg
expr_stmt|;
name|before
operator|=
literal|0
expr_stmt|;
name|after
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|flag_backward
condition|)
name|usage
argument_list|()
expr_stmt|;
name|flag_orthodox
operator|=
literal|1
expr_stmt|;
name|flag_easter
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'p'
case|:
if|if
condition|(
name|flag_backward
condition|)
name|usage
argument_list|()
expr_stmt|;
name|printcc
argument_list|()
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
break|break;
case|case
literal|'s'
case|:
if|if
condition|(
name|flag_backward
condition|)
name|usage
argument_list|()
expr_stmt|;
name|q
operator|=
name|switches
operator|+
sizeof|sizeof
argument_list|(
name|switches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|djswitch
argument_list|)
expr_stmt|;
for|for
control|(
name|p
operator|=
name|switches
init|;
name|p
operator|!=
name|q
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|cc
argument_list|,
name|optarg
argument_list|)
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
empty_stmt|;
if|if
condition|(
name|p
operator|==
name|q
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"%s: invalid country code"
argument_list|,
name|optarg
argument_list|)
expr_stmt|;
name|nswitch
operator|=
name|ndaysj
argument_list|(
operator|&
operator|(
name|p
operator|->
name|dt
operator|)
argument_list|)
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
if|if
condition|(
name|flag_backward
condition|)
name|usage
argument_list|()
expr_stmt|;
name|flag_weeks
operator|=
literal|1
expr_stmt|;
break|break;
case|case
literal|'y'
case|:
name|flag_hole_year
operator|=
literal|1
expr_stmt|;
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
name|argc
operator|-=
name|optind
expr_stmt|;
name|argv
operator|+=
name|optind
expr_stmt|;
switch|switch
condition|(
name|argc
condition|)
block|{
case|case
literal|2
case|:
if|if
condition|(
name|flag_easter
condition|)
name|usage
argument_list|()
expr_stmt|;
name|flag_month
operator|=
operator|*
name|argv
operator|++
expr_stmt|;
name|before
operator|=
literal|0
expr_stmt|;
name|after
operator|=
literal|0
expr_stmt|;
name|m
operator|=
name|strtol
argument_list|(
name|flag_month
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|1
case|:
name|y
operator|=
name|atoi
argument_list|(
operator|*
name|argv
operator|++
argument_list|)
expr_stmt|;
if|if
condition|(
name|y
operator|<
literal|1
operator|||
name|y
operator|>
literal|9999
condition|)
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"year %d not in range 1..9999"
argument_list|,
name|y
argument_list|)
expr_stmt|;
if|if
condition|(
name|before
operator|==
operator|-
literal|1
operator|&&
name|after
operator|==
operator|-
literal|1
condition|)
block|{
name|before
operator|=
literal|0
expr_stmt|;
name|after
operator|=
literal|11
expr_stmt|;
name|m
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|0
case|:
block|{
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm
decl_stmt|;
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tm
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|y
operator|=
name|tm
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|m
operator|=
name|tm
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|before
operator|==
operator|-
literal|1
condition|)
name|before
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|after
operator|==
operator|-
literal|1
condition|)
name|after
operator|=
literal|0
expr_stmt|;
block|}
break|break;
default|default:
name|usage
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|flag_hole_year
condition|)
block|{
name|m
operator|=
literal|1
expr_stmt|;
name|before
operator|=
literal|0
expr_stmt|;
name|after
operator|=
literal|11
expr_stmt|;
block|}
if|if
condition|(
name|flag_month
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|parsemonth
argument_list|(
name|flag_month
argument_list|,
operator|&
name|m
argument_list|,
operator|&
name|y
argument_list|)
condition|)
block|{
name|errx
argument_list|(
name|EX_USAGE
argument_list|,
literal|"%s is neither a month number (1..12) nor a name"
argument_list|,
name|flag_month
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|flag_highlightdate
operator|!=
name|NULL
condition|)
block|{
name|dt
operator|.
name|y
operator|=
name|strtol
argument_list|(
name|flag_highlightdate
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|dt
operator|.
name|m
operator|=
name|strtol
argument_list|(
name|flag_highlightdate
operator|+
literal|5
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
name|dt
operator|.
name|d
operator|=
name|strtol
argument_list|(
name|flag_highlightdate
operator|+
literal|8
argument_list|,
name|NULL
argument_list|,
literal|10
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|time_t
name|t
decl_stmt|;
name|struct
name|tm
modifier|*
name|tm1
decl_stmt|;
name|t
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
name|tm1
operator|=
name|localtime
argument_list|(
operator|&
name|t
argument_list|)
expr_stmt|;
name|dt
operator|.
name|y
operator|=
name|tm1
operator|->
name|tm_year
operator|+
literal|1900
expr_stmt|;
name|dt
operator|.
name|m
operator|=
name|tm1
operator|->
name|tm_mon
operator|+
literal|1
expr_stmt|;
name|dt
operator|.
name|d
operator|=
name|tm1
operator|->
name|tm_mday
expr_stmt|;
block|}
name|today
operator|=
name|sndaysb
argument_list|(
operator|&
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|flag_easter
condition|)
name|printeaster
argument_list|(
name|y
argument_list|,
name|flag_julian_cal
argument_list|,
name|flag_orthodox
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|flag_backward
condition|)
name|monthrangeb
argument_list|(
name|y
argument_list|,
name|flag_julian_day
argument_list|,
name|m
argument_list|,
name|before
argument_list|,
name|after
argument_list|)
expr_stmt|;
else|else
name|monthranger
argument_list|(
name|y
argument_list|,
name|flag_julian_day
argument_list|,
name|m
argument_list|,
name|before
argument_list|,
name|after
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_function
specifier|static
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
name|fputs
argument_list|(
literal|"usage: cal [-hjy] [[month] year]\n"
literal|"       cal [-hj] [-m month] [year]\n"
literal|"       ncal [-hJjpwy] [-s country_code] [[month] year]\n"
literal|"       ncal [-hJeo] [year]\n"
literal|"for debug the highlighting: [-b] [-d yyyy-mm-dd]\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|EX_USAGE
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print the assumed switches for all countries */
end_comment

begin_function
name|void
name|printcc
parameter_list|(
name|void
parameter_list|)
block|{
name|struct
name|djswitch
modifier|*
name|p
decl_stmt|;
name|int
name|n
decl_stmt|;
comment|/* number of lines to print */
name|int
name|m
decl_stmt|;
comment|/* offset from left to right table entry on the same line */
define|#
directive|define
name|FSTR
value|"%c%s %-15s%4d-%02d-%02d"
define|#
directive|define
name|DFLT
parameter_list|(
name|p
parameter_list|)
value|((p) == dftswitch ? '*' : ' ')
define|#
directive|define
name|FSTRARG
parameter_list|(
name|p
parameter_list|)
value|DFLT(p), (p)->cc, (p)->nm, (p)->dt.y, (p)->dt.m, (p)->dt.d
name|n
operator|=
sizeof|sizeof
argument_list|(
name|switches
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
expr|struct
name|djswitch
argument_list|)
expr_stmt|;
name|m
operator|=
operator|(
name|n
operator|+
literal|1
operator|)
operator|/
literal|2
expr_stmt|;
name|n
operator|/=
literal|2
expr_stmt|;
for|for
control|(
name|p
operator|=
name|switches
init|;
name|p
operator|!=
name|switches
operator|+
name|n
condition|;
name|p
operator|++
control|)
name|printf
argument_list|(
name|FSTR
literal|"     "
name|FSTR
literal|"\n"
argument_list|,
name|FSTRARG
argument_list|(
name|p
argument_list|)
argument_list|,
name|FSTRARG
argument_list|(
name|p
operator|+
name|m
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|!=
name|n
condition|)
name|printf
argument_list|(
name|FSTR
literal|"\n"
argument_list|,
name|FSTRARG
argument_list|(
name|p
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* print the date of easter sunday */
end_comment

begin_function
name|void
name|printeaster
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|julian
parameter_list|,
name|int
name|orthodox
parameter_list|)
block|{
name|date
name|dt
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|char
name|buf
index|[
name|MAX_WIDTH
index|]
decl_stmt|;
specifier|static
name|int
name|d_first
init|=
operator|-
literal|1
decl_stmt|;
if|if
condition|(
name|d_first
operator|<
literal|0
condition|)
name|d_first
operator|=
operator|(
operator|*
name|nl_langinfo
argument_list|(
name|D_MD_ORDER
argument_list|)
operator|==
literal|'d'
operator|)
expr_stmt|;
comment|/* force orthodox easter for years before 1583 */
if|if
condition|(
name|y
operator|<
literal|1583
condition|)
name|orthodox
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|orthodox
condition|)
if|if
condition|(
name|julian
condition|)
name|easteroj
argument_list|(
name|y
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
else|else
name|easterog
argument_list|(
name|y
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
else|else
name|easterg
argument_list|(
name|y
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_year
operator|=
name|dt
operator|.
name|y
operator|-
literal|1900
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|dt
operator|.
name|m
operator|-
literal|1
expr_stmt|;
name|tm
operator|.
name|tm_mday
operator|=
name|dt
operator|.
name|d
expr_stmt|;
name|strftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
name|d_first
condition|?
literal|"%e %B %Y"
else|:
literal|"%B %e %Y"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|buf
argument_list|)
expr_stmt|;
block|}
end_function

begin_define
define|#
directive|define
name|MW
parameter_list|(
name|mw
parameter_list|,
name|me
parameter_list|)
value|((mw) + me)
end_define

begin_define
define|#
directive|define
name|DECREASEMONTH
parameter_list|(
name|m
parameter_list|,
name|y
parameter_list|)
define|\
value|if (--m == 0) {		\ 			m = 12;		\ 			y--;		\ 		}
end_define

begin_define
define|#
directive|define
name|INCREASEMONTH
parameter_list|(
name|m
parameter_list|,
name|y
parameter_list|)
define|\
value|if (++(m) == 13) {	\ 			(m) = 1;	\ 			(y)++;		\ 		}
end_define

begin_define
define|#
directive|define
name|M2Y
parameter_list|(
name|m
parameter_list|)
value|((m) / 12)
end_define

begin_define
define|#
directive|define
name|M2M
parameter_list|(
name|m
parameter_list|)
value|(1 + (m) % 12)
end_define

begin_function
name|void
name|monthrangeb
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|before
parameter_list|,
name|int
name|after
parameter_list|)
block|{
name|struct
name|monthlines
name|year
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|weekdays
name|wds
decl_stmt|;
name|char
name|s
index|[
name|MAX_WIDTH
index|]
decl_stmt|,
name|t
index|[
name|MAX_WIDTH
index|]
decl_stmt|;
name|wchar_t
name|ws
index|[
name|MAX_WIDTH
index|]
decl_stmt|,
name|ws1
index|[
name|MAX_WIDTH
index|]
decl_stmt|;
specifier|const
name|char
modifier|*
name|wdss
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|mpl
decl_stmt|;
name|int
name|mw
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|int
name|printyearheader
decl_stmt|;
name|int
name|prevyear
init|=
operator|-
literal|1
decl_stmt|;
name|mpl
operator|=
name|jd_flag
condition|?
literal|2
else|:
literal|3
expr_stmt|;
name|mw
operator|=
name|jd_flag
condition|?
name|MONTH_WIDTH_B_J
else|:
name|MONTH_WIDTH_B
expr_stmt|;
name|wdss
operator|=
operator|(
name|mpl
operator|==
literal|2
operator|)
condition|?
literal|" "
else|:
literal|""
expr_stmt|;
while|while
condition|(
name|before
operator|!=
literal|0
condition|)
block|{
name|DECREASEMONTH
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|before
operator|--
expr_stmt|;
name|after
operator|++
expr_stmt|;
block|}
name|m1
operator|=
name|y
operator|*
literal|12
operator|+
name|m
operator|-
literal|1
expr_stmt|;
name|m2
operator|=
name|m1
operator|+
name|after
expr_stmt|;
name|mkweekdays
argument_list|(
operator|&
name|wds
argument_list|)
expr_stmt|;
comment|/* 	 * The year header is printed when there are more than 'mpl' months 	 * and if the first month is a multitude of 'mpl'. 	 * If not, it will print the year behind every month. 	 */
name|printyearheader
operator|=
operator|(
name|after
operator|>=
name|mpl
operator|-
literal|1
operator|)
operator|&&
operator|(
name|M2M
argument_list|(
name|m1
argument_list|)
operator|-
literal|1
operator|)
operator|%
name|mpl
operator|==
literal|0
expr_stmt|;
name|m
operator|=
name|m1
expr_stmt|;
while|while
condition|(
name|m
operator|<=
name|m2
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|mpl
operator|&&
name|m
operator|+
name|i
operator|<=
name|m2
condition|;
name|i
operator|++
control|)
block|{
name|mkmonthb
argument_list|(
name|M2Y
argument_list|(
name|m
operator|+
name|i
argument_list|)
argument_list|,
name|M2M
argument_list|(
name|m
operator|+
name|i
argument_list|)
operator|-
literal|1
argument_list|,
name|jd_flag
argument_list|,
name|year
operator|+
name|i
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Empty line between two rows of months */
if|if
condition|(
name|m
operator|!=
name|m1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Year at the top */
if|if
condition|(
name|printyearheader
operator|&&
name|M2Y
argument_list|(
name|m
argument_list|)
operator|!=
name|prevyear
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
name|M2Y
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|center
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|mpl
operator|*
name|mw
argument_list|)
argument_list|)
expr_stmt|;
name|prevyear
operator|=
name|M2Y
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Month names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|printyearheader
condition|)
name|wprintf
argument_list|(
literal|L"%-*ls  "
argument_list|,
name|mw
argument_list|,
name|wcenter
argument_list|(
name|ws
argument_list|,
name|year
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|mw
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
name|swprintf
argument_list|(
name|ws
argument_list|,
sizeof|sizeof
argument_list|(
name|ws
argument_list|)
argument_list|,
literal|L"%-ls %d"
argument_list|,
name|year
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|M2Y
argument_list|(
name|m
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|wprintf
argument_list|(
literal|L"%-*ls  "
argument_list|,
name|mw
argument_list|,
name|wcenter
argument_list|(
name|ws1
argument_list|,
name|ws
argument_list|,
name|mw
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Day of the week names */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
block|{
name|wprintf
argument_list|(
literal|L"%s%ls%s%ls%s%ls%s%ls%s%ls%s%ls%s%ls "
argument_list|,
name|wdss
argument_list|,
name|wds
operator|.
name|names
index|[
literal|6
index|]
argument_list|,
name|wdss
argument_list|,
name|wds
operator|.
name|names
index|[
literal|0
index|]
argument_list|,
name|wdss
argument_list|,
name|wds
operator|.
name|names
index|[
literal|1
index|]
argument_list|,
name|wdss
argument_list|,
name|wds
operator|.
name|names
index|[
literal|2
index|]
argument_list|,
name|wdss
argument_list|,
name|wds
operator|.
name|names
index|[
literal|3
index|]
argument_list|,
name|wdss
argument_list|,
name|wds
operator|.
name|names
index|[
literal|4
index|]
argument_list|,
name|wdss
argument_list|,
name|wds
operator|.
name|names
index|[
literal|5
index|]
argument_list|)
expr_stmt|;
block|}
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|6
condition|;
name|i
operator|++
control|)
block|{
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%-*s  "
argument_list|,
name|MW
argument_list|(
name|mw
argument_list|,
name|year
index|[
name|j
index|]
operator|.
name|extralen
index|[
name|i
index|]
argument_list|)
argument_list|,
name|year
index|[
name|j
index|]
operator|.
name|lines
index|[
name|i
index|]
operator|+
literal|1
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|m
operator|+=
name|mpl
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|monthranger
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|before
parameter_list|,
name|int
name|after
parameter_list|)
block|{
name|struct
name|monthlines
name|year
index|[
literal|12
index|]
decl_stmt|;
name|struct
name|weekdays
name|wds
decl_stmt|;
name|char
name|s
index|[
name|MAX_WIDTH
index|]
decl_stmt|,
name|t
index|[
name|MAX_WIDTH
index|]
decl_stmt|;
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|mpl
decl_stmt|;
name|int
name|mw
decl_stmt|;
name|int
name|m1
decl_stmt|,
name|m2
decl_stmt|;
name|int
name|prevyear
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|printyearheader
decl_stmt|;
name|mpl
operator|=
name|jd_flag
condition|?
literal|3
else|:
literal|4
expr_stmt|;
name|mw
operator|=
name|jd_flag
condition|?
name|MONTH_WIDTH_R_J
else|:
name|MONTH_WIDTH_R
expr_stmt|;
while|while
condition|(
name|before
operator|!=
literal|0
condition|)
block|{
name|DECREASEMONTH
argument_list|(
name|m
argument_list|,
name|y
argument_list|)
expr_stmt|;
name|before
operator|--
expr_stmt|;
name|after
operator|++
expr_stmt|;
block|}
name|m1
operator|=
name|y
operator|*
literal|12
operator|+
name|m
operator|-
literal|1
expr_stmt|;
name|m2
operator|=
name|m1
operator|+
name|after
expr_stmt|;
name|mkweekdays
argument_list|(
operator|&
name|wds
argument_list|)
expr_stmt|;
comment|/* 	 * The year header is printed when there are more than 'mpl' months 	 * and if the first month is a multitude of 'mpl'. 	 * If not, it will print the year behind every month. 	 */
name|printyearheader
operator|=
operator|(
name|after
operator|>=
name|mpl
operator|-
literal|1
operator|)
operator|&&
operator|(
name|M2M
argument_list|(
name|m1
argument_list|)
operator|-
literal|1
operator|)
operator|%
name|mpl
operator|==
literal|0
expr_stmt|;
name|m
operator|=
name|m1
expr_stmt|;
while|while
condition|(
name|m
operator|<=
name|m2
condition|)
block|{
name|int
name|count
init|=
literal|0
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
name|mpl
operator|&&
name|m
operator|+
name|i
operator|<=
name|m2
condition|;
name|i
operator|++
control|)
block|{
name|mkmonthr
argument_list|(
name|M2Y
argument_list|(
name|m
operator|+
name|i
argument_list|)
argument_list|,
name|M2M
argument_list|(
name|m
operator|+
name|i
argument_list|)
operator|-
literal|1
argument_list|,
name|jd_flag
argument_list|,
name|year
operator|+
name|i
argument_list|)
expr_stmt|;
name|count
operator|++
expr_stmt|;
block|}
comment|/* Empty line between two rows of months */
if|if
condition|(
name|m
operator|!=
name|m1
condition|)
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
comment|/* Year at the top */
if|if
condition|(
name|printyearheader
operator|&&
name|M2Y
argument_list|(
name|m
argument_list|)
operator|!=
name|prevyear
condition|)
block|{
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%d"
argument_list|,
name|M2Y
argument_list|(
name|m
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"%s\n"
argument_list|,
name|center
argument_list|(
name|t
argument_list|,
name|s
argument_list|,
name|mpl
operator|*
name|mw
argument_list|)
argument_list|)
expr_stmt|;
name|prevyear
operator|=
name|M2Y
argument_list|(
name|m
argument_list|)
expr_stmt|;
block|}
comment|/* Month names */
name|wprintf
argument_list|(
literal|L"    "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
if|if
condition|(
name|printyearheader
condition|)
name|wprintf
argument_list|(
literal|L"%-*ls"
argument_list|,
name|mw
argument_list|,
name|year
index|[
name|i
index|]
operator|.
name|name
argument_list|)
expr_stmt|;
else|else
name|wprintf
argument_list|(
literal|L"%-ls %-*d"
argument_list|,
name|year
index|[
name|i
index|]
operator|.
name|name
argument_list|,
name|mw
operator|-
name|wcslen
argument_list|(
name|year
index|[
name|i
index|]
operator|.
name|name
argument_list|)
operator|-
literal|1
argument_list|,
name|M2Y
argument_list|(
name|m
operator|+
name|i
argument_list|)
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|7
condition|;
name|i
operator|++
control|)
block|{
comment|/* Week day */
name|wprintf
argument_list|(
literal|L"%.2ls"
argument_list|,
name|wds
operator|.
name|names
index|[
name|i
index|]
argument_list|)
expr_stmt|;
comment|/* Full months */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|count
condition|;
name|j
operator|++
control|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|MW
argument_list|(
name|mw
argument_list|,
name|year
index|[
name|j
index|]
operator|.
name|extralen
index|[
name|i
index|]
argument_list|)
argument_list|,
name|year
index|[
name|j
index|]
operator|.
name|lines
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|flag_weeks
condition|)
block|{
name|printf
argument_list|(
literal|"  "
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|count
condition|;
name|i
operator|++
control|)
name|printf
argument_list|(
literal|"%-*s"
argument_list|,
name|mw
argument_list|,
name|year
index|[
name|i
index|]
operator|.
name|weeks
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|m
operator|+=
name|mpl
expr_stmt|;
block|}
return|return;
block|}
end_function

begin_function
name|void
name|mkmonthr
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|struct
name|monthlines
modifier|*
name|mlines
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
comment|/* for strftime printing local names of 				 * months */
name|date
name|dt
decl_stmt|;
comment|/* handy date */
name|int
name|dw
decl_stmt|;
comment|/* width of numbers */
name|int
name|first
decl_stmt|;
comment|/* first day of month */
name|int
name|firstm
decl_stmt|;
comment|/* first day of first week of month */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
comment|/* just indices */
name|int
name|last
decl_stmt|;
comment|/* the first day of next month */
name|int
name|jan1
init|=
literal|0
decl_stmt|;
comment|/* the first day of this year */
name|char
modifier|*
name|ds
decl_stmt|;
comment|/* pointer to day strings (daystr or 				 * jdaystr) */
comment|/* Set name of month. */
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|m
expr_stmt|;
name|wcsftime
argument_list|(
name|mlines
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mlines
operator|->
name|name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mlines
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|L"%OB"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|mlines
operator|->
name|name
index|[
literal|0
index|]
operator|=
name|towupper
argument_list|(
name|mlines
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set first and last to the day number of the first day of this 	 * month and the first day of next month respectively. Set jan1 to 	 * the day number of the first day of this year. 	 */
name|first
operator|=
name|firstday
argument_list|(
name|y
argument_list|,
name|m
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|11
condition|)
name|last
operator|=
name|firstday
argument_list|(
name|y
operator|+
literal|1
argument_list|,
literal|1
argument_list|)
expr_stmt|;
else|else
name|last
operator|=
name|firstday
argument_list|(
name|y
argument_list|,
name|m
operator|+
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|jd_flag
condition|)
name|jan1
operator|=
name|firstday
argument_list|(
name|y
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* 	 * Set firstm to the day number of monday of the first week of 	 * this month. (This might be in the last month) 	 */
name|firstm
operator|=
name|first
operator|-
name|weekday
argument_list|(
name|first
argument_list|)
expr_stmt|;
comment|/* Set ds (daystring) and dw (daywidth) according to the jd_flag */
if|if
condition|(
name|jd_flag
condition|)
block|{
name|ds
operator|=
name|jdaystr
expr_stmt|;
name|dw
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|=
name|daystr
expr_stmt|;
name|dw
operator|=
literal|3
expr_stmt|;
block|}
comment|/* 	 * Fill the lines with day of month or day of year (julian day) 	 * line index: i, each line is one weekday. column index: j, each 	 * column is one day number. print column index: k. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|firstm
operator|+
name|i
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|last
condition|;
name|j
operator|+=
literal|7
operator|,
name|k
operator|+=
name|dw
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|first
condition|)
block|{
if|if
condition|(
name|jd_flag
condition|)
name|dt
operator|.
name|d
operator|=
name|j
operator|-
name|jan1
operator|+
literal|1
expr_stmt|;
else|else
name|sdater
argument_list|(
name|j
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|today
operator|&&
operator|!
name|flag_nohighlight
condition|)
name|highlight
argument_list|(
name|mlines
operator|->
name|lines
index|[
name|i
index|]
operator|+
name|k
argument_list|,
name|ds
operator|+
name|dt
operator|.
name|d
operator|*
name|dw
argument_list|,
name|dw
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|mlines
operator|->
name|lines
index|[
name|i
index|]
operator|+
name|k
operator|+
name|l
argument_list|,
name|ds
operator|+
name|dt
operator|.
name|d
operator|*
name|dw
argument_list|,
name|dw
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|mlines
operator|->
name|lines
index|[
name|i
index|]
operator|+
name|k
operator|+
name|l
argument_list|,
literal|"    "
argument_list|,
name|dw
argument_list|)
expr_stmt|;
block|}
name|mlines
operator|->
name|lines
index|[
name|i
index|]
index|[
name|k
operator|+
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mlines
operator|->
name|extralen
index|[
name|i
index|]
operator|=
name|l
expr_stmt|;
block|}
comment|/* fill the weeknumbers */
if|if
condition|(
name|flag_weeks
condition|)
block|{
for|for
control|(
name|j
operator|=
name|firstm
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|last
condition|;
name|k
operator|+=
name|dw
operator|,
name|j
operator|+=
literal|7
control|)
if|if
condition|(
name|j
operator|<=
name|nswitch
condition|)
name|memset
argument_list|(
name|mlines
operator|->
name|weeks
operator|+
name|k
argument_list|,
literal|' '
argument_list|,
name|dw
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|mlines
operator|->
name|weeks
operator|+
name|k
argument_list|,
name|ds
operator|+
name|week
argument_list|(
name|j
argument_list|,
operator|&
name|i
argument_list|)
operator|*
name|dw
argument_list|,
name|dw
argument_list|)
expr_stmt|;
name|mlines
operator|->
name|weeks
index|[
name|k
index|]
operator|=
literal|'\0'
expr_stmt|;
block|}
block|}
end_function

begin_function
name|void
name|mkmonthb
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|,
name|int
name|jd_flag
parameter_list|,
name|struct
name|monthlines
modifier|*
name|mlines
parameter_list|)
block|{
name|struct
name|tm
name|tm
decl_stmt|;
comment|/* for strftime printing local names of 				 * months */
name|date
name|dt
decl_stmt|;
comment|/* handy date */
name|int
name|dw
decl_stmt|;
comment|/* width of numbers */
name|int
name|first
decl_stmt|;
comment|/* first day of month */
name|int
name|firsts
decl_stmt|;
comment|/* sunday of first week of month */
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
name|l
decl_stmt|;
comment|/* just indices */
name|int
name|jan1
init|=
literal|0
decl_stmt|;
comment|/* the first day of this year */
name|int
name|last
decl_stmt|;
comment|/* the first day of next month */
name|char
modifier|*
name|ds
decl_stmt|;
comment|/* pointer to day strings (daystr or 				 * jdaystr) */
comment|/* Set ds (daystring) and dw (daywidth) according to the jd_flag */
if|if
condition|(
name|jd_flag
condition|)
block|{
name|ds
operator|=
name|jdaystr
expr_stmt|;
name|dw
operator|=
literal|4
expr_stmt|;
block|}
else|else
block|{
name|ds
operator|=
name|daystr
expr_stmt|;
name|dw
operator|=
literal|3
expr_stmt|;
block|}
comment|/* Set name of month centered */
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
name|tm
operator|.
name|tm_mon
operator|=
name|m
expr_stmt|;
name|wcsftime
argument_list|(
name|mlines
operator|->
name|name
argument_list|,
sizeof|sizeof
argument_list|(
name|mlines
operator|->
name|name
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|mlines
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
argument_list|,
literal|L"%OB"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
name|mlines
operator|->
name|name
index|[
literal|0
index|]
operator|=
name|towupper
argument_list|(
name|mlines
operator|->
name|name
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* 	 * Set first and last to the day number of the first day of this 	 * month and the first day of next month respectively. Set jan1 to 	 * the day number of Jan 1st of this year. 	 */
name|dt
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|dt
operator|.
name|m
operator|=
name|m
operator|+
literal|1
expr_stmt|;
name|dt
operator|.
name|d
operator|=
literal|1
expr_stmt|;
name|first
operator|=
name|sndaysb
argument_list|(
operator|&
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|m
operator|==
literal|11
condition|)
block|{
name|dt
operator|.
name|y
operator|=
name|y
operator|+
literal|1
expr_stmt|;
name|dt
operator|.
name|m
operator|=
literal|1
expr_stmt|;
name|dt
operator|.
name|d
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
name|dt
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|dt
operator|.
name|m
operator|=
name|m
operator|+
literal|2
expr_stmt|;
name|dt
operator|.
name|d
operator|=
literal|1
expr_stmt|;
block|}
name|last
operator|=
name|sndaysb
argument_list|(
operator|&
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|jd_flag
condition|)
block|{
name|dt
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|dt
operator|.
name|m
operator|=
literal|1
expr_stmt|;
name|dt
operator|.
name|d
operator|=
literal|1
expr_stmt|;
name|jan1
operator|=
name|sndaysb
argument_list|(
operator|&
name|dt
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * Set firsts to the day number of sunday of the first week of 	 * this month. (This might be in the last month) 	 */
name|firsts
operator|=
name|first
operator|-
operator|(
name|weekday
argument_list|(
name|first
argument_list|)
operator|+
literal|1
operator|)
operator|%
literal|7
expr_stmt|;
comment|/* 	 * Fill the lines with day of month or day of year (Julian day) 	 * line index: i, each line is one week. column index: j, each 	 * column is one day number. print column index: k. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|6
condition|;
name|i
operator|++
control|)
block|{
name|l
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|j
operator|=
name|firsts
operator|+
literal|7
operator|*
name|i
operator|,
name|k
operator|=
literal|0
init|;
name|j
operator|<
name|last
operator|&&
name|k
operator|!=
name|dw
operator|*
literal|7
condition|;
name|j
operator|++
operator|,
name|k
operator|+=
name|dw
control|)
block|{
if|if
condition|(
name|j
operator|>=
name|first
condition|)
block|{
if|if
condition|(
name|jd_flag
condition|)
name|dt
operator|.
name|d
operator|=
name|j
operator|-
name|jan1
operator|+
literal|1
expr_stmt|;
else|else
name|sdateb
argument_list|(
name|j
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
name|j
operator|==
name|today
operator|&&
operator|!
name|flag_nohighlight
condition|)
name|highlight
argument_list|(
name|mlines
operator|->
name|lines
index|[
name|i
index|]
operator|+
name|k
argument_list|,
name|ds
operator|+
name|dt
operator|.
name|d
operator|*
name|dw
argument_list|,
name|dw
argument_list|,
operator|&
name|l
argument_list|)
expr_stmt|;
else|else
name|memcpy
argument_list|(
name|mlines
operator|->
name|lines
index|[
name|i
index|]
operator|+
name|k
operator|+
name|l
argument_list|,
name|ds
operator|+
name|dt
operator|.
name|d
operator|*
name|dw
argument_list|,
name|dw
argument_list|)
expr_stmt|;
block|}
else|else
name|memcpy
argument_list|(
name|mlines
operator|->
name|lines
index|[
name|i
index|]
operator|+
name|k
operator|+
name|l
argument_list|,
literal|"    "
argument_list|,
name|dw
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|k
operator|==
literal|0
condition|)
name|mlines
operator|->
name|lines
index|[
name|i
index|]
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
else|else
name|mlines
operator|->
name|lines
index|[
name|i
index|]
index|[
name|k
operator|+
name|l
index|]
operator|=
literal|'\0'
expr_stmt|;
name|mlines
operator|->
name|extralen
index|[
name|i
index|]
operator|=
name|l
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Put the local names of weekdays into the wds */
end_comment

begin_function
name|void
name|mkweekdays
parameter_list|(
name|struct
name|weekdays
modifier|*
name|wds
parameter_list|)
block|{
name|int
name|i
decl_stmt|,
name|len
decl_stmt|,
name|width
init|=
literal|0
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|wchar_t
name|buf
index|[
literal|20
index|]
decl_stmt|;
name|memset
argument_list|(
operator|&
name|tm
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|tm
argument_list|)
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|!=
literal|7
condition|;
name|i
operator|++
control|)
block|{
name|tm
operator|.
name|tm_wday
operator|=
operator|(
name|i
operator|+
literal|1
operator|)
operator|%
literal|7
expr_stmt|;
name|wcsftime
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|buf
argument_list|)
argument_list|,
literal|L"%a"
argument_list|,
operator|&
name|tm
argument_list|)
expr_stmt|;
for|for
control|(
name|len
operator|=
literal|2
init|;
name|len
operator|>
literal|0
condition|;
operator|--
name|len
control|)
block|{
if|if
condition|(
operator|(
name|width
operator|=
name|wcswidth
argument_list|(
name|buf
argument_list|,
name|len
argument_list|)
operator|)
operator|<=
literal|2
condition|)
break|break;
block|}
name|wmemset
argument_list|(
name|wds
operator|->
name|names
index|[
name|i
index|]
argument_list|,
literal|L'
expr|\0'
argument_list|,
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|width
operator|==
literal|1
condition|)
name|wds
operator|->
name|names
index|[
name|i
index|]
index|[
literal|0
index|]
operator|=
literal|L'
expr|'
expr_stmt|;
name|wcsncat
argument_list|(
name|wds
operator|->
name|names
index|[
name|i
index|]
argument_list|,
name|buf
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|wcsncat
argument_list|(
name|wds
operator|->
name|names
index|[
name|i
index|]
argument_list|,
literal|L" "
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/*  * Compute the day number of the first  * existing date after the first day in month.  * (the first day in month and even the month might not exist!)  */
end_comment

begin_function
name|int
name|firstday
parameter_list|(
name|int
name|y
parameter_list|,
name|int
name|m
parameter_list|)
block|{
name|date
name|dt
decl_stmt|;
name|int
name|nd
decl_stmt|;
name|dt
operator|.
name|y
operator|=
name|y
expr_stmt|;
name|dt
operator|.
name|m
operator|=
name|m
expr_stmt|;
name|dt
operator|.
name|d
operator|=
literal|1
expr_stmt|;
name|nd
operator|=
name|sndaysr
argument_list|(
operator|&
name|dt
argument_list|)
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
name|sdater
argument_list|(
name|nd
argument_list|,
operator|&
name|dt
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|dt
operator|.
name|m
operator|>=
name|m
operator|&&
name|dt
operator|.
name|y
operator|==
name|y
operator|)
operator|||
name|dt
operator|.
name|y
operator|>
name|y
condition|)
return|return
operator|(
name|nd
operator|)
return|;
else|else
name|nd
operator|++
expr_stmt|;
block|}
comment|/* NEVER REACHED */
block|}
end_function

begin_comment
comment|/*  * Compute the number of days from date, obey the local switch from  * Julian to Gregorian if specified by the user.  */
end_comment

begin_function
name|int
name|sndaysr
parameter_list|(
name|struct
name|date
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|nswitch
operator|!=
literal|0
condition|)
if|if
condition|(
name|nswitch
operator|<
name|ndaysj
argument_list|(
name|d
argument_list|)
condition|)
return|return
operator|(
name|ndaysg
argument_list|(
name|d
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|ndaysj
argument_list|(
name|d
argument_list|)
operator|)
return|;
else|else
return|return
name|ndaysg
argument_list|(
name|d
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/*  * Compute the number of days from date, obey the switch from  * Julian to Gregorian as used by UK and her colonies.  */
end_comment

begin_function
name|int
name|sndaysb
parameter_list|(
name|struct
name|date
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|nswitchb
operator|<
name|ndaysj
argument_list|(
name|d
argument_list|)
condition|)
return|return
operator|(
name|ndaysg
argument_list|(
name|d
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|ndaysj
argument_list|(
name|d
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Inverse of sndays */
end_comment

begin_function
name|struct
name|date
modifier|*
name|sdater
parameter_list|(
name|int
name|nd
parameter_list|,
name|struct
name|date
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|nswitch
operator|<
name|nd
condition|)
return|return
operator|(
name|gdate
argument_list|(
name|nd
argument_list|,
name|d
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|jdate
argument_list|(
name|nd
argument_list|,
name|d
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Inverse of sndaysb */
end_comment

begin_function
name|struct
name|date
modifier|*
name|sdateb
parameter_list|(
name|int
name|nd
parameter_list|,
name|struct
name|date
modifier|*
name|d
parameter_list|)
block|{
if|if
condition|(
name|nswitchb
operator|<
name|nd
condition|)
return|return
operator|(
name|gdate
argument_list|(
name|nd
argument_list|,
name|d
argument_list|)
operator|)
return|;
else|else
return|return
operator|(
name|jdate
argument_list|(
name|nd
argument_list|,
name|d
argument_list|)
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Center string t in string s of length w by putting enough leading blanks */
end_comment

begin_function
name|char
modifier|*
name|center
parameter_list|(
name|char
modifier|*
name|s
parameter_list|,
name|char
modifier|*
name|t
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|char
name|blanks
index|[
name|MAX_WIDTH
index|]
decl_stmt|;
name|memset
argument_list|(
name|blanks
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|blanks
argument_list|)
argument_list|)
expr_stmt|;
name|sprintf
argument_list|(
name|s
argument_list|,
literal|"%.*s%s"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|w
operator|-
name|strlen
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
literal|2
argument_list|,
name|blanks
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_comment
comment|/* Center string t in string s of length w by putting enough leading blanks */
end_comment

begin_function
name|wchar_t
modifier|*
name|wcenter
parameter_list|(
name|wchar_t
modifier|*
name|s
parameter_list|,
name|wchar_t
modifier|*
name|t
parameter_list|,
name|int
name|w
parameter_list|)
block|{
name|char
name|blanks
index|[
name|MAX_WIDTH
index|]
decl_stmt|;
name|memset
argument_list|(
name|blanks
argument_list|,
literal|' '
argument_list|,
sizeof|sizeof
argument_list|(
name|blanks
argument_list|)
argument_list|)
expr_stmt|;
name|swprintf
argument_list|(
name|s
argument_list|,
name|MAX_WIDTH
argument_list|,
literal|L"%.*s%ls"
argument_list|,
call|(
name|int
call|)
argument_list|(
name|w
operator|-
name|wcslen
argument_list|(
name|t
argument_list|)
argument_list|)
operator|/
literal|2
argument_list|,
name|blanks
argument_list|,
name|t
argument_list|)
expr_stmt|;
return|return
operator|(
name|s
operator|)
return|;
block|}
end_function

begin_function
name|int
name|parsemonth
parameter_list|(
specifier|const
name|char
modifier|*
name|s
parameter_list|,
name|int
modifier|*
name|m
parameter_list|,
name|int
modifier|*
name|y
parameter_list|)
block|{
name|int
name|nm
decl_stmt|,
name|ny
decl_stmt|;
name|char
modifier|*
name|cp
decl_stmt|;
name|struct
name|tm
name|tm
decl_stmt|;
name|nm
operator|=
operator|(
name|int
operator|)
name|strtol
argument_list|(
name|s
argument_list|,
operator|&
name|cp
argument_list|,
literal|10
argument_list|)
expr_stmt|;
if|if
condition|(
name|cp
operator|!=
name|s
condition|)
block|{
name|ny
operator|=
operator|*
name|y
expr_stmt|;
if|if
condition|(
operator|*
name|cp
operator|==
literal|'\0'
condition|)
block|{
empty_stmt|;
comment|/* no special action */
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'f'
operator|||
operator|*
name|cp
operator|==
literal|'F'
condition|)
block|{
if|if
condition|(
name|nm
operator|<=
operator|*
name|m
condition|)
name|ny
operator|++
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|*
name|cp
operator|==
literal|'p'
operator|||
operator|*
name|cp
operator|==
literal|'P'
condition|)
block|{
if|if
condition|(
name|nm
operator|>=
operator|*
name|m
condition|)
name|ny
operator|--
expr_stmt|;
block|}
else|else
return|return
operator|(
literal|1
operator|)
return|;
if|if
condition|(
name|nm
operator|<
literal|1
operator|||
name|nm
operator|>
literal|12
condition|)
return|return
literal|1
return|;
operator|*
name|m
operator|=
name|nm
expr_stmt|;
operator|*
name|y
operator|=
name|ny
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|strptime
argument_list|(
name|s
argument_list|,
literal|"%B"
argument_list|,
operator|&
name|tm
argument_list|)
operator|!=
name|NULL
operator|||
name|strptime
argument_list|(
name|s
argument_list|,
literal|"%b"
argument_list|,
operator|&
name|tm
argument_list|)
operator|!=
name|NULL
condition|)
block|{
operator|*
name|m
operator|=
name|tm
operator|.
name|tm_mon
operator|+
literal|1
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_function
name|void
name|highlight
parameter_list|(
name|char
modifier|*
name|dst
parameter_list|,
name|char
modifier|*
name|src
parameter_list|,
name|int
name|len
parameter_list|,
name|int
modifier|*
name|extralen
parameter_list|)
block|{
specifier|static
name|int
name|first
init|=
literal|1
decl_stmt|;
specifier|static
specifier|const
name|char
modifier|*
name|term_so
decl_stmt|,
modifier|*
name|term_se
decl_stmt|;
if|if
condition|(
name|first
condition|)
block|{
name|char
name|tbuf
index|[
literal|1024
index|]
decl_stmt|,
name|cbuf
index|[
literal|512
index|]
decl_stmt|,
modifier|*
name|b
decl_stmt|;
name|term_se
operator|=
name|term_so
operator|=
name|NULL
expr_stmt|;
comment|/* On how to highlight on this type of terminal (if any) */
if|if
condition|(
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
operator|&&
name|tgetent
argument_list|(
name|tbuf
argument_list|,
name|NULL
argument_list|)
operator|==
literal|1
condition|)
block|{
name|b
operator|=
name|cbuf
expr_stmt|;
name|term_so
operator|=
name|tgetstr
argument_list|(
literal|"so"
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
name|term_se
operator|=
name|tgetstr
argument_list|(
literal|"se"
argument_list|,
operator|&
name|b
argument_list|)
expr_stmt|;
block|}
name|first
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 	 * This check is not necessary, should have been handled before calling 	 * this function. 	 */
if|if
condition|(
name|flag_nohighlight
condition|)
block|{
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* If it is a real terminal, use the data from the termcap database. */
if|if
condition|(
name|term_so
operator|!=
name|NULL
operator|&&
name|term_se
operator|!=
name|NULL
condition|)
block|{
comment|/* separator */
name|dst
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
comment|/* highlight on */
name|memcpy
argument_list|(
name|dst
argument_list|,
name|term_so
argument_list|,
name|strlen
argument_list|(
name|term_so
argument_list|)
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|strlen
argument_list|(
name|term_so
argument_list|)
expr_stmt|;
comment|/* the actual text (minus leading space) */
name|len
operator|--
expr_stmt|;
name|src
operator|++
expr_stmt|;
name|memcpy
argument_list|(
name|dst
argument_list|,
name|src
argument_list|,
name|len
argument_list|)
expr_stmt|;
name|dst
operator|+=
name|len
expr_stmt|;
comment|/* highlight off */
name|memcpy
argument_list|(
name|dst
argument_list|,
name|term_se
argument_list|,
name|strlen
argument_list|(
name|term_se
argument_list|)
argument_list|)
expr_stmt|;
operator|*
name|extralen
operator|=
name|strlen
argument_list|(
name|term_so
argument_list|)
operator|+
name|strlen
argument_list|(
name|term_se
argument_list|)
expr_stmt|;
return|return;
block|}
comment|/* 	 * Otherwise, print a _, backspace and the letter 	 */
operator|*
name|extralen
operator|=
literal|0
expr_stmt|;
comment|/* skip leading space */
name|src
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
comment|/* separator */
name|dst
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
name|dst
operator|++
expr_stmt|;
while|while
condition|(
name|len
operator|>
literal|0
condition|)
block|{
comment|/* _ and backspace */
name|memcpy
argument_list|(
name|dst
argument_list|,
literal|"_\010"
argument_list|,
literal|2
argument_list|)
expr_stmt|;
name|dst
operator|+=
literal|2
expr_stmt|;
operator|*
name|extralen
operator|+=
literal|2
expr_stmt|;
comment|/* the character */
operator|*
name|dst
operator|++
operator|=
operator|*
name|src
operator|++
expr_stmt|;
name|len
operator|--
expr_stmt|;
block|}
block|}
end_function

end_unit

