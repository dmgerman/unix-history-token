begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * SPDX-License-Identifier: BSD-4-Clause  *  * Copyright (c) 1991 Keith Muller.  * Copyright (c) 1993  *	The Regents of the University of California.  All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Keith Muller of the University of California, San Diego.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)pr.c	8.2 (Berkeley) 4/16/94";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|<sys/time.h>
end_include

begin_include
include|#
directive|include
file|<sys/stat.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<errno.h>
end_include

begin_include
include|#
directive|include
file|<langinfo.h>
end_include

begin_include
include|#
directive|include
file|<locale.h>
end_include

begin_include
include|#
directive|include
file|<signal.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|"pr.h"
end_include

begin_include
include|#
directive|include
file|"extern.h"
end_include

begin_comment
comment|/*  * pr:	a printing and pagination filter. If multiple input files  *	are specified, each is read, formatted, and written to standard  *	output. By default, input is separated into 66-line pages, each  *	with a header that includes the page number, date, time and the  *	files pathname.  *  *	Complies with posix P1003.2/D11  */
end_comment

begin_comment
comment|/*  * parameter variables  */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pgnm
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* starting page number */
end_comment

begin_decl_stmt
specifier|static
name|int
name|clcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of columns */
end_comment

begin_decl_stmt
specifier|static
name|int
name|colwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* column data width - multiple columns */
end_comment

begin_decl_stmt
specifier|static
name|int
name|across
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* mult col flag; write across page */
end_comment

begin_decl_stmt
specifier|static
name|int
name|dspace
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* double space flag */
end_comment

begin_decl_stmt
specifier|static
name|char
name|inchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* expand input char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ingap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* expand input gap */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pausefst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pause before first page */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pauseall
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Pause before each page */
end_comment

begin_decl_stmt
specifier|static
name|int
name|formfeed
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* use formfeed as trailer */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|header
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* header name instead of file name */
end_comment

begin_decl_stmt
specifier|static
name|char
name|ochar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contract output char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ogap
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* contract output gap */
end_comment

begin_decl_stmt
specifier|static
name|int
name|lines
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of lines per page */
end_comment

begin_decl_stmt
specifier|static
name|int
name|merge
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* merge multiple files in output */
end_comment

begin_decl_stmt
specifier|static
name|char
name|nmchar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* line numbering append char */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nmwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* width of line number field */
end_comment

begin_decl_stmt
specifier|static
name|int
name|offst
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* number of page offset spaces */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nodiag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do not report file open errors */
end_comment

begin_decl_stmt
specifier|static
name|char
name|schar
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* text column separation character */
end_comment

begin_decl_stmt
specifier|static
name|int
name|sflag
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* -s option for multiple columns */
end_comment

begin_decl_stmt
specifier|static
name|int
name|nohead
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* do not write head and trailer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|pgwd
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page width with multiple col output */
end_comment

begin_decl_stmt
specifier|static
name|char
modifier|*
name|timefrmt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* time conversion string */
end_comment

begin_comment
comment|/*  * misc globals  */
end_comment

begin_decl_stmt
specifier|static
name|FILE
modifier|*
name|err
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error message file pointer */
end_comment

begin_decl_stmt
specifier|static
name|int
name|addone
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page length is odd with double space */
end_comment

begin_decl_stmt
specifier|static
name|int
name|errcnt
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* error count on file processing */
end_comment

begin_decl_stmt
specifier|static
name|char
name|digs
index|[]
init|=
literal|"0123456789"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* page number translation map */
end_comment

begin_decl_stmt
specifier|static
name|char
name|fnamedefault
index|[]
init|=
name|FNAME
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|ret_val
decl_stmt|;
if|if
condition|(
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|SIG_IGN
argument_list|)
operator|!=
name|SIG_IGN
condition|)
operator|(
name|void
operator|)
name|signal
argument_list|(
name|SIGINT
argument_list|,
name|terminate
argument_list|)
expr_stmt|;
name|ret_val
operator|=
name|setup
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|ret_val
condition|)
block|{
comment|/* 		 * select the output format based on options 		 */
if|if
condition|(
name|merge
condition|)
name|ret_val
operator|=
name|mulfile
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|clcnt
operator|==
literal|1
condition|)
name|ret_val
operator|=
name|onecol
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|across
condition|)
name|ret_val
operator|=
name|horzcol
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
else|else
name|ret_val
operator|=
name|vertcol
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|timefrmt
argument_list|)
expr_stmt|;
block|}
else|else
name|usage
argument_list|()
expr_stmt|;
name|flsh_errs
argument_list|()
expr_stmt|;
if|if
condition|(
name|errcnt
operator|||
name|ret_val
condition|)
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Check if we should pause and write an alert character and wait for a  * carriage return on /dev/tty.  */
end_comment

begin_function
specifier|static
name|void
name|ttypause
parameter_list|(
name|int
name|pagecnt
parameter_list|)
block|{
name|int
name|pch
decl_stmt|;
name|FILE
modifier|*
name|ttyfp
decl_stmt|;
if|if
condition|(
operator|(
name|pauseall
operator|||
operator|(
name|pausefst
operator|&&
name|pagecnt
operator|==
literal|1
operator|)
operator|)
operator|&&
name|isatty
argument_list|(
name|STDOUT_FILENO
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ttyfp
operator|=
name|fopen
argument_list|(
literal|"/dev/tty"
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
operator|(
name|void
operator|)
name|putc
argument_list|(
literal|'\a'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|pch
operator|=
name|getc
argument_list|(
name|ttyfp
argument_list|)
operator|)
operator|!=
literal|'\n'
operator|&&
name|pch
operator|!=
name|EOF
condition|)
empty_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|ttyfp
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/*  * onecol:	print files with only one column of output.  *		Line length is unlimited.  */
end_comment

begin_function
name|int
name|onecol
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|cnt
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|off
decl_stmt|;
name|int
name|lrgln
decl_stmt|;
name|int
name|linecnt
decl_stmt|;
name|int
name|num
decl_stmt|;
name|int
name|lncnt
decl_stmt|;
name|int
name|pagecnt
decl_stmt|;
name|int
name|ips
decl_stmt|;
name|int
name|ops
decl_stmt|;
name|int
name|cps
decl_stmt|;
name|char
modifier|*
name|obuf
decl_stmt|;
name|char
modifier|*
name|lbuf
decl_stmt|;
name|char
modifier|*
name|nbuf
decl_stmt|;
name|char
modifier|*
name|hbuf
decl_stmt|;
name|char
modifier|*
name|ohbuf
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|mor
decl_stmt|;
if|if
condition|(
name|nmwd
condition|)
name|num
operator|=
name|nmwd
operator|+
literal|1
expr_stmt|;
else|else
name|num
operator|=
literal|0
expr_stmt|;
name|off
operator|=
name|num
operator|+
name|offst
expr_stmt|;
comment|/* 	 * allocate line buffer 	 */
if|if
condition|(
operator|(
name|obuf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|LBUF
operator|+
name|off
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * allocate header buffer 	 */
if|if
condition|(
operator|(
name|hbuf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|HDBUF
operator|+
name|offst
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
name|mfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ohbuf
operator|=
name|hbuf
operator|+
name|offst
expr_stmt|;
name|nbuf
operator|=
name|obuf
operator|+
name|offst
expr_stmt|;
name|lbuf
operator|=
name|nbuf
operator|+
name|num
expr_stmt|;
if|if
condition|(
name|num
condition|)
name|nbuf
index|[
operator|--
name|num
index|]
operator|=
name|nmchar
expr_stmt|;
if|if
condition|(
name|offst
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|obuf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|hbuf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * loop by file 	 */
while|while
condition|(
operator|(
name|inf
operator|=
name|nxtfile
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|fname
argument_list|,
name|ohbuf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pgnm
condition|)
block|{
comment|/* 			 * skip to specified page 			 */
if|if
condition|(
name|inskip
argument_list|(
name|inf
argument_list|,
name|pgnm
argument_list|,
name|lines
argument_list|)
condition|)
continue|continue;
name|pagecnt
operator|=
name|pgnm
expr_stmt|;
block|}
else|else
name|pagecnt
operator|=
literal|1
expr_stmt|;
name|lncnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * loop by page 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|linecnt
operator|=
literal|0
expr_stmt|;
name|lrgln
operator|=
literal|0
expr_stmt|;
name|ops
operator|=
literal|0
expr_stmt|;
name|ips
operator|=
literal|0
expr_stmt|;
name|cps
operator|=
literal|0
expr_stmt|;
name|ttypause
argument_list|(
name|pagecnt
argument_list|)
expr_stmt|;
comment|/* 			 * loop by line 			 */
while|while
condition|(
name|linecnt
operator|<
name|lines
condition|)
block|{
comment|/* 				 * input next line 				 */
if|if
condition|(
operator|(
name|cnt
operator|=
name|inln
argument_list|(
name|inf
argument_list|,
name|lbuf
argument_list|,
name|LBUF
argument_list|,
operator|&
name|cps
argument_list|,
literal|0
argument_list|,
operator|&
name|mor
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
if|if
condition|(
operator|!
name|linecnt
operator|&&
operator|!
name|nohead
operator|&&
name|prhead
argument_list|(
name|hbuf
argument_list|,
name|fname
argument_list|,
name|pagecnt
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 				 * start of new line. 				 */
if|if
condition|(
operator|!
name|lrgln
condition|)
block|{
if|if
condition|(
name|num
condition|)
name|addnum
argument_list|(
name|nbuf
argument_list|,
name|num
argument_list|,
operator|++
name|lncnt
argument_list|)
expr_stmt|;
if|if
condition|(
name|otln
argument_list|(
name|obuf
argument_list|,
name|cnt
operator|+
name|off
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
name|mor
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
elseif|else
if|if
condition|(
name|otln
argument_list|(
name|lbuf
argument_list|,
name|cnt
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
name|mor
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 				 * if line bigger than buffer, get more 				 */
if|if
condition|(
name|mor
condition|)
block|{
name|lrgln
operator|=
literal|1
expr_stmt|;
continue|continue;
block|}
comment|/* 				 * whole line rcvd. reset tab proc. state 				 */
operator|++
name|linecnt
expr_stmt|;
name|lrgln
operator|=
literal|0
expr_stmt|;
name|ops
operator|=
literal|0
expr_stmt|;
name|ips
operator|=
literal|0
expr_stmt|;
block|}
comment|/* 			 * fill to end of page 			 */
if|if
condition|(
name|linecnt
operator|&&
name|prtail
argument_list|(
name|lines
operator|-
name|linecnt
operator|-
name|lrgln
argument_list|,
name|lrgln
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 			 * On EOF go to next file 			 */
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
break|break;
operator|++
name|pagecnt
expr_stmt|;
block|}
if|if
condition|(
name|inf
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eoptind
operator|<
name|argc
condition|)
goto|goto
name|err
goto|;
name|free
argument_list|(
name|hbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|hbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|obuf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * vertcol:	print files with more than one column of output down a page  */
end_comment

begin_function
name|int
name|vertcol
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|ptbf
decl_stmt|;
name|char
modifier|*
modifier|*
name|lstdat
init|=
name|NULL
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|cnt
init|=
operator|-
literal|1
decl_stmt|;
name|int
name|pln
decl_stmt|;
name|int
modifier|*
name|indy
init|=
name|NULL
decl_stmt|;
name|int
name|cvc
decl_stmt|;
name|int
modifier|*
name|lindy
init|=
name|NULL
decl_stmt|;
name|int
name|lncnt
decl_stmt|;
name|int
name|stp
decl_stmt|;
name|int
name|pagecnt
decl_stmt|;
name|int
name|col
init|=
name|colwd
operator|+
literal|1
decl_stmt|;
name|int
name|mxlen
init|=
name|pgwd
operator|+
name|offst
operator|+
literal|1
decl_stmt|;
name|int
name|mclcnt
init|=
name|clcnt
operator|-
literal|1
decl_stmt|;
name|struct
name|vcol
modifier|*
name|vc
init|=
name|NULL
decl_stmt|;
name|int
name|mvc
decl_stmt|;
name|int
name|tvc
decl_stmt|;
name|int
name|cw
init|=
name|nmwd
operator|+
literal|1
decl_stmt|;
name|int
name|fullcol
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|hbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ohbuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
name|int
name|ips
init|=
literal|0
decl_stmt|;
name|int
name|cps
init|=
literal|0
decl_stmt|;
name|int
name|ops
init|=
literal|0
decl_stmt|;
name|int
name|mor
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
comment|/* 	 * allocate page buffer 	 */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|lines
operator|*
name|mxlen
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * allocate page header 	 */
if|if
condition|(
operator|(
name|hbuf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|HDBUF
operator|+
name|offst
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ohbuf
operator|=
name|hbuf
operator|+
name|offst
expr_stmt|;
if|if
condition|(
name|offst
condition|)
operator|(
name|void
operator|)
name|memset
argument_list|(
name|hbuf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
comment|/* 	 * col pointers when no headers 	 */
name|mvc
operator|=
name|lines
operator|*
name|clcnt
expr_stmt|;
if|if
condition|(
operator|(
name|vc
operator|=
operator|(
expr|struct
name|vcol
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|mvc
operator|*
sizeof|sizeof
argument_list|(
expr|struct
name|vcol
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * pointer into page where last data per line is located 	 */
if|if
condition|(
operator|(
name|lstdat
operator|=
operator|(
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|lines
operator|*
sizeof|sizeof
argument_list|(
name|char
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * fast index lookups to locate start of lines 	 */
if|if
condition|(
operator|(
name|indy
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|lines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
operator|(
name|lindy
operator|=
operator|(
name|int
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|lines
operator|*
sizeof|sizeof
argument_list|(
name|int
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|nmwd
condition|)
name|fullcol
operator|=
name|col
operator|+
name|cw
expr_stmt|;
else|else
name|fullcol
operator|=
name|col
expr_stmt|;
comment|/* 	 * initialize buffer lookup indexes and offset area 	 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|lines
condition|;
operator|++
name|j
control|)
block|{
name|lindy
index|[
name|j
index|]
operator|=
name|j
operator|*
name|mxlen
expr_stmt|;
name|indy
index|[
name|j
index|]
operator|=
name|lindy
index|[
name|j
index|]
operator|+
name|offst
expr_stmt|;
if|if
condition|(
name|offst
condition|)
block|{
name|ptbf
operator|=
name|buf
operator|+
name|lindy
index|[
name|j
index|]
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|ptbf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
name|ptbf
operator|+=
name|offst
expr_stmt|;
block|}
else|else
name|ptbf
operator|=
name|buf
operator|+
name|indy
index|[
name|j
index|]
expr_stmt|;
name|lstdat
index|[
name|j
index|]
operator|=
name|ptbf
expr_stmt|;
block|}
comment|/* 	 * loop by file 	 */
while|while
condition|(
operator|(
name|inf
operator|=
name|nxtfile
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|fname
argument_list|,
name|ohbuf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pgnm
condition|)
block|{
comment|/* 			 * skip to requested page 			 */
if|if
condition|(
name|inskip
argument_list|(
name|inf
argument_list|,
name|pgnm
argument_list|,
name|lines
argument_list|)
condition|)
continue|continue;
name|pagecnt
operator|=
name|pgnm
expr_stmt|;
block|}
else|else
name|pagecnt
operator|=
literal|1
expr_stmt|;
name|lncnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * loop by page 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ttypause
argument_list|(
name|pagecnt
argument_list|)
expr_stmt|;
comment|/* 			 * loop by column 			 */
name|cvc
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|clcnt
condition|;
operator|++
name|i
control|)
block|{
name|j
operator|=
literal|0
expr_stmt|;
comment|/* 				 * if last column, do not pad 				 */
if|if
condition|(
name|i
operator|==
name|mclcnt
condition|)
name|stp
operator|=
literal|1
expr_stmt|;
else|else
name|stp
operator|=
literal|0
expr_stmt|;
comment|/* 				 * loop by line 				 */
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* 					 * is this first column 					 */
if|if
condition|(
operator|!
name|i
condition|)
block|{
name|ptbf
operator|=
name|buf
operator|+
name|indy
index|[
name|j
index|]
expr_stmt|;
name|lstdat
index|[
name|j
index|]
operator|=
name|ptbf
expr_stmt|;
block|}
else|else
name|ptbf
operator|=
name|lstdat
index|[
name|j
index|]
expr_stmt|;
name|vc
index|[
name|cvc
index|]
operator|.
name|pt
operator|=
name|ptbf
expr_stmt|;
comment|/* 					 * add number 					 */
if|if
condition|(
name|nmwd
condition|)
block|{
name|addnum
argument_list|(
name|ptbf
argument_list|,
name|nmwd
argument_list|,
operator|++
name|lncnt
argument_list|)
expr_stmt|;
name|ptbf
operator|+=
name|nmwd
expr_stmt|;
operator|*
name|ptbf
operator|++
operator|=
name|nmchar
expr_stmt|;
block|}
comment|/* 					 * input next line 					 */
name|cnt
operator|=
name|inln
argument_list|(
name|inf
argument_list|,
name|ptbf
argument_list|,
name|colwd
argument_list|,
operator|&
name|cps
argument_list|,
literal|1
argument_list|,
operator|&
name|mor
argument_list|)
expr_stmt|;
name|vc
index|[
name|cvc
operator|++
index|]
operator|.
name|cnt
operator|=
name|cnt
expr_stmt|;
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
break|break;
name|ptbf
operator|+=
name|cnt
expr_stmt|;
comment|/* 					 * pad all but last column on page 					 */
if|if
condition|(
operator|!
name|stp
condition|)
block|{
comment|/* 						 * pad to end of column 						 */
if|if
condition|(
name|sflag
condition|)
operator|*
name|ptbf
operator|++
operator|=
name|schar
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pln
operator|=
name|col
operator|-
name|cnt
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|ptbf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|pln
argument_list|)
expr_stmt|;
name|ptbf
operator|+=
name|pln
expr_stmt|;
block|}
block|}
comment|/* 					 * remember last char in line 					 */
name|lstdat
index|[
name|j
index|]
operator|=
name|ptbf
expr_stmt|;
if|if
condition|(
operator|++
name|j
operator|>=
name|lines
condition|)
break|break;
block|}
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
break|break;
block|}
comment|/* 			 * when -t (no header) is specified the spec requires 			 * the min number of lines. The last page may not have 			 * balanced length columns. To fix this we must reorder 			 * the columns. This is a very slow technique so it is 			 * only used under limited conditions. Without -t, the 			 * balancing of text columns is unspecified. To NOT 			 * balance the last page, add the global variable 			 * nohead to the if statement below e.g. 			 * 			 * if ((cnt< 0)&& nohead&& cvc ...... 			 */
operator|--
name|cvc
expr_stmt|;
comment|/* 			 * check to see if last page needs to be reordered 			 */
if|if
condition|(
operator|(
name|cnt
operator|<
literal|0
operator|)
operator|&&
name|cvc
operator|&&
operator|(
operator|(
name|mvc
operator|-
name|cvc
operator|)
operator|>=
name|clcnt
operator|)
condition|)
block|{
name|pln
operator|=
name|cvc
operator|/
name|clcnt
expr_stmt|;
if|if
condition|(
name|cvc
operator|%
name|clcnt
condition|)
operator|++
name|pln
expr_stmt|;
comment|/* 				 * print header 				 */
if|if
condition|(
operator|!
name|nohead
operator|&&
name|prhead
argument_list|(
name|hbuf
argument_list|,
name|fname
argument_list|,
name|pagecnt
argument_list|)
condition|)
goto|goto
name|out
goto|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pln
condition|;
operator|++
name|i
control|)
block|{
name|ips
operator|=
literal|0
expr_stmt|;
name|ops
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|offst
operator|&&
name|otln
argument_list|(
name|buf
argument_list|,
name|offst
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|tvc
operator|=
name|i
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|clcnt
condition|;
operator|++
name|j
control|)
block|{
comment|/* 						 * determine column length 						 */
if|if
condition|(
name|j
operator|==
name|mclcnt
condition|)
block|{
comment|/* 							 * last column 							 */
name|cnt
operator|=
name|vc
index|[
name|tvc
index|]
operator|.
name|cnt
expr_stmt|;
if|if
condition|(
name|nmwd
condition|)
name|cnt
operator|+=
name|cw
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|sflag
condition|)
block|{
comment|/* 							 * single ch between 							 */
name|cnt
operator|=
name|vc
index|[
name|tvc
index|]
operator|.
name|cnt
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|nmwd
condition|)
name|cnt
operator|+=
name|cw
expr_stmt|;
block|}
else|else
name|cnt
operator|=
name|fullcol
expr_stmt|;
if|if
condition|(
name|otln
argument_list|(
name|vc
index|[
name|tvc
index|]
operator|.
name|pt
argument_list|,
name|cnt
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
literal|1
argument_list|)
condition|)
goto|goto
name|out
goto|;
name|tvc
operator|+=
name|pln
expr_stmt|;
if|if
condition|(
name|tvc
operator|>=
name|cvc
condition|)
break|break;
block|}
comment|/* 					 * terminate line 					 */
if|if
condition|(
name|otln
argument_list|(
name|buf
argument_list|,
literal|0
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 				 * pad to end of page 				 */
if|if
condition|(
name|prtail
argument_list|(
operator|(
name|lines
operator|-
name|pln
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 				 * done with output, go to next file 				 */
break|break;
block|}
comment|/* 			 * determine how many lines to output 			 */
if|if
condition|(
name|i
operator|>
literal|0
condition|)
name|pln
operator|=
name|lines
expr_stmt|;
else|else
name|pln
operator|=
name|j
expr_stmt|;
comment|/* 			 * print header 			 */
if|if
condition|(
name|pln
operator|&&
operator|!
name|nohead
operator|&&
name|prhead
argument_list|(
name|hbuf
argument_list|,
name|fname
argument_list|,
name|pagecnt
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * output each line 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|pln
condition|;
operator|++
name|i
control|)
block|{
name|ptbf
operator|=
name|buf
operator|+
name|lindy
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
operator|(
name|j
operator|=
name|lstdat
index|[
name|i
index|]
operator|-
name|ptbf
operator|)
operator|<=
name|offst
condition|)
break|break;
if|if
condition|(
name|otln
argument_list|(
name|ptbf
argument_list|,
name|j
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
block|}
comment|/* 			 * pad to end of page 			 */
if|if
condition|(
name|pln
operator|&&
name|prtail
argument_list|(
operator|(
name|lines
operator|-
name|pln
operator|)
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * if EOF go to next file 			 */
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
break|break;
operator|++
name|pagecnt
expr_stmt|;
block|}
if|if
condition|(
name|inf
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eoptind
operator|<
name|argc
condition|)
goto|goto
name|out
goto|;
name|retval
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|lindy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|indy
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|lstdat
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|vc
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * horzcol:	print files with more than one column of output across a page  */
end_comment

begin_function
name|int
name|horzcol
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|ptbf
decl_stmt|;
name|int
name|pln
decl_stmt|;
name|int
name|cnt
init|=
operator|-
literal|1
decl_stmt|;
name|char
modifier|*
name|lstdat
decl_stmt|;
name|int
name|col
init|=
name|colwd
operator|+
literal|1
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|i
decl_stmt|;
name|int
name|lncnt
decl_stmt|;
name|int
name|pagecnt
decl_stmt|;
name|char
modifier|*
name|buf
decl_stmt|;
name|char
modifier|*
name|hbuf
decl_stmt|;
name|char
modifier|*
name|ohbuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|FILE
modifier|*
name|inf
decl_stmt|;
name|int
name|ips
init|=
literal|0
decl_stmt|;
name|int
name|cps
init|=
literal|0
decl_stmt|;
name|int
name|ops
init|=
literal|0
decl_stmt|;
name|int
name|mor
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|pgwd
operator|+
name|offst
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * page header 	 */
if|if
condition|(
operator|(
name|hbuf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|HDBUF
operator|+
name|offst
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|mfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ohbuf
operator|=
name|hbuf
operator|+
name|offst
expr_stmt|;
if|if
condition|(
name|offst
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|hbuf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
block|}
comment|/* 	 * loop by file 	 */
while|while
condition|(
operator|(
name|inf
operator|=
name|nxtfile
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|fname
argument_list|,
name|ohbuf
argument_list|,
literal|0
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|pgnm
condition|)
block|{
if|if
condition|(
name|inskip
argument_list|(
name|inf
argument_list|,
name|pgnm
argument_list|,
name|lines
argument_list|)
condition|)
continue|continue;
name|pagecnt
operator|=
name|pgnm
expr_stmt|;
block|}
else|else
name|pagecnt
operator|=
literal|1
expr_stmt|;
name|lncnt
operator|=
literal|0
expr_stmt|;
comment|/* 		 * loop by page 		 */
for|for
control|(
init|;
condition|;
control|)
block|{
name|ttypause
argument_list|(
name|pagecnt
argument_list|)
expr_stmt|;
comment|/* 			 * loop by line 			 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
operator|++
name|i
control|)
block|{
name|ptbf
operator|=
name|buf
operator|+
name|offst
expr_stmt|;
name|lstdat
operator|=
name|ptbf
expr_stmt|;
name|j
operator|=
literal|0
expr_stmt|;
comment|/* 				 * loop by col 				 */
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
name|nmwd
condition|)
block|{
comment|/* 						 * add number to column 						 */
name|addnum
argument_list|(
name|ptbf
argument_list|,
name|nmwd
argument_list|,
operator|++
name|lncnt
argument_list|)
expr_stmt|;
name|ptbf
operator|+=
name|nmwd
expr_stmt|;
operator|*
name|ptbf
operator|++
operator|=
name|nmchar
expr_stmt|;
block|}
comment|/* 					 * input line 					 */
if|if
condition|(
operator|(
name|cnt
operator|=
name|inln
argument_list|(
name|inf
argument_list|,
name|ptbf
argument_list|,
name|colwd
argument_list|,
operator|&
name|cps
argument_list|,
literal|1
argument_list|,
operator|&
name|mor
argument_list|)
operator|)
operator|<
literal|0
condition|)
break|break;
name|ptbf
operator|+=
name|cnt
expr_stmt|;
name|lstdat
operator|=
name|ptbf
expr_stmt|;
comment|/* 					 * if last line skip padding 					 */
if|if
condition|(
operator|++
name|j
operator|>=
name|clcnt
condition|)
break|break;
comment|/* 					 * pad to end of column 					 */
if|if
condition|(
name|sflag
condition|)
operator|*
name|ptbf
operator|++
operator|=
name|schar
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|pln
operator|=
name|col
operator|-
name|cnt
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|ptbf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|pln
argument_list|)
expr_stmt|;
name|ptbf
operator|+=
name|pln
expr_stmt|;
block|}
block|}
comment|/* 				 * determine line length 				 */
if|if
condition|(
operator|(
name|j
operator|=
name|lstdat
operator|-
name|buf
operator|)
operator|<=
name|offst
condition|)
break|break;
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|nohead
operator|&&
name|prhead
argument_list|(
name|hbuf
argument_list|,
name|fname
argument_list|,
name|pagecnt
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 				 * output line 				 */
if|if
condition|(
name|otln
argument_list|(
name|buf
argument_list|,
name|j
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
block|}
comment|/* 			 * pad to end of page 			 */
if|if
condition|(
name|i
operator|&&
name|prtail
argument_list|(
name|lines
operator|-
name|i
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|err
goto|;
comment|/* 			 * if EOF go to next file 			 */
if|if
condition|(
name|cnt
operator|<
literal|0
condition|)
break|break;
operator|++
name|pagecnt
expr_stmt|;
block|}
if|if
condition|(
name|inf
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|eoptind
operator|<
name|argc
condition|)
goto|goto
name|err
goto|;
name|free
argument_list|(
name|hbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
name|err
label|:
name|free
argument_list|(
name|hbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * mulfile:	print files with more than one column of output and  *		more than one file concurrently  */
end_comment

begin_function
name|int
name|mulfile
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|char
modifier|*
name|ptbf
decl_stmt|;
name|int
name|j
decl_stmt|;
name|int
name|pln
decl_stmt|;
name|int
name|cnt
decl_stmt|;
name|char
modifier|*
name|lstdat
decl_stmt|;
name|int
name|i
decl_stmt|;
name|FILE
modifier|*
modifier|*
name|fbuf
init|=
name|NULL
decl_stmt|;
name|int
name|actf
decl_stmt|;
name|int
name|lncnt
decl_stmt|;
name|int
name|col
decl_stmt|;
name|int
name|pagecnt
decl_stmt|;
name|int
name|fproc
decl_stmt|;
name|char
modifier|*
name|buf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|hbuf
init|=
name|NULL
decl_stmt|;
name|char
modifier|*
name|ohbuf
decl_stmt|;
specifier|const
name|char
modifier|*
name|fname
decl_stmt|;
name|int
name|ips
init|=
literal|0
decl_stmt|;
name|int
name|cps
init|=
literal|0
decl_stmt|;
name|int
name|ops
init|=
literal|0
decl_stmt|;
name|int
name|mor
init|=
literal|0
decl_stmt|;
name|int
name|retval
init|=
literal|1
decl_stmt|;
comment|/* 	 * array of FILE *, one for each operand 	 */
if|if
condition|(
operator|(
name|fbuf
operator|=
operator|(
name|FILE
operator|*
operator|*
operator|)
name|malloc
argument_list|(
operator|(
name|unsigned
operator|)
name|clcnt
operator|*
sizeof|sizeof
argument_list|(
name|FILE
operator|*
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
comment|/* 	 * page header 	 */
if|if
condition|(
operator|(
name|hbuf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|HDBUF
operator|+
name|offst
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|ohbuf
operator|=
name|hbuf
operator|+
name|offst
expr_stmt|;
comment|/* 	 * do not know how many columns yet. The number of operands provide an 	 * upper bound on the number of columns. We use the number of files 	 * we can open successfully to set the number of columns. The operation 	 * of the merge operation (-m) in relation to unsuccessful file opens 	 * is unspecified by posix. 	 */
name|j
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|j
operator|<
name|clcnt
condition|)
block|{
if|if
condition|(
operator|(
name|fbuf
index|[
name|j
index|]
operator|=
name|nxtfile
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
operator|&
name|fname
argument_list|,
name|ohbuf
argument_list|,
literal|1
argument_list|)
operator|)
operator|==
name|NULL
condition|)
break|break;
if|if
condition|(
name|pgnm
operator|&&
operator|(
name|inskip
argument_list|(
name|fbuf
index|[
name|j
index|]
argument_list|,
name|pgnm
argument_list|,
name|lines
argument_list|)
operator|)
condition|)
name|fbuf
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
operator|++
name|j
expr_stmt|;
block|}
comment|/* 	 * if no files, exit 	 */
if|if
condition|(
operator|!
name|j
condition|)
goto|goto
name|out
goto|;
comment|/* 	 * calculate page boundaries based on open file count 	 */
name|clcnt
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|nmwd
condition|)
block|{
name|colwd
operator|=
operator|(
name|pgwd
operator|-
name|clcnt
operator|-
name|nmwd
operator|)
operator|/
name|clcnt
expr_stmt|;
name|pgwd
operator|=
operator|(
operator|(
name|colwd
operator|+
literal|1
operator|)
operator|*
name|clcnt
operator|)
operator|-
name|nmwd
operator|-
literal|2
expr_stmt|;
block|}
else|else
block|{
name|colwd
operator|=
operator|(
name|pgwd
operator|+
literal|1
operator|-
name|clcnt
operator|)
operator|/
name|clcnt
expr_stmt|;
name|pgwd
operator|=
operator|(
operator|(
name|colwd
operator|+
literal|1
operator|)
operator|*
name|clcnt
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|colwd
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: page width too small for %d columns\n"
argument_list|,
name|clcnt
argument_list|)
expr_stmt|;
goto|goto
name|out
goto|;
block|}
name|actf
operator|=
name|clcnt
expr_stmt|;
name|col
operator|=
name|colwd
operator|+
literal|1
expr_stmt|;
comment|/* 	 * line buffer 	 */
if|if
condition|(
operator|(
name|buf
operator|=
name|malloc
argument_list|(
call|(
name|unsigned
call|)
argument_list|(
name|pgwd
operator|+
name|offst
operator|+
literal|1
argument_list|)
operator|*
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|mfail
argument_list|()
expr_stmt|;
goto|goto
name|out
goto|;
block|}
if|if
condition|(
name|offst
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|buf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|memset
argument_list|(
name|hbuf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|offst
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|pgnm
condition|)
name|pagecnt
operator|=
name|pgnm
expr_stmt|;
else|else
name|pagecnt
operator|=
literal|1
expr_stmt|;
name|lncnt
operator|=
literal|0
expr_stmt|;
comment|/* 	 * continue to loop while any file still has data 	 */
while|while
condition|(
name|actf
operator|>
literal|0
condition|)
block|{
name|ttypause
argument_list|(
name|pagecnt
argument_list|)
expr_stmt|;
comment|/* 		 * loop by line 		 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<
name|lines
condition|;
operator|++
name|i
control|)
block|{
name|ptbf
operator|=
name|buf
operator|+
name|offst
expr_stmt|;
name|lstdat
operator|=
name|ptbf
expr_stmt|;
if|if
condition|(
name|nmwd
condition|)
block|{
comment|/* 				 * add line number to line 				 */
name|addnum
argument_list|(
name|ptbf
argument_list|,
name|nmwd
argument_list|,
operator|++
name|lncnt
argument_list|)
expr_stmt|;
name|ptbf
operator|+=
name|nmwd
expr_stmt|;
operator|*
name|ptbf
operator|++
operator|=
name|nmchar
expr_stmt|;
block|}
name|j
operator|=
literal|0
expr_stmt|;
name|fproc
operator|=
literal|0
expr_stmt|;
comment|/* 			 * loop by column 			 */
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|clcnt
condition|;
operator|++
name|j
control|)
block|{
if|if
condition|(
name|fbuf
index|[
name|j
index|]
operator|==
name|NULL
condition|)
block|{
comment|/* 					 * empty column; EOF 					 */
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|cnt
operator|=
name|inln
argument_list|(
name|fbuf
index|[
name|j
index|]
argument_list|,
name|ptbf
argument_list|,
name|colwd
argument_list|,
operator|&
name|cps
argument_list|,
literal|1
argument_list|,
operator|&
name|mor
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
comment|/* 					 * EOF hit; no data 					 */
if|if
condition|(
name|fbuf
index|[
name|j
index|]
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|fbuf
index|[
name|j
index|]
argument_list|)
expr_stmt|;
name|fbuf
index|[
name|j
index|]
operator|=
name|NULL
expr_stmt|;
operator|--
name|actf
expr_stmt|;
name|cnt
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 					 * process file data 					 */
name|ptbf
operator|+=
name|cnt
expr_stmt|;
name|lstdat
operator|=
name|ptbf
expr_stmt|;
name|fproc
operator|++
expr_stmt|;
block|}
comment|/* 				 * if last ACTIVE column, done with line 				 */
if|if
condition|(
name|fproc
operator|>=
name|actf
condition|)
break|break;
comment|/* 				 * pad to end of column 				 */
if|if
condition|(
name|sflag
condition|)
block|{
operator|*
name|ptbf
operator|++
operator|=
name|schar
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|pln
operator|=
name|col
operator|-
name|cnt
operator|)
operator|>
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|memset
argument_list|(
name|ptbf
argument_list|,
operator|(
name|int
operator|)
literal|' '
argument_list|,
name|pln
argument_list|)
expr_stmt|;
name|ptbf
operator|+=
name|pln
expr_stmt|;
block|}
block|}
comment|/* 			 * calculate data in line 			 */
if|if
condition|(
operator|(
name|j
operator|=
name|lstdat
operator|-
name|buf
operator|)
operator|<=
name|offst
condition|)
break|break;
if|if
condition|(
operator|!
name|i
operator|&&
operator|!
name|nohead
operator|&&
name|prhead
argument_list|(
name|hbuf
argument_list|,
name|fname
argument_list|,
name|pagecnt
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * output line 			 */
if|if
condition|(
name|otln
argument_list|(
name|buf
argument_list|,
name|j
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
comment|/* 			 * if no more active files, done 			 */
if|if
condition|(
name|actf
operator|<=
literal|0
condition|)
block|{
operator|++
name|i
expr_stmt|;
break|break;
block|}
block|}
comment|/* 		 * pad to end of page 		 */
if|if
condition|(
name|i
operator|&&
name|prtail
argument_list|(
name|lines
operator|-
name|i
argument_list|,
literal|0
argument_list|)
condition|)
goto|goto
name|out
goto|;
operator|++
name|pagecnt
expr_stmt|;
block|}
if|if
condition|(
name|eoptind
operator|<
name|argc
condition|)
goto|goto
name|out
goto|;
name|retval
operator|=
literal|0
expr_stmt|;
name|out
label|:
name|free
argument_list|(
name|buf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|hbuf
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|fbuf
argument_list|)
expr_stmt|;
return|return
operator|(
name|retval
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inln():	input a line of data (unlimited length lines supported)  *		Input is optionally expanded to spaces  *  *	inf:	file  *	buf:	buffer  *	lim:	buffer length  *	cps:	column position 1st char in buffer (large line support)  *	trnc:	throw away data more than lim up to \n  *	mor:	set if more data in line (not truncated)  */
end_comment

begin_function
name|int
name|inln
parameter_list|(
name|FILE
modifier|*
name|inf
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|lim
parameter_list|,
name|int
modifier|*
name|cps
parameter_list|,
name|int
name|trnc
parameter_list|,
name|int
modifier|*
name|mor
parameter_list|)
block|{
name|int
name|col
decl_stmt|;
name|int
name|gap
init|=
name|ingap
decl_stmt|;
name|int
name|ch
init|=
name|EOF
decl_stmt|;
name|char
modifier|*
name|ptbuf
decl_stmt|;
name|int
name|chk
init|=
operator|(
name|int
operator|)
name|inchar
decl_stmt|;
name|ptbuf
operator|=
name|buf
expr_stmt|;
if|if
condition|(
name|gap
condition|)
block|{
comment|/* 		 * expanding input option 		 */
while|while
condition|(
operator|(
operator|--
name|lim
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
condition|)
block|{
comment|/* 			 * is this the input "tab" char 			 */
if|if
condition|(
name|ch
operator|==
name|chk
condition|)
block|{
comment|/* 				 * expand to number of spaces 				 */
name|col
operator|=
operator|(
name|ptbuf
operator|-
name|buf
operator|)
operator|+
operator|*
name|cps
expr_stmt|;
name|col
operator|=
name|gap
operator|-
operator|(
name|col
operator|%
name|gap
operator|)
expr_stmt|;
comment|/* 				 * if more than this line, push back 				 */
if|if
condition|(
operator|(
name|col
operator|>
name|lim
operator|)
operator|&&
operator|(
name|ungetc
argument_list|(
name|ch
argument_list|,
name|inf
argument_list|)
operator|==
name|EOF
operator|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
comment|/* 				 * expand to spaces 				 */
while|while
condition|(
operator|(
operator|--
name|col
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|--
name|lim
operator|>=
literal|0
operator|)
condition|)
operator|*
name|ptbuf
operator|++
operator|=
literal|' '
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|ptbuf
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
else|else
block|{
comment|/* 		 * no expansion 		 */
while|while
condition|(
operator|(
operator|--
name|lim
operator|>=
literal|0
operator|)
operator|&&
operator|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
operator|)
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
operator|*
name|ptbuf
operator|++
operator|=
name|ch
expr_stmt|;
block|}
block|}
name|col
operator|=
name|ptbuf
operator|-
name|buf
expr_stmt|;
if|if
condition|(
name|ch
operator|==
name|EOF
condition|)
block|{
operator|*
name|mor
operator|=
literal|0
expr_stmt|;
operator|*
name|cps
operator|=
literal|0
expr_stmt|;
if|if
condition|(
operator|!
name|col
condition|)
return|return
operator|(
operator|-
literal|1
operator|)
return|;
return|return
operator|(
name|col
operator|)
return|;
block|}
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
block|{
comment|/* 		 * entire line processed 		 */
operator|*
name|mor
operator|=
literal|0
expr_stmt|;
operator|*
name|cps
operator|=
literal|0
expr_stmt|;
return|return
operator|(
name|col
operator|)
return|;
block|}
comment|/* 	 * line was larger than limit 	 */
if|if
condition|(
name|trnc
condition|)
block|{
comment|/* 		 * throw away rest of line 		 */
while|while
condition|(
operator|(
name|ch
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
name|ch
operator|==
literal|'\n'
condition|)
break|break;
block|}
operator|*
name|cps
operator|=
literal|0
expr_stmt|;
operator|*
name|mor
operator|=
literal|0
expr_stmt|;
block|}
else|else
block|{
comment|/* 		 * save column offset if not truncated 		 */
operator|*
name|cps
operator|+=
name|col
expr_stmt|;
operator|*
name|mor
operator|=
literal|1
expr_stmt|;
block|}
return|return
operator|(
name|col
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * otln():	output a line of data. (Supports unlimited length lines)  *		output is optionally contracted to tabs  *  *	buf:	output buffer with data  *	cnt:	number of chars of valid data in buf  *	svips:	buffer input column position (for large lines)  *	svops:	buffer output column position (for large lines)  *	mor:	output line not complete in this buf; more data to come.  *		1 is more, 0 is complete, -1 is no \n's  */
end_comment

begin_function
name|int
name|otln
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|cnt
parameter_list|,
name|int
modifier|*
name|svips
parameter_list|,
name|int
modifier|*
name|svops
parameter_list|,
name|int
name|mor
parameter_list|)
block|{
name|int
name|ops
decl_stmt|;
comment|/* last col output */
name|int
name|ips
decl_stmt|;
comment|/* last col in buf examined */
name|int
name|gap
init|=
name|ogap
decl_stmt|;
name|int
name|tbps
decl_stmt|;
name|char
modifier|*
name|endbuf
decl_stmt|;
if|if
condition|(
name|ogap
condition|)
block|{
comment|/* 		 * contracting on output 		 */
name|endbuf
operator|=
name|buf
operator|+
name|cnt
expr_stmt|;
name|ops
operator|=
operator|*
name|svops
expr_stmt|;
name|ips
operator|=
operator|*
name|svips
expr_stmt|;
while|while
condition|(
name|buf
operator|<
name|endbuf
condition|)
block|{
comment|/* 			 * count number of spaces and ochar in buffer 			 */
if|if
condition|(
operator|*
name|buf
operator|==
literal|' '
condition|)
block|{
operator|++
name|ips
expr_stmt|;
operator|++
name|buf
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * simulate ochar processing 			 */
if|if
condition|(
operator|*
name|buf
operator|==
name|ochar
condition|)
block|{
name|ips
operator|+=
name|gap
operator|-
operator|(
name|ips
operator|%
name|gap
operator|)
expr_stmt|;
operator|++
name|buf
expr_stmt|;
continue|continue;
block|}
comment|/* 			 * got a non space char; contract out spaces 			 */
while|while
condition|(
name|ips
operator|-
name|ops
operator|>
literal|1
condition|)
block|{
comment|/* 				 * use as many ochar as will fit 				 */
if|if
condition|(
operator|(
name|tbps
operator|=
name|ops
operator|+
name|gap
operator|-
operator|(
name|ops
operator|%
name|gap
operator|)
operator|)
operator|>
name|ips
condition|)
break|break;
if|if
condition|(
name|putchar
argument_list|(
name|ochar
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ops
operator|=
name|tbps
expr_stmt|;
block|}
while|while
condition|(
name|ops
operator|<
name|ips
condition|)
block|{
comment|/* 				 * finish off with spaces 				 */
if|if
condition|(
name|putchar
argument_list|(
literal|' '
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|++
name|ops
expr_stmt|;
block|}
comment|/* 			 * output non space char 			 */
if|if
condition|(
name|putchar
argument_list|(
operator|*
name|buf
operator|++
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|++
name|ips
expr_stmt|;
operator|++
name|ops
expr_stmt|;
block|}
if|if
condition|(
name|mor
operator|>
literal|0
condition|)
block|{
comment|/* 			 * if incomplete line, save position counts 			 */
operator|*
name|svops
operator|=
name|ops
expr_stmt|;
operator|*
name|svips
operator|=
name|ips
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
if|if
condition|(
name|mor
operator|<
literal|0
condition|)
block|{
while|while
condition|(
name|ips
operator|-
name|ops
operator|>
literal|1
condition|)
block|{
comment|/* 				 * use as many ochar as will fit 				 */
if|if
condition|(
operator|(
name|tbps
operator|=
name|ops
operator|+
name|gap
operator|-
operator|(
name|ops
operator|%
name|gap
operator|)
operator|)
operator|>
name|ips
condition|)
break|break;
if|if
condition|(
name|putchar
argument_list|(
name|ochar
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
name|ops
operator|=
name|tbps
expr_stmt|;
block|}
while|while
condition|(
name|ops
operator|<
name|ips
condition|)
block|{
comment|/* 				 * finish off with spaces 				 */
if|if
condition|(
name|putchar
argument_list|(
literal|' '
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
operator|++
name|ops
expr_stmt|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
block|}
else|else
block|{
comment|/* 		 * output is not contracted 		 */
if|if
condition|(
name|cnt
operator|&&
operator|(
name|fwrite
argument_list|(
name|buf
argument_list|,
sizeof|sizeof
argument_list|(
name|char
argument_list|)
argument_list|,
name|cnt
argument_list|,
name|stdout
argument_list|)
operator|<=
literal|0
operator|)
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|mor
operator|!=
literal|0
condition|)
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * process line end and double space as required 	 */
if|if
condition|(
operator|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
operator|||
operator|(
name|dspace
operator|&&
operator|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
operator|)
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * inskip():	skip over pgcnt pages with lncnt lines per page  *		file is closed at EOF (if not stdin).  *  *	inf	FILE * to read from  *	pgcnt	number of pages to skip  *	lncnt	number of lines per page  */
end_comment

begin_function
name|int
name|inskip
parameter_list|(
name|FILE
modifier|*
name|inf
parameter_list|,
name|int
name|pgcnt
parameter_list|,
name|int
name|lncnt
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|cnt
decl_stmt|;
while|while
condition|(
operator|--
name|pgcnt
operator|>
literal|0
condition|)
block|{
name|cnt
operator|=
name|lncnt
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|inf
argument_list|)
operator|)
operator|!=
name|EOF
condition|)
block|{
if|if
condition|(
operator|(
name|c
operator|==
literal|'\n'
operator|)
operator|&&
operator|(
operator|--
name|cnt
operator|==
literal|0
operator|)
condition|)
break|break;
block|}
if|if
condition|(
name|c
operator|==
name|EOF
condition|)
block|{
if|if
condition|(
name|inf
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * nxtfile:	returns a FILE * to next file in arg list and sets the  *		time field for this file (or current date).  *  *	buf	array to store proper date for the header.  *	dt	if set skips the date processing (used with -m)  */
end_comment

begin_function
name|FILE
modifier|*
name|nxtfile
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|,
specifier|const
name|char
modifier|*
modifier|*
name|fname
parameter_list|,
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|dt
parameter_list|)
block|{
name|FILE
modifier|*
name|inf
init|=
name|NULL
decl_stmt|;
name|time_t
name|tv_sec
decl_stmt|;
name|struct
name|tm
modifier|*
name|timeptr
init|=
name|NULL
decl_stmt|;
name|struct
name|stat
name|statbuf
decl_stmt|;
specifier|static
name|int
name|twice
init|=
operator|-
literal|1
decl_stmt|;
operator|++
name|twice
expr_stmt|;
if|if
condition|(
name|eoptind
operator|>=
name|argc
condition|)
block|{
comment|/* 		 * no file listed; default, use standard input 		 */
if|if
condition|(
name|twice
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|inf
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
operator|*
name|fname
operator|=
name|header
expr_stmt|;
else|else
operator|*
name|fname
operator|=
name|fnamedefault
expr_stmt|;
if|if
condition|(
name|nohead
condition|)
return|return
operator|(
name|inf
operator|)
return|;
if|if
condition|(
operator|(
name|tv_sec
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
name|errcnt
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: cannot get time of day, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|eoptind
operator|=
name|argc
operator|-
literal|1
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|timeptr
operator|=
name|localtime
argument_list|(
operator|&
name|tv_sec
argument_list|)
expr_stmt|;
block|}
for|for
control|(
init|;
name|eoptind
operator|<
name|argc
condition|;
operator|++
name|eoptind
control|)
block|{
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|eoptind
index|]
argument_list|,
literal|"-"
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* 			 * process a "-" for filename 			 */
name|clearerr
argument_list|(
name|stdin
argument_list|)
expr_stmt|;
name|inf
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
operator|*
name|fname
operator|=
name|header
expr_stmt|;
else|else
operator|*
name|fname
operator|=
name|fnamedefault
expr_stmt|;
operator|++
name|eoptind
expr_stmt|;
if|if
condition|(
name|nohead
operator|||
operator|(
name|dt
operator|&&
name|twice
operator|)
condition|)
return|return
operator|(
name|inf
operator|)
return|;
if|if
condition|(
operator|(
name|tv_sec
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
name|errcnt
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: cannot get time of day, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|timeptr
operator|=
name|localtime
argument_list|(
operator|&
name|tv_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* 			 * normal file processing 			 */
if|if
condition|(
operator|(
name|inf
operator|=
name|fopen
argument_list|(
name|argv
index|[
name|eoptind
index|]
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
operator|++
name|errcnt
expr_stmt|;
if|if
condition|(
name|nodiag
condition|)
continue|continue;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: cannot open %s, %s\n"
argument_list|,
name|argv
index|[
name|eoptind
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
name|header
operator|!=
name|NULL
condition|)
operator|*
name|fname
operator|=
name|header
expr_stmt|;
elseif|else
if|if
condition|(
name|dt
condition|)
operator|*
name|fname
operator|=
name|fnamedefault
expr_stmt|;
else|else
operator|*
name|fname
operator|=
name|argv
index|[
name|eoptind
index|]
expr_stmt|;
operator|++
name|eoptind
expr_stmt|;
if|if
condition|(
name|nohead
operator|||
operator|(
name|dt
operator|&&
name|twice
operator|)
condition|)
return|return
operator|(
name|inf
operator|)
return|;
if|if
condition|(
name|dt
condition|)
block|{
if|if
condition|(
operator|(
name|tv_sec
operator|=
name|time
argument_list|(
name|NULL
argument_list|)
operator|)
operator|==
operator|-
literal|1
condition|)
block|{
operator|++
name|errcnt
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: cannot get time of day, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|timeptr
operator|=
name|localtime
argument_list|(
operator|&
name|tv_sec
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|fstat
argument_list|(
name|fileno
argument_list|(
name|inf
argument_list|)
argument_list|,
operator|&
name|statbuf
argument_list|)
operator|<
literal|0
condition|)
block|{
operator|++
name|errcnt
expr_stmt|;
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: cannot stat %s, %s\n"
argument_list|,
name|argv
index|[
name|eoptind
index|]
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
name|timeptr
operator|=
name|localtime
argument_list|(
operator|&
operator|(
name|statbuf
operator|.
name|st_mtime
operator|)
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
block|}
if|if
condition|(
name|inf
operator|==
name|NULL
condition|)
return|return
operator|(
name|NULL
operator|)
return|;
comment|/* 	 * set up time field used in header 	 */
if|if
condition|(
name|strftime
argument_list|(
name|buf
argument_list|,
name|HDBUF
argument_list|,
name|timefrmt
argument_list|,
name|timeptr
argument_list|)
operator|<=
literal|0
condition|)
block|{
operator|++
name|errcnt
expr_stmt|;
if|if
condition|(
name|inf
operator|!=
name|stdin
condition|)
operator|(
name|void
operator|)
name|fclose
argument_list|(
name|inf
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: time conversion failed\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
name|NULL
operator|)
return|;
block|}
return|return
operator|(
name|inf
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * addnum():	adds the line number to the column  *		Truncates from the front or pads with spaces as required.  *		Numbers are right justified.  *  *	buf	buffer to store the number  *	wdth	width of buffer to fill  *	line	line number  *  *		NOTE: numbers occupy part of the column. The posix  *		spec does not specify if -i processing should or should not  *		occur on number padding. The spec does say it occupies  *		part of the column. The usage of addnum	currently treats  *		numbers as part of the column so spaces may be replaced.  */
end_comment

begin_function
name|void
name|addnum
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
name|int
name|wdth
parameter_list|,
name|int
name|line
parameter_list|)
block|{
name|char
modifier|*
name|pt
init|=
name|buf
operator|+
name|wdth
decl_stmt|;
do|do
block|{
operator|*
operator|--
name|pt
operator|=
name|digs
index|[
name|line
operator|%
literal|10
index|]
expr_stmt|;
name|line
operator|/=
literal|10
expr_stmt|;
block|}
do|while
condition|(
name|line
operator|&&
operator|(
name|pt
operator|>
name|buf
operator|)
condition|)
do|;
comment|/* 	 * pad with space as required 	 */
while|while
condition|(
name|pt
operator|>
name|buf
condition|)
operator|*
operator|--
name|pt
operator|=
literal|' '
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * prhead():	prints the top of page header  *  *	buf	buffer with time field (and offset)  *	cnt	number of chars in buf  *	fname	fname field for header  *	pagcnt	page number  */
end_comment

begin_function
name|int
name|prhead
parameter_list|(
name|char
modifier|*
name|buf
parameter_list|,
specifier|const
name|char
modifier|*
name|fname
parameter_list|,
name|int
name|pagcnt
parameter_list|)
block|{
name|int
name|ips
init|=
literal|0
decl_stmt|;
name|int
name|ops
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
operator|||
operator|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 	 * posix is not clear if the header is subject to line length 	 * restrictions. The specification for header line format 	 * in the spec clearly does not limit length. No pr currently 	 * restricts header length. However if we need to truncate in 	 * a reasonable way, adjust the length of the printf by 	 * changing HDFMT to allow a length max as an argument to printf. 	 * buf (which contains the offset spaces and time field could 	 * also be trimmed 	 * 	 * note only the offset (if any) is processed for tab expansion 	 */
if|if
condition|(
name|offst
operator|&&
name|otln
argument_list|(
name|buf
argument_list|,
name|offst
argument_list|,
operator|&
name|ips
argument_list|,
operator|&
name|ops
argument_list|,
operator|-
literal|1
argument_list|)
condition|)
return|return
operator|(
literal|1
operator|)
return|;
operator|(
name|void
operator|)
name|printf
argument_list|(
name|HDFMT
argument_list|,
name|buf
operator|+
name|offst
argument_list|,
name|fname
argument_list|,
name|pagcnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * prtail():	pad page with empty lines (if required) and print page trailer  *		if requested  *  *	cnt	number of lines of padding needed  *	incomp	was a '\n' missing from last line output  */
end_comment

begin_function
name|int
name|prtail
parameter_list|(
name|int
name|cnt
parameter_list|,
name|int
name|incomp
parameter_list|)
block|{
if|if
condition|(
name|nohead
condition|)
block|{
comment|/* 		 * only pad with no headers when incomplete last line 		 */
if|if
condition|(
name|incomp
operator|&&
operator|(
operator|(
name|dspace
operator|&&
operator|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
operator|)
operator|||
operator|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
operator|)
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
comment|/* 		 * but honor the formfeed request 		 */
if|if
condition|(
name|formfeed
condition|)
block|{
if|if
condition|(
name|putchar
argument_list|(
literal|'\f'
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
comment|/* 	 * if double space output two \n 	 */
if|if
condition|(
name|dspace
condition|)
name|cnt
operator|*=
literal|2
expr_stmt|;
comment|/* 	 * if an odd number of lines per page, add an extra \n 	 */
if|if
condition|(
name|addone
condition|)
operator|++
name|cnt
expr_stmt|;
comment|/* 	 * pad page 	 */
if|if
condition|(
name|formfeed
condition|)
block|{
if|if
condition|(
operator|(
name|incomp
operator|&&
operator|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
operator|)
operator|)
operator|||
operator|(
name|putchar
argument_list|(
literal|'\f'
argument_list|)
operator|==
name|EOF
operator|)
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
name|cnt
operator|+=
name|TAILLEN
expr_stmt|;
while|while
condition|(
operator|--
name|cnt
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
name|putchar
argument_list|(
literal|'\n'
argument_list|)
operator|==
name|EOF
condition|)
block|{
name|pfail
argument_list|()
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * terminate():	when a SIGINT is recvd  */
end_comment

begin_function
name|void
name|terminate
parameter_list|(
name|int
name|which_sig
name|__unused
parameter_list|)
block|{
name|flsh_errs
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * flsh_errs():	output saved up diagnostic messages after all normal  *		processing has completed  */
end_comment

begin_function
name|void
name|flsh_errs
parameter_list|(
name|void
parameter_list|)
block|{
name|char
name|buf
index|[
name|BUFSIZ
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fflush
argument_list|(
name|err
argument_list|)
expr_stmt|;
if|if
condition|(
name|err
operator|==
name|stderr
condition|)
return|return;
name|rewind
argument_list|(
name|err
argument_list|)
expr_stmt|;
while|while
condition|(
name|fgets
argument_list|(
name|buf
argument_list|,
name|BUFSIZ
argument_list|,
name|err
argument_list|)
operator|!=
name|NULL
condition|)
operator|(
name|void
operator|)
name|fputs
argument_list|(
name|buf
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|mfail
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: memory allocation failed\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|pfail
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: write failure, %s\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|(
name|void
parameter_list|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"usage: pr [+page] [-col] [-adFfmprt] [-e[ch][gap]] [-h header]\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"          [-i[ch][gap]] [-l line] [-n[ch][width]] [-o offset]\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"          [-L locale] [-s[ch]] [-w width] [-] [file ...]\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/*  * setup:	Validate command args, initialize and perform sanity  *		checks on options  */
end_comment

begin_function
name|int
name|setup
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
name|argv
index|[]
parameter_list|)
block|{
name|int
name|c
decl_stmt|;
name|int
name|d_first
decl_stmt|;
name|int
name|eflag
init|=
literal|0
decl_stmt|;
name|int
name|iflag
init|=
literal|0
decl_stmt|;
name|int
name|wflag
init|=
literal|0
decl_stmt|;
name|int
name|cflag
init|=
literal|0
decl_stmt|;
name|char
modifier|*
name|Lflag
init|=
name|NULL
decl_stmt|;
if|if
condition|(
name|isatty
argument_list|(
name|fileno
argument_list|(
name|stdout
argument_list|)
argument_list|)
condition|)
block|{
comment|/* 		 * defer diagnostics until processing is done 		 */
if|if
condition|(
operator|(
name|err
operator|=
name|tmpfile
argument_list|()
operator|)
operator|==
name|NULL
condition|)
block|{
name|err
operator|=
name|stderr
expr_stmt|;
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"Cannot defer diagnostic messages\n"
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
else|else
name|err
operator|=
name|stderr
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|egetopt
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|,
literal|"#adFfmrte?h:i?L:l:n?o:ps?w:"
argument_list|)
operator|)
operator|!=
operator|-
literal|1
condition|)
block|{
switch|switch
condition|(
name|c
condition|)
block|{
case|case
literal|'+'
case|:
if|if
condition|(
operator|(
name|pgnm
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: +page number must be 1 or more\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'-'
case|:
if|if
condition|(
operator|(
name|clcnt
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -columns must be 1 or more\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|clcnt
operator|>
literal|1
condition|)
operator|++
name|cflag
expr_stmt|;
break|break;
case|case
literal|'a'
case|:
operator|++
name|across
expr_stmt|;
break|break;
case|case
literal|'d'
case|:
operator|++
name|dspace
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
operator|++
name|eflag
expr_stmt|;
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
condition|)
name|inchar
operator|=
operator|*
name|eoptarg
operator|++
expr_stmt|;
else|else
name|inchar
operator|=
name|INCHAR
expr_stmt|;
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ingap
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -e gap must be 0 or more\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ingap
operator|==
literal|0
condition|)
name|ingap
operator|=
name|INGAP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|eoptarg
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: invalid value for -e %s\n"
argument_list|,
name|eoptarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|ingap
operator|=
name|INGAP
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
operator|++
name|pausefst
expr_stmt|;
comment|/*FALLTHROUGH*/
case|case
literal|'F'
case|:
operator|++
name|formfeed
expr_stmt|;
break|break;
case|case
literal|'h'
case|:
name|header
operator|=
name|eoptarg
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
operator|++
name|iflag
expr_stmt|;
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
condition|)
name|ochar
operator|=
operator|*
name|eoptarg
operator|++
expr_stmt|;
else|else
name|ochar
operator|=
name|OCHAR
expr_stmt|;
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|ogap
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|0
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -i gap must be 0 or more\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|ogap
operator|==
literal|0
condition|)
name|ogap
operator|=
name|OGAP
expr_stmt|;
block|}
elseif|else
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|eoptarg
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: invalid value for -i %s\n"
argument_list|,
name|eoptarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|ogap
operator|=
name|OGAP
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|Lflag
operator|=
name|eoptarg
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
operator|||
operator|(
operator|(
name|lines
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: number of lines must be 1 or more\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'m'
case|:
operator|++
name|merge
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
condition|)
name|nmchar
operator|=
operator|*
name|eoptarg
operator|++
expr_stmt|;
else|else
name|nmchar
operator|=
name|NMCHAR
expr_stmt|;
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
condition|)
block|{
if|if
condition|(
operator|(
name|nmwd
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -n width must be 1 or more\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
elseif|else
if|if
condition|(
operator|(
name|eoptarg
operator|!=
name|NULL
operator|)
operator|&&
operator|(
operator|*
name|eoptarg
operator|!=
literal|'\0'
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: invalid value for -n %s\n"
argument_list|,
name|eoptarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
else|else
name|nmwd
operator|=
name|NMWD
expr_stmt|;
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
operator|||
operator|(
operator|(
name|offst
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -o offset must be 1 or more\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'p'
case|:
operator|++
name|pauseall
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
operator|++
name|nodiag
expr_stmt|;
break|break;
case|case
literal|'s'
case|:
operator|++
name|sflag
expr_stmt|;
if|if
condition|(
name|eoptarg
operator|==
name|NULL
condition|)
name|schar
operator|=
name|SCHAR
expr_stmt|;
else|else
block|{
name|schar
operator|=
operator|*
name|eoptarg
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|eoptarg
operator|!=
literal|'\0'
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: invalid value for -s %s\n"
argument_list|,
name|eoptarg
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
break|break;
case|case
literal|'t'
case|:
operator|++
name|nohead
expr_stmt|;
break|break;
case|case
literal|'w'
case|:
operator|++
name|wflag
expr_stmt|;
if|if
condition|(
operator|(
name|eoptarg
operator|==
name|NULL
operator|)
operator|||
operator|!
name|isdigit
argument_list|(
operator|(
name|unsigned
name|char
operator|)
operator|*
name|eoptarg
argument_list|)
operator|||
operator|(
operator|(
name|pgwd
operator|=
name|atoi
argument_list|(
name|eoptarg
argument_list|)
operator|)
operator|<
literal|1
operator|)
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -w width must be 1 or more \n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
break|break;
case|case
literal|'?'
case|:
default|default:
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
comment|/* 	 * default and sanity checks 	 */
if|if
condition|(
operator|!
name|clcnt
condition|)
block|{
if|if
condition|(
name|merge
condition|)
block|{
if|if
condition|(
operator|(
name|clcnt
operator|=
name|argc
operator|-
name|eoptind
operator|)
operator|<=
literal|1
condition|)
block|{
name|clcnt
operator|=
name|CLCNT
expr_stmt|;
name|merge
operator|=
literal|0
expr_stmt|;
block|}
block|}
else|else
name|clcnt
operator|=
name|CLCNT
expr_stmt|;
block|}
if|if
condition|(
name|across
condition|)
block|{
if|if
condition|(
name|clcnt
operator|==
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -a flag requires multiple columns\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|merge
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -m cannot be used with -a\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|wflag
condition|)
block|{
if|if
condition|(
name|sflag
condition|)
name|pgwd
operator|=
name|SPGWD
expr_stmt|;
else|else
name|pgwd
operator|=
name|PGWD
expr_stmt|;
block|}
if|if
condition|(
name|cflag
operator|||
name|merge
condition|)
block|{
if|if
condition|(
operator|!
name|eflag
condition|)
block|{
name|inchar
operator|=
name|INCHAR
expr_stmt|;
name|ingap
operator|=
name|INGAP
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|iflag
condition|)
block|{
name|ochar
operator|=
name|OCHAR
expr_stmt|;
name|ogap
operator|=
name|OGAP
expr_stmt|;
block|}
block|}
if|if
condition|(
name|cflag
condition|)
block|{
if|if
condition|(
name|merge
condition|)
block|{
operator|(
name|void
operator|)
name|fputs
argument_list|(
literal|"pr: -m cannot be used with multiple columns\n"
argument_list|,
name|err
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
if|if
condition|(
name|nmwd
condition|)
block|{
name|colwd
operator|=
operator|(
name|pgwd
operator|+
literal|1
operator|-
operator|(
name|clcnt
operator|*
operator|(
name|nmwd
operator|+
literal|2
operator|)
operator|)
operator|)
operator|/
name|clcnt
expr_stmt|;
name|pgwd
operator|=
operator|(
operator|(
name|colwd
operator|+
name|nmwd
operator|+
literal|2
operator|)
operator|*
name|clcnt
operator|)
operator|-
literal|1
expr_stmt|;
block|}
else|else
block|{
name|colwd
operator|=
operator|(
name|pgwd
operator|+
literal|1
operator|-
name|clcnt
operator|)
operator|/
name|clcnt
expr_stmt|;
name|pgwd
operator|=
operator|(
operator|(
name|colwd
operator|+
literal|1
operator|)
operator|*
name|clcnt
operator|)
operator|-
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|colwd
operator|<
literal|1
condition|)
block|{
operator|(
name|void
operator|)
name|fprintf
argument_list|(
name|err
argument_list|,
literal|"pr: page width is too small for %d columns\n"
argument_list|,
name|clcnt
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
block|}
block|}
if|if
condition|(
operator|!
name|lines
condition|)
name|lines
operator|=
name|LINES
expr_stmt|;
comment|/* 	 * make sure long enough for headers. if not disable 	 */
if|if
condition|(
name|lines
operator|<=
name|HEADLEN
operator|+
name|TAILLEN
condition|)
operator|++
name|nohead
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|nohead
condition|)
name|lines
operator|-=
name|HEADLEN
operator|+
name|TAILLEN
expr_stmt|;
comment|/* 	 * adjust for double space on odd length pages 	 */
if|if
condition|(
name|dspace
condition|)
block|{
if|if
condition|(
name|lines
operator|==
literal|1
condition|)
name|dspace
operator|=
literal|0
expr_stmt|;
else|else
block|{
if|if
condition|(
name|lines
operator|&
literal|1
condition|)
operator|++
name|addone
expr_stmt|;
name|lines
operator|/=
literal|2
expr_stmt|;
block|}
block|}
operator|(
name|void
operator|)
name|setlocale
argument_list|(
name|LC_TIME
argument_list|,
operator|(
name|Lflag
operator|!=
name|NULL
operator|)
condition|?
name|Lflag
else|:
literal|""
argument_list|)
expr_stmt|;
name|d_first
operator|=
operator|(
operator|*
name|nl_langinfo
argument_list|(
name|D_MD_ORDER
argument_list|)
operator|==
literal|'d'
operator|)
expr_stmt|;
name|timefrmt
operator|=
name|strdup
argument_list|(
name|d_first
condition|?
name|TIMEFMTD
else|:
name|TIMEFMTM
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

