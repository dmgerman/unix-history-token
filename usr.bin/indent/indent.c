begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Sun Microsystems, Inc.  * Copyright (c) 1976 Board of Trustees of the University of Illinois.  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1985 Sun Microsystems, Inc.\n\ @(#) Copyright (c) 1976 Board of Trustees of the University of Illinois.\n\ @(#) Copyright (c) 1980, 1993\n\ 	The Regents of the University of California.  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_if
if|#
directive|if
literal|0
end_if

begin_endif
unit|static char sccsid[] = "@(#)indent.c	5.17 (Berkeley) 6/7/93";
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<sys/param.h>
end_include

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<fcntl.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_include
include|#
directive|include
file|"indent_codes.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_function_decl
specifier|static
name|void
name|bakcopy
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_decl_stmt
name|char
modifier|*
name|in_name
init|=
literal|"Standard Input"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will always point to name of input 					 * file */
end_comment

begin_decl_stmt
name|char
modifier|*
name|out_name
init|=
literal|"Standard Output"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* will always point to name 						 * of output file */
end_comment

begin_decl_stmt
name|char
name|bakfile
index|[
name|MAXPATHLEN
index|]
init|=
literal|""
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|int
name|argc
parameter_list|,
name|char
modifier|*
modifier|*
name|argv
parameter_list|)
block|{
specifier|extern
name|int
name|found_err
decl_stmt|;
comment|/* flag set in diagN() on error */
name|int
name|dec_ind
decl_stmt|;
comment|/* current indentation for declarations */
name|int
name|di_stack
index|[
literal|20
index|]
decl_stmt|;
comment|/* a stack of structure indentation levels */
name|int
name|flushed_nl
decl_stmt|;
comment|/* used when buffering up comments to remember 				 * that a newline was passed over */
name|int
name|force_nl
decl_stmt|;
comment|/* when true, code must be broken */
name|int
name|hd_type
init|=
literal|0
decl_stmt|;
comment|/* used to store type of stmt for if (...), 				 * for (...), etc */
specifier|register
name|int
name|i
decl_stmt|;
comment|/* local loop counter */
name|int
name|scase
decl_stmt|;
comment|/* set to true when we see a case, so we will 				 * know what to do with the following colon */
name|int
name|sp_sw
decl_stmt|;
comment|/* when true, we are in the expressin of 				 * if(...), while(...), etc. */
name|int
name|squest
decl_stmt|;
comment|/* when this is positive, we have seen a ? 				 * without the matching : in a<c>?<s>:<s> 				 * construct */
specifier|register
name|char
modifier|*
name|t_ptr
decl_stmt|;
comment|/* used for copying tokens */
name|int
name|type_code
decl_stmt|;
comment|/* the type of token, returned by lexi */
name|int
name|last_else
init|=
literal|0
decl_stmt|;
comment|/* true iff last keyword was an else */
comment|/*-----------------------------------------------*\     |		      INITIALIZATION		      |     \*-----------------------------------------------*/
name|ps
operator|.
name|p_stack
index|[
literal|0
index|]
operator|=
name|stmt
expr_stmt|;
comment|/* this is the parser's stack */
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* this is true if the last thing scanned was 				 * a newline */
name|ps
operator|.
name|last_token
operator|=
name|semicolon
expr_stmt|;
name|combuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|labbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|codebuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|tokenbuf
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|bufsize
argument_list|)
expr_stmt|;
name|l_com
operator|=
name|combuf
operator|+
name|bufsize
operator|-
literal|5
expr_stmt|;
name|l_lab
operator|=
name|labbuf
operator|+
name|bufsize
operator|-
literal|5
expr_stmt|;
name|l_code
operator|=
name|codebuf
operator|+
name|bufsize
operator|-
literal|5
expr_stmt|;
name|l_token
operator|=
name|tokenbuf
operator|+
name|bufsize
operator|-
literal|5
expr_stmt|;
name|combuf
index|[
literal|0
index|]
operator|=
name|codebuf
index|[
literal|0
index|]
operator|=
name|labbuf
index|[
literal|0
index|]
operator|=
literal|' '
expr_stmt|;
comment|/* set up code, label, and 						 * comment buffers */
name|combuf
index|[
literal|1
index|]
operator|=
name|codebuf
index|[
literal|1
index|]
operator|=
name|labbuf
index|[
literal|1
index|]
operator|=
literal|'\0'
expr_stmt|;
name|ps
operator|.
name|else_if
operator|=
literal|1
expr_stmt|;
comment|/* Default else-if special processing to on */
name|s_lab
operator|=
name|e_lab
operator|=
name|labbuf
operator|+
literal|1
expr_stmt|;
name|s_code
operator|=
name|e_code
operator|=
name|codebuf
operator|+
literal|1
expr_stmt|;
name|s_com
operator|=
name|e_com
operator|=
name|combuf
operator|+
literal|1
expr_stmt|;
name|s_token
operator|=
name|e_token
operator|=
name|tokenbuf
operator|+
literal|1
expr_stmt|;
name|in_buffer
operator|=
operator|(
name|char
operator|*
operator|)
name|malloc
argument_list|(
literal|10
argument_list|)
expr_stmt|;
name|in_buffer_limit
operator|=
name|in_buffer
operator|+
literal|8
expr_stmt|;
name|buf_ptr
operator|=
name|buf_end
operator|=
name|in_buffer
expr_stmt|;
name|line_no
operator|=
literal|1
expr_stmt|;
name|had_eof
operator|=
name|ps
operator|.
name|in_decl
operator|=
name|ps
operator|.
name|decl_on_line
operator|=
name|break_comma
operator|=
name|false
expr_stmt|;
name|sp_sw
operator|=
name|force_nl
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|in_or_st
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|bl_line
operator|=
name|true
expr_stmt|;
name|dec_ind
operator|=
literal|0
expr_stmt|;
name|di_stack
index|[
name|ps
operator|.
name|dec_nest
operator|=
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|ps
operator|.
name|in_stmt
operator|=
name|ps
operator|.
name|ind_stmt
operator|=
name|false
expr_stmt|;
name|scase
operator|=
name|ps
operator|.
name|pcase
operator|=
name|false
expr_stmt|;
name|squest
operator|=
literal|0
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
name|bp_save
operator|=
literal|0
expr_stmt|;
name|be_save
operator|=
literal|0
expr_stmt|;
name|output
operator|=
literal|0
expr_stmt|;
comment|/*--------------------------------------------------*\     |   		COMMAND LINE SCAN		 |     \*--------------------------------------------------*/
ifdef|#
directive|ifdef
name|undef
name|max_col
operator|=
literal|78
expr_stmt|;
comment|/* -l78 */
name|lineup_to_parens
operator|=
literal|1
expr_stmt|;
comment|/* -lp */
name|ps
operator|.
name|ljust_decl
operator|=
literal|0
expr_stmt|;
comment|/* -ndj */
name|ps
operator|.
name|com_ind
operator|=
literal|33
expr_stmt|;
comment|/* -c33 */
name|star_comment_cont
operator|=
literal|1
expr_stmt|;
comment|/* -sc */
name|ps
operator|.
name|ind_size
operator|=
literal|8
expr_stmt|;
comment|/* -i8 */
name|verbose
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|decl_indent
operator|=
literal|16
expr_stmt|;
comment|/* -di16 */
name|ps
operator|.
name|indent_parameters
operator|=
literal|1
expr_stmt|;
comment|/* -ip */
name|ps
operator|.
name|decl_com_ind
operator|=
literal|0
expr_stmt|;
comment|/* if this is not set to some positive value 				 * by an arg, we will set this equal to 				 * ps.com_ind */
name|btype_2
operator|=
literal|1
expr_stmt|;
comment|/* -br */
name|cuddle_else
operator|=
literal|1
expr_stmt|;
comment|/* -ce */
name|ps
operator|.
name|unindent_displace
operator|=
literal|0
expr_stmt|;
comment|/* -d0 */
name|ps
operator|.
name|case_indent
operator|=
literal|0
expr_stmt|;
comment|/* -cli0 */
name|format_block_comments
operator|=
literal|1
expr_stmt|;
comment|/* -fcb */
name|format_col1_comments
operator|=
literal|1
expr_stmt|;
comment|/* -fc1 */
name|procnames_start_line
operator|=
literal|1
expr_stmt|;
comment|/* -psl */
name|proc_calls_space
operator|=
literal|0
expr_stmt|;
comment|/* -npcs */
name|comment_delimiter_on_blankline
operator|=
literal|1
expr_stmt|;
comment|/* -cdb */
name|ps
operator|.
name|leave_comma
operator|=
literal|1
expr_stmt|;
comment|/* -nbc */
endif|#
directive|endif
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|strcmp
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|,
literal|"-npro"
argument_list|)
operator|==
literal|0
condition|)
break|break;
name|set_defaults
argument_list|()
expr_stmt|;
if|if
condition|(
name|i
operator|>=
name|argc
condition|)
name|set_profile
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|argc
condition|;
operator|++
name|i
control|)
block|{
comment|/* 	 * look thru args (if any) for changes to defaults 	 */
if|if
condition|(
name|argv
index|[
name|i
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
condition|)
block|{
comment|/* no flag on parameter */
if|if
condition|(
name|input
operator|==
literal|0
condition|)
block|{
comment|/* we must have the input file */
name|in_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* remember name of input file */
name|input
operator|=
name|fopen
argument_list|(
name|in_name
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|0
condition|)
comment|/* check for open error */
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|in_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
elseif|else
if|if
condition|(
name|output
operator|==
literal|0
condition|)
block|{
comment|/* we have the output file */
name|out_name
operator|=
name|argv
index|[
name|i
index|]
expr_stmt|;
comment|/* remember name of output file */
if|if
condition|(
name|strcmp
argument_list|(
name|in_name
argument_list|,
name|out_name
argument_list|)
operator|==
literal|0
condition|)
block|{
comment|/* attempt to overwrite 							 * the file */
name|errx
argument_list|(
literal|1
argument_list|,
literal|"input and output files must be different"
argument_list|)
expr_stmt|;
block|}
name|output
operator|=
name|fopen
argument_list|(
name|out_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
literal|0
condition|)
comment|/* check for create error */
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|out_name
argument_list|)
expr_stmt|;
continue|continue;
block|}
name|errx
argument_list|(
literal|1
argument_list|,
literal|"unknown parameter: %s"
argument_list|,
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
else|else
name|set_option
argument_list|(
name|argv
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* end of for */
if|if
condition|(
name|input
operator|==
literal|0
condition|)
name|input
operator|=
name|stdin
expr_stmt|;
if|if
condition|(
name|output
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|troff
operator|||
name|input
operator|==
name|stdin
condition|)
name|output
operator|=
name|stdout
expr_stmt|;
else|else
block|{
name|out_name
operator|=
name|in_name
expr_stmt|;
name|bakcopy
argument_list|()
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ps
operator|.
name|com_ind
operator|<=
literal|1
condition|)
name|ps
operator|.
name|com_ind
operator|=
literal|2
expr_stmt|;
comment|/* dont put normal comments before column 2 */
if|if
condition|(
name|troff
condition|)
block|{
if|if
condition|(
name|bodyf
operator|.
name|font
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|parsefont
argument_list|(
operator|&
name|bodyf
argument_list|,
literal|"R"
argument_list|)
expr_stmt|;
if|if
condition|(
name|scomf
operator|.
name|font
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|parsefont
argument_list|(
operator|&
name|scomf
argument_list|,
literal|"I"
argument_list|)
expr_stmt|;
if|if
condition|(
name|blkcomf
operator|.
name|font
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|blkcomf
operator|=
name|scomf
operator|,
name|blkcomf
operator|.
name|size
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|boxcomf
operator|.
name|font
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|boxcomf
operator|=
name|blkcomf
expr_stmt|;
if|if
condition|(
name|stringf
operator|.
name|font
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|parsefont
argument_list|(
operator|&
name|stringf
argument_list|,
literal|"L"
argument_list|)
expr_stmt|;
if|if
condition|(
name|keywordf
operator|.
name|font
index|[
literal|0
index|]
operator|==
literal|0
condition|)
name|parsefont
argument_list|(
operator|&
name|keywordf
argument_list|,
literal|"B"
argument_list|)
expr_stmt|;
name|writefdef
argument_list|(
operator|&
name|bodyf
argument_list|,
literal|'B'
argument_list|)
expr_stmt|;
name|writefdef
argument_list|(
operator|&
name|scomf
argument_list|,
literal|'C'
argument_list|)
expr_stmt|;
name|writefdef
argument_list|(
operator|&
name|blkcomf
argument_list|,
literal|'L'
argument_list|)
expr_stmt|;
name|writefdef
argument_list|(
operator|&
name|boxcomf
argument_list|,
literal|'X'
argument_list|)
expr_stmt|;
name|writefdef
argument_list|(
operator|&
name|stringf
argument_list|,
literal|'S'
argument_list|)
expr_stmt|;
name|writefdef
argument_list|(
operator|&
name|keywordf
argument_list|,
literal|'K'
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|block_comment_max_col
operator|<=
literal|0
condition|)
name|block_comment_max_col
operator|=
name|max_col
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|decl_com_ind
operator|<=
literal|0
condition|)
comment|/* if not specified by user, set this */
name|ps
operator|.
name|decl_com_ind
operator|=
name|ps
operator|.
name|ljust_decl
condition|?
operator|(
name|ps
operator|.
name|com_ind
operator|<=
literal|10
condition|?
literal|2
else|:
name|ps
operator|.
name|com_ind
operator|-
literal|8
operator|)
else|:
name|ps
operator|.
name|com_ind
expr_stmt|;
if|if
condition|(
name|continuation_indent
operator|==
literal|0
condition|)
name|continuation_indent
operator|=
name|ps
operator|.
name|ind_size
expr_stmt|;
name|fill_buffer
argument_list|()
expr_stmt|;
comment|/* get first batch of stuff into input buffer */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|buf_ptr
decl_stmt|;
specifier|register
name|int
name|col
init|=
literal|1
decl_stmt|;
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|p
operator|==
literal|' '
condition|)
name|col
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|p
operator|==
literal|'\t'
condition|)
name|col
operator|=
operator|(
operator|(
name|col
operator|-
literal|1
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
literal|9
expr_stmt|;
else|else
break|break;
name|p
operator|++
expr_stmt|;
block|}
if|if
condition|(
name|col
operator|>
name|ps
operator|.
name|ind_size
condition|)
name|ps
operator|.
name|ind_level
operator|=
name|ps
operator|.
name|i_l_follow
operator|=
name|col
operator|/
name|ps
operator|.
name|ind_size
expr_stmt|;
block|}
if|if
condition|(
name|troff
condition|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|in_name
decl_stmt|,
modifier|*
name|beg
init|=
name|in_name
decl_stmt|;
while|while
condition|(
operator|*
name|p
condition|)
if|if
condition|(
operator|*
name|p
operator|++
operator|==
literal|'/'
condition|)
name|beg
operator|=
name|p
expr_stmt|;
name|fprintf
argument_list|(
name|output
argument_list|,
literal|".Fn \"%s\"\n"
argument_list|,
name|beg
argument_list|)
expr_stmt|;
block|}
comment|/*      * START OF MAIN LOOP      */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* this is the main loop.  it will go until we 				 * reach eof */
name|int
name|is_procname
decl_stmt|;
name|type_code
operator|=
name|lexi
argument_list|()
expr_stmt|;
comment|/* lexi reads one token.  The actual 				 * characters read are stored in "token". lexi 				 * returns a code indicating the type of token */
name|is_procname
operator|=
name|ps
operator|.
name|procname
index|[
literal|0
index|]
expr_stmt|;
comment|/* 	 * The following code moves everything following an if (), while (), 	 * else, etc. up to the start of the following stmt to a buffer. This 	 * allows proper handling of both kinds of brace placement. 	 */
name|flushed_nl
operator|=
name|false
expr_stmt|;
while|while
condition|(
name|ps
operator|.
name|search_brace
condition|)
block|{
comment|/* if we scanned an if(), while(), 					 * etc., we might need to copy stuff 					 * into a buffer we must loop, copying 					 * stuff into save_com, until we find 					 * the start of the stmt which follows 					 * the if, or whatever */
switch|switch
condition|(
name|type_code
condition|)
block|{
case|case
name|newline
case|:
operator|++
name|line_no
expr_stmt|;
name|flushed_nl
operator|=
name|true
expr_stmt|;
case|case
name|form_feed
case|:
break|break;
comment|/* form feeds and newlines found here will be 				 * ignored */
case|case
name|lbrace
case|:
comment|/* this is a brace that starts the compound 				 * stmt */
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* ignore buffering if a comment wasnt 					 * stored up */
name|ps
operator|.
name|search_brace
operator|=
name|false
expr_stmt|;
goto|goto
name|check_type
goto|;
block|}
if|if
condition|(
name|btype_2
condition|)
block|{
name|save_com
index|[
literal|0
index|]
operator|=
literal|'{'
expr_stmt|;
comment|/* we either want to put the brace 					 * right after the if */
goto|goto
name|sw_buffer
goto|;
comment|/* go to common code to get out of 					 * this loop */
block|}
case|case
name|comment
case|:
comment|/* we have a comment, so we must copy it into 				 * the buffer */
if|if
condition|(
operator|!
name|flushed_nl
operator|||
name|sc_end
operator|!=
literal|0
condition|)
block|{
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* if this is the first comment, we 					 * must set up the buffer */
name|save_com
index|[
literal|0
index|]
operator|=
name|save_com
index|[
literal|1
index|]
operator|=
literal|' '
expr_stmt|;
name|sc_end
operator|=
operator|&
operator|(
name|save_com
index|[
literal|2
index|]
operator|)
expr_stmt|;
block|}
else|else
block|{
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* add newline between 						 * comments */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
block|}
operator|*
name|sc_end
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* copy in start of comment */
operator|*
name|sc_end
operator|++
operator|=
literal|'*'
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
comment|/* loop until we get to the end of the comment */
operator|*
name|sc_end
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|sc_end
operator|++
operator|==
literal|'*'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
break|break;
comment|/* we are at end of comment */
if|if
condition|(
name|sc_end
operator|>=
operator|&
operator|(
name|save_com
index|[
name|sc_size
index|]
operator|)
condition|)
block|{
comment|/* check for temp buffer 								 * overflow */
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Internal buffer overflow - Move big comment from right after if, while, or whatever."
argument_list|)
expr_stmt|;
name|fflush
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
block|}
operator|*
name|sc_end
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* add ending slash */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* get past / in buffer */
name|fill_buffer
argument_list|()
expr_stmt|;
break|break;
block|}
default|default:
comment|/* it is the start of a normal statment */
if|if
condition|(
name|flushed_nl
condition|)
comment|/* if we flushed a newline, make sure it is 				 * put back */
name|force_nl
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|type_code
operator|==
name|sp_paren
operator|&&
operator|*
name|token
operator|==
literal|'i'
operator|&&
name|last_else
operator|&&
name|ps
operator|.
name|else_if
operator|)
operator|||
operator|(
name|type_code
operator|==
name|sp_nparen
operator|&&
operator|*
name|token
operator|==
literal|'e'
operator|&&
name|e_code
operator|!=
name|s_code
operator|&&
name|e_code
index|[
operator|-
literal|1
index|]
operator|==
literal|'}'
operator|)
condition|)
name|force_nl
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
block|{
comment|/* ignore buffering if comment wasnt 					 * saved up */
name|ps
operator|.
name|search_brace
operator|=
name|false
expr_stmt|;
goto|goto
name|check_type
goto|;
block|}
if|if
condition|(
name|force_nl
condition|)
block|{
comment|/* if we should insert a nl here, put it into 				 * the buffer */
name|force_nl
operator|=
name|false
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
comment|/* this will be re-increased when the nl is 				 * read from the buffer */
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|verbose
operator|&&
operator|!
name|flushed_nl
condition|)
comment|/* print error msg if the line 						 * was not already broken */
name|diag2
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|flushed_nl
operator|=
name|false
expr_stmt|;
block|}
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|sc_end
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* copy token into temp buffer */
name|ps
operator|.
name|procname
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|sw_buffer
label|:
name|ps
operator|.
name|search_brace
operator|=
name|false
expr_stmt|;
comment|/* stop looking for start of 						 * stmt */
name|bp_save
operator|=
name|buf_ptr
expr_stmt|;
comment|/* save current input buffer */
name|be_save
operator|=
name|buf_end
expr_stmt|;
name|buf_ptr
operator|=
name|save_com
expr_stmt|;
comment|/* fix so that subsequent calls to 					 * lexi will take tokens out of 					 * save_com */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add trailing blank, just in case */
name|buf_end
operator|=
name|sc_end
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
break|break;
block|}
comment|/* end of switch */
if|if
condition|(
name|type_code
operator|!=
literal|0
condition|)
comment|/* we must make this check, just in case there 				 * was an unexpected EOF */
name|type_code
operator|=
name|lexi
argument_list|()
expr_stmt|;
comment|/* read another token */
comment|/* if (ps.search_brace) ps.procname[0] = 0; */
if|if
condition|(
operator|(
name|is_procname
operator|=
name|ps
operator|.
name|procname
index|[
literal|0
index|]
operator|)
operator|&&
name|flushed_nl
operator|&&
operator|!
name|procnames_start_line
operator|&&
name|ps
operator|.
name|in_decl
operator|&&
name|type_code
operator|==
name|ident
condition|)
name|flushed_nl
operator|=
literal|0
expr_stmt|;
block|}
comment|/* end of while (search_brace) */
name|last_else
operator|=
literal|0
expr_stmt|;
name|check_type
label|:
if|if
condition|(
name|type_code
operator|==
literal|0
condition|)
block|{
comment|/* we got eof */
if|if
condition|(
name|s_lab
operator|!=
name|e_lab
operator|||
name|s_code
operator|!=
name|e_code
operator|||
name|s_com
operator|!=
name|e_com
condition|)
comment|/* must dump end of line */
name|dump_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|tos
operator|>
literal|1
condition|)
comment|/* check for balanced braces */
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Stuff missing from end of file."
argument_list|)
expr_stmt|;
if|if
condition|(
name|verbose
condition|)
block|{
name|printf
argument_list|(
literal|"There were %d output lines and %d comments\n"
argument_list|,
name|ps
operator|.
name|out_lines
argument_list|,
name|ps
operator|.
name|out_coms
argument_list|)
expr_stmt|;
name|printf
argument_list|(
literal|"(Lines with comments)/(Lines with code): %6.3f\n"
argument_list|,
operator|(
literal|1.0
operator|*
name|ps
operator|.
name|com_lines
operator|)
operator|/
name|code_lines
argument_list|)
expr_stmt|;
block|}
name|fflush
argument_list|(
name|output
argument_list|)
expr_stmt|;
name|exit
argument_list|(
name|found_err
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|type_code
operator|!=
name|comment
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|newline
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|preesc
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|form_feed
operator|)
condition|)
block|{
if|if
condition|(
name|force_nl
operator|&&
operator|(
name|type_code
operator|!=
name|semicolon
operator|)
operator|&&
operator|(
name|type_code
operator|!=
name|lbrace
operator|||
operator|!
name|btype_2
operator|)
condition|)
block|{
comment|/* we should force a broken line here */
if|if
condition|(
name|verbose
operator|&&
operator|!
name|flushed_nl
condition|)
name|diag2
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|flushed_nl
operator|=
name|false
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* dont insert blank at line start */
name|force_nl
operator|=
name|false
expr_stmt|;
block|}
name|ps
operator|.
name|in_stmt
operator|=
name|true
expr_stmt|;
comment|/* turn on flag which causes an extra level of 				 * indentation. this is turned off by a ; or 				 * '}' */
if|if
condition|(
name|s_com
operator|!=
name|e_com
condition|)
block|{
comment|/* the turkey has embedded a comment 					 * in a line. fix it */
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|s_com
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
block|}
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate code sect */
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
name|e_com
operator|=
name|s_com
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|type_code
operator|!=
name|comment
condition|)
comment|/* preserve force_nl thru a comment */
name|force_nl
operator|=
name|false
expr_stmt|;
comment|/* cancel forced newline after newline, form 				 * feed, etc */
comment|/*-----------------------------------------------------*\ 	|	   do switch on type of token scanned		| 	\*-----------------------------------------------------*/
name|CHECK_SIZE_CODE
expr_stmt|;
switch|switch
condition|(
name|type_code
condition|)
block|{
comment|/* now, decide what to do with the token */
case|case
name|form_feed
case|:
comment|/* found a form feed in line */
name|ps
operator|.
name|use_ff
operator|=
name|true
expr_stmt|;
comment|/* a form feed is treated much like a newline */
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|newline
case|:
if|if
condition|(
name|ps
operator|.
name|last_token
operator|!=
name|comma
operator|||
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
operator|||
operator|!
name|ps
operator|.
name|leave_comma
operator|||
name|ps
operator|.
name|block_init
operator|||
operator|!
name|break_comma
operator|||
name|s_com
operator|!=
name|e_com
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
operator|++
name|line_no
expr_stmt|;
comment|/* keep track of input line number */
break|break;
case|case
name|lparen
case|:
comment|/* got a '(' or '[' */
operator|++
name|ps
operator|.
name|p_l_follow
expr_stmt|;
comment|/* count parens to make Healy happy */
if|if
condition|(
name|ps
operator|.
name|want_blank
operator|&&
operator|*
name|token
operator|!=
literal|'['
operator|&&
operator|(
name|ps
operator|.
name|last_token
operator|!=
name|ident
operator|||
name|proc_calls_space
operator|||
operator|(
name|ps
operator|.
name|its_a_keyword
operator|&&
operator|(
operator|!
name|ps
operator|.
name|sizeof_keyword
operator|||
name|Bill_Shannon
operator|)
operator|)
operator|)
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
if|if
condition|(
name|troff
operator|&&
operator|!
name|ps
operator|.
name|dumped_decl_indent
operator|&&
operator|!
name|is_procname
operator|&&
name|ps
operator|.
name|last_token
operator|==
name|decl
condition|)
block|{
name|ps
operator|.
name|dumped_decl_indent
operator|=
literal|1
expr_stmt|;
name|sprintf
argument_list|(
name|e_code
argument_list|,
literal|"\n.Du %dp+\200p \"%s\"\n"
argument_list|,
name|dec_ind
operator|*
literal|7
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|e_code
operator|+=
name|strlen
argument_list|(
name|e_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
name|dec_ind
condition|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
block|}
else|else
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
name|ps
operator|.
name|paren_indents
index|[
name|ps
operator|.
name|p_l_follow
operator|-
literal|1
index|]
operator|=
name|e_code
operator|-
name|s_code
expr_stmt|;
if|if
condition|(
name|sp_sw
operator|&&
name|ps
operator|.
name|p_l_follow
operator|==
literal|1
operator|&&
name|extra_expression_indent
operator|&&
name|ps
operator|.
name|paren_indents
index|[
literal|0
index|]
operator|<
literal|2
operator|*
name|ps
operator|.
name|ind_size
condition|)
name|ps
operator|.
name|paren_indents
index|[
literal|0
index|]
operator|=
literal|2
operator|*
name|ps
operator|.
name|ind_size
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_or_st
operator|&&
operator|*
name|token
operator|==
literal|'('
operator|&&
name|ps
operator|.
name|tos
operator|<=
literal|2
condition|)
block|{
comment|/* 		 * this is a kluge to make sure that declarations will be 		 * aligned right if proc decl has an explicit type on it, i.e. 		 * "int a(x) {..." 		 */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
comment|/* I said this was a kluge... */
name|ps
operator|.
name|in_or_st
operator|=
name|false
expr_stmt|;
comment|/* turn off flag for structure decl or 					 * initialization */
block|}
if|if
condition|(
name|ps
operator|.
name|sizeof_keyword
condition|)
name|ps
operator|.
name|sizeof_mask
operator||=
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
expr_stmt|;
break|break;
case|case
name|rparen
case|:
comment|/* got a ')' or ']' */
name|rparen_count
operator|--
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|cast_mask
operator|&
operator|(
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
operator|)
operator|&
operator|~
name|ps
operator|.
name|sizeof_mask
condition|)
block|{
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|cast_mask
operator|&=
operator|(
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
operator|)
operator|-
literal|1
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
else|else
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|sizeof_mask
operator|&=
operator|(
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
operator|)
operator|-
literal|1
expr_stmt|;
if|if
condition|(
operator|--
name|ps
operator|.
name|p_l_follow
operator|<
literal|0
condition|)
block|{
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
name|diag3
argument_list|(
literal|0
argument_list|,
literal|"Extra %c"
argument_list|,
operator|*
name|token
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|e_code
operator|==
name|s_code
condition|)
comment|/* if the paren starts the line */
name|ps
operator|.
name|paren_level
operator|=
name|ps
operator|.
name|p_l_follow
expr_stmt|;
comment|/* then indent it */
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|sp_sw
operator|&&
operator|(
name|ps
operator|.
name|p_l_follow
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* check for end of if 							 * (...), or some such */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* must force newline after if */
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
comment|/* inform lexi that a following 					 * operator is unary */
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* dont use stmt continuation 					 * indentation */
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
comment|/* let parser worry about if, or whatever */
block|}
name|ps
operator|.
name|search_brace
operator|=
name|btype_2
expr_stmt|;
comment|/* this should insure that constructs 					 * such as main(){...} and int[]{...} 					 * have their braces put in the right 					 * place */
break|break;
case|case
name|unary_op
case|:
comment|/* this could be any unary operation */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|troff
operator|&&
operator|!
name|ps
operator|.
name|dumped_decl_indent
operator|&&
name|ps
operator|.
name|in_decl
operator|&&
operator|!
name|is_procname
condition|)
block|{
name|sprintf
argument_list|(
name|e_code
argument_list|,
literal|"\n.Du %dp+\200p \"%s\"\n"
argument_list|,
name|dec_ind
operator|*
literal|7
argument_list|,
name|token
argument_list|)
expr_stmt|;
name|ps
operator|.
name|dumped_decl_indent
operator|=
literal|1
expr_stmt|;
name|e_code
operator|+=
name|strlen
argument_list|(
name|e_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
modifier|*
name|res
init|=
name|token
decl_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
block|{
comment|/* if this is a unary op 							 * in a declaration, we 							 * should indent this 							 * token */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
index|]
condition|;
operator|++
name|i
control|)
empty_stmt|;
comment|/* find length of token */
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
name|i
operator|)
condition|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* pad it */
block|}
block|}
if|if
condition|(
name|troff
operator|&&
name|token
index|[
literal|0
index|]
operator|==
literal|'-'
operator|&&
name|token
index|[
literal|1
index|]
operator|==
literal|'>'
condition|)
name|res
operator|=
literal|"\\(->"
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|res
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
block|}
block|}
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|binary_op
case|:
comment|/* any binary operation */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|{
name|char
modifier|*
name|res
init|=
name|token
decl_stmt|;
if|if
condition|(
name|troff
condition|)
switch|switch
condition|(
name|token
index|[
literal|0
index|]
condition|)
block|{
case|case
literal|'<'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|res
operator|=
literal|"\\(<="
expr_stmt|;
break|break;
case|case
literal|'>'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|res
operator|=
literal|"\\(>="
expr_stmt|;
break|break;
case|case
literal|'!'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'='
condition|)
name|res
operator|=
literal|"\\(!="
expr_stmt|;
break|break;
case|case
literal|'|'
case|:
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|'|'
condition|)
name|res
operator|=
literal|"\\(br\\(br"
expr_stmt|;
elseif|else
if|if
condition|(
name|token
index|[
literal|1
index|]
operator|==
literal|0
condition|)
name|res
operator|=
literal|"\\(br"
expr_stmt|;
break|break;
block|}
for|for
control|(
name|t_ptr
operator|=
name|res
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* move the operator */
block|}
block|}
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|postop
case|:
comment|/* got a trailing ++ or -- */
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|0
index|]
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
name|token
index|[
literal|1
index|]
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|question
case|:
comment|/* got a ? */
name|squest
operator|++
expr_stmt|;
comment|/* this will be used when a later colon 				 * appears so we can distinguish the 				 *<c>?<n>:<n> construct */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'?'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|casestmt
case|:
comment|/* got word 'case' or 'default' */
name|scase
operator|=
name|true
expr_stmt|;
comment|/* so we can process the later colon properly */
goto|goto
name|copy_id
goto|;
case|case
name|colon
case|:
comment|/* got a ':' */
if|if
condition|(
name|squest
operator|>
literal|0
condition|)
block|{
comment|/* it is part of the<c>?<n>:<n> construct */
operator|--
name|squest
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|':'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|ps
operator|.
name|in_decl
condition|)
block|{
operator|*
name|e_code
operator|++
operator|=
literal|':'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
block|}
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* seeing a label does not imply we are in a 				 * stmt */
for|for
control|(
name|t_ptr
operator|=
name|s_code
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
comment|/* turn everything so far into a label */
name|e_code
operator|=
name|s_code
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|':'
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_lab
operator|=
literal|'\0'
expr_stmt|;
name|force_nl
operator|=
name|ps
operator|.
name|pcase
operator|=
name|scase
expr_stmt|;
comment|/* ps.pcase will be used by 						 * dump_line to decide how to 						 * indent the label. force_nl 						 * will force a case n: to be 						 * on a line by itself */
name|scase
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
break|break;
case|case
name|semicolon
case|:
comment|/* got a ';' */
name|ps
operator|.
name|in_or_st
operator|=
name|false
expr_stmt|;
comment|/* we are not in an initialization or 				 * structure declaration */
name|scase
operator|=
name|false
expr_stmt|;
comment|/* these will only need resetting in a error */
name|squest
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|last_token
operator|==
name|rparen
operator|&&
name|rparen_count
operator|==
literal|0
condition|)
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|cast_mask
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|sizeof_mask
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|block_init
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|block_init_level
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|--
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
name|s_code
operator|==
name|e_code
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
literal|1
operator|)
condition|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|ps
operator|.
name|in_decl
operator|=
operator|(
name|ps
operator|.
name|dec_nest
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* if we were in a first level 						 * structure declaration, we 						 * arent any more */
if|if
condition|(
operator|(
operator|!
name|sp_sw
operator|||
name|hd_type
operator|!=
name|forstmt
operator|)
operator|&&
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
condition|)
block|{
comment|/* 		 * This should be true iff there were unbalanced parens in the 		 * stmt.  It is a bit complicated, because the semicolon might 		 * be in a for stmt 		 */
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Unbalanced parens"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp_sw
condition|)
block|{
comment|/* this is a check for a if, while, etc. with 				 * unbalanced parens */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
comment|/* dont lose the if, or whatever */
block|}
block|}
operator|*
name|e_code
operator|++
operator|=
literal|';'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|in_stmt
operator|=
operator|(
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
operator|)
expr_stmt|;
comment|/* we are no longer in the 						 * middle of a stmt */
if|if
condition|(
operator|!
name|sp_sw
condition|)
block|{
comment|/* if not if for (;;) */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
comment|/* let parser know about end of stmt */
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* force newline after a end of stmt */
block|}
break|break;
case|case
name|lbrace
case|:
comment|/* got a '{' */
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
comment|/* dont indent the {} */
if|if
condition|(
operator|!
name|ps
operator|.
name|block_init
condition|)
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* force other stuff on same line as '{' onto 				 * new line */
elseif|else
if|if
condition|(
name|ps
operator|.
name|block_init_level
operator|<=
literal|0
condition|)
name|ps
operator|.
name|block_init_level
operator|=
literal|1
expr_stmt|;
else|else
name|ps
operator|.
name|block_init_level
operator|++
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
block|{
if|if
condition|(
operator|!
name|btype_2
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|ps
operator|.
name|in_parameter_declaration
operator|&&
operator|!
name|ps
operator|.
name|in_or_st
condition|)
block|{
name|ps
operator|.
name|i_l_follow
operator|=
literal|0
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ps
operator|.
name|in_parameter_declaration
condition|)
name|prefix_blankline_requested
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|p_l_follow
operator|>
literal|0
condition|)
block|{
comment|/* check for preceding unbalanced 					 * parens */
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Unbalanced parens"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|sp_sw
condition|)
block|{
comment|/* check for unclosed if, for, etc. */
name|sp_sw
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
name|ps
operator|.
name|ind_level
operator|=
name|ps
operator|.
name|i_l_follow
expr_stmt|;
block|}
block|}
if|if
condition|(
name|s_code
operator|==
name|e_code
condition|)
name|ps
operator|.
name|ind_stmt
operator|=
name|false
expr_stmt|;
comment|/* dont put extra indentation on line 					 * with '{' */
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
name|ps
operator|.
name|in_or_st
condition|)
block|{
comment|/* this is either a structure 						 * declaration or an init */
name|di_stack
index|[
name|ps
operator|.
name|dec_nest
operator|++
index|]
operator|=
name|dec_ind
expr_stmt|;
comment|/* ?		dec_ind = 0; */
block|}
else|else
block|{
name|ps
operator|.
name|decl_on_line
operator|=
name|false
expr_stmt|;
comment|/* we cant be in the middle of 						 * a declaration, so dont do 						 * special indentation of 						 * comments */
if|if
condition|(
name|blanklines_after_declarations_at_proctop
operator|&&
name|ps
operator|.
name|in_parameter_declaration
condition|)
name|postfix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|0
expr_stmt|;
block|}
name|dec_ind
operator|=
literal|0
expr_stmt|;
name|parse
argument_list|(
name|lbrace
argument_list|)
expr_stmt|;
comment|/* let parser know about this */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
comment|/* put a blank before '{' if '{' is not at 				 * start of line */
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|'{'
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
literal|0
expr_stmt|;
break|break;
case|case
name|rbrace
case|:
comment|/* got a '}' */
if|if
condition|(
name|ps
operator|.
name|p_stack
index|[
name|ps
operator|.
name|tos
index|]
operator|==
name|decl
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
comment|/* semicolons can be 								 * omitted in 								 * declarations */
name|parse
argument_list|(
name|semicolon
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|p_l_follow
condition|)
block|{
comment|/* check for unclosed if, for, else. */
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Unbalanced parens"
argument_list|)
expr_stmt|;
name|ps
operator|.
name|p_l_follow
operator|=
literal|0
expr_stmt|;
name|sp_sw
operator|=
name|false
expr_stmt|;
block|}
name|ps
operator|.
name|just_saw_decl
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|block_init_level
operator|--
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
block|{
comment|/* '}' must be first on 							 * line */
if|if
condition|(
name|verbose
condition|)
name|diag2
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
block|}
operator|*
name|e_code
operator|++
operator|=
literal|'}'
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|in_stmt
operator|=
name|ps
operator|.
name|ind_stmt
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|dec_nest
operator|>
literal|0
condition|)
block|{
comment|/* we are in multi-level structure 					 * declaration */
name|dec_ind
operator|=
name|di_stack
index|[
operator|--
name|ps
operator|.
name|dec_nest
index|]
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|dec_nest
operator|==
literal|0
operator|&&
operator|!
name|ps
operator|.
name|in_parameter_declaration
condition|)
name|ps
operator|.
name|just_saw_decl
operator|=
literal|2
expr_stmt|;
name|ps
operator|.
name|in_decl
operator|=
name|true
expr_stmt|;
block|}
name|prefix_blankline_requested
operator|=
literal|0
expr_stmt|;
name|parse
argument_list|(
name|rbrace
argument_list|)
expr_stmt|;
comment|/* let parser know about this */
name|ps
operator|.
name|search_brace
operator|=
name|cuddle_else
operator|&&
name|ps
operator|.
name|p_stack
index|[
name|ps
operator|.
name|tos
index|]
operator|==
name|ifhead
operator|&&
name|ps
operator|.
name|il
index|[
name|ps
operator|.
name|tos
index|]
operator|>=
name|ps
operator|.
name|ind_level
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|tos
operator|<=
literal|1
operator|&&
name|blanklines_after_procs
operator|&&
name|ps
operator|.
name|dec_nest
operator|<=
literal|0
condition|)
name|postfix_blankline_requested
operator|=
literal|1
expr_stmt|;
break|break;
case|case
name|swstmt
case|:
comment|/* got keyword "switch" */
name|sp_sw
operator|=
name|true
expr_stmt|;
name|hd_type
operator|=
name|swstmt
expr_stmt|;
comment|/* keep this for when we have seen the 				 * expression */
goto|goto
name|copy_id
goto|;
comment|/* go move the token into buffer */
case|case
name|sp_paren
case|:
comment|/* token is if, while, for */
name|sp_sw
operator|=
name|true
expr_stmt|;
comment|/* the interesting stuff is done after the 				 * expression is scanned */
name|hd_type
operator|=
operator|(
operator|*
name|token
operator|==
literal|'i'
condition|?
name|ifstmt
else|:
operator|(
operator|*
name|token
operator|==
literal|'w'
condition|?
name|whilestmt
else|:
name|forstmt
operator|)
operator|)
expr_stmt|;
comment|/* 	     * remember the type of header for later use by parser 	     */
goto|goto
name|copy_id
goto|;
comment|/* copy the token into line */
case|case
name|sp_nparen
case|:
comment|/* got else, do */
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
if|if
condition|(
operator|*
name|token
operator|==
literal|'e'
condition|)
block|{
if|if
condition|(
name|e_code
operator|!=
name|s_code
operator|&&
operator|(
operator|!
name|cuddle_else
operator|||
name|e_code
index|[
operator|-
literal|1
index|]
operator|!=
literal|'}'
operator|)
condition|)
block|{
if|if
condition|(
name|verbose
condition|)
name|diag2
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
comment|/* make sure this starts a line */
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* also, following stuff must go onto new line */
name|last_else
operator|=
literal|1
expr_stmt|;
name|parse
argument_list|(
name|elselit
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|e_code
operator|!=
name|s_code
condition|)
block|{
comment|/* make sure this starts a line */
if|if
condition|(
name|verbose
condition|)
name|diag2
argument_list|(
literal|0
argument_list|,
literal|"Line broken"
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
name|force_nl
operator|=
name|true
expr_stmt|;
comment|/* also, following stuff must go onto new line */
name|last_else
operator|=
literal|0
expr_stmt|;
name|parse
argument_list|(
name|dolit
argument_list|)
expr_stmt|;
block|}
goto|goto
name|copy_id
goto|;
comment|/* move the token into line */
case|case
name|decl
case|:
comment|/* we have a declaration type (int, register, 				 * etc.) */
name|parse
argument_list|(
name|decl
argument_list|)
expr_stmt|;
comment|/* let parser worry about indentation */
if|if
condition|(
name|ps
operator|.
name|last_token
operator|==
name|rparen
operator|&&
name|ps
operator|.
name|tos
operator|<=
literal|1
condition|)
block|{
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
literal|0
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ps
operator|.
name|in_parameter_declaration
operator|&&
name|ps
operator|.
name|indent_parameters
operator|&&
name|ps
operator|.
name|dec_nest
operator|==
literal|0
condition|)
block|{
name|ps
operator|.
name|ind_level
operator|=
name|ps
operator|.
name|i_l_follow
operator|=
literal|1
expr_stmt|;
name|ps
operator|.
name|ind_stmt
operator|=
literal|0
expr_stmt|;
block|}
name|ps
operator|.
name|in_or_st
operator|=
name|true
expr_stmt|;
comment|/* this might be a structure or initialization 				 * declaration */
name|ps
operator|.
name|in_decl
operator|=
name|ps
operator|.
name|decl_on_line
operator|=
name|true
expr_stmt|;
if|if
condition|(
comment|/* !ps.in_or_st&& */
name|ps
operator|.
name|dec_nest
operator|<=
literal|0
condition|)
name|ps
operator|.
name|just_saw_decl
operator|=
literal|2
expr_stmt|;
name|prefix_blankline_requested
operator|=
literal|0
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|0
init|;
name|token
index|[
name|i
operator|++
index|]
condition|;
control|)
empty_stmt|;
comment|/* get length of token */
comment|/* 	     * dec_ind = e_code - s_code + (ps.decl_indent>i ? ps.decl_indent 	     * : i); 	     */
name|dec_ind
operator|=
name|ps
operator|.
name|decl_indent
operator|>
literal|0
condition|?
name|ps
operator|.
name|decl_indent
else|:
name|i
expr_stmt|;
goto|goto
name|copy_id
goto|;
case|case
name|ident
case|:
comment|/* got an identifier or constant */
if|if
condition|(
name|ps
operator|.
name|in_decl
condition|)
block|{
comment|/* if we are in a declaration, we must indent 				 * identifier */
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|is_procname
operator|==
literal|0
operator|||
operator|!
name|procnames_start_line
condition|)
block|{
if|if
condition|(
operator|!
name|ps
operator|.
name|block_init
condition|)
block|{
if|if
condition|(
name|troff
operator|&&
operator|!
name|ps
operator|.
name|dumped_decl_indent
condition|)
block|{
name|sprintf
argument_list|(
name|e_code
argument_list|,
literal|"\n.De %dp+\200p\n"
argument_list|,
name|dec_ind
operator|*
literal|7
argument_list|)
expr_stmt|;
name|ps
operator|.
name|dumped_decl_indent
operator|=
literal|1
expr_stmt|;
name|e_code
operator|+=
name|strlen
argument_list|(
name|e_code
argument_list|)
expr_stmt|;
block|}
else|else
block|{
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
name|dec_ind
condition|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|dec_ind
operator|&&
name|s_code
operator|!=
name|e_code
condition|)
name|dump_line
argument_list|()
expr_stmt|;
name|dec_ind
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|sp_sw
operator|&&
name|ps
operator|.
name|p_l_follow
operator|==
literal|0
condition|)
block|{
name|sp_sw
operator|=
name|false
expr_stmt|;
name|force_nl
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|in_stmt
operator|=
name|false
expr_stmt|;
name|parse
argument_list|(
name|hd_type
argument_list|)
expr_stmt|;
block|}
name|copy_id
label|:
if|if
condition|(
name|ps
operator|.
name|want_blank
condition|)
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
name|troff
operator|&&
name|ps
operator|.
name|its_a_keyword
condition|)
block|{
name|e_code
operator|=
name|chfont
argument_list|(
operator|&
name|bodyf
argument_list|,
operator|&
name|keywordf
argument_list|,
name|e_code
argument_list|)
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
name|keywordf
operator|.
name|allcaps
operator|&&
name|islower
argument_list|(
operator|*
name|t_ptr
argument_list|)
condition|?
name|toupper
argument_list|(
operator|*
name|t_ptr
argument_list|)
else|:
operator|*
name|t_ptr
expr_stmt|;
block|}
name|e_code
operator|=
name|chfont
argument_list|(
operator|&
name|keywordf
argument_list|,
operator|&
name|bodyf
argument_list|,
name|e_code
argument_list|)
expr_stmt|;
block|}
else|else
for|for
control|(
name|t_ptr
operator|=
name|token
init|;
operator|*
name|t_ptr
condition|;
operator|++
name|t_ptr
control|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
operator|*
name|t_ptr
expr_stmt|;
block|}
name|ps
operator|.
name|want_blank
operator|=
name|true
expr_stmt|;
break|break;
case|case
name|period
case|:
comment|/* treat a period kind of like a binary 				 * operation */
operator|*
name|e_code
operator|++
operator|=
literal|'.'
expr_stmt|;
comment|/* move the period into line */
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* dont put a blank after a period */
break|break;
case|case
name|comma
case|:
name|ps
operator|.
name|want_blank
operator|=
operator|(
name|s_code
operator|!=
name|e_code
operator|)
expr_stmt|;
comment|/* only put blank after comma 						 * if comma does not start the 						 * line */
if|if
condition|(
name|ps
operator|.
name|in_decl
operator|&&
name|is_procname
operator|==
literal|0
operator|&&
operator|!
name|ps
operator|.
name|block_init
condition|)
while|while
condition|(
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|<
operator|(
name|dec_ind
operator|-
literal|1
operator|)
condition|)
block|{
name|CHECK_SIZE_CODE
expr_stmt|;
operator|*
name|e_code
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|e_code
operator|++
operator|=
literal|','
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|p_l_follow
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ps
operator|.
name|block_init_level
operator|<=
literal|0
condition|)
name|ps
operator|.
name|block_init
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|break_comma
operator|&&
operator|(
operator|!
name|ps
operator|.
name|leave_comma
operator|||
name|compute_code_target
argument_list|()
operator|+
operator|(
name|e_code
operator|-
name|s_code
operator|)
operator|>
name|max_col
operator|-
literal|8
operator|)
condition|)
name|force_nl
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
name|preesc
case|:
comment|/* got the character '#' */
if|if
condition|(
operator|(
name|s_com
operator|!=
name|e_com
operator|)
operator|||
operator|(
name|s_lab
operator|!=
name|e_lab
operator|)
operator|||
operator|(
name|s_code
operator|!=
name|e_code
operator|)
condition|)
name|dump_line
argument_list|()
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
literal|'#'
expr_stmt|;
comment|/* move whole line to 'label' buffer */
block|{
name|int
name|in_comment
init|=
literal|0
decl_stmt|;
name|int
name|com_start
init|=
literal|0
decl_stmt|;
name|char
name|quote
init|=
literal|0
decl_stmt|;
name|int
name|com_end
init|=
literal|0
decl_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
while|while
condition|(
operator|*
name|buf_ptr
operator|!=
literal|'\n'
operator|||
operator|(
name|in_comment
operator|&&
operator|!
name|had_eof
operator|)
condition|)
block|{
name|CHECK_SIZE_LAB
expr_stmt|;
operator|*
name|e_lab
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|e_lab
operator|++
condition|)
block|{
case|case
name|BACKSLASH
case|:
if|if
condition|(
name|troff
condition|)
operator|*
name|e_lab
operator|++
operator|=
name|BACKSLASH
expr_stmt|;
if|if
condition|(
operator|!
name|in_comment
condition|)
block|{
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|'/'
case|:
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
operator|!
name|in_comment
operator|&&
operator|!
name|quote
condition|)
block|{
name|in_comment
operator|=
literal|1
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|com_start
operator|=
name|e_lab
operator|-
name|s_lab
operator|-
literal|2
expr_stmt|;
block|}
break|break;
case|case
literal|'"'
case|:
if|if
condition|(
name|quote
operator|==
literal|'"'
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'\''
case|:
if|if
condition|(
name|quote
operator|==
literal|'\''
condition|)
name|quote
operator|=
literal|0
expr_stmt|;
break|break;
case|case
literal|'*'
case|:
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
operator|&&
name|in_comment
condition|)
block|{
name|in_comment
operator|=
literal|0
expr_stmt|;
operator|*
name|e_lab
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|com_end
operator|=
name|e_lab
operator|-
name|s_lab
expr_stmt|;
block|}
break|break;
block|}
block|}
while|while
condition|(
name|e_lab
operator|>
name|s_lab
operator|&&
operator|(
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|e_lab
operator|--
expr_stmt|;
if|if
condition|(
name|e_lab
operator|-
name|s_lab
operator|==
name|com_end
operator|&&
name|bp_save
operator|==
literal|0
condition|)
block|{
comment|/* comment on 								 * preprocessor line */
if|if
condition|(
name|sc_end
operator|==
literal|0
condition|)
comment|/* if this is the first comment, we 					 * must set up the buffer */
name|sc_end
operator|=
operator|&
operator|(
name|save_com
index|[
literal|0
index|]
operator|)
expr_stmt|;
else|else
block|{
operator|*
name|sc_end
operator|++
operator|=
literal|'\n'
expr_stmt|;
comment|/* add newline between 						 * comments */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
operator|--
name|line_no
expr_stmt|;
block|}
name|bcopy
argument_list|(
name|s_lab
operator|+
name|com_start
argument_list|,
name|sc_end
argument_list|,
name|com_end
operator|-
name|com_start
argument_list|)
expr_stmt|;
name|sc_end
operator|+=
name|com_end
operator|-
name|com_start
expr_stmt|;
if|if
condition|(
name|sc_end
operator|>=
operator|&
name|save_com
index|[
name|sc_size
index|]
condition|)
name|abort
argument_list|()
expr_stmt|;
name|e_lab
operator|=
name|s_lab
operator|+
name|com_start
expr_stmt|;
while|while
condition|(
name|e_lab
operator|>
name|s_lab
operator|&&
operator|(
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|' '
operator|||
name|e_lab
index|[
operator|-
literal|1
index|]
operator|==
literal|'\t'
operator|)
condition|)
name|e_lab
operator|--
expr_stmt|;
name|bp_save
operator|=
name|buf_ptr
expr_stmt|;
comment|/* save current input buffer */
name|be_save
operator|=
name|buf_end
expr_stmt|;
name|buf_ptr
operator|=
name|save_com
expr_stmt|;
comment|/* fix so that subsequent calls to 					 * lexi will take tokens out of 					 * save_com */
operator|*
name|sc_end
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add trailing blank, just in case */
name|buf_end
operator|=
name|sc_end
expr_stmt|;
name|sc_end
operator|=
literal|0
expr_stmt|;
block|}
operator|*
name|e_lab
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate line */
name|ps
operator|.
name|pcase
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|strncmp
argument_list|(
name|s_lab
argument_list|,
literal|"#if"
argument_list|,
literal|3
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|blanklines_around_conditional_compilation
condition|)
block|{
specifier|register
name|int
name|c
decl_stmt|;
name|prefix_blankline_requested
operator|++
expr_stmt|;
while|while
condition|(
operator|(
name|c
operator|=
name|getc
argument_list|(
name|input
argument_list|)
operator|)
operator|==
literal|'\n'
condition|)
empty_stmt|;
name|ungetc
argument_list|(
name|c
argument_list|,
name|input
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ifdef_level
operator|<
sizeof|sizeof
name|state_stack
operator|/
sizeof|sizeof
name|state_stack
index|[
literal|0
index|]
condition|)
block|{
name|match_state
index|[
name|ifdef_level
index|]
operator|.
name|tos
operator|=
operator|-
literal|1
expr_stmt|;
name|state_stack
index|[
name|ifdef_level
operator|++
index|]
operator|=
name|ps
expr_stmt|;
block|}
else|else
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"#if stack overflow"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s_lab
argument_list|,
literal|"#else"
argument_list|,
literal|5
argument_list|)
operator|==
literal|0
condition|)
if|if
condition|(
name|ifdef_level
operator|<=
literal|0
condition|)
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Unmatched #else"
argument_list|)
expr_stmt|;
else|else
block|{
name|match_state
index|[
name|ifdef_level
operator|-
literal|1
index|]
operator|=
name|ps
expr_stmt|;
name|ps
operator|=
name|state_stack
index|[
name|ifdef_level
operator|-
literal|1
index|]
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|strncmp
argument_list|(
name|s_lab
argument_list|,
literal|"#endif"
argument_list|,
literal|6
argument_list|)
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|ifdef_level
operator|<=
literal|0
condition|)
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Unmatched #endif"
argument_list|)
expr_stmt|;
else|else
block|{
name|ifdef_level
operator|--
expr_stmt|;
ifdef|#
directive|ifdef
name|undef
comment|/* 		     * This match needs to be more intelligent before the 		     * message is useful 		     */
if|if
condition|(
name|match_state
index|[
name|ifdef_level
index|]
operator|.
name|tos
operator|>=
literal|0
operator|&&
name|bcmp
argument_list|(
operator|&
name|ps
argument_list|,
operator|&
name|match_state
index|[
name|ifdef_level
index|]
argument_list|,
sizeof|sizeof
name|ps
argument_list|)
condition|)
name|diag2
argument_list|(
literal|0
argument_list|,
literal|"Syntactically inconsistant #ifdef alternatives."
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
if|if
condition|(
name|blanklines_around_conditional_compilation
condition|)
block|{
name|postfix_blankline_requested
operator|++
expr_stmt|;
name|n_real_blanklines
operator|=
literal|0
expr_stmt|;
block|}
block|}
break|break;
comment|/* subsequent processing of the newline 				 * character will cause the line to be printed */
case|case
name|comment
case|:
comment|/* we have gotten a / followed by * this is a biggie */
if|if
condition|(
name|flushed_nl
condition|)
block|{
comment|/* we should force a broken line here */
name|flushed_nl
operator|=
name|false
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
comment|/* dont insert blank at line start */
name|force_nl
operator|=
name|false
expr_stmt|;
block|}
name|pr_comment
argument_list|()
expr_stmt|;
break|break;
block|}
comment|/* end of big switch stmt */
operator|*
name|e_code
operator|=
literal|'\0'
expr_stmt|;
comment|/* make sure code section is null terminated */
if|if
condition|(
name|type_code
operator|!=
name|comment
operator|&&
name|type_code
operator|!=
name|newline
operator|&&
name|type_code
operator|!=
name|preesc
condition|)
name|ps
operator|.
name|last_token
operator|=
name|type_code
expr_stmt|;
block|}
comment|/* end of main while (1) loop */
block|}
end_function

begin_comment
comment|/*  * copy input file to backup file if in_name is /blah/blah/blah/file, then  * backup file will be ".Bfile" then make the backup file the input and  * original input file the output  */
end_comment

begin_function
specifier|static
name|void
name|bakcopy
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|n
decl_stmt|,
name|bakchn
decl_stmt|;
name|char
name|buff
index|[
literal|8
operator|*
literal|1024
index|]
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
comment|/* construct file name .Bfile */
for|for
control|(
name|p
operator|=
name|in_name
init|;
operator|*
name|p
condition|;
name|p
operator|++
control|)
empty_stmt|;
comment|/* skip to end of string */
while|while
condition|(
name|p
operator|>
name|in_name
operator|&&
operator|*
name|p
operator|!=
literal|'/'
condition|)
comment|/* find last '/' */
name|p
operator|--
expr_stmt|;
if|if
condition|(
operator|*
name|p
operator|==
literal|'/'
condition|)
name|p
operator|++
expr_stmt|;
name|sprintf
argument_list|(
name|bakfile
argument_list|,
literal|"%s.BAK"
argument_list|,
name|p
argument_list|)
expr_stmt|;
comment|/* copy in_name to backup file */
name|bakchn
operator|=
name|creat
argument_list|(
name|bakfile
argument_list|,
literal|0600
argument_list|)
expr_stmt|;
if|if
condition|(
name|bakchn
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|bakfile
argument_list|)
expr_stmt|;
while|while
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fileno
argument_list|(
name|input
argument_list|)
argument_list|,
name|buff
argument_list|,
sizeof|sizeof
name|buff
argument_list|)
operator|)
operator|!=
literal|0
condition|)
if|if
condition|(
name|write
argument_list|(
name|bakchn
argument_list|,
name|buff
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|bakfile
argument_list|)
expr_stmt|;
if|if
condition|(
name|n
operator|<
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|in_name
argument_list|)
expr_stmt|;
name|close
argument_list|(
name|bakchn
argument_list|)
expr_stmt|;
name|fclose
argument_list|(
name|input
argument_list|)
expr_stmt|;
comment|/* re-open backup file as the input file */
name|input
operator|=
name|fopen
argument_list|(
name|bakfile
argument_list|,
literal|"r"
argument_list|)
expr_stmt|;
if|if
condition|(
name|input
operator|==
literal|0
condition|)
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|bakfile
argument_list|)
expr_stmt|;
comment|/* now the original input file will be the output */
name|output
operator|=
name|fopen
argument_list|(
name|in_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|output
operator|==
literal|0
condition|)
block|{
name|unlink
argument_list|(
name|bakfile
argument_list|)
expr_stmt|;
name|err
argument_list|(
literal|1
argument_list|,
literal|"%s"
argument_list|,
name|in_name
argument_list|)
expr_stmt|;
block|}
block|}
end_function

end_unit

