begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Sun Microsystems, Inc.  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)pr_comment.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_comment
comment|/*  * NAME:  *	pr_comment  *  * FUNCTION:  *	This routine takes care of scanning and printing comments.  *  * ALGORITHM:  *	1) Decide where the comment should be aligned, and if lines should  *	   be broken.  *	2) If lines should not be broken and filled, just copy up to end of  *	   comment.  *	3) If lines should be filled, then scan thru input_buffer copying  *	   characters to com_buf.  Remember where the last blank, tab, or  *	   newline was.  When line is filled, print up to last blank and  *	   continue copying.  *  * HISTORY:  *	November 1976	D A Willcox of CAC	Initial coding  *	12/6/76		D A Willcox of CAC	Modification to handle  *						UNIX-style comments  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * this routine processes comments.  It makes an attempt to keep comments from  * going over the max line length.  If a line is too long, it moves everything  * from the last blank to the next comment line.  Blanks and tabs from the  * beginning of the input line are removed  */
end_comment

begin_function
name|void
name|pr_comment
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|now_col
decl_stmt|;
comment|/* column we are in now */
name|int
name|adj_max_col
decl_stmt|;
comment|/* Adjusted max_col for when we decide to 				 * spill comments over the right margin */
name|char
modifier|*
name|last_bl
decl_stmt|;
comment|/* points to the last blank in the output 				 * buffer */
name|char
modifier|*
name|t_ptr
decl_stmt|;
comment|/* used for moving string */
name|int
name|break_delim
init|=
name|comment_delimiter_on_blankline
decl_stmt|;
name|int
name|l_just_saw_decl
init|=
name|ps
operator|.
name|just_saw_decl
decl_stmt|;
name|adj_max_col
operator|=
name|max_col
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
literal|0
expr_stmt|;
name|last_bl
operator|=
name|NULL
expr_stmt|;
comment|/* no blanks found so far */
name|ps
operator|.
name|box_com
operator|=
name|false
expr_stmt|;
comment|/* at first, assume that we are not in 					 * a boxed comment or some other 					 * comment that should not be touched */
operator|++
name|ps
operator|.
name|out_coms
expr_stmt|;
comment|/* keep track of number of comments */
comment|/* Figure where to align and how to treat the comment */
if|if
condition|(
name|ps
operator|.
name|col_1
operator|&&
operator|!
name|format_col1_comments
condition|)
block|{
comment|/* if comment starts in column 						 * 1 it should not be touched */
name|ps
operator|.
name|box_com
operator|=
name|true
expr_stmt|;
name|break_delim
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|com_col
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'-'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|||
operator|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
operator|&&
operator|!
name|format_block_comments
operator|)
condition|)
block|{
name|ps
operator|.
name|box_com
operator|=
name|true
expr_stmt|;
comment|/* A comment with a '-' or '*' immediately 				 * after the /+* is assumed to be a boxed 				 * comment. A comment with a newline 				 * immediately after the /+* is assumed to 				 * be a block comment and is treated as a 				 * box comment unless format_block_comments 				 * is nonzero (the default). */
name|break_delim
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
comment|/* ps.bl_line&& */
operator|(
name|s_lab
operator|==
name|e_lab
operator|)
operator|&&
operator|(
name|s_code
operator|==
name|e_code
operator|)
condition|)
block|{
comment|/* klg: check only if this line is blank */
comment|/* 	     * If this (*and previous lines are*) blank, dont put comment way 	     * out at left 	     */
name|ps
operator|.
name|com_col
operator|=
operator|(
name|ps
operator|.
name|ind_level
operator|-
name|ps
operator|.
name|unindent_displace
operator|)
operator|*
name|ps
operator|.
name|ind_size
operator|+
literal|1
expr_stmt|;
name|adj_max_col
operator|=
name|block_comment_max_col
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<=
literal|1
condition|)
name|ps
operator|.
name|com_col
operator|=
literal|1
operator|+
operator|!
name|format_col1_comments
expr_stmt|;
block|}
else|else
block|{
name|int
name|target_col
decl_stmt|;
name|break_delim
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
condition|)
name|target_col
operator|=
name|count_spaces
argument_list|(
name|compute_code_target
argument_list|()
argument_list|,
name|s_code
argument_list|)
expr_stmt|;
else|else
block|{
name|target_col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s_lab
operator|!=
name|e_lab
condition|)
name|target_col
operator|=
name|count_spaces
argument_list|(
name|compute_label_target
argument_list|()
argument_list|,
name|s_lab
argument_list|)
expr_stmt|;
block|}
name|ps
operator|.
name|com_col
operator|=
name|ps
operator|.
name|decl_on_line
operator|||
name|ps
operator|.
name|ind_level
operator|==
literal|0
condition|?
name|ps
operator|.
name|decl_com_ind
else|:
name|ps
operator|.
name|com_ind
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<
name|target_col
condition|)
name|ps
operator|.
name|com_col
operator|=
operator|(
operator|(
name|target_col
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|+
literal|24
operator|>
name|adj_max_col
condition|)
name|adj_max_col
operator|=
name|ps
operator|.
name|com_col
operator|+
literal|24
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ps
operator|.
name|box_com
condition|)
block|{
name|buf_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|n_comment_delta
operator|=
literal|1
operator|-
name|count_spaces
argument_list|(
literal|1
argument_list|,
name|in_buffer
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|n_comment_delta
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
name|buf_ptr
operator|++
expr_stmt|;
block|}
name|ps
operator|.
name|comment_delta
operator|=
literal|0
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* put '/' followed by '*' into buffer */
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|!=
literal|' '
operator|&&
operator|!
name|ps
operator|.
name|box_com
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* Don't put a break delimiter if this comment is a one-liner */
for|for
control|(
name|t_ptr
operator|=
name|buf_ptr
init|;
operator|*
name|t_ptr
operator|!=
literal|'\0'
operator|&&
operator|*
name|t_ptr
operator|!=
literal|'\n'
condition|;
name|t_ptr
operator|++
control|)
block|{
if|if
condition|(
name|t_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|t_ptr
index|[
literal|0
index|]
operator|==
literal|'*'
operator|&&
name|t_ptr
index|[
literal|1
index|]
operator|==
literal|'/'
condition|)
block|{
name|break_delim
operator|=
name|false
expr_stmt|;
break|break;
block|}
block|}
if|if
condition|(
name|break_delim
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|e_com
decl_stmt|;
name|e_com
operator|=
name|s_com
operator|+
literal|2
expr_stmt|;
operator|*
name|e_com
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanklines_before_blockcomments
condition|)
name|prefix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|e_com
operator|=
name|s_com
operator|=
name|t
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|star_comment_cont
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|troff
condition|)
name|adj_max_col
operator|=
literal|80
expr_stmt|;
comment|/* Start to copy the comment */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* this loop will go until the comment is 				 * copied */
name|CHECK_SIZE_COM
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf_ptr
condition|)
block|{
comment|/* this checks for various spcl cases */
case|case
literal|014
case|:
comment|/* check for a form feed */
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
comment|/* in a text comment, break the line here */
name|ps
operator|.
name|use_ff
operator|=
name|true
expr_stmt|;
comment|/* fix so dump_line uses a form feed */
name|dump_line
argument_list|()
expr_stmt|;
name|last_bl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|star_comment_cont
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|014
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|had_eof
condition|)
block|{
comment|/* check for unexpected eof */
name|printf
argument_list|(
literal|"Unterminated comment\n"
argument_list|)
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|last_bl
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|box_com
operator|||
name|ps
operator|.
name|last_nl
condition|)
block|{
comment|/* if this is a boxed comment, 						 * we dont ignore the newline */
if|if
condition|(
name|s_com
operator|==
name|e_com
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|e_com
operator|-
name|s_com
operator|>
literal|3
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
if|if
condition|(
name|star_comment_cont
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|dump_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|star_comment_cont
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|last_nl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
operator|-
literal|1
expr_stmt|;
comment|/* 		 * if there was a space at the end of the last line, remember 		 * where it was 		 */
else|else
block|{
comment|/* otherwise, insert one */
name|last_bl
operator|=
name|e_com
expr_stmt|;
name|CHECK_SIZE_COM
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
block|}
operator|++
name|line_no
expr_stmt|;
comment|/* keep track of input line number */
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
name|int
name|nstar
init|=
literal|1
decl_stmt|;
do|do
block|{
comment|/* flush any blanks and/or tabs at start of 				 * next line */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
operator|--
name|nstar
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
goto|goto
name|end_of_comment
goto|;
block|}
block|}
do|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
break|break;
comment|/* end of case for newline */
case|case
literal|'*'
case|:
comment|/* must check for possibility of being at end 				 * of comment */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* get to next char after * */
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
block|{
comment|/* it is the end!!! */
name|end_of_comment
label|:
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
name|CHECK_SIZE_COM
expr_stmt|;
if|if
condition|(
name|break_delim
condition|)
block|{
if|if
condition|(
name|e_com
operator|>
name|s_com
operator|+
literal|3
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
block|}
else|else
name|s_com
operator|=
name|e_com
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|e_com
index|[
operator|-
literal|1
index|]
operator|!=
literal|' '
operator|&&
operator|!
name|ps
operator|.
name|box_com
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* ensure blank before end */
operator|*
name|e_com
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|'/'
operator|,
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
name|l_just_saw_decl
expr_stmt|;
return|return;
block|}
else|else
comment|/* handle isolated '*' */
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
break|break;
default|default:
comment|/* we have a random char */
name|now_col
operator|=
name|count_spaces_until
argument_list|(
name|ps
operator|.
name|com_col
argument_list|,
name|s_com
argument_list|,
name|e_com
argument_list|)
expr_stmt|;
do|do
block|{
operator|*
name|e_com
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|e_com
operator|==
literal|' '
operator|||
operator|*
name|e_com
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
expr_stmt|;
comment|/* remember we saw a blank */
operator|++
name|e_com
expr_stmt|;
name|now_col
operator|++
expr_stmt|;
block|}
do|while
condition|(
operator|!
name|memchr
argument_list|(
literal|"*\n\r\b\t"
argument_list|,
operator|*
name|buf_ptr
argument_list|,
literal|6
argument_list|)
operator|&&
operator|(
name|now_col
operator|<=
name|adj_max_col
operator|||
operator|!
name|last_bl
operator|)
condition|)
do|;
name|ps
operator|.
name|last_nl
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|now_col
operator|>
name|adj_max_col
operator|&&
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|e_com
index|[
operator|-
literal|1
index|]
operator|>
literal|' '
condition|)
block|{
comment|/* 		 * the comment is too long, it must be broken up 		 */
if|if
condition|(
name|last_bl
operator|==
name|NULL
condition|)
block|{
name|dump_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|star_comment_cont
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
break|break;
block|}
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|e_com
operator|=
name|last_bl
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|star_comment_cont
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|'*'
operator|,
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
for|for
control|(
name|t_ptr
operator|=
name|last_bl
operator|+
literal|1
init|;
operator|*
name|t_ptr
operator|==
literal|' '
operator|||
operator|*
name|t_ptr
operator|==
literal|'\t'
condition|;
name|t_ptr
operator|++
control|)
empty_stmt|;
name|last_bl
operator|=
name|NULL
expr_stmt|;
while|while
condition|(
operator|*
name|t_ptr
operator|!=
literal|'\0'
condition|)
block|{
if|if
condition|(
operator|*
name|t_ptr
operator|==
literal|' '
operator|||
operator|*
name|t_ptr
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
operator|*
name|t_ptr
operator|++
expr_stmt|;
block|}
block|}
break|break;
block|}
block|}
block|}
end_function

end_unit

