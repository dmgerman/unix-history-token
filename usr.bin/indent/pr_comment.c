begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Sun Microsystems, Inc.  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)pr_comment.c	8.1 (Berkeley) 6/6/93"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
name|rcsid
index|[]
init|=
literal|"$FreeBSD$"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_comment
comment|/*  * NAME:  *	pr_comment  *  * FUNCTION:  *	This routine takes care of scanning and printing comments.  *  * ALGORITHM:  *	1) Decide where the comment should be aligned, and if lines should  *	   be broken.  *	2) If lines should not be broken and filled, just copy up to end of  *	   comment.  *	3) If lines should be filled, then scan thru input_buffer copying  *	   characters to com_buf.  Remember where the last blank, tab, or  *	   newline was.  When line is filled, print up to last blank and  *	   continue copying.  *  * HISTORY:  *	November 1976	D A Willcox of CAC	Initial coding  *	12/6/76		D A Willcox of CAC	Modification to handle  *						UNIX-style comments  *  */
end_comment

begin_escape
end_escape

begin_comment
comment|/*  * this routine processes comments.  It makes an attempt to keep comments from  * going over the max line length.  If a line is too long, it moves everything  * from the last blank to the next comment line.  Blanks and tabs from the  * beginning of the input line are removed  */
end_comment

begin_macro
name|pr_comment
argument_list|()
end_macro

begin_block
block|{
name|int
name|now_col
decl_stmt|;
comment|/* column we are in now */
name|int
name|adj_max_col
decl_stmt|;
comment|/* Adjusted max_col for when we decide to 				 * spill comments over the right margin */
name|char
modifier|*
name|last_bl
decl_stmt|;
comment|/* points to the last blank in the output 				 * buffer */
name|char
modifier|*
name|t_ptr
decl_stmt|;
comment|/* used for moving string */
name|int
name|unix_comment
decl_stmt|;
comment|/* tri-state variable used to decide if it is 				 * a unix-style comment. 0 means only blanks 				 * since /*, 1 means regular style comment, 2 				 * means unix style comment */
name|int
name|break_delim
init|=
name|comment_delimiter_on_blankline
decl_stmt|;
name|int
name|l_just_saw_decl
init|=
name|ps
operator|.
name|just_saw_decl
decl_stmt|;
comment|/*      * int         ps.last_nl = 0;	/* true iff the last significant thing      * weve seen is a newline      */
name|int
name|one_liner
init|=
literal|1
decl_stmt|;
comment|/* true iff this comment is a one-liner */
name|adj_max_col
operator|=
name|max_col
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
literal|0
expr_stmt|;
name|last_bl
operator|=
literal|0
expr_stmt|;
comment|/* no blanks found so far */
name|ps
operator|.
name|box_com
operator|=
name|false
expr_stmt|;
comment|/* at first, assume that we are not in 					 * a boxed comment or some other 					 * comment that should not be touched */
operator|++
name|ps
operator|.
name|out_coms
expr_stmt|;
comment|/* keep track of number of comments */
name|unix_comment
operator|=
literal|1
expr_stmt|;
comment|/* set flag to let us figure out if there is a 				 * unix-style comment ** DISABLED: use 0 to 				 * reenable this hack! */
comment|/* Figure where to align and how to treat the comment */
if|if
condition|(
name|ps
operator|.
name|col_1
operator|&&
operator|!
name|format_col1_comments
condition|)
block|{
comment|/* if comment starts in column 						 * 1 it should not be touched */
name|ps
operator|.
name|box_com
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|com_col
operator|=
literal|1
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'-'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|||
operator|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
operator|&&
operator|!
name|format_block_comments
operator|)
condition|)
block|{
name|ps
operator|.
name|box_com
operator|=
name|true
expr_stmt|;
comment|/* A comment with a '-' or '*' immediately 				 * after the /* is assumed to be a boxed 				 * comment. A comment with a newline 				 * immediately after the /* is assumed to 				 * be a block comment and is treated as a 				 * box comment unless format_block_comments 				 * is nonzero (the default). */
name|break_delim
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
comment|/* ps.bl_line&& */
operator|(
name|s_lab
operator|==
name|e_lab
operator|)
operator|&&
operator|(
name|s_code
operator|==
name|e_code
operator|)
condition|)
block|{
comment|/* klg: check only if this line is blank */
comment|/* 	     * If this (*and previous lines are*) blank, dont put comment way 	     * out at left 	     */
name|ps
operator|.
name|com_col
operator|=
operator|(
name|ps
operator|.
name|ind_level
operator|-
name|ps
operator|.
name|unindent_displace
operator|)
operator|*
name|ps
operator|.
name|ind_size
operator|+
literal|1
expr_stmt|;
name|adj_max_col
operator|=
name|block_comment_max_col
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<=
literal|1
condition|)
name|ps
operator|.
name|com_col
operator|=
literal|1
operator|+
operator|!
name|format_col1_comments
expr_stmt|;
block|}
else|else
block|{
specifier|register
name|target_col
expr_stmt|;
name|break_delim
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|s_code
operator|!=
name|e_code
condition|)
name|target_col
operator|=
name|count_spaces
argument_list|(
name|compute_code_target
argument_list|()
argument_list|,
name|s_code
argument_list|)
expr_stmt|;
else|else
block|{
name|target_col
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|s_lab
operator|!=
name|e_lab
condition|)
name|target_col
operator|=
name|count_spaces
argument_list|(
name|compute_label_target
argument_list|()
argument_list|,
name|s_lab
argument_list|)
expr_stmt|;
block|}
name|ps
operator|.
name|com_col
operator|=
name|ps
operator|.
name|decl_on_line
operator|||
name|ps
operator|.
name|ind_level
operator|==
literal|0
condition|?
name|ps
operator|.
name|decl_com_ind
else|:
name|ps
operator|.
name|com_ind
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<
name|target_col
condition|)
name|ps
operator|.
name|com_col
operator|=
operator|(
operator|(
name|target_col
operator|+
literal|7
operator|)
operator|&
operator|~
literal|7
operator|)
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|+
literal|24
operator|>
name|adj_max_col
condition|)
name|adj_max_col
operator|=
name|ps
operator|.
name|com_col
operator|+
literal|24
expr_stmt|;
block|}
block|}
if|if
condition|(
name|ps
operator|.
name|box_com
condition|)
block|{
name|buf_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|0
expr_stmt|;
name|ps
operator|.
name|n_comment_delta
operator|=
literal|1
operator|-
name|count_spaces
argument_list|(
literal|1
argument_list|,
name|in_buffer
argument_list|)
expr_stmt|;
name|buf_ptr
index|[
operator|-
literal|2
index|]
operator|=
literal|'/'
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|n_comment_delta
operator|=
literal|0
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
name|buf_ptr
operator|++
expr_stmt|;
block|}
name|ps
operator|.
name|comment_delta
operator|=
literal|0
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'/'
expr_stmt|;
comment|/* put '/*' into buffer */
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|!=
literal|' '
operator|&&
operator|!
name|ps
operator|.
name|box_com
condition|)
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|troff
condition|)
block|{
name|now_col
operator|=
literal|1
expr_stmt|;
name|adj_max_col
operator|=
literal|80
expr_stmt|;
block|}
else|else
name|now_col
operator|=
name|count_spaces
argument_list|(
name|ps
operator|.
name|com_col
argument_list|,
name|s_com
argument_list|)
expr_stmt|;
comment|/* figure what column we 							 * would be in if we 							 * printed the comment 							 * now */
comment|/* Start to copy the comment */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* this loop will go until the comment is 				 * copied */
if|if
condition|(
operator|*
name|buf_ptr
operator|>
literal|040
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'*'
condition|)
name|ps
operator|.
name|last_nl
operator|=
literal|0
expr_stmt|;
name|CHECK_SIZE_COM
expr_stmt|;
switch|switch
condition|(
operator|*
name|buf_ptr
condition|)
block|{
comment|/* this checks for various spcl cases */
case|case
literal|014
case|:
comment|/* check for a form feed */
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
comment|/* in a text comment, break the line here */
name|ps
operator|.
name|use_ff
operator|=
name|true
expr_stmt|;
comment|/* fix so dump_line uses a form feed */
name|dump_line
argument_list|()
expr_stmt|;
name|last_bl
operator|=
literal|0
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
while|while
condition|(
operator|*
operator|++
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
empty_stmt|;
block|}
else|else
block|{
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|014
expr_stmt|;
block|}
break|break;
case|case
literal|'\n'
case|:
if|if
condition|(
name|had_eof
condition|)
block|{
comment|/* check for unexpected eof */
name|printf
argument_list|(
literal|"Unterminated comment\n"
argument_list|)
expr_stmt|;
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
return|return;
block|}
name|one_liner
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|box_com
operator|||
name|ps
operator|.
name|last_nl
condition|)
block|{
comment|/* if this is a boxed comment, 						 * we dont ignore the newline */
if|if
condition|(
name|s_com
operator|==
name|e_com
condition|)
block|{
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|e_com
operator|-
name|s_com
operator|>
literal|3
condition|)
block|{
if|if
condition|(
name|break_delim
operator|==
literal|1
operator|&&
name|s_com
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|s_com
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|s_com
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|e_com
decl_stmt|;
name|break_delim
operator|=
literal|2
expr_stmt|;
name|e_com
operator|=
name|s_com
operator|+
literal|2
expr_stmt|;
operator|*
name|e_com
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanklines_before_blockcomments
condition|)
name|prefix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|e_com
operator|=
name|t
expr_stmt|;
name|s_com
index|[
literal|0
index|]
operator|=
name|s_com
index|[
literal|1
index|]
operator|=
name|s_com
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
block|}
name|dump_line
argument_list|()
expr_stmt|;
name|CHECK_SIZE_COM
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
name|dump_line
argument_list|()
expr_stmt|;
name|now_col
operator|=
name|ps
operator|.
name|com_col
expr_stmt|;
block|}
else|else
block|{
name|ps
operator|.
name|last_nl
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|unix_comment
operator|!=
literal|1
condition|)
block|{
comment|/* we not are in unix_style 						 * comment */
if|if
condition|(
name|unix_comment
operator|==
literal|0
operator|&&
name|s_code
operator|==
name|e_code
condition|)
block|{
comment|/* 			 * if it is a UNIX-style comment, ignore the 			 * requirement that previous line be blank for 			 * unindention 			 */
name|ps
operator|.
name|com_col
operator|=
operator|(
name|ps
operator|.
name|ind_level
operator|-
name|ps
operator|.
name|unindent_displace
operator|)
operator|*
name|ps
operator|.
name|ind_size
operator|+
literal|1
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|com_col
operator|<=
literal|1
condition|)
name|ps
operator|.
name|com_col
operator|=
literal|2
expr_stmt|;
block|}
name|unix_comment
operator|=
literal|2
expr_stmt|;
comment|/* permanently remember that we are in 					 * this type of comment */
name|dump_line
argument_list|()
expr_stmt|;
operator|++
name|line_no
expr_stmt|;
name|now_col
operator|=
name|ps
operator|.
name|com_col
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* 		     * fix so that the star at the start of the line will line 		     * up 		     */
do|do
comment|/* flush leading white space */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
do|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
do|;
break|break;
block|}
if|if
condition|(
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|==
literal|' '
operator|||
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
operator|-
literal|1
expr_stmt|;
comment|/* 		 * if there was a space at the end of the last line, remember 		 * where it was 		 */
else|else
block|{
comment|/* otherwise, insert one */
name|last_bl
operator|=
name|e_com
expr_stmt|;
name|CHECK_SIZE_COM
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|++
name|now_col
expr_stmt|;
block|}
block|}
operator|++
name|line_no
expr_stmt|;
comment|/* keep track of input line number */
if|if
condition|(
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
name|int
name|nstar
init|=
literal|1
decl_stmt|;
do|do
block|{
comment|/* flush any blanks and/or tabs at start of 				 * next line */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
operator|--
name|nstar
operator|>=
literal|0
condition|)
block|{
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
goto|goto
name|end_of_comment
goto|;
block|}
block|}
do|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
do|;
block|}
elseif|else
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
break|break;
comment|/* end of case for newline */
case|case
literal|'*'
case|:
comment|/* must check for possibility of being at end 				 * of comment */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* get to next char after * */
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
name|unix_comment
operator|==
literal|0
condition|)
comment|/* set flag to show we are not in 					 * unix-style comment */
name|unix_comment
operator|=
literal|1
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'/'
condition|)
block|{
comment|/* it is the end!!! */
name|end_of_comment
label|:
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
operator|(
name|e_com
operator|-
literal|1
operator|)
operator|!=
literal|' '
operator|&&
operator|!
name|ps
operator|.
name|box_com
condition|)
block|{
comment|/* insure blank before 								 * end */
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|++
name|now_col
expr_stmt|;
block|}
if|if
condition|(
name|break_delim
operator|==
literal|1
operator|&&
operator|!
name|one_liner
operator|&&
name|s_com
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|s_com
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|s_com
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|e_com
decl_stmt|;
name|break_delim
operator|=
literal|2
expr_stmt|;
name|e_com
operator|=
name|s_com
operator|+
literal|2
expr_stmt|;
operator|*
name|e_com
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanklines_before_blockcomments
condition|)
name|prefix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|e_com
operator|=
name|t
expr_stmt|;
name|s_com
index|[
literal|0
index|]
operator|=
name|s_com
index|[
literal|1
index|]
operator|=
name|s_com
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|break_delim
operator|==
literal|2
operator|&&
name|e_com
operator|>
name|s_com
operator|+
literal|3
comment|/* now_col> adj_max_col - 2&& !ps.box_com */
condition|)
block|{
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|now_col
operator|=
name|ps
operator|.
name|com_col
expr_stmt|;
block|}
name|CHECK_SIZE_COM
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|'/'
expr_stmt|;
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|ps
operator|.
name|just_saw_decl
operator|=
name|l_just_saw_decl
expr_stmt|;
return|return;
block|}
else|else
block|{
comment|/* handle isolated '*' */
operator|*
name|e_com
operator|++
operator|=
literal|'*'
expr_stmt|;
operator|++
name|now_col
expr_stmt|;
block|}
break|break;
default|default:
comment|/* we have a random char */
if|if
condition|(
name|unix_comment
operator|==
literal|0
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|' '
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'\t'
condition|)
name|unix_comment
operator|=
literal|1
expr_stmt|;
comment|/* we are not in unix-style comment */
operator|*
name|e_com
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|e_com
operator|==
literal|'\t'
condition|)
comment|/* keep track of column */
name|now_col
operator|=
operator|(
operator|(
name|now_col
operator|-
literal|1
operator|)
operator|&
name|tabmask
operator|)
operator|+
name|tabsize
operator|+
literal|1
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|e_com
operator|==
literal|'\b'
condition|)
comment|/* this is a backspace */
operator|--
name|now_col
expr_stmt|;
else|else
operator|++
name|now_col
expr_stmt|;
if|if
condition|(
operator|*
name|e_com
operator|==
literal|' '
operator|||
operator|*
name|e_com
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
expr_stmt|;
comment|/* remember we saw a blank */
operator|++
name|e_com
expr_stmt|;
if|if
condition|(
name|now_col
operator|>
name|adj_max_col
operator|&&
operator|!
name|ps
operator|.
name|box_com
operator|&&
name|unix_comment
operator|==
literal|1
operator|&&
name|e_com
index|[
operator|-
literal|1
index|]
operator|>
literal|' '
condition|)
block|{
comment|/* 		 * the comment is too long, it must be broken up 		 */
if|if
condition|(
name|break_delim
operator|==
literal|1
operator|&&
name|s_com
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
name|s_com
index|[
literal|1
index|]
operator|==
literal|'*'
operator|&&
name|s_com
index|[
literal|2
index|]
operator|==
literal|' '
condition|)
block|{
name|char
modifier|*
name|t
init|=
name|e_com
decl_stmt|;
name|break_delim
operator|=
literal|2
expr_stmt|;
name|e_com
operator|=
name|s_com
operator|+
literal|2
expr_stmt|;
operator|*
name|e_com
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|blanklines_before_blockcomments
condition|)
name|prefix_blankline_requested
operator|=
literal|1
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
name|e_com
operator|=
name|t
expr_stmt|;
name|s_com
index|[
literal|0
index|]
operator|=
name|s_com
index|[
literal|1
index|]
operator|=
name|s_com
index|[
literal|2
index|]
operator|=
literal|' '
expr_stmt|;
block|}
if|if
condition|(
name|last_bl
operator|==
literal|0
condition|)
block|{
comment|/* we have seen no blanks */
name|last_bl
operator|=
name|e_com
expr_stmt|;
comment|/* fake it */
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
block|}
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
comment|/* print what we have */
operator|*
name|last_bl
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
name|last_bl
operator|>
name|s_com
operator|&&
name|last_bl
index|[
operator|-
literal|1
index|]
operator|<
literal|040
condition|)
operator|*
operator|--
name|last_bl
operator|=
literal|0
expr_stmt|;
name|e_com
operator|=
name|last_bl
expr_stmt|;
name|dump_line
argument_list|()
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
comment|/* add blanks for continuation */
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
literal|' '
expr_stmt|;
name|t_ptr
operator|=
name|last_bl
operator|+
literal|1
expr_stmt|;
name|last_bl
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|t_ptr
operator|>=
name|e_com
condition|)
block|{
while|while
condition|(
operator|*
name|t_ptr
operator|==
literal|' '
operator|||
operator|*
name|t_ptr
operator|==
literal|'\t'
condition|)
name|t_ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|t_ptr
operator|!=
literal|'\0'
condition|)
block|{
comment|/* move unprinted part of 						 * comment down in buffer */
if|if
condition|(
operator|*
name|t_ptr
operator|==
literal|' '
operator|||
operator|*
name|t_ptr
operator|==
literal|'\t'
condition|)
name|last_bl
operator|=
name|e_com
expr_stmt|;
operator|*
name|e_com
operator|++
operator|=
operator|*
name|t_ptr
operator|++
expr_stmt|;
block|}
block|}
operator|*
name|e_com
operator|=
literal|'\0'
expr_stmt|;
name|now_col
operator|=
name|count_spaces
argument_list|(
name|ps
operator|.
name|com_col
argument_list|,
name|s_com
argument_list|)
expr_stmt|;
comment|/* recompute current 								 * position */
block|}
break|break;
block|}
block|}
block|}
end_block

end_unit

