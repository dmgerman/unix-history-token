begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * Copyright (c) 1985 Sun Microsystems, Inc.  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)lexi.c	8.1 (Berkeley) 6/6/93"; static const char rcsid[] =   "$FreeBSD$";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Here we have the token scanner for indent.  It scans off one token and puts  * it in the global variable "token".  It returns a code, indicating the type  * of token scanned.  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_include
include|#
directive|include
file|"indent_codes.h"
end_include

begin_define
define|#
directive|define
name|alphanum
value|1
end_define

begin_define
define|#
directive|define
name|opchar
value|3
end_define

begin_function_decl
name|void
name|fill_buffer
parameter_list|(
name|void
parameter_list|)
function_decl|;
end_function_decl

begin_struct
struct|struct
name|templ
block|{
name|char
modifier|*
name|rwd
decl_stmt|;
name|int
name|rwcode
decl_stmt|;
block|}
struct|;
end_struct

begin_decl_stmt
name|struct
name|templ
name|specials
index|[
literal|1000
index|]
init|=
block|{
block|{
literal|"switch"
block|,
literal|1
block|}
block|,
block|{
literal|"case"
block|,
literal|2
block|}
block|,
block|{
literal|"break"
block|,
literal|0
block|}
block|,
block|{
literal|"struct"
block|,
literal|3
block|}
block|,
block|{
literal|"union"
block|,
literal|3
block|}
block|,
block|{
literal|"enum"
block|,
literal|3
block|}
block|,
block|{
literal|"default"
block|,
literal|2
block|}
block|,
block|{
literal|"int"
block|,
literal|4
block|}
block|,
block|{
literal|"char"
block|,
literal|4
block|}
block|,
block|{
literal|"float"
block|,
literal|4
block|}
block|,
block|{
literal|"double"
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
literal|4
block|}
block|,
block|{
literal|"short"
block|,
literal|4
block|}
block|,
block|{
literal|"typdef"
block|,
literal|4
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|4
block|}
block|,
block|{
literal|"register"
block|,
literal|4
block|}
block|,
block|{
literal|"static"
block|,
literal|4
block|}
block|,
block|{
literal|"global"
block|,
literal|4
block|}
block|,
block|{
literal|"extern"
block|,
literal|4
block|}
block|,
block|{
literal|"void"
block|,
literal|4
block|}
block|,
block|{
literal|"goto"
block|,
literal|0
block|}
block|,
block|{
literal|"return"
block|,
literal|0
block|}
block|,
block|{
literal|"if"
block|,
literal|5
block|}
block|,
block|{
literal|"while"
block|,
literal|5
block|}
block|,
block|{
literal|"for"
block|,
literal|5
block|}
block|,
block|{
literal|"else"
block|,
literal|6
block|}
block|,
block|{
literal|"do"
block|,
literal|6
block|}
block|,
block|{
literal|"sizeof"
block|,
literal|7
block|}
block|,
block|{
literal|"const"
block|,
literal|9
block|}
block|,
block|{
literal|"volatile"
block|,
literal|9
block|}
block|,
block|{
literal|0
block|,
literal|0
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chartype
index|[
literal|128
index|]
init|=
block|{
comment|/* this is used to facilitate the decision of 				 * what type (alphanumeric, operator) each 				 * character is */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|lexi
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|unary_delim
decl_stmt|;
comment|/* this is set to 1 if the current token 				 * forces a following operator to be unary */
specifier|static
name|int
name|last_code
decl_stmt|;
comment|/* the last token type returned */
specifier|static
name|int
name|l_struct
decl_stmt|;
comment|/* set to 1 if the last token was 'struct' */
name|int
name|code
decl_stmt|;
comment|/* internal code to be returned */
name|char
name|qchar
decl_stmt|;
comment|/* the delimiter character for a string */
name|e_token
operator|=
name|s_token
expr_stmt|;
comment|/* point to start of place to save token */
name|unary_delim
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|col_1
operator|=
name|ps
operator|.
name|last_nl
expr_stmt|;
comment|/* tell world that this token started in 				 * column 1 iff the last thing scanned was nl */
name|ps
operator|.
name|last_nl
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* get rid of blanks */
name|ps
operator|.
name|col_1
operator|=
name|false
expr_stmt|;
comment|/* leading blanks imply token is not in column 				 * 1 */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
comment|/* Scan an alphanumeric token */
if|if
condition|(
name|chartype
index|[
operator|(
name|int
operator|)
operator|*
name|buf_ptr
index|]
operator|==
name|alphanum
operator|||
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isdigit
argument_list|(
name|buf_ptr
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* 	 * we have a character or number 	 */
specifier|register
name|char
modifier|*
name|j
decl_stmt|;
comment|/* used for searching thru list of 				 * 				 * reserved words */
specifier|register
name|struct
name|templ
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|buf_ptr
argument_list|)
operator|||
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isdigit
argument_list|(
name|buf_ptr
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
name|int
name|seendot
init|=
literal|0
decl_stmt|,
name|seenexp
init|=
literal|0
decl_stmt|,
name|seensfx
init|=
literal|0
decl_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'0'
operator|&&
operator|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|'X'
operator|)
condition|)
block|{
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
while|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|buf_ptr
argument_list|)
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
block|}
block|}
else|else
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|seendot
condition|)
break|break;
else|else
name|seendot
operator|++
expr_stmt|;
block|}
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|buf_ptr
argument_list|)
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|buf_ptr
operator|!=
literal|'E'
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'e'
operator|)
operator|||
name|seenexp
condition|)
break|break;
else|else
block|{
name|seenexp
operator|++
expr_stmt|;
name|seendot
operator|++
expr_stmt|;
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'+'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'-'
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seensfx
operator|&
literal|1
operator|)
operator|&&
operator|(
operator|*
name|buf_ptr
operator|==
literal|'U'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'u'
operator|)
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|seensfx
operator||=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|seensfx
operator|&
literal|2
operator|)
operator|&&
operator|(
operator|*
name|buf_ptr
operator|==
literal|'L'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'l'
operator|)
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
if|if
condition|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
name|buf_ptr
index|[
literal|0
index|]
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|seensfx
operator||=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
else|else
while|while
condition|(
name|chartype
index|[
operator|(
name|int
operator|)
operator|*
name|buf_ptr
index|]
operator|==
name|alphanum
operator|||
operator|*
name|buf_ptr
operator|==
name|BACKSLASH
condition|)
block|{
comment|/* fill_buffer() terminates buffer with newline */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|BACKSLASH
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|buf_ptr
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|buf_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
block|}
name|CHECK_SIZE_TOKEN
expr_stmt|;
comment|/* copy it over */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
operator|*
name|e_token
operator|++
operator|=
literal|'\0'
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* get rid of blanks */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|ps
operator|.
name|its_a_keyword
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|sizeof_keyword
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|l_struct
condition|)
block|{
comment|/* if last token was 'struct', then this token 				 * should be treated as a declaration */
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|ident
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
block|}
name|ps
operator|.
name|last_u_d
operator|=
name|false
expr_stmt|;
comment|/* Operator after indentifier is binary */
name|last_code
operator|=
name|ident
expr_stmt|;
comment|/* Remember that this is the code we will 				 * return */
comment|/* 	 * This loop will check if the token is a keyword. 	 */
for|for
control|(
name|p
operator|=
name|specials
init|;
operator|(
name|j
operator|=
name|p
operator|->
name|rwd
operator|)
operator|!=
literal|0
condition|;
name|p
operator|++
control|)
block|{
specifier|register
name|char
modifier|*
name|p
init|=
name|s_token
decl_stmt|;
comment|/* point at scanned token */
if|if
condition|(
operator|*
name|j
operator|++
operator|!=
operator|*
name|p
operator|++
operator|||
operator|*
name|j
operator|++
operator|!=
operator|*
name|p
operator|++
condition|)
continue|continue;
comment|/* This test depends on the fact that 				 * identifiers are always at least 1 character 				 * long (ie. the first two bytes of the 				 * identifier are always meaningful) */
if|if
condition|(
name|p
index|[
operator|-
literal|1
index|]
operator|==
literal|0
condition|)
break|break;
comment|/* If its a one-character identifier */
while|while
condition|(
operator|*
name|p
operator|++
operator|==
operator|*
name|j
condition|)
if|if
condition|(
operator|*
name|j
operator|++
operator|==
literal|0
condition|)
goto|goto
name|found_keyword
goto|;
comment|/* I wish that C had a multi-level 					 * break... */
block|}
if|if
condition|(
name|p
operator|->
name|rwd
condition|)
block|{
comment|/* we have a keyword */
name|found_keyword
label|:
name|ps
operator|.
name|its_a_keyword
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|rwcode
condition|)
block|{
case|case
literal|1
case|:
comment|/* it is a switch */
return|return
operator|(
name|swstmt
operator|)
return|;
case|case
literal|2
case|:
comment|/* a case or default */
return|return
operator|(
name|casestmt
operator|)
return|;
case|case
literal|3
case|:
comment|/* a "struct" */
if|if
condition|(
name|ps
operator|.
name|p_l_follow
condition|)
break|break;
comment|/* inside parens: cast */
comment|/* 		 * Next time around, we may want to know that we have had a 		 * 'struct' 		 */
name|l_struct
operator|=
name|true
expr_stmt|;
comment|/* 		 * Fall through to test for a cast, function prototype or 		 * sizeof(). 		 */
case|case
literal|4
case|:
comment|/* one of the declaration keywords */
if|if
condition|(
name|ps
operator|.
name|p_l_follow
condition|)
block|{
name|ps
operator|.
name|cast_mask
operator||=
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
expr_stmt|;
comment|/* 		     * Forget that we saw `struct' if we're in a sizeof(). 		     */
if|if
condition|(
name|ps
operator|.
name|sizeof_mask
condition|)
name|l_struct
operator|=
name|false
expr_stmt|;
break|break;
comment|/* inside parens: cast, prototype or sizeof() */
block|}
name|last_code
operator|=
name|decl
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
case|case
literal|5
case|:
comment|/* if, while, for */
return|return
operator|(
name|sp_paren
operator|)
return|;
case|case
literal|6
case|:
comment|/* do, else */
return|return
operator|(
name|sp_nparen
operator|)
return|;
case|case
literal|7
case|:
name|ps
operator|.
name|sizeof_keyword
operator|=
name|true
expr_stmt|;
default|default:
comment|/* all others are treated like any other 				 * identifier */
return|return
operator|(
name|ident
operator|)
return|;
block|}
comment|/* end of switch */
block|}
comment|/* end of if (found_it) */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'('
operator|&&
name|ps
operator|.
name|tos
operator|<=
literal|1
operator|&&
name|ps
operator|.
name|ind_level
operator|==
literal|0
condition|)
block|{
specifier|register
name|char
modifier|*
name|tp
init|=
name|buf_ptr
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|buf_end
condition|)
if|if
condition|(
operator|*
name|tp
operator|++
operator|==
literal|')'
operator|&&
operator|(
operator|*
name|tp
operator|==
literal|';'
operator|||
operator|*
name|tp
operator|==
literal|','
operator|)
condition|)
goto|goto
name|not_proc
goto|;
name|strncpy
argument_list|(
name|ps
operator|.
name|procname
argument_list|,
name|token
argument_list|,
sizeof|sizeof
name|ps
operator|.
name|procname
operator|-
literal|1
argument_list|)
expr_stmt|;
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|1
expr_stmt|;
name|rparen_count
operator|=
literal|1
expr_stmt|;
name|not_proc
label|:
empty_stmt|;
block|}
comment|/* 	 * The following hack attempts to guess whether or not the current 	 * token is in fact a declaration keyword -- one that has been 	 * typedefd 	 */
if|if
condition|(
operator|(
operator|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
name|buf_ptr
index|[
literal|1
index|]
operator|!=
literal|'='
operator|)
operator|||
name|isalpha
argument_list|(
operator|*
name|buf_ptr
argument_list|)
operator|||
operator|*
name|buf_ptr
operator|==
literal|'_'
operator|)
operator|&&
operator|!
name|ps
operator|.
name|p_l_follow
operator|&&
operator|!
name|ps
operator|.
name|block_init
operator|&&
operator|(
name|ps
operator|.
name|last_token
operator|==
name|rparen
operator|||
name|ps
operator|.
name|last_token
operator|==
name|semicolon
operator|||
name|ps
operator|.
name|last_token
operator|==
name|decl
operator|||
name|ps
operator|.
name|last_token
operator|==
name|lbrace
operator|||
name|ps
operator|.
name|last_token
operator|==
name|rbrace
operator|)
condition|)
block|{
name|ps
operator|.
name|its_a_keyword
operator|=
name|true
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
name|last_code
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|last_code
operator|==
name|decl
condition|)
comment|/* if this is a declared variable, then 				 * following sign is unary */
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
comment|/* will make "int a -1" work */
name|last_code
operator|=
name|ident
expr_stmt|;
return|return
operator|(
name|ident
operator|)
return|;
comment|/* the ident is not in the list */
block|}
comment|/* end of procesing for alpanum character */
comment|/* Scan a non-alphanumeric token */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
comment|/* if it is only a one-character token, it is 				 * moved here */
operator|*
name|e_token
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|token
condition|)
block|{
case|case
literal|'\n'
case|:
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember that we just had a newline */
name|code
operator|=
operator|(
name|had_eof
condition|?
literal|0
else|:
name|newline
operator|)
expr_stmt|;
comment|/* 	 * if data has been exausted, the newline is a dummy, and we should 	 * return code to stop 	 */
break|break;
case|case
literal|'\''
case|:
comment|/* start of quoted character */
case|case
literal|'"'
case|:
comment|/* start of string */
name|qchar
operator|=
operator|*
name|token
expr_stmt|;
if|if
condition|(
name|troff
condition|)
block|{
name|e_token
index|[
operator|-
literal|1
index|]
operator|=
literal|'`'
expr_stmt|;
if|if
condition|(
name|qchar
operator|==
literal|'"'
condition|)
operator|*
name|e_token
operator|++
operator|=
literal|'`'
expr_stmt|;
name|e_token
operator|=
name|chfont
argument_list|(
operator|&
name|bodyf
argument_list|,
operator|&
name|stringf
argument_list|,
name|e_token
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* copy the string */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* move one character or [/<char>]<char> */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
block|{
name|printf
argument_list|(
literal|"%d: Unterminated literal\n"
argument_list|,
name|line_no
argument_list|)
expr_stmt|;
goto|goto
name|stop_lit
goto|;
block|}
name|CHECK_SIZE_TOKEN
expr_stmt|;
comment|/* Only have to do this once in this loop, 					 * since CHECK_SIZE guarantees that there 					 * are at least 5 entries left */
operator|*
name|e_token
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|e_token
operator|==
name|BACKSLASH
condition|)
block|{
comment|/* if escape, copy extra char */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
comment|/* check for escaped newline */
operator|++
name|line_no
expr_stmt|;
if|if
condition|(
name|troff
condition|)
block|{
operator|*
operator|++
name|e_token
operator|=
name|BACKSLASH
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|BACKSLASH
condition|)
operator|*
operator|++
name|e_token
operator|=
name|BACKSLASH
expr_stmt|;
block|}
operator|*
operator|++
name|e_token
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|++
name|e_token
expr_stmt|;
comment|/* we must increment this again because we 				 * copied two chars */
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
comment|/* we copied one character */
block|}
comment|/* end of while (1) */
block|}
do|while
condition|(
operator|*
name|e_token
operator|++
operator|!=
name|qchar
condition|)
do|;
if|if
condition|(
name|troff
condition|)
block|{
name|e_token
operator|=
name|chfont
argument_list|(
operator|&
name|stringf
argument_list|,
operator|&
name|bodyf
argument_list|,
name|e_token
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qchar
operator|==
literal|'"'
condition|)
operator|*
name|e_token
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
name|stop_lit
label|:
name|code
operator|=
name|ident
expr_stmt|;
break|break;
case|case
operator|(
literal|'('
operator|)
case|:
case|case
operator|(
literal|'['
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|lparen
expr_stmt|;
break|break;
case|case
operator|(
literal|')'
operator|)
case|:
case|case
operator|(
literal|']'
operator|)
case|:
name|code
operator|=
name|rparen
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|code
operator|=
name|preesc
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|question
expr_stmt|;
break|break;
case|case
operator|(
literal|':'
operator|)
case|:
name|code
operator|=
name|colon
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
case|case
operator|(
literal|';'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|semicolon
expr_stmt|;
break|break;
case|case
operator|(
literal|'{'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
comment|/* 	 * if (ps.in_or_st) ps.block_init = 1; 	 */
comment|/* ?	code = ps.block_init ? lparen : lbrace; */
name|code
operator|=
name|lbrace
expr_stmt|;
break|break;
case|case
operator|(
literal|'}'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
comment|/* ?	code = ps.block_init ? rparen : rbrace; */
name|code
operator|=
name|rbrace
expr_stmt|;
break|break;
case|case
literal|014
case|:
comment|/* a form feed */
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember this so we can set 'ps.col_1' 				 * right */
name|code
operator|=
name|form_feed
expr_stmt|;
break|break;
case|case
operator|(
literal|','
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|comma
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|unary_delim
operator|=
name|false
expr_stmt|;
name|code
operator|=
name|period
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
comment|/* check for -, +, --, ++ */
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|token
index|[
literal|0
index|]
condition|)
block|{
comment|/* check for doubled character */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
comment|/* buffer overflow will be checked at end of loop */
if|if
condition|(
name|last_code
operator|==
name|ident
operator|||
name|last_code
operator|==
name|rparen
condition|)
block|{
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|postop
operator|)
expr_stmt|;
comment|/* check for following ++ or -- */
name|unary_delim
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
comment|/* check for operator += */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'>'
condition|)
block|{
comment|/* check for operator -> */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|pointer_as_binop
condition|)
block|{
name|unary_delim
operator|=
name|false
expr_stmt|;
name|code
operator|=
name|unary_op
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
block|}
break|break;
comment|/* buffer overflow will be checked at end of 				 * switch */
case|case
literal|'='
case|:
if|if
condition|(
name|ps
operator|.
name|in_or_st
condition|)
name|ps
operator|.
name|block_init
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|undef
if|if
condition|(
name|chartype
index|[
operator|*
name|buf_ptr
index|]
operator|==
name|opchar
condition|)
block|{
comment|/* we have two char assignment */
name|e_token
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|e_token
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
operator|||
name|e_token
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|e_token
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|buf_ptr
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
literal|'='
expr_stmt|;
comment|/* Flip =+ to += */
operator|*
name|e_token
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
comment|/* == */
operator|*
name|e_token
operator|++
operator|=
literal|'='
expr_stmt|;
comment|/* Flip =+ to += */
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|binary_op
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
comment|/* can drop thru!!! */
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|'!'
case|:
comment|/* ops like<,<<,<=, !=, etc */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'>'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'<'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'*'
condition|)
block|{
comment|/* it is start of comment */
operator|*
name|e_token
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
name|code
operator|=
name|comment
expr_stmt|;
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
operator|(
name|e_token
operator|-
literal|1
operator|)
operator|==
operator|*
name|buf_ptr
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
comment|/* 	     * handle ||,&&, etc, and also things as in int *****i 	     */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
block|}
comment|/* end of switch */
if|if
condition|(
name|code
operator|!=
name|newline
condition|)
block|{
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* check for input buffer empty */
name|fill_buffer
argument_list|()
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|unary_delim
expr_stmt|;
operator|*
name|e_token
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate the token */
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_comment
comment|/*  * Add the given keyword to the keyword table, using val as the keyword type  */
end_comment

begin_function
name|void
name|addkey
parameter_list|(
name|char
modifier|*
name|key
parameter_list|,
name|int
name|val
parameter_list|)
block|{
specifier|register
name|struct
name|templ
modifier|*
name|p
init|=
name|specials
decl_stmt|;
while|while
condition|(
name|p
operator|->
name|rwd
condition|)
if|if
condition|(
name|p
operator|->
name|rwd
index|[
literal|0
index|]
operator|==
name|key
index|[
literal|0
index|]
operator|&&
name|strcmp
argument_list|(
name|p
operator|->
name|rwd
argument_list|,
name|key
argument_list|)
operator|==
literal|0
condition|)
return|return;
else|else
name|p
operator|++
expr_stmt|;
if|if
condition|(
name|p
operator|>=
name|specials
operator|+
sizeof|sizeof
name|specials
operator|/
sizeof|sizeof
name|specials
index|[
literal|0
index|]
condition|)
return|return;
comment|/* For now, table overflows are silently 				 * ignored */
name|p
operator|->
name|rwd
operator|=
name|key
expr_stmt|;
name|p
operator|->
name|rwcode
operator|=
name|val
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|.
name|rwd
operator|=
literal|0
expr_stmt|;
name|p
index|[
literal|1
index|]
operator|.
name|rwcode
operator|=
literal|0
expr_stmt|;
block|}
end_function

end_unit

