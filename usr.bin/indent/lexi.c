begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1985 Sun Microsystems, Inc.  * Copyright (c) 1980, 1993  *	The Regents of the University of California.  All rights reserved.  * All rights reserved.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_if
if|#
directive|if
literal|0
end_if

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_endif
unit|static char sccsid[] = "@(#)lexi.c	8.1 (Berkeley) 6/6/93";
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<sys/cdefs.h>
end_include

begin_expr_stmt
name|__FBSDID
argument_list|(
literal|"$FreeBSD$"
argument_list|)
expr_stmt|;
end_expr_stmt

begin_comment
comment|/*  * Here we have the token scanner for indent.  It scans off one token and puts  * it in the global variable "token".  It returns a code, indicating the type  * of token scanned.  */
end_comment

begin_include
include|#
directive|include
file|<err.h>
end_include

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|"indent_globs.h"
end_include

begin_include
include|#
directive|include
file|"indent_codes.h"
end_include

begin_include
include|#
directive|include
file|"indent.h"
end_include

begin_define
define|#
directive|define
name|alphanum
value|1
end_define

begin_ifdef
ifdef|#
directive|ifdef
name|undef
end_ifdef

begin_define
define|#
directive|define
name|opchar
value|3
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_struct
struct|struct
name|templ
block|{
specifier|const
name|char
modifier|*
name|rwd
decl_stmt|;
name|int
name|rwcode
decl_stmt|;
block|}
struct|;
end_struct

begin_comment
comment|/*  * This table has to be sorted alphabetically, because it'll be used in binary  * search. For the same reason, string must be the first thing in struct templ.  */
end_comment

begin_decl_stmt
name|struct
name|templ
name|specials
index|[]
init|=
block|{
block|{
literal|"auto"
block|,
literal|10
block|}
block|,
block|{
literal|"break"
block|,
literal|9
block|}
block|,
block|{
literal|"case"
block|,
literal|8
block|}
block|,
block|{
literal|"char"
block|,
literal|4
block|}
block|,
block|{
literal|"const"
block|,
literal|4
block|}
block|,
block|{
literal|"default"
block|,
literal|8
block|}
block|,
block|{
literal|"do"
block|,
literal|6
block|}
block|,
block|{
literal|"double"
block|,
literal|4
block|}
block|,
block|{
literal|"else"
block|,
literal|6
block|}
block|,
block|{
literal|"enum"
block|,
literal|3
block|}
block|,
block|{
literal|"extern"
block|,
literal|10
block|}
block|,
block|{
literal|"float"
block|,
literal|4
block|}
block|,
block|{
literal|"for"
block|,
literal|5
block|}
block|,
block|{
literal|"global"
block|,
literal|4
block|}
block|,
block|{
literal|"goto"
block|,
literal|9
block|}
block|,
block|{
literal|"if"
block|,
literal|5
block|}
block|,
block|{
literal|"int"
block|,
literal|4
block|}
block|,
block|{
literal|"long"
block|,
literal|4
block|}
block|,
block|{
literal|"offsetof"
block|,
literal|1
block|}
block|,
block|{
literal|"register"
block|,
literal|10
block|}
block|,
block|{
literal|"return"
block|,
literal|9
block|}
block|,
block|{
literal|"short"
block|,
literal|4
block|}
block|,
block|{
literal|"sizeof"
block|,
literal|2
block|}
block|,
block|{
literal|"static"
block|,
literal|10
block|}
block|,
block|{
literal|"struct"
block|,
literal|3
block|}
block|,
block|{
literal|"switch"
block|,
literal|7
block|}
block|,
block|{
literal|"typedef"
block|,
literal|10
block|}
block|,
block|{
literal|"union"
block|,
literal|3
block|}
block|,
block|{
literal|"unsigned"
block|,
literal|4
block|}
block|,
block|{
literal|"void"
block|,
literal|4
block|}
block|,
block|{
literal|"volatile"
block|,
literal|4
block|}
block|,
block|{
literal|"while"
block|,
literal|5
block|}
block|}
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|const
name|char
modifier|*
modifier|*
name|typenames
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|typename_count
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|typename_top
init|=
operator|-
literal|1
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|chartype
index|[
literal|128
index|]
init|=
block|{
comment|/* this is used to facilitate the decision of 				 * what type (alphanumeric, operator) each 				 * character is */
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

begin_function
specifier|static
name|int
name|strcmp_type
parameter_list|(
specifier|const
name|void
modifier|*
name|e1
parameter_list|,
specifier|const
name|void
modifier|*
name|e2
parameter_list|)
block|{
return|return
operator|(
name|strcmp
argument_list|(
name|e1
argument_list|,
operator|*
operator|(
specifier|const
name|char
operator|*
specifier|const
operator|*
operator|)
name|e2
argument_list|)
operator|)
return|;
block|}
end_function

begin_function
name|int
name|lexi
parameter_list|(
name|void
parameter_list|)
block|{
name|int
name|unary_delim
decl_stmt|;
comment|/* this is set to 1 if the current token 				 * forces a following operator to be unary */
specifier|static
name|int
name|last_code
decl_stmt|;
comment|/* the last token type returned */
specifier|static
name|int
name|l_struct
decl_stmt|;
comment|/* set to 1 if the last token was 'struct' */
name|int
name|code
decl_stmt|;
comment|/* internal code to be returned */
name|char
name|qchar
decl_stmt|;
comment|/* the delimiter character for a string */
name|e_token
operator|=
name|s_token
expr_stmt|;
comment|/* point to start of place to save token */
name|unary_delim
operator|=
name|false
expr_stmt|;
name|ps
operator|.
name|col_1
operator|=
name|ps
operator|.
name|last_nl
expr_stmt|;
comment|/* tell world that this token started in 				 * column 1 iff the last thing scanned was nl */
name|ps
operator|.
name|last_nl
operator|=
name|false
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* get rid of blanks */
name|ps
operator|.
name|col_1
operator|=
name|false
expr_stmt|;
comment|/* leading blanks imply token is not in column 				 * 1 */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
comment|/* Scan an alphanumeric token */
if|if
condition|(
name|chartype
index|[
operator|(
name|int
operator|)
operator|*
name|buf_ptr
index|]
operator|==
name|alphanum
operator|||
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isdigit
argument_list|(
name|buf_ptr
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
comment|/* 	 * we have a character or number 	 */
name|struct
name|templ
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|isdigit
argument_list|(
operator|*
name|buf_ptr
argument_list|)
operator|||
operator|(
name|buf_ptr
index|[
literal|0
index|]
operator|==
literal|'.'
operator|&&
name|isdigit
argument_list|(
name|buf_ptr
index|[
literal|1
index|]
argument_list|)
operator|)
condition|)
block|{
enum|enum
name|base
block|{
name|BASE_2
block|,
name|BASE_8
block|,
name|BASE_10
block|,
name|BASE_16
block|}
enum|;
name|int
name|seendot
init|=
literal|0
decl_stmt|,
name|seenexp
init|=
literal|0
decl_stmt|,
name|seensfx
init|=
literal|0
decl_stmt|;
name|enum
name|base
name|in_base
init|=
name|BASE_10
decl_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'0'
condition|)
block|{
if|if
condition|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|'b'
operator|||
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|'B'
condition|)
name|in_base
operator|=
name|BASE_2
expr_stmt|;
elseif|else
if|if
condition|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|'x'
operator|||
name|buf_ptr
index|[
literal|1
index|]
operator|==
literal|'X'
condition|)
name|in_base
operator|=
name|BASE_16
expr_stmt|;
elseif|else
if|if
condition|(
name|isdigit
argument_list|(
name|buf_ptr
index|[
literal|1
index|]
argument_list|)
condition|)
name|in_base
operator|=
name|BASE_8
expr_stmt|;
block|}
switch|switch
condition|(
name|in_base
condition|)
block|{
case|case
name|BASE_2
case|:
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|'0'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'1'
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BASE_8
case|:
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
while|while
condition|(
operator|*
name|buf_ptr
operator|>=
literal|'0'
operator|&&
operator|*
name|buf_ptr
operator|<=
literal|'8'
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BASE_16
case|:
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
while|while
condition|(
name|isxdigit
argument_list|(
operator|*
name|buf_ptr
argument_list|)
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
block|}
break|break;
case|case
name|BASE_10
case|:
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'.'
condition|)
block|{
if|if
condition|(
name|seendot
condition|)
break|break;
else|else
name|seendot
operator|++
expr_stmt|;
block|}
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|isdigit
argument_list|(
operator|*
name|buf_ptr
argument_list|)
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'.'
condition|)
block|{
if|if
condition|(
operator|(
operator|*
name|buf_ptr
operator|!=
literal|'E'
operator|&&
operator|*
name|buf_ptr
operator|!=
literal|'e'
operator|)
operator|||
name|seenexp
condition|)
break|break;
else|else
block|{
name|seenexp
operator|++
expr_stmt|;
name|seendot
operator|++
expr_stmt|;
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'+'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'-'
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
block|}
block|}
block|}
break|break;
block|}
while|while
condition|(
literal|1
condition|)
block|{
if|if
condition|(
operator|!
operator|(
name|seensfx
operator|&
literal|1
operator|)
operator|&&
operator|(
operator|*
name|buf_ptr
operator|==
literal|'U'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'u'
operator|)
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|seensfx
operator||=
literal|1
expr_stmt|;
continue|continue;
block|}
if|if
condition|(
operator|!
operator|(
name|seensfx
operator|&
literal|2
operator|)
operator|&&
operator|(
name|strchr
argument_list|(
literal|"fFlL"
argument_list|,
operator|*
name|buf_ptr
argument_list|)
operator|!=
name|NULL
operator|)
condition|)
block|{
name|CHECK_SIZE_TOKEN
expr_stmt|;
if|if
condition|(
name|buf_ptr
index|[
literal|1
index|]
operator|==
name|buf_ptr
index|[
literal|0
index|]
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|seensfx
operator||=
literal|2
expr_stmt|;
continue|continue;
block|}
break|break;
block|}
block|}
else|else
while|while
condition|(
name|chartype
index|[
operator|(
name|int
operator|)
operator|*
name|buf_ptr
index|]
operator|==
name|alphanum
operator|||
operator|*
name|buf_ptr
operator|==
name|BACKSLASH
condition|)
block|{
comment|/* fill_buffer() terminates buffer with newline */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|BACKSLASH
condition|)
block|{
if|if
condition|(
operator|*
operator|(
name|buf_ptr
operator|+
literal|1
operator|)
operator|==
literal|'\n'
condition|)
block|{
name|buf_ptr
operator|+=
literal|2
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
block|}
name|CHECK_SIZE_TOKEN
expr_stmt|;
comment|/* copy it over */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
operator|*
name|e_token
operator|++
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
name|s_token
index|[
literal|0
index|]
operator|==
literal|'L'
operator|&&
name|s_token
index|[
literal|1
index|]
operator|==
literal|'\0'
operator|&&
operator|(
operator|*
name|buf_ptr
operator|==
literal|'"'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\''
operator|)
condition|)
return|return
operator|(
name|strpfx
operator|)
return|;
while|while
condition|(
operator|*
name|buf_ptr
operator|==
literal|' '
operator|||
operator|*
name|buf_ptr
operator|==
literal|'\t'
condition|)
block|{
comment|/* get rid of blanks */
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|ps
operator|.
name|keyword
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|l_struct
operator|&&
operator|!
name|ps
operator|.
name|p_l_follow
condition|)
block|{
comment|/* if last token was 'struct' and we're not 				 * in parentheses, then this token 				 * should be treated as a declaration */
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|ident
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
block|}
name|ps
operator|.
name|last_u_d
operator|=
name|l_struct
expr_stmt|;
comment|/* Operator after identifier is binary 				 * unless last token was 'struct' */
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|ident
expr_stmt|;
comment|/* Remember that this is the code we will 				 * return */
name|p
operator|=
name|bsearch
argument_list|(
name|s_token
argument_list|,
name|specials
argument_list|,
sizeof|sizeof
argument_list|(
name|specials
argument_list|)
operator|/
sizeof|sizeof
argument_list|(
name|specials
index|[
literal|0
index|]
argument_list|)
argument_list|,
sizeof|sizeof
argument_list|(
name|specials
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|strcmp_type
argument_list|)
expr_stmt|;
if|if
condition|(
name|p
operator|==
name|NULL
condition|)
block|{
comment|/* not a special keyword... */
name|char
modifier|*
name|u
decl_stmt|;
comment|/* ... so maybe a type_t or a typedef */
if|if
condition|(
operator|(
name|auto_typedefs
operator|&&
operator|(
operator|(
name|u
operator|=
name|strrchr
argument_list|(
name|s_token
argument_list|,
literal|'_'
argument_list|)
operator|)
operator|!=
name|NULL
operator|)
operator|&&
name|strcmp
argument_list|(
name|u
argument_list|,
literal|"_t"
argument_list|)
operator|==
literal|0
operator|)
operator|||
operator|(
name|typename_top
operator|>=
literal|0
operator|&&
name|bsearch
argument_list|(
name|s_token
argument_list|,
name|typenames
argument_list|,
name|typename_top
operator|+
literal|1
argument_list|,
sizeof|sizeof
argument_list|(
name|typenames
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|strcmp_type
argument_list|)
operator|)
condition|)
block|{
name|ps
operator|.
name|keyword
operator|=
literal|4
expr_stmt|;
comment|/* a type name */
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
goto|goto
name|found_typename
goto|;
block|}
block|}
else|else
block|{
comment|/* we have a keyword */
name|ps
operator|.
name|keyword
operator|=
name|p
operator|->
name|rwcode
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
switch|switch
condition|(
name|p
operator|->
name|rwcode
condition|)
block|{
case|case
literal|7
case|:
comment|/* it is a switch */
return|return
operator|(
name|swstmt
operator|)
return|;
case|case
literal|8
case|:
comment|/* a case or default */
return|return
operator|(
name|casestmt
operator|)
return|;
case|case
literal|3
case|:
comment|/* a "struct" */
comment|/* 		 * Next time around, we will want to know that we have had a 		 * 'struct' 		 */
name|l_struct
operator|=
name|true
expr_stmt|;
comment|/* FALLTHROUGH */
case|case
literal|4
case|:
comment|/* one of the declaration keywords */
name|found_typename
label|:
if|if
condition|(
name|ps
operator|.
name|p_l_follow
condition|)
block|{
comment|/* inside parens: cast, param list, offsetof or sizeof */
name|ps
operator|.
name|cast_mask
operator||=
operator|(
literal|1
operator|<<
name|ps
operator|.
name|p_l_follow
operator|)
operator|&
operator|~
name|ps
operator|.
name|not_cast_mask
expr_stmt|;
break|break;
block|}
name|last_code
operator|=
name|decl
expr_stmt|;
return|return
operator|(
name|decl
operator|)
return|;
case|case
literal|5
case|:
comment|/* if, while, for */
return|return
operator|(
name|sp_paren
operator|)
return|;
case|case
literal|6
case|:
comment|/* do, else */
return|return
operator|(
name|sp_nparen
operator|)
return|;
case|case
literal|10
case|:
comment|/* storage class specifier */
return|return
operator|(
name|storage
operator|)
return|;
default|default:
comment|/* all others are treated like any other 				 * identifier */
return|return
operator|(
name|ident
operator|)
return|;
block|}
comment|/* end of switch */
block|}
comment|/* end of if (found_it) */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'('
operator|&&
name|ps
operator|.
name|tos
operator|<=
literal|1
operator|&&
name|ps
operator|.
name|ind_level
operator|==
literal|0
condition|)
block|{
name|char
modifier|*
name|tp
init|=
name|buf_ptr
decl_stmt|;
while|while
condition|(
name|tp
operator|<
name|buf_end
condition|)
if|if
condition|(
operator|*
name|tp
operator|++
operator|==
literal|')'
operator|&&
operator|(
operator|*
name|tp
operator|==
literal|';'
operator|||
operator|*
name|tp
operator|==
literal|','
operator|)
condition|)
goto|goto
name|not_proc
goto|;
name|strncpy
argument_list|(
name|ps
operator|.
name|procname
argument_list|,
name|token
argument_list|,
sizeof|sizeof
name|ps
operator|.
name|procname
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ps
operator|.
name|in_decl
condition|)
name|ps
operator|.
name|in_parameter_declaration
operator|=
literal|1
expr_stmt|;
name|rparen_count
operator|=
literal|1
expr_stmt|;
name|not_proc
label|:
empty_stmt|;
block|}
comment|/* 	 * The following hack attempts to guess whether or not the current 	 * token is in fact a declaration keyword -- one that has been 	 * typedefd 	 */
if|if
condition|(
operator|(
operator|(
operator|*
name|buf_ptr
operator|==
literal|'*'
operator|&&
name|buf_ptr
index|[
literal|1
index|]
operator|!=
literal|'='
operator|)
operator|||
name|isalpha
argument_list|(
operator|*
name|buf_ptr
argument_list|)
operator|||
operator|*
name|buf_ptr
operator|==
literal|'_'
operator|)
operator|&&
operator|!
name|ps
operator|.
name|p_l_follow
operator|&&
operator|!
name|ps
operator|.
name|block_init
operator|&&
operator|(
name|ps
operator|.
name|last_token
operator|==
name|rparen
operator|||
name|ps
operator|.
name|last_token
operator|==
name|semicolon
operator|||
name|ps
operator|.
name|last_token
operator|==
name|decl
operator|||
name|ps
operator|.
name|last_token
operator|==
name|lbrace
operator|||
name|ps
operator|.
name|last_token
operator|==
name|rbrace
operator|)
condition|)
block|{
name|ps
operator|.
name|keyword
operator|=
literal|4
expr_stmt|;
comment|/* a type name */
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
name|last_code
operator|=
name|decl
expr_stmt|;
return|return
name|decl
return|;
block|}
if|if
condition|(
name|last_code
operator|==
name|decl
condition|)
comment|/* if this is a declared variable, then 				 * following sign is unary */
name|ps
operator|.
name|last_u_d
operator|=
name|true
expr_stmt|;
comment|/* will make "int a -1" work */
name|last_code
operator|=
name|ident
expr_stmt|;
return|return
operator|(
name|ident
operator|)
return|;
comment|/* the ident is not in the list */
block|}
comment|/* end of procesing for alpanum character */
comment|/* Scan a non-alphanumeric token */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
comment|/* if it is only a one-character token, it is 				 * moved here */
operator|*
name|e_token
operator|=
literal|'\0'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
switch|switch
condition|(
operator|*
name|token
condition|)
block|{
case|case
literal|'\n'
case|:
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember that we just had a newline */
name|code
operator|=
operator|(
name|had_eof
condition|?
literal|0
else|:
name|newline
operator|)
expr_stmt|;
comment|/* 	 * if data has been exhausted, the newline is a dummy, and we should 	 * return code to stop 	 */
break|break;
case|case
literal|'\''
case|:
comment|/* start of quoted character */
case|case
literal|'"'
case|:
comment|/* start of string */
name|qchar
operator|=
operator|*
name|token
expr_stmt|;
if|if
condition|(
name|troff
condition|)
block|{
name|e_token
index|[
operator|-
literal|1
index|]
operator|=
literal|'`'
expr_stmt|;
if|if
condition|(
name|qchar
operator|==
literal|'"'
condition|)
operator|*
name|e_token
operator|++
operator|=
literal|'`'
expr_stmt|;
name|e_token
operator|=
name|chfont
argument_list|(
operator|&
name|bodyf
argument_list|,
operator|&
name|stringf
argument_list|,
name|e_token
argument_list|)
expr_stmt|;
block|}
do|do
block|{
comment|/* copy the string */
while|while
condition|(
literal|1
condition|)
block|{
comment|/* move one character or [/<char>]<char> */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
block|{
name|diag2
argument_list|(
literal|1
argument_list|,
literal|"Unterminated literal"
argument_list|)
expr_stmt|;
goto|goto
name|stop_lit
goto|;
block|}
name|CHECK_SIZE_TOKEN
expr_stmt|;
comment|/* Only have to do this once in this loop, 					 * since CHECK_SIZE guarantees that there 					 * are at least 5 entries left */
operator|*
name|e_token
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
if|if
condition|(
operator|*
name|e_token
operator|==
name|BACKSLASH
condition|)
block|{
comment|/* if escape, copy extra char */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'\n'
condition|)
comment|/* check for escaped newline */
operator|++
name|line_no
expr_stmt|;
if|if
condition|(
name|troff
condition|)
block|{
operator|*
operator|++
name|e_token
operator|=
name|BACKSLASH
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|BACKSLASH
condition|)
operator|*
operator|++
name|e_token
operator|=
name|BACKSLASH
expr_stmt|;
block|}
operator|*
operator|++
name|e_token
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|++
name|e_token
expr_stmt|;
comment|/* we must increment this again because we 				 * copied two chars */
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
else|else
break|break;
comment|/* we copied one character */
block|}
comment|/* end of while (1) */
block|}
do|while
condition|(
operator|*
name|e_token
operator|++
operator|!=
name|qchar
condition|)
do|;
if|if
condition|(
name|troff
condition|)
block|{
name|e_token
operator|=
name|chfont
argument_list|(
operator|&
name|stringf
argument_list|,
operator|&
name|bodyf
argument_list|,
name|e_token
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|qchar
operator|==
literal|'"'
condition|)
operator|*
name|e_token
operator|++
operator|=
literal|'\''
expr_stmt|;
block|}
name|stop_lit
label|:
name|code
operator|=
name|ident
expr_stmt|;
break|break;
case|case
operator|(
literal|'('
operator|)
case|:
case|case
operator|(
literal|'['
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|lparen
expr_stmt|;
break|break;
case|case
operator|(
literal|')'
operator|)
case|:
case|case
operator|(
literal|']'
operator|)
case|:
name|code
operator|=
name|rparen
expr_stmt|;
break|break;
case|case
literal|'#'
case|:
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|code
operator|=
name|preesc
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|question
expr_stmt|;
break|break;
case|case
operator|(
literal|':'
operator|)
case|:
name|code
operator|=
name|colon
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
case|case
operator|(
literal|';'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|semicolon
expr_stmt|;
break|break;
case|case
operator|(
literal|'{'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
comment|/* 	 * if (ps.in_or_st) ps.block_init = 1; 	 */
comment|/* ?	code = ps.block_init ? lparen : lbrace; */
name|code
operator|=
name|lbrace
expr_stmt|;
break|break;
case|case
operator|(
literal|'}'
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
comment|/* ?	code = ps.block_init ? rparen : rbrace; */
name|code
operator|=
name|rbrace
expr_stmt|;
break|break;
case|case
literal|014
case|:
comment|/* a form feed */
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
name|ps
operator|.
name|last_nl
operator|=
name|true
expr_stmt|;
comment|/* remember this so we can set 'ps.col_1' 				 * right */
name|code
operator|=
name|form_feed
expr_stmt|;
break|break;
case|case
operator|(
literal|','
operator|)
case|:
name|unary_delim
operator|=
name|true
expr_stmt|;
name|code
operator|=
name|comma
expr_stmt|;
break|break;
case|case
literal|'.'
case|:
name|unary_delim
operator|=
name|false
expr_stmt|;
name|code
operator|=
name|period
expr_stmt|;
break|break;
case|case
literal|'-'
case|:
case|case
literal|'+'
case|:
comment|/* check for -, +, --, ++ */
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|*
name|buf_ptr
operator|==
name|token
index|[
literal|0
index|]
condition|)
block|{
comment|/* check for doubled character */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
comment|/* buffer overflow will be checked at end of loop */
if|if
condition|(
name|last_code
operator|==
name|ident
operator|||
name|last_code
operator|==
name|rparen
condition|)
block|{
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|postop
operator|)
expr_stmt|;
comment|/* check for following ++ or -- */
name|unary_delim
operator|=
name|false
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
comment|/* check for operator += */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
elseif|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'>'
condition|)
block|{
comment|/* check for operator -> */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|!
name|pointer_as_binop
condition|)
block|{
name|unary_delim
operator|=
name|false
expr_stmt|;
name|code
operator|=
name|unary_op
expr_stmt|;
name|ps
operator|.
name|want_blank
operator|=
name|false
expr_stmt|;
block|}
block|}
break|break;
comment|/* buffer overflow will be checked at end of 				 * switch */
case|case
literal|'='
case|:
if|if
condition|(
name|ps
operator|.
name|in_or_st
condition|)
name|ps
operator|.
name|block_init
operator|=
literal|1
expr_stmt|;
ifdef|#
directive|ifdef
name|undef
if|if
condition|(
name|chartype
index|[
operator|*
name|buf_ptr
index|]
operator|==
name|opchar
condition|)
block|{
comment|/* we have two char assignment */
name|e_token
index|[
operator|-
literal|1
index|]
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
if|if
condition|(
operator|(
name|e_token
index|[
operator|-
literal|1
index|]
operator|==
literal|'<'
operator|||
name|e_token
index|[
operator|-
literal|1
index|]
operator|==
literal|'>'
operator|)
operator|&&
name|e_token
index|[
operator|-
literal|1
index|]
operator|==
operator|*
name|buf_ptr
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|++
operator|=
literal|'='
expr_stmt|;
comment|/* Flip =+ to += */
operator|*
name|e_token
operator|=
literal|0
expr_stmt|;
block|}
else|#
directive|else
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
comment|/* == */
operator|*
name|e_token
operator|++
operator|=
literal|'='
expr_stmt|;
comment|/* Flip =+ to += */
name|buf_ptr
operator|++
expr_stmt|;
operator|*
name|e_token
operator|=
literal|0
expr_stmt|;
block|}
endif|#
directive|endif
name|code
operator|=
name|binary_op
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
comment|/* can drop thru!!! */
case|case
literal|'>'
case|:
case|case
literal|'<'
case|:
case|case
literal|'!'
case|:
comment|/* ops like<,<<,<=, !=, etc */
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'>'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'<'
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
operator|++
expr_stmt|;
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
break|break;
default|default:
if|if
condition|(
name|token
index|[
literal|0
index|]
operator|==
literal|'/'
operator|&&
operator|*
name|buf_ptr
operator|==
literal|'*'
condition|)
block|{
comment|/* it is start of comment */
operator|*
name|e_token
operator|++
operator|=
literal|'*'
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
name|code
operator|=
name|comment
expr_stmt|;
name|unary_delim
operator|=
name|ps
operator|.
name|last_u_d
expr_stmt|;
break|break;
block|}
while|while
condition|(
operator|*
operator|(
name|e_token
operator|-
literal|1
operator|)
operator|==
operator|*
name|buf_ptr
operator|||
operator|*
name|buf_ptr
operator|==
literal|'='
condition|)
block|{
comment|/* 	     * handle ||,&&, etc, and also things as in int *****i 	     */
operator|*
name|e_token
operator|++
operator|=
operator|*
name|buf_ptr
expr_stmt|;
if|if
condition|(
operator|++
name|buf_ptr
operator|>=
name|buf_end
condition|)
name|fill_buffer
argument_list|()
expr_stmt|;
block|}
name|code
operator|=
operator|(
name|ps
operator|.
name|last_u_d
condition|?
name|unary_op
else|:
name|binary_op
operator|)
expr_stmt|;
name|unary_delim
operator|=
name|true
expr_stmt|;
block|}
comment|/* end of switch */
if|if
condition|(
name|code
operator|!=
name|newline
condition|)
block|{
name|l_struct
operator|=
name|false
expr_stmt|;
name|last_code
operator|=
name|code
expr_stmt|;
block|}
if|if
condition|(
name|buf_ptr
operator|>=
name|buf_end
condition|)
comment|/* check for input buffer empty */
name|fill_buffer
argument_list|()
expr_stmt|;
name|ps
operator|.
name|last_u_d
operator|=
name|unary_delim
expr_stmt|;
operator|*
name|e_token
operator|=
literal|'\0'
expr_stmt|;
comment|/* null terminate the token */
return|return
operator|(
name|code
operator|)
return|;
block|}
end_function

begin_function
name|void
name|alloc_typenames
parameter_list|(
name|void
parameter_list|)
block|{
name|typenames
operator|=
operator|(
specifier|const
name|char
operator|*
operator|*
operator|)
name|malloc
argument_list|(
sizeof|sizeof
argument_list|(
name|typenames
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|typename_count
operator|=
literal|16
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenames
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

begin_function
name|void
name|add_typename
parameter_list|(
specifier|const
name|char
modifier|*
name|key
parameter_list|)
block|{
name|int
name|comparison
decl_stmt|;
specifier|const
name|char
modifier|*
name|copy
decl_stmt|;
if|if
condition|(
name|typename_top
operator|+
literal|1
operator|>=
name|typename_count
condition|)
block|{
name|typenames
operator|=
name|realloc
argument_list|(
operator|(
name|void
operator|*
operator|)
name|typenames
argument_list|,
sizeof|sizeof
argument_list|(
name|typenames
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
name|typename_count
operator|*=
literal|2
operator|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|typenames
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|typename_top
operator|==
operator|-
literal|1
condition|)
name|typenames
index|[
operator|++
name|typename_top
index|]
operator|=
name|copy
operator|=
name|strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|comparison
operator|=
name|strcmp
argument_list|(
name|key
argument_list|,
name|typenames
index|[
name|typename_top
index|]
argument_list|)
operator|)
operator|>=
literal|0
condition|)
block|{
comment|/* take advantage of sorted input */
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
comment|/* remove duplicates */
return|return;
name|typenames
index|[
operator|++
name|typename_top
index|]
operator|=
name|copy
operator|=
name|strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|int
name|p
decl_stmt|;
for|for
control|(
name|p
operator|=
literal|0
init|;
operator|(
name|comparison
operator|=
name|strcmp
argument_list|(
name|key
argument_list|,
name|typenames
index|[
name|p
index|]
argument_list|)
operator|)
operator|>
literal|0
condition|;
name|p
operator|++
control|)
comment|/* find place for the new key */
empty_stmt|;
if|if
condition|(
name|comparison
operator|==
literal|0
condition|)
comment|/* remove duplicates */
return|return;
name|memmove
argument_list|(
operator|&
name|typenames
index|[
name|p
operator|+
literal|1
index|]
argument_list|,
operator|&
name|typenames
index|[
name|p
index|]
argument_list|,
sizeof|sizeof
argument_list|(
name|typenames
index|[
literal|0
index|]
argument_list|)
operator|*
operator|(
operator|++
name|typename_top
operator|-
name|p
operator|)
argument_list|)
expr_stmt|;
name|typenames
index|[
name|p
index|]
operator|=
name|copy
operator|=
name|strdup
argument_list|(
name|key
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|copy
operator|==
name|NULL
condition|)
name|err
argument_list|(
literal|1
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

