begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * compress routines:  *	is_compress() returns 0 if uncompressed, number of bits if compressed.  *	uncompress(old, n, newch) - uncompress old into new, return sizeof new  * compress.c,v 1.1 1993/06/10 00:38:05 jtc Exp  */
end_comment

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_include
include|#
directive|include
file|<unistd.h>
end_include

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<sys/wait.h>
end_include

begin_include
include|#
directive|include
file|"file.h"
end_include

begin_comment
comment|/* Check for compression, return nbits. Algorithm, in magic(4) format:  * 0       string          \037\235        compressed data  *>2      byte&0x80>0              block compressed  *>2      byte&0x1f       x               %d bits  */
end_comment

begin_function
name|int
name|is_compress
parameter_list|(
name|p
parameter_list|,
name|b
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|p
decl_stmt|;
name|int
modifier|*
name|b
decl_stmt|;
block|{
if|if
condition|(
operator|*
name|p
operator|!=
literal|'\037'
operator|||
operator|*
operator|(
comment|/*signed*/
name|char
operator|*
operator|)
operator|(
name|p
operator|+
literal|1
operator|)
operator|!=
literal|'\235'
condition|)
return|return
literal|0
return|;
comment|/* not compress()ed */
operator|*
name|b
operator|=
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|&
literal|0x80
expr_stmt|;
return|return
operator|*
operator|(
name|p
operator|+
literal|2
operator|)
operator|&
literal|0x1f
return|;
block|}
end_function

begin_function
name|int
name|uncompress
parameter_list|(
name|old
parameter_list|,
name|newch
parameter_list|,
name|n
parameter_list|)
specifier|const
name|unsigned
name|char
modifier|*
name|old
decl_stmt|;
name|unsigned
name|char
modifier|*
modifier|*
name|newch
decl_stmt|;
name|int
name|n
decl_stmt|;
block|{
name|int
name|fdin
index|[
literal|2
index|]
decl_stmt|,
name|fdout
index|[
literal|2
index|]
decl_stmt|;
if|if
condition|(
name|pipe
argument_list|(
name|fdin
argument_list|)
operator|==
operator|-
literal|1
operator|||
name|pipe
argument_list|(
name|fdout
argument_list|)
operator|==
operator|-
literal|1
condition|)
block|{
name|error
argument_list|(
literal|"cannot create pipe (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
switch|switch
condition|(
name|fork
argument_list|()
condition|)
block|{
case|case
literal|0
case|:
comment|/* child */
operator|(
name|void
operator|)
name|close
argument_list|(
literal|0
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|fdin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdin
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
literal|1
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|dup
argument_list|(
name|fdout
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdout
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdout
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
name|execlp
argument_list|(
literal|"uncompress"
argument_list|,
literal|"uncompress"
argument_list|,
literal|"-c"
argument_list|,
name|NULL
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"could not execute `uncompress' (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
case|case
operator|-
literal|1
case|:
name|error
argument_list|(
literal|"could not fork (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
default|default:
comment|/* parent */
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdin
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdout
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|write
argument_list|(
name|fdin
index|[
literal|1
index|]
argument_list|,
name|old
argument_list|,
name|n
argument_list|)
operator|!=
name|n
condition|)
block|{
name|error
argument_list|(
literal|"write failed (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdin
index|[
literal|1
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
operator|*
name|newch
operator|=
operator|(
name|unsigned
name|char
operator|*
operator|)
name|malloc
argument_list|(
name|n
argument_list|)
operator|)
operator|==
name|NULL
condition|)
block|{
name|error
argument_list|(
literal|"out of memory.\n"
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
if|if
condition|(
operator|(
name|n
operator|=
name|read
argument_list|(
name|fdout
index|[
literal|0
index|]
argument_list|,
operator|*
name|newch
argument_list|,
name|n
argument_list|)
operator|)
operator|<=
literal|0
condition|)
block|{
name|free
argument_list|(
operator|*
name|newch
argument_list|)
expr_stmt|;
name|error
argument_list|(
literal|"read failed (%s).\n"
argument_list|,
name|strerror
argument_list|(
name|errno
argument_list|)
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
operator|(
name|void
operator|)
name|close
argument_list|(
name|fdout
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
operator|(
name|void
operator|)
name|wait
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
return|return
name|n
return|;
block|}
block|}
end_function

end_unit

