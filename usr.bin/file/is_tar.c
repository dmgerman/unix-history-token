begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*  * is_tar() -- figure out whether file is a tar archive.  *  * Stolen (by the author!) from the public domain tar program:  * Pubic Domain version written 26 Aug 1985 John Gilmore (ihnp4!hoptoad!gnu).  *  * @(#)list.c 1.18 9/23/86 Public Domain - gnu  * $Id$  *  * Comments changed and some code/comments reformatted  * for file command by Ian Darwin.  */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_include
include|#
directive|include
file|<ctype.h>
end_include

begin_include
include|#
directive|include
file|<sys/types.h>
end_include

begin_include
include|#
directive|include
file|"tar.h"
end_include

begin_define
define|#
directive|define
name|isodigit
parameter_list|(
name|c
parameter_list|)
value|( ((c)>= '0')&& ((c)<= '7') )
end_define

begin_if
if|#
directive|if
name|defined
argument_list|(
name|__STDC__
argument_list|)
operator|||
name|defined
argument_list|(
name|__cplusplus
argument_list|)
end_if

begin_function_decl
specifier|static
name|long
name|from_oct
parameter_list|(
name|int
parameter_list|,
name|char
modifier|*
parameter_list|)
function_decl|;
end_function_decl

begin_comment
comment|/* Decode octal number */
end_comment

begin_else
else|#
directive|else
end_else

begin_function_decl
specifier|static
name|long
name|from_oct
parameter_list|()
function_decl|;
end_function_decl

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/*  * Return  *	0 if the checksum is bad (i.e., probably not a tar archive),  *	1 for old UNIX tar file,  *	2 for Unix Std (POSIX) tar file.  */
end_comment

begin_function
name|int
name|is_tar
parameter_list|(
name|buf
parameter_list|,
name|nbytes
parameter_list|)
name|unsigned
name|char
modifier|*
name|buf
decl_stmt|;
name|int
name|nbytes
decl_stmt|;
block|{
specifier|register
name|union
name|record
modifier|*
name|header
init|=
operator|(
expr|union
name|record
operator|*
operator|)
name|buf
decl_stmt|;
specifier|register
name|int
name|i
decl_stmt|;
specifier|register
name|long
name|sum
decl_stmt|,
name|recsum
decl_stmt|;
specifier|register
name|char
modifier|*
name|p
decl_stmt|;
if|if
condition|(
name|nbytes
operator|<
sizeof|sizeof
argument_list|(
expr|union
name|record
argument_list|)
condition|)
return|return
literal|0
return|;
name|recsum
operator|=
name|from_oct
argument_list|(
literal|8
argument_list|,
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|)
expr_stmt|;
name|sum
operator|=
literal|0
expr_stmt|;
name|p
operator|=
name|header
operator|->
name|charptr
expr_stmt|;
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
expr|union
name|record
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
block|{
comment|/* 		 * We can't use unsigned char here because of old compilers, 		 * e.g. V7. 		 */
name|sum
operator|+=
literal|0xFF
operator|&
operator|*
name|p
operator|++
expr_stmt|;
block|}
comment|/* Adjust checksum to count the "chksum" field as blanks. */
for|for
control|(
name|i
operator|=
sizeof|sizeof
argument_list|(
name|header
operator|->
name|header
operator|.
name|chksum
argument_list|)
init|;
operator|--
name|i
operator|>=
literal|0
condition|;
control|)
name|sum
operator|-=
literal|0xFF
operator|&
name|header
operator|->
name|header
operator|.
name|chksum
index|[
name|i
index|]
expr_stmt|;
name|sum
operator|+=
literal|' '
operator|*
sizeof|sizeof
name|header
operator|->
name|header
operator|.
name|chksum
expr_stmt|;
if|if
condition|(
name|sum
operator|!=
name|recsum
condition|)
return|return
literal|0
return|;
comment|/* Not a tar archive */
if|if
condition|(
literal|0
operator|==
name|strcmp
argument_list|(
name|header
operator|->
name|header
operator|.
name|magic
argument_list|,
name|TMAGIC
argument_list|)
condition|)
return|return
literal|2
return|;
comment|/* Unix Standard tar archive */
return|return
literal|1
return|;
comment|/* Old fashioned tar archive */
block|}
end_function

begin_comment
comment|/*  * Quick and dirty octal conversion.  *  * Result is -1 if the field is invalid (all blank, or nonoctal).  */
end_comment

begin_function
specifier|static
name|long
name|from_oct
parameter_list|(
name|digs
parameter_list|,
name|where
parameter_list|)
specifier|register
name|int
name|digs
decl_stmt|;
specifier|register
name|char
modifier|*
name|where
decl_stmt|;
block|{
specifier|register
name|long
name|value
decl_stmt|;
while|while
condition|(
name|isspace
argument_list|(
operator|*
name|where
argument_list|)
condition|)
block|{
comment|/* Skip spaces */
name|where
operator|++
expr_stmt|;
if|if
condition|(
operator|--
name|digs
operator|<=
literal|0
condition|)
return|return
operator|-
literal|1
return|;
comment|/* All blank field */
block|}
name|value
operator|=
literal|0
expr_stmt|;
while|while
condition|(
name|digs
operator|>
literal|0
operator|&&
name|isodigit
argument_list|(
operator|*
name|where
argument_list|)
condition|)
block|{
comment|/* Scan til nonoctal */
name|value
operator|=
operator|(
name|value
operator|<<
literal|3
operator|)
operator||
operator|(
operator|*
name|where
operator|++
operator|-
literal|'0'
operator|)
expr_stmt|;
operator|--
name|digs
expr_stmt|;
block|}
if|if
condition|(
name|digs
operator|>
literal|0
operator|&&
operator|*
name|where
operator|&&
operator|!
name|isspace
argument_list|(
operator|*
name|where
argument_list|)
condition|)
return|return
operator|-
literal|1
return|;
comment|/* Ended on non-space/nul */
return|return
name|value
return|;
block|}
end_function

end_unit

