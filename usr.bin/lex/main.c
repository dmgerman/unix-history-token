begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson of Lawrence Berkeley Laboratory.  *   * The United States Government has rights in this work pursuant   * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms, with or without  * modification, are permitted provided that the following conditions  * are met:  * 1. Redistributions of source code must retain the above copyright  *    notice, this list of conditions and the following disclaimer.  * 2. Redistributions in binary form must reproduce the above copyright  *    notice, this list of conditions and the following disclaimer in the  *    documentation and/or other materials provided with the distribution.  * 3. All advertising materials mentioning features or use of this software  *    must display the following acknowledgement:  *	This product includes software developed by the University of  *	California, Berkeley and its contributors.  * 4. Neither the name of the University nor the names of its contributors  *    may be used to endorse or promote products derived from this software  *    without specific prior written permission.  *  * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND  * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE  * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE  * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL  * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS  * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)  * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT  * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY  * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF  * SUCH DAMAGE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1990 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
name|char
name|sccsid
index|[]
init|=
literal|"@(#)main.c	5.3 (Berkeley) 6/18/90"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* flex - tool to generate fast lexical analyzers */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_include
include|#
directive|include
file|"pathnames.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|flex_version
index|[]
init|=
literal|"2.3"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|flexinit
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|readin
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_up_initial_allocations
name|PROTO
argument_list|(
operator|(
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* these globals are all defined and commented in flexdef.h */
end_comment

begin_decl_stmt
name|int
name|printstats
decl_stmt|,
name|syntaxerror
decl_stmt|,
name|eofseen
decl_stmt|,
name|ddebug
decl_stmt|,
name|trace
decl_stmt|,
name|spprdflt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interactive
decl_stmt|,
name|caseins
decl_stmt|,
name|useecs
decl_stmt|,
name|fulltbl
decl_stmt|,
name|usemecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fullspd
decl_stmt|,
name|gen_line_dirs
decl_stmt|,
name|performance_report
decl_stmt|,
name|backtrack_report
decl_stmt|,
name|csize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yymore_used
decl_stmt|,
name|reject
decl_stmt|,
name|real_reject
decl_stmt|,
name|continued_action
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yymore_really_used
decl_stmt|,
name|reject_really_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datapos
decl_stmt|,
name|dataline
decl_stmt|,
name|linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|skelfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infilename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onestate
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onesym
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onenext
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onedef
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onesp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_mns
decl_stmt|,
name|num_rules
decl_stmt|,
name|current_max_rules
decl_stmt|,
name|lastnfa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|firstst
decl_stmt|,
modifier|*
name|lastst
decl_stmt|,
modifier|*
name|finalst
decl_stmt|,
modifier|*
name|transchar
decl_stmt|,
modifier|*
name|trans1
decl_stmt|,
modifier|*
name|trans2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|accptnum
decl_stmt|,
modifier|*
name|assoc_rule
decl_stmt|,
modifier|*
name|state_type
decl_stmt|,
modifier|*
name|rule_type
decl_stmt|,
modifier|*
name|rule_linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_state_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|variable_trailing_context_rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numtemps
decl_stmt|,
name|numprots
decl_stmt|,
name|protprev
index|[
name|MSP
index|]
decl_stmt|,
name|protnext
index|[
name|MSP
index|]
decl_stmt|,
name|prottbl
index|[
name|MSP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|protcomst
index|[
name|MSP
index|]
decl_stmt|,
name|firstprot
decl_stmt|,
name|lastprot
decl_stmt|,
name|protsave
index|[
name|PROT_SAVE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numecs
decl_stmt|,
name|nextecm
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|ecgroup
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|nummecs
decl_stmt|,
name|tecfwd
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tecbck
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|xlation
init|=
operator|(
name|int
operator|*
operator|)
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_xlations
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastsc
decl_stmt|,
name|current_max_scs
decl_stmt|,
modifier|*
name|scset
decl_stmt|,
modifier|*
name|scbol
decl_stmt|,
modifier|*
name|scxclu
decl_stmt|,
modifier|*
name|sceof
decl_stmt|,
modifier|*
name|actvsc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|scname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_dfa_size
decl_stmt|,
name|current_max_xpairs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_template_xpairs
decl_stmt|,
name|current_max_dfas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastdfa
decl_stmt|,
modifier|*
name|nxt
decl_stmt|,
modifier|*
name|chk
decl_stmt|,
modifier|*
name|tnxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|base
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|nultrans
decl_stmt|,
name|NUL_ec
decl_stmt|,
name|tblend
decl_stmt|,
name|firstfree
decl_stmt|,
modifier|*
modifier|*
name|dss
decl_stmt|,
modifier|*
name|dfasiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|dfaacc_union
modifier|*
name|dfaacc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|accsiz
decl_stmt|,
modifier|*
name|dhash
decl_stmt|,
name|numas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numsnpairs
decl_stmt|,
name|jambase
decl_stmt|,
name|jamstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastccl
decl_stmt|,
name|current_maxccls
decl_stmt|,
modifier|*
name|cclmap
decl_stmt|,
modifier|*
name|ccllen
decl_stmt|,
modifier|*
name|cclng
decl_stmt|,
name|cclreuse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_ccl_tbl_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|ccltbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|starttime
decl_stmt|,
modifier|*
name|endtime
decl_stmt|,
name|nmstr
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sectnum
decl_stmt|,
name|nummt
decl_stmt|,
name|hshcol
decl_stmt|,
name|dfaeql
decl_stmt|,
name|numeps
decl_stmt|,
name|eps2
decl_stmt|,
name|num_reallocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tmpuses
decl_stmt|,
name|totnst
decl_stmt|,
name|peakpairs
decl_stmt|,
name|numuniq
decl_stmt|,
name|numdup
decl_stmt|,
name|hshsave
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_backtracking
decl_stmt|,
name|bol_needed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|temp_action_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|backtrack_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|end_of_buffer_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|action_file_name
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|input_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_input_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|program_name
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_FILE_NAMES
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile
init|=
literal|"lex.yy.c"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile
init|=
literal|"lexyy.c"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|int
name|outfile_created
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|use_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skelname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|flexinit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|readin
argument_list|()
expr_stmt|;
if|if
condition|(
name|syntaxerror
condition|)
name|flexend
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_really_used
operator|==
name|REALLY_USED
condition|)
name|yymore_used
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|yymore_really_used
operator|==
name|REALLY_NOT_USED
condition|)
name|yymore_used
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|reject_really_used
operator|==
name|REALLY_USED
condition|)
name|reject
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|reject_really_used
operator|==
name|REALLY_NOT_USED
condition|)
name|reject
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|performance_report
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"-I (interactive) entails a minor performance penalty\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"yymore() entails a minor performance penalty\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"REJECT entails a large performance penalty\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"Variable trailing context rules entail a large performance penalty\n"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
name|real_reject
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
name|reject
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|fulltbl
operator|||
name|fullspd
operator|)
operator|&&
name|reject
condition|)
block|{
if|if
condition|(
name|real_reject
condition|)
name|flexerror
argument_list|(
literal|"REJECT cannot be used with -f or -F"
argument_list|)
expr_stmt|;
else|else
name|flexerror
argument_list|(
literal|"variable trailing context rules cannot be used with -f or -F"
argument_list|)
expr_stmt|;
block|}
name|ntod
argument_list|()
expr_stmt|;
comment|/* generate the C state transition tables from the DFA */
name|make_tables
argument_list|()
expr_stmt|;
comment|/* note, flexend does not return.  It exits with its argument as status. */
name|flexend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
comment|/*NOTREACHED*/
block|}
end_function

begin_comment
comment|/* flexend - terminate flex  *  * synopsis  *    int status;  *    flexend( status );  *  *    status is exit status.  *  * note  *    This routine does not return.  */
end_comment

begin_function
name|void
name|flexend
parameter_list|(
name|status
parameter_list|)
name|int
name|status
decl_stmt|;
block|{
name|int
name|tblsiz
decl_stmt|;
name|char
modifier|*
name|flex_gettime
parameter_list|()
function_decl|;
if|if
condition|(
name|skelfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|skelfile
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when writing skeleton file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|skelfile
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when closing skeleton file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|temp_action_file
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|temp_action_file
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when writing temporary action file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|temp_action_file
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when closing temporary action file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|action_file_name
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when deleting temporary action file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|status
operator|!=
literal|0
operator|&&
name|outfile_created
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when writing output file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when closing output file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|outfile
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when deleting output file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backtrack_report
operator|&&
name|backtrack_file
condition|)
block|{
if|if
condition|(
name|num_backtracking
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|backtrack_file
argument_list|,
literal|"No backtracking.\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|fprintf
argument_list|(
name|backtrack_file
argument_list|,
literal|"%d backtracking (non-accepting) states.\n"
argument_list|,
name|num_backtracking
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|backtrack_file
argument_list|,
literal|"Compressed tables always backtrack.\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|backtrack_file
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when writing backtracking file"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|backtrack_file
argument_list|)
condition|)
name|flexfatal
argument_list|(
literal|"error occurred when closing backtracking file"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printstats
condition|)
block|{
name|endtime
operator|=
name|flex_gettime
argument_list|()
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s version %s usage statistics:\n"
argument_list|,
name|program_name
argument_list|,
name|flex_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  started at %s, finished at %s\n"
argument_list|,
name|starttime
argument_list|,
name|endtime
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  scanner options: -"
argument_list|)
expr_stmt|;
if|if
condition|(
name|backtrack_report
condition|)
name|putc
argument_list|(
literal|'b'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|putc
argument_list|(
literal|'d'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|putc
argument_list|(
literal|'I'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|caseins
condition|)
name|putc
argument_list|(
literal|'i'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gen_line_dirs
condition|)
name|putc
argument_list|(
literal|'L'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|performance_report
condition|)
name|putc
argument_list|(
literal|'p'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spprdflt
condition|)
name|putc
argument_list|(
literal|'s'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_stdout
condition|)
name|putc
argument_list|(
literal|'t'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|putc
argument_list|(
literal|'T'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|printstats
condition|)
name|putc
argument_list|(
literal|'v'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* always true! */
if|if
condition|(
name|csize
operator|==
literal|256
condition|)
name|putc
argument_list|(
literal|'8'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
condition|)
name|putc
argument_list|(
literal|'f'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
name|putc
argument_list|(
literal|'F'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|putc
argument_list|(
literal|'e'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
name|putc
argument_list|(
literal|'m'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|skelname
argument_list|,
name|_PATH_SKELETONFILE
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -S%s"
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d NFA states\n"
argument_list|,
name|lastnfa
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d DFA states (%d words)\n"
argument_list|,
name|lastdfa
argument_list|,
name|current_max_dfas
argument_list|,
name|totnst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d rules\n"
argument_list|,
name|num_rules
operator|-
literal|1
comment|/* - 1 for def. rule */
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backtracking
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  No backtracking\n"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d backtracking (non-accepting) states\n"
argument_list|,
name|num_backtracking
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  compressed tables always backtrack\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  Beginning-of-line patterns used\n"
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d start conditions\n"
argument_list|,
name|lastsc
argument_list|,
name|current_max_scs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d epsilon states, %d double epsilon states\n"
argument_list|,
name|numeps
argument_list|,
name|eps2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastccl
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  no character classes\n"
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d character classes needed %d/%d words of storage, %d reused\n"
argument_list|,
name|lastccl
argument_list|,
name|current_maxccls
argument_list|,
name|cclmap
index|[
name|lastccl
index|]
operator|+
name|ccllen
index|[
name|lastccl
index|]
argument_list|,
name|current_max_ccl_tbl_size
argument_list|,
name|cclreuse
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d state/nextstate pairs created\n"
argument_list|,
name|numsnpairs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d unique/duplicate transitions\n"
argument_list|,
name|numuniq
argument_list|,
name|numdup
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
condition|)
block|{
name|tblsiz
operator|=
name|lastdfa
operator|*
name|numecs
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d table entries\n"
argument_list|,
name|tblsiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tblsiz
operator|=
literal|2
operator|*
operator|(
name|lastdfa
operator|+
name|numtemps
operator|)
operator|+
literal|2
operator|*
name|tblend
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d base-def entries created\n"
argument_list|,
name|lastdfa
operator|+
name|numtemps
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d (peak %d) nxt-chk entries created\n"
argument_list|,
name|tblend
argument_list|,
name|current_max_xpairs
argument_list|,
name|peakpairs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d (peak %d) template nxt-chk entries created\n"
argument_list|,
name|numtemps
operator|*
name|nummecs
argument_list|,
name|current_max_template_xpairs
argument_list|,
name|numtemps
operator|*
name|numecs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d empty table entries\n"
argument_list|,
name|nummt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d protos created\n"
argument_list|,
name|numprots
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d templates created, %d uses\n"
argument_list|,
name|numtemps
argument_list|,
name|tmpuses
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useecs
condition|)
block|{
name|tblsiz
operator|=
name|tblsiz
operator|+
name|csize
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d equivalence classes created\n"
argument_list|,
name|numecs
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usemecs
condition|)
block|{
name|tblsiz
operator|=
name|tblsiz
operator|+
name|numecs
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d/%d meta-equivalence classes created\n"
argument_list|,
name|nummecs
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d (%d saved) hash collisions, %d DFAs equal\n"
argument_list|,
name|hshcol
argument_list|,
name|hshsave
argument_list|,
name|dfaeql
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d sets of reallocations needed\n"
argument_list|,
name|num_reallocs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  %d total table entries needed\n"
argument_list|,
name|tblsiz
argument_list|)
expr_stmt|;
block|}
ifndef|#
directive|ifndef
name|VMS
name|exit
argument_list|(
name|status
argument_list|)
expr_stmt|;
else|#
directive|else
name|exit
argument_list|(
name|status
operator|+
literal|1
argument_list|)
expr_stmt|;
endif|#
directive|endif
block|}
end_function

begin_comment
comment|/* flexinit - initialize flex  *  * synopsis  *    int argc;  *    char **argv;  *    flexinit( argc, argv );  */
end_comment

begin_function
name|void
name|flexinit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|sawcmpflag
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|,
modifier|*
name|flex_gettime
argument_list|()
decl_stmt|,
modifier|*
name|mktemp
argument_list|()
decl_stmt|;
name|printstats
operator|=
name|syntaxerror
operator|=
name|trace
operator|=
name|spprdflt
operator|=
name|interactive
operator|=
name|caseins
operator|=
name|false
expr_stmt|;
name|backtrack_report
operator|=
name|performance_report
operator|=
name|ddebug
operator|=
name|fulltbl
operator|=
name|fullspd
operator|=
name|false
expr_stmt|;
name|yymore_used
operator|=
name|continued_action
operator|=
name|reject
operator|=
name|false
expr_stmt|;
name|yymore_really_used
operator|=
name|reject_really_used
operator|=
name|false
expr_stmt|;
name|gen_line_dirs
operator|=
name|usemecs
operator|=
name|useecs
operator|=
name|true
expr_stmt|;
name|sawcmpflag
operator|=
name|false
expr_stmt|;
name|use_stdout
operator|=
name|false
expr_stmt|;
name|csize
operator|=
name|DEFAULT_CSIZE
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
comment|/* read flags */
for|for
control|(
operator|--
name|argc
operator|,
operator|++
name|argv
init|;
name|argc
condition|;
operator|--
name|argc
operator|,
operator|++
name|argv
control|)
block|{
if|if
condition|(
name|argv
index|[
literal|0
index|]
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|argv
index|[
literal|0
index|]
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
name|arg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|arg
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'b'
case|:
name|backtrack_report
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s: Assuming use of deprecated -c flag is really intended to be -C\n"
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
comment|/* fall through */
case|case
literal|'C'
case|:
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|flexerror
argument_list|(
literal|"-C flag must be given separately"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sawcmpflag
condition|)
block|{
name|useecs
operator|=
name|false
expr_stmt|;
name|usemecs
operator|=
name|false
expr_stmt|;
name|fulltbl
operator|=
name|false
expr_stmt|;
name|sawcmpflag
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
operator|++
name|i
init|;
name|arg
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'e'
case|:
name|useecs
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fullspd
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fulltbl
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|usemecs
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|lerrif
argument_list|(
literal|"unknown -C option '%c'"
argument_list|,
operator|(
name|int
operator|)
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|get_next_arg
goto|;
case|case
literal|'d'
case|:
name|ddebug
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|useecs
operator|=
name|usemecs
operator|=
name|false
expr_stmt|;
name|fulltbl
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|useecs
operator|=
name|usemecs
operator|=
name|false
expr_stmt|;
name|fullspd
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'I'
case|:
name|interactive
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|caseins
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|gen_line_dirs
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* stupid do-nothing deprecated option */
break|break;
case|case
literal|'p'
case|:
name|performance_report
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|flexerror
argument_list|(
literal|"-S flag must be given separately"
argument_list|)
expr_stmt|;
name|skelname
operator|=
name|arg
operator|+
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|get_next_arg
goto|;
case|case
literal|'s'
case|:
name|spprdflt
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|use_stdout
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|trace
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printstats
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|csize
operator|=
name|CSIZE
expr_stmt|;
break|break;
default|default:
name|lerrif
argument_list|(
literal|"unknown flag '%c'"
argument_list|,
operator|(
name|int
operator|)
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
name|get_next_arg
label|:
comment|/* used by -C and -S flags in lieu of a "continue 2" control */
empty_stmt|;
block|}
if|if
condition|(
operator|(
name|fulltbl
operator|||
name|fullspd
operator|)
operator|&&
name|usemecs
condition|)
name|flexerror
argument_list|(
literal|"full table and -Cm don't make sense together"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|(
name|fulltbl
operator|||
name|fullspd
operator|)
operator|&&
name|interactive
condition|)
name|flexerror
argument_list|(
literal|"full table and -I are (currently) incompatible"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
operator|&&
name|fullspd
condition|)
name|flexerror
argument_list|(
literal|"full table and -F are mutually exclusive"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|skelname
condition|)
block|{
specifier|static
name|char
name|skeleton_name_storage
index|[
literal|400
index|]
decl_stmt|;
name|skelname
operator|=
name|skeleton_name_storage
expr_stmt|;
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|skelname
argument_list|,
name|_PATH_SKELETONFILE
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|use_stdout
condition|)
block|{
name|FILE
modifier|*
name|prev_stdout
init|=
name|freopen
argument_list|(
name|outfile
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
decl_stmt|;
if|if
condition|(
name|prev_stdout
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
literal|"could not create %s"
argument_list|,
name|outfile
argument_list|)
expr_stmt|;
name|outfile_created
operator|=
literal|1
expr_stmt|;
block|}
name|num_input_files
operator|=
name|argc
expr_stmt|;
name|input_files
operator|=
name|argv
expr_stmt|;
name|set_input_file
argument_list|(
name|num_input_files
operator|>
literal|0
condition|?
name|input_files
index|[
literal|0
index|]
else|:
name|NULL
argument_list|)
expr_stmt|;
if|if
condition|(
name|backtrack_report
condition|)
block|{
ifndef|#
directive|ifndef
name|SHORT_FILE_NAMES
name|backtrack_file
operator|=
name|fopen
argument_list|(
literal|"lex.backtrack"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
else|#
directive|else
name|backtrack_file
operator|=
name|fopen
argument_list|(
literal|"lex.bck"
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|backtrack_file
operator|==
name|NULL
condition|)
name|flexerror
argument_list|(
literal|"could not create lex.backtrack"
argument_list|)
expr_stmt|;
block|}
else|else
name|backtrack_file
operator|=
name|NULL
expr_stmt|;
name|lastccl
operator|=
literal|0
expr_stmt|;
name|lastsc
operator|=
literal|0
expr_stmt|;
comment|/* initialize the statistics */
name|starttime
operator|=
name|flex_gettime
argument_list|()
expr_stmt|;
if|if
condition|(
operator|(
name|skelfile
operator|=
name|fopen
argument_list|(
name|skelname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
literal|"can't open skeleton file %s"
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
ifdef|#
directive|ifdef
name|SYS_V
name|action_file_name
operator|=
name|tmpnam
argument_list|(
name|NULL
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|action_file_name
operator|==
name|NULL
condition|)
block|{
specifier|static
name|char
name|temp_action_file_name
index|[
literal|32
index|]
decl_stmt|;
ifndef|#
directive|ifndef
name|SHORT_FILE_NAMES
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|temp_action_file_name
argument_list|,
literal|"/tmp/flexXXXXXX"
argument_list|)
expr_stmt|;
else|#
directive|else
operator|(
name|void
operator|)
name|strcpy
argument_list|(
name|temp_action_file_name
argument_list|,
literal|"flexXXXXXX.tmp"
argument_list|)
expr_stmt|;
endif|#
directive|endif
operator|(
name|void
operator|)
name|mktemp
argument_list|(
name|temp_action_file_name
argument_list|)
expr_stmt|;
name|action_file_name
operator|=
name|temp_action_file_name
expr_stmt|;
block|}
if|if
condition|(
operator|(
name|temp_action_file
operator|=
name|fopen
argument_list|(
name|action_file_name
argument_list|,
literal|"w"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
literal|"can't open temporary action file %s"
argument_list|,
name|action_file_name
argument_list|)
expr_stmt|;
name|lastdfa
operator|=
name|lastnfa
operator|=
name|num_rules
operator|=
name|numas
operator|=
name|numsnpairs
operator|=
name|tmpuses
operator|=
literal|0
expr_stmt|;
name|numecs
operator|=
name|numeps
operator|=
name|eps2
operator|=
name|num_reallocs
operator|=
name|hshcol
operator|=
name|dfaeql
operator|=
name|totnst
operator|=
literal|0
expr_stmt|;
name|numuniq
operator|=
name|numdup
operator|=
name|hshsave
operator|=
name|eofseen
operator|=
name|datapos
operator|=
name|dataline
operator|=
literal|0
expr_stmt|;
name|num_backtracking
operator|=
name|onesp
operator|=
name|numprots
operator|=
literal|0
expr_stmt|;
name|variable_trailing_context_rules
operator|=
name|bol_needed
operator|=
name|false
expr_stmt|;
name|linenum
operator|=
name|sectnum
operator|=
literal|1
expr_stmt|;
name|firstprot
operator|=
name|NIL
expr_stmt|;
comment|/* used in mkprot() so that the first proto goes in slot 1      * of the proto queue      */
name|lastprot
operator|=
literal|1
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
block|{
comment|/* set up doubly-linked equivalence classes */
comment|/* We loop all the way up to csize, since ecgroup[csize] is the 	 * position used for NUL characters 	 */
name|ecgroup
index|[
literal|1
index|]
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|nextecm
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
name|nextecm
index|[
name|csize
index|]
operator|=
name|NIL
expr_stmt|;
block|}
else|else
block|{
comment|/* put everything in its own equivalence class */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|nextecm
index|[
name|i
index|]
operator|=
name|BAD_SUBSCRIPT
expr_stmt|;
comment|/* to catch errors */
block|}
block|}
name|set_up_initial_allocations
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* readin - read in the rules section of the input file(s)  *  * synopsis  *    readin();  */
end_comment

begin_function
name|void
name|readin
parameter_list|()
block|{
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|puts
argument_list|(
literal|"#define FLEX_DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|==
literal|256
condition|)
name|puts
argument_list|(
literal|"#define YY_CHAR unsigned char"
argument_list|)
expr_stmt|;
else|else
name|puts
argument_list|(
literal|"#define YY_CHAR char"
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
condition|)
block|{
name|pinpoint_message
argument_list|(
literal|"fatal parse error"
argument_list|)
expr_stmt|;
name|flexend
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|xlation
condition|)
block|{
name|numecs
operator|=
name|ecs_from_xlation
argument_list|(
name|ecgroup
argument_list|)
expr_stmt|;
name|useecs
operator|=
name|true
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|useecs
condition|)
name|numecs
operator|=
name|cre8ecs
argument_list|(
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|)
expr_stmt|;
else|else
name|numecs
operator|=
name|csize
expr_stmt|;
comment|/* now map the equivalence class for NUL to its expected place */
name|ecgroup
index|[
literal|0
index|]
operator|=
name|ecgroup
index|[
name|csize
index|]
expr_stmt|;
name|NUL_ec
operator|=
name|abs
argument_list|(
name|ecgroup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|ccl2ecl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_up_initial_allocations - allocate memory for internal tables */
end_comment

begin_function
name|void
name|set_up_initial_allocations
parameter_list|()
block|{
name|current_mns
operator|=
name|INITIAL_MNS
expr_stmt|;
name|firstst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|lastst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|finalst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|transchar
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|trans1
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|trans2
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|accptnum
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|assoc_rule
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|state_type
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|current_max_rules
operator|=
name|INITIAL_MAX_RULES
expr_stmt|;
name|rule_type
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_linenum
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|current_max_scs
operator|=
name|INITIAL_MAX_SCS
expr_stmt|;
name|scset
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scbol
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scxclu
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|sceof
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scname
operator|=
name|allocate_char_ptr_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|actvsc
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|current_maxccls
operator|=
name|INITIAL_MAX_CCLS
expr_stmt|;
name|cclmap
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|ccllen
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|cclng
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|current_max_ccl_tbl_size
operator|=
name|INITIAL_MAX_CCL_TBL_SIZE
expr_stmt|;
name|ccltbl
operator|=
name|allocate_character_array
argument_list|(
name|current_max_ccl_tbl_size
argument_list|)
expr_stmt|;
name|current_max_dfa_size
operator|=
name|INITIAL_MAX_DFA_SIZE
expr_stmt|;
name|current_max_xpairs
operator|=
name|INITIAL_MAX_XPAIRS
expr_stmt|;
name|nxt
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|chk
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|current_max_template_xpairs
operator|=
name|INITIAL_MAX_TEMPLATE_XPAIRS
expr_stmt|;
name|tnxt
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_template_xpairs
argument_list|)
expr_stmt|;
name|current_max_dfas
operator|=
name|INITIAL_MAX_DFAS
expr_stmt|;
name|base
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|def
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfasiz
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|accsiz
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dhash
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dss
operator|=
name|allocate_int_ptr_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfaacc
operator|=
name|allocate_dfaacc_union
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|nultrans
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

end_unit

