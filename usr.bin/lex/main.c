begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* flex - tool to generate fast lexical analyzers */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *  * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
name|char
name|copyright
index|[]
init|=
literal|"@(#) Copyright (c) 1990 The Regents of the University of California.\n\  All rights reserved.\n"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* not lint */
end_comment

begin_comment
comment|/* $Header: /home/daffy/u0/vern/flex/RCS/main.c,v 2.64 96/05/25 20:42:42 vern Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_include
include|#
directive|include
file|"version.h"
end_include

begin_decl_stmt
specifier|static
name|char
name|flex_version
index|[]
init|=
name|FLEX_VERSION
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|flexinit
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|char
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|readin
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|set_up_initial_allocations
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_ifdef
ifdef|#
directive|ifdef
name|NEED_ARGV_FIXUP
end_ifdef

begin_decl_stmt
specifier|extern
name|void
name|argv_fixup
name|PROTO
argument_list|(
operator|(
name|int
operator|*
operator|,
name|char
operator|*
operator|*
operator|*
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* these globals are all defined and commented in flexdef.h */
end_comment

begin_decl_stmt
name|int
name|printstats
decl_stmt|,
name|syntaxerror
decl_stmt|,
name|eofseen
decl_stmt|,
name|ddebug
decl_stmt|,
name|trace
decl_stmt|,
name|nowarn
decl_stmt|,
name|spprdflt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|interactive
decl_stmt|,
name|caseins
decl_stmt|,
name|lex_compat
decl_stmt|,
name|do_yylineno
decl_stmt|,
name|useecs
decl_stmt|,
name|fulltbl
decl_stmt|,
name|usemecs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|fullspd
decl_stmt|,
name|gen_line_dirs
decl_stmt|,
name|performance_report
decl_stmt|,
name|backing_up_report
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|C_plus_plus
decl_stmt|,
name|long_align
decl_stmt|,
name|use_read
decl_stmt|,
name|yytext_is_array
decl_stmt|,
name|do_yywrap
decl_stmt|,
name|csize
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yymore_used
decl_stmt|,
name|reject
decl_stmt|,
name|real_reject
decl_stmt|,
name|continued_action
decl_stmt|,
name|in_rule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yymore_really_used
decl_stmt|,
name|reject_really_used
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|datapos
decl_stmt|,
name|dataline
decl_stmt|,
name|linenum
decl_stmt|,
name|out_linenum
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|skelfile
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|skel_ind
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|action_array
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|action_size
decl_stmt|,
name|defs1_offset
decl_stmt|,
name|prolog_offset
decl_stmt|,
name|action_offset
decl_stmt|,
name|action_index
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|infilename
init|=
name|NULL
decl_stmt|,
modifier|*
name|outfilename
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|did_outfilename
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
name|prefix
decl_stmt|,
modifier|*
name|yyclass
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|do_stdinit
decl_stmt|,
name|use_stdout
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onestate
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onesym
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|onenext
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onedef
index|[
name|ONE_STACK_SIZE
index|]
decl_stmt|,
name|onesp
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_mns
decl_stmt|,
name|current_max_rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_rules
decl_stmt|,
name|num_eof_rules
decl_stmt|,
name|default_rule
decl_stmt|,
name|lastnfa
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|firstst
decl_stmt|,
modifier|*
name|lastst
decl_stmt|,
modifier|*
name|finalst
decl_stmt|,
modifier|*
name|transchar
decl_stmt|,
modifier|*
name|trans1
decl_stmt|,
modifier|*
name|trans2
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|accptnum
decl_stmt|,
modifier|*
name|assoc_rule
decl_stmt|,
modifier|*
name|state_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|rule_type
decl_stmt|,
modifier|*
name|rule_linenum
decl_stmt|,
modifier|*
name|rule_useful
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_state_type
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|variable_trailing_context_rules
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numtemps
decl_stmt|,
name|numprots
decl_stmt|,
name|protprev
index|[
name|MSP
index|]
decl_stmt|,
name|protnext
index|[
name|MSP
index|]
decl_stmt|,
name|prottbl
index|[
name|MSP
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|protcomst
index|[
name|MSP
index|]
decl_stmt|,
name|firstprot
decl_stmt|,
name|lastprot
decl_stmt|,
name|protsave
index|[
name|PROT_SAVE_SIZE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numecs
decl_stmt|,
name|nextecm
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|ecgroup
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|,
name|nummecs
decl_stmt|,
name|tecfwd
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tecbck
index|[
name|CSIZE
operator|+
literal|1
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastsc
decl_stmt|,
modifier|*
name|scset
decl_stmt|,
modifier|*
name|scbol
decl_stmt|,
modifier|*
name|scxclu
decl_stmt|,
modifier|*
name|sceof
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_scs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|scname
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_dfa_size
decl_stmt|,
name|current_max_xpairs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_max_template_xpairs
decl_stmt|,
name|current_max_dfas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastdfa
decl_stmt|,
modifier|*
name|nxt
decl_stmt|,
modifier|*
name|chk
decl_stmt|,
modifier|*
name|tnxt
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|base
decl_stmt|,
modifier|*
name|def
decl_stmt|,
modifier|*
name|nultrans
decl_stmt|,
name|NUL_ec
decl_stmt|,
name|tblend
decl_stmt|,
name|firstfree
decl_stmt|,
modifier|*
modifier|*
name|dss
decl_stmt|,
modifier|*
name|dfasiz
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|union
name|dfaacc_union
modifier|*
name|dfaacc
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|accsiz
decl_stmt|,
modifier|*
name|dhash
decl_stmt|,
name|numas
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|numsnpairs
decl_stmt|,
name|jambase
decl_stmt|,
name|jamstate
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|lastccl
decl_stmt|,
modifier|*
name|cclmap
decl_stmt|,
modifier|*
name|ccllen
decl_stmt|,
modifier|*
name|cclng
decl_stmt|,
name|cclreuse
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|current_maxccls
decl_stmt|,
name|current_max_ccl_tbl_size
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|Char
modifier|*
name|ccltbl
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
name|nmstr
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|sectnum
decl_stmt|,
name|nummt
decl_stmt|,
name|hshcol
decl_stmt|,
name|dfaeql
decl_stmt|,
name|numeps
decl_stmt|,
name|eps2
decl_stmt|,
name|num_reallocs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|tmpuses
decl_stmt|,
name|totnst
decl_stmt|,
name|peakpairs
decl_stmt|,
name|numuniq
decl_stmt|,
name|numdup
decl_stmt|,
name|hshsave
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_backing_up
decl_stmt|,
name|bol_needed
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|FILE
modifier|*
name|backing_up_file
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|end_of_buffer_state
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|char
modifier|*
modifier|*
name|input_files
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|num_input_files
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Make sure program_name is initialized so we don't crash if writing  * out an error message before getting the program name from argv[0].  */
end_comment

begin_decl_stmt
name|char
modifier|*
name|program_name
init|=
literal|"flex"
decl_stmt|;
end_decl_stmt

begin_ifndef
ifndef|#
directive|ifndef
name|SHORT_FILE_NAMES
end_ifndef

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile_template
init|=
literal|"lex.%s.%s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backing_name
init|=
literal|"lex.backup"
decl_stmt|;
end_decl_stmt

begin_else
else|#
directive|else
end_else

begin_decl_stmt
specifier|static
name|char
modifier|*
name|outfile_template
init|=
literal|"lex%s.%s"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|backing_name
init|=
literal|"lex.bck"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|THINK_C
end_ifdef

begin_include
include|#
directive|include
file|<console.h>
end_include

begin_endif
endif|#
directive|endif
end_endif

begin_ifdef
ifdef|#
directive|ifdef
name|MS_DOS
end_ifdef

begin_decl_stmt
specifier|extern
name|unsigned
name|_stklen
init|=
literal|16384
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
specifier|static
name|char
name|outfile_path
index|[
name|MAXLINE
index|]
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|outfile_created
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
modifier|*
name|skelname
init|=
name|NULL
decl_stmt|;
end_decl_stmt

begin_function
name|int
name|main
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|;
ifdef|#
directive|ifdef
name|THINK_C
name|argc
operator|=
name|ccommand
argument_list|(
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
ifdef|#
directive|ifdef
name|NEED_ARGV_FIXUP
name|argv_fixup
argument_list|(
operator|&
name|argc
argument_list|,
operator|&
name|argv
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|flexinit
argument_list|(
name|argc
argument_list|,
name|argv
argument_list|)
expr_stmt|;
name|readin
argument_list|()
expr_stmt|;
name|ntod
argument_list|()
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num_rules
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|rule_useful
index|[
name|i
index|]
operator|&&
name|i
operator|!=
name|default_rule
condition|)
name|line_warning
argument_list|(
name|_
argument_list|(
literal|"rule cannot be matched"
argument_list|)
argument_list|,
name|rule_linenum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|spprdflt
operator|&&
operator|!
name|reject
operator|&&
name|rule_useful
index|[
name|default_rule
index|]
condition|)
name|line_warning
argument_list|(
name|_
argument_list|(
literal|"-s option given but default rule can be matched"
argument_list|)
argument_list|,
name|rule_linenum
index|[
name|default_rule
index|]
argument_list|)
expr_stmt|;
comment|/* Generate the C state transition tables from the DFA. */
name|make_tables
argument_list|()
expr_stmt|;
comment|/* Note, flexend does not return.  It exits with its argument 	 * as status. 	 */
name|flexend
argument_list|(
literal|0
argument_list|)
expr_stmt|;
return|return
literal|0
return|;
comment|/* keep compilers/lint happy */
block|}
end_function

begin_comment
comment|/* check_options - check user-specified options */
end_comment

begin_function
name|void
name|check_options
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
if|if
condition|(
name|lex_compat
condition|)
block|{
if|if
condition|(
name|C_plus_plus
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Can't use -+ with -l option"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
operator|||
name|fullspd
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Can't use -f or -F with -l option"
argument_list|)
argument_list|)
expr_stmt|;
comment|/* Don't rely on detecting use of yymore() and REJECT, 		 * just assume they'll be used. 		 */
name|yymore_really_used
operator|=
name|reject_really_used
operator|=
name|true
expr_stmt|;
name|yytext_is_array
operator|=
name|true
expr_stmt|;
name|do_yylineno
operator|=
name|true
expr_stmt|;
name|use_read
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|do_yylineno
condition|)
comment|/* This should really be "maintain_backup_tables = true" */
name|reject_really_used
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|csize
operator|==
name|unspecified
condition|)
block|{
if|if
condition|(
operator|(
name|fulltbl
operator|||
name|fullspd
operator|)
operator|&&
operator|!
name|useecs
condition|)
name|csize
operator|=
name|DEFAULT_CSIZE
expr_stmt|;
else|else
name|csize
operator|=
name|CSIZE
expr_stmt|;
block|}
if|if
condition|(
name|interactive
operator|==
name|unspecified
condition|)
block|{
if|if
condition|(
name|fulltbl
operator|||
name|fullspd
condition|)
name|interactive
operator|=
name|false
expr_stmt|;
else|else
name|interactive
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|fulltbl
operator|||
name|fullspd
condition|)
block|{
if|if
condition|(
name|usemecs
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf/-CF and -Cm don't make sense together"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf/-CF and -I are incompatible"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_compat
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf/-CF are incompatible with lex-compatibility mode"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf/-CF and %option yylineno are incompatible"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
operator|&&
name|fullspd
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-Cf and -CF are mutually exclusive"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|C_plus_plus
operator|&&
name|fullspd
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"Can't use -+ with -CF option"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_plus_plus
operator|&&
name|yytext_is_array
condition|)
block|{
name|warn
argument_list|(
name|_
argument_list|(
literal|"%array incompatible with -+ option"
argument_list|)
argument_list|)
expr_stmt|;
name|yytext_is_array
operator|=
name|false
expr_stmt|;
block|}
if|if
condition|(
name|useecs
condition|)
block|{
comment|/* Set up doubly-linked equivalence classes. */
comment|/* We loop all the way up to csize, since ecgroup[csize] is 		 * the position used for NUL characters. 		 */
name|ecgroup
index|[
literal|1
index|]
operator|=
name|NIL
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|2
init|;
name|i
operator|<=
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|i
operator|-
literal|1
expr_stmt|;
name|nextecm
index|[
name|i
operator|-
literal|1
index|]
operator|=
name|i
expr_stmt|;
block|}
name|nextecm
index|[
name|csize
index|]
operator|=
name|NIL
expr_stmt|;
block|}
else|else
block|{
comment|/* Put everything in its own equivalence class. */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|csize
condition|;
operator|++
name|i
control|)
block|{
name|ecgroup
index|[
name|i
index|]
operator|=
name|i
expr_stmt|;
name|nextecm
index|[
name|i
index|]
operator|=
name|BAD_SUBSCRIPT
expr_stmt|;
comment|/* to catch errors */
block|}
block|}
if|if
condition|(
operator|!
name|use_stdout
condition|)
block|{
name|FILE
modifier|*
name|prev_stdout
decl_stmt|;
if|if
condition|(
operator|!
name|did_outfilename
condition|)
block|{
name|char
modifier|*
name|suffix
decl_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
name|suffix
operator|=
literal|"cc"
expr_stmt|;
else|else
name|suffix
operator|=
literal|"c"
expr_stmt|;
name|sprintf
argument_list|(
name|outfile_path
argument_list|,
name|outfile_template
argument_list|,
name|prefix
argument_list|,
name|suffix
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|outfile_path
expr_stmt|;
block|}
name|prev_stdout
operator|=
name|freopen
argument_list|(
name|outfilename
argument_list|,
literal|"w"
argument_list|,
name|stdout
argument_list|)
expr_stmt|;
if|if
condition|(
name|prev_stdout
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"could not create %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|outfile_created
operator|=
literal|1
expr_stmt|;
block|}
if|if
condition|(
name|skelname
operator|&&
operator|(
name|skelfile
operator|=
name|fopen
argument_list|(
name|skelname
argument_list|,
literal|"r"
argument_list|)
operator|)
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"can't open skeleton file %s"
argument_list|)
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prefix
argument_list|,
literal|"yy"
argument_list|)
condition|)
block|{
define|#
directive|define
name|GEN_PREFIX
parameter_list|(
name|name
parameter_list|)
value|out_str3( "#define yy%s %s%s\n", name, prefix, name )
if|if
condition|(
name|C_plus_plus
condition|)
name|GEN_PREFIX
argument_list|(
literal|"FlexLexer"
argument_list|)
expr_stmt|;
else|else
block|{
name|GEN_PREFIX
argument_list|(
literal|"_create_buffer"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_delete_buffer"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_scan_buffer"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_scan_string"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_scan_bytes"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_flex_debug"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_init_buffer"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_flush_buffer"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_load_buffer_state"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"_switch_to_buffer"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"in"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"leng"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"lex"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"out"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"restart"
argument_list|)
expr_stmt|;
name|GEN_PREFIX
argument_list|(
literal|"text"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
name|GEN_PREFIX
argument_list|(
literal|"lineno"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|do_yywrap
condition|)
name|GEN_PREFIX
argument_list|(
literal|"wrap"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|did_outfilename
condition|)
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* flexend - terminate flex  *  * note  *    This routine does not return.  */
end_comment

begin_function
name|void
name|flexend
parameter_list|(
name|exit_status
parameter_list|)
name|int
name|exit_status
decl_stmt|;
block|{
name|int
name|tblsiz
decl_stmt|;
name|int
name|unlink
parameter_list|()
function_decl|;
if|if
condition|(
name|skelfile
operator|!=
name|NULL
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|skelfile
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"input error reading skeleton file %s"
argument_list|)
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|skelfile
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing skeleton file %s"
argument_list|)
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|exit_status
operator|!=
literal|0
operator|&&
name|outfile_created
condition|)
block|{
if|if
condition|(
name|ferror
argument_list|(
name|stdout
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error writing output file %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|stdout
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing output file %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|unlink
argument_list|(
name|outfilename
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error deleting output file %s"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|backing_up_report
operator|&&
name|backing_up_file
condition|)
block|{
if|if
condition|(
name|num_backing_up
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|backing_up_file
argument_list|,
name|_
argument_list|(
literal|"No backing up.\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|fprintf
argument_list|(
name|backing_up_file
argument_list|,
name|_
argument_list|(
literal|"%d backing up (non-accepting) states.\n"
argument_list|)
argument_list|,
name|num_backing_up
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|backing_up_file
argument_list|,
name|_
argument_list|(
literal|"Compressed tables always back up.\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|ferror
argument_list|(
name|backing_up_file
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error writing backup file %s"
argument_list|)
argument_list|,
name|backing_name
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fclose
argument_list|(
name|backing_up_file
argument_list|)
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"error closing backup file %s"
argument_list|)
argument_list|,
name|backing_name
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|printstats
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s version %s usage statistics:\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|flex_version
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  scanner options: -"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
name|putc
argument_list|(
literal|'+'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|backing_up_report
condition|)
name|putc
argument_list|(
literal|'b'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|putc
argument_list|(
literal|'d'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|caseins
condition|)
name|putc
argument_list|(
literal|'i'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_compat
condition|)
name|putc
argument_list|(
literal|'l'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|0
condition|)
name|putc
argument_list|(
literal|'p'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|1
condition|)
name|putc
argument_list|(
literal|'p'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|spprdflt
condition|)
name|putc
argument_list|(
literal|'s'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_stdout
condition|)
name|putc
argument_list|(
literal|'t'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|printstats
condition|)
name|putc
argument_list|(
literal|'v'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
comment|/* always true! */
if|if
condition|(
name|nowarn
condition|)
name|putc
argument_list|(
literal|'w'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
operator|==
name|false
condition|)
name|putc
argument_list|(
literal|'B'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
operator|==
name|true
condition|)
name|putc
argument_list|(
literal|'I'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|gen_line_dirs
condition|)
name|putc
argument_list|(
literal|'L'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|putc
argument_list|(
literal|'T'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|==
name|unspecified
condition|)
comment|/* We encountered an error fairly early on, so csize 			 * never got specified.  Define it now, to prevent 			 * bogus table sizes being written out below. 			 */
name|csize
operator|=
literal|256
expr_stmt|;
if|if
condition|(
name|csize
operator|==
literal|128
condition|)
name|putc
argument_list|(
literal|'7'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'8'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -C"
argument_list|)
expr_stmt|;
if|if
condition|(
name|long_align
condition|)
name|putc
argument_list|(
literal|'a'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
condition|)
name|putc
argument_list|(
literal|'f'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
name|putc
argument_list|(
literal|'F'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|putc
argument_list|(
literal|'e'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
name|putc
argument_list|(
literal|'m'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|use_read
condition|)
name|putc
argument_list|(
literal|'r'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
if|if
condition|(
name|did_outfilename
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -o%s"
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
if|if
condition|(
name|skelname
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -S%s"
argument_list|,
name|skelname
argument_list|)
expr_stmt|;
if|if
condition|(
name|strcmp
argument_list|(
name|prefix
argument_list|,
literal|"yy"
argument_list|)
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|" -P%s"
argument_list|,
name|prefix
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d NFA states\n"
argument_list|)
argument_list|,
name|lastnfa
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d DFA states (%d words)\n"
argument_list|)
argument_list|,
name|lastdfa
argument_list|,
name|current_max_dfas
argument_list|,
name|totnst
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d rules\n"
argument_list|)
argument_list|,
name|num_rules
operator|+
name|num_eof_rules
operator|-
literal|1
comment|/* - 1 for def. rule */
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  No backing up\n"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d backing-up (non-accepting) states\n"
argument_list|)
argument_list|,
name|num_backing_up
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  Compressed tables always back-up\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  Beginning-of-line patterns used\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d start conditions\n"
argument_list|)
argument_list|,
name|lastsc
argument_list|,
name|current_max_scs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d epsilon states, %d double epsilon states\n"
argument_list|)
argument_list|,
name|numeps
argument_list|,
name|eps2
argument_list|)
expr_stmt|;
if|if
condition|(
name|lastccl
operator|==
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  no character classes\n"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d character classes needed %d/%d words of storage, %d reused\n"
argument_list|)
argument_list|,
name|lastccl
argument_list|,
name|current_maxccls
argument_list|,
name|cclmap
index|[
name|lastccl
index|]
operator|+
name|ccllen
index|[
name|lastccl
index|]
argument_list|,
name|current_max_ccl_tbl_size
argument_list|,
name|cclreuse
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d state/nextstate pairs created\n"
argument_list|)
argument_list|,
name|numsnpairs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d unique/duplicate transitions\n"
argument_list|)
argument_list|,
name|numuniq
argument_list|,
name|numdup
argument_list|)
expr_stmt|;
if|if
condition|(
name|fulltbl
condition|)
block|{
name|tblsiz
operator|=
name|lastdfa
operator|*
name|numecs
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d table entries\n"
argument_list|)
argument_list|,
name|tblsiz
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tblsiz
operator|=
literal|2
operator|*
operator|(
name|lastdfa
operator|+
name|numtemps
operator|)
operator|+
literal|2
operator|*
name|tblend
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d base-def entries created\n"
argument_list|)
argument_list|,
name|lastdfa
operator|+
name|numtemps
argument_list|,
name|current_max_dfas
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d (peak %d) nxt-chk entries created\n"
argument_list|)
argument_list|,
name|tblend
argument_list|,
name|current_max_xpairs
argument_list|,
name|peakpairs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d (peak %d) template nxt-chk entries created\n"
argument_list|)
argument_list|,
name|numtemps
operator|*
name|nummecs
argument_list|,
name|current_max_template_xpairs
argument_list|,
name|numtemps
operator|*
name|numecs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d empty table entries\n"
argument_list|)
argument_list|,
name|nummt
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d protos created\n"
argument_list|)
argument_list|,
name|numprots
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d templates created, %d uses\n"
argument_list|)
argument_list|,
name|numtemps
argument_list|,
name|tmpuses
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useecs
condition|)
block|{
name|tblsiz
operator|=
name|tblsiz
operator|+
name|csize
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d equivalence classes created\n"
argument_list|)
argument_list|,
name|numecs
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|usemecs
condition|)
block|{
name|tblsiz
operator|=
name|tblsiz
operator|+
name|numecs
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d/%d meta-equivalence classes created\n"
argument_list|)
argument_list|,
name|nummecs
argument_list|,
name|csize
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d (%d saved) hash collisions, %d DFAs equal\n"
argument_list|)
argument_list|,
name|hshcol
argument_list|,
name|hshsave
argument_list|,
name|dfaeql
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d sets of reallocations needed\n"
argument_list|)
argument_list|,
name|num_reallocs
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"  %d total table entries needed\n"
argument_list|)
argument_list|,
name|tblsiz
argument_list|)
expr_stmt|;
block|}
name|exit
argument_list|(
name|exit_status
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* flexinit - initialize flex */
end_comment

begin_function
name|void
name|flexinit
parameter_list|(
name|argc
parameter_list|,
name|argv
parameter_list|)
name|int
name|argc
decl_stmt|;
name|char
modifier|*
modifier|*
name|argv
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|sawcmpflag
decl_stmt|;
name|char
modifier|*
name|arg
decl_stmt|;
name|printstats
operator|=
name|syntaxerror
operator|=
name|trace
operator|=
name|spprdflt
operator|=
name|caseins
operator|=
name|false
expr_stmt|;
name|lex_compat
operator|=
name|C_plus_plus
operator|=
name|backing_up_report
operator|=
name|ddebug
operator|=
name|fulltbl
operator|=
name|false
expr_stmt|;
name|fullspd
operator|=
name|long_align
operator|=
name|nowarn
operator|=
name|yymore_used
operator|=
name|continued_action
operator|=
name|false
expr_stmt|;
name|do_yylineno
operator|=
name|yytext_is_array
operator|=
name|in_rule
operator|=
name|reject
operator|=
name|do_stdinit
operator|=
name|false
expr_stmt|;
name|yymore_really_used
operator|=
name|reject_really_used
operator|=
name|unspecified
expr_stmt|;
name|interactive
operator|=
name|csize
operator|=
name|unspecified
expr_stmt|;
name|do_yywrap
operator|=
name|gen_line_dirs
operator|=
name|usemecs
operator|=
name|useecs
operator|=
name|true
expr_stmt|;
name|performance_report
operator|=
literal|0
expr_stmt|;
name|did_outfilename
operator|=
literal|0
expr_stmt|;
name|prefix
operator|=
literal|"yy"
expr_stmt|;
name|yyclass
operator|=
literal|0
expr_stmt|;
name|use_read
operator|=
name|use_stdout
operator|=
name|false
expr_stmt|;
name|sawcmpflag
operator|=
name|false
expr_stmt|;
comment|/* Initialize dynamic array for holding the rule actions. */
name|action_size
operator|=
literal|2048
expr_stmt|;
comment|/* default size of action array in bytes */
name|action_array
operator|=
name|allocate_character_array
argument_list|(
name|action_size
argument_list|)
expr_stmt|;
name|defs1_offset
operator|=
name|prolog_offset
operator|=
name|action_offset
operator|=
name|action_index
operator|=
literal|0
expr_stmt|;
name|action_array
index|[
literal|0
index|]
operator|=
literal|'\0'
expr_stmt|;
name|program_name
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|program_name
index|[
literal|0
index|]
operator|!=
literal|'\0'
operator|&&
name|program_name
index|[
name|strlen
argument_list|(
name|program_name
argument_list|)
operator|-
literal|1
index|]
operator|==
literal|'+'
condition|)
name|C_plus_plus
operator|=
name|true
expr_stmt|;
comment|/* read flags */
for|for
control|(
operator|--
name|argc
operator|,
operator|++
name|argv
init|;
name|argc
condition|;
operator|--
name|argc
operator|,
operator|++
name|argv
control|)
block|{
name|arg
operator|=
name|argv
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|arg
index|[
literal|0
index|]
operator|!=
literal|'-'
operator|||
name|arg
index|[
literal|1
index|]
operator|==
literal|'\0'
condition|)
break|break;
if|if
condition|(
name|arg
index|[
literal|1
index|]
operator|==
literal|'-'
condition|)
block|{
comment|/* --option */
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--help"
argument_list|)
condition|)
name|arg
operator|=
literal|"-h"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--version"
argument_list|)
condition|)
name|arg
operator|=
literal|"-V"
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|strcmp
argument_list|(
name|arg
argument_list|,
literal|"--"
argument_list|)
condition|)
block|{
comment|/* end of options */
operator|--
name|argc
expr_stmt|;
operator|++
name|argv
expr_stmt|;
break|break;
block|}
block|}
for|for
control|(
name|i
operator|=
literal|1
init|;
name|arg
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'+'
case|:
name|C_plus_plus
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'B'
case|:
name|interactive
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'b'
case|:
name|backing_up_report
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'c'
case|:
break|break;
case|case
literal|'C'
case|:
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-C flag must be given separately"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|sawcmpflag
condition|)
block|{
name|useecs
operator|=
name|false
expr_stmt|;
name|usemecs
operator|=
name|false
expr_stmt|;
name|fulltbl
operator|=
name|false
expr_stmt|;
name|sawcmpflag
operator|=
name|true
expr_stmt|;
block|}
for|for
control|(
operator|++
name|i
init|;
name|arg
index|[
name|i
index|]
operator|!=
literal|'\0'
condition|;
operator|++
name|i
control|)
switch|switch
condition|(
name|arg
index|[
name|i
index|]
condition|)
block|{
case|case
literal|'a'
case|:
name|long_align
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'e'
case|:
name|useecs
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|fullspd
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|fulltbl
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'m'
case|:
name|usemecs
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'r'
case|:
name|use_read
operator|=
name|true
expr_stmt|;
break|break;
default|default:
name|lerrif
argument_list|(
name|_
argument_list|(
literal|"unknown -C option '%c'"
argument_list|)
argument_list|,
operator|(
name|int
operator|)
name|arg
index|[
name|i
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
goto|goto
name|get_next_arg
goto|;
case|case
literal|'d'
case|:
name|ddebug
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'f'
case|:
name|useecs
operator|=
name|usemecs
operator|=
name|false
expr_stmt|;
name|use_read
operator|=
name|fulltbl
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'F'
case|:
name|useecs
operator|=
name|usemecs
operator|=
name|false
expr_stmt|;
name|use_read
operator|=
name|fullspd
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'?'
case|:
case|case
literal|'h'
case|:
name|usage
argument_list|()
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'I'
case|:
name|interactive
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'i'
case|:
name|caseins
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'l'
case|:
name|lex_compat
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'L'
case|:
name|gen_line_dirs
operator|=
name|false
expr_stmt|;
break|break;
case|case
literal|'n'
case|:
comment|/* Stupid do-nothing deprecated 					 * option. 					 */
break|break;
case|case
literal|'o'
case|:
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-o flag must be given separately"
argument_list|)
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|arg
operator|+
name|i
operator|+
literal|1
expr_stmt|;
name|did_outfilename
operator|=
literal|1
expr_stmt|;
goto|goto
name|get_next_arg
goto|;
case|case
literal|'P'
case|:
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-P flag must be given separately"
argument_list|)
argument_list|)
expr_stmt|;
name|prefix
operator|=
name|arg
operator|+
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|get_next_arg
goto|;
case|case
literal|'p'
case|:
operator|++
name|performance_report
expr_stmt|;
break|break;
case|case
literal|'S'
case|:
if|if
condition|(
name|i
operator|!=
literal|1
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"-S flag must be given separately"
argument_list|)
argument_list|)
expr_stmt|;
name|skelname
operator|=
name|arg
operator|+
name|i
operator|+
literal|1
expr_stmt|;
goto|goto
name|get_next_arg
goto|;
case|case
literal|'s'
case|:
name|spprdflt
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'t'
case|:
name|use_stdout
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'T'
case|:
name|trace
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'v'
case|:
name|printstats
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'V'
case|:
name|printf
argument_list|(
name|_
argument_list|(
literal|"%s version %s\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
name|flex_version
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|0
argument_list|)
expr_stmt|;
case|case
literal|'w'
case|:
name|nowarn
operator|=
name|true
expr_stmt|;
break|break;
case|case
literal|'7'
case|:
name|csize
operator|=
literal|128
expr_stmt|;
break|break;
case|case
literal|'8'
case|:
name|csize
operator|=
name|CSIZE
expr_stmt|;
break|break;
default|default:
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%s: unknown flag '%c'.  For usage, try\n\t%s --help\n"
argument_list|)
argument_list|,
name|program_name
argument_list|,
operator|(
name|int
operator|)
name|arg
index|[
name|i
index|]
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|exit
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
comment|/* Used by -C, -S, -o, and -P flags in lieu of a "continue 2" 		 * control. 		 */
name|get_next_arg
label|:
empty_stmt|;
block|}
name|num_input_files
operator|=
name|argc
expr_stmt|;
name|input_files
operator|=
name|argv
expr_stmt|;
name|set_input_file
argument_list|(
name|num_input_files
operator|>
literal|0
condition|?
name|input_files
index|[
literal|0
index|]
else|:
name|NULL
argument_list|)
expr_stmt|;
name|lastccl
operator|=
name|lastsc
operator|=
name|lastdfa
operator|=
name|lastnfa
operator|=
literal|0
expr_stmt|;
name|num_rules
operator|=
name|num_eof_rules
operator|=
name|default_rule
operator|=
literal|0
expr_stmt|;
name|numas
operator|=
name|numsnpairs
operator|=
name|tmpuses
operator|=
literal|0
expr_stmt|;
name|numecs
operator|=
name|numeps
operator|=
name|eps2
operator|=
name|num_reallocs
operator|=
name|hshcol
operator|=
name|dfaeql
operator|=
name|totnst
operator|=
literal|0
expr_stmt|;
name|numuniq
operator|=
name|numdup
operator|=
name|hshsave
operator|=
name|eofseen
operator|=
name|datapos
operator|=
name|dataline
operator|=
literal|0
expr_stmt|;
name|num_backing_up
operator|=
name|onesp
operator|=
name|numprots
operator|=
literal|0
expr_stmt|;
name|variable_trailing_context_rules
operator|=
name|bol_needed
operator|=
name|false
expr_stmt|;
name|out_linenum
operator|=
name|linenum
operator|=
name|sectnum
operator|=
literal|1
expr_stmt|;
name|firstprot
operator|=
name|NIL
expr_stmt|;
comment|/* Used in mkprot() so that the first proto goes in slot 1 	 * of the proto queue. 	 */
name|lastprot
operator|=
literal|1
expr_stmt|;
name|set_up_initial_allocations
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* readin - read in the rules section of the input file(s) */
end_comment

begin_function
name|void
name|readin
parameter_list|()
block|{
specifier|static
name|char
name|yy_stdinit
index|[]
init|=
literal|"FILE *yyin = stdin, *yyout = stdout;"
decl_stmt|;
specifier|static
name|char
name|yy_nostdinit
index|[]
init|=
literal|"FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;"
decl_stmt|;
name|line_directive_out
argument_list|(
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyparse
argument_list|()
condition|)
block|{
name|pinpoint_message
argument_list|(
name|_
argument_list|(
literal|"fatal parse error"
argument_list|)
argument_list|)
expr_stmt|;
name|flexend
argument_list|(
literal|1
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|syntaxerror
condition|)
name|flexend
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|backing_up_report
condition|)
block|{
name|backing_up_file
operator|=
name|fopen
argument_list|(
name|backing_name
argument_list|,
literal|"w"
argument_list|)
expr_stmt|;
if|if
condition|(
name|backing_up_file
operator|==
name|NULL
condition|)
name|lerrsf
argument_list|(
name|_
argument_list|(
literal|"could not create backing-up info file %s"
argument_list|)
argument_list|,
name|backing_name
argument_list|)
expr_stmt|;
block|}
else|else
name|backing_up_file
operator|=
name|NULL
expr_stmt|;
if|if
condition|(
name|yymore_really_used
operator|==
name|true
condition|)
name|yymore_used
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|yymore_really_used
operator|==
name|false
condition|)
name|yymore_used
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|reject_really_used
operator|==
name|true
condition|)
name|reject
operator|=
name|true
expr_stmt|;
elseif|else
if|if
condition|(
name|reject_really_used
operator|==
name|false
condition|)
name|reject
operator|=
name|false
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|0
condition|)
block|{
if|if
condition|(
name|lex_compat
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"-l AT&T lex compatibility option entails a large performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|" and may be the actual source of other reported performance penalties\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"%%option yylineno entails a large performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|performance_report
operator|>
literal|1
condition|)
block|{
if|if
condition|(
name|interactive
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"-I (interactive) entails a minor performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"yymore() entails a minor performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"REJECT entails a large performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Variable trailing context rules entail a large performance penalty\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
name|real_reject
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
name|reject
operator|=
name|true
expr_stmt|;
if|if
condition|(
operator|(
name|fulltbl
operator|||
name|fullspd
operator|)
operator|&&
name|reject
condition|)
block|{
if|if
condition|(
name|real_reject
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"REJECT cannot be used with -f or -F"
argument_list|)
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|do_yylineno
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"%option yylineno cannot be used with -f or -F"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"variable trailing context rules cannot be used with -f or -F"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
name|outn
argument_list|(
literal|"\n#define YY_USES_REJECT"
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|do_yywrap
condition|)
block|{
name|outn
argument_list|(
literal|"\n#define yywrap() 1"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define YY_SKIP_YYWRAP"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|ddebug
condition|)
name|outn
argument_list|(
literal|"\n#define FLEX_DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|csize
operator|==
literal|256
condition|)
name|outn
argument_list|(
literal|"typedef unsigned char YY_CHAR;"
argument_list|)
expr_stmt|;
else|else
name|outn
argument_list|(
literal|"typedef char YY_CHAR;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|outn
argument_list|(
literal|"#define yytext_ptr yytext"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|outn
argument_list|(
literal|"#define YY_INTERACTIVE"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|do_stdinit
condition|)
block|{
name|outn
argument_list|(
literal|"#ifdef VMS"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#ifndef __VMS_POSIX"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
name|yy_nostdinit
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#else"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
name|yy_stdinit
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#else"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
name|yy_stdinit
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif"
argument_list|)
expr_stmt|;
block|}
else|else
name|outn
argument_list|(
name|yy_nostdinit
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|fullspd
condition|)
name|outn
argument_list|(
literal|"typedef yyconst struct yy_trans_info *yy_state_type;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
name|outn
argument_list|(
literal|"typedef int yy_state_type;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
name|outn
argument_list|(
literal|"\n#define FLEX_DEBUG"
argument_list|)
expr_stmt|;
if|if
condition|(
name|lex_compat
condition|)
name|outn
argument_list|(
literal|"#define YY_FLEX_LEX_COMPAT"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_yylineno
operator|&&
operator|!
name|C_plus_plus
condition|)
block|{
name|outn
argument_list|(
literal|"extern int yylineno;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"int yylineno = 1;"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|outn
argument_list|(
literal|"\n#include<FlexLexer.h>"
argument_list|)
expr_stmt|;
if|if
condition|(
name|yyclass
condition|)
block|{
name|outn
argument_list|(
literal|"int yyFlexLexer::yylex()"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t{"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\tLexerError( \"yyFlexLexer::yylex invoked but %option yyclass used\" );"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\treturn 0;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t}"
argument_list|)
expr_stmt|;
name|out_str
argument_list|(
literal|"\n#define YY_DECL int %s::yylex()\n"
argument_list|,
name|yyclass
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
if|if
condition|(
name|yytext_is_array
condition|)
name|outn
argument_list|(
literal|"extern char yytext[];\n"
argument_list|)
expr_stmt|;
else|else
block|{
name|outn
argument_list|(
literal|"extern char *yytext;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define yytext_ptr yytext"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yyclass
condition|)
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"%option yyclass only meaningful for C++ scanners"
argument_list|)
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|useecs
condition|)
name|numecs
operator|=
name|cre8ecs
argument_list|(
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|)
expr_stmt|;
else|else
name|numecs
operator|=
name|csize
expr_stmt|;
comment|/* Now map the equivalence class for NUL to its expected place. */
name|ecgroup
index|[
literal|0
index|]
operator|=
name|ecgroup
index|[
name|csize
index|]
expr_stmt|;
name|NUL_ec
operator|=
name|ABS
argument_list|(
name|ecgroup
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|ccl2ecl
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* set_up_initial_allocations - allocate memory for internal tables */
end_comment

begin_function
name|void
name|set_up_initial_allocations
parameter_list|()
block|{
name|current_mns
operator|=
name|INITIAL_MNS
expr_stmt|;
name|firstst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|lastst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|finalst
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|transchar
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|trans1
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|trans2
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|accptnum
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|assoc_rule
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|state_type
operator|=
name|allocate_integer_array
argument_list|(
name|current_mns
argument_list|)
expr_stmt|;
name|current_max_rules
operator|=
name|INITIAL_MAX_RULES
expr_stmt|;
name|rule_type
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_linenum
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_useful
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_rules
argument_list|)
expr_stmt|;
name|current_max_scs
operator|=
name|INITIAL_MAX_SCS
expr_stmt|;
name|scset
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scbol
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scxclu
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|sceof
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|scname
operator|=
name|allocate_char_ptr_array
argument_list|(
name|current_max_scs
argument_list|)
expr_stmt|;
name|current_maxccls
operator|=
name|INITIAL_MAX_CCLS
expr_stmt|;
name|cclmap
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|ccllen
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|cclng
operator|=
name|allocate_integer_array
argument_list|(
name|current_maxccls
argument_list|)
expr_stmt|;
name|current_max_ccl_tbl_size
operator|=
name|INITIAL_MAX_CCL_TBL_SIZE
expr_stmt|;
name|ccltbl
operator|=
name|allocate_Character_array
argument_list|(
name|current_max_ccl_tbl_size
argument_list|)
expr_stmt|;
name|current_max_dfa_size
operator|=
name|INITIAL_MAX_DFA_SIZE
expr_stmt|;
name|current_max_xpairs
operator|=
name|INITIAL_MAX_XPAIRS
expr_stmt|;
name|nxt
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|chk
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_xpairs
argument_list|)
expr_stmt|;
name|current_max_template_xpairs
operator|=
name|INITIAL_MAX_TEMPLATE_XPAIRS
expr_stmt|;
name|tnxt
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_template_xpairs
argument_list|)
expr_stmt|;
name|current_max_dfas
operator|=
name|INITIAL_MAX_DFAS
expr_stmt|;
name|base
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|def
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfasiz
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|accsiz
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dhash
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dss
operator|=
name|allocate_int_ptr_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|dfaacc
operator|=
name|allocate_dfaacc_union
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|nultrans
operator|=
operator|(
name|int
operator|*
operator|)
literal|0
expr_stmt|;
block|}
end_function

begin_function
name|void
name|usage
parameter_list|()
block|{
name|FILE
modifier|*
name|f
init|=
name|stdout
decl_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"%s [-bcdfhilnpstvwBFILTV78+? -C[aefFmr] -ooutput -Pprefix -Sskeleton]\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t[--help --version] [file ...]\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-b  generate backing-up information to %s\n"
argument_list|)
argument_list|,
name|backing_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-c  do-nothing POSIX option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-d  turn on debug mode in generated scanner\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-f  generate fast, large scanner\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-h  produce this help message\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-i  generate case-insensitive scanner\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-l  maximal compatibility with original lex\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-n  do-nothing POSIX option\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-p  generate performance report to stderr\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-s  suppress default rule to ECHO unmatched text\n"
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|did_outfilename
condition|)
block|{
name|sprintf
argument_list|(
name|outfile_path
argument_list|,
name|outfile_template
argument_list|,
name|prefix
argument_list|,
name|C_plus_plus
condition|?
literal|"cc"
else|:
literal|"c"
argument_list|)
expr_stmt|;
name|outfilename
operator|=
name|outfile_path
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-t  write generated scanner on stdout instead of %s\n"
argument_list|)
argument_list|,
name|outfilename
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-v  write summary of scanner statistics to f\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-w  do not generate warnings\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-B  generate batch scanner (opposite of -I)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-F  use alternative fast scanner representation\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-I  generate interactive scanner (opposite of -B)\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-L  suppress #line directives in scanner\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-T  %s should run in trace mode\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-V  report %s version\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-7  generate 7-bit scanner\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-8  generate 8-bit scanner\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-+  generate C++ scanner class\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-?  produce this help message\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-C  specify degree of table compression (default is -Cem):\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t\t-Ca  trade off larger tables for better memory alignment\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t\t-Ce  construct equivalence classes\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t\t-Cf  do not compress scanner tables; use -f representation\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t\t-CF  do not compress scanner tables; use -F representation\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t\t-Cm  construct meta-equivalence classes\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t\t-Cr  use read() instead of stdio for scanner input\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-o  specify output filename\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-P  specify scanner prefix other than \"yy\"\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t-S  specify skeleton file\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t--help     produce this help message\n"
argument_list|)
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|f
argument_list|,
name|_
argument_list|(
literal|"\t--version  report %s version\n"
argument_list|)
argument_list|,
name|program_name
argument_list|)
expr_stmt|;
block|}
end_function

end_unit

