begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* nfa - NFA construction routines */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *   * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/* $Header: /home/daffy/u0/vern/flex/RCS/nfa.c,v 2.17 95/03/04 16:11:42 vern Exp $ */
end_comment

begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|int
name|dupmachine
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|mkxtion
name|PROTO
argument_list|(
operator|(
name|int
operator|,
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* add_accept - add an accepting state to a machine  *  * accepting_number becomes mach's accepting number.  */
end_comment

begin_function
name|void
name|add_accept
parameter_list|(
name|mach
parameter_list|,
name|accepting_number
parameter_list|)
name|int
name|mach
decl_stmt|,
name|accepting_number
decl_stmt|;
block|{
comment|/* Hang the accepting number off an epsilon state.  if it is associated 	 * with a state that has a non-epsilon out-transition, then the state 	 * will accept BEFORE it makes that transition, i.e., one character 	 * too soon. 	 */
if|if
condition|(
name|transchar
index|[
name|finalst
index|[
name|mach
index|]
index|]
operator|==
name|SYM_EPSILON
condition|)
name|accptnum
index|[
name|finalst
index|[
name|mach
index|]
index|]
operator|=
name|accepting_number
expr_stmt|;
else|else
block|{
name|int
name|astate
init|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
decl_stmt|;
name|accptnum
index|[
name|astate
index|]
operator|=
name|accepting_number
expr_stmt|;
operator|(
name|void
operator|)
name|link_machines
argument_list|(
name|mach
argument_list|,
name|astate
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* copysingl - make a given number of copies of a singleton machine  *  * synopsis  *  *   newsng = copysingl( singl, num );  *  *     newsng - a new singleton composed of num copies of singl  *     singl  - a singleton machine  *     num    - the number of copies of singl to be present in newsng  */
end_comment

begin_function
name|int
name|copysingl
parameter_list|(
name|singl
parameter_list|,
name|num
parameter_list|)
name|int
name|singl
decl_stmt|,
name|num
decl_stmt|;
block|{
name|int
name|copy
decl_stmt|,
name|i
decl_stmt|;
name|copy
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|num
condition|;
operator|++
name|i
control|)
name|copy
operator|=
name|link_machines
argument_list|(
name|copy
argument_list|,
name|dupmachine
argument_list|(
name|singl
argument_list|)
argument_list|)
expr_stmt|;
return|return
name|copy
return|;
block|}
end_function

begin_comment
comment|/* dumpnfa - debugging routine to write out an nfa */
end_comment

begin_function
name|void
name|dumpnfa
parameter_list|(
name|state1
parameter_list|)
name|int
name|state1
decl_stmt|;
block|{
name|int
name|sym
decl_stmt|,
name|tsp1
decl_stmt|,
name|tsp2
decl_stmt|,
name|anum
decl_stmt|,
name|ns
decl_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"\n\n********** beginning dump of nfa with start state %d\n"
argument_list|)
argument_list|,
name|state1
argument_list|)
expr_stmt|;
comment|/* We probably should loop starting at firstst[state1] and going to 	 * lastst[state1], but they're not maintained properly when we "or" 	 * all of the rules together.  So we use our knowledge that the machine 	 * starts at state 1 and ends at lastnfa. 	 */
comment|/* for ( ns = firstst[state1]; ns<= lastst[state1]; ++ns ) */
for|for
control|(
name|ns
operator|=
literal|1
init|;
name|ns
operator|<=
name|lastnfa
condition|;
operator|++
name|ns
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %4d\t"
argument_list|)
argument_list|,
name|ns
argument_list|)
expr_stmt|;
name|sym
operator|=
name|transchar
index|[
name|ns
index|]
expr_stmt|;
name|tsp1
operator|=
name|trans1
index|[
name|ns
index|]
expr_stmt|;
name|tsp2
operator|=
name|trans2
index|[
name|ns
index|]
expr_stmt|;
name|anum
operator|=
name|accptnum
index|[
name|ns
index|]
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%3d:  %4d, %4d"
argument_list|,
name|sym
argument_list|,
name|tsp1
argument_list|,
name|tsp2
argument_list|)
expr_stmt|;
if|if
condition|(
name|anum
operator|!=
name|NIL
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"  [%d]"
argument_list|,
name|anum
argument_list|)
expr_stmt|;
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"\n"
argument_list|)
expr_stmt|;
block|}
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"********** end of dump\n"
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* dupmachine - make a duplicate of a given machine  *  * synopsis  *  *   copy = dupmachine( mach );  *  *     copy - holds duplicate of mach  *     mach - machine to be duplicated  *  * note that the copy of mach is NOT an exact duplicate; rather, all the  * transition states values are adjusted so that the copy is self-contained,  * as the original should have been.  *  * also note that the original MUST be contiguous, with its low and high  * states accessible by the arrays firstst and lastst  */
end_comment

begin_function
name|int
name|dupmachine
parameter_list|(
name|mach
parameter_list|)
name|int
name|mach
decl_stmt|;
block|{
name|int
name|i
decl_stmt|,
name|init
decl_stmt|,
name|state_offset
decl_stmt|;
name|int
name|state
init|=
literal|0
decl_stmt|;
name|int
name|last
init|=
name|lastst
index|[
name|mach
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
name|firstst
index|[
name|mach
index|]
init|;
name|i
operator|<=
name|last
condition|;
operator|++
name|i
control|)
block|{
name|state
operator|=
name|mkstate
argument_list|(
name|transchar
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans1
index|[
name|i
index|]
operator|!=
name|NO_TRANSITION
condition|)
block|{
name|mkxtion
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|,
name|trans1
index|[
name|i
index|]
operator|+
name|state
operator|-
name|i
argument_list|)
expr_stmt|;
if|if
condition|(
name|transchar
index|[
name|i
index|]
operator|==
name|SYM_EPSILON
operator|&&
name|trans2
index|[
name|i
index|]
operator|!=
name|NO_TRANSITION
condition|)
name|mkxtion
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|,
name|trans2
index|[
name|i
index|]
operator|+
name|state
operator|-
name|i
argument_list|)
expr_stmt|;
block|}
name|accptnum
index|[
name|state
index|]
operator|=
name|accptnum
index|[
name|i
index|]
expr_stmt|;
block|}
if|if
condition|(
name|state
operator|==
literal|0
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"empty machine in dupmachine()"
argument_list|)
argument_list|)
expr_stmt|;
name|state_offset
operator|=
name|state
operator|-
name|i
operator|+
literal|1
expr_stmt|;
name|init
operator|=
name|mach
operator|+
name|state_offset
expr_stmt|;
name|firstst
index|[
name|init
index|]
operator|=
name|firstst
index|[
name|mach
index|]
operator|+
name|state_offset
expr_stmt|;
name|finalst
index|[
name|init
index|]
operator|=
name|finalst
index|[
name|mach
index|]
operator|+
name|state_offset
expr_stmt|;
name|lastst
index|[
name|init
index|]
operator|=
name|lastst
index|[
name|mach
index|]
operator|+
name|state_offset
expr_stmt|;
return|return
name|init
return|;
block|}
end_function

begin_comment
comment|/* finish_rule - finish up the processing for a rule  *  * An accepting number is added to the given machine.  If variable_trail_rule  * is true then the rule has trailing context and both the head and trail  * are variable size.  Otherwise if headcnt or trailcnt is non-zero then  * the machine recognizes a pattern with trailing context and headcnt is  * the number of characters in the matched part of the pattern, or zero  * if the matched part has variable length.  trailcnt is the number of  * trailing context characters in the pattern, or zero if the trailing  * context has variable length.  */
end_comment

begin_function
name|void
name|finish_rule
parameter_list|(
name|mach
parameter_list|,
name|variable_trail_rule
parameter_list|,
name|headcnt
parameter_list|,
name|trailcnt
parameter_list|)
name|int
name|mach
decl_stmt|,
name|variable_trail_rule
decl_stmt|,
name|headcnt
decl_stmt|,
name|trailcnt
decl_stmt|;
block|{
name|char
name|action_text
index|[
name|MAXLINE
index|]
decl_stmt|;
name|add_accept
argument_list|(
name|mach
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
comment|/* We did this in new_rule(), but it often gets the wrong 	 * number because we do it before we start parsing the current rule. 	 */
name|rule_linenum
index|[
name|num_rules
index|]
operator|=
name|linenum
expr_stmt|;
comment|/* If this is a continued action, then the line-number has already 	 * been updated, giving us the wrong number. 	 */
if|if
condition|(
name|continued_action
condition|)
operator|--
name|rule_linenum
index|[
name|num_rules
index|]
expr_stmt|;
name|sprintf
argument_list|(
name|action_text
argument_list|,
literal|"case %d:\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|add_action
argument_list|(
name|action_text
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trail_rule
condition|)
block|{
name|rule_type
index|[
name|num_rules
index|]
operator|=
name|RULE_VARIABLE
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|0
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"Variable trailing context rule at line %d\n"
argument_list|)
argument_list|,
name|rule_linenum
index|[
name|num_rules
index|]
argument_list|)
expr_stmt|;
name|variable_trailing_context_rules
operator|=
name|true
expr_stmt|;
block|}
else|else
block|{
name|rule_type
index|[
name|num_rules
index|]
operator|=
name|RULE_NORMAL
expr_stmt|;
if|if
condition|(
name|headcnt
operator|>
literal|0
operator|||
name|trailcnt
operator|>
literal|0
condition|)
block|{
comment|/* Do trailing context magic to not match the trailing 			 * characters. 			 */
name|char
modifier|*
name|scanner_cp
init|=
literal|"yy_c_buf_p = yy_cp"
decl_stmt|;
name|char
modifier|*
name|scanner_bp
init|=
literal|"yy_bp"
decl_stmt|;
name|add_action
argument_list|(
literal|"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */\n"
argument_list|)
expr_stmt|;
if|if
condition|(
name|headcnt
operator|>
literal|0
condition|)
block|{
name|sprintf
argument_list|(
name|action_text
argument_list|,
literal|"%s = %s + %d;\n"
argument_list|,
name|scanner_cp
argument_list|,
name|scanner_bp
argument_list|,
name|headcnt
argument_list|)
expr_stmt|;
name|add_action
argument_list|(
name|action_text
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|sprintf
argument_list|(
name|action_text
argument_list|,
literal|"%s -= %d;\n"
argument_list|,
name|scanner_cp
argument_list|,
name|trailcnt
argument_list|)
expr_stmt|;
name|add_action
argument_list|(
name|action_text
argument_list|)
expr_stmt|;
block|}
name|add_action
argument_list|(
literal|"YY_DO_BEFORE_ACTION; /* set up yytext again */\n"
argument_list|)
expr_stmt|;
block|}
block|}
comment|/* Okay, in the action code at this point yytext and yyleng have 	 * their proper final values for this rule, so here's the point 	 * to do any user action.  But don't do it for continued actions, 	 * as that'll result in multiple YY_RULE_SETUP's. 	 */
if|if
condition|(
operator|!
name|continued_action
condition|)
name|add_action
argument_list|(
literal|"YY_RULE_SETUP\n"
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* link_machines - connect two machines together  *  * synopsis  *  *   new = link_machines( first, last );  *  *     new    - a machine constructed by connecting first to last  *     first  - the machine whose successor is to be last  *     last   - the machine whose predecessor is to be first  *  * note: this routine concatenates the machine first with the machine  *  last to produce a machine new which will pattern-match first first  *  and then last, and will fail if either of the sub-patterns fails.  *  FIRST is set to new by the operation.  last is unmolested.  */
end_comment

begin_function
name|int
name|link_machines
parameter_list|(
name|first
parameter_list|,
name|last
parameter_list|)
name|int
name|first
decl_stmt|,
name|last
decl_stmt|;
block|{
if|if
condition|(
name|first
operator|==
name|NIL
condition|)
return|return
name|last
return|;
elseif|else
if|if
condition|(
name|last
operator|==
name|NIL
condition|)
return|return
name|first
return|;
else|else
block|{
name|mkxtion
argument_list|(
name|finalst
index|[
name|first
index|]
argument_list|,
name|last
argument_list|)
expr_stmt|;
name|finalst
index|[
name|first
index|]
operator|=
name|finalst
index|[
name|last
index|]
expr_stmt|;
name|lastst
index|[
name|first
index|]
operator|=
name|MAX
argument_list|(
name|lastst
index|[
name|first
index|]
argument_list|,
name|lastst
index|[
name|last
index|]
argument_list|)
expr_stmt|;
name|firstst
index|[
name|first
index|]
operator|=
name|MIN
argument_list|(
name|firstst
index|[
name|first
index|]
argument_list|,
name|firstst
index|[
name|last
index|]
argument_list|)
expr_stmt|;
return|return
name|first
return|;
block|}
block|}
end_function

begin_comment
comment|/* mark_beginning_as_normal - mark each "beginning" state in a machine  *                            as being a "normal" (i.e., not trailing context-  *                            associated) states  *  * The "beginning" states are the epsilon closure of the first state  */
end_comment

begin_function
name|void
name|mark_beginning_as_normal
parameter_list|(
name|mach
parameter_list|)
specifier|register
name|int
name|mach
decl_stmt|;
block|{
switch|switch
condition|(
name|state_type
index|[
name|mach
index|]
condition|)
block|{
case|case
name|STATE_NORMAL
case|:
comment|/* Oh, we've already visited here. */
return|return;
case|case
name|STATE_TRAILING_CONTEXT
case|:
name|state_type
index|[
name|mach
index|]
operator|=
name|STATE_NORMAL
expr_stmt|;
if|if
condition|(
name|transchar
index|[
name|mach
index|]
operator|==
name|SYM_EPSILON
condition|)
block|{
if|if
condition|(
name|trans1
index|[
name|mach
index|]
operator|!=
name|NO_TRANSITION
condition|)
name|mark_beginning_as_normal
argument_list|(
name|trans1
index|[
name|mach
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|trans2
index|[
name|mach
index|]
operator|!=
name|NO_TRANSITION
condition|)
name|mark_beginning_as_normal
argument_list|(
name|trans2
index|[
name|mach
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
default|default:
name|flexerror
argument_list|(
name|_
argument_list|(
literal|"bad state type in mark_beginning_as_normal()"
argument_list|)
argument_list|)
expr_stmt|;
break|break;
block|}
block|}
end_function

begin_comment
comment|/* mkbranch - make a machine that branches to two machines  *  * synopsis  *  *   branch = mkbranch( first, second );  *  *     branch - a machine which matches either first's pattern or second's  *     first, second - machines whose patterns are to be or'ed (the | operator)  *  * Note that first and second are NEITHER destroyed by the operation.  Also,  * the resulting machine CANNOT be used with any other "mk" operation except  * more mkbranch's.  Compare with mkor()  */
end_comment

begin_function
name|int
name|mkbranch
parameter_list|(
name|first
parameter_list|,
name|second
parameter_list|)
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|NO_TRANSITION
condition|)
return|return
name|second
return|;
elseif|else
if|if
condition|(
name|second
operator|==
name|NO_TRANSITION
condition|)
return|return
name|first
return|;
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|eps
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|eps
argument_list|,
name|second
argument_list|)
expr_stmt|;
return|return
name|eps
return|;
block|}
end_function

begin_comment
comment|/* mkclos - convert a machine into a closure  *  * synopsis  *   new = mkclos( state );  *  * new - a new state which matches the closure of "state"  */
end_comment

begin_function
name|int
name|mkclos
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
return|return
name|mkopt
argument_list|(
name|mkposcl
argument_list|(
name|state
argument_list|)
argument_list|)
return|;
block|}
end_function

begin_comment
comment|/* mkopt - make a machine optional  *  * synopsis  *  *   new = mkopt( mach );  *  *     new  - a machine which optionally matches whatever mach matched  *     mach - the machine to make optional  *  * notes:  *     1. mach must be the last machine created  *     2. mach is destroyed by the call  */
end_comment

begin_function
name|int
name|mkopt
parameter_list|(
name|mach
parameter_list|)
name|int
name|mach
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|;
if|if
condition|(
operator|!
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|mach
index|]
argument_list|)
condition|)
block|{
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mach
operator|=
name|link_machines
argument_list|(
name|mach
argument_list|,
name|eps
argument_list|)
expr_stmt|;
block|}
comment|/* Can't skimp on the following if FREE_EPSILON(mach) is true because 	 * some state interior to "mach" might point back to the beginning 	 * for a closure. 	 */
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mach
operator|=
name|link_machines
argument_list|(
name|eps
argument_list|,
name|mach
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|mach
argument_list|,
name|finalst
index|[
name|mach
index|]
argument_list|)
expr_stmt|;
return|return
name|mach
return|;
block|}
end_function

begin_comment
comment|/* mkor - make a machine that matches either one of two machines  *  * synopsis  *  *   new = mkor( first, second );  *  *     new - a machine which matches either first's pattern or second's  *     first, second - machines whose patterns are to be or'ed (the | operator)  *  * note that first and second are both destroyed by the operation  * the code is rather convoluted because an attempt is made to minimize  * the number of epsilon states needed  */
end_comment

begin_function
name|int
name|mkor
parameter_list|(
name|first
parameter_list|,
name|second
parameter_list|)
name|int
name|first
decl_stmt|,
name|second
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|,
name|orend
decl_stmt|;
if|if
condition|(
name|first
operator|==
name|NIL
condition|)
return|return
name|second
return|;
elseif|else
if|if
condition|(
name|second
operator|==
name|NIL
condition|)
return|return
name|first
return|;
else|else
block|{
comment|/* See comment in mkopt() about why we can't use the first 		 * state of "first" or "second" if they satisfy "FREE_EPSILON". 		 */
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|first
operator|=
name|link_machines
argument_list|(
name|eps
argument_list|,
name|first
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|first
argument_list|,
name|second
argument_list|)
expr_stmt|;
if|if
condition|(
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|first
index|]
argument_list|)
operator|&&
name|accptnum
index|[
name|finalst
index|[
name|first
index|]
index|]
operator|==
name|NIL
condition|)
block|{
name|orend
operator|=
name|finalst
index|[
name|first
index|]
expr_stmt|;
name|mkxtion
argument_list|(
name|finalst
index|[
name|second
index|]
argument_list|,
name|orend
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|second
index|]
argument_list|)
operator|&&
name|accptnum
index|[
name|finalst
index|[
name|second
index|]
index|]
operator|==
name|NIL
condition|)
block|{
name|orend
operator|=
name|finalst
index|[
name|second
index|]
expr_stmt|;
name|mkxtion
argument_list|(
name|finalst
index|[
name|first
index|]
argument_list|,
name|orend
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|first
operator|=
name|link_machines
argument_list|(
name|first
argument_list|,
name|eps
argument_list|)
expr_stmt|;
name|orend
operator|=
name|finalst
index|[
name|first
index|]
expr_stmt|;
name|mkxtion
argument_list|(
name|finalst
index|[
name|second
index|]
argument_list|,
name|orend
argument_list|)
expr_stmt|;
block|}
block|}
name|finalst
index|[
name|first
index|]
operator|=
name|orend
expr_stmt|;
return|return
name|first
return|;
block|}
end_function

begin_comment
comment|/* mkposcl - convert a machine into a positive closure  *  * synopsis  *   new = mkposcl( state );  *  *    new - a machine matching the positive closure of "state"  */
end_comment

begin_function
name|int
name|mkposcl
parameter_list|(
name|state
parameter_list|)
name|int
name|state
decl_stmt|;
block|{
name|int
name|eps
decl_stmt|;
if|if
condition|(
name|SUPER_FREE_EPSILON
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|)
condition|)
block|{
name|mkxtion
argument_list|(
name|finalst
index|[
name|state
index|]
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|state
return|;
block|}
else|else
block|{
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|mkxtion
argument_list|(
name|eps
argument_list|,
name|state
argument_list|)
expr_stmt|;
return|return
name|link_machines
argument_list|(
name|state
argument_list|,
name|eps
argument_list|)
return|;
block|}
block|}
end_function

begin_comment
comment|/* mkrep - make a replicated machine  *  * synopsis  *   new = mkrep( mach, lb, ub );  *  *    new - a machine that matches whatever "mach" matched from "lb"  *          number of times to "ub" number of times  *  * note  *   if "ub" is INFINITY then "new" matches "lb" or more occurrences of "mach"  */
end_comment

begin_function
name|int
name|mkrep
parameter_list|(
name|mach
parameter_list|,
name|lb
parameter_list|,
name|ub
parameter_list|)
name|int
name|mach
decl_stmt|,
name|lb
decl_stmt|,
name|ub
decl_stmt|;
block|{
name|int
name|base_mach
decl_stmt|,
name|tail
decl_stmt|,
name|copy
decl_stmt|,
name|i
decl_stmt|;
name|base_mach
operator|=
name|copysingl
argument_list|(
name|mach
argument_list|,
name|lb
operator|-
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|ub
operator|==
name|INFINITY
condition|)
block|{
name|copy
operator|=
name|dupmachine
argument_list|(
name|mach
argument_list|)
expr_stmt|;
name|mach
operator|=
name|link_machines
argument_list|(
name|mach
argument_list|,
name|link_machines
argument_list|(
name|base_mach
argument_list|,
name|mkclos
argument_list|(
name|copy
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|tail
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|lb
init|;
name|i
operator|<
name|ub
condition|;
operator|++
name|i
control|)
block|{
name|copy
operator|=
name|dupmachine
argument_list|(
name|mach
argument_list|)
expr_stmt|;
name|tail
operator|=
name|mkopt
argument_list|(
name|link_machines
argument_list|(
name|copy
argument_list|,
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|mach
operator|=
name|link_machines
argument_list|(
name|mach
argument_list|,
name|link_machines
argument_list|(
name|base_mach
argument_list|,
name|tail
argument_list|)
argument_list|)
expr_stmt|;
block|}
return|return
name|mach
return|;
block|}
end_function

begin_comment
comment|/* mkstate - create a state with a transition on a given symbol  *  * synopsis  *  *   state = mkstate( sym );  *  *     state - a new state matching sym  *     sym   - the symbol the new state is to have an out-transition on  *  * note that this routine makes new states in ascending order through the  * state array (and increments LASTNFA accordingly).  The routine DUPMACHINE  * relies on machines being made in ascending order and that they are  * CONTIGUOUS.  Change it and you will have to rewrite DUPMACHINE (kludge  * that it admittedly is)  */
end_comment

begin_function
name|int
name|mkstate
parameter_list|(
name|sym
parameter_list|)
name|int
name|sym
decl_stmt|;
block|{
if|if
condition|(
operator|++
name|lastnfa
operator|>=
name|current_mns
condition|)
block|{
if|if
condition|(
operator|(
name|current_mns
operator|+=
name|MNS_INCREMENT
operator|)
operator|>=
name|MAXIMUM_MNS
condition|)
name|lerrif
argument_list|(
name|_
argument_list|(
literal|"input rules are too complicated (>= %d NFA states)"
argument_list|)
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
operator|++
name|num_reallocs
expr_stmt|;
name|firstst
operator|=
name|reallocate_integer_array
argument_list|(
name|firstst
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|lastst
operator|=
name|reallocate_integer_array
argument_list|(
name|lastst
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|finalst
operator|=
name|reallocate_integer_array
argument_list|(
name|finalst
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|transchar
operator|=
name|reallocate_integer_array
argument_list|(
name|transchar
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|trans1
operator|=
name|reallocate_integer_array
argument_list|(
name|trans1
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|trans2
operator|=
name|reallocate_integer_array
argument_list|(
name|trans2
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|accptnum
operator|=
name|reallocate_integer_array
argument_list|(
name|accptnum
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|assoc_rule
operator|=
name|reallocate_integer_array
argument_list|(
name|assoc_rule
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
name|state_type
operator|=
name|reallocate_integer_array
argument_list|(
name|state_type
argument_list|,
name|current_mns
argument_list|)
expr_stmt|;
block|}
name|firstst
index|[
name|lastnfa
index|]
operator|=
name|lastnfa
expr_stmt|;
name|finalst
index|[
name|lastnfa
index|]
operator|=
name|lastnfa
expr_stmt|;
name|lastst
index|[
name|lastnfa
index|]
operator|=
name|lastnfa
expr_stmt|;
name|transchar
index|[
name|lastnfa
index|]
operator|=
name|sym
expr_stmt|;
name|trans1
index|[
name|lastnfa
index|]
operator|=
name|NO_TRANSITION
expr_stmt|;
name|trans2
index|[
name|lastnfa
index|]
operator|=
name|NO_TRANSITION
expr_stmt|;
name|accptnum
index|[
name|lastnfa
index|]
operator|=
name|NIL
expr_stmt|;
name|assoc_rule
index|[
name|lastnfa
index|]
operator|=
name|num_rules
expr_stmt|;
name|state_type
index|[
name|lastnfa
index|]
operator|=
name|current_state_type
expr_stmt|;
comment|/* Fix up equivalence classes base on this transition.  Note that any 	 * character which has its own transition gets its own equivalence 	 * class.  Thus only characters which are only in character classes 	 * have a chance at being in the same equivalence class.  E.g. "a|b" 	 * puts 'a' and 'b' into two different equivalence classes.  "[ab]" 	 * puts them in the same equivalence class (barring other differences 	 * elsewhere in the input). 	 */
if|if
condition|(
name|sym
operator|<
literal|0
condition|)
block|{
comment|/* We don't have to update the equivalence classes since 		 * that was already done when the ccl was created for the 		 * first time. 		 */
block|}
elseif|else
if|if
condition|(
name|sym
operator|==
name|SYM_EPSILON
condition|)
operator|++
name|numeps
expr_stmt|;
else|else
block|{
name|check_char
argument_list|(
name|sym
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
comment|/* Map NUL's to csize. */
name|mkechar
argument_list|(
name|sym
condition|?
name|sym
else|:
name|csize
argument_list|,
name|nextecm
argument_list|,
name|ecgroup
argument_list|)
expr_stmt|;
block|}
return|return
name|lastnfa
return|;
block|}
end_function

begin_comment
comment|/* mkxtion - make a transition from one state to another  *  * synopsis  *  *   mkxtion( statefrom, stateto );  *  *     statefrom - the state from which the transition is to be made  *     stateto   - the state to which the transition is to be made  */
end_comment

begin_function
name|void
name|mkxtion
parameter_list|(
name|statefrom
parameter_list|,
name|stateto
parameter_list|)
name|int
name|statefrom
decl_stmt|,
name|stateto
decl_stmt|;
block|{
if|if
condition|(
name|trans1
index|[
name|statefrom
index|]
operator|==
name|NO_TRANSITION
condition|)
name|trans1
index|[
name|statefrom
index|]
operator|=
name|stateto
expr_stmt|;
elseif|else
if|if
condition|(
operator|(
name|transchar
index|[
name|statefrom
index|]
operator|!=
name|SYM_EPSILON
operator|)
operator|||
operator|(
name|trans2
index|[
name|statefrom
index|]
operator|!=
name|NO_TRANSITION
operator|)
condition|)
name|flexfatal
argument_list|(
name|_
argument_list|(
literal|"found too many transitions in mkxtion()"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* second out-transition for an epsilon state */
operator|++
name|eps2
expr_stmt|;
name|trans2
index|[
name|statefrom
index|]
operator|=
name|stateto
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* new_rule - initialize for a new rule */
end_comment

begin_function
name|void
name|new_rule
parameter_list|()
block|{
if|if
condition|(
operator|++
name|num_rules
operator|>=
name|current_max_rules
condition|)
block|{
operator|++
name|num_reallocs
expr_stmt|;
name|current_max_rules
operator|+=
name|MAX_RULES_INCREMENT
expr_stmt|;
name|rule_type
operator|=
name|reallocate_integer_array
argument_list|(
name|rule_type
argument_list|,
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_linenum
operator|=
name|reallocate_integer_array
argument_list|(
name|rule_linenum
argument_list|,
name|current_max_rules
argument_list|)
expr_stmt|;
name|rule_useful
operator|=
name|reallocate_integer_array
argument_list|(
name|rule_useful
argument_list|,
name|current_max_rules
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|num_rules
operator|>
name|MAX_RULE
condition|)
name|lerrif
argument_list|(
name|_
argument_list|(
literal|"too many rules (> %d)!"
argument_list|)
argument_list|,
name|MAX_RULE
argument_list|)
expr_stmt|;
name|rule_linenum
index|[
name|num_rules
index|]
operator|=
name|linenum
expr_stmt|;
name|rule_useful
index|[
name|num_rules
index|]
operator|=
name|false
expr_stmt|;
block|}
end_function

end_unit

