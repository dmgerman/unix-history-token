begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|lint
end_ifndef

begin_decl_stmt
specifier|static
specifier|const
name|char
name|yysccsid
index|[]
init|=
literal|"@(#)yaccpar	1.9 (Berkeley) 02/21/93"
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYBYACC
value|1
end_define

begin_define
define|#
directive|define
name|YYMAJOR
value|1
end_define

begin_define
define|#
directive|define
name|YYMINOR
value|9
end_define

begin_define
define|#
directive|define
name|YYEMPTY
value|(-1)
end_define

begin_define
define|#
directive|define
name|yyclearin
value|(yychar = YYEMPTY)
end_define

begin_define
define|#
directive|define
name|yyerrok
value|(yyerrflag = 0)
end_define

begin_define
define|#
directive|define
name|YYRECOVERING
parameter_list|()
value|(yyerrflag != 0)
end_define

begin_define
define|#
directive|define
name|YYPREFIX
value|"yy"
end_define

begin_define
define|#
directive|define
name|YYPURE
value|0
end_define

begin_line
line|#
directive|line
number|35
file|"parse.y"
end_line

begin_comment
comment|/*  Copyright (c) 1990 The Regents of the University of California. */
end_comment

begin_comment
comment|/*  All rights reserved. */
end_comment

begin_comment
comment|/*  This code is derived from software contributed to Berkeley by */
end_comment

begin_comment
comment|/*  Vern Paxson. */
end_comment

begin_comment
comment|/*  The United States Government has rights in this work pursuant */
end_comment

begin_comment
comment|/*  to contract no. DE-AC03-76SF00098 between the United States */
end_comment

begin_comment
comment|/*  Department of Energy and the University of California. */
end_comment

begin_comment
comment|/*  This file is part of flex. */
end_comment

begin_comment
comment|/*  Redistribution and use in source and binary forms, with or without */
end_comment

begin_comment
comment|/*  modification, are permitted provided that the following conditions */
end_comment

begin_comment
comment|/*  are met: */
end_comment

begin_comment
comment|/*  1. Redistributions of source code must retain the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer. */
end_comment

begin_comment
comment|/*  2. Redistributions in binary form must reproduce the above copyright */
end_comment

begin_comment
comment|/*     notice, this list of conditions and the following disclaimer in the */
end_comment

begin_comment
comment|/*     documentation and/or other materials provided with the distribution. */
end_comment

begin_comment
comment|/*  Neither the name of the University nor the names of its contributors */
end_comment

begin_comment
comment|/*  may be used to endorse or promote products derived from this software */
end_comment

begin_comment
comment|/*  without specific prior written permission. */
end_comment

begin_comment
comment|/*  THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR */
end_comment

begin_comment
comment|/*  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED */
end_comment

begin_comment
comment|/*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR */
end_comment

begin_comment
comment|/*  PURPOSE. */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_include
include|#
directive|include
file|"tables.h"
end_include

begin_decl_stmt
name|int
name|pat
decl_stmt|,
name|scnum
decl_stmt|,
name|eps
decl_stmt|,
name|headcnt
decl_stmt|,
name|trailcnt
decl_stmt|,
name|lastchar
decl_stmt|,
name|i
decl_stmt|,
name|rulelen
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|trlcontxt
decl_stmt|,
name|xcluflg
decl_stmt|,
name|currccl
decl_stmt|,
name|cclsorted
decl_stmt|,
name|varlength
decl_stmt|,
name|variable_trail_rule
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
modifier|*
name|scon_stk
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|scon_stk_ptr
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|madeany
init|=
name|false
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether we've made the '.' character class */
end_comment

begin_decl_stmt
specifier|static
name|int
name|ccldot
decl_stmt|,
name|cclany
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|previous_continued_action
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* whether the previous rule's action was '|' */
end_comment

begin_define
define|#
directive|define
name|format_warn3
parameter_list|(
name|fmt
parameter_list|,
name|a1
parameter_list|,
name|a2
parameter_list|)
define|\
value|do{ \         char fw3_msg[MAXLINE];\         snprintf( fw3_msg, MAXLINE,(fmt), (a1), (a2) );\         warn( fw3_msg );\ 	}while(0)
end_define

begin_comment
comment|/* Expand a POSIX character class expression. */
end_comment

begin_define
define|#
directive|define
name|CCL_EXPR
parameter_list|(
name|func
parameter_list|)
define|\
value|do{ \ 	int c; \ 	for ( c = 0; c< csize; ++c ) \ 		if ( isascii(c)&& func(c) ) \ 			ccladd( currccl, c ); \ 	}while(0)
end_define

begin_comment
comment|/* negated class */
end_comment

begin_define
define|#
directive|define
name|CCL_NEG_EXPR
parameter_list|(
name|func
parameter_list|)
define|\
value|do{ \ 	int c; \ 	for ( c = 0; c< csize; ++c ) \ 		if ( !func(c) ) \ 			ccladd( currccl, c ); \ 	}while(0)
end_define

begin_comment
comment|/* While POSIX defines isblank(), it's not ANSI C. */
end_comment

begin_define
define|#
directive|define
name|IS_BLANK
parameter_list|(
name|c
parameter_list|)
value|((c) == ' ' || (c) == '\t')
end_define

begin_comment
comment|/* On some over-ambitious machines, such as DEC Alpha's, the default  * token type is "long" instead of "int"; this leads to problems with  * declaring yylval in flexdef.h.  But so far, all the yacc's I've seen  * wrap their definitions of YYSTYPE with "#ifndef YYSTYPE"'s, so the  * following should ensure that the default token type is "int".  */
end_comment

begin_define
define|#
directive|define
name|YYSTYPE
value|int
end_define

begin_line
line|#
directive|line
number|99
file|"parse.c"
end_line

begin_ifndef
ifndef|#
directive|ifndef
name|YYSTYPE
end_ifndef

begin_typedef
typedef|typedef
name|int
name|YYSTYPE
typedef|;
end_typedef

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* compatibility with bison */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM
end_ifdef

begin_comment
comment|/* compatibility with FreeBSD */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYPARSE_PARAM_TYPE
end_ifdef

begin_define
define|#
directive|define
name|YYPARSE_DECL
parameter_list|()
value|yyparse(YYPARSE_PARAM_TYPE YYPARSE_PARAM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYPARSE_DECL
parameter_list|()
value|yyparse(void *YYPARSE_PARAM)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYPARSE_DECL
parameter_list|()
value|yyparse(void)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Parameters sent to lex. */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYLEX_PARAM
end_ifdef

begin_define
define|#
directive|define
name|YYLEX_DECL
parameter_list|()
value|yylex(void *YYLEX_PARAM)
end_define

begin_define
define|#
directive|define
name|YYLEX
value|yylex(YYLEX_PARAM)
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYLEX_DECL
parameter_list|()
value|yylex(void)
end_define

begin_define
define|#
directive|define
name|YYLEX
value|yylex()
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_comment
comment|/* Parameters sent to yyerror. */
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|YYERROR_DECL
end_ifndef

begin_define
define|#
directive|define
name|YYERROR_DECL
parameter_list|()
value|yyerror(const char *s)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_ifndef
ifndef|#
directive|ifndef
name|YYERROR_CALL
end_ifndef

begin_define
define|#
directive|define
name|YYERROR_CALL
parameter_list|(
name|msg
parameter_list|)
value|yyerror(msg)
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_function_decl
specifier|extern
name|int
name|YYPARSE_DECL
parameter_list|()
function_decl|;
end_function_decl

begin_define
define|#
directive|define
name|CHAR
value|257
end_define

begin_define
define|#
directive|define
name|NUMBER
value|258
end_define

begin_define
define|#
directive|define
name|SECTEND
value|259
end_define

begin_define
define|#
directive|define
name|SCDECL
value|260
end_define

begin_define
define|#
directive|define
name|XSCDECL
value|261
end_define

begin_define
define|#
directive|define
name|NAME
value|262
end_define

begin_define
define|#
directive|define
name|PREVCCL
value|263
end_define

begin_define
define|#
directive|define
name|EOF_OP
value|264
end_define

begin_define
define|#
directive|define
name|OPTION_OP
value|265
end_define

begin_define
define|#
directive|define
name|OPT_OUTFILE
value|266
end_define

begin_define
define|#
directive|define
name|OPT_PREFIX
value|267
end_define

begin_define
define|#
directive|define
name|OPT_YYCLASS
value|268
end_define

begin_define
define|#
directive|define
name|OPT_HEADER
value|269
end_define

begin_define
define|#
directive|define
name|OPT_EXTRA_TYPE
value|270
end_define

begin_define
define|#
directive|define
name|OPT_TABLES
value|271
end_define

begin_define
define|#
directive|define
name|CCE_ALNUM
value|272
end_define

begin_define
define|#
directive|define
name|CCE_ALPHA
value|273
end_define

begin_define
define|#
directive|define
name|CCE_BLANK
value|274
end_define

begin_define
define|#
directive|define
name|CCE_CNTRL
value|275
end_define

begin_define
define|#
directive|define
name|CCE_DIGIT
value|276
end_define

begin_define
define|#
directive|define
name|CCE_GRAPH
value|277
end_define

begin_define
define|#
directive|define
name|CCE_LOWER
value|278
end_define

begin_define
define|#
directive|define
name|CCE_PRINT
value|279
end_define

begin_define
define|#
directive|define
name|CCE_PUNCT
value|280
end_define

begin_define
define|#
directive|define
name|CCE_SPACE
value|281
end_define

begin_define
define|#
directive|define
name|CCE_UPPER
value|282
end_define

begin_define
define|#
directive|define
name|CCE_XDIGIT
value|283
end_define

begin_define
define|#
directive|define
name|CCE_NEG_ALNUM
value|284
end_define

begin_define
define|#
directive|define
name|CCE_NEG_ALPHA
value|285
end_define

begin_define
define|#
directive|define
name|CCE_NEG_BLANK
value|286
end_define

begin_define
define|#
directive|define
name|CCE_NEG_CNTRL
value|287
end_define

begin_define
define|#
directive|define
name|CCE_NEG_DIGIT
value|288
end_define

begin_define
define|#
directive|define
name|CCE_NEG_GRAPH
value|289
end_define

begin_define
define|#
directive|define
name|CCE_NEG_LOWER
value|290
end_define

begin_define
define|#
directive|define
name|CCE_NEG_PRINT
value|291
end_define

begin_define
define|#
directive|define
name|CCE_NEG_PUNCT
value|292
end_define

begin_define
define|#
directive|define
name|CCE_NEG_SPACE
value|293
end_define

begin_define
define|#
directive|define
name|CCE_NEG_UPPER
value|294
end_define

begin_define
define|#
directive|define
name|CCE_NEG_XDIGIT
value|295
end_define

begin_define
define|#
directive|define
name|CCL_OP_DIFF
value|296
end_define

begin_define
define|#
directive|define
name|CCL_OP_UNION
value|297
end_define

begin_define
define|#
directive|define
name|BEGIN_REPEAT_POSIX
value|298
end_define

begin_define
define|#
directive|define
name|END_REPEAT_POSIX
value|299
end_define

begin_define
define|#
directive|define
name|BEGIN_REPEAT_FLEX
value|300
end_define

begin_define
define|#
directive|define
name|END_REPEAT_FLEX
value|301
end_define

begin_define
define|#
directive|define
name|YYERRCODE
value|256
end_define

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yylhs
index|[]
init|=
block|{
operator|-
literal|1
block|,
literal|0
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|3
block|,
literal|6
block|,
literal|6
block|,
literal|7
block|,
literal|7
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|9
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|10
block|,
literal|4
block|,
literal|4
block|,
literal|4
block|,
literal|5
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|12
block|,
literal|14
block|,
literal|11
block|,
literal|11
block|,
literal|11
block|,
literal|15
block|,
literal|15
block|,
literal|15
block|,
literal|16
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|18
block|,
literal|18
block|,
literal|17
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|19
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|20
block|,
literal|21
block|,
literal|21
block|,
literal|21
block|,
literal|23
block|,
literal|23
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|24
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|25
block|,
literal|22
block|,
literal|22
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yylen
index|[]
init|=
block|{
literal|2
block|,
literal|5
block|,
literal|0
block|,
literal|3
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|5
block|,
literal|5
block|,
literal|0
block|,
literal|0
block|,
literal|2
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|0
block|,
literal|4
block|,
literal|3
block|,
literal|0
block|,
literal|3
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|3
block|,
literal|2
block|,
literal|1
block|,
literal|3
block|,
literal|1
block|,
literal|2
block|,
literal|2
block|,
literal|1
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|2
block|,
literal|6
block|,
literal|5
block|,
literal|4
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|3
block|,
literal|1
block|,
literal|3
block|,
literal|4
block|,
literal|4
block|,
literal|2
block|,
literal|2
block|,
literal|0
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|1
block|,
literal|2
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydefred
index|[]
init|=
block|{
literal|2
block|,
literal|0
block|,
literal|0
block|,
literal|6
block|,
literal|0
block|,
literal|7
block|,
literal|8
block|,
literal|9
block|,
literal|15
block|,
literal|24
block|,
literal|0
block|,
literal|4
block|,
literal|0
block|,
literal|0
block|,
literal|12
block|,
literal|11
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|14
block|,
literal|0
block|,
literal|1
block|,
literal|0
block|,
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|24
block|,
literal|0
block|,
literal|16
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|17
block|,
literal|21
block|,
literal|32
block|,
literal|36
block|,
literal|37
block|,
literal|0
block|,
literal|35
block|,
literal|0
block|,
literal|29
block|,
literal|61
block|,
literal|58
block|,
literal|28
block|,
literal|0
block|,
literal|56
block|,
literal|96
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|27
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|64
block|,
literal|31
block|,
literal|0
block|,
literal|23
block|,
literal|26
block|,
literal|0
block|,
literal|0
block|,
literal|70
block|,
literal|0
block|,
literal|22
block|,
literal|0
block|,
literal|40
block|,
literal|0
block|,
literal|44
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|50
block|,
literal|51
block|,
literal|52
block|,
literal|0
block|,
literal|0
block|,
literal|34
block|,
literal|95
block|,
literal|59
block|,
literal|60
block|,
literal|0
block|,
literal|0
block|,
literal|71
block|,
literal|72
block|,
literal|73
block|,
literal|74
block|,
literal|75
block|,
literal|76
block|,
literal|77
block|,
literal|78
block|,
literal|79
block|,
literal|80
block|,
literal|82
block|,
literal|81
block|,
literal|83
block|,
literal|84
block|,
literal|85
block|,
literal|86
block|,
literal|87
block|,
literal|88
block|,
literal|93
block|,
literal|89
block|,
literal|90
block|,
literal|91
block|,
literal|94
block|,
literal|92
block|,
literal|65
block|,
literal|69
block|,
literal|39
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|62
block|,
literal|63
block|,
literal|66
block|,
literal|0
block|,
literal|49
block|,
literal|0
block|,
literal|55
block|,
literal|0
block|,
literal|67
block|,
literal|0
block|,
literal|48
block|,
literal|0
block|,
literal|54
block|,
literal|47
block|,
literal|53
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yydgoto
index|[]
init|=
block|{
literal|1
block|,
literal|2
block|,
literal|4
block|,
literal|9
block|,
literal|13
block|,
literal|25
block|,
literal|10
block|,
literal|16
block|,
literal|11
block|,
literal|12
block|,
literal|23
block|,
literal|26
block|,
literal|59
block|,
literal|60
block|,
literal|35
block|,
literal|47
block|,
literal|48
block|,
literal|61
block|,
literal|62
block|,
literal|63
block|,
literal|64
block|,
literal|65
block|,
literal|71
block|,
literal|66
block|,
literal|74
block|,
literal|119
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yysindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|222
block|,
literal|0
block|,
operator|-
literal|155
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|215
block|,
literal|0
block|,
operator|-
literal|123
block|,
literal|6
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|193
block|,
literal|10
block|,
literal|21
block|,
literal|26
block|,
literal|31
block|,
literal|35
block|,
literal|37
block|,
literal|0
block|,
literal|59
block|,
literal|0
block|,
operator|-
literal|44
block|,
literal|0
block|,
operator|-
literal|147
block|,
operator|-
literal|145
block|,
operator|-
literal|140
block|,
operator|-
literal|133
block|,
operator|-
literal|132
block|,
operator|-
literal|129
block|,
literal|75
block|,
operator|-
literal|214
block|,
literal|0
block|,
operator|-
literal|19
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|23
block|,
literal|0
block|,
operator|-
literal|48
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|17
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|17
block|,
literal|27
block|,
literal|128
block|,
literal|0
block|,
operator|-
literal|17
block|,
operator|-
literal|1
block|,
operator|-
literal|30
block|,
operator|-
literal|41
block|,
operator|-
literal|189
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|121
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|31
block|,
operator|-
literal|34
block|,
literal|0
block|,
operator|-
literal|87
block|,
literal|0
block|,
operator|-
literal|25
block|,
literal|0
block|,
operator|-
literal|17
block|,
literal|0
block|,
operator|-
literal|109
block|,
operator|-
literal|41
block|,
operator|-
literal|108
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|60
block|,
literal|60
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|46
block|,
literal|107
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|30
block|,
operator|-
literal|36
block|,
operator|-
literal|39
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|104
block|,
literal|0
block|,
operator|-
literal|219
block|,
literal|0
block|,
operator|-
literal|238
block|,
literal|0
block|,
operator|-
literal|144
block|,
literal|0
block|,
operator|-
literal|143
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yyrindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
operator|-
literal|141
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|134
block|,
literal|9
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|125
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|178
block|,
literal|0
block|,
literal|22
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
operator|-
literal|21
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|85
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|144
block|,
literal|47
block|,
literal|4
block|,
operator|-
literal|10
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|146
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|18
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|124
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|50
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yygindex
index|[]
init|=
block|{
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|121
block|,
literal|133
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|106
block|,
literal|0
block|,
literal|0
block|,
literal|93
block|,
literal|0
block|,
literal|32
block|,
literal|84
block|,
operator|-
literal|45
block|,
literal|0
block|,
literal|0
block|,
literal|25
block|,
literal|90
block|,
literal|0
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYTABLESIZE
value|419
end_define

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yytable
index|[]
init|=
block|{
literal|57
block|,
literal|83
block|,
literal|84
block|,
literal|90
block|,
literal|56
block|,
literal|131
block|,
literal|118
block|,
literal|91
block|,
literal|129
block|,
literal|25
block|,
literal|57
block|,
literal|120
block|,
literal|24
block|,
literal|33
block|,
literal|46
block|,
literal|56
block|,
literal|55
block|,
literal|56
block|,
literal|81
block|,
literal|33
block|,
literal|135
block|,
literal|57
block|,
literal|85
block|,
literal|57
block|,
literal|57
block|,
literal|33
block|,
literal|57
block|,
literal|55
block|,
literal|45
block|,
literal|55
block|,
literal|57
block|,
literal|57
block|,
literal|57
block|,
literal|57
block|,
literal|3
block|,
literal|77
block|,
literal|57
block|,
literal|57
block|,
literal|46
block|,
literal|133
block|,
literal|46
block|,
literal|14
block|,
literal|45
block|,
literal|33
block|,
literal|46
block|,
literal|46
block|,
literal|79
block|,
literal|15
block|,
literal|46
block|,
literal|33
block|,
literal|46
block|,
literal|46
block|,
literal|45
block|,
literal|57
block|,
literal|45
block|,
literal|33
block|,
literal|25
block|,
literal|43
block|,
literal|45
block|,
literal|45
block|,
literal|42
block|,
literal|58
block|,
literal|25
block|,
literal|136
block|,
literal|45
block|,
literal|45
block|,
literal|24
block|,
literal|68
block|,
literal|25
block|,
literal|27
block|,
literal|33
block|,
literal|28
block|,
literal|58
block|,
literal|33
block|,
literal|58
block|,
literal|54
block|,
literal|81
block|,
literal|69
block|,
literal|30
block|,
literal|36
block|,
literal|134
block|,
literal|57
block|,
literal|29
block|,
literal|43
block|,
literal|30
block|,
literal|67
block|,
literal|42
block|,
literal|30
block|,
literal|43
block|,
literal|72
block|,
literal|78
block|,
literal|42
block|,
literal|31
block|,
literal|76
block|,
literal|43
block|,
literal|46
block|,
literal|32
block|,
literal|42
block|,
literal|33
block|,
literal|78
block|,
literal|33
block|,
literal|34
block|,
literal|33
block|,
literal|33
block|,
literal|5
block|,
literal|6
block|,
literal|7
block|,
literal|86
block|,
literal|87
block|,
literal|45
block|,
literal|8
block|,
literal|124
block|,
literal|125
block|,
literal|25
block|,
literal|57
block|,
literal|38
block|,
literal|25
block|,
literal|39
block|,
literal|5
block|,
literal|5
block|,
literal|5
block|,
literal|73
block|,
literal|40
block|,
literal|78
block|,
literal|5
block|,
literal|13
block|,
literal|13
block|,
literal|13
block|,
literal|46
block|,
literal|41
block|,
literal|42
block|,
literal|13
block|,
literal|33
block|,
literal|43
block|,
literal|3
block|,
literal|3
block|,
literal|3
block|,
literal|44
block|,
literal|75
block|,
literal|126
block|,
literal|3
block|,
literal|46
block|,
literal|45
block|,
literal|17
block|,
literal|18
block|,
literal|19
block|,
literal|20
block|,
literal|21
block|,
literal|22
block|,
literal|122
block|,
literal|123
block|,
literal|58
block|,
literal|127
block|,
literal|132
block|,
literal|41
block|,
literal|137
block|,
literal|38
block|,
literal|49
block|,
literal|138
block|,
literal|37
block|,
literal|70
block|,
literal|88
block|,
literal|121
block|,
literal|92
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|93
block|,
literal|43
block|,
literal|0
block|,
literal|0
block|,
literal|42
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|70
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|68
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|89
block|,
literal|51
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|52
block|,
literal|0
block|,
literal|33
block|,
literal|33
block|,
literal|50
block|,
literal|51
block|,
literal|0
block|,
literal|51
block|,
literal|0
block|,
literal|33
block|,
literal|33
block|,
literal|52
block|,
literal|53
block|,
literal|52
block|,
literal|57
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|57
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|82
block|,
literal|0
block|,
literal|46
block|,
literal|130
block|,
literal|128
block|,
literal|0
block|,
literal|33
block|,
literal|33
block|,
literal|46
block|,
literal|80
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|33
block|,
literal|33
block|,
literal|0
block|,
literal|45
block|,
literal|0
block|,
literal|0
block|,
literal|25
block|,
literal|25
block|,
literal|0
block|,
literal|45
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|25
block|,
literal|25
block|,
literal|0
block|,
literal|57
block|,
literal|0
block|,
literal|57
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|46
block|,
literal|93
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|45
block|,
literal|0
block|,
literal|94
block|,
literal|95
block|,
literal|96
block|,
literal|97
block|,
literal|98
block|,
literal|99
block|,
literal|100
block|,
literal|101
block|,
literal|102
block|,
literal|103
block|,
literal|104
block|,
literal|105
block|,
literal|106
block|,
literal|107
block|,
literal|108
block|,
literal|109
block|,
literal|110
block|,
literal|111
block|,
literal|112
block|,
literal|113
block|,
literal|114
block|,
literal|115
block|,
literal|116
block|,
literal|117
block|,
literal|70
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|70
block|,
literal|68
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|,
literal|68
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|short
name|yycheck
index|[]
init|=
block|{
literal|10
block|,
literal|42
block|,
literal|43
block|,
literal|34
block|,
literal|34
block|,
literal|44
block|,
literal|93
block|,
literal|41
block|,
literal|44
block|,
literal|0
block|,
literal|40
block|,
literal|36
block|,
literal|60
block|,
literal|34
block|,
literal|10
block|,
literal|34
block|,
literal|46
block|,
literal|34
block|,
literal|63
block|,
literal|40
block|,
literal|258
block|,
literal|40
block|,
literal|63
block|,
literal|40
block|,
literal|34
block|,
literal|46
block|,
literal|36
block|,
literal|46
block|,
literal|10
block|,
literal|46
block|,
literal|40
block|,
literal|41
block|,
literal|42
block|,
literal|43
block|,
literal|256
block|,
literal|36
block|,
literal|46
block|,
literal|47
block|,
literal|34
block|,
literal|258
block|,
literal|36
block|,
literal|256
block|,
literal|256
block|,
literal|34
block|,
literal|40
block|,
literal|41
block|,
literal|47
block|,
literal|262
block|,
literal|262
block|,
literal|40
block|,
literal|46
block|,
literal|47
block|,
literal|34
block|,
literal|63
block|,
literal|36
block|,
literal|46
block|,
literal|34
block|,
literal|10
block|,
literal|40
block|,
literal|41
block|,
literal|10
block|,
literal|91
block|,
literal|40
block|,
literal|301
block|,
literal|46
block|,
literal|47
block|,
literal|60
block|,
literal|44
block|,
literal|46
block|,
literal|262
block|,
literal|91
block|,
literal|61
block|,
literal|91
block|,
literal|94
block|,
literal|91
block|,
literal|94
block|,
literal|121
block|,
literal|125
block|,
literal|256
block|,
literal|123
block|,
literal|299
block|,
literal|91
block|,
literal|61
block|,
literal|36
block|,
literal|262
block|,
literal|62
block|,
literal|36
block|,
literal|61
block|,
literal|41
block|,
literal|57
block|,
literal|124
block|,
literal|41
block|,
literal|61
block|,
literal|61
block|,
literal|47
block|,
literal|91
block|,
literal|61
block|,
literal|47
block|,
literal|61
block|,
literal|124
block|,
literal|91
block|,
literal|42
block|,
literal|123
block|,
literal|94
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|296
block|,
literal|297
block|,
literal|91
block|,
literal|265
block|,
literal|86
block|,
literal|87
block|,
literal|91
block|,
literal|124
block|,
literal|262
block|,
literal|94
block|,
literal|262
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|94
block|,
literal|262
block|,
literal|124
block|,
literal|265
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|124
block|,
literal|262
block|,
literal|262
block|,
literal|265
block|,
literal|123
block|,
literal|262
block|,
literal|259
block|,
literal|260
block|,
literal|261
block|,
literal|62
block|,
literal|10
block|,
literal|93
block|,
literal|265
block|,
literal|262
block|,
literal|124
block|,
literal|266
block|,
literal|267
block|,
literal|268
block|,
literal|269
block|,
literal|270
block|,
literal|271
block|,
literal|258
block|,
literal|258
block|,
literal|91
block|,
literal|45
block|,
literal|257
block|,
literal|10
block|,
literal|299
block|,
literal|10
block|,
literal|36
block|,
literal|301
block|,
literal|26
block|,
literal|54
block|,
literal|68
block|,
literal|78
block|,
literal|73
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|257
block|,
literal|124
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|124
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|93
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|284
block|,
literal|285
block|,
literal|286
block|,
literal|287
block|,
literal|288
block|,
literal|289
block|,
literal|290
block|,
literal|291
block|,
literal|292
block|,
literal|293
block|,
literal|294
block|,
literal|295
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|93
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|257
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|263
block|,
operator|-
literal|1
block|,
literal|256
block|,
literal|257
block|,
literal|256
block|,
literal|257
block|,
operator|-
literal|1
block|,
literal|257
block|,
operator|-
literal|1
block|,
literal|263
block|,
literal|264
block|,
literal|263
block|,
literal|264
block|,
literal|263
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|263
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|300
block|,
operator|-
literal|1
block|,
literal|257
block|,
literal|301
block|,
literal|299
block|,
operator|-
literal|1
block|,
literal|256
block|,
literal|257
block|,
literal|263
block|,
literal|298
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|263
block|,
literal|264
block|,
operator|-
literal|1
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|256
block|,
literal|257
block|,
operator|-
literal|1
block|,
literal|263
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|263
block|,
literal|264
block|,
operator|-
literal|1
block|,
literal|298
block|,
operator|-
literal|1
block|,
literal|300
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|298
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|298
block|,
operator|-
literal|1
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|284
block|,
literal|285
block|,
literal|286
block|,
literal|287
block|,
literal|288
block|,
literal|289
block|,
literal|290
block|,
literal|291
block|,
literal|292
block|,
literal|293
block|,
literal|294
block|,
literal|295
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|284
block|,
literal|285
block|,
literal|286
block|,
literal|287
block|,
literal|288
block|,
literal|289
block|,
literal|290
block|,
literal|291
block|,
literal|292
block|,
literal|293
block|,
literal|294
block|,
literal|295
block|,
literal|257
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
operator|-
literal|1
block|,
literal|272
block|,
literal|273
block|,
literal|274
block|,
literal|275
block|,
literal|276
block|,
literal|277
block|,
literal|278
block|,
literal|279
block|,
literal|280
block|,
literal|281
block|,
literal|282
block|,
literal|283
block|,
literal|284
block|,
literal|285
block|,
literal|286
block|,
literal|287
block|,
literal|288
block|,
literal|289
block|,
literal|290
block|,
literal|291
block|,
literal|292
block|,
literal|293
block|,
literal|294
block|,
literal|295
block|, }
decl_stmt|;
end_decl_stmt

begin_define
define|#
directive|define
name|YYFINAL
value|1
end_define

begin_ifndef
ifndef|#
directive|ifndef
name|YYDEBUG
end_ifndef

begin_define
define|#
directive|define
name|YYDEBUG
value|0
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYMAXTOKEN
value|301
end_define

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|yyname
index|[]
init|=
block|{
literal|"end-of-file"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'\\n'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'\"'"
block|,
literal|0
block|,
literal|"'$'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'('"
block|,
literal|"')'"
block|,
literal|"'*'"
block|,
literal|"'+'"
block|,
literal|"','"
block|,
literal|"'-'"
block|,
literal|"'.'"
block|,
literal|"'/'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'<'"
block|,
literal|"'='"
block|,
literal|"'>'"
block|,
literal|"'?'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'['"
block|,
literal|0
block|,
literal|"']'"
block|,
literal|"'^'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"'{'"
block|,
literal|"'|'"
block|,
literal|"'}'"
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|0
block|,
literal|"CHAR"
block|,
literal|"NUMBER"
block|,
literal|"SECTEND"
block|,
literal|"SCDECL"
block|,
literal|"XSCDECL"
block|,
literal|"NAME"
block|,
literal|"PREVCCL"
block|,
literal|"EOF_OP"
block|,
literal|"OPTION_OP"
block|,
literal|"OPT_OUTFILE"
block|,
literal|"OPT_PREFIX"
block|,
literal|"OPT_YYCLASS"
block|,
literal|"OPT_HEADER"
block|,
literal|"OPT_EXTRA_TYPE"
block|,
literal|"OPT_TABLES"
block|,
literal|"CCE_ALNUM"
block|,
literal|"CCE_ALPHA"
block|,
literal|"CCE_BLANK"
block|,
literal|"CCE_CNTRL"
block|,
literal|"CCE_DIGIT"
block|,
literal|"CCE_GRAPH"
block|,
literal|"CCE_LOWER"
block|,
literal|"CCE_PRINT"
block|,
literal|"CCE_PUNCT"
block|,
literal|"CCE_SPACE"
block|,
literal|"CCE_UPPER"
block|,
literal|"CCE_XDIGIT"
block|,
literal|"CCE_NEG_ALNUM"
block|,
literal|"CCE_NEG_ALPHA"
block|,
literal|"CCE_NEG_BLANK"
block|,
literal|"CCE_NEG_CNTRL"
block|,
literal|"CCE_NEG_DIGIT"
block|,
literal|"CCE_NEG_GRAPH"
block|,
literal|"CCE_NEG_LOWER"
block|,
literal|"CCE_NEG_PRINT"
block|,
literal|"CCE_NEG_PUNCT"
block|,
literal|"CCE_NEG_SPACE"
block|,
literal|"CCE_NEG_UPPER"
block|,
literal|"CCE_NEG_XDIGIT"
block|,
literal|"CCL_OP_DIFF"
block|,
literal|"CCL_OP_UNION"
block|,
literal|"BEGIN_REPEAT_POSIX"
block|,
literal|"END_REPEAT_POSIX"
block|,
literal|"BEGIN_REPEAT_FLEX"
block|,
literal|"END_REPEAT_FLEX"
block|, }
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
specifier|const
name|char
modifier|*
name|yyrule
index|[]
init|=
block|{
literal|"$accept : goal"
block|,
literal|"goal : initlex sect1 sect1end sect2 initforrule"
block|,
literal|"initlex :"
block|,
literal|"sect1 : sect1 startconddecl namelist1"
block|,
literal|"sect1 : sect1 options"
block|,
literal|"sect1 :"
block|,
literal|"sect1 : error"
block|,
literal|"sect1end : SECTEND"
block|,
literal|"startconddecl : SCDECL"
block|,
literal|"startconddecl : XSCDECL"
block|,
literal|"namelist1 : namelist1 NAME"
block|,
literal|"namelist1 : NAME"
block|,
literal|"namelist1 : error"
block|,
literal|"options : OPTION_OP optionlist"
block|,
literal|"optionlist : optionlist option"
block|,
literal|"optionlist :"
block|,
literal|"option : OPT_OUTFILE '=' NAME"
block|,
literal|"option : OPT_EXTRA_TYPE '=' NAME"
block|,
literal|"option : OPT_PREFIX '=' NAME"
block|,
literal|"option : OPT_YYCLASS '=' NAME"
block|,
literal|"option : OPT_HEADER '=' NAME"
block|,
literal|"option : OPT_TABLES '=' NAME"
block|,
literal|"sect2 : sect2 scon initforrule flexrule '\\n'"
block|,
literal|"sect2 : sect2 scon '{' sect2 '}'"
block|,
literal|"sect2 :"
block|,
literal|"initforrule :"
block|,
literal|"flexrule : '^' rule"
block|,
literal|"flexrule : rule"
block|,
literal|"flexrule : EOF_OP"
block|,
literal|"flexrule : error"
block|,
literal|"scon_stk_ptr :"
block|,
literal|"scon : '<' scon_stk_ptr namelist2 '>'"
block|,
literal|"scon : '<' '*' '>'"
block|,
literal|"scon :"
block|,
literal|"namelist2 : namelist2 ',' sconname"
block|,
literal|"namelist2 : sconname"
block|,
literal|"namelist2 : error"
block|,
literal|"sconname : NAME"
block|,
literal|"rule : re2 re"
block|,
literal|"rule : re2 re '$'"
block|,
literal|"rule : re '$'"
block|,
literal|"rule : re"
block|,
literal|"re : re '|' series"
block|,
literal|"re : series"
block|,
literal|"re2 : re '/'"
block|,
literal|"series : series singleton"
block|,
literal|"series : singleton"
block|,
literal|"series : series BEGIN_REPEAT_POSIX NUMBER ',' NUMBER END_REPEAT_POSIX"
block|,
literal|"series : series BEGIN_REPEAT_POSIX NUMBER ',' END_REPEAT_POSIX"
block|,
literal|"series : series BEGIN_REPEAT_POSIX NUMBER END_REPEAT_POSIX"
block|,
literal|"singleton : singleton '*'"
block|,
literal|"singleton : singleton '+'"
block|,
literal|"singleton : singleton '?'"
block|,
literal|"singleton : singleton BEGIN_REPEAT_FLEX NUMBER ',' NUMBER END_REPEAT_FLEX"
block|,
literal|"singleton : singleton BEGIN_REPEAT_FLEX NUMBER ',' END_REPEAT_FLEX"
block|,
literal|"singleton : singleton BEGIN_REPEAT_FLEX NUMBER END_REPEAT_FLEX"
block|,
literal|"singleton : '.'"
block|,
literal|"singleton : fullccl"
block|,
literal|"singleton : PREVCCL"
block|,
literal|"singleton : '\"' string '\"'"
block|,
literal|"singleton : '(' re ')'"
block|,
literal|"singleton : CHAR"
block|,
literal|"fullccl : fullccl CCL_OP_DIFF braceccl"
block|,
literal|"fullccl : fullccl CCL_OP_UNION braceccl"
block|,
literal|"fullccl : braceccl"
block|,
literal|"braceccl : '[' ccl ']'"
block|,
literal|"braceccl : '[' '^' ccl ']'"
block|,
literal|"ccl : ccl CHAR '-' CHAR"
block|,
literal|"ccl : ccl CHAR"
block|,
literal|"ccl : ccl ccl_expr"
block|,
literal|"ccl :"
block|,
literal|"ccl_expr : CCE_ALNUM"
block|,
literal|"ccl_expr : CCE_ALPHA"
block|,
literal|"ccl_expr : CCE_BLANK"
block|,
literal|"ccl_expr : CCE_CNTRL"
block|,
literal|"ccl_expr : CCE_DIGIT"
block|,
literal|"ccl_expr : CCE_GRAPH"
block|,
literal|"ccl_expr : CCE_LOWER"
block|,
literal|"ccl_expr : CCE_PRINT"
block|,
literal|"ccl_expr : CCE_PUNCT"
block|,
literal|"ccl_expr : CCE_SPACE"
block|,
literal|"ccl_expr : CCE_XDIGIT"
block|,
literal|"ccl_expr : CCE_UPPER"
block|,
literal|"ccl_expr : CCE_NEG_ALNUM"
block|,
literal|"ccl_expr : CCE_NEG_ALPHA"
block|,
literal|"ccl_expr : CCE_NEG_BLANK"
block|,
literal|"ccl_expr : CCE_NEG_CNTRL"
block|,
literal|"ccl_expr : CCE_NEG_DIGIT"
block|,
literal|"ccl_expr : CCE_NEG_GRAPH"
block|,
literal|"ccl_expr : CCE_NEG_PRINT"
block|,
literal|"ccl_expr : CCE_NEG_PUNCT"
block|,
literal|"ccl_expr : CCE_NEG_SPACE"
block|,
literal|"ccl_expr : CCE_NEG_XDIGIT"
block|,
literal|"ccl_expr : CCE_NEG_LOWER"
block|,
literal|"ccl_expr : CCE_NEG_UPPER"
block|,
literal|"string : string CHAR"
block|,
literal|"string :"
block|,  }
decl_stmt|;
end_decl_stmt

begin_endif
endif|#
directive|endif
end_endif

begin_decl_stmt
name|int
name|yydebug
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yynerrs
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yyerrflag
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|int
name|yychar
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yyval
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|YYSTYPE
name|yylval
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* define the initial stack-sizes */
end_comment

begin_ifdef
ifdef|#
directive|ifdef
name|YYSTACKSIZE
end_ifdef

begin_undef
undef|#
directive|undef
name|YYMAXDEPTH
end_undef

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|YYSTACKSIZE
end_define

begin_else
else|#
directive|else
end_else

begin_ifdef
ifdef|#
directive|ifdef
name|YYMAXDEPTH
end_ifdef

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|YYMAXDEPTH
end_define

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|YYSTACKSIZE
value|500
end_define

begin_define
define|#
directive|define
name|YYMAXDEPTH
value|500
end_define

begin_endif
endif|#
directive|endif
end_endif

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYINITSTACKSIZE
value|500
end_define

begin_typedef
typedef|typedef
struct|struct
block|{
name|unsigned
name|stacksize
decl_stmt|;
name|short
modifier|*
name|s_base
decl_stmt|;
name|short
modifier|*
name|s_mark
decl_stmt|;
name|short
modifier|*
name|s_last
decl_stmt|;
name|YYSTYPE
modifier|*
name|l_base
decl_stmt|;
name|YYSTYPE
modifier|*
name|l_mark
decl_stmt|;
block|}
name|YYSTACKDATA
typedef|;
end_typedef

begin_comment
comment|/* variables for the parser stack */
end_comment

begin_decl_stmt
specifier|static
name|YYSTACKDATA
name|yystack
decl_stmt|;
end_decl_stmt

begin_line
line|#
directive|line
number|948
file|"parse.y"
end_line

begin_comment
comment|/* build_eof_action - build the "<<EOF>>" action for the active start  *                    conditions  */
end_comment

begin_function
name|void
name|build_eof_action
parameter_list|()
block|{
name|int
name|i
decl_stmt|;
name|char
name|action_text
index|[
name|MAXLINE
index|]
decl_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|sceof
index|[
name|scon_stk
index|[
name|i
index|]
index|]
condition|)
name|format_pinpoint_message
argument_list|(
literal|"multiple<<EOF>> rules for start condition %s"
argument_list|,
name|scname
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
else|else
block|{
name|sceof
index|[
name|scon_stk
index|[
name|i
index|]
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|previous_continued_action
comment|/*&& previous action was regular */
condition|)
name|add_action
argument_list|(
literal|"YY_RULE_SETUP\n"
argument_list|)
expr_stmt|;
name|snprintf
argument_list|(
name|action_text
argument_list|,
sizeof|sizeof
argument_list|(
name|action_text
argument_list|)
argument_list|,
literal|"case YY_STATE_EOF(%s):\n"
argument_list|,
name|scname
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|)
expr_stmt|;
name|add_action
argument_list|(
name|action_text
argument_list|)
expr_stmt|;
block|}
block|}
name|line_directive_out
argument_list|(
operator|(
name|FILE
operator|*
operator|)
literal|0
argument_list|,
literal|1
argument_list|)
expr_stmt|;
comment|/* This isn't a normal rule after all - don't count it as 	 * such, so we don't have any holes in the rule numbering 	 * (which make generating "rule can never match" warnings 	 * more difficult. 	 */
operator|--
name|num_rules
expr_stmt|;
operator|++
name|num_eof_rules
expr_stmt|;
block|}
end_function

begin_comment
comment|/* format_synerr - write out formatted syntax error */
end_comment

begin_decl_stmt
name|void
name|format_synerr
argument_list|(
name|msg
argument_list|,
name|arg
argument_list|)
decl|const
name|char
modifier|*
name|msg
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|errmsg
index|[
name|MAXLINE
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|snprintf
argument_list|(
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|,
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|synerr
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* synerr - report a syntax error */
end_comment

begin_function
name|void
name|synerr
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|syntaxerror
operator|=
name|true
expr_stmt|;
name|pinpoint_message
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* format_warn - write out formatted warning */
end_comment

begin_decl_stmt
name|void
name|format_warn
argument_list|(
name|msg
argument_list|,
name|arg
argument_list|)
decl|const
name|char
modifier|*
name|msg
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|warn_msg
index|[
name|MAXLINE
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|warn_msg
argument_list|,
sizeof|sizeof
argument_list|(
name|warn_msg
argument_list|)
argument_list|,
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|warn
argument_list|(
name|warn_msg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* warn - report a warning, unless -w was given */
end_comment

begin_function
name|void
name|warn
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|line_warning
argument_list|(
name|str
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* format_pinpoint_message - write out a message formatted with one string,  *			     pinpointing its location  */
end_comment

begin_decl_stmt
name|void
name|format_pinpoint_message
argument_list|(
name|msg
argument_list|,
name|arg
argument_list|)
decl|const
name|char
modifier|*
name|msg
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|char
name|errmsg
index|[
name|MAXLINE
index|]
decl_stmt|;
name|snprintf
argument_list|(
name|errmsg
argument_list|,
sizeof|sizeof
argument_list|(
name|errmsg
argument_list|)
argument_list|,
name|msg
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|pinpoint_message
argument_list|(
name|errmsg
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* pinpoint_message - write out a message, pinpointing its location */
end_comment

begin_function
name|void
name|pinpoint_message
parameter_list|(
name|str
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
block|{
name|line_pinpoint
argument_list|(
name|str
argument_list|,
name|linenum
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* line_warning - report a warning at a given line, unless -w was given */
end_comment

begin_function
name|void
name|line_warning
parameter_list|(
name|str
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|char
name|warning
index|[
name|MAXLINE
index|]
decl_stmt|;
if|if
condition|(
operator|!
name|nowarn
condition|)
block|{
name|snprintf
argument_list|(
name|warning
argument_list|,
sizeof|sizeof
argument_list|(
name|warning
argument_list|)
argument_list|,
literal|"warning, %s"
argument_list|,
name|str
argument_list|)
expr_stmt|;
name|line_pinpoint
argument_list|(
name|warning
argument_list|,
name|line
argument_list|)
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* line_pinpoint - write out a message, pinpointing it at the given line */
end_comment

begin_function
name|void
name|line_pinpoint
parameter_list|(
name|str
parameter_list|,
name|line
parameter_list|)
specifier|const
name|char
modifier|*
name|str
decl_stmt|;
name|int
name|line
decl_stmt|;
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%s:%d: %s\n"
argument_list|,
name|infilename
argument_list|,
name|line
argument_list|,
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* yyerror - eat up an error message from the parser;  *	     currently, messages are ignore  */
end_comment

begin_function
name|void
name|yyerror
parameter_list|(
name|msg
parameter_list|)
specifier|const
name|char
modifier|*
name|msg
decl_stmt|;
block|{ 	}
end_function

begin_line
line|#
directive|line
number|656
file|"parse.c"
end_line

begin_if
if|#
directive|if
name|YYDEBUG
end_if

begin_include
include|#
directive|include
file|<stdio.h>
end_include

begin_comment
comment|/* needed for printf */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_include
include|#
directive|include
file|<stdlib.h>
end_include

begin_comment
comment|/* needed for malloc, etc */
end_comment

begin_include
include|#
directive|include
file|<string.h>
end_include

begin_comment
comment|/* needed for memset */
end_comment

begin_comment
comment|/* allocate initial stack or double stack size, up to YYMAXDEPTH */
end_comment

begin_function
specifier|static
name|int
name|yygrowstack
parameter_list|(
name|YYSTACKDATA
modifier|*
name|data
parameter_list|)
block|{
name|int
name|i
decl_stmt|;
name|unsigned
name|newsize
decl_stmt|;
name|short
modifier|*
name|newss
decl_stmt|;
name|YYSTYPE
modifier|*
name|newvs
decl_stmt|;
if|if
condition|(
operator|(
name|newsize
operator|=
name|data
operator|->
name|stacksize
operator|)
operator|==
literal|0
condition|)
name|newsize
operator|=
name|YYINITSTACKSIZE
expr_stmt|;
elseif|else
if|if
condition|(
name|newsize
operator|>=
name|YYMAXDEPTH
condition|)
return|return
operator|-
literal|1
return|;
elseif|else
if|if
condition|(
operator|(
name|newsize
operator|*=
literal|2
operator|)
operator|>
name|YYMAXDEPTH
condition|)
name|newsize
operator|=
name|YYMAXDEPTH
expr_stmt|;
name|i
operator|=
name|data
operator|->
name|s_mark
operator|-
name|data
operator|->
name|s_base
expr_stmt|;
name|newss
operator|=
operator|(
name|short
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|s_base
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newss
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newss
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|->
name|s_base
operator|=
name|newss
expr_stmt|;
name|data
operator|->
name|s_mark
operator|=
name|newss
operator|+
name|i
expr_stmt|;
name|newvs
operator|=
operator|(
name|YYSTYPE
operator|*
operator|)
name|realloc
argument_list|(
name|data
operator|->
name|l_base
argument_list|,
name|newsize
operator|*
sizeof|sizeof
argument_list|(
operator|*
name|newvs
argument_list|)
argument_list|)
expr_stmt|;
if|if
condition|(
name|newvs
operator|==
name|NULL
condition|)
return|return
operator|-
literal|1
return|;
name|data
operator|->
name|l_base
operator|=
name|newvs
expr_stmt|;
name|data
operator|->
name|l_mark
operator|=
name|newvs
operator|+
name|i
expr_stmt|;
name|data
operator|->
name|stacksize
operator|=
name|newsize
expr_stmt|;
name|data
operator|->
name|s_last
operator|=
name|data
operator|->
name|s_base
operator|+
name|newsize
operator|-
literal|1
expr_stmt|;
return|return
literal|0
return|;
block|}
end_function

begin_if
if|#
directive|if
name|YYPURE
operator|||
name|defined
argument_list|(
name|YY_NO_LEAKS
argument_list|)
end_if

begin_function
specifier|static
name|void
name|yyfreestack
parameter_list|(
name|YYSTACKDATA
modifier|*
name|data
parameter_list|)
block|{
name|free
argument_list|(
name|data
operator|->
name|s_base
argument_list|)
expr_stmt|;
name|free
argument_list|(
name|data
operator|->
name|l_base
argument_list|)
expr_stmt|;
name|memset
argument_list|(
name|data
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|data
argument_list|)
argument_list|)
expr_stmt|;
block|}
end_function

begin_else
else|#
directive|else
end_else

begin_define
define|#
directive|define
name|yyfreestack
parameter_list|(
name|data
parameter_list|)
end_define

begin_comment
comment|/* nothing */
end_comment

begin_endif
endif|#
directive|endif
end_endif

begin_define
define|#
directive|define
name|YYABORT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYREJECT
value|goto yyabort
end_define

begin_define
define|#
directive|define
name|YYACCEPT
value|goto yyaccept
end_define

begin_define
define|#
directive|define
name|YYERROR
value|goto yyerrlab
end_define

begin_function
name|int
name|YYPARSE_DECL
parameter_list|()
block|{
name|int
name|yym
decl_stmt|,
name|yyn
decl_stmt|,
name|yystate
decl_stmt|;
if|#
directive|if
name|YYDEBUG
specifier|const
name|char
modifier|*
name|yys
decl_stmt|;
if|if
condition|(
operator|(
name|yys
operator|=
name|getenv
argument_list|(
literal|"YYDEBUG"
argument_list|)
operator|)
operator|!=
name|NULL
condition|)
block|{
name|yyn
operator|=
operator|*
name|yys
expr_stmt|;
if|if
condition|(
name|yyn
operator|>=
literal|'0'
operator|&&
name|yyn
operator|<=
literal|'9'
condition|)
name|yydebug
operator|=
name|yyn
operator|-
literal|'0'
expr_stmt|;
block|}
endif|#
directive|endif
name|yynerrs
operator|=
literal|0
expr_stmt|;
name|yyerrflag
operator|=
literal|0
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|YYPURE
name|memset
argument_list|(
operator|&
name|yystack
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
argument_list|(
name|yystack
argument_list|)
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_base
operator|==
name|NULL
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
condition|)
goto|goto
name|yyoverflow
goto|;
name|yystack
operator|.
name|s_mark
operator|=
name|yystack
operator|.
name|s_base
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|=
name|yystack
operator|.
name|l_base
expr_stmt|;
name|yystate
operator|=
literal|0
expr_stmt|;
operator|*
name|yystack
operator|.
name|s_mark
operator|=
literal|0
expr_stmt|;
name|yyloop
label|:
if|if
condition|(
operator|(
name|yyn
operator|=
name|yydefred
index|[
name|yystate
index|]
operator|)
operator|!=
literal|0
condition|)
goto|goto
name|yyreduce
goto|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|yychar
operator|=
name|YYLEX
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|yys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|<=
name|YYMAXTOKEN
condition|)
name|yys
operator|=
name|yyname
index|[
name|yychar
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|yys
condition|)
name|yys
operator|=
literal|"illegal-symbol"
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, reading %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
name|yystate
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|yychar
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, shifting to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
condition|)
block|{
goto|goto
name|yyoverflow
goto|;
block|}
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yylval
expr_stmt|;
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
if|if
condition|(
name|yyerrflag
operator|>
literal|0
condition|)
operator|--
name|yyerrflag
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yyrindex
index|[
name|yystate
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yychar
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|yychar
condition|)
block|{
name|yyn
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
goto|goto
name|yyreduce
goto|;
block|}
if|if
condition|(
name|yyerrflag
condition|)
goto|goto
name|yyinrecovery
goto|;
name|yyerror
argument_list|(
literal|"syntax error"
argument_list|)
expr_stmt|;
goto|goto
name|yyerrlab
goto|;
name|yyerrlab
label|:
operator|++
name|yynerrs
expr_stmt|;
name|yyinrecovery
label|:
if|if
condition|(
name|yyerrflag
operator|<
literal|3
condition|)
block|{
name|yyerrflag
operator|=
literal|3
expr_stmt|;
for|for
control|(
init|;
condition|;
control|)
block|{
if|if
condition|(
operator|(
name|yyn
operator|=
name|yysindex
index|[
operator|*
name|yystack
operator|.
name|s_mark
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|YYERRCODE
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|YYERRCODE
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, error recovery shifting\  to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|,
name|yytable
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
condition|)
block|{
goto|goto
name|yyoverflow
goto|;
block|}
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yylval
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
else|else
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: error recovery discarding state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|<=
name|yystack
operator|.
name|s_base
condition|)
goto|goto
name|yyabort
goto|;
operator|--
name|yystack
operator|.
name|s_mark
expr_stmt|;
operator|--
name|yystack
operator|.
name|l_mark
expr_stmt|;
block|}
block|}
block|}
else|else
block|{
if|if
condition|(
name|yychar
operator|==
literal|0
condition|)
goto|goto
name|yyabort
goto|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|yys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|<=
name|YYMAXTOKEN
condition|)
name|yys
operator|=
name|yyname
index|[
name|yychar
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|yys
condition|)
name|yys
operator|=
literal|"illegal-symbol"
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, error recovery discards token %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
name|yychar
operator|=
name|YYEMPTY
expr_stmt|;
goto|goto
name|yyloop
goto|;
block|}
name|yyreduce
label|:
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: state %d, reducing by rule %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|yystate
argument_list|,
name|yyn
argument_list|,
name|yyrule
index|[
name|yyn
index|]
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yym
operator|=
name|yylen
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yym
condition|)
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|1
operator|-
name|yym
index|]
expr_stmt|;
else|else
name|memset
argument_list|(
operator|&
name|yyval
argument_list|,
literal|0
argument_list|,
sizeof|sizeof
name|yyval
argument_list|)
expr_stmt|;
switch|switch
condition|(
name|yyn
condition|)
block|{
case|case
literal|1
case|:
line|#
directive|line
number|119
file|"parse.y"
block|{
comment|/* add default rule */
name|int
name|def_rule
decl_stmt|;
name|pat
operator|=
name|cclinit
argument_list|()
expr_stmt|;
name|cclnegate
argument_list|(
name|pat
argument_list|)
expr_stmt|;
name|def_rule
operator|=
name|mkstate
argument_list|(
operator|-
name|pat
argument_list|)
expr_stmt|;
comment|/* Remember the number of the default rule so we 			 * don't generate "can't match" warnings for it. 			 */
name|default_rule
operator|=
name|num_rules
expr_stmt|;
name|finish_rule
argument_list|(
name|def_rule
argument_list|,
name|false
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
name|scset
index|[
name|i
index|]
operator|=
name|mkbranch
argument_list|(
name|scset
index|[
name|i
index|]
argument_list|,
name|def_rule
argument_list|)
expr_stmt|;
if|if
condition|(
name|spprdflt
condition|)
name|add_action
argument_list|(
literal|"YY_FATAL_ERROR( \"flex scanner jammed\" )"
argument_list|)
expr_stmt|;
else|else
name|add_action
argument_list|(
literal|"ECHO"
argument_list|)
expr_stmt|;
name|add_action
argument_list|(
literal|";\n\tYY_BREAK\n"
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|2
case|:
line|#
directive|line
number|148
file|"parse.y"
block|{
comment|/* initialize for processing rules */
comment|/* Create default DFA start condition. */
name|scinstal
argument_list|(
literal|"INITIAL"
argument_list|,
name|false
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|6
case|:
line|#
directive|line
number|159
file|"parse.y"
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"unknown error processing section 1"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|7
case|:
line|#
directive|line
number|163
file|"parse.y"
block|{
name|check_options
argument_list|()
expr_stmt|;
name|scon_stk
operator|=
name|allocate_integer_array
argument_list|(
name|lastsc
operator|+
literal|1
argument_list|)
expr_stmt|;
name|scon_stk_ptr
operator|=
literal|0
expr_stmt|;
block|}
break|break;
case|case
literal|8
case|:
line|#
directive|line
number|171
file|"parse.y"
block|{
name|xcluflg
operator|=
name|false
expr_stmt|;
block|}
break|break;
case|case
literal|9
case|:
line|#
directive|line
number|174
file|"parse.y"
block|{
name|xcluflg
operator|=
name|true
expr_stmt|;
block|}
break|break;
case|case
literal|10
case|:
line|#
directive|line
number|178
file|"parse.y"
block|{
name|scinstal
argument_list|(
name|nmstr
argument_list|,
name|xcluflg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|11
case|:
line|#
directive|line
number|181
file|"parse.y"
block|{
name|scinstal
argument_list|(
name|nmstr
argument_list|,
name|xcluflg
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|12
case|:
line|#
directive|line
number|184
file|"parse.y"
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"bad start condition list"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|16
case|:
line|#
directive|line
number|195
file|"parse.y"
block|{
name|outfilename
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
name|did_outfilename
operator|=
literal|1
expr_stmt|;
block|}
break|break;
case|case
literal|17
case|:
line|#
directive|line
number|200
file|"parse.y"
block|{
name|extra_type
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|18
case|:
line|#
directive|line
number|202
file|"parse.y"
block|{
name|prefix
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|19
case|:
line|#
directive|line
number|204
file|"parse.y"
block|{
name|yyclass
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|20
case|:
line|#
directive|line
number|206
file|"parse.y"
block|{
name|headerfilename
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|21
case|:
line|#
directive|line
number|208
file|"parse.y"
block|{
name|tablesext
operator|=
name|true
expr_stmt|;
name|tablesfilename
operator|=
name|copy_string
argument_list|(
name|nmstr
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|22
case|:
line|#
directive|line
number|212
file|"parse.y"
block|{
name|scon_stk_ptr
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|23
case|:
line|#
directive|line
number|214
file|"parse.y"
block|{
name|scon_stk_ptr
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|25
case|:
line|#
directive|line
number|219
file|"parse.y"
block|{
comment|/* Initialize for a parse of one rule. */
name|trlcontxt
operator|=
name|variable_trail_rule
operator|=
name|varlength
operator|=
name|false
expr_stmt|;
name|trailcnt
operator|=
name|headcnt
operator|=
name|rulelen
operator|=
literal|0
expr_stmt|;
name|current_state_type
operator|=
name|STATE_NORMAL
expr_stmt|;
name|previous_continued_action
operator|=
name|continued_action
expr_stmt|;
name|in_rule
operator|=
name|true
expr_stmt|;
name|new_rule
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|26
case|:
line|#
directive|line
number|232
file|"parse.y"
block|{
name|pat
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
name|finish_rule
argument_list|(
name|pat
argument_list|,
name|variable_trail_rule
argument_list|,
name|headcnt
argument_list|,
name|trailcnt
argument_list|,
name|previous_continued_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|scon_stk_ptr
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
name|scbol
index|[
name|scon_stk
index|[
name|i
index|]
index|]
operator|=
name|mkbranch
argument_list|(
name|scbol
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Add to all non-exclusive start conditions, 				 * including the default (0) start condition. 				 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|scxclu
index|[
name|i
index|]
condition|)
name|scbol
index|[
name|i
index|]
operator|=
name|mkbranch
argument_list|(
name|scbol
index|[
name|i
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|bol_needed
condition|)
block|{
name|bol_needed
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|performance_report
operator|>
literal|1
condition|)
name|pinpoint_message
argument_list|(
literal|"'^' operator results in sub-optimal performance"
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|27
case|:
line|#
directive|line
number|268
file|"parse.y"
block|{
name|pat
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
name|finish_rule
argument_list|(
name|pat
argument_list|,
name|variable_trail_rule
argument_list|,
name|headcnt
argument_list|,
name|trailcnt
argument_list|,
name|previous_continued_action
argument_list|)
expr_stmt|;
if|if
condition|(
name|scon_stk_ptr
operator|>
literal|0
condition|)
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
name|scset
index|[
name|scon_stk
index|[
name|i
index|]
index|]
operator|=
name|mkbranch
argument_list|(
name|scset
index|[
name|scon_stk
index|[
name|i
index|]
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|scxclu
index|[
name|i
index|]
condition|)
name|scset
index|[
name|i
index|]
operator|=
name|mkbranch
argument_list|(
name|scset
index|[
name|i
index|]
argument_list|,
name|pat
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|28
case|:
line|#
directive|line
number|292
file|"parse.y"
block|{
if|if
condition|(
name|scon_stk_ptr
operator|>
literal|0
condition|)
name|build_eof_action
argument_list|()
expr_stmt|;
else|else
block|{
comment|/* This EOF applies to all start conditions 				 * which don't already have EOF actions. 				 */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|sceof
index|[
name|i
index|]
condition|)
name|scon_stk
index|[
operator|++
name|scon_stk_ptr
index|]
operator|=
name|i
expr_stmt|;
if|if
condition|(
name|scon_stk_ptr
operator|==
literal|0
condition|)
name|warn
argument_list|(
literal|"all start conditions already have<<EOF>> rules"
argument_list|)
expr_stmt|;
else|else
name|build_eof_action
argument_list|()
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|29
case|:
line|#
directive|line
number|315
file|"parse.y"
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"unrecognized rule"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|30
case|:
line|#
directive|line
number|319
file|"parse.y"
block|{
name|yyval
operator|=
name|scon_stk_ptr
expr_stmt|;
block|}
break|break;
case|case
literal|31
case|:
line|#
directive|line
number|323
file|"parse.y"
block|{
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|32
case|:
line|#
directive|line
number|326
file|"parse.y"
block|{
name|yyval
operator|=
name|scon_stk_ptr
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
block|{
name|int
name|j
decl_stmt|;
for|for
control|(
name|j
operator|=
literal|1
init|;
name|j
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|j
control|)
if|if
condition|(
name|scon_stk
index|[
name|j
index|]
operator|==
name|i
condition|)
break|break;
if|if
condition|(
name|j
operator|>
name|scon_stk_ptr
condition|)
name|scon_stk
index|[
operator|++
name|scon_stk_ptr
index|]
operator|=
name|i
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|33
case|:
line|#
directive|line
number|343
file|"parse.y"
block|{
name|yyval
operator|=
name|scon_stk_ptr
expr_stmt|;
block|}
break|break;
case|case
literal|36
case|:
line|#
directive|line
number|351
file|"parse.y"
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"bad start condition list"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|37
case|:
line|#
directive|line
number|355
file|"parse.y"
block|{
if|if
condition|(
operator|(
name|scnum
operator|=
name|sclookup
argument_list|(
name|nmstr
argument_list|)
operator|)
operator|==
literal|0
condition|)
name|format_pinpoint_message
argument_list|(
literal|"undeclared start condition %s"
argument_list|,
name|nmstr
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|scon_stk_ptr
condition|;
operator|++
name|i
control|)
if|if
condition|(
name|scon_stk
index|[
name|i
index|]
operator|==
name|scnum
condition|)
block|{
name|format_warn
argument_list|(
literal|"<%s> specified twice"
argument_list|,
name|scname
index|[
name|scnum
index|]
argument_list|)
expr_stmt|;
break|break;
block|}
if|if
condition|(
name|i
operator|>
name|scon_stk_ptr
condition|)
name|scon_stk
index|[
operator|++
name|scon_stk_ptr
index|]
operator|=
name|scnum
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|38
case|:
line|#
directive|line
number|378
file|"parse.y"
block|{
if|if
condition|(
name|transchar
index|[
name|lastst
index|[
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
index|]
index|]
operator|!=
name|SYM_EPSILON
condition|)
comment|/* Provide final transition \now/ so it 				 * will be marked as a trailing context 				 * state. 				 */
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
operator|=
name|link_machines
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|,
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
argument_list|)
expr_stmt|;
name|mark_beginning_as_normal
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|current_state_type
operator|=
name|STATE_NORMAL
expr_stmt|;
if|if
condition|(
name|previous_continued_action
condition|)
block|{
comment|/* We need to treat this as variable trailing 				 * context so that the backup does not happen 				 * in the action but before the action switch 				 * statement.  If the backup happens in the 				 * action, then the rules "falling into" this 				 * one's action will *also* do the backup, 				 * erroneously. 				 */
if|if
condition|(
operator|!
name|varlength
operator|||
name|headcnt
operator|!=
literal|0
condition|)
name|warn
argument_list|(
literal|"trailing context made variable due to preceding '|' action"
argument_list|)
expr_stmt|;
comment|/* Mark as variable. */
name|varlength
operator|=
name|true
expr_stmt|;
name|headcnt
operator|=
literal|0
expr_stmt|;
block|}
if|if
condition|(
name|lex_compat
operator|||
operator|(
name|varlength
operator|&&
name|headcnt
operator|==
literal|0
operator|)
condition|)
block|{
comment|/* variable trailing context rule */
comment|/* Mark the first part of the rule as the 				 * accepting "head" part of a trailing 				 * context rule. 				 * 				 * By the way, we didn't do this at the 				 * beginning of this production because back 				 * then current_state_type was set up for a 				 * trail rule, and add_accept() can create 				 * a new state ... 				 */
name|add_accept
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|num_rules
operator||
name|YY_TRAILING_HEAD_MASK
argument_list|)
expr_stmt|;
name|variable_trail_rule
operator|=
name|true
expr_stmt|;
block|}
else|else
name|trailcnt
operator|=
name|rulelen
expr_stmt|;
name|yyval
operator|=
name|link_machines
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|39
case|:
line|#
directive|line
number|434
file|"parse.y"
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"trailing context used twice"
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|40
case|:
line|#
directive|line
number|437
file|"parse.y"
block|{
name|headcnt
operator|=
literal|0
expr_stmt|;
name|trailcnt
operator|=
literal|1
expr_stmt|;
name|rulelen
operator|=
literal|1
expr_stmt|;
name|varlength
operator|=
name|false
expr_stmt|;
name|current_state_type
operator|=
name|STATE_TRAILING_CONTEXT
expr_stmt|;
if|if
condition|(
name|trlcontxt
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"trailing context used twice"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|previous_continued_action
condition|)
block|{
comment|/* See the comment in the rule for "re2 re" 				 * above. 				 */
name|warn
argument_list|(
literal|"trailing context made variable due to preceding '|' action"
argument_list|)
expr_stmt|;
name|varlength
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|lex_compat
operator|||
name|varlength
condition|)
block|{
comment|/* Again, see the comment in the rule for 				 * "re2 re" above. 				 */
name|add_accept
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|num_rules
operator||
name|YY_TRAILING_HEAD_MASK
argument_list|)
expr_stmt|;
name|variable_trail_rule
operator|=
name|true
expr_stmt|;
block|}
name|trlcontxt
operator|=
name|true
expr_stmt|;
name|eps
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|link_machines
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|link_machines
argument_list|(
name|eps
argument_list|,
name|mkstate
argument_list|(
literal|'\n'
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|41
case|:
line|#
directive|line
number|480
file|"parse.y"
block|{
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
if|if
condition|(
name|trlcontxt
condition|)
block|{
if|if
condition|(
name|lex_compat
operator|||
operator|(
name|varlength
operator|&&
name|headcnt
operator|==
literal|0
operator|)
condition|)
comment|/* Both head and trail are 					 * variable-length. 					 */
name|variable_trail_rule
operator|=
name|true
expr_stmt|;
else|else
name|trailcnt
operator|=
name|rulelen
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|42
case|:
line|#
directive|line
number|498
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkor
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|43
case|:
line|#
directive|line
number|504
file|"parse.y"
block|{
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|44
case|:
line|#
directive|line
number|509
file|"parse.y"
block|{
comment|/* This rule is written separately so the 			 * reduction will occur before the trailing 			 * series is parsed. 			 */
if|if
condition|(
name|trlcontxt
condition|)
name|synerr
argument_list|(
name|_
argument_list|(
literal|"trailing context used twice"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|trlcontxt
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|varlength
condition|)
comment|/* We hope the trailing context is 				 * fixed-length. 				 */
name|varlength
operator|=
name|false
expr_stmt|;
else|else
name|headcnt
operator|=
name|rulelen
expr_stmt|;
name|rulelen
operator|=
literal|0
expr_stmt|;
name|current_state_type
operator|=
name|STATE_TRAILING_CONTEXT
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|45
case|:
line|#
directive|line
number|536
file|"parse.y"
block|{
comment|/* This is where concatenation of adjacent patterns 			 * gets done. 			 */
name|yyval
operator|=
name|link_machines
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|46
case|:
line|#
directive|line
number|544
file|"parse.y"
block|{
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|47
case|:
line|#
directive|line
number|547
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
operator|>
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|||
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
operator|<
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"bad iteration values"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"bad iteration values"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkopt
argument_list|(
name|mkrep
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
argument_list|,
literal|1
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkrep
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|48
case|:
line|#
directive|line
number|575
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"iteration value must be positive"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|4
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkrep
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|4
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|INFINITE_REPEAT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|49
case|:
line|#
directive|line
number|589
file|"parse.y"
block|{
comment|/* The series could be something like "(foo)", 			 * in which case we have no idea what its length 			 * is, so we punt here. 			 */
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"iteration value must be positive"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|link_machines
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|copysingl
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|50
case|:
line|#
directive|line
number|611
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkclos
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|51
case|:
line|#
directive|line
number|618
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkposcl
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|52
case|:
line|#
directive|line
number|624
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkopt
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|53
case|:
line|#
directive|line
number|630
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
operator|>
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|||
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
operator|<
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"bad iteration values"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
expr_stmt|;
block|}
else|else
block|{
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
operator|==
literal|0
condition|)
block|{
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"bad iteration values"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkopt
argument_list|(
name|mkrep
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
argument_list|,
literal|1
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkrep
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|5
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
block|}
block|}
break|break;
case|case
literal|54
case|:
line|#
directive|line
number|658
file|"parse.y"
block|{
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"iteration value must be positive"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|4
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|mkrep
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|4
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|INFINITE_REPEAT
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|55
case|:
line|#
directive|line
number|672
file|"parse.y"
block|{
comment|/* The singleton could be something like "(foo)", 			 * in which case we have no idea what its length 			 * is, so we punt here. 			 */
name|varlength
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|<=
literal|0
condition|)
block|{
name|synerr
argument_list|(
name|_
argument_list|(
literal|"iteration value must be positive"
argument_list|)
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
else|else
name|yyval
operator|=
name|link_machines
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|copysingl
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
operator|-
literal|1
argument_list|)
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|56
case|:
line|#
directive|line
number|691
file|"parse.y"
block|{
if|if
condition|(
operator|!
name|madeany
condition|)
block|{
comment|/* Create the '.' character class. */
name|ccldot
operator|=
name|cclinit
argument_list|()
expr_stmt|;
name|ccladd
argument_list|(
name|ccldot
argument_list|,
literal|'\n'
argument_list|)
expr_stmt|;
name|cclnegate
argument_list|(
name|ccldot
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|mkeccl
argument_list|(
name|ccltbl
operator|+
name|cclmap
index|[
name|ccldot
index|]
argument_list|,
name|ccllen
index|[
name|ccldot
index|]
argument_list|,
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|,
name|csize
argument_list|)
expr_stmt|;
comment|/* Create the (?s:'.') character class. */
name|cclany
operator|=
name|cclinit
argument_list|()
expr_stmt|;
name|cclnegate
argument_list|(
name|cclany
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|mkeccl
argument_list|(
name|ccltbl
operator|+
name|cclmap
index|[
name|cclany
index|]
argument_list|,
name|ccllen
index|[
name|cclany
index|]
argument_list|,
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|,
name|csize
argument_list|)
expr_stmt|;
name|madeany
operator|=
name|true
expr_stmt|;
block|}
operator|++
name|rulelen
expr_stmt|;
if|if
condition|(
name|sf_dot_all
argument_list|()
condition|)
name|yyval
operator|=
name|mkstate
argument_list|(
operator|-
name|cclany
argument_list|)
expr_stmt|;
else|else
name|yyval
operator|=
name|mkstate
argument_list|(
operator|-
name|ccldot
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|57
case|:
line|#
directive|line
number|725
file|"parse.y"
block|{
comment|/* Sort characters for fast searching. 				 */
name|qsort
argument_list|(
name|ccltbl
operator|+
name|cclmap
index|[
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
index|]
argument_list|,
name|ccllen
index|[
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
index|]
argument_list|,
sizeof|sizeof
argument_list|(
operator|*
name|ccltbl
argument_list|)
argument_list|,
name|cclcmp
argument_list|)
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|mkeccl
argument_list|(
name|ccltbl
operator|+
name|cclmap
index|[
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
index|]
argument_list|,
name|ccllen
index|[
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
index|]
argument_list|,
name|nextecm
argument_list|,
name|ecgroup
argument_list|,
name|csize
argument_list|,
name|csize
argument_list|)
expr_stmt|;
operator|++
name|rulelen
expr_stmt|;
if|if
condition|(
name|ccl_has_nl
index|[
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
index|]
condition|)
name|rule_has_nl
index|[
name|num_rules
index|]
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
operator|-
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|58
case|:
line|#
directive|line
number|743
file|"parse.y"
block|{
operator|++
name|rulelen
expr_stmt|;
if|if
condition|(
name|ccl_has_nl
index|[
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
index|]
condition|)
name|rule_has_nl
index|[
name|num_rules
index|]
operator|=
name|true
expr_stmt|;
name|yyval
operator|=
name|mkstate
argument_list|(
operator|-
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|59
case|:
line|#
directive|line
number|753
file|"parse.y"
block|{
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|60
case|:
line|#
directive|line
number|756
file|"parse.y"
block|{
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|61
case|:
line|#
directive|line
number|759
file|"parse.y"
block|{
operator|++
name|rulelen
expr_stmt|;
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
operator|==
name|nlch
condition|)
name|rule_has_nl
index|[
name|num_rules
index|]
operator|=
name|true
expr_stmt|;
if|if
condition|(
name|sf_case_ins
argument_list|()
operator|&&
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
condition|)
comment|/* create an alternation, as in (a|A) */
name|yyval
operator|=
name|mkor
argument_list|(
name|mkstate
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mkstate
argument_list|(
name|reverse_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|yyval
operator|=
name|mkstate
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|62
case|:
line|#
directive|line
number|773
file|"parse.y"
block|{
name|yyval
operator|=
name|ccl_set_diff
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|63
case|:
line|#
directive|line
number|774
file|"parse.y"
block|{
name|yyval
operator|=
name|ccl_set_union
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|65
case|:
line|#
directive|line
number|780
file|"parse.y"
block|{
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|66
case|:
line|#
directive|line
number|783
file|"parse.y"
block|{
name|cclnegate
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|67
case|:
line|#
directive|line
number|790
file|"parse.y"
block|{
if|if
condition|(
name|sf_case_ins
argument_list|()
condition|)
block|{
comment|/* If one end of the range has case and the other 			     * does not, or the cases are different, then we're not 			     * sure what range the user is trying to express. 			     * Examples: [@-z] or [S-t] 			     */
if|if
condition|(
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
operator|!=
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
operator|||
operator|(
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|b_islower
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
operator|!=
name|b_islower
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
operator|||
operator|(
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
operator|(
name|b_isupper
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
operator|!=
name|b_isupper
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
operator|)
operator|)
condition|)
name|format_warn3
argument_list|(
name|_
argument_list|(
literal|"the character range [%c-%c] is ambiguous in a case-insensitive scanner"
argument_list|)
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
comment|/* If the range spans uppercase characters but not 			     * lowercase (or vice-versa), then should we automatically 			     * include lowercase characters in the range? 			     * Example: [@-_] spans [a-z] but not [A-Z] 			     */
elseif|else
if|if
condition|(
operator|!
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
operator|!
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
operator|&&
operator|!
name|range_covers_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
condition|)
name|format_warn3
argument_list|(
name|_
argument_list|(
literal|"the character range [%c-%c] is ambiguous in a case-insensitive scanner"
argument_list|)
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
operator|>
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
condition|)
name|synerr
argument_list|(
name|_
argument_list|(
literal|"negative range in character class"
argument_list|)
argument_list|)
expr_stmt|;
else|else
block|{
for|for
control|(
name|i
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
init|;
name|i
operator|<=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
condition|;
operator|++
name|i
control|)
name|ccladd
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
comment|/* Keep track if this ccl is staying in 				 * alphabetical order. 				 */
name|cclsorted
operator|=
name|cclsorted
operator|&&
operator|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
operator|>
name|lastchar
operator|)
expr_stmt|;
name|lastchar
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
comment|/* Do it again for upper/lowercase */
if|if
condition|(
name|sf_case_ins
argument_list|()
operator|&&
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
operator|&&
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
operator|=
name|reverse_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
argument_list|)
expr_stmt|;
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
operator|=
name|reverse_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
init|;
name|i
operator|<=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
condition|;
operator|++
name|i
control|)
name|ccladd
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
argument_list|,
name|i
argument_list|)
expr_stmt|;
name|cclsorted
operator|=
name|cclsorted
operator|&&
operator|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|2
index|]
operator|>
name|lastchar
operator|)
expr_stmt|;
name|lastchar
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
block|}
block|}
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|3
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|68
case|:
line|#
directive|line
number|850
file|"parse.y"
block|{
name|ccladd
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cclsorted
operator|=
name|cclsorted
operator|&&
operator|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
operator|>
name|lastchar
operator|)
expr_stmt|;
name|lastchar
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
comment|/* Do it again for upper/lowercase */
if|if
condition|(
name|sf_case_ins
argument_list|()
operator|&&
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
condition|)
block|{
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
operator|=
name|reverse_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|ccladd
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|cclsorted
operator|=
name|cclsorted
operator|&&
operator|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
operator|>
name|lastchar
operator|)
expr_stmt|;
name|lastchar
operator|=
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
expr_stmt|;
block|}
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|69
case|:
line|#
directive|line
number|868
file|"parse.y"
block|{
comment|/* Too hard to properly maintain cclsorted. */
name|cclsorted
operator|=
name|false
expr_stmt|;
name|yyval
operator|=
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
expr_stmt|;
block|}
break|break;
case|case
literal|70
case|:
line|#
directive|line
number|875
file|"parse.y"
block|{
name|cclsorted
operator|=
name|true
expr_stmt|;
name|lastchar
operator|=
literal|0
expr_stmt|;
name|currccl
operator|=
name|yyval
operator|=
name|cclinit
argument_list|()
expr_stmt|;
block|}
break|break;
case|case
literal|71
case|:
line|#
directive|line
number|883
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isalnum
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|72
case|:
line|#
directive|line
number|884
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isalpha
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|73
case|:
line|#
directive|line
number|885
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|IS_BLANK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|74
case|:
line|#
directive|line
number|886
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|iscntrl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|75
case|:
line|#
directive|line
number|887
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isdigit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|76
case|:
line|#
directive|line
number|888
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isgraph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|77
case|:
line|#
directive|line
number|889
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|islower
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf_case_ins
argument_list|()
condition|)
name|CCL_EXPR
argument_list|(
name|isupper
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|78
case|:
line|#
directive|line
number|894
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isprint
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|79
case|:
line|#
directive|line
number|895
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|ispunct
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|80
case|:
line|#
directive|line
number|896
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isspace
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|81
case|:
line|#
directive|line
number|897
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isxdigit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|82
case|:
line|#
directive|line
number|898
file|"parse.y"
block|{
name|CCL_EXPR
argument_list|(
name|isupper
argument_list|)
expr_stmt|;
if|if
condition|(
name|sf_case_ins
argument_list|()
condition|)
name|CCL_EXPR
argument_list|(
name|islower
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|83
case|:
line|#
directive|line
number|904
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|isalnum
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|84
case|:
line|#
directive|line
number|905
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|isalpha
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|85
case|:
line|#
directive|line
number|906
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|IS_BLANK
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|86
case|:
line|#
directive|line
number|907
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|iscntrl
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|87
case|:
line|#
directive|line
number|908
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|isdigit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|88
case|:
line|#
directive|line
number|909
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|isgraph
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|89
case|:
line|#
directive|line
number|910
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|isprint
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|90
case|:
line|#
directive|line
number|911
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|ispunct
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|91
case|:
line|#
directive|line
number|912
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|isspace
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|92
case|:
line|#
directive|line
number|913
file|"parse.y"
block|{
name|CCL_NEG_EXPR
argument_list|(
name|isxdigit
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|93
case|:
line|#
directive|line
number|914
file|"parse.y"
block|{
if|if
condition|(
name|sf_case_ins
argument_list|()
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"[:^lower:] is ambiguous in case insensitive scanner"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CCL_NEG_EXPR
argument_list|(
name|islower
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|94
case|:
line|#
directive|line
number|920
file|"parse.y"
block|{
if|if
condition|(
name|sf_case_ins
argument_list|()
condition|)
name|warn
argument_list|(
name|_
argument_list|(
literal|"[:^upper:] ambiguous in case insensitive scanner"
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|CCL_NEG_EXPR
argument_list|(
name|isupper
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|95
case|:
line|#
directive|line
number|929
file|"parse.y"
block|{
if|if
condition|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
operator|==
name|nlch
condition|)
name|rule_has_nl
index|[
name|num_rules
index|]
operator|=
name|true
expr_stmt|;
operator|++
name|rulelen
expr_stmt|;
if|if
condition|(
name|sf_case_ins
argument_list|()
operator|&&
name|has_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
condition|)
name|yyval
operator|=
name|mkor
argument_list|(
name|mkstate
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
argument_list|,
name|mkstate
argument_list|(
name|reverse_case
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
argument_list|)
argument_list|)
expr_stmt|;
else|else
name|yyval
operator|=
name|mkstate
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
literal|0
index|]
argument_list|)
expr_stmt|;
name|yyval
operator|=
name|link_machines
argument_list|(
name|yystack
operator|.
name|l_mark
index|[
operator|-
literal|1
index|]
argument_list|,
name|yyval
argument_list|)
expr_stmt|;
block|}
break|break;
case|case
literal|96
case|:
line|#
directive|line
number|944
file|"parse.y"
block|{
name|yyval
operator|=
name|mkstate
argument_list|(
name|SYM_EPSILON
argument_list|)
expr_stmt|;
block|}
break|break;
line|#
directive|line
number|1787
file|"parse.c"
block|}
name|yystack
operator|.
name|s_mark
operator|-=
name|yym
expr_stmt|;
name|yystate
operator|=
operator|*
name|yystack
operator|.
name|s_mark
expr_stmt|;
name|yystack
operator|.
name|l_mark
operator|-=
name|yym
expr_stmt|;
name|yym
operator|=
name|yylhs
index|[
name|yyn
index|]
expr_stmt|;
if|if
condition|(
name|yystate
operator|==
literal|0
operator|&&
name|yym
operator|==
literal|0
condition|)
block|{
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: after reduction, shifting from state 0 to\  state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|YYFINAL
argument_list|)
expr_stmt|;
endif|#
directive|endif
name|yystate
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
name|YYFINAL
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yyval
expr_stmt|;
if|if
condition|(
name|yychar
operator|<
literal|0
condition|)
block|{
if|if
condition|(
operator|(
name|yychar
operator|=
name|YYLEX
operator|)
operator|<
literal|0
condition|)
name|yychar
operator|=
literal|0
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
block|{
name|yys
operator|=
literal|0
expr_stmt|;
if|if
condition|(
name|yychar
operator|<=
name|YYMAXTOKEN
condition|)
name|yys
operator|=
name|yyname
index|[
name|yychar
index|]
expr_stmt|;
if|if
condition|(
operator|!
name|yys
condition|)
name|yys
operator|=
literal|"illegal-symbol"
expr_stmt|;
name|printf
argument_list|(
literal|"%sdebug: state %d, reading %d (%s)\n"
argument_list|,
name|YYPREFIX
argument_list|,
name|YYFINAL
argument_list|,
name|yychar
argument_list|,
name|yys
argument_list|)
expr_stmt|;
block|}
endif|#
directive|endif
block|}
if|if
condition|(
name|yychar
operator|==
literal|0
condition|)
goto|goto
name|yyaccept
goto|;
goto|goto
name|yyloop
goto|;
block|}
if|if
condition|(
operator|(
name|yyn
operator|=
name|yygindex
index|[
name|yym
index|]
operator|)
operator|&&
operator|(
name|yyn
operator|+=
name|yystate
operator|)
operator|>=
literal|0
operator|&&
name|yyn
operator|<=
name|YYTABLESIZE
operator|&&
name|yycheck
index|[
name|yyn
index|]
operator|==
name|yystate
condition|)
name|yystate
operator|=
name|yytable
index|[
name|yyn
index|]
expr_stmt|;
else|else
name|yystate
operator|=
name|yydgoto
index|[
name|yym
index|]
expr_stmt|;
if|#
directive|if
name|YYDEBUG
if|if
condition|(
name|yydebug
condition|)
name|printf
argument_list|(
literal|"%sdebug: after reduction, shifting from state %d \ to state %d\n"
argument_list|,
name|YYPREFIX
argument_list|,
operator|*
name|yystack
operator|.
name|s_mark
argument_list|,
name|yystate
argument_list|)
expr_stmt|;
endif|#
directive|endif
if|if
condition|(
name|yystack
operator|.
name|s_mark
operator|>=
name|yystack
operator|.
name|s_last
operator|&&
name|yygrowstack
argument_list|(
operator|&
name|yystack
argument_list|)
condition|)
block|{
goto|goto
name|yyoverflow
goto|;
block|}
operator|*
operator|++
name|yystack
operator|.
name|s_mark
operator|=
operator|(
name|short
operator|)
name|yystate
expr_stmt|;
operator|*
operator|++
name|yystack
operator|.
name|l_mark
operator|=
name|yyval
expr_stmt|;
goto|goto
name|yyloop
goto|;
name|yyoverflow
label|:
name|yyerror
argument_list|(
literal|"yacc stack overflow"
argument_list|)
expr_stmt|;
name|yyabort
label|:
name|yyfreestack
argument_list|(
operator|&
name|yystack
argument_list|)
expr_stmt|;
return|return
operator|(
literal|1
operator|)
return|;
name|yyaccept
label|:
name|yyfreestack
argument_list|(
operator|&
name|yystack
argument_list|)
expr_stmt|;
return|return
operator|(
literal|0
operator|)
return|;
block|}
end_function

end_unit

