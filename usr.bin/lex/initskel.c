begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* $FreeBSD$ */
end_comment

begin_comment
comment|/* File created from flex.skl via mkskel.sh */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_decl_stmt
specifier|const
name|char
modifier|*
name|skel
index|[]
init|=
block|{
literal|"%# -*-C-*- vi: set ft=c:"
block|,
literal|"%# This file is processed in several stages."
block|,
literal|"%# Here are the stages, as best as I can describe:"
block|,
literal|"%#"
block|,
literal|"%#   1. flex.skl is processed through GNU m4 during the"
block|,
literal|"%#      pre-compilation stage of flex. Only macros starting"
block|,
literal|"%#      with `m4_' are processed, and quoting is normal."
block|,
literal|"%#"
block|,
literal|"%#   2. The preprocessed skeleton is translated verbatim into a"
block|,
literal|"%#      C array, saved as \"skel.c\" and compiled into the flex binary."
block|,
literal|"%#"
block|,
literal|"%#   3. At runtime, the skeleton is generated and filtered (again)"
block|,
literal|"%#      through m4. Macros beginning with `m4_' will be processed."
block|,
literal|"%#      The quoting is \"[[\" and \"]]\" so we don't interfere with"
block|,
literal|"%#      user code."
block|,
literal|"%# "
block|,
literal|"%# All generate macros for the m4 stage contain the text \"m4\" or \"M4\""
block|,
literal|"%# in them. This is to distinguish them from CPP macros."
block|,
literal|"%# The exception to this rule is YY_G, which is an m4 macro, "
block|,
literal|"%# but it needs to be remain short because it is used everywhere."
block|,
literal|"%#"
block|,
literal|"/* A lexical scanner generated by flex */"
block|,
literal|""
block|,
literal|"%#  Macros for preproc stage."
block|,
literal|""
block|,
literal|""
block|,
literal|"%# Macros for runtime processing stage."
block|,
literal|"m4_changecom"
block|,
literal|"m4_changequote"
block|,
literal|"m4_changequote([[, ]])"
block|,
literal|""
block|,
literal|"%# "
block|,
literal|"%# Lines in this skeleton starting with a \"%\" character are \"control lines\""
block|,
literal|"%# and affect the generation of the scanner. The possible control codes are"
block|,
literal|"%# listed and processed in misc.c."
block|,
literal|"%#"
block|,
literal|"%#   %#  -  A comment. The current line is omitted from the generated scanner."
block|,
literal|"%#   %if-c++-only  -  The following lines are printed for C++ scanners ONLY."
block|,
literal|"%#   %if-c-only    -  The following lines are NOT printed for C++ scanners."
block|,
literal|"%#   %if-c-or-c++  -  The following lines are printed in BOTH C and C++ scanners."
block|,
literal|"%#   %if-reentrant     - Print for reentrant scanners.(push)"
block|,
literal|"%#   %if-not-reentrant - Print for non-reentrant scanners. (push)"
block|,
literal|"%#   %if-bison-bridge  - Print for bison-bridge. (push)"
block|,
literal|"%#   %if-not-bison-bridge  - Print for non-bison-bridge. (push)"
block|,
literal|"%#   %endif        - pop from the previous if code."
block|,
literal|"%#   %%  -  A stop-point, where code is inserted by flex."
block|,
literal|"%#          Each stop-point is numbered here and also in the code generator."
block|,
literal|"%#          (See gen.c, etc. for details.)"
block|,
literal|"%#   %not-for-header  -  Begin code that should NOT appear in a \".h\" file."
block|,
literal|"%#   %ok-for-header   -  %c and %e are used for building a header file."
block|,
literal|"%#   %if-tables-serialization"
block|,
literal|"%#"
block|,
literal|"%#   All control-lines EXCEPT comment lines (\"%#\") will be inserted into"
block|,
literal|"%#   the generated scanner as a C-style comment. This is to aid those who"
block|,
literal|"%#   edit the skeleton."
block|,
literal|"%#"
block|,
literal|""
block|,
literal|"%not-for-header"
block|,
literal|"%if-c-only"
block|,
literal|"%if-not-reentrant"
block|,
literal|"m4_ifelse(M4_YY_PREFIX,yy,,"
block|,
literal|"#define yy_create_buffer M4_YY_PREFIX[[_create_buffer]]"
block|,
literal|"#define yy_delete_buffer M4_YY_PREFIX[[_delete_buffer]]"
block|,
literal|"#define yy_flex_debug M4_YY_PREFIX[[_flex_debug]]"
block|,
literal|"#define yy_init_buffer M4_YY_PREFIX[[_init_buffer]]"
block|,
literal|"#define yy_flush_buffer M4_YY_PREFIX[[_flush_buffer]]"
block|,
literal|"#define yy_load_buffer_state M4_YY_PREFIX[[_load_buffer_state]]"
block|,
literal|"#define yy_switch_to_buffer M4_YY_PREFIX[[_switch_to_buffer]]"
block|,
literal|"#define yyin M4_YY_PREFIX[[in]]"
block|,
literal|"#define yyleng M4_YY_PREFIX[[leng]]"
block|,
literal|"#define yylex M4_YY_PREFIX[[lex]]"
block|,
literal|"#define yylineno M4_YY_PREFIX[[lineno]]"
block|,
literal|"#define yyout M4_YY_PREFIX[[out]]"
block|,
literal|"#define yyrestart M4_YY_PREFIX[[restart]]"
block|,
literal|"#define yytext M4_YY_PREFIX[[text]]"
block|,
literal|"#define yywrap M4_YY_PREFIX[[wrap]]"
block|,
literal|"#define yyalloc M4_YY_PREFIX[[alloc]]"
block|,
literal|"#define yyrealloc M4_YY_PREFIX[[realloc]]"
block|,
literal|"#define yyfree M4_YY_PREFIX[[free]]"
block|,
literal|")"
block|,
literal|"%endif"
block|,
literal|"%endif"
block|,
literal|"%ok-for-header"
block|,
literal|""
block|,
literal|"#define FLEX_SCANNER"
block|,
literal|"#define YY_FLEX_MAJOR_VERSION 2"
block|,
literal|"#define YY_FLEX_MINOR_VERSION 5"
block|,
literal|"#define YY_FLEX_SUBMINOR_VERSION 37"
block|,
literal|"#if YY_FLEX_SUBMINOR_VERSION> 0"
block|,
literal|"#define FLEX_BETA"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%# Some negated symbols"
block|,
literal|"m4_ifdef( [[M4_YY_IN_HEADER]], , [[m4_define([[M4_YY_NOT_IN_HEADER]], [[]])]])"
block|,
literal|"m4_ifdef( [[M4_YY_REENTRANT]], , [[m4_define([[M4_YY_NOT_REENTRANT]], [[]])]])"
block|,
literal|""
block|,
literal|"%# This is the m4 way to say \"(stack_used || is_reentrant)"
block|,
literal|"m4_ifdef( [[M4_YY_STACK_USED]], [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])"
block|,
literal|"m4_ifdef( [[M4_YY_REENTRANT]],  [[m4_define([[M4_YY_HAS_START_STACK_VARS]])]])"
block|,
literal|""
block|,
literal|"%# Prefixes."
block|,
literal|"%# The complexity here is necessary so that m4 preserves"
block|,
literal|"%# the argument lists to each C function."
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_PREFIX]],, [[m4_define([[M4_YY_PREFIX]], [[yy]])]])"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c++-only"
block|,
literal|"    /* The c++ scanner is a mess. The FlexLexer.h header file relies on the"
block|,
literal|"     * following macro. This is required in order to pass the c++-multiple-scanners"
block|,
literal|"     * test in the regression suite. We get reports that it breaks inheritance."
block|,
literal|"     * We will address this in a future release of flex, or omit the C++ scanner"
block|,
literal|"     * altogether."
block|,
literal|"     */"
block|,
literal|"    #define yyFlexLexer M4_YY_PREFIX[[FlexLexer]]"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"    m4_define(yy[[_create_buffer]], [[M4_YY_PREFIX[[_create_buffer]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_delete_buffer]], [[M4_YY_PREFIX[[_delete_buffer]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_scan_buffer]], [[M4_YY_PREFIX[[_scan_buffer]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_scan_string]], [[M4_YY_PREFIX[[_scan_string]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_scan_bytes]], [[M4_YY_PREFIX[[_scan_bytes]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_init_buffer]], [[M4_YY_PREFIX[[_init_buffer]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_flush_buffer]], [[M4_YY_PREFIX[[_flush_buffer]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_load_buffer_state]], [[M4_YY_PREFIX[[_load_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_switch_to_buffer]], [[M4_YY_PREFIX[[_switch_to_buffer]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[push_buffer_state]], [[M4_YY_PREFIX[[push_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[pop_buffer_state]], [[M4_YY_PREFIX[[pop_buffer_state]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[ensure_buffer_stack]], [[M4_YY_PREFIX[[ensure_buffer_stack]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[lex]], [[M4_YY_PREFIX[[lex]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[restart]], [[M4_YY_PREFIX[[restart]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[lex_init]], [[M4_YY_PREFIX[[lex_init]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[lex_init_extra]], [[M4_YY_PREFIX[[lex_init_extra]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[lex_destroy]], [[M4_YY_PREFIX[[lex_destroy]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[get_debug]], [[M4_YY_PREFIX[[get_debug]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[set_debug]], [[M4_YY_PREFIX[[set_debug]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[get_extra]], [[M4_YY_PREFIX[[get_extra]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[set_extra]], [[M4_YY_PREFIX[[set_extra]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[get_in]], [[M4_YY_PREFIX[[get_in]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[set_in]], [[M4_YY_PREFIX[[set_in]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[get_out]], [[M4_YY_PREFIX[[get_out]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[set_out]], [[M4_YY_PREFIX[[set_out]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[get_leng]], [[M4_YY_PREFIX[[get_leng]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[get_text]], [[M4_YY_PREFIX[[get_text]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[get_lineno]], [[M4_YY_PREFIX[[get_lineno]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[set_lineno]], [[M4_YY_PREFIX[[set_lineno]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"    [["
block|,
literal|"        m4_define(yy[[get_column]], [[M4_YY_PREFIX[[get_column]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"        m4_define(yy[[set_column]], [[M4_YY_PREFIX[[set_column]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    ]])"
block|,
literal|"    m4_define(yy[[wrap]], [[M4_YY_PREFIX[[wrap]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_BISON_LVAL]],"
block|,
literal|"[["
block|,
literal|"    m4_define(yy[[get_lval]], [[M4_YY_PREFIX[[get_lval]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[set_lval]], [[M4_YY_PREFIX[[set_lval]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"[["
block|,
literal|"    m4_define(yy[[get_lloc]], [[M4_YY_PREFIX[[get_lloc]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[set_lloc]], [[M4_YY_PREFIX[[set_lloc]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"    m4_define(yy[[alloc]], [[M4_YY_PREFIX[[alloc]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[realloc]], [[M4_YY_PREFIX[[realloc]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[free]], [[M4_YY_PREFIX[[free]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"m4_ifdef( [[M4_YY_NOT_REENTRANT]],"
block|,
literal|"[["
block|,
literal|"    m4_define(yy[[text]], [[M4_YY_PREFIX[[text]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[leng]], [[M4_YY_PREFIX[[leng]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[in]], [[M4_YY_PREFIX[[in]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[out]], [[M4_YY_PREFIX[[out]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[_flex_debug]], [[M4_YY_PREFIX[[_flex_debug]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[lineno]], [[M4_YY_PREFIX[[lineno]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_TABLES_EXTERNAL]],"
block|,
literal|"[["
block|,
literal|"    m4_define(yy[[tables_fload]], [[M4_YY_PREFIX[[tables_fload]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[tables_destroy]], [[M4_YY_PREFIX[[tables_destroy]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"    m4_define(yy[[TABLES_NAME]], [[M4_YY_PREFIX[[TABLES_NAME]]m4_ifelse($#,0,,[[($@)]])]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"/* First, we deal with  platform-specific or compiler-specific issues. */"
block|,
literal|""
block|,
literal|"#if defined(__FreeBSD__)"
block|,
literal|"#ifndef __STDC_LIMIT_MACROS"
block|,
literal|"#define	__STDC_LIMIT_MACROS"
block|,
literal|"#endif"
block|,
literal|"#include<sys/cdefs.h>"
block|,
literal|"#include<stdint.h>"
block|,
literal|"#else"
block|,
literal|"#define	__dead2"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* begin standard C headers. */"
block|,
literal|"%if-c-only"
block|,
literal|"#include<stdio.h>"
block|,
literal|"#include<string.h>"
block|,
literal|"#include<errno.h>"
block|,
literal|"#include<stdlib.h>"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-tables-serialization"
block|,
literal|"#include<sys/types.h>"
block|,
literal|"#include<netinet/in.h>"
block|,
literal|"%endif"
block|,
literal|"/* end standard C headers. */"
block|,
literal|""
block|,
literal|"%if-c-or-c++"
block|,
literal|"/* flex integer type definitions */"
block|,
literal|""
block|,
literal|"#ifndef FLEXINT_H"
block|,
literal|"#define FLEXINT_H"
block|,
literal|""
block|,
literal|"/* C99 systems have<inttypes.h>. Non-C99 systems may or may not. */"
block|,
literal|""
block|,
literal|"#if defined(__FreeBSD__) || \\"
block|,
literal|"    (defined (__STDC_VERSION__)&& __STDC_VERSION__>= 199901L)"
block|,
literal|""
block|,
literal|"/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,"
block|,
literal|" * if you want the limit (max/min) macros for int types. "
block|,
literal|" */"
block|,
literal|"#ifndef __STDC_LIMIT_MACROS"
block|,
literal|"#define __STDC_LIMIT_MACROS 1"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"#include<inttypes.h>"
block|,
literal|"typedef int8_t flex_int8_t;"
block|,
literal|"typedef uint8_t flex_uint8_t;"
block|,
literal|"typedef int16_t flex_int16_t;"
block|,
literal|"typedef uint16_t flex_uint16_t;"
block|,
literal|"typedef int32_t flex_int32_t;"
block|,
literal|"typedef uint32_t flex_uint32_t;"
block|,
literal|"#else"
block|,
literal|"typedef signed char flex_int8_t;"
block|,
literal|"typedef short int flex_int16_t;"
block|,
literal|"typedef int flex_int32_t;"
block|,
literal|"typedef unsigned char flex_uint8_t; "
block|,
literal|"typedef unsigned short int flex_uint16_t;"
block|,
literal|"typedef unsigned int flex_uint32_t;"
block|,
literal|""
block|,
literal|"/* Limits of integral types. */"
block|,
literal|"#ifndef INT8_MIN"
block|,
literal|"#define INT8_MIN               (-128)"
block|,
literal|"#endif"
block|,
literal|"#ifndef INT16_MIN"
block|,
literal|"#define INT16_MIN              (-32767-1)"
block|,
literal|"#endif"
block|,
literal|"#ifndef INT32_MIN"
block|,
literal|"#define INT32_MIN              (-2147483647-1)"
block|,
literal|"#endif"
block|,
literal|"#ifndef INT8_MAX"
block|,
literal|"#define INT8_MAX               (127)"
block|,
literal|"#endif"
block|,
literal|"#ifndef INT16_MAX"
block|,
literal|"#define INT16_MAX              (32767)"
block|,
literal|"#endif"
block|,
literal|"#ifndef INT32_MAX"
block|,
literal|"#define INT32_MAX              (2147483647)"
block|,
literal|"#endif"
block|,
literal|"#ifndef UINT8_MAX"
block|,
literal|"#define UINT8_MAX              (255U)"
block|,
literal|"#endif"
block|,
literal|"#ifndef UINT16_MAX"
block|,
literal|"#define UINT16_MAX             (65535U)"
block|,
literal|"#endif"
block|,
literal|"#ifndef UINT32_MAX"
block|,
literal|"#define UINT32_MAX             (4294967295U)"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"#endif /* ! C99 */"
block|,
literal|""
block|,
literal|"#endif /* ! FLEXINT_H */"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-c++-only"
block|,
literal|"/* begin standard C++ headers. */"
block|,
literal|"#include<iostream> "
block|,
literal|"#include<errno.h>"
block|,
literal|"#include<cstdlib>"
block|,
literal|"#include<cstdio>"
block|,
literal|"#include<cstring>"
block|,
literal|"/* end standard C++ headers. */"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"#ifdef __cplusplus"
block|,
literal|""
block|,
literal|"/* The \"const\" storage-class-modifier is valid. */"
block|,
literal|"#define YY_USE_CONST"
block|,
literal|""
block|,
literal|"#else	/* ! __cplusplus */"
block|,
literal|""
block|,
literal|"/* C99 requires __STDC__ to be defined as 1. */"
block|,
literal|"#if defined (__STDC__)"
block|,
literal|""
block|,
literal|"#define YY_USE_CONST"
block|,
literal|""
block|,
literal|"#endif	/* defined (__STDC__) */"
block|,
literal|"#endif	/* ! __cplusplus */"
block|,
literal|""
block|,
literal|"#ifdef YY_USE_CONST"
block|,
literal|"#define yyconst const"
block|,
literal|"#else"
block|,
literal|"#define yyconst"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%# For compilers that can not handle prototypes."
block|,
literal|"%# e.g.,"
block|,
literal|"%# The function prototype"
block|,
literal|"%#    int foo(int x, char* y);"
block|,
literal|"%# "
block|,
literal|"%# ...should be written as"
block|,
literal|"%#    int foo M4_YY_PARAMS(int x, char* y);"
block|,
literal|"%# "
block|,
literal|"%# ...which could possibly generate"
block|,
literal|"%#    int foo ();"
block|,
literal|"%# "
block|,
literal|"m4_ifdef( [[M4_YY_NO_ANSI_FUNC_PROTOS]],"
block|,
literal|"[["
block|,
literal|"    m4_define( [[M4_YY_PARAMS]], [[()]])"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"    m4_define( [[M4_YY_PARAMS]], [[($*)]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%not-for-header"
block|,
literal|"/* Returned upon end-of-file. */"
block|,
literal|"#define YY_NULL 0"
block|,
literal|"%ok-for-header"
block|,
literal|""
block|,
literal|"%not-for-header"
block|,
literal|"/* Promotes a possibly negative, possibly signed char to an unsigned"
block|,
literal|" * integer for use as an array index.  If the signed char is negative,"
block|,
literal|" * we want to instead treat it as an 8-bit unsigned char, hence the"
block|,
literal|" * double cast."
block|,
literal|" */"
block|,
literal|"#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)"
block|,
literal|"%ok-for-header"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-reentrant"
block|,
literal|""
block|,
literal|"/* An opaque pointer. */"
block|,
literal|"#ifndef YY_TYPEDEF_YY_SCANNER_T"
block|,
literal|"#define YY_TYPEDEF_YY_SCANNER_T"
block|,
literal|"typedef void* yyscan_t;"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%# Declare yyguts variable"
block|,
literal|"m4_define( [[M4_YY_DECL_GUTS_VAR]], [[struct yyguts_t * yyg = (struct yyguts_t*)yyscanner]])"
block|,
literal|"%# Perform a noop access on yyguts to prevent unused variable complains"
block|,
literal|"m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[(void)yyg]])"
block|,
literal|"%# For use wherever a Global is accessed or assigned."
block|,
literal|"m4_define( [[YY_G]], [[yyg->$1]])"
block|,
literal|""
block|,
literal|"%# For use in function prototypes to append the additional argument."
block|,
literal|"m4_define( [[M4_YY_PROTO_LAST_ARG]],  [[, yyscan_t yyscanner]])"
block|,
literal|"m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[yyscan_t yyscanner]])"
block|,
literal|""
block|,
literal|"%# For use in function definitions to append the additional argument."
block|,
literal|"m4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],"
block|,
literal|"[["
block|,
literal|"    m4_define( [[M4_YY_DEF_LAST_ARG]], [[, yyscanner]])"
block|,
literal|"    m4_define( [[M4_YY_DEF_ONLY_ARG]], [[yyscanner]])"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"    m4_define( [[M4_YY_DEF_LAST_ARG]],  [[, yyscan_t yyscanner]])"
block|,
literal|"    m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[yyscan_t yyscanner]])"
block|,
literal|"]])"
block|,
literal|"m4_define( [[M4_YY_DECL_LAST_ARG]],  [[yyscan_t yyscanner;]])"
block|,
literal|""
block|,
literal|"%# For use in function calls to pass the additional argument."
block|,
literal|"m4_define( [[M4_YY_CALL_LAST_ARG]], [[, yyscanner]])"
block|,
literal|"m4_define( [[M4_YY_CALL_ONLY_ARG]], [[yyscanner]])"
block|,
literal|""
block|,
literal|"%# For use in function documentation to adjust for additional argument."
block|,
literal|"m4_define( [[M4_YY_DOC_PARAM]], [[@param yyscanner The scanner object.]])"
block|,
literal|""
block|,
literal|"/* For convenience, these vars (plus the bison vars far below)"
block|,
literal|"   are macros in the reentrant scanner. */"
block|,
literal|"#define yyin YY_G(yyin_r)"
block|,
literal|"#define yyout YY_G(yyout_r)"
block|,
literal|"#define yyextra YY_G(yyextra_r)"
block|,
literal|"#define yyleng YY_G(yyleng_r)"
block|,
literal|"#define yytext YY_G(yytext_r)"
block|,
literal|"#define yylineno (YY_CURRENT_BUFFER_LVALUE->yy_bs_lineno)"
block|,
literal|"#define yycolumn (YY_CURRENT_BUFFER_LVALUE->yy_bs_column)"
block|,
literal|"#define yy_flex_debug YY_G(yy_flex_debug_r)"
block|,
literal|""
block|,
literal|"m4_define( [[M4_YY_INCR_LINENO]],"
block|,
literal|"[[   "
block|,
literal|"    do{ yylineno++;"
block|,
literal|"        yycolumn=0;"
block|,
literal|"    }while(0)"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-not-reentrant"
block|,
literal|""
block|,
literal|"m4_define( [[M4_YY_INCR_LINENO]],"
block|,
literal|"[[   "
block|,
literal|"    yylineno++;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%# Define these macros to be no-ops."
block|,
literal|"m4_define( [[M4_YY_DECL_GUTS_VAR]], [[m4_dnl]])"
block|,
literal|"m4_define( [[M4_YY_NOOP_GUTS_VAR]], [[m4_dnl]])"
block|,
literal|"m4_define( [[YY_G]], [[($1)]])"
block|,
literal|"m4_define( [[M4_YY_PROTO_LAST_ARG]])"
block|,
literal|"m4_define( [[M4_YY_PROTO_ONLY_ARG]],  [[void]])"
block|,
literal|"m4_define( [[M4_YY_DEF_LAST_ARG]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],"
block|,
literal|"[["
block|,
literal|"    m4_define( [[M4_YY_DEF_ONLY_ARG]])"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"    m4_define( [[M4_YY_DEF_ONLY_ARG]],  [[void]])"
block|,
literal|"]])"
block|,
literal|"m4_define([[M4_YY_DECL_LAST_ARG]])"
block|,
literal|"m4_define([[M4_YY_CALL_LAST_ARG]])"
block|,
literal|"m4_define([[M4_YY_CALL_ONLY_ARG]])"
block|,
literal|"m4_define( [[M4_YY_DOC_PARAM]], [[]])"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],"
block|,
literal|"[["
block|,
literal|"%# For compilers that need traditional function definitions."
block|,
literal|"%# e.g.,"
block|,
literal|"%# The function prototype taking 2 arguments"
block|,
literal|"%#    int foo (int x, char* y)"
block|,
literal|"%#"
block|,
literal|"%# ...should be written as"
block|,
literal|"%#    int foo YYFARGS2(int,x, char*,y)"
block|,
literal|"%#"
block|,
literal|"%# ...which could possibly generate"
block|,
literal|"%#    int foo (x,y,yyscanner)"
block|,
literal|"%#        int x;"
block|,
literal|"%#        char * y;"
block|,
literal|"%#        yyscan_t yyscanner;"
block|,
literal|"%#"
block|,
literal|"%# Generate traditional function defs"
block|,
literal|"    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG) [[\\]]"
block|,
literal|"        M4_YY_DECL_LAST_ARG]])"
block|,
literal|"    m4_define( [[YYFARGS1]], [[($2 M4_YY_DEF_LAST_ARG) [[\\]]"
block|,
literal|"        $1 $2; [[\\]]"
block|,
literal|"        M4_YY_DECL_LAST_ARG]])"
block|,
literal|"    m4_define( [[YYFARGS2]], [[($2,$4 M4_YY_DEF_LAST_ARG) [[\\]]"
block|,
literal|"        $1 $2; [[\\]]"
block|,
literal|"        $3 $4; [[\\]]"
block|,
literal|"        M4_YY_DECL_LAST_ARG]])"
block|,
literal|"    m4_define( [[YYFARGS3]], [[($2,$4,$6 M4_YY_DEF_LAST_ARG) [[\\]]"
block|,
literal|"        $1 $2; [[\\]]"
block|,
literal|"        $3 $4; [[\\]]"
block|,
literal|"        $5 $6; [[\\]]"
block|,
literal|"        M4_YY_DECL_LAST_ARG]])"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"%# Generate C99 function defs."
block|,
literal|"    m4_define( [[YYFARGS0]], [[(M4_YY_DEF_ONLY_ARG)]])"
block|,
literal|"    m4_define( [[YYFARGS1]], [[($1 $2 M4_YY_DEF_LAST_ARG)]])"
block|,
literal|"    m4_define( [[YYFARGS2]], [[($1 $2, $3 $4 M4_YY_DEF_LAST_ARG)]])"
block|,
literal|"    m4_define( [[YYFARGS3]], [[($1 $2, $3 $4, $5 $6 M4_YY_DEF_LAST_ARG)]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Enter a start condition.  This macro really ought to take a parameter,"
block|,
literal|" * but we do it the disgusting crufty way forced on us by the ()-less"
block|,
literal|" * definition of BEGIN."
block|,
literal|" */"
block|,
literal|"#define BEGIN YY_G(yy_start) = 1 + 2 *"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Translate the current start state into a value that can be later handed"
block|,
literal|" * to BEGIN to return to the state.  The YYSTATE alias is for lex"
block|,
literal|" * compatibility."
block|,
literal|" */"
block|,
literal|"#define YY_START ((YY_G(yy_start) - 1) / 2)"
block|,
literal|"#define YYSTATE YY_START"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Action number for EOF rule of a given start state. */"
block|,
literal|"#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Special action meaning \"start processing a new file\". */"
block|,
literal|"#define YY_NEW_FILE yyrestart( yyin M4_YY_CALL_LAST_ARG )"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define YY_END_OF_BUFFER_CHAR 0"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"/* Size of default input buffer. */"
block|,
literal|"#ifndef YY_BUF_SIZE"
block|,
literal|"#define YY_BUF_SIZE 16384"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* The state buf must be large enough to hold one state per character in the main buffer."
block|,
literal|" */"
block|,
literal|"#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"#ifndef YY_TYPEDEF_YY_BUFFER_STATE"
block|,
literal|"#define YY_TYPEDEF_YY_BUFFER_STATE"
block|,
literal|"typedef struct yy_buffer_state *YY_BUFFER_STATE;"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"#ifndef YY_TYPEDEF_YY_SIZE_T"
block|,
literal|"#define YY_TYPEDEF_YY_SIZE_T"
block|,
literal|"typedef size_t yy_size_t;"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%if-not-reentrant"
block|,
literal|"extern yy_size_t yyleng;"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"%if-not-reentrant"
block|,
literal|"extern FILE *yyin, *yyout;"
block|,
literal|"%endif"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define EOB_ACT_CONTINUE_SCAN 0"
block|,
literal|"#define EOB_ACT_END_OF_FILE 1"
block|,
literal|"#define EOB_ACT_LAST_MATCH 2"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_USE_LINENO]],"
block|,
literal|"    [["
block|,
literal|"    /* Note: We specifically omit the test for yy_rule_can_match_eol because it requires"
block|,
literal|"     *       access to the local variable yy_act. Since yyless() is a macro, it would break"
block|,
literal|"     *       existing scanners that call yyless() from OUTSIDE yylex. "
block|,
literal|"     *       One obvious solution it to make yy_act a global. I tried that, and saw"
block|,
literal|"     *       a 5% performance hit in a non-yylineno scanner, because yy_act is"
block|,
literal|"     *       normally declared as a register variable-- so it is not worth it."
block|,
literal|"     */"
block|,
literal|"    #define  YY_LESS_LINENO(n) \\"
block|,
literal|"            do { \\"
block|,
literal|"                int yyl;\\"
block|,
literal|"                for ( yyl = n; yyl< yyleng; ++yyl )\\"
block|,
literal|"                    if ( yytext[yyl] == '\\n' )\\"
block|,
literal|"                        --yylineno;\\"
block|,
literal|"            }while(0)"
block|,
literal|"    ]],"
block|,
literal|"    [["
block|,
literal|"    #define YY_LESS_LINENO(n)"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Return all but the first \"n\" matched characters back to the input stream. */"
block|,
literal|"#define yyless(n) \\"
block|,
literal|"	do \\"
block|,
literal|"		{ \\"
block|,
literal|"		/* Undo effects of setting up yytext. */ \\"
block|,
literal|"        int yyless_macro_arg = (n); \\"
block|,
literal|"        YY_LESS_LINENO(yyless_macro_arg);\\"
block|,
literal|"		*yy_cp = YY_G(yy_hold_char); \\"
block|,
literal|"		YY_RESTORE_YY_MORE_OFFSET \\"
block|,
literal|"		YY_G(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \\"
block|,
literal|"		YY_DO_BEFORE_ACTION; /* set up yytext again */ \\"
block|,
literal|"		} \\"
block|,
literal|"	while ( 0 )"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define unput(c) yyunput( c, YY_G(yytext_ptr) M4_YY_CALL_LAST_ARG )"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"#ifndef YY_STRUCT_YY_BUFFER_STATE"
block|,
literal|"#define YY_STRUCT_YY_BUFFER_STATE"
block|,
literal|"struct yy_buffer_state"
block|,
literal|"	{"
block|,
literal|"%if-c-only"
block|,
literal|"	FILE *yy_input_file;"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-c++-only"
block|,
literal|"	std::istream* yy_input_file;"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"	char *yy_ch_buf;		/* input buffer */"
block|,
literal|"	char *yy_buf_pos;		/* current position in input buffer */"
block|,
literal|""
block|,
literal|"	/* Size of input buffer in bytes, not including room for EOB"
block|,
literal|"	 * characters."
block|,
literal|"	 */"
block|,
literal|"	yy_size_t yy_buf_size;"
block|,
literal|""
block|,
literal|"	/* Number of characters read into yy_ch_buf, not including EOB"
block|,
literal|"	 * characters."
block|,
literal|"	 */"
block|,
literal|"	yy_size_t yy_n_chars;"
block|,
literal|""
block|,
literal|"	/* Whether we \"own\" the buffer - i.e., we know we created it,"
block|,
literal|"	 * and can realloc() it to grow it, and should free() it to"
block|,
literal|"	 * delete it."
block|,
literal|"	 */"
block|,
literal|"	int yy_is_our_buffer;"
block|,
literal|""
block|,
literal|"	/* Whether this is an \"interactive\" input source; if so, and"
block|,
literal|"	 * if we're using stdio for input, then we want to use getc()"
block|,
literal|"	 * instead of fread(), to make sure we stop fetching input after"
block|,
literal|"	 * each newline."
block|,
literal|"	 */"
block|,
literal|"	int yy_is_interactive;"
block|,
literal|""
block|,
literal|"	/* Whether we're considered to be at the beginning of a line."
block|,
literal|"	 * If so, '^' rules will be active on the next match, otherwise"
block|,
literal|"	 * not."
block|,
literal|"	 */"
block|,
literal|"	int yy_at_bol;"
block|,
literal|""
block|,
literal|"    int yy_bs_lineno; /**< The line count. */"
block|,
literal|"    int yy_bs_column; /**< The column count. */"
block|,
literal|"    "
block|,
literal|""
block|,
literal|"	/* Whether to try to fill the input buffer when we reach the"
block|,
literal|"	 * end of it."
block|,
literal|"	 */"
block|,
literal|"	int yy_fill_buffer;"
block|,
literal|""
block|,
literal|"	int yy_buffer_status;"
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define YY_BUFFER_NEW 0"
block|,
literal|"#define YY_BUFFER_NORMAL 1"
block|,
literal|"	/* When an EOF's been seen but there's still some text to process"
block|,
literal|"	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we"
block|,
literal|"	 * shouldn't try reading from the input source any more.  We might"
block|,
literal|"	 * still have a bunch of tokens to match, though, because of"
block|,
literal|"	 * possible backing-up."
block|,
literal|"	 *"
block|,
literal|"	 * When we actually see the EOF, we change the status to \"new\""
block|,
literal|"	 * (via yyrestart()), so that the user can continue scanning by"
block|,
literal|"	 * just pointing yyin at a new input file."
block|,
literal|"	 */"
block|,
literal|"#define YY_BUFFER_EOF_PENDING 2"
block|,
literal|"]])"
block|,
literal|"	};"
block|,
literal|"#endif /* !YY_STRUCT_YY_BUFFER_STATE */"
block|,
literal|""
block|,
literal|"%if-c-only Standard (non-C++) definition"
block|,
literal|"%not-for-header"
block|,
literal|"%if-not-reentrant"
block|,
literal|""
block|,
literal|"/* Stack of input buffers. */"
block|,
literal|"static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */"
block|,
literal|"static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */"
block|,
literal|"static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */"
block|,
literal|"%endif"
block|,
literal|"%ok-for-header"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* We provide macros for accessing buffer states in case in the"
block|,
literal|" * future we want to put the buffer states in a more general"
block|,
literal|" * \"scanner state\"."
block|,
literal|" *"
block|,
literal|" * Returns the top of the stack, or NULL."
block|,
literal|" */"
block|,
literal|"#define YY_CURRENT_BUFFER ( YY_G(yy_buffer_stack) \\"
block|,
literal|"                          ? YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)] \\"
block|,
literal|"                          : NULL)"
block|,
literal|"#define yy_current_buffer YY_CURRENT_BUFFER"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Same as previous macro, but useful when we know that the buffer stack is not"
block|,
literal|" * NULL or when we need an lvalue. For internal use only."
block|,
literal|" */"
block|,
literal|"#define YY_CURRENT_BUFFER_LVALUE YY_G(yy_buffer_stack)[YY_G(yy_buffer_stack_top)]"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%if-c-only Standard (non-C++) definition"
block|,
literal|""
block|,
literal|"%if-not-reentrant"
block|,
literal|"%not-for-header"
block|,
literal|"/* yy_hold_char holds the character lost when yytext is formed. */"
block|,
literal|"static char yy_hold_char;"
block|,
literal|"static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */"
block|,
literal|"yy_size_t yyleng;"
block|,
literal|""
block|,
literal|"/* Points to current character in buffer. */"
block|,
literal|"static char *yy_c_buf_p = (char *) 0;"
block|,
literal|"static int yy_init = 0;		/* whether we need to initialize */"
block|,
literal|"static int yy_start = 0;	/* start state number */"
block|,
literal|""
block|,
literal|"/* Flag which is used to allow yywrap()'s to do buffer switches"
block|,
literal|" * instead of setting up a fresh yyin.  A bit of a hack ..."
block|,
literal|" */"
block|,
literal|"static int yy_did_buffer_switch_on_eof;"
block|,
literal|"%ok-for-header"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"void yyrestart M4_YY_PARAMS( FILE *input_file M4_YY_PROTO_LAST_ARG );"
block|,
literal|"void yy_switch_to_buffer M4_YY_PARAMS( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );"
block|,
literal|"YY_BUFFER_STATE yy_create_buffer M4_YY_PARAMS( FILE *file, int size M4_YY_PROTO_LAST_ARG );"
block|,
literal|"void yy_delete_buffer M4_YY_PARAMS( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );"
block|,
literal|"void yy_flush_buffer M4_YY_PARAMS( YY_BUFFER_STATE b M4_YY_PROTO_LAST_ARG );"
block|,
literal|"void yypush_buffer_state M4_YY_PARAMS( YY_BUFFER_STATE new_buffer M4_YY_PROTO_LAST_ARG );"
block|,
literal|"void yypop_buffer_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"static void yyensure_buffer_stack M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"static void yy_load_buffer_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"static void yy_init_buffer M4_YY_PARAMS( YY_BUFFER_STATE b, FILE *file M4_YY_PROTO_LAST_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG)"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"YY_BUFFER_STATE yy_scan_buffer M4_YY_PARAMS( char *base, yy_size_t size M4_YY_PROTO_LAST_ARG );"
block|,
literal|"YY_BUFFER_STATE yy_scan_string M4_YY_PARAMS( yyconst char *yy_str M4_YY_PROTO_LAST_ARG );"
block|,
literal|"YY_BUFFER_STATE yy_scan_bytes M4_YY_PARAMS( yyconst char *bytes, yy_size_t len M4_YY_PROTO_LAST_ARG );"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"void *yyalloc M4_YY_PARAMS( yy_size_t M4_YY_PROTO_LAST_ARG );"
block|,
literal|"void *yyrealloc M4_YY_PARAMS( void *, yy_size_t M4_YY_PROTO_LAST_ARG );"
block|,
literal|"void yyfree M4_YY_PARAMS( void * M4_YY_PROTO_LAST_ARG );"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define yy_new_buffer yy_create_buffer"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define yy_set_interactive(is_interactive) \\"
block|,
literal|"	{ \\"
block|,
literal|"	if ( ! YY_CURRENT_BUFFER ){ \\"
block|,
literal|"        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \\"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE =    \\"
block|,
literal|"            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \\"
block|,
literal|"	} \\"
block|,
literal|"	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \\"
block|,
literal|"	}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define yy_set_bol(at_bol) \\"
block|,
literal|"	{ \\"
block|,
literal|"	if ( ! YY_CURRENT_BUFFER ){\\"
block|,
literal|"        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG); \\"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE =    \\"
block|,
literal|"            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG); \\"
block|,
literal|"	} \\"
block|,
literal|"	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \\"
block|,
literal|"	}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%% [1.0] yytext/yyin/yyout/yy_state_type/yylineno etc. def's& init go here"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"%% [1.5] DFA"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%if-c-only Standard (non-C++) definition"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"static yy_state_type yy_get_previous_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"static yy_state_type yy_try_NUL_trans M4_YY_PARAMS( yy_state_type current_state  M4_YY_PROTO_LAST_ARG);"
block|,
literal|"static int yy_get_next_buffer M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"static void yy_fatal_error M4_YY_PARAMS( yyconst char msg[] M4_YY_PROTO_LAST_ARG ) __dead2;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Done after the current pattern has been matched and before the"
block|,
literal|" * corresponding action - sets up yytext."
block|,
literal|" */"
block|,
literal|"#define YY_DO_BEFORE_ACTION \\"
block|,
literal|"	YY_G(yytext_ptr) = yy_bp; \\"
block|,
literal|"%% [2.0] code to fiddle yytext and yyleng for yymore() goes here \\"
block|,
literal|"	YY_G(yy_hold_char) = *yy_cp; \\"
block|,
literal|"	*yy_cp = '\\0'; \\"
block|,
literal|"%% [3.0] code to copy yytext_ptr to yytext[] goes here, if %array \\"
block|,
literal|"	YY_G(yy_c_buf_p) = yy_cp;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"%% [4.0] data tables for the DFA and the user's section 1 definitions go here"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_IN_HEADER]], [[#ifdef YY_HEADER_EXPORT_START_CONDITIONS]])"
block|,
literal|"M4_YY_SC_DEFS"
block|,
literal|"m4_ifdef( [[M4_YY_IN_HEADER]], [[#endif]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_UNISTD_H]],,"
block|,
literal|"[["
block|,
literal|"#ifndef YY_NO_UNISTD_H"
block|,
literal|"/* Special case for \"unistd.h\", since it is non-ANSI. We include it way"
block|,
literal|" * down here because we want the user's section 1 to have been scanned first."
block|,
literal|" * The user has a chance to override it with an option."
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"#include<unistd.h>"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"#include<unistd.h>"
block|,
literal|"%endif"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_EXTRA_TYPE_DEFS]],"
block|,
literal|"[["
block|,
literal|"#define YY_EXTRA_TYPE M4_EXTRA_TYPE_DEFS"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"#ifndef YY_EXTRA_TYPE"
block|,
literal|"#define YY_EXTRA_TYPE void *"
block|,
literal|"#endif"
block|,
literal|"]]"
block|,
literal|")"
block|,
literal|""
block|,
literal|"%if-c-only Reentrant structure and macros (non-C++)."
block|,
literal|"%if-reentrant"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Holds the entire state of the reentrant scanner. */"
block|,
literal|"struct yyguts_t"
block|,
literal|"    {"
block|,
literal|""
block|,
literal|"    /* User-defined. Not touched by flex. */"
block|,
literal|"    YY_EXTRA_TYPE yyextra_r;"
block|,
literal|""
block|,
literal|"    /* The rest are the same as the globals declared in the non-reentrant scanner. */"
block|,
literal|"    FILE *yyin_r, *yyout_r;"
block|,
literal|"    size_t yy_buffer_stack_top; /**< index of top of stack. */"
block|,
literal|"    size_t yy_buffer_stack_max; /**< capacity of stack. */"
block|,
literal|"    YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */"
block|,
literal|"    char yy_hold_char;"
block|,
literal|"    yy_size_t yy_n_chars;"
block|,
literal|"    yy_size_t yyleng_r;"
block|,
literal|"    char *yy_c_buf_p;"
block|,
literal|"    int yy_init;"
block|,
literal|"    int yy_start;"
block|,
literal|"    int yy_did_buffer_switch_on_eof;"
block|,
literal|"    int yy_start_stack_ptr;"
block|,
literal|"    int yy_start_stack_depth;"
block|,
literal|"    int *yy_start_stack;"
block|,
literal|"    yy_state_type yy_last_accepting_state;"
block|,
literal|"    char* yy_last_accepting_cpos;"
block|,
literal|""
block|,
literal|"    int yylineno_r;"
block|,
literal|"    int yy_flex_debug_r;"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],"
block|,
literal|"[["
block|,
literal|"    yy_state_type *yy_state_buf;"
block|,
literal|"    yy_state_type *yy_state_ptr;"
block|,
literal|"    char *yy_full_match;"
block|,
literal|"    int yy_lp;"
block|,
literal|""
block|,
literal|"    /* These are only needed for trailing context rules,"
block|,
literal|"     * but there's no conditional variable for that yet. */"
block|,
literal|"    int yy_looking_for_trail_begin;"
block|,
literal|"    int yy_full_lp;"
block|,
literal|"    int *yy_full_state;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],"
block|,
literal|"[["
block|,
literal|"    char yytext_r[YYLMAX];"
block|,
literal|"    char *yytext_ptr;"
block|,
literal|"    int yy_more_offset;"
block|,
literal|"    int yy_prev_more_offset;"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"    char *yytext_r;"
block|,
literal|"    int yy_more_flag;"
block|,
literal|"    int yy_more_len;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_BISON_LVAL]],"
block|,
literal|"[["
block|,
literal|"    YYSTYPE * yylval_r;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"[["
block|,
literal|"    YYLTYPE * yylloc_r;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"    }; /* end struct yyguts_t */"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"static int yy_init_globals M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-reentrant"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_BISON_LVAL]],"
block|,
literal|"    [["
block|,
literal|"    /* This must go here because YYSTYPE and YYLTYPE are included"
block|,
literal|"     * from bison output in section 1.*/"
block|,
literal|"    #    define yylval YY_G(yylval_r)"
block|,
literal|"    ]])"
block|,
literal|""
block|,
literal|"    m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"    [["
block|,
literal|"    #    define yylloc YY_G(yylloc_r)"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"int yylex_init M4_YY_PARAMS(yyscan_t* scanner);"
block|,
literal|""
block|,
literal|"int yylex_init_extra M4_YY_PARAMS( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%endif End reentrant structures and macros."
block|,
literal|""
block|,
literal|"/* Accessor methods to globals."
block|,
literal|"   These are made visible to non-reentrant scanners for convenience. */"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_DESTROY]],,"
block|,
literal|"[["
block|,
literal|"int yylex_destroy M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_DEBUG]],,"
block|,
literal|"[["
block|,
literal|"int yyget_debug M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_DEBUG]],,"
block|,
literal|"[["
block|,
literal|"void yyset_debug M4_YY_PARAMS( int debug_flag M4_YY_PROTO_LAST_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_EXTRA]],,"
block|,
literal|"[["
block|,
literal|"YY_EXTRA_TYPE yyget_extra M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_EXTRA]],,"
block|,
literal|"[["
block|,
literal|"void yyset_extra M4_YY_PARAMS( YY_EXTRA_TYPE user_defined M4_YY_PROTO_LAST_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_IN]],,"
block|,
literal|"[["
block|,
literal|"FILE *yyget_in M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_IN]],,"
block|,
literal|"[["
block|,
literal|"void yyset_in  M4_YY_PARAMS( FILE * in_str M4_YY_PROTO_LAST_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_OUT]],,"
block|,
literal|"[["
block|,
literal|"FILE *yyget_out M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_OUT]],,"
block|,
literal|"[["
block|,
literal|"void yyset_out  M4_YY_PARAMS( FILE * out_str M4_YY_PROTO_LAST_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_LENG]],,"
block|,
literal|"[["
block|,
literal|"yy_size_t yyget_leng M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_TEXT]],,"
block|,
literal|"[["
block|,
literal|"char *yyget_text M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_LINENO]],,"
block|,
literal|"[["
block|,
literal|"int yyget_lineno M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_LINENO]],,"
block|,
literal|"[["
block|,
literal|"void yyset_lineno M4_YY_PARAMS( int line_number M4_YY_PROTO_LAST_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"[["
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_COLUMN]],,"
block|,
literal|"[["
block|,
literal|"int yyget_column  M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"[["
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_COLUMN]],,"
block|,
literal|"[["
block|,
literal|"void yyset_column M4_YY_PARAMS( int column_no M4_YY_PROTO_LAST_ARG );"
block|,
literal|"]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%if-bison-bridge"
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_LVAL]],,"
block|,
literal|"[["
block|,
literal|"YYSTYPE * yyget_lval M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"void yyset_lval M4_YY_PARAMS( YYSTYPE * yylval_param M4_YY_PROTO_LAST_ARG );"
block|,
literal|""
block|,
literal|"m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,"
block|,
literal|"    [["
block|,
literal|"       YYLTYPE *yyget_lloc M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"    ]])"
block|,
literal|""
block|,
literal|"    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,"
block|,
literal|"    [["
block|,
literal|"        void yyset_lloc M4_YY_PARAMS( YYLTYPE * yylloc_param M4_YY_PROTO_LAST_ARG );"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"/* Macros after this point can all be overridden by user definitions in"
block|,
literal|" * section 1."
block|,
literal|" */"
block|,
literal|""
block|,
literal|"#ifndef YY_SKIP_YYWRAP"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"extern \"C\" int yywrap M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"#else"
block|,
literal|"extern int yywrap M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"#endif"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%not-for-header"
block|,
literal|"    m4_ifdef( [[M4_YY_NO_UNPUT]],,"
block|,
literal|"    [["
block|,
literal|"#ifndef YY_NO_UNPUT"
block|,
literal|"    static void yyunput M4_YY_PARAMS( int c, char *buf_ptr  M4_YY_PROTO_LAST_ARG);"
block|,
literal|"#endif"
block|,
literal|"    ]])"
block|,
literal|"%ok-for-header"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"#ifndef yytext_ptr"
block|,
literal|"static void yy_flex_strncpy M4_YY_PARAMS( char *, yyconst char *, int M4_YY_PROTO_LAST_ARG);"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"#ifdef YY_NEED_STRLEN"
block|,
literal|"static int yy_flex_strlen M4_YY_PARAMS( yyconst char * M4_YY_PROTO_LAST_ARG);"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"#ifndef YY_NO_INPUT"
block|,
literal|"%if-c-only Standard (non-C++) definition"
block|,
literal|"%not-for-header"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"static int yyinput M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"#else"
block|,
literal|"static int input M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"#endif"
block|,
literal|"%ok-for-header"
block|,
literal|"%endif"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"%# TODO: This is messy."
block|,
literal|"m4_ifdef( [[M4_YY_STACK_USED]],"
block|,
literal|"[["
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_REENTRANT]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"    [["
block|,
literal|"        static int yy_start_stack_ptr = 0;"
block|,
literal|"        static int yy_start_stack_depth = 0;"
block|,
literal|"        static int *yy_start_stack = NULL;"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,"
block|,
literal|"    [["
block|,
literal|"    static void yy_push_state M4_YY_PARAMS( int new_state M4_YY_PROTO_LAST_ARG);"
block|,
literal|"    ]])"
block|,
literal|"    m4_ifdef( [[M4_YY_NO_POP_STATE]],,"
block|,
literal|"    [["
block|,
literal|"    static void yy_pop_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"    ]])"
block|,
literal|"    m4_ifdef( [[M4_YY_NO_TOP_STATE]],,"
block|,
literal|"    [["
block|,
literal|"    static int yy_top_state M4_YY_PARAMS( M4_YY_PROTO_ONLY_ARG );"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"m4_define( [[M4_YY_NO_PUSH_STATE]])"
block|,
literal|"m4_define( [[M4_YY_NO_POP_STATE]])"
block|,
literal|"m4_define( [[M4_YY_NO_TOP_STATE]])"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"/* Amount of stuff to slurp up with each read. */"
block|,
literal|"#ifndef YY_READ_BUF_SIZE"
block|,
literal|"#define YY_READ_BUF_SIZE 8192"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Copy whatever the last rule matched to the standard output. */"
block|,
literal|"#ifndef ECHO"
block|,
literal|"%if-c-only Standard (non-C++) definition"
block|,
literal|"/* This used to be an fputs(), but since the string might contain NUL's,"
block|,
literal|" * we now use fwrite()."
block|,
literal|" */"
block|,
literal|"#define ECHO do { if (fwrite( yytext, yyleng, 1, yyout )) {} } while (0)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only C++ definition"
block|,
literal|"#define ECHO LexerOutput( yytext, yyleng )"
block|,
literal|"%endif"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Gets input and stuffs it into \"buf\".  number of characters read, or YY_NULL,"
block|,
literal|" * is returned in \"result\"."
block|,
literal|" */"
block|,
literal|"#ifndef YY_INPUT"
block|,
literal|"#define YY_INPUT(buf,result,max_size) \\"
block|,
literal|"%% [5.0] fread()/read() definition of YY_INPUT goes here unless we're doing C++ \\"
block|,
literal|"\\"
block|,
literal|"%if-c++-only C++ definition \\"
block|,
literal|"	if ( (result = LexerInput( (char *) buf, max_size ))< 0 ) \\"
block|,
literal|"		YY_FATAL_ERROR( \"input in flex scanner failed\" );"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* No semi-colon after return; correct usage is to write \"yyterminate();\" -"
block|,
literal|" * we don't want an extra ';' after the \"return\" because that will cause"
block|,
literal|" * some compilers to complain about unreachable statements."
block|,
literal|" */"
block|,
literal|"#ifndef yyterminate"
block|,
literal|"#define yyterminate() return YY_NULL"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"/* Number of entries by which start-condition stack grows. */"
block|,
literal|"#ifndef YY_START_STACK_INCR"
block|,
literal|"#define YY_START_STACK_INCR 25"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Report a fatal error. */"
block|,
literal|"#ifndef YY_FATAL_ERROR"
block|,
literal|"%if-c-only"
block|,
literal|"#define YY_FATAL_ERROR(msg) yy_fatal_error( msg M4_YY_CALL_LAST_ARG)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"#define YY_FATAL_ERROR(msg) LexerError( msg )"
block|,
literal|"%endif"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%if-tables-serialization structures and prototypes"
block|,
literal|"#ifdef FLEX_SCANNER"
block|,
literal|"/*"
block|,
literal|"dnl  tables_shared.h - tables serialization header"
block|,
literal|"dnl"
block|,
literal|"dnl  Copyright (c) 1990 The Regents of the University of California."
block|,
literal|"dnl  All rights reserved."
block|,
literal|"dnl"
block|,
literal|"dnl  This code is derived from software contributed to Berkeley by"
block|,
literal|"dnl  Vern Paxson."
block|,
literal|"dnl"
block|,
literal|"dnl  The United States Government has rights in this work pursuant"
block|,
literal|"dnl  to contract no. DE-AC03-76SF00098 between the United States"
block|,
literal|"dnl  Department of Energy and the University of California."
block|,
literal|"dnl"
block|,
literal|"dnl  This file is part of flex."
block|,
literal|"dnl"
block|,
literal|"dnl  Redistribution and use in source and binary forms, with or without"
block|,
literal|"dnl  modification, are permitted provided that the following conditions"
block|,
literal|"dnl  are met:"
block|,
literal|"dnl"
block|,
literal|"dnl  1. Redistributions of source code must retain the above copyright"
block|,
literal|"dnl     notice, this list of conditions and the following disclaimer."
block|,
literal|"dnl  2. Redistributions in binary form must reproduce the above copyright"
block|,
literal|"dnl     notice, this list of conditions and the following disclaimer in the"
block|,
literal|"dnl     documentation and/or other materials provided with the distribution."
block|,
literal|"dnl"
block|,
literal|"dnl  Neither the name of the University nor the names of its contributors"
block|,
literal|"dnl  may be used to endorse or promote products derived from this software"
block|,
literal|"dnl  without specific prior written permission."
block|,
literal|"dnl"
block|,
literal|"dnl  THIS SOFTWARE IS PROVIDED `AS IS' AND WITHOUT ANY EXPRESS OR"
block|,
literal|"dnl  IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED"
block|,
literal|"dnl  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"
block|,
literal|"dnl  PURPOSE."
block|,
literal|"
literal|"
block|,
literal|"dnl"
block|,
literal|"dnl  This file is meant to be included in both the skeleton and the actual"
block|,
literal|"dnl  flex code (hence the name \"_shared\")."
block|,
literal|"*/"
block|,
literal|"#ifndef yyskel_static"
block|,
literal|"#define yyskel_static static"
block|,
literal|"#endif"
block|,
literal|"#else"
block|,
literal|"#ifndef yyskel_static"
block|,
literal|"#define yyskel_static"
block|,
literal|"#endif"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* Structures and prototypes for serializing flex tables.  The"
block|,
literal|" * binary format is documented in the manual."
block|,
literal|" *"
block|,
literal|" * Design considerations:"
block|,
literal|" *"
block|,
literal|" *  -  The format allows many tables per file."
block|,
literal|" *  -  The tables can be streamed."
block|,
literal|" *  -  All data is stored in network byte order."
block|,
literal|" *  -  We do not hinder future unicode support."
block|,
literal|" *  -  We can lookup tables by name."
block|,
literal|" */"
block|,
literal|""
block|,
literal|"/** Magic number for serialized format. */"
block|,
literal|"#ifndef YYTBL_MAGIC"
block|,
literal|"#define YYTBL_MAGIC 0xF13C57B1"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/** Calculate (0-7) = number bytes needed to pad n to next 64-bit boundary. */"
block|,
literal|"#ifndef yypad64"
block|,
literal|"#define yypad64(n) ((8-((n)%8))%8)"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"#ifndef YYTABLES_TYPES"
block|,
literal|"#define YYTABLES_TYPES"
block|,
literal|"/** Possible values for td_id field. Each one corresponds to a"
block|,
literal|" *  scanner table of the same name."
block|,
literal|" */"
block|,
literal|"enum yytbl_id {"
block|,
literal|"	YYTD_ID_ACCEPT = 0x01,		/**< 1-dim ints */"
block|,
literal|"	YYTD_ID_BASE = 0x02,		/**< 1-dim ints */"
block|,
literal|"	YYTD_ID_CHK = 0x03,		/**< 1-dim ints */"
block|,
literal|"	YYTD_ID_DEF = 0x04,		/**< 1-dim ints */"
block|,
literal|"	YYTD_ID_EC = 0x05,		/**< 1-dim ints */"
block|,
literal|"	YYTD_ID_META = 0x06,		/**< 1-dim ints */"
block|,
literal|"	YYTD_ID_NUL_TRANS = 0x07,	/**< 1-dim ints, maybe indices */"
block|,
literal|"	YYTD_ID_NXT = 0x08,		/**< may be 2 dimensional ints */"
block|,
literal|"	YYTD_ID_RULE_CAN_MATCH_EOL = 0x09, /**< 1-dim ints */"
block|,
literal|"	YYTD_ID_START_STATE_LIST = 0x0A,	/**< 1-dim indices into trans tbl  */"
block|,
literal|"	YYTD_ID_TRANSITION = 0x0B,	/**< structs */"
block|,
literal|"	YYTD_ID_ACCLIST = 0x0C		/**< 1-dim ints */"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"/** bit flags for t_flags field of struct yytbl_data */"
block|,
literal|"enum yytbl_flags {"
block|,
literal|"	/* These first three are mutually exclusive */"
block|,
literal|"	YYTD_DATA8 = 0x01,   /**< data is an array of type flex_int8_t */"
block|,
literal|"	YYTD_DATA16 = 0x02,  /**< data is an array of type flex_int16_t */"
block|,
literal|"	YYTD_DATA32 = 0x04,  /**< data is an array of type flex_int32_t */"
block|,
literal|""
block|,
literal|"	/* These two are mutually exclusive. */"
block|,
literal|"	YYTD_PTRANS = 0x08,  /**< data is a list of indexes of entries"
block|,
literal|"                                 into the expanded yy_transition"
block|,
literal|"                                 array. See notes in manual. */"
block|,
literal|"	YYTD_STRUCT = 0x10  /**< data consists of yy_trans_info structs */"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"/* The serialized tables header. */"
block|,
literal|"struct yytbl_hdr {"
block|,
literal|"	flex_uint32_t th_magic;  /**< Must be 0xF13C57B1 (comes from \"Flex Table\") */"
block|,
literal|"	flex_uint32_t th_hsize;  /**< Size of this header in bytes. */"
block|,
literal|"	flex_uint32_t th_ssize;  /**< Size of this dataset, in bytes, including header. */"
block|,
literal|"	flex_uint16_t th_flags;  /**< Currently unused, must be 0 */"
block|,
literal|"	char   *th_version; /**< Flex version string. NUL terminated. */"
block|,
literal|"	char   *th_name;    /**< The name of this table set. NUL terminated. */"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"/** A single serialized table */"
block|,
literal|"struct yytbl_data {"
block|,
literal|"	flex_uint16_t td_id;      /**< enum yytbl_id table identifier */"
block|,
literal|"	flex_uint16_t td_flags;   /**< how to interpret this data */"
block|,
literal|"	flex_uint32_t td_hilen;   /**< num elements in highest dimension array */"
block|,
literal|"	flex_uint32_t td_lolen;   /**< num elements in lowest dimension array */"
block|,
literal|"	void   *td_data;     /**< table data */"
block|,
literal|"};"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/** Extract corresponding data size_t from td_flags */"
block|,
literal|"#ifndef YYTDFLAGS2BYTES"
block|,
literal|"#define YYTDFLAGS2BYTES(td_flags)\\"
block|,
literal|"        (((td_flags)& YYTD_DATA8)\\"
block|,
literal|"            ? sizeof(flex_int8_t)\\"
block|,
literal|"            :(((td_flags)& YYTD_DATA16)\\"
block|,
literal|"                ? sizeof(flex_int16_t)\\"
block|,
literal|"                :sizeof(flex_int32_t)))"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"#ifdef FLEX_SCANNER"
block|,
literal|"%not-for-header"
block|,
literal|"#endif"
block|,
literal|"yyskel_static flex_int32_t yytbl_calc_total_len (const struct yytbl_data *tbl);"
block|,
literal|"#ifdef FLEX_SCANNER"
block|,
literal|"%ok-for-header"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"/* vim:set noexpandtab cindent tabstop=8 softtabstop=0 shiftwidth=8 textwidth=0: */"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* Load the DFA tables from the given stream.  */"
block|,
literal|"int yytables_fload M4_YY_PARAMS(FILE * fp M4_YY_PROTO_LAST_ARG);"
block|,
literal|""
block|,
literal|"/* Unload the tables from memory. */"
block|,
literal|"int yytables_destroy M4_YY_PARAMS(M4_YY_PROTO_ONLY_ARG);"
block|,
literal|"%not-for-header"
block|,
literal|""
block|,
literal|"/** Describes a mapping from a serialized table id to its deserialized state in"
block|,
literal|" * this scanner.  This is the bridge between our \"generic\" deserialization code"
block|,
literal|" * and the specifics of this scanner. "
block|,
literal|" */"
block|,
literal|"struct yytbl_dmap {"
block|,
literal|"	enum yytbl_id dm_id;/**< table identifier */"
block|,
literal|"	void  **dm_arr;		/**< address of pointer to store the deserialized table. */"
block|,
literal|"	size_t  dm_sz;		/**< local sizeof() each element in table. */"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"/** A {0,0,0}-terminated list of structs, forming the map */"
block|,
literal|"static struct yytbl_dmap yydmap[] ="
block|,
literal|"{"
block|,
literal|"%tables-yydmap generated elements"
block|,
literal|"    {0,0,0}"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"/** A tables-reader object to maintain some state in the read. */"
block|,
literal|"struct yytbl_reader {"
block|,
literal|"    FILE * fp; /**< input stream */"
block|,
literal|"    flex_uint32_t bread; /**< bytes read since beginning of current tableset */"
block|,
literal|"};"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|"/* end tables serialization structures and prototypes */"
block|,
literal|""
block|,
literal|"%ok-for-header"
block|,
literal|""
block|,
literal|"/* Default declaration of generated scanner - a define so the user can"
block|,
literal|" * easily add parameters."
block|,
literal|" */"
block|,
literal|"#ifndef YY_DECL"
block|,
literal|"#define YY_DECL_IS_OURS 1"
block|,
literal|"%if-c-only Standard (non-C++) definition"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_define( [[M4_YY_LEX_PROTO]], [[M4_YY_PARAMS(M4_YY_PROTO_ONLY_ARG)]])"
block|,
literal|"m4_define( [[M4_YY_LEX_DECLARATION]], [[YYFARGS0(void)]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_BISON_LVAL]],"
block|,
literal|"[["
block|,
literal|"    m4_dnl  The bison pure parser is used. Redefine yylex to"
block|,
literal|"    m4_dnl  accept the lval parameter."
block|,
literal|""
block|,
literal|"    m4_define( [[M4_YY_LEX_PROTO]], [[\\]]"
block|,
literal|"               [[M4_YY_PARAMS(YYSTYPE * yylval_param M4_YY_PROTO_LAST_ARG)]])"
block|,
literal|"    m4_define( [[M4_YY_LEX_DECLARATION]], [[\\]]"
block|,
literal|"               [[YYFARGS1(YYSTYPE *,yylval_param)]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"[["
block|,
literal|"    m4_dnl  Locations are used. yylex should also accept the ylloc parameter."
block|,
literal|""
block|,
literal|"    m4_define( [[M4_YY_LEX_PROTO]], [[\\]]"
block|,
literal|"               [[M4_YY_PARAMS(YYSTYPE * yylval_param, YYLTYPE * yylloc_param M4_YY_PROTO_LAST_ARG)]])"
block|,
literal|"    m4_define( [[M4_YY_LEX_DECLARATION]], [[\\]]"
block|,
literal|"               [[YYFARGS2(YYSTYPE *,yylval_param, YYLTYPE *,yylloc_param)]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"extern int yylex M4_YY_LEX_PROTO;"
block|,
literal|""
block|,
literal|"#define YY_DECL int yylex M4_YY_LEX_DECLARATION"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only C++ definition"
block|,
literal|"#define YY_DECL int yyFlexLexer::yylex()"
block|,
literal|"%endif"
block|,
literal|"#endif /* !YY_DECL */"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Code executed at the beginning of each rule, after yytext and yyleng"
block|,
literal|" * have been set up."
block|,
literal|" */"
block|,
literal|"#ifndef YY_USER_ACTION"
block|,
literal|"#define YY_USER_ACTION"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* Code executed at the end of each rule. */"
block|,
literal|"#ifndef YY_BREAK"
block|,
literal|"#define YY_BREAK break;"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"%% [6.0] YY_RULE_SETUP definition goes here"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%not-for-header"
block|,
literal|"/** The main scanner function which does all the work."
block|,
literal|" */"
block|,
literal|"YY_DECL"
block|,
literal|"{"
block|,
literal|"	yy_state_type yy_current_state;"
block|,
literal|"	char *yy_cp, *yy_bp;"
block|,
literal|"	int yy_act;"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_REENTRANT]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_BISON_LVAL]],"
block|,
literal|"    [["
block|,
literal|"        YYSTYPE * yylval;"
block|,
literal|"    ]])"
block|,
literal|"    m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"    [["
block|,
literal|"        YYLTYPE * yylloc;"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%% [7.0] user's declarations go here"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_BISON_LVAL]],"
block|,
literal|"[["
block|,
literal|"    yylval = yylval_param;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"[["
block|,
literal|"    yylloc = yylloc_param;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"	if ( !YY_G(yy_init) )"
block|,
literal|"		{"
block|,
literal|"		YY_G(yy_init) = 1;"
block|,
literal|""
block|,
literal|"#ifdef YY_USER_INIT"
block|,
literal|"		YY_USER_INIT;"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],"
block|,
literal|"[["
block|,
literal|"        /* Create the reject buffer large enough to save one state per allowed character. */"
block|,
literal|"        if ( ! YY_G(yy_state_buf) )"
block|,
literal|"            YY_G(yy_state_buf) = (yy_state_type *)yyalloc(YY_STATE_BUF_SIZE  M4_YY_CALL_LAST_ARG);"
block|,
literal|"            if ( ! YY_G(yy_state_buf) )"
block|,
literal|"                YY_FATAL_ERROR( \"out of dynamic memory in yylex()\" );"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"		if ( ! YY_G(yy_start) )"
block|,
literal|"			YY_G(yy_start) = 1;	/* first start state */"
block|,
literal|""
block|,
literal|"		if ( ! yyin )"
block|,
literal|"%if-c-only"
block|,
literal|"			yyin = stdin;"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"			yyin =& std::cin;"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"		if ( ! yyout )"
block|,
literal|"%if-c-only"
block|,
literal|"			yyout = stdout;"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"			yyout =& std::cout;"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"		if ( ! YY_CURRENT_BUFFER ) {"
block|,
literal|"			yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);"
block|,
literal|"			YY_CURRENT_BUFFER_LVALUE ="
block|,
literal|"				yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"		yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	while ( 1 )		/* loops until end-of-file is reached */"
block|,
literal|"		{"
block|,
literal|"%% [8.0] yymore()-related code goes here"
block|,
literal|"		yy_cp = YY_G(yy_c_buf_p);"
block|,
literal|""
block|,
literal|"		/* Support of yytext. */"
block|,
literal|"		*yy_cp = YY_G(yy_hold_char);"
block|,
literal|""
block|,
literal|"		/* yy_bp points to the position in yy_ch_buf of the start of"
block|,
literal|"		 * the current run."
block|,
literal|"		 */"
block|,
literal|"		yy_bp = yy_cp;"
block|,
literal|""
block|,
literal|"%% [9.0] code to set up and find next match goes here"
block|,
literal|""
block|,
literal|"yy_find_action:"
block|,
literal|"%% [10.0] code to find the action number goes here"
block|,
literal|""
block|,
literal|"		YY_DO_BEFORE_ACTION;"
block|,
literal|""
block|,
literal|"%% [11.0] code for yylineno update goes here"
block|,
literal|""
block|,
literal|"do_action:	/* This label is used only to access EOF actions. */"
block|,
literal|""
block|,
literal|"%% [12.0] debug code goes here"
block|,
literal|""
block|,
literal|"		switch ( yy_act )"
block|,
literal|"	{ /* beginning of action switch */"
block|,
literal|"%% [13.0] actions go here"
block|,
literal|""
block|,
literal|"	case YY_END_OF_BUFFER:"
block|,
literal|"		{"
block|,
literal|"		/* Amount of text matched not including the EOB char. */"
block|,
literal|"		int yy_amount_of_matched_text = (int) (yy_cp - YY_G(yytext_ptr)) - 1;"
block|,
literal|""
block|,
literal|"		/* Undo the effects of YY_DO_BEFORE_ACTION. */"
block|,
literal|"		*yy_cp = YY_G(yy_hold_char);"
block|,
literal|"		YY_RESTORE_YY_MORE_OFFSET"
block|,
literal|""
block|,
literal|"		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )"
block|,
literal|"			{"
block|,
literal|"			/* We're scanning a new file or input source.  It's"
block|,
literal|"			 * possible that this happened because the user"
block|,
literal|"			 * just pointed yyin at a new source and called"
block|,
literal|"			 * yylex().  If so, then we have to assure"
block|,
literal|"			 * consistency between YY_CURRENT_BUFFER and our"
block|,
literal|"			 * globals.  Here is the right place to do so, because"
block|,
literal|"			 * this is the first action (other than possibly a"
block|,
literal|"			 * back-up) that will match for the new input source."
block|,
literal|"			 */"
block|,
literal|"			YY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"
block|,
literal|"			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;"
block|,
literal|"			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		/* Note that here we test for yy_c_buf_p \"<=\" to the position"
block|,
literal|"		 * of the first EOB in the buffer, since yy_c_buf_p will"
block|,
literal|"		 * already have been incremented past the NUL character"
block|,
literal|"		 * (since all states make transitions on EOB to the"
block|,
literal|"		 * end-of-buffer state).  Contrast this with the test"
block|,
literal|"		 * in input()."
block|,
literal|"		 */"
block|,
literal|"		if ( YY_G(yy_c_buf_p)<=&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] )"
block|,
literal|"			{ /* This was really a NUL. */"
block|,
literal|"			yy_state_type yy_next_state;"
block|,
literal|""
block|,
literal|"			YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + yy_amount_of_matched_text;"
block|,
literal|""
block|,
literal|"			yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|""
block|,
literal|"			/* Okay, we're now positioned to make the NUL"
block|,
literal|"			 * transition.  We couldn't have"
block|,
literal|"			 * yy_get_previous_state() go ahead and do it"
block|,
literal|"			 * for us because it doesn't know how to deal"
block|,
literal|"			 * with the possibility of jamming (and we don't"
block|,
literal|"			 * want to build jamming into it because then it"
block|,
literal|"			 * will run more slowly)."
block|,
literal|"			 */"
block|,
literal|""
block|,
literal|"			yy_next_state = yy_try_NUL_trans( yy_current_state M4_YY_CALL_LAST_ARG);"
block|,
literal|""
block|,
literal|"			yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;"
block|,
literal|""
block|,
literal|"			if ( yy_next_state )"
block|,
literal|"				{"
block|,
literal|"				/* Consume the NUL. */"
block|,
literal|"				yy_cp = ++YY_G(yy_c_buf_p);"
block|,
literal|"				yy_current_state = yy_next_state;"
block|,
literal|"				goto yy_match;"
block|,
literal|"				}"
block|,
literal|""
block|,
literal|"			else"
block|,
literal|"				{"
block|,
literal|"%% [14.0] code to do back-up for compressed tables and set up yy_cp goes here"
block|,
literal|"				goto yy_find_action;"
block|,
literal|"				}"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		else switch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) )"
block|,
literal|"			{"
block|,
literal|"			case EOB_ACT_END_OF_FILE:"
block|,
literal|"				{"
block|,
literal|"				YY_G(yy_did_buffer_switch_on_eof) = 0;"
block|,
literal|""
block|,
literal|"				if ( yywrap( M4_YY_CALL_ONLY_ARG ) )"
block|,
literal|"					{"
block|,
literal|"					/* Note: because we've taken care in"
block|,
literal|"					 * yy_get_next_buffer() to have set up"
block|,
literal|"					 * yytext, we can now set up"
block|,
literal|"					 * yy_c_buf_p so that if some total"
block|,
literal|"					 * hoser (like flex itself) wants to"
block|,
literal|"					 * call the scanner after we return the"
block|,
literal|"					 * YY_NULL, it'll still work - another"
block|,
literal|"					 * YY_NULL will get returned."
block|,
literal|"					 */"
block|,
literal|"					YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + YY_MORE_ADJ;"
block|,
literal|""
block|,
literal|"					yy_act = YY_STATE_EOF(YY_START);"
block|,
literal|"					goto do_action;"
block|,
literal|"					}"
block|,
literal|""
block|,
literal|"				else"
block|,
literal|"					{"
block|,
literal|"					if ( ! YY_G(yy_did_buffer_switch_on_eof) )"
block|,
literal|"						YY_NEW_FILE;"
block|,
literal|"					}"
block|,
literal|"				break;"
block|,
literal|"				}"
block|,
literal|""
block|,
literal|"			case EOB_ACT_CONTINUE_SCAN:"
block|,
literal|"				YY_G(yy_c_buf_p) ="
block|,
literal|"					YY_G(yytext_ptr) + yy_amount_of_matched_text;"
block|,
literal|""
block|,
literal|"				yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|""
block|,
literal|"				yy_cp = YY_G(yy_c_buf_p);"
block|,
literal|"				yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;"
block|,
literal|"				goto yy_match;"
block|,
literal|""
block|,
literal|"			case EOB_ACT_LAST_MATCH:"
block|,
literal|"				YY_G(yy_c_buf_p) ="
block|,
literal|"&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)];"
block|,
literal|""
block|,
literal|"				yy_current_state = yy_get_previous_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|""
block|,
literal|"				yy_cp = YY_G(yy_c_buf_p);"
block|,
literal|"				yy_bp = YY_G(yytext_ptr) + YY_MORE_ADJ;"
block|,
literal|"				goto yy_find_action;"
block|,
literal|"			}"
block|,
literal|"		break;"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	default:"
block|,
literal|"		YY_FATAL_ERROR("
block|,
literal|"			\"fatal flex scanner internal error--no action found\" );"
block|,
literal|"	} /* end of action switch */"
block|,
literal|"		} /* end of scanning one token */"
block|,
literal|"} /* end of yylex */"
block|,
literal|"%ok-for-header"
block|,
literal|""
block|,
literal|"%if-c++-only"
block|,
literal|"%not-for-header"
block|,
literal|"/* The contents of this function are C++ specific, so the YY_G macro is not used."
block|,
literal|" */"
block|,
literal|"yyFlexLexer::yyFlexLexer( std::istream* arg_yyin, std::ostream* arg_yyout )"
block|,
literal|"{"
block|,
literal|"	yyin = arg_yyin;"
block|,
literal|"	yyout = arg_yyout;"
block|,
literal|"	yy_c_buf_p = 0;"
block|,
literal|"	yy_init = 0;"
block|,
literal|"	yy_start = 0;"
block|,
literal|"	yy_flex_debug = 0;"
block|,
literal|"	yylineno = 1;	// this will only get updated if %option yylineno"
block|,
literal|""
block|,
literal|"	yy_did_buffer_switch_on_eof = 0;"
block|,
literal|""
block|,
literal|"	yy_looking_for_trail_begin = 0;"
block|,
literal|"	yy_more_flag = 0;"
block|,
literal|"	yy_more_len = 0;"
block|,
literal|"	yy_more_offset = yy_prev_more_offset = 0;"
block|,
literal|""
block|,
literal|"	yy_start_stack_ptr = yy_start_stack_depth = 0;"
block|,
literal|"	yy_start_stack = NULL;"
block|,
literal|""
block|,
literal|"	yy_buffer_stack = 0;"
block|,
literal|"	yy_buffer_stack_top = 0;"
block|,
literal|"	yy_buffer_stack_max = 0;"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],"
block|,
literal|"[["
block|,
literal|"	yy_state_buf = new yy_state_type[YY_STATE_BUF_SIZE];"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"	yy_state_buf = 0;"
block|,
literal|"]])"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/* The contents of this function are C++ specific, so the YY_G macro is not used."
block|,
literal|" */"
block|,
literal|"yyFlexLexer::~yyFlexLexer()"
block|,
literal|"{"
block|,
literal|"	delete [] yy_state_buf;"
block|,
literal|"	yyfree( yy_start_stack M4_YY_CALL_LAST_ARG );"
block|,
literal|"	yy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);"
block|,
literal|"	yyfree( yy_buffer_stack M4_YY_CALL_LAST_ARG );"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/* The contents of this function are C++ specific, so the YY_G macro is not used."
block|,
literal|" */"
block|,
literal|"void yyFlexLexer::switch_streams( std::istream* new_in, std::ostream* new_out )"
block|,
literal|"{"
block|,
literal|"	if ( new_in )"
block|,
literal|"		{"
block|,
literal|"		yy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);"
block|,
literal|"		yy_switch_to_buffer( yy_create_buffer( new_in, YY_BUF_SIZE  M4_YY_CALL_LAST_ARG) M4_YY_CALL_LAST_ARG);"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	if ( new_out )"
block|,
literal|"		yyout = new_out;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"#ifdef YY_INTERACTIVE"
block|,
literal|"int yyFlexLexer::LexerInput( char* buf, int /* max_size */ )"
block|,
literal|"#else"
block|,
literal|"int yyFlexLexer::LexerInput( char* buf, int max_size )"
block|,
literal|"#endif"
block|,
literal|"{"
block|,
literal|"	if ( yyin->eof() || yyin->fail() )"
block|,
literal|"		return 0;"
block|,
literal|""
block|,
literal|"#ifdef YY_INTERACTIVE"
block|,
literal|"	yyin->get( buf[0] );"
block|,
literal|""
block|,
literal|"	if ( yyin->eof() )"
block|,
literal|"		return 0;"
block|,
literal|""
block|,
literal|"	if ( yyin->bad() )"
block|,
literal|"		return -1;"
block|,
literal|""
block|,
literal|"	return 1;"
block|,
literal|""
block|,
literal|"#else"
block|,
literal|"	(void) yyin->read( buf, max_size );"
block|,
literal|""
block|,
literal|"	if ( yyin->bad() )"
block|,
literal|"		return -1;"
block|,
literal|"	else"
block|,
literal|"		return yyin->gcount();"
block|,
literal|"#endif"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"void yyFlexLexer::LexerOutput( const char* buf, int size )"
block|,
literal|"{"
block|,
literal|"	(void) yyout->write( buf, size );"
block|,
literal|"}"
block|,
literal|"%ok-for-header"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/* yy_get_next_buffer - try to read in a new buffer"
block|,
literal|" *"
block|,
literal|" * Returns a code representing an action:"
block|,
literal|" *	EOB_ACT_LAST_MATCH -"
block|,
literal|" *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position"
block|,
literal|" *	EOB_ACT_END_OF_FILE - end of file"
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"static int yy_get_next_buffer YYFARGS0(void)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"int yyFlexLexer::yy_get_next_buffer()"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;"
block|,
literal|"	char *source = YY_G(yytext_ptr);"
block|,
literal|"	int number_to_move, i;"
block|,
literal|"	int ret_val;"
block|,
literal|""
block|,
literal|"	if ( YY_G(yy_c_buf_p)>&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars) + 1] )"
block|,
literal|"		YY_FATAL_ERROR("
block|,
literal|"		\"fatal flex scanner internal error--end of buffer missed\" );"
block|,
literal|""
block|,
literal|"	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )"
block|,
literal|"		{ /* Don't try to fill the buffer, so this is an EOF. */"
block|,
literal|"		if ( YY_G(yy_c_buf_p) - YY_G(yytext_ptr) - YY_MORE_ADJ == 1 )"
block|,
literal|"			{"
block|,
literal|"			/* We matched a single character, the EOB, so"
block|,
literal|"			 * treat this as a final EOF."
block|,
literal|"			 */"
block|,
literal|"			return EOB_ACT_END_OF_FILE;"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			{"
block|,
literal|"			/* We matched some text prior to the EOB, first"
block|,
literal|"			 * process it."
block|,
literal|"			 */"
block|,
literal|"			return EOB_ACT_LAST_MATCH;"
block|,
literal|"			}"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	/* Try to read more data. */"
block|,
literal|""
block|,
literal|"	/* First move last chars to start of buffer. */"
block|,
literal|"	number_to_move = (int) (YY_G(yy_c_buf_p) - YY_G(yytext_ptr)) - 1;"
block|,
literal|""
block|,
literal|"	for ( i = 0; i< number_to_move; ++i )"
block|,
literal|"		*(dest++) = *(source++);"
block|,
literal|""
block|,
literal|"	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )"
block|,
literal|"		/* don't do the read, it's not guaranteed to return an EOF,"
block|,
literal|"		 * just force an EOF"
block|,
literal|"		 */"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars) = 0;"
block|,
literal|""
block|,
literal|"	else"
block|,
literal|"		{"
block|,
literal|"			yy_size_t num_to_read ="
block|,
literal|"			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;"
block|,
literal|""
block|,
literal|"		while ( num_to_read<= 0 )"
block|,
literal|"			{ /* Not enough room in the buffer - grow it. */"
block|,
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],"
block|,
literal|"[["
block|,
literal|"			YY_FATAL_ERROR("
block|,
literal|"\"input buffer overflow, can't enlarge buffer because scanner uses REJECT\" );"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"			/* just a shorter name for the current buffer */"
block|,
literal|"			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;"
block|,
literal|""
block|,
literal|"			int yy_c_buf_p_offset ="
block|,
literal|"				(int) (YY_G(yy_c_buf_p) - b->yy_ch_buf);"
block|,
literal|""
block|,
literal|"			if ( b->yy_is_our_buffer )"
block|,
literal|"				{"
block|,
literal|"				yy_size_t new_size = b->yy_buf_size * 2;"
block|,
literal|""
block|,
literal|"				if ( new_size<= 0 )"
block|,
literal|"					b->yy_buf_size += b->yy_buf_size / 8;"
block|,
literal|"				else"
block|,
literal|"					b->yy_buf_size *= 2;"
block|,
literal|""
block|,
literal|"				b->yy_ch_buf = (char *)"
block|,
literal|"					/* Include room in for 2 EOB chars. */"
block|,
literal|"					yyrealloc( (void *) b->yy_ch_buf,"
block|,
literal|"							 b->yy_buf_size + 2 M4_YY_CALL_LAST_ARG );"
block|,
literal|"				}"
block|,
literal|"			else"
block|,
literal|"				/* Can't grow it, we don't own it. */"
block|,
literal|"				b->yy_ch_buf = 0;"
block|,
literal|""
block|,
literal|"			if ( ! b->yy_ch_buf )"
block|,
literal|"				YY_FATAL_ERROR("
block|,
literal|"				\"fatal error - scanner input buffer overflow\" );"
block|,
literal|""
block|,
literal|"			YY_G(yy_c_buf_p) =&b->yy_ch_buf[yy_c_buf_p_offset];"
block|,
literal|""
block|,
literal|"			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -"
block|,
literal|"						number_to_move - 1;"
block|,
literal|"]])"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		if ( num_to_read> YY_READ_BUF_SIZE )"
block|,
literal|"			num_to_read = YY_READ_BUF_SIZE;"
block|,
literal|""
block|,
literal|"		/* Read in more data. */"
block|,
literal|"		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),"
block|,
literal|"			YY_G(yy_n_chars), num_to_read );"
block|,
literal|""
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	if ( YY_G(yy_n_chars) == 0 )"
block|,
literal|"		{"
block|,
literal|"		if ( number_to_move == YY_MORE_ADJ )"
block|,
literal|"			{"
block|,
literal|"			ret_val = EOB_ACT_END_OF_FILE;"
block|,
literal|"			yyrestart( yyin  M4_YY_CALL_LAST_ARG);"
block|,
literal|"			}"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			{"
block|,
literal|"			ret_val = EOB_ACT_LAST_MATCH;"
block|,
literal|"			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status ="
block|,
literal|"				YY_BUFFER_EOF_PENDING;"
block|,
literal|"			}"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	else"
block|,
literal|"		ret_val = EOB_ACT_CONTINUE_SCAN;"
block|,
literal|""
block|,
literal|"	if ((yy_size_t) (YY_G(yy_n_chars) + number_to_move)> YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {"
block|,
literal|"		/* Extend the array by 50%, plus the number we really need. */"
block|,
literal|"		yy_size_t new_size = YY_G(yy_n_chars) + number_to_move + (YY_G(yy_n_chars)>> 1);"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc("
block|,
literal|"			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, new_size M4_YY_CALL_LAST_ARG );"
block|,
literal|"		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"
block|,
literal|"			YY_FATAL_ERROR( \"out of dynamic memory in yy_get_next_buffer()\" );"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"	YY_G(yy_n_chars) += number_to_move;"
block|,
literal|"	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|"	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|""
block|,
literal|"	YY_G(yytext_ptr) =&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];"
block|,
literal|""
block|,
literal|"	return ret_val;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"/* yy_get_previous_state - get the state just before the EOB char was reached */"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"%not-for-header"
block|,
literal|"    static yy_state_type yy_get_previous_state YYFARGS0(void)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    yy_state_type yyFlexLexer::yy_get_previous_state()"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"	yy_state_type yy_current_state;"
block|,
literal|"	char *yy_cp;"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"%% [15.0] code to get the start state into yy_current_state goes here"
block|,
literal|""
block|,
literal|"	for ( yy_cp = YY_G(yytext_ptr) + YY_MORE_ADJ; yy_cp< YY_G(yy_c_buf_p); ++yy_cp )"
block|,
literal|"		{"
block|,
literal|"%% [16.0] code to find the next state goes here"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	return yy_current_state;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* yy_try_NUL_trans - try to make a transition on the NUL character"
block|,
literal|" *"
block|,
literal|" * synopsis"
block|,
literal|" *	next_state = yy_try_NUL_trans( current_state );"
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"    static yy_state_type yy_try_NUL_trans  YYFARGS1( yy_state_type, yy_current_state)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    yy_state_type yyFlexLexer::yy_try_NUL_trans( yy_state_type yy_current_state )"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"	int yy_is_jam;"
block|,
literal|"    M4_YY_DECL_GUTS_VAR(); /* This var may be unused depending upon options. */"
block|,
literal|"%% [17.0] code to find the next state, and perhaps do backing up, goes here"
block|,
literal|""
block|,
literal|"	M4_YY_NOOP_GUTS_VAR();"
block|,
literal|"	return yy_is_jam ? 0 : yy_current_state;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"m4_ifdef( [[M4_YY_NO_UNPUT]],,"
block|,
literal|"[["
block|,
literal|"#ifndef YY_NO_UNPUT"
block|,
literal|"    static void yyunput YYFARGS2( int,c, char *,yy_bp)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"#ifndef YY_NO_UNPUT"
block|,
literal|"    void yyFlexLexer::yyunput( int c, char* yy_bp)"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"	char *yy_cp;"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"    yy_cp = YY_G(yy_c_buf_p);"
block|,
literal|""
block|,
literal|"	/* undo effects of setting up yytext */"
block|,
literal|"	*yy_cp = YY_G(yy_hold_char);"
block|,
literal|""
block|,
literal|"	if ( yy_cp< YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"
block|,
literal|"		{ /* need to shift things up to make room */"
block|,
literal|"		/* +2 for EOB chars. */"
block|,
literal|"		yy_size_t number_to_move = YY_G(yy_n_chars) + 2;"
block|,
literal|"		char *dest =&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf["
block|,
literal|"					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];"
block|,
literal|"		char *source ="
block|,
literal|"&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];"
block|,
literal|""
block|,
literal|"		while ( source> YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )"
block|,
literal|"			*--dest = *--source;"
block|,
literal|""
block|,
literal|"		yy_cp += (int) (dest - source);"
block|,
literal|"		yy_bp += (int) (dest - source);"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_n_chars ="
block|,
literal|"			YY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;"
block|,
literal|""
block|,
literal|"		if ( yy_cp< YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )"
block|,
literal|"			YY_FATAL_ERROR( \"flex scanner push-back overflow\" );"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	*--yy_cp = (char) c;"
block|,
literal|""
block|,
literal|"%% [18.0] update yylineno here"
block|,
literal|"m4_ifdef( [[M4_YY_USE_LINENO]],"
block|,
literal|"[["
block|,
literal|"    if ( c == '\\n' ){"
block|,
literal|"        --yylineno;"
block|,
literal|"    }"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"	YY_G(yytext_ptr) = yy_bp;"
block|,
literal|"	YY_G(yy_hold_char) = *yy_cp;"
block|,
literal|"	YY_G(yy_c_buf_p) = yy_cp;"
block|,
literal|"}"
block|,
literal|"#endif	/* ifndef YY_NO_UNPUT */"
block|,
literal|"%if-c-only"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"#ifndef YY_NO_INPUT"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"    static int yyinput YYFARGS0(void)"
block|,
literal|"#else"
block|,
literal|"    static int input  YYFARGS0(void)"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    int yyFlexLexer::yyinput()"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"	int c;"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);"
block|,
literal|""
block|,
literal|"	if ( *YY_G(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )"
block|,
literal|"		{"
block|,
literal|"		/* yy_c_buf_p now points to the character we want to return."
block|,
literal|"		 * If this occurs *before* the EOB characters, then it's a"
block|,
literal|"		 * valid NUL; if not, then we've hit the end of the buffer."
block|,
literal|"		 */"
block|,
literal|"		if ( YY_G(yy_c_buf_p)<&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[YY_G(yy_n_chars)] )"
block|,
literal|"			/* This was really a NUL. */"
block|,
literal|"			*YY_G(yy_c_buf_p) = '\\0';"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			{ /* need more input */"
block|,
literal|"			yy_size_t offset = YY_G(yy_c_buf_p) - YY_G(yytext_ptr);"
block|,
literal|"			++YY_G(yy_c_buf_p);"
block|,
literal|""
block|,
literal|"			switch ( yy_get_next_buffer( M4_YY_CALL_ONLY_ARG ) )"
block|,
literal|"				{"
block|,
literal|"				case EOB_ACT_LAST_MATCH:"
block|,
literal|"					/* This happens because yy_g_n_b()"
block|,
literal|"					 * sees that we've accumulated a"
block|,
literal|"					 * token and flags that we need to"
block|,
literal|"					 * try matching the token before"
block|,
literal|"					 * proceeding.  But for input(),"
block|,
literal|"					 * there's no matching to consider."
block|,
literal|"					 * So convert the EOB_ACT_LAST_MATCH"
block|,
literal|"					 * to EOB_ACT_END_OF_FILE."
block|,
literal|"					 */"
block|,
literal|""
block|,
literal|"					/* Reset buffer status. */"
block|,
literal|"					yyrestart( yyin M4_YY_CALL_LAST_ARG);"
block|,
literal|""
block|,
literal|"					/*FALLTHROUGH*/"
block|,
literal|""
block|,
literal|"				case EOB_ACT_END_OF_FILE:"
block|,
literal|"					{"
block|,
literal|"					if ( yywrap( M4_YY_CALL_ONLY_ARG ) )"
block|,
literal|"						return EOF;"
block|,
literal|""
block|,
literal|"					if ( ! YY_G(yy_did_buffer_switch_on_eof) )"
block|,
literal|"						YY_NEW_FILE;"
block|,
literal|"#ifdef __cplusplus"
block|,
literal|"					return yyinput(M4_YY_CALL_ONLY_ARG);"
block|,
literal|"#else"
block|,
literal|"					return input(M4_YY_CALL_ONLY_ARG);"
block|,
literal|"#endif"
block|,
literal|"					}"
block|,
literal|""
block|,
literal|"				case EOB_ACT_CONTINUE_SCAN:"
block|,
literal|"					YY_G(yy_c_buf_p) = YY_G(yytext_ptr) + offset;"
block|,
literal|"					break;"
block|,
literal|"				}"
block|,
literal|"			}"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	c = *(unsigned char *) YY_G(yy_c_buf_p);	/* cast for 8-bit char's */"
block|,
literal|"	*YY_G(yy_c_buf_p) = '\\0';	/* preserve yytext */"
block|,
literal|"	YY_G(yy_hold_char) = *++YY_G(yy_c_buf_p);"
block|,
literal|""
block|,
literal|"%% [19.0] update BOL and yylineno"
block|,
literal|""
block|,
literal|"	return c;"
block|,
literal|"}"
block|,
literal|"%if-c-only"
block|,
literal|"#endif	/* ifndef YY_NO_INPUT */"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"/** Immediately switch to a different input stream."
block|,
literal|" * @param input_file A readable stream."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" * @note This function does not reset the start condition to @c INITIAL ."
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"    void yyrestart  YYFARGS1( FILE *,input_file)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yyrestart( std::istream* input_file )"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	if ( ! YY_CURRENT_BUFFER ){"
block|,
literal|"        yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE ="
block|,
literal|"            yy_create_buffer( yyin, YY_BUF_SIZE M4_YY_CALL_LAST_ARG);"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"	yy_init_buffer( YY_CURRENT_BUFFER, input_file M4_YY_CALL_LAST_ARG);"
block|,
literal|"	yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Switch to a different input buffer."
block|,
literal|" * @param new_buffer The new input buffer."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"    void yy_switch_to_buffer  YYFARGS1( YY_BUFFER_STATE ,new_buffer)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	/* TODO. We should be able to replace this entire function body"
block|,
literal|"	 * with"
block|,
literal|"	 *		yypop_buffer_state();"
block|,
literal|"	 *		yypush_buffer_state(new_buffer);"
block|,
literal|"     */"
block|,
literal|"	yyensure_buffer_stack (M4_YY_CALL_ONLY_ARG);"
block|,
literal|"	if ( YY_CURRENT_BUFFER == new_buffer )"
block|,
literal|"		return;"
block|,
literal|""
block|,
literal|"	if ( YY_CURRENT_BUFFER )"
block|,
literal|"		{"
block|,
literal|"		/* Flush out information for old buffer. */"
block|,
literal|"		*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = YY_G(yy_c_buf_p);"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	YY_CURRENT_BUFFER_LVALUE = new_buffer;"
block|,
literal|"	yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|""
block|,
literal|"	/* We don't actually know whether we did this switch during"
block|,
literal|"	 * EOF (yywrap()) processing, but the only time this flag"
block|,
literal|"	 * is looked at is after yywrap() is called, so it's safe"
block|,
literal|"	 * to go ahead and always set it."
block|,
literal|"	 */"
block|,
literal|"	YY_G(yy_did_buffer_switch_on_eof) = 1;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"static void yy_load_buffer_state  YYFARGS0(void)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yy_load_buffer_state()"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	YY_G(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;"
block|,
literal|"	YY_G(yytext_ptr) = YY_G(yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;"
block|,
literal|"	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;"
block|,
literal|"	YY_G(yy_hold_char) = *YY_G(yy_c_buf_p);"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Allocate and initialize an input buffer state."
block|,
literal|" * @param file A readable stream."
block|,
literal|" * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" * @return the allocated buffer state."
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"    YY_BUFFER_STATE yy_create_buffer  YYFARGS2( FILE *,file, int ,size)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    YY_BUFFER_STATE yyFlexLexer::yy_create_buffer( std::istream* file, int size )"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"	YY_BUFFER_STATE b;"
block|,
literal|"    m4_dnl M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) M4_YY_CALL_LAST_ARG );"
block|,
literal|"	if ( ! b )"
block|,
literal|"		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );"
block|,
literal|""
block|,
literal|"	b->yy_buf_size = size;"
block|,
literal|""
block|,
literal|"	/* yy_ch_buf has to be 2 characters longer than the size given because"
block|,
literal|"	 * we need to put in 2 end-of-buffer characters."
block|,
literal|"	 */"
block|,
literal|"	b->yy_ch_buf = (char *) yyalloc( b->yy_buf_size + 2 M4_YY_CALL_LAST_ARG );"
block|,
literal|"	if ( ! b->yy_ch_buf )"
block|,
literal|"		YY_FATAL_ERROR( \"out of dynamic memory in yy_create_buffer()\" );"
block|,
literal|""
block|,
literal|"	b->yy_is_our_buffer = 1;"
block|,
literal|""
block|,
literal|"	yy_init_buffer( b, file M4_YY_CALL_LAST_ARG);"
block|,
literal|""
block|,
literal|"	return b;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Destroy the buffer."
block|,
literal|" * @param b a buffer created with yy_create_buffer()"
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"    void yy_delete_buffer YYFARGS1( YY_BUFFER_STATE ,b)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yy_delete_buffer( YY_BUFFER_STATE b )"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	if ( ! b )"
block|,
literal|"		return;"
block|,
literal|""
block|,
literal|"	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;"
block|,
literal|""
block|,
literal|"	if ( b->yy_is_our_buffer )"
block|,
literal|"		yyfree( (void *) b->yy_ch_buf M4_YY_CALL_LAST_ARG );"
block|,
literal|""
block|,
literal|"	yyfree( (void *) b M4_YY_CALL_LAST_ARG );"
block|,
literal|"}"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* Initializes or reinitializes a buffer."
block|,
literal|" * This function is sometimes called more than once on the same buffer,"
block|,
literal|" * such as during a yyrestart() or at EOF."
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"    static void yy_init_buffer  YYFARGS2( YY_BUFFER_STATE ,b, FILE *,file)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yy_init_buffer( YY_BUFFER_STATE b, std::istream* file )"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"{"
block|,
literal|"	int oerrno = errno;"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	yy_flush_buffer( b M4_YY_CALL_LAST_ARG);"
block|,
literal|""
block|,
literal|"	b->yy_input_file = file;"
block|,
literal|"	b->yy_fill_buffer = 1;"
block|,
literal|""
block|,
literal|"    /* If b is the current buffer, then yy_init_buffer was _probably_"
block|,
literal|"     * called from yyrestart() or through yy_get_next_buffer."
block|,
literal|"     * In that case, we don't want to reset the lineno or column."
block|,
literal|"     */"
block|,
literal|"    if (b != YY_CURRENT_BUFFER){"
block|,
literal|"        b->yy_bs_lineno = 1;"
block|,
literal|"        b->yy_bs_column = 0;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"m4_ifdef( [[M4_YY_ALWAYS_INTERACTIVE]],"
block|,
literal|"[["
block|,
literal|"	b->yy_is_interactive = 1;"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_NEVER_INTERACTIVE]],"
block|,
literal|"    [["
block|,
literal|"        b->yy_is_interactive = 0;"
block|,
literal|"    ]],"
block|,
literal|"    [["
block|,
literal|"        b->yy_is_interactive = file ? (isatty( fileno(file) )> 0) : 0;"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"	b->yy_is_interactive = 0;"
block|,
literal|"%endif"
block|,
literal|"	errno = oerrno;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Discard all buffered characters. On the next scan, YY_INPUT will be called."
block|,
literal|" * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"    void yy_flush_buffer YYFARGS1( YY_BUFFER_STATE ,b)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yy_flush_buffer( YY_BUFFER_STATE b )"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	if ( ! b )"
block|,
literal|"		return;"
block|,
literal|""
block|,
literal|"	b->yy_n_chars = 0;"
block|,
literal|""
block|,
literal|"	/* We always need two end-of-buffer characters.  The first causes"
block|,
literal|"	 * a transition to the end-of-buffer state.  The second causes"
block|,
literal|"	 * a jam in that state."
block|,
literal|"	 */"
block|,
literal|"	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|"	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|""
block|,
literal|"	b->yy_buf_pos =&b->yy_ch_buf[0];"
block|,
literal|""
block|,
literal|"	b->yy_at_bol = 1;"
block|,
literal|"	b->yy_buffer_status = YY_BUFFER_NEW;"
block|,
literal|""
block|,
literal|"	if ( b == YY_CURRENT_BUFFER )"
block|,
literal|"		yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"%if-c-or-c++"
block|,
literal|"/** Pushes the new state onto the stack. The new state becomes"
block|,
literal|" *  the current state. This function will allocate the stack"
block|,
literal|" *  if necessary."
block|,
literal|" *  @param new_buffer The new state."
block|,
literal|" *  M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"void yypush_buffer_state YYFARGS1(YY_BUFFER_STATE,new_buffer)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"void yyFlexLexer::yypush_buffer_state (YY_BUFFER_STATE new_buffer)"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	if (new_buffer == NULL)"
block|,
literal|"		return;"
block|,
literal|""
block|,
literal|"	yyensure_buffer_stack(M4_YY_CALL_ONLY_ARG);"
block|,
literal|""
block|,
literal|"	/* This block is copied from yy_switch_to_buffer. */"
block|,
literal|"	if ( YY_CURRENT_BUFFER )"
block|,
literal|"		{"
block|,
literal|"		/* Flush out information for old buffer. */"
block|,
literal|"		*YY_G(yy_c_buf_p) = YY_G(yy_hold_char);"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = YY_G(yy_c_buf_p);"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = YY_G(yy_n_chars);"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	/* Only push if top exists. Otherwise, replace top. */"
block|,
literal|"	if (YY_CURRENT_BUFFER)"
block|,
literal|"		YY_G(yy_buffer_stack_top)++;"
block|,
literal|"	YY_CURRENT_BUFFER_LVALUE = new_buffer;"
block|,
literal|""
block|,
literal|"	/* copied from yy_switch_to_buffer. */"
block|,
literal|"	yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|"	YY_G(yy_did_buffer_switch_on_eof) = 1;"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-or-c++"
block|,
literal|"/** Removes and deletes the top of the stack, if present."
block|,
literal|" *  The next element becomes the new top."
block|,
literal|" *  M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"void yypop_buffer_state YYFARGS0(void)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"void yyFlexLexer::yypop_buffer_state (void)"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	if (!YY_CURRENT_BUFFER)"
block|,
literal|"		return;"
block|,
literal|""
block|,
literal|"	yy_delete_buffer(YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG);"
block|,
literal|"	YY_CURRENT_BUFFER_LVALUE = NULL;"
block|,
literal|"	if (YY_G(yy_buffer_stack_top)> 0)"
block|,
literal|"		--YY_G(yy_buffer_stack_top);"
block|,
literal|""
block|,
literal|"	if (YY_CURRENT_BUFFER) {"
block|,
literal|"		yy_load_buffer_state( M4_YY_CALL_ONLY_ARG );"
block|,
literal|"		YY_G(yy_did_buffer_switch_on_eof) = 1;"
block|,
literal|"	}"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-or-c++"
block|,
literal|"/* Allocates the stack if it does not exist."
block|,
literal|" *  Guarantees space for at least one push."
block|,
literal|" */"
block|,
literal|"%if-c-only"
block|,
literal|"static void yyensure_buffer_stack YYFARGS0(void)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"void yyFlexLexer::yyensure_buffer_stack(void)"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"	yy_size_t num_to_alloc;"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	if (!YY_G(yy_buffer_stack)) {"
block|,
literal|""
block|,
literal|"		/* First allocation is just for 2 elements, since we don't know if this"
block|,
literal|"		 * scanner will even need a stack. We use 2 instead of 1 to avoid an"
block|,
literal|"		 * immediate realloc on the next call."
block|,
literal|"         */"
block|,
literal|"		num_to_alloc = 1;"
block|,
literal|"		YY_G(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc"
block|,
literal|"								(num_to_alloc * sizeof(struct yy_buffer_state*)"
block|,
literal|"								M4_YY_CALL_LAST_ARG);"
block|,
literal|"		if ( ! YY_G(yy_buffer_stack) )"
block|,
literal|"			YY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );"
block|,
literal|"								  "
block|,
literal|"		"
block|,
literal|"		memset(YY_G(yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));"
block|,
literal|"				"
block|,
literal|"		YY_G(yy_buffer_stack_max) = num_to_alloc;"
block|,
literal|"		YY_G(yy_buffer_stack_top) = 0;"
block|,
literal|"		return;"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"	if (YY_G(yy_buffer_stack_top)>= (YY_G(yy_buffer_stack_max)) - 1){"
block|,
literal|""
block|,
literal|"		/* Increase the buffer to prepare for a possible push. */"
block|,
literal|"		int grow_size = 8 /* arbitrary grow size */;"
block|,
literal|""
block|,
literal|"		num_to_alloc = YY_G(yy_buffer_stack_max) + grow_size;"
block|,
literal|"		YY_G(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc"
block|,
literal|"								(YY_G(yy_buffer_stack),"
block|,
literal|"								num_to_alloc * sizeof(struct yy_buffer_state*)"
block|,
literal|"								M4_YY_CALL_LAST_ARG);"
block|,
literal|"		if ( ! YY_G(yy_buffer_stack) )"
block|,
literal|"			YY_FATAL_ERROR( \"out of dynamic memory in yyensure_buffer_stack()\" );"
block|,
literal|""
block|,
literal|"		/* zero only the new slots.*/"
block|,
literal|"		memset(YY_G(yy_buffer_stack) + YY_G(yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));"
block|,
literal|"		YY_G(yy_buffer_stack_max) = num_to_alloc;"
block|,
literal|"	}"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SCAN_BUFFER]],,"
block|,
literal|"[["
block|,
literal|"%if-c-only"
block|,
literal|"/** Setup the input buffer state to scan directly from a user-specified character buffer."
block|,
literal|" * @param base the character buffer"
block|,
literal|" * @param size the size in bytes of the character buffer"
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" * @return the newly allocated buffer state object. "
block|,
literal|" */"
block|,
literal|"YY_BUFFER_STATE yy_scan_buffer  YYFARGS2( char *,base, yy_size_t ,size)"
block|,
literal|"{"
block|,
literal|"	YY_BUFFER_STATE b;"
block|,
literal|"    m4_dnl M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	if ( size< 2 ||"
block|,
literal|"	     base[size-2] != YY_END_OF_BUFFER_CHAR ||"
block|,
literal|"	     base[size-1] != YY_END_OF_BUFFER_CHAR )"
block|,
literal|"		/* They forgot to leave room for the EOB's. */"
block|,
literal|"		return 0;"
block|,
literal|""
block|,
literal|"	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) M4_YY_CALL_LAST_ARG );"
block|,
literal|"	if ( ! b )"
block|,
literal|"		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_buffer()\" );"
block|,
literal|""
block|,
literal|"	b->yy_buf_size = size - 2;	/* \"- 2\" to take care of EOB's */"
block|,
literal|"	b->yy_buf_pos = b->yy_ch_buf = base;"
block|,
literal|"	b->yy_is_our_buffer = 0;"
block|,
literal|"	b->yy_input_file = 0;"
block|,
literal|"	b->yy_n_chars = b->yy_buf_size;"
block|,
literal|"	b->yy_is_interactive = 0;"
block|,
literal|"	b->yy_at_bol = 1;"
block|,
literal|"	b->yy_fill_buffer = 0;"
block|,
literal|"	b->yy_buffer_status = YY_BUFFER_NEW;"
block|,
literal|""
block|,
literal|"	yy_switch_to_buffer( b M4_YY_CALL_LAST_ARG );"
block|,
literal|""
block|,
literal|"	return b;"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SCAN_STRING]],,"
block|,
literal|"[["
block|,
literal|"%if-c-only"
block|,
literal|"/** Setup the input buffer state to scan a string. The next call to yylex() will"
block|,
literal|" * scan from a @e copy of @a str."
block|,
literal|" * @param yystr a NUL-terminated string to scan"
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" * @return the newly allocated buffer state object."
block|,
literal|" * @note If you want to scan bytes that may contain NUL values, then use"
block|,
literal|" *       yy_scan_bytes() instead."
block|,
literal|" */"
block|,
literal|"YY_BUFFER_STATE yy_scan_string YYFARGS1( yyconst char *, yystr)"
block|,
literal|"{"
block|,
literal|"    m4_dnl M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	return yy_scan_bytes( yystr, strlen(yystr) M4_YY_CALL_LAST_ARG);"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SCAN_BYTES]],,"
block|,
literal|"[["
block|,
literal|"%if-c-only"
block|,
literal|"/** Setup the input buffer state to scan the given bytes. The next call to yylex() will"
block|,
literal|" * scan from a @e copy of @a bytes."
block|,
literal|" * @param yybytes the byte buffer to scan"
block|,
literal|" * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" * @return the newly allocated buffer state object."
block|,
literal|" */"
block|,
literal|"YY_BUFFER_STATE yy_scan_bytes  YYFARGS2( yyconst char *,yybytes, yy_size_t ,_yybytes_len)"
block|,
literal|"{"
block|,
literal|"	YY_BUFFER_STATE b;"
block|,
literal|"	char *buf;"
block|,
literal|"	yy_size_t n;"
block|,
literal|"	yy_size_t i;"
block|,
literal|"    m4_dnl M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"	/* Get memory for full buffer, including space for trailing EOB's. */"
block|,
literal|"	n = _yybytes_len + 2;"
block|,
literal|"	buf = (char *) yyalloc( n M4_YY_CALL_LAST_ARG );"
block|,
literal|"	if ( ! buf )"
block|,
literal|"		YY_FATAL_ERROR( \"out of dynamic memory in yy_scan_bytes()\" );"
block|,
literal|""
block|,
literal|"	for ( i = 0; i< _yybytes_len; ++i )"
block|,
literal|"		buf[i] = yybytes[i];"
block|,
literal|""
block|,
literal|"	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;"
block|,
literal|""
block|,
literal|"	b = yy_scan_buffer( buf, n M4_YY_CALL_LAST_ARG);"
block|,
literal|"	if ( ! b )"
block|,
literal|"		YY_FATAL_ERROR( \"bad buffer in yy_scan_bytes()\" );"
block|,
literal|""
block|,
literal|"	/* It's okay to grow etc. this buffer, and we should throw it"
block|,
literal|"	 * away when we're done."
block|,
literal|"	 */"
block|,
literal|"	b->yy_is_our_buffer = 1;"
block|,
literal|""
block|,
literal|"	return b;"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_PUSH_STATE]],,"
block|,
literal|"[["
block|,
literal|"%if-c-only"
block|,
literal|"    static void yy_push_state YYFARGS1( int ,new_state)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yy_push_state( int new_state )"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	if ( YY_G(yy_start_stack_ptr)>= YY_G(yy_start_stack_depth) )"
block|,
literal|"		{"
block|,
literal|"		yy_size_t new_size;"
block|,
literal|""
block|,
literal|"		YY_G(yy_start_stack_depth) += YY_START_STACK_INCR;"
block|,
literal|"		new_size = YY_G(yy_start_stack_depth) * sizeof( int );"
block|,
literal|""
block|,
literal|"		if ( ! YY_G(yy_start_stack) )"
block|,
literal|"			YY_G(yy_start_stack) = (int *) yyalloc( new_size M4_YY_CALL_LAST_ARG );"
block|,
literal|""
block|,
literal|"		else"
block|,
literal|"			YY_G(yy_start_stack) = (int *) yyrealloc("
block|,
literal|"					(void *) YY_G(yy_start_stack), new_size M4_YY_CALL_LAST_ARG );"
block|,
literal|""
block|,
literal|"		if ( ! YY_G(yy_start_stack) )"
block|,
literal|"			YY_FATAL_ERROR( \"out of memory expanding start-condition stack\" );"
block|,
literal|"		}"
block|,
literal|""
block|,
literal|"	YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)++] = YY_START;"
block|,
literal|""
block|,
literal|"	BEGIN(new_state);"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_POP_STATE]],,"
block|,
literal|"[["
block|,
literal|"%if-c-only"
block|,
literal|"    static void yy_pop_state  YYFARGS0(void)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    void yyFlexLexer::yy_pop_state()"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	if ( --YY_G(yy_start_stack_ptr)< 0 )"
block|,
literal|"		YY_FATAL_ERROR( \"start-condition stack underflow\" );"
block|,
literal|""
block|,
literal|"	BEGIN(YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr)]);"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_TOP_STATE]],,"
block|,
literal|"[["
block|,
literal|"%if-c-only"
block|,
literal|"    static int yy_top_state  YYFARGS0(void)"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"    int yyFlexLexer::yy_top_state()"
block|,
literal|"%endif"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	return YY_G(yy_start_stack)[YY_G(yy_start_stack_ptr) - 1];"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"#ifndef YY_EXIT_FAILURE"
block|,
literal|"#define YY_EXIT_FAILURE 2"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"static void yy_fatal_error YYFARGS1(yyconst char*, msg)"
block|,
literal|"{"
block|,
literal|"    m4_dnl M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	(void) fprintf( stderr, \"%s\\n\", msg );"
block|,
literal|"	exit( YY_EXIT_FAILURE );"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|"%if-c++-only"
block|,
literal|"void yyFlexLexer::LexerError( yyconst char msg[] )"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"	std::cerr<< msg<< std::endl;"
block|,
literal|"	exit( YY_EXIT_FAILURE );"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"/* Redefine yyless() so it works in section 3 code. */"
block|,
literal|""
block|,
literal|"#undef yyless"
block|,
literal|"#define yyless(n) \\"
block|,
literal|"	do \\"
block|,
literal|"		{ \\"
block|,
literal|"		/* Undo effects of setting up yytext. */ \\"
block|,
literal|"        int yyless_macro_arg = (n); \\"
block|,
literal|"        YY_LESS_LINENO(yyless_macro_arg);\\"
block|,
literal|"		yytext[yyleng] = YY_G(yy_hold_char); \\"
block|,
literal|"		YY_G(yy_c_buf_p) = yytext + yyless_macro_arg; \\"
block|,
literal|"		YY_G(yy_hold_char) = *YY_G(yy_c_buf_p); \\"
block|,
literal|"		*YY_G(yy_c_buf_p) = '\\0'; \\"
block|,
literal|"		yyleng = yyless_macro_arg; \\"
block|,
literal|"		} \\"
block|,
literal|"	while ( 0 )"
block|,
literal|""
block|,
literal|""
block|,
literal|""
block|,
literal|"/* Accessor  methods (get/set functions) to struct members. */"
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"%if-reentrant"
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_EXTRA]],,"
block|,
literal|"[["
block|,
literal|"/** Get the user-defined data for this scanner."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"YY_EXTRA_TYPE yyget_extra  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yyextra;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_LINENO]],,"
block|,
literal|"[["
block|,
literal|"/** Get the current line number."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"int yyget_lineno  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    "
block|,
literal|"    m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"    [["
block|,
literal|"        if (! YY_CURRENT_BUFFER)"
block|,
literal|"            return 0;"
block|,
literal|"    ]])"
block|,
literal|"    return yylineno;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"[["
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_COLUMN]],,"
block|,
literal|"[["
block|,
literal|"/** Get the current column number."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"int yyget_column  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    "
block|,
literal|"    m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"    [["
block|,
literal|"        if (! YY_CURRENT_BUFFER)"
block|,
literal|"            return 0;"
block|,
literal|"    ]])"
block|,
literal|"    return yycolumn;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_IN]],,"
block|,
literal|"[["
block|,
literal|"/** Get the input stream."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"FILE *yyget_in  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yyin;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_OUT]],,"
block|,
literal|"[["
block|,
literal|"/** Get the output stream."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"FILE *yyget_out  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yyout;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_LENG]],,"
block|,
literal|"[["
block|,
literal|"/** Get the length of the current token."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"yy_size_t yyget_leng  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yyleng;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"/** Get the current token."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_TEXT]],,"
block|,
literal|"[["
block|,
literal|"char *yyget_text  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yytext;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%if-reentrant"
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_EXTRA]],,"
block|,
literal|"[["
block|,
literal|"/** Set the user-defined data. This data is never touched by the scanner."
block|,
literal|" * @param user_defined The data to be associated with this scanner."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"void yyset_extra YYFARGS1( YY_EXTRA_TYPE ,user_defined)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    yyextra = user_defined ;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_LINENO]],,"
block|,
literal|"[["
block|,
literal|"/** Set the current line number."
block|,
literal|" * @param line_number"
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"void yyset_lineno YYFARGS1( int ,line_number)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"    m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"    [["
block|,
literal|"        /* lineno is only valid if an input buffer exists. */"
block|,
literal|"        if (! YY_CURRENT_BUFFER )"
block|,
literal|"           YY_FATAL_ERROR( \"yyset_lineno called with no buffer\" );"
block|,
literal|"    ]])"
block|,
literal|"    yylineno = line_number;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"[["
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_COLUMN]],,"
block|,
literal|"[["
block|,
literal|"/** Set the current column."
block|,
literal|" * @param line_number"
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" */"
block|,
literal|"void yyset_column YYFARGS1( int , column_no)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"    m4_ifdef( [[M4_YY_REENTRANT]],"
block|,
literal|"    [["
block|,
literal|"        /* column is only valid if an input buffer exists. */"
block|,
literal|"        if (! YY_CURRENT_BUFFER )"
block|,
literal|"           YY_FATAL_ERROR( \"yyset_column called with no buffer\" );"
block|,
literal|"    ]])"
block|,
literal|"    yycolumn = column_no;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_IN]],,"
block|,
literal|"[["
block|,
literal|"/** Set the input stream. This does not discard the current"
block|,
literal|" * input buffer."
block|,
literal|" * @param in_str A readable stream."
block|,
literal|" * M4_YY_DOC_PARAM"
block|,
literal|" * @see yy_switch_to_buffer"
block|,
literal|" */"
block|,
literal|"void yyset_in YYFARGS1( FILE * ,in_str)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    yyin = in_str ;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_OUT]],,"
block|,
literal|"[["
block|,
literal|"void yyset_out YYFARGS1( FILE * ,out_str)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    yyout = out_str ;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_DEBUG]],,"
block|,
literal|"[["
block|,
literal|"int yyget_debug  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yy_flex_debug;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_DEBUG]],,"
block|,
literal|"[["
block|,
literal|"void yyset_debug YYFARGS1( int ,bdebug)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    yy_flex_debug = bdebug ;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"%if-reentrant"
block|,
literal|"/* Accessor methods for yylval and yylloc */"
block|,
literal|""
block|,
literal|"%if-bison-bridge"
block|,
literal|"m4_ifdef( [[M4_YY_NO_GET_LVAL]],,"
block|,
literal|"[["
block|,
literal|"YYSTYPE * yyget_lval  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yylval;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_SET_LVAL]],,"
block|,
literal|"[["
block|,
literal|"void yyset_lval YYFARGS1( YYSTYPE * ,yylval_param)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    yylval = yylval_param;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[<M4_YY_BISON_LLOC>]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_NO_GET_LLOC]],,"
block|,
literal|"    [["
block|,
literal|"YYLTYPE *yyget_lloc  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    return yylloc;"
block|,
literal|"}"
block|,
literal|"    ]])"
block|,
literal|""
block|,
literal|"    m4_ifdef( [[M4_YY_NO_SET_LLOC]],,"
block|,
literal|"    [["
block|,
literal|"void yyset_lloc YYFARGS1( YYLTYPE * ,yylloc_param)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    yylloc = yylloc_param;"
block|,
literal|"}"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* User-visible API */"
block|,
literal|""
block|,
literal|"/* yylex_init is special because it creates the scanner itself, so it is"
block|,
literal|" * the ONLY reentrant function that doesn't take the scanner as the last argument."
block|,
literal|" * That's why we explicitly handle the declaration, instead of using our macros."
block|,
literal|" */"
block|,
literal|"m4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],"
block|,
literal|"[["
block|,
literal|"int yylex_init( ptr_yy_globals )"
block|,
literal|"    yyscan_t* ptr_yy_globals;"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"int yylex_init(yyscan_t* ptr_yy_globals)"
block|,
literal|"]])"
block|,
literal|"{"
block|,
literal|"    if (ptr_yy_globals == NULL){"
block|,
literal|"        errno = EINVAL;"
block|,
literal|"        return 1;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), NULL );"
block|,
literal|""
block|,
literal|"    if (*ptr_yy_globals == NULL){"
block|,
literal|"        errno = ENOMEM;"
block|,
literal|"        return 1;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */"
block|,
literal|"    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));"
block|,
literal|""
block|,
literal|"    return yy_init_globals ( *ptr_yy_globals );"
block|,
literal|"}"
block|,
literal|""
block|,
literal|""
block|,
literal|"/* yylex_init_extra has the same functionality as yylex_init, but follows the"
block|,
literal|" * convention of taking the scanner as the last argument. Note however, that"
block|,
literal|" * this is a *pointer* to a scanner, as it will be allocated by this call (and"
block|,
literal|" * is the reason, too, why this function also must handle its own declaration)."
block|,
literal|" * The user defined value in the first argument will be available to yyalloc in"
block|,
literal|" * the yyextra field."
block|,
literal|" */"
block|,
literal|"m4_ifdef( [[M4_YY_NO_ANSI_FUNC_DEFS]],"
block|,
literal|"[["
block|,
literal|"int yylex_init_extra( yy_user_defined, ptr_yy_globals )"
block|,
literal|"    YY_EXTRA_TYPE yy_user_defined;"
block|,
literal|"    yyscan_t* ptr_yy_globals;"
block|,
literal|"]],"
block|,
literal|"[["
block|,
literal|"int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )"
block|,
literal|"]])"
block|,
literal|"{"
block|,
literal|"    struct yyguts_t dummy_yyguts;"
block|,
literal|""
block|,
literal|"    yyset_extra (yy_user_defined,&dummy_yyguts);"
block|,
literal|""
block|,
literal|"    if (ptr_yy_globals == NULL){"
block|,
literal|"        errno = EINVAL;"
block|,
literal|"        return 1;"
block|,
literal|"    }"
block|,
literal|"	"
block|,
literal|"    *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ),&dummy_yyguts );"
block|,
literal|"	"
block|,
literal|"    if (*ptr_yy_globals == NULL){"
block|,
literal|"        errno = ENOMEM;"
block|,
literal|"        return 1;"
block|,
literal|"    }"
block|,
literal|"    "
block|,
literal|"    /* By setting to 0xAA, we expose bugs in"
block|,
literal|"    yy_init_globals. Leave at 0x00 for releases. */"
block|,
literal|"    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));"
block|,
literal|"    "
block|,
literal|"    yyset_extra (yy_user_defined, *ptr_yy_globals);"
block|,
literal|"    "
block|,
literal|"    return yy_init_globals ( *ptr_yy_globals );"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"%endif if-c-only"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-only"
block|,
literal|"static int yy_init_globals YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|"    /* Initialization is the same as for the non-reentrant scanner."
block|,
literal|"     * This function is called from yylex_destroy(), so don't allocate here."
block|,
literal|"     */"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_USE_LINENO]],"
block|,
literal|"[["
block|,
literal|"    m4_ifdef( [[M4_YY_NOT_REENTRANT]],"
block|,
literal|"    [["
block|,
literal|"    /* We do not touch yylineno unless the option is enabled. */"
block|,
literal|"    yylineno =  1;"
block|,
literal|"    ]])"
block|,
literal|"]])"
block|,
literal|"    YY_G(yy_buffer_stack) = 0;"
block|,
literal|"    YY_G(yy_buffer_stack_top) = 0;"
block|,
literal|"    YY_G(yy_buffer_stack_max) = 0;"
block|,
literal|"    YY_G(yy_c_buf_p) = (char *) 0;"
block|,
literal|"    YY_G(yy_init) = 0;"
block|,
literal|"    YY_G(yy_start) = 0;"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],"
block|,
literal|"[["
block|,
literal|"    YY_G(yy_start_stack_ptr) = 0;"
block|,
literal|"    YY_G(yy_start_stack_depth) = 0;"
block|,
literal|"    YY_G(yy_start_stack) =  NULL;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],"
block|,
literal|"[["
block|,
literal|"    YY_G(yy_state_buf) = 0;"
block|,
literal|"    YY_G(yy_state_ptr) = 0;"
block|,
literal|"    YY_G(yy_full_match) = 0;"
block|,
literal|"    YY_G(yy_lp) = 0;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_TEXT_IS_ARRAY]],"
block|,
literal|"[["
block|,
literal|"    YY_G(yytext_ptr) = 0;"
block|,
literal|"    YY_G(yy_more_offset) = 0;"
block|,
literal|"    YY_G(yy_prev_more_offset) = 0;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"/* Defined in main.c */"
block|,
literal|"#ifdef YY_STDINIT"
block|,
literal|"    yyin = stdin;"
block|,
literal|"    yyout = stdout;"
block|,
literal|"#else"
block|,
literal|"    yyin = (FILE *) 0;"
block|,
literal|"    yyout = (FILE *) 0;"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|"    /* For future reference: Set errno on error, since we are called by"
block|,
literal|"     * yylex_init()"
block|,
literal|"     */"
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"%if-c-only SNIP! this currently causes conflicts with the c++ scanner"
block|,
literal|"/* yylex_destroy is for both reentrant and non-reentrant scanners. */"
block|,
literal|"int yylex_destroy  YYFARGS0(void)"
block|,
literal|"{"
block|,
literal|"    M4_YY_DECL_GUTS_VAR();"
block|,
literal|""
block|,
literal|"    /* Pop the buffer stack, destroying each element. */"
block|,
literal|"	while(YY_CURRENT_BUFFER){"
block|,
literal|"		yy_delete_buffer( YY_CURRENT_BUFFER M4_YY_CALL_LAST_ARG );"
block|,
literal|"		YY_CURRENT_BUFFER_LVALUE = NULL;"
block|,
literal|"		yypop_buffer_state(M4_YY_CALL_ONLY_ARG);"
block|,
literal|"	}"
block|,
literal|""
block|,
literal|"	/* Destroy the stack itself. */"
block|,
literal|"	yyfree(YY_G(yy_buffer_stack) M4_YY_CALL_LAST_ARG);"
block|,
literal|"	YY_G(yy_buffer_stack) = NULL;"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_HAS_START_STACK_VARS]],"
block|,
literal|"[["
block|,
literal|"    /* Destroy the start condition stack. */"
block|,
literal|"        yyfree( YY_G(yy_start_stack) M4_YY_CALL_LAST_ARG );"
block|,
literal|"        YY_G(yy_start_stack) = NULL;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_USES_REJECT]],"
block|,
literal|"[["
block|,
literal|"    yyfree ( YY_G(yy_state_buf) M4_YY_CALL_LAST_ARG);"
block|,
literal|"    YY_G(yy_state_buf)  = NULL;"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"    /* Reset the globals. This is important in a non-reentrant scanner so the next time"
block|,
literal|"     * yylex() is called, initialization will occur. */"
block|,
literal|"    yy_init_globals( M4_YY_CALL_ONLY_ARG);"
block|,
literal|""
block|,
literal|"%if-reentrant"
block|,
literal|"    /* Destroy the main struct (reentrant only). */"
block|,
literal|"    yyfree ( yyscanner M4_YY_CALL_LAST_ARG );"
block|,
literal|"    yyscanner = NULL;"
block|,
literal|"%endif"
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"/*"
block|,
literal|" * Internal utility routines."
block|,
literal|" */"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#ifndef yytext_ptr"
block|,
literal|"static void yy_flex_strncpy YYFARGS3( char*,s1, yyconst char *,s2, int,n)"
block|,
literal|"{"
block|,
literal|"	int i;"
block|,
literal|"	for ( i = 0; i< n; ++i )"
block|,
literal|"		s1[i] = s2[i];"
block|,
literal|"}"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NOT_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#ifdef YY_NEED_STRLEN"
block|,
literal|"static int yy_flex_strlen YYFARGS1( yyconst char *,s)"
block|,
literal|"{"
block|,
literal|"	int n;"
block|,
literal|"	for ( n = 0; s[n]; ++n )"
block|,
literal|"		;"
block|,
literal|""
block|,
literal|"	return n;"
block|,
literal|"}"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_FLEX_ALLOC]],,"
block|,
literal|"[["
block|,
literal|"void *yyalloc YYFARGS1( yy_size_t ,size)"
block|,
literal|"{"
block|,
literal|"	return (void *) malloc( size );"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_FLEX_REALLOC]],,"
block|,
literal|"[["
block|,
literal|"void *yyrealloc  YYFARGS2( void *,ptr, yy_size_t ,size)"
block|,
literal|"{"
block|,
literal|"	/* The cast to (char *) in the following accommodates both"
block|,
literal|"	 * implementations that use char* generic pointers, and those"
block|,
literal|"	 * that use void* generic pointers.  It works with the latter"
block|,
literal|"	 * because both ANSI C and C++ allow castless assignment from"
block|,
literal|"	 * any pointer type to void*, and deal with argument conversions"
block|,
literal|"	 * as though doing an assignment."
block|,
literal|"	 */"
block|,
literal|"	return (void *) realloc( (char *) ptr, size );"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"m4_ifdef( [[M4_YY_NO_FLEX_FREE]],,"
block|,
literal|"[["
block|,
literal|"void yyfree YYFARGS1( void *,ptr)"
block|,
literal|"{"
block|,
literal|"	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%if-tables-serialization definitions"
block|,
literal|"#ifdef FLEX_SCANNER"
block|,
literal|"/*"
block|,
literal|"dnl   tables_shared.c - tables serialization code"
block|,
literal|"dnl "
block|,
literal|"dnl   Copyright (c) 1990 The Regents of the University of California."
block|,
literal|"dnl   All rights reserved."
block|,
literal|"dnl "
block|,
literal|"dnl   This code is derived from software contributed to Berkeley by"
block|,
literal|"dnl   Vern Paxson."
block|,
literal|"dnl "
block|,
literal|"dnl   The United States Government has rights in this work pursuant"
block|,
literal|"dnl   to contract no. DE-AC03-76SF00098 between the United States"
block|,
literal|"dnl   Department of Energy and the University of California."
block|,
literal|"dnl "
block|,
literal|"dnl   This file is part of flex."
block|,
literal|"dnl "
block|,
literal|"dnl   Redistribution and use in source and binary forms, with or without"
block|,
literal|"dnl   modification, are permitted provided that the following conditions"
block|,
literal|"dnl   are met:"
block|,
literal|"dnl "
block|,
literal|"dnl   1. Redistributions of source code must retain the above copyright"
block|,
literal|"dnl      notice, this list of conditions and the following disclaimer."
block|,
literal|"dnl   2. Redistributions in binary form must reproduce the above copyright"
block|,
literal|"dnl      notice, this list of conditions and the following disclaimer in the"
block|,
literal|"dnl      documentation and/or other materials provided with the distribution."
block|,
literal|"dnl "
block|,
literal|"dnl   Neither the name of the University nor the names of its contributors"
block|,
literal|"dnl   may be used to endorse or promote products derived from this software"
block|,
literal|"dnl   without specific prior written permission."
block|,
literal|"dnl "
block|,
literal|"dnl   THIS SOFTWARE IS PROVIDED `AS IS' AND WITHOUT ANY EXPRESS OR"
block|,
literal|"dnl   IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED"
block|,
literal|"dnl   WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR"
block|,
literal|"dnl   PURPOSE."
block|,
literal|"dnl "
block|,
literal|"*/"
block|,
literal|"
literal|"
block|,
literal|"/* This file is meant to be included in both the skeleton and the actual"
block|,
literal|" * flex code (hence the name \"_shared\"). "
block|,
literal|" */"
block|,
literal|"#ifndef yyskel_static"
block|,
literal|"#define yyskel_static static"
block|,
literal|"#endif"
block|,
literal|"#else"
block|,
literal|"#include \"flexdef.h\""
block|,
literal|"#include \"tables.h\""
block|,
literal|"#ifndef yyskel_static"
block|,
literal|"#define yyskel_static"
block|,
literal|"#endif"
block|,
literal|"#endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"/** Get the number of integers in this table. This is NOT the"
block|,
literal|" *  same thing as the number of elements."
block|,
literal|" *  @param td the table "
block|,
literal|" *  @return the number of integers in the table"
block|,
literal|" */"
block|,
literal|"yyskel_static flex_int32_t yytbl_calc_total_len (const struct yytbl_data *tbl)"
block|,
literal|"{"
block|,
literal|"	flex_int32_t n;"
block|,
literal|""
block|,
literal|"	/* total number of ints */"
block|,
literal|"	n = tbl->td_lolen;"
block|,
literal|"	if (tbl->td_hilen> 0)"
block|,
literal|"		n *= tbl->td_hilen;"
block|,
literal|""
block|,
literal|"	if (tbl->td_id == YYTD_ID_TRANSITION)"
block|,
literal|"		n *= 2;"
block|,
literal|"	return n;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|""
block|,
literal|"static int yytbl_read8 (void *v, struct yytbl_reader * rd)"
block|,
literal|"{"
block|,
literal|"    errno = 0;"
block|,
literal|"    if (fread (v, sizeof (flex_uint8_t), 1, rd->fp) != 1){"
block|,
literal|"        errno = EIO;"
block|,
literal|"        return -1;"
block|,
literal|"    }"
block|,
literal|"    rd->bread += sizeof(flex_uint8_t);"
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"static int yytbl_read16 (void *v, struct yytbl_reader * rd)"
block|,
literal|"{"
block|,
literal|"    errno = 0;"
block|,
literal|"    if (fread (v, sizeof (flex_uint16_t), 1, rd->fp) != 1){"
block|,
literal|"        errno = EIO;"
block|,
literal|"        return -1;"
block|,
literal|"    }"
block|,
literal|"    *((flex_uint16_t *) v) = ntohs (*((flex_uint16_t *) v));"
block|,
literal|"    rd->bread += sizeof(flex_uint16_t);"
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"static int yytbl_read32 (void *v, struct yytbl_reader * rd)"
block|,
literal|"{"
block|,
literal|"    errno = 0;"
block|,
literal|"    if (fread (v, sizeof (flex_uint32_t), 1, rd->fp) != 1){"
block|,
literal|"        errno = EIO;"
block|,
literal|"        return -1;"
block|,
literal|"    }"
block|,
literal|"    *((flex_uint32_t *) v) = ntohl (*((flex_uint32_t *) v));"
block|,
literal|"    rd->bread += sizeof(flex_uint32_t);"
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Read the header */"
block|,
literal|"static int yytbl_hdr_read YYFARGS2(struct yytbl_hdr *, th, struct yytbl_reader *, rd)"
block|,
literal|"{"
block|,
literal|"    int     bytes;"
block|,
literal|"    memset (th, 0, sizeof (struct yytbl_hdr));"
block|,
literal|""
block|,
literal|"    if (yytbl_read32 (&(th->th_magic), rd) != 0)"
block|,
literal|"        return -1;"
block|,
literal|""
block|,
literal|"    if (th->th_magic != YYTBL_MAGIC){"
block|,
literal|"        YY_FATAL_ERROR( \"bad magic number\" );   /* TODO: not fatal. */"
block|,
literal|"        return -1;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    if (yytbl_read32 (&(th->th_hsize), rd) != 0"
block|,
literal|"        || yytbl_read32 (&(th->th_ssize), rd) != 0"
block|,
literal|"        || yytbl_read16 (&(th->th_flags), rd) != 0)"
block|,
literal|"        return -1;"
block|,
literal|""
block|,
literal|"    /* Sanity check on header size. Greater than 1k suggests some funny business. */"
block|,
literal|"    if (th->th_hsize< 16 || th->th_hsize> 1024){"
block|,
literal|"        YY_FATAL_ERROR( \"insane header size detected\" );   /* TODO: not fatal. */"
block|,
literal|"        return -1;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    /* Allocate enough space for the version and name fields */"
block|,
literal|"    bytes = th->th_hsize - 14;"
block|,
literal|"    th->th_version = (char *) yyalloc (bytes M4_YY_CALL_LAST_ARG);"
block|,
literal|"    if ( ! th->th_version )"
block|,
literal|"        YY_FATAL_ERROR( \"out of dynamic memory in yytbl_hdr_read()\" );"
block|,
literal|""
block|,
literal|"    /* we read it all into th_version, and point th_name into that data */"
block|,
literal|"    if (fread (th->th_version, 1, bytes, rd->fp) != bytes){"
block|,
literal|"        errno = EIO;"
block|,
literal|"        yyfree(th->th_version M4_YY_CALL_LAST_ARG);"
block|,
literal|"        th->th_version = NULL;"
block|,
literal|"        return -1;"
block|,
literal|"    }"
block|,
literal|"    else"
block|,
literal|"        rd->bread += bytes;"
block|,
literal|""
block|,
literal|"    th->th_name = th->th_version + strlen (th->th_version) + 1;"
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** lookup id in the dmap list."
block|,
literal|" *  @param dmap pointer to first element in list"
block|,
literal|" *  @return NULL if not found."
block|,
literal|" */"
block|,
literal|"static struct yytbl_dmap *yytbl_dmap_lookup YYFARGS2(struct yytbl_dmap *, dmap,"
block|,
literal|"                                                      int, id)"
block|,
literal|"{"
block|,
literal|"    while (dmap->dm_id)"
block|,
literal|"        if (dmap->dm_id == id)"
block|,
literal|"            return dmap;"
block|,
literal|"        else"
block|,
literal|"            dmap++;"
block|,
literal|"    return NULL;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Read a table while mapping its contents to the local array. "
block|,
literal|" *  @param dmap used to performing mapping"
block|,
literal|" *  @return 0 on success"
block|,
literal|" */"
block|,
literal|"static int yytbl_data_load YYFARGS2(struct yytbl_dmap *, dmap, struct yytbl_reader*, rd)"
block|,
literal|"{"
block|,
literal|"    struct yytbl_data td;"
block|,
literal|"    struct yytbl_dmap *transdmap=0;"
block|,
literal|"    int     len, i, rv, inner_loop_count;"
block|,
literal|"    void   *p=0;"
block|,
literal|""
block|,
literal|"    memset (&td, 0, sizeof (struct yytbl_data));"
block|,
literal|""
block|,
literal|"    if (yytbl_read16 (&td.td_id, rd) != 0"
block|,
literal|"        || yytbl_read16 (&td.td_flags, rd) != 0"
block|,
literal|"        || yytbl_read32 (&td.td_hilen, rd) != 0"
block|,
literal|"        || yytbl_read32 (&td.td_lolen, rd) != 0)"
block|,
literal|"        return -1;"
block|,
literal|""
block|,
literal|"    /* Lookup the map for the transition table so we have it in case we need it"
block|,
literal|"     * inside the loop below. This scanner might not even have a transition"
block|,
literal|"     * table, which is ok."
block|,
literal|"     */"
block|,
literal|"    transdmap = yytbl_dmap_lookup (dmap, YYTD_ID_TRANSITION M4_YY_CALL_LAST_ARG);"
block|,
literal|""
block|,
literal|"    if ((dmap = yytbl_dmap_lookup (dmap, td.td_id M4_YY_CALL_LAST_ARG)) == NULL){"
block|,
literal|"        YY_FATAL_ERROR( \"table id not found in map.\" );   /* TODO: not fatal. */"
block|,
literal|"        return -1;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    /* Allocate space for table."
block|,
literal|"     * The --full yy_transition table is a special case, since we"
block|,
literal|"     * need the dmap.dm_sz entry to tell us the sizeof the individual"
block|,
literal|"     * struct members."
block|,
literal|"     */"
block|,
literal|"    {"
block|,
literal|"    size_t  bytes;"
block|,
literal|""
block|,
literal|"    if ((td.td_flags& YYTD_STRUCT))"
block|,
literal|"        bytes = sizeof(struct yy_trans_info) * td.td_lolen * (td.td_hilen ? td.td_hilen : 1);"
block|,
literal|"    else"
block|,
literal|"        bytes = td.td_lolen * (td.td_hilen ? td.td_hilen : 1) * dmap->dm_sz;"
block|,
literal|""
block|,
literal|"    if(M4_YY_TABLES_VERIFY)"
block|,
literal|"        /* We point to the array itself */"
block|,
literal|"        p = dmap->dm_arr; "
block|,
literal|"    else"
block|,
literal|"        /* We point to the address of a pointer. */"
block|,
literal|"        *dmap->dm_arr = p = (void *) yyalloc (bytes M4_YY_CALL_LAST_ARG);"
block|,
literal|"        if ( ! p )"
block|,
literal|"            YY_FATAL_ERROR( \"out of dynamic memory in yytbl_data_load()\" );"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    /* If it's a struct, we read 2 integers to get one element */"
block|,
literal|"    if ((td.td_flags& YYTD_STRUCT) != 0)"
block|,
literal|"        inner_loop_count = 2;"
block|,
literal|"    else"
block|,
literal|"        inner_loop_count = 1;"
block|,
literal|""
block|,
literal|"    /* read and map each element."
block|,
literal|"     * This loop iterates once for each element of the td_data array."
block|,
literal|"     * Notice that we increment 'i' in the inner loop."
block|,
literal|"     */"
block|,
literal|"    len = yytbl_calc_total_len (&td);"
block|,
literal|"    for (i = 0; i< len; ){"
block|,
literal|"        int    j;"
block|,
literal|""
block|,
literal|""
block|,
literal|"        /* This loop really executes exactly 1 or 2 times."
block|,
literal|"         * The second time is to handle the second member of the"
block|,
literal|"         * YYTD_STRUCT for the yy_transition array."
block|,
literal|"         */"
block|,
literal|"        for (j = 0; j< inner_loop_count; j++, i++) {"
block|,
literal|"            flex_int32_t t32;"
block|,
literal|""
block|,
literal|"            /* read into t32 no matter what the real size is. */"
block|,
literal|"            {"
block|,
literal|"            flex_int16_t t16;"
block|,
literal|"            flex_int8_t  t8;"
block|,
literal|""
block|,
literal|"            switch (YYTDFLAGS2BYTES (td.td_flags)) {"
block|,
literal|"            case sizeof (flex_int32_t):"
block|,
literal|"                rv = yytbl_read32 (&t32, rd);"
block|,
literal|"                break;"
block|,
literal|"            case sizeof (flex_int16_t):"
block|,
literal|"                rv = yytbl_read16 (&t16, rd);"
block|,
literal|"                t32 = t16;"
block|,
literal|"                break;"
block|,
literal|"            case sizeof (flex_int8_t):"
block|,
literal|"                rv = yytbl_read8 (&t8, rd);"
block|,
literal|"                t32 = t8;"
block|,
literal|"                break;"
block|,
literal|"            default: "
block|,
literal|"                YY_FATAL_ERROR( \"invalid td_flags\" );   /* TODO: not fatal. */"
block|,
literal|"                return -1;"
block|,
literal|"            }"
block|,
literal|"            }"
block|,
literal|"            if (rv != 0)"
block|,
literal|"                return -1;"
block|,
literal|""
block|,
literal|"            /* copy into the deserialized array... */"
block|,
literal|""
block|,
literal|"            if ((td.td_flags& YYTD_STRUCT)) {"
block|,
literal|"                /* t32 is the j'th member of a two-element struct. */"
block|,
literal|"                void   *v;"
block|,
literal|""
block|,
literal|"                v = j == 0 ?&(((struct yy_trans_info *) p)->yy_verify)"
block|,
literal|"                    :&(((struct yy_trans_info *) p)->yy_nxt);"
block|,
literal|""
block|,
literal|"                switch (dmap->dm_sz) {"
block|,
literal|"                case sizeof (flex_int32_t):"
block|,
literal|"                    if (M4_YY_TABLES_VERIFY){"
block|,
literal|"                        if( ((flex_int32_t *) v)[0] != (flex_int32_t) t32)"
block|,
literal|"                           YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int32_t\" );"
block|,
literal|"                    }else"
block|,
literal|"                        ((flex_int32_t *) v)[0] = (flex_int32_t) t32;"
block|,
literal|"                    break;"
block|,
literal|"                case sizeof (flex_int16_t):"
block|,
literal|"                    if (M4_YY_TABLES_VERIFY ){"
block|,
literal|"                        if(((flex_int16_t *) v)[0] != (flex_int16_t) t32)"
block|,
literal|"                        YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int16_t\" );"
block|,
literal|"                    }else"
block|,
literal|"                        ((flex_int16_t *) v)[0] = (flex_int16_t) t32;"
block|,
literal|"                    break;"
block|,
literal|"                case sizeof(flex_int8_t):"
block|,
literal|"                    if (M4_YY_TABLES_VERIFY ){"
block|,
literal|"                         if( ((flex_int8_t *) v)[0] != (flex_int8_t) t32)"
block|,
literal|"                        YY_FATAL_ERROR( \"tables verification failed at YYTD_STRUCT flex_int8_t\" );"
block|,
literal|"                    }else"
block|,
literal|"                        ((flex_int8_t *) v)[0] = (flex_int8_t) t32;"
block|,
literal|"                    break;"
block|,
literal|"                default:"
block|,
literal|"                    YY_FATAL_ERROR( \"invalid dmap->dm_sz for struct\" );   /* TODO: not fatal. */"
block|,
literal|"                    return -1;"
block|,
literal|"                }"
block|,
literal|""
block|,
literal|"                /* if we're done with j, increment p */"
block|,
literal|"                if (j == 1)"
block|,
literal|"                    p = (struct yy_trans_info *) p + 1;"
block|,
literal|"            }"
block|,
literal|"            else if ((td.td_flags& YYTD_PTRANS)) {"
block|,
literal|"                /* t32 is an index into the transition array. */"
block|,
literal|"                struct yy_trans_info *v;"
block|,
literal|""
block|,
literal|""
block|,
literal|"                if (!transdmap){"
block|,
literal|"                    YY_FATAL_ERROR( \"transition table not found\" );   /* TODO: not fatal. */"
block|,
literal|"                    return -1;"
block|,
literal|"                }"
block|,
literal|"                "
block|,
literal|"                if( M4_YY_TABLES_VERIFY)"
block|,
literal|"                    v =&(((struct yy_trans_info *) (transdmap->dm_arr))[t32]);"
block|,
literal|"                else"
block|,
literal|"                    v =&((*((struct yy_trans_info **) (transdmap->dm_arr)))[t32]);"
block|,
literal|""
block|,
literal|"                if(M4_YY_TABLES_VERIFY ){"
block|,
literal|"                    if( ((struct yy_trans_info **) p)[0] != v)"
block|,
literal|"                        YY_FATAL_ERROR( \"tables verification failed at YYTD_PTRANS\" );"
block|,
literal|"                }else"
block|,
literal|"                    ((struct yy_trans_info **) p)[0] = v;"
block|,
literal|"                "
block|,
literal|"                /* increment p */"
block|,
literal|"                p = (struct yy_trans_info **) p + 1;"
block|,
literal|"            }"
block|,
literal|"            else {"
block|,
literal|"                /* t32 is a plain int. copy data, then incrememnt p. */"
block|,
literal|"                switch (dmap->dm_sz) {"
block|,
literal|"                case sizeof (flex_int32_t):"
block|,
literal|"                    if(M4_YY_TABLES_VERIFY ){"
block|,
literal|"                        if( ((flex_int32_t *) p)[0] != (flex_int32_t) t32)"
block|,
literal|"                        YY_FATAL_ERROR( \"tables verification failed at flex_int32_t\" );"
block|,
literal|"                    }else"
block|,
literal|"                        ((flex_int32_t *) p)[0] = (flex_int32_t) t32;"
block|,
literal|"                    p = ((flex_int32_t *) p) + 1;"
block|,
literal|"                    break;"
block|,
literal|"                case sizeof (flex_int16_t):"
block|,
literal|"                    if(M4_YY_TABLES_VERIFY ){"
block|,
literal|"                        if( ((flex_int16_t *) p)[0] != (flex_int16_t) t32)"
block|,
literal|"                        YY_FATAL_ERROR( \"tables verification failed at flex_int16_t\" );"
block|,
literal|"                    }else"
block|,
literal|"                        ((flex_int16_t *) p)[0] = (flex_int16_t) t32;"
block|,
literal|"                    p = ((flex_int16_t *) p) + 1;"
block|,
literal|"                    break;"
block|,
literal|"                case sizeof (flex_int8_t):"
block|,
literal|"                    if(M4_YY_TABLES_VERIFY ){"
block|,
literal|"                        if( ((flex_int8_t *) p)[0] != (flex_int8_t) t32)"
block|,
literal|"                        YY_FATAL_ERROR( \"tables verification failed at flex_int8_t\" );"
block|,
literal|"                    }else"
block|,
literal|"                        ((flex_int8_t *) p)[0] = (flex_int8_t) t32;"
block|,
literal|"                    p = ((flex_int8_t *) p) + 1;"
block|,
literal|"                    break;"
block|,
literal|"                default:"
block|,
literal|"                    YY_FATAL_ERROR( \"invalid dmap->dm_sz for plain int\" );   /* TODO: not fatal. */"
block|,
literal|"                    return -1;"
block|,
literal|"                }"
block|,
literal|"            }"
block|,
literal|"        }"
block|,
literal|""
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    /* Now eat padding. */"
block|,
literal|"    {"
block|,
literal|"        int pad;"
block|,
literal|"        pad = yypad64(rd->bread);"
block|,
literal|"        while(--pad>= 0){"
block|,
literal|"            flex_int8_t t8;"
block|,
literal|"            if(yytbl_read8(&t8,rd) != 0)"
block|,
literal|"                return -1;"
block|,
literal|"        }"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"%define-yytables   The name for this specific scanner's tables."
block|,
literal|""
block|,
literal|"/* Find the key and load the DFA tables from the given stream.  */"
block|,
literal|"static int yytbl_fload YYFARGS2(FILE *, fp, const char *, key)"
block|,
literal|"{"
block|,
literal|"    int rv=0;"
block|,
literal|"    struct yytbl_hdr th;"
block|,
literal|"    struct yytbl_reader rd;"
block|,
literal|""
block|,
literal|"    rd.fp = fp;"
block|,
literal|"    th.th_version = NULL;"
block|,
literal|""
block|,
literal|"    /* Keep trying until we find the right set of tables or end of file. */"
block|,
literal|"    while (!feof(rd.fp)) {"
block|,
literal|"        rd.bread = 0;"
block|,
literal|"        if (yytbl_hdr_read (&th,&rd M4_YY_CALL_LAST_ARG) != 0){"
block|,
literal|"            rv = -1;"
block|,
literal|"            goto return_rv;"
block|,
literal|"        }"
block|,
literal|""
block|,
literal|"        /* A NULL key means choose the first set of tables. */"
block|,
literal|"        if (key == NULL)"
block|,
literal|"            break;"
block|,
literal|""
block|,
literal|"        if (strcmp(th.th_name,key) != 0){"
block|,
literal|"            /* Skip ahead to next set */"
block|,
literal|"            fseek(rd.fp, th.th_ssize - th.th_hsize, SEEK_CUR);"
block|,
literal|"            yyfree(th.th_version M4_YY_CALL_LAST_ARG);"
block|,
literal|"            th.th_version = NULL;"
block|,
literal|"        }"
block|,
literal|"        else"
block|,
literal|"            break;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    while (rd.bread< th.th_ssize){"
block|,
literal|"        /* Load the data tables */"
block|,
literal|"        if(yytbl_data_load (yydmap,&rd M4_YY_CALL_LAST_ARG) != 0){"
block|,
literal|"            rv = -1;"
block|,
literal|"            goto return_rv;"
block|,
literal|"        }"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"return_rv:"
block|,
literal|"    if(th.th_version){"
block|,
literal|"        yyfree(th.th_version M4_YY_CALL_LAST_ARG);"
block|,
literal|"        th.th_version = NULL;"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    return rv;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Load the DFA tables for this scanner from the given stream.  */"
block|,
literal|"int yytables_fload YYFARGS1(FILE *, fp)"
block|,
literal|"{"
block|,
literal|""
block|,
literal|"    if( yytbl_fload(fp, YYTABLES_NAME M4_YY_CALL_LAST_ARG) != 0)"
block|,
literal|"        return -1;"
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/** Destroy the loaded tables, freeing memory, etc.. */"
block|,
literal|"int yytables_destroy YYFARGS0(void)"
block|,
literal|"{   "
block|,
literal|"    struct yytbl_dmap *dmap=0;"
block|,
literal|""
block|,
literal|"    if(!M4_YY_TABLES_VERIFY){"
block|,
literal|"        /* Walk the dmap, freeing the pointers */"
block|,
literal|"        for(dmap=yydmap; dmap->dm_id; dmap++) {"
block|,
literal|"            void * v;"
block|,
literal|"            v = dmap->dm_arr;"
block|,
literal|"            if(v&& *(char**)v){"
block|,
literal|"                    yyfree(*(char**)v M4_YY_CALL_LAST_ARG);"
block|,
literal|"                    *(char**)v = NULL;"
block|,
literal|"            }"
block|,
literal|"        }"
block|,
literal|"    }"
block|,
literal|""
block|,
literal|"    return 0;"
block|,
literal|"}"
block|,
literal|""
block|,
literal|"/* end table serialization code definitions */"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|""
block|,
literal|"m4_ifdef([[M4_YY_MAIN]], [["
block|,
literal|"int main M4_YY_PARAMS(void);"
block|,
literal|""
block|,
literal|"int main ()"
block|,
literal|"{"
block|,
literal|""
block|,
literal|"%if-reentrant"
block|,
literal|"    yyscan_t lexer;"
block|,
literal|"    yylex_init(&lexer);"
block|,
literal|"    yylex( lexer );"
block|,
literal|"    yylex_destroy( lexer);"
block|,
literal|""
block|,
literal|"%endif"
block|,
literal|"%if-not-reentrant"
block|,
literal|"	yylex();"
block|,
literal|"%endif"
block|,
literal|""
block|,
literal|"	return 0;"
block|,
literal|"}"
block|,
literal|"]])"
block|,
literal|""
block|,
literal|"%ok-for-header"
block|,
literal|"m4_ifdef( [[M4_YY_IN_HEADER]],"
block|,
literal|"[["
block|,
literal|"#undef YY_NEW_FILE"
block|,
literal|"#undef YY_FLUSH_BUFFER"
block|,
literal|"#undef yy_set_bol"
block|,
literal|"#undef yy_new_buffer"
block|,
literal|"#undef yy_set_interactive"
block|,
literal|"#undef YY_DO_BEFORE_ACTION"
block|,
literal|""
block|,
literal|"#ifdef YY_DECL_IS_OURS"
block|,
literal|"#undef YY_DECL_IS_OURS"
block|,
literal|"#undef YY_DECL"
block|,
literal|"#endif"
block|,
literal|"]])"
block|,
literal|0
block|}
decl_stmt|;
end_decl_stmt

end_unit

