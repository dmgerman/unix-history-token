begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|/* gen - actual generation (writing) of flex scanners */
end_comment

begin_comment
comment|/*-  * Copyright (c) 1990 The Regents of the University of California.  * All rights reserved.  *  * This code is derived from software contributed to Berkeley by  * Vern Paxson.  *   * The United States Government has rights in this work pursuant  * to contract no. DE-AC03-76SF00098 between the United States  * Department of Energy and the University of California.  *  * Redistribution and use in source and binary forms are permitted provided  * that: (1) source distributions retain this entire copyright notice and  * comment, and (2) distributions including binaries display the following  * acknowledgement:  ``This product includes software developed by the  * University of California, Berkeley and its contributors'' in the  * documentation or other materials provided with the distribution and in  * all advertising materials mentioning features or use of this software.  * Neither the name of the University nor the names of its contributors may  * be used to endorse or promote products derived from this software without  * specific prior written permission.  * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED  * WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF  * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  */
end_comment

begin_comment
comment|/* $Header: /home/daffy/u0/vern/flex/RCS/gen.c,v 2.56 96/05/25 20:43:38 vern Exp $ */
end_comment

begin_include
include|#
directive|include
file|"flexdef.h"
end_include

begin_comment
comment|/* declare functions that have forward references */
end_comment

begin_decl_stmt
name|void
name|gen_next_state
name|PROTO
argument_list|(
operator|(
name|int
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|genecs
name|PROTO
argument_list|(
operator|(
name|void
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|indent_put2s
name|PROTO
argument_list|(
operator|(
name|char
index|[]
operator|,
name|char
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
name|void
name|indent_puts
name|PROTO
argument_list|(
operator|(
name|char
index|[]
operator|)
argument_list|)
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|int
name|indent_level
init|=
literal|0
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* each level is 8 spaces */
end_comment

begin_define
define|#
directive|define
name|indent_up
parameter_list|()
value|(++indent_level)
end_define

begin_define
define|#
directive|define
name|indent_down
parameter_list|()
value|(--indent_level)
end_define

begin_define
define|#
directive|define
name|set_indent
parameter_list|(
name|indent_val
parameter_list|)
value|indent_level = indent_val
end_define

begin_comment
comment|/* Almost everything is done in terms of arrays starting at 1, so provide  * a null entry for the zero element of all C arrays.  (The exception  * to this is that the fast table representation generally uses the  * 0 elements of its arrays, too.)  */
end_comment

begin_decl_stmt
specifier|static
name|char
name|C_int_decl
index|[]
init|=
literal|"static yyconst int %s[%d] =\n    {   0,\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|C_short_decl
index|[]
init|=
literal|"static yyconst short int %s[%d] =\n    {   0,\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|C_long_decl
index|[]
init|=
literal|"static yyconst long int %s[%d] =\n    {   0,\n"
decl_stmt|;
end_decl_stmt

begin_decl_stmt
specifier|static
name|char
name|C_state_decl
index|[]
init|=
literal|"static yyconst yy_state_type %s[%d] =\n    {   0,\n"
decl_stmt|;
end_decl_stmt

begin_comment
comment|/* Indent to the current level. */
end_comment

begin_function
name|void
name|do_indent
parameter_list|()
block|{
specifier|register
name|int
name|i
init|=
name|indent_level
operator|*
literal|8
decl_stmt|;
while|while
condition|(
name|i
operator|>=
literal|8
condition|)
block|{
name|outc
argument_list|(
literal|'\t'
argument_list|)
expr_stmt|;
name|i
operator|-=
literal|8
expr_stmt|;
block|}
while|while
condition|(
name|i
operator|>
literal|0
condition|)
block|{
name|outc
argument_list|(
literal|' '
argument_list|)
expr_stmt|;
operator|--
name|i
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the code to keep backing-up information. */
end_comment

begin_function
name|void
name|gen_backing_up
parameter_list|()
block|{
if|if
condition|(
name|reject
operator|||
name|num_backing_up
operator|==
literal|0
condition|)
return|return;
if|if
condition|(
name|fullspd
condition|)
name|indent_puts
argument_list|(
literal|"if ( yy_current_state[-1].yy_nxt )"
argument_list|)
expr_stmt|;
else|else
name|indent_puts
argument_list|(
literal|"if ( yy_accept[yy_current_state] )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_last_accepting_state = yy_current_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_last_accepting_cpos = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code to perform the backing up. */
end_comment

begin_function
name|void
name|gen_bu_action
parameter_list|()
block|{
if|if
condition|(
name|reject
operator|||
name|num_backing_up
operator|==
literal|0
condition|)
return|return;
name|set_indent
argument_list|(
literal|3
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"case 0: /* must back up */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"/* undo the effects of YY_DO_BEFORE_ACTION */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*yy_cp = yy_hold_char;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos + 1;"
argument_list|)
expr_stmt|;
else|else
comment|/* Backing-up info for compressed tables is taken \after/ 		 * yy_cp has been incremented for the next state. 		 */
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_last_accepting_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"goto yy_find_action;"
argument_list|)
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* genctbl - generates full speed compressed transition table */
end_comment

begin_function
name|void
name|genctbl
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
comment|/* Table of verify for transition and offset to next state. */
name|out_dec
argument_list|(
literal|"static yyconst struct yy_trans_info yy_transition[%d] =\n"
argument_list|,
name|tblend
operator|+
name|numecs
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
comment|/* We want the transition to be represented as the offset to the 	 * next state, not the actual state number, which is what it currently 	 * is.  The offset is base[nxt[i]] - (base of current state)].  That's 	 * just the difference between the starting points of the two involved 	 * states (to - from). 	 * 	 * First, though, we need to find some way to put in our end-of-buffer 	 * flags and states.  We do this by making a state with absolutely no 	 * transitions.  We put it at the end of the table. 	 */
comment|/* We need to have room in nxt/chk for two more slots: One for the 	 * action and one for the end-of-buffer transition.  We now *assume* 	 * that we're guaranteed the only character we'll try to index this 	 * nxt/chk pair with is EOB, i.e., 0, so we don't have to make sure 	 * there's room for jam entries for other characters. 	 */
while|while
condition|(
name|tblend
operator|+
literal|2
operator|>=
name|current_max_xpairs
condition|)
name|expand_nxt_chk
argument_list|()
expr_stmt|;
while|while
condition|(
name|lastdfa
operator|+
literal|1
operator|>=
name|current_max_dfas
condition|)
name|increase_max_dfas
argument_list|()
expr_stmt|;
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|=
name|tblend
operator|+
literal|2
expr_stmt|;
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|end_of_buffer_action
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
operator|=
name|numecs
operator|+
literal|1
expr_stmt|;
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|1
expr_stmt|;
comment|/* anything but EOB */
comment|/* So that "make test" won't show arb. differences. */
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
operator|=
literal|0
expr_stmt|;
comment|/* Make sure every state has an end-of-buffer transition and an 	 * action #. 	 */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|int
name|offset
init|=
name|base
index|[
name|i
index|]
decl_stmt|;
name|chk
index|[
name|offset
index|]
operator|=
name|EOB_POSITION
expr_stmt|;
name|chk
index|[
name|offset
operator|-
literal|1
index|]
operator|=
name|ACTION_POSITION
expr_stmt|;
name|nxt
index|[
name|offset
operator|-
literal|1
index|]
operator|=
name|anum
expr_stmt|;
comment|/* action number */
block|}
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|EOB_POSITION
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
name|base
index|[
name|lastdfa
operator|+
literal|1
index|]
operator|-
name|i
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
name|ACTION_POSITION
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
name|nxt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|>
name|numecs
operator|||
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|transition_struct_out
argument_list|(
literal|0
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* unused slot */
else|else
comment|/* verify, transition */
name|transition_struct_out
argument_list|(
name|chk
index|[
name|i
index|]
argument_list|,
name|base
index|[
name|nxt
index|[
name|i
index|]
index|]
operator|-
operator|(
name|i
operator|-
name|chk
index|[
name|i
index|]
operator|)
argument_list|)
expr_stmt|;
block|}
comment|/* Here's the final, end-of-buffer state. */
name|transition_struct_out
argument_list|(
name|chk
index|[
name|tblend
operator|+
literal|1
index|]
argument_list|,
name|nxt
index|[
name|tblend
operator|+
literal|1
index|]
argument_list|)
expr_stmt|;
name|transition_struct_out
argument_list|(
name|chk
index|[
name|tblend
operator|+
literal|2
index|]
argument_list|,
name|nxt
index|[
name|tblend
operator|+
literal|2
index|]
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"    };\n"
argument_list|)
expr_stmt|;
comment|/* Table of pointers to start states. */
name|out_dec
argument_list|(
literal|"static yyconst struct yy_trans_info *yy_start_state_list[%d] =\n"
argument_list|,
name|lastsc
operator|*
literal|2
operator|+
literal|1
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"    {"
argument_list|)
expr_stmt|;
comment|/* } so vi doesn't get confused */
for|for
control|(
name|i
operator|=
literal|0
init|;
name|i
operator|<=
name|lastsc
operator|*
literal|2
condition|;
operator|++
name|i
control|)
name|out_dec
argument_list|(
literal|"&yy_transition[%d],\n"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate equivalence-class tables. */
end_comment

begin_function
name|void
name|genecs
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|,
name|j
decl_stmt|;
name|int
name|numrows
decl_stmt|;
name|out_str_dec
argument_list|(
name|C_int_decl
argument_list|,
literal|"yy_ec"
argument_list|,
name|csize
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|csize
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|caseins
operator|&&
operator|(
name|i
operator|>=
literal|'A'
operator|)
operator|&&
operator|(
name|i
operator|<=
literal|'Z'
operator|)
condition|)
name|ecgroup
index|[
name|i
index|]
operator|=
name|ecgroup
index|[
name|clower
argument_list|(
name|i
argument_list|)
index|]
expr_stmt|;
name|ecgroup
index|[
name|i
index|]
operator|=
name|ABS
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|mkdata
argument_list|(
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\n\nEquivalence Classes:\n\n"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|numrows
operator|=
name|csize
operator|/
literal|8
expr_stmt|;
for|for
control|(
name|j
operator|=
literal|0
init|;
name|j
operator|<
name|numrows
condition|;
operator|++
name|j
control|)
block|{
for|for
control|(
name|i
operator|=
name|j
init|;
name|i
operator|<
name|csize
condition|;
name|i
operator|=
name|i
operator|+
name|numrows
control|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%4s = %-2d"
argument_list|,
name|readable_form
argument_list|(
name|i
argument_list|)
argument_list|,
name|ecgroup
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|putc
argument_list|(
literal|' '
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the code to find the action number. */
end_comment

begin_function
name|void
name|gen_find_action
parameter_list|()
block|{
if|if
condition|(
name|fullspd
condition|)
name|indent_puts
argument_list|(
literal|"yy_act = yy_current_state[-1].yy_nxt;"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|reject
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = *--yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_lp = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"find_rule: /* we branch to this label when backing up */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"for ( ; ; ) /* until we find what rule we matched */"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_lp&& yy_lp< yy_accept[yy_current_state + 1] )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act = yy_acclist[yy_lp];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_act& YY_TRAILING_HEAD_MASK ||"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"     yy_looking_for_trail_begin )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_act == yy_looking_for_trail_begin )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_looking_for_trail_begin = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act&= ~YY_TRAILING_HEAD_MASK;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else if ( yy_act& YY_TRAILING_MASK )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_looking_for_trail_begin = yy_act& ~YY_TRAILING_MASK;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_looking_for_trail_begin |= YY_TRAILING_HEAD_MASK;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|real_reject
condition|)
block|{
comment|/* Remember matched text in case we back up 				 * due to REJECT. 				 */
name|indent_puts
argument_list|(
literal|"yy_full_match = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_state = yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_lp = yy_lp;"
argument_list|)
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_match = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_state = yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_lp = yy_lp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yy_lp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"goto find_rule;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* Remember matched text in case we back up due to 			 * trailing context plus REJECT. 			 */
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_full_match = yy_cp;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"break;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"--yy_cp;"
argument_list|)
expr_stmt|;
comment|/* We could consolidate the following two lines with those at 		 * the beginning, but at the cost of complaints that we're 		 * branching inside a loop. 		 */
name|indent_puts
argument_list|(
literal|"yy_current_state = *--yy_state_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_lp = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
else|else
block|{
comment|/* compressed */
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|interactive
operator|&&
operator|!
name|reject
condition|)
block|{
comment|/* Do the guaranteed-needed backing up to figure out 			 * the match. 			 */
name|indent_puts
argument_list|(
literal|"if ( yy_act == 0 )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{ /* have to back up */"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_last_accepting_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_act = yy_accept[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* genftbl - generate full transition table */
end_comment

begin_function
name|void
name|genftbl
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_accept"
argument_list|,
name|lastdfa
operator|+
literal|1
argument_list|)
expr_stmt|;
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_state
operator|=
name|end_of_buffer_action
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|int
name|anum
init|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
decl_stmt|;
name|mkdata
argument_list|(
name|anum
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
operator|&&
name|anum
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %d accepts: [%d]\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|anum
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
comment|/* Don't have to dump the actual full table entries - they were 	 * created on-the-fly. 	 */
block|}
end_function

begin_comment
comment|/* Generate the code to find the next compressed-table state. */
end_comment

begin_function
name|void
name|gen_next_compressed_state
parameter_list|(
name|char_map
parameter_list|)
name|char
modifier|*
name|char_map
decl_stmt|;
block|{
name|indent_put2s
argument_list|(
literal|"register YY_CHAR yy_c = %s;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
comment|/* Save the backing-up info \before/ computing the next state 	 * because we always compute one more state than needed - we 	 * always proceed until we reach a jam state 	 */
name|gen_backing_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = (int) yy_def[yy_current_state];"
argument_list|)
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* We've arrange it so that templates are never chained 		 * to one another.  This means we can afford to make a 		 * very simple test to see if we need to convert to 		 * yy_c's meta-equivalence class without worrying 		 * about erroneously looking up the meta-equivalence 		 * class twice 		 */
name|do_indent
argument_list|()
expr_stmt|;
comment|/* lastdfa + 2 is the beginning of the templates */
name|out_dec
argument_list|(
literal|"if ( yy_current_state>= %d )\n"
argument_list|,
name|lastdfa
operator|+
literal|2
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_c = yy_meta[(unsigned int) yy_c];"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code to find the next match. */
end_comment

begin_function
name|void
name|gen_next_match
parameter_list|()
block|{
comment|/* NOTE - changes in here should be reflected in gen_next_state() and 	 * gen_NUL_trans(). 	 */
name|char
modifier|*
name|char_map
init|=
name|useecs
condition|?
literal|"yy_ec[YY_SC_TO_UI(*yy_cp)]"
else|:
literal|"YY_SC_TO_UI(*yy_cp)"
decl_stmt|;
name|char
modifier|*
name|char_map_2
init|=
name|useecs
condition|?
literal|"yy_ec[YY_SC_TO_UI(*++yy_cp)]"
else|:
literal|"YY_SC_TO_UI(*++yy_cp)"
decl_stmt|;
if|if
condition|(
name|fulltbl
condition|)
block|{
name|indent_put2s
argument_list|(
literal|"while ( (yy_current_state = yy_nxt[yy_current_state][%s])> 0 )"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
block|{
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|/* } for vi */
name|gen_backing_up
argument_list|()
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"++yy_cp;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
comment|/* { for vi */
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = -yy_current_state;"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
block|{
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|/* } for vi */
name|indent_puts
argument_list|(
literal|"register yyconst struct yy_trans_info *yy_trans_info;\n"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"register YY_CHAR yy_c;\n"
argument_list|)
expr_stmt|;
name|indent_put2s
argument_list|(
literal|"for ( yy_c = %s;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"      (yy_trans_info =&yy_current_state[(unsigned int) yy_c])->"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_verify == yy_c;"
argument_list|)
expr_stmt|;
name|indent_put2s
argument_list|(
literal|"      yy_c = %s )"
argument_list|,
name|char_map_2
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|/* } for vi */
name|indent_puts
argument_list|(
literal|"yy_current_state += yy_trans_info->yy_nxt;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|num_backing_up
operator|>
literal|0
condition|)
block|{
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|gen_backing_up
argument_list|()
expr_stmt|;
comment|/* { for vi */
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
comment|/* { for vi */
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
comment|/* compressed */
name|indent_puts
argument_list|(
literal|"do"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|/* } for vi */
name|gen_next_state
argument_list|(
name|false
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yy_cp;"
argument_list|)
expr_stmt|;
comment|/* { for vi */
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
if|if
condition|(
name|interactive
condition|)
name|out_dec
argument_list|(
literal|"while ( yy_base[yy_current_state] != %d );\n"
argument_list|,
name|jambase
argument_list|)
expr_stmt|;
else|else
name|out_dec
argument_list|(
literal|"while ( yy_current_state != %d );\n"
argument_list|,
name|jamstate
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reject
operator|&&
operator|!
name|interactive
condition|)
block|{
comment|/* Do the guaranteed-needed backing up to figure out 			 * the match. 			 */
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_last_accepting_state;"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* Generate the code to find the next state. */
end_comment

begin_function
name|void
name|gen_next_state
parameter_list|(
name|worry_about_NULs
parameter_list|)
name|int
name|worry_about_NULs
decl_stmt|;
block|{
comment|/* NOTE - changes in here should be reflected in gen_next_match() */
name|char
name|char_map
index|[
literal|256
index|]
decl_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
operator|!
name|nultrans
condition|)
block|{
if|if
condition|(
name|useecs
condition|)
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|char_map
argument_list|,
literal|"(*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : %d)"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
else|else
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|char_map
argument_list|,
literal|"(*yy_cp ? YY_SC_TO_UI(*yy_cp) : %d)"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
block|}
else|else
name|strcpy
argument_list|(
name|char_map
argument_list|,
name|useecs
condition|?
literal|"yy_ec[YY_SC_TO_UI(*yy_cp)]"
else|:
literal|"YY_SC_TO_UI(*yy_cp)"
argument_list|)
expr_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
name|nultrans
condition|)
block|{
if|if
condition|(
operator|!
name|fulltbl
operator|&&
operator|!
name|fullspd
condition|)
comment|/* Compressed tables back up *before* they match. */
name|gen_backing_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( *yy_cp )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|/* } for vi */
block|}
if|if
condition|(
name|fulltbl
condition|)
name|indent_put2s
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state][%s];"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
elseif|else
if|if
condition|(
name|fullspd
condition|)
name|indent_put2s
argument_list|(
literal|"yy_current_state += yy_current_state[%s].yy_nxt;"
argument_list|,
name|char_map
argument_list|)
expr_stmt|;
else|else
name|gen_next_compressed_state
argument_list|(
name|char_map
argument_list|)
expr_stmt|;
if|if
condition|(
name|worry_about_NULs
operator|&&
name|nultrans
condition|)
block|{
comment|/* { for vi */
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_NUL_trans[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|gen_backing_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|reject
condition|)
name|indent_puts
argument_list|(
literal|"*yy_state_ptr++ = yy_current_state;"
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Generate the code to make a NUL transition. */
end_comment

begin_function
name|void
name|gen_NUL_trans
parameter_list|()
block|{
comment|/* NOTE - changes in here should be reflected in gen_next_match() */
comment|/* Only generate a definition for "yy_cp" if we'll generate code 	 * that uses it.  Otherwise lint and the like complain. 	 */
name|int
name|need_backing_up
init|=
operator|(
name|num_backing_up
operator|>
literal|0
operator|&&
operator|!
name|reject
operator|)
decl_stmt|;
if|if
condition|(
name|need_backing_up
operator|&&
operator|(
operator|!
name|nultrans
operator|||
name|fullspd
operator|||
name|fulltbl
operator|)
condition|)
comment|/* We're going to need yy_cp lying around for the call 		 * below to gen_backing_up(). 		 */
name|indent_puts
argument_list|(
literal|"register char *yy_cp = yy_c_buf_p;"
argument_list|)
expr_stmt|;
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
if|if
condition|(
name|nultrans
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_NUL_trans[yy_current_state];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_current_state == 0);"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fulltbl
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"yy_current_state = yy_nxt[yy_current_state][%d];\n"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_current_state<= 0);"
argument_list|)
expr_stmt|;
block|}
elseif|else
if|if
condition|(
name|fullspd
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"register int yy_c = %d;\n"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"register yyconst struct yy_trans_info *yy_trans_info;\n"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_trans_info =&yy_current_state[(unsigned int) yy_c];"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state += yy_trans_info->yy_nxt;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_is_jam = (yy_trans_info->yy_verify != yy_c);"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|char
name|NUL_ec_str
index|[
literal|20
index|]
decl_stmt|;
operator|(
name|void
operator|)
name|sprintf
argument_list|(
name|NUL_ec_str
argument_list|,
literal|"%d"
argument_list|,
name|NUL_ec
argument_list|)
expr_stmt|;
name|gen_next_compressed_state
argument_list|(
name|NUL_ec_str
argument_list|)
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"yy_is_jam = (yy_current_state == %d);\n"
argument_list|,
name|jamstate
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Only stack this state if it's a transition we 			 * actually make.  If we stack it on a jam, then 			 * the state stack and yy_c_buf_p get out of sync. 			 */
name|indent_puts
argument_list|(
literal|"if ( ! yy_is_jam )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*yy_state_ptr++ = yy_current_state;"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
comment|/* If we've entered an accepting state, back up; note that 	 * compressed tables have *already* done such backing up, so 	 * we needn't bother with it again. 	 */
if|if
condition|(
name|need_backing_up
operator|&&
operator|(
name|fullspd
operator|||
name|fulltbl
operator|)
condition|)
block|{
name|outc
argument_list|(
literal|'\n'
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( ! yy_is_jam )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|gen_backing_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
end_function

begin_comment
comment|/* Generate the code to find the start state. */
end_comment

begin_function
name|void
name|gen_start_state
parameter_list|()
block|{
if|if
condition|(
name|fullspd
condition|)
block|{
if|if
condition|(
name|bol_needed
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_start_state_list[yy_start + YY_AT_BOL()];"
argument_list|)
expr_stmt|;
block|}
else|else
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_start_state_list[yy_start];"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_start;"
argument_list|)
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
name|indent_puts
argument_list|(
literal|"yy_current_state += YY_AT_BOL();"
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Set up for storing up states. */
name|indent_puts
argument_list|(
literal|"yy_state_ptr = yy_state_buf;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"*yy_state_ptr++ = yy_current_state;"
argument_list|)
expr_stmt|;
block|}
block|}
block|}
end_function

begin_comment
comment|/* gentabs - generate data statements for the transition tables */
end_comment

begin_function
name|void
name|gentabs
parameter_list|()
block|{
name|int
name|i
decl_stmt|,
name|j
decl_stmt|,
name|k
decl_stmt|,
modifier|*
name|accset
decl_stmt|,
name|nacc
decl_stmt|,
modifier|*
name|acc_array
decl_stmt|,
name|total_states
decl_stmt|;
name|int
name|end_of_buffer_action
init|=
name|num_rules
operator|+
literal|1
decl_stmt|;
name|acc_array
operator|=
name|allocate_integer_array
argument_list|(
name|current_max_dfas
argument_list|)
expr_stmt|;
name|nummt
operator|=
literal|0
expr_stmt|;
comment|/* The compressed table format jams by entering the "jam state", 	 * losing information about the previous state in the process. 	 * In order to recover the previous state, we effectively need 	 * to keep backing-up information. 	 */
operator|++
name|num_backing_up
expr_stmt|;
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Write out accepting list and pointer list. 		 * 		 * First we generate the "yy_acclist" array.  In the process, 		 * we compute the indices that will go into the "yy_accept" 		 * array, and save the indices in the dfaacc array. 		 */
name|int
name|EOB_accepting_list
index|[
literal|2
index|]
decl_stmt|;
comment|/* Set up accepting structures for the End Of Buffer state. */
name|EOB_accepting_list
index|[
literal|0
index|]
operator|=
literal|0
expr_stmt|;
name|EOB_accepting_list
index|[
literal|1
index|]
operator|=
name|end_of_buffer_action
expr_stmt|;
name|accsiz
index|[
name|end_of_buffer_state
index|]
operator|=
literal|1
expr_stmt|;
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_set
operator|=
name|EOB_accepting_list
expr_stmt|;
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_acclist"
argument_list|,
name|MAX
argument_list|(
name|numas
argument_list|,
literal|1
argument_list|)
operator|+
literal|1
argument_list|)
expr_stmt|;
name|j
operator|=
literal|1
expr_stmt|;
comment|/* index into "yy_acclist" array */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|acc_array
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
if|if
condition|(
name|accsiz
index|[
name|i
index|]
operator|!=
literal|0
condition|)
block|{
name|accset
operator|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_set
expr_stmt|;
name|nacc
operator|=
name|accsiz
index|[
name|i
index|]
expr_stmt|;
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %d accepts: "
argument_list|)
argument_list|,
name|i
argument_list|)
expr_stmt|;
for|for
control|(
name|k
operator|=
literal|1
init|;
name|k
operator|<=
name|nacc
condition|;
operator|++
name|k
control|)
block|{
name|int
name|accnum
init|=
name|accset
index|[
name|k
index|]
decl_stmt|;
operator|++
name|j
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
operator|&&
operator|!
operator|(
name|accnum
operator|&
name|YY_TRAILING_HEAD_MASK
operator|)
operator|&&
name|accnum
operator|>
literal|0
operator|&&
name|accnum
operator|<=
name|num_rules
operator|&&
name|rule_type
index|[
name|accnum
index|]
operator|==
name|RULE_VARIABLE
condition|)
block|{
comment|/* Special hack to flag 						 * accepting number as part 						 * of trailing context rule. 						 */
name|accnum
operator||=
name|YY_TRAILING_MASK
expr_stmt|;
block|}
name|mkdata
argument_list|(
name|accnum
argument_list|)
expr_stmt|;
if|if
condition|(
name|trace
condition|)
block|{
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"[%d]"
argument_list|,
name|accset
index|[
name|k
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|k
operator|<
name|nacc
condition|)
name|fputs
argument_list|(
literal|", "
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
else|else
name|putc
argument_list|(
literal|'\n'
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
block|}
block|}
block|}
block|}
comment|/* add accepting number for the "jam" state */
name|acc_array
index|[
name|i
index|]
operator|=
name|j
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|dfaacc
index|[
name|end_of_buffer_state
index|]
operator|.
name|dfaacc_state
operator|=
name|end_of_buffer_action
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
name|acc_array
index|[
name|i
index|]
operator|=
name|dfaacc
index|[
name|i
index|]
operator|.
name|dfaacc_state
expr_stmt|;
comment|/* add accepting number for jam state */
name|acc_array
index|[
name|i
index|]
operator|=
literal|0
expr_stmt|;
block|}
comment|/* Spit out "yy_accept" array.  If we're doing "reject", it'll be 	 * pointers into the "yy_acclist" array.  Otherwise it's actual 	 * accepting numbers.  In either case, we just dump the numbers. 	 */
comment|/* "lastdfa + 2" is the size of "yy_accept"; includes room for C arrays 	 * beginning at 0 and for "jam" state. 	 */
name|k
operator|=
name|lastdfa
operator|+
literal|2
expr_stmt|;
if|if
condition|(
name|reject
condition|)
comment|/* We put a "cap" on the table associating lists of accepting 		 * numbers with state numbers.  This is needed because we tell 		 * where the end of an accepting list is by looking at where 		 * the list for the next state starts. 		 */
operator|++
name|k
expr_stmt|;
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_accept"
argument_list|,
name|k
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
operator|!
name|reject
operator|&&
name|trace
operator|&&
name|acc_array
index|[
name|i
index|]
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
name|_
argument_list|(
literal|"state # %d accepts: [%d]\n"
argument_list|)
argument_list|,
name|i
argument_list|,
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Add entry for "jam" state. */
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
if|if
condition|(
name|reject
condition|)
comment|/* Add "cap" for the list. */
name|mkdata
argument_list|(
name|acc_array
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
if|if
condition|(
name|useecs
condition|)
name|genecs
argument_list|()
expr_stmt|;
if|if
condition|(
name|usemecs
condition|)
block|{
comment|/* Write out meta-equivalence classes (used to index 		 * templates with). 		 */
if|if
condition|(
name|trace
condition|)
name|fputs
argument_list|(
name|_
argument_list|(
literal|"\n\nMeta-Equivalence Classes:\n"
argument_list|)
argument_list|,
name|stderr
argument_list|)
expr_stmt|;
name|out_str_dec
argument_list|(
name|C_int_decl
argument_list|,
literal|"yy_meta"
argument_list|,
name|numecs
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|numecs
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|trace
condition|)
name|fprintf
argument_list|(
name|stderr
argument_list|,
literal|"%d = %d\n"
argument_list|,
name|i
argument_list|,
name|ABS
argument_list|(
name|tecbck
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
name|mkdata
argument_list|(
name|ABS
argument_list|(
name|tecbck
index|[
name|i
index|]
argument_list|)
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
block|}
name|total_states
operator|=
name|lastdfa
operator|+
name|numtemps
expr_stmt|;
name|out_str_dec
argument_list|(
operator|(
name|tblend
operator|>=
name|MAX_SHORT
operator|||
name|long_align
operator|)
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_base"
argument_list|,
name|total_states
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
specifier|register
name|int
name|d
init|=
name|def
index|[
name|i
index|]
decl_stmt|;
if|if
condition|(
name|base
index|[
name|i
index|]
operator|==
name|JAMSTATE
condition|)
name|base
index|[
name|i
index|]
operator|=
name|jambase
expr_stmt|;
if|if
condition|(
name|d
operator|==
name|JAMSTATE
condition|)
name|def
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
elseif|else
if|if
condition|(
name|d
operator|<
literal|0
condition|)
block|{
comment|/* Template reference. */
operator|++
name|tmpuses
expr_stmt|;
name|def
index|[
name|i
index|]
operator|=
name|lastdfa
operator|-
name|d
operator|+
literal|1
expr_stmt|;
block|}
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
comment|/* Generate jam state's base index. */
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
for|for
control|(
operator|++
name|i
comment|/* skip jam state */
init|;
name|i
operator|<=
name|total_states
condition|;
operator|++
name|i
control|)
block|{
name|mkdata
argument_list|(
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|def
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
name|out_str_dec
argument_list|(
operator|(
name|total_states
operator|>=
name|MAX_SHORT
operator|||
name|long_align
operator|)
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_def"
argument_list|,
name|total_states
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|total_states
condition|;
operator|++
name|i
control|)
name|mkdata
argument_list|(
name|def
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
name|out_str_dec
argument_list|(
operator|(
name|total_states
operator|>=
name|MAX_SHORT
operator|||
name|long_align
operator|)
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_nxt"
argument_list|,
name|tblend
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
comment|/* Note, the order of the following test is important. 		 * If chk[i] is 0, then nxt[i] is undefined. 		 */
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
literal|0
operator|||
name|nxt
index|[
name|i
index|]
operator|==
literal|0
condition|)
name|nxt
index|[
name|i
index|]
operator|=
name|jamstate
expr_stmt|;
comment|/* new state is the JAM state */
name|mkdata
argument_list|(
name|nxt
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
name|out_str_dec
argument_list|(
operator|(
name|total_states
operator|>=
name|MAX_SHORT
operator|||
name|long_align
operator|)
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_chk"
argument_list|,
name|tblend
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|tblend
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|chk
index|[
name|i
index|]
operator|==
literal|0
condition|)
operator|++
name|nummt
expr_stmt|;
name|mkdata
argument_list|(
name|chk
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
block|}
end_function

begin_comment
comment|/* Write out a formatted string (with a secondary string argument) at the  * current indentation level, adding a final newline.  */
end_comment

begin_decl_stmt
name|void
name|indent_put2s
argument_list|(
name|fmt
argument_list|,
name|arg
argument_list|)
name|char
name|fmt
index|[]
decl_stmt|,
name|arg
index|[]
decl_stmt|;
end_decl_stmt

begin_block
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|out_str
argument_list|(
name|fmt
argument_list|,
name|arg
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|""
argument_list|)
expr_stmt|;
block|}
end_block

begin_comment
comment|/* Write out a string at the current indentation level, adding a final  * newline.  */
end_comment

begin_function
name|void
name|indent_puts
parameter_list|(
name|str
parameter_list|)
name|char
name|str
index|[]
decl_stmt|;
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|outn
argument_list|(
name|str
argument_list|)
expr_stmt|;
block|}
end_function

begin_comment
comment|/* make_tables - generate transition tables and finishes generating output file  */
end_comment

begin_function
name|void
name|make_tables
parameter_list|()
block|{
specifier|register
name|int
name|i
decl_stmt|;
name|int
name|did_eof_rule
init|=
name|false
decl_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* First, take care of YY_DO_BEFORE_ACTION depending on yymore 	 * being used. 	 */
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
operator|&&
operator|!
name|yytext_is_array
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yytext_ptr -= yy_more_len; \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyleng = (int) (yy_cp - yytext_ptr); \\"
argument_list|)
expr_stmt|;
block|}
else|else
name|indent_puts
argument_list|(
literal|"yyleng = (int) (yy_cp - yy_bp); \\"
argument_list|)
expr_stmt|;
comment|/* Now also deal with copying yytext_ptr to yytext if needed. */
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|yytext_is_array
condition|)
block|{
if|if
condition|(
name|yymore_used
condition|)
name|indent_puts
argument_list|(
literal|"if ( yyleng + yy_more_offset>= YYLMAX ) \\"
argument_list|)
expr_stmt|;
else|else
name|indent_puts
argument_list|(
literal|"if ( yyleng>= YYLMAX ) \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"YY_FATAL_ERROR( \"token too large, exceeds YYLMAX\" ); \\"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
if|if
condition|(
name|yymore_used
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_flex_strncpy(&yytext[yy_more_offset], yytext_ptr, yyleng + 1 ); \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyleng += yy_more_offset; \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_prev_more_offset = yy_more_offset; \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_more_offset = 0; \\"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"yy_flex_strncpy( yytext, yytext_ptr, yyleng + 1 ); \\"
argument_list|)
expr_stmt|;
block|}
block|}
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"#define YY_NUM_RULES %d\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|out_dec
argument_list|(
literal|"#define YY_END_OF_BUFFER %d\n"
argument_list|,
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
condition|)
block|{
comment|/* Need to define the transet type as a size large 		 * enough to hold the biggest offset. 		 */
name|int
name|total_table_size
init|=
name|tblend
operator|+
name|numecs
operator|+
literal|1
decl_stmt|;
name|char
modifier|*
name|trans_offset_type
init|=
operator|(
name|total_table_size
operator|>=
name|MAX_SHORT
operator|||
name|long_align
operator|)
condition|?
literal|"long"
else|:
literal|"short"
decl_stmt|;
name|set_indent
argument_list|(
literal|0
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"struct yy_trans_info"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
comment|/* } for vi */
if|if
condition|(
name|long_align
condition|)
name|indent_puts
argument_list|(
literal|"long yy_verify;"
argument_list|)
expr_stmt|;
else|else
name|indent_puts
argument_list|(
literal|"short yy_verify;"
argument_list|)
expr_stmt|;
comment|/* In cases where its sister yy_verify *is* a "yes, there is 		 * a transition", yy_nxt is the offset (in records) to the 		 * next state.  In most cases where there is no transition, 		 * the value of yy_nxt is irrelevant.  If yy_nxt is the -1th 		 * record of a state, though, then yy_nxt is the action number 		 * for that state. 		 */
name|indent_put2s
argument_list|(
literal|"%s yy_nxt;"
argument_list|,
name|trans_offset_type
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"};"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|fullspd
condition|)
name|genctbl
argument_list|()
expr_stmt|;
elseif|else
if|if
condition|(
name|fulltbl
condition|)
name|genftbl
argument_list|()
expr_stmt|;
else|else
name|gentabs
argument_list|()
expr_stmt|;
comment|/* Definitions for backing up.  We don't need them if REJECT 	 * is being used because then we use an alternative backin-up 	 * technique instead. 	 */
if|if
condition|(
name|num_backing_up
operator|>
literal|0
operator|&&
operator|!
name|reject
condition|)
block|{
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"static yy_state_type yy_last_accepting_state;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static char *yy_last_accepting_cpos;\n"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|nultrans
condition|)
block|{
name|out_str_dec
argument_list|(
name|C_state_decl
argument_list|,
literal|"yy_NUL_trans"
argument_list|,
name|lastdfa
operator|+
literal|1
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastdfa
condition|;
operator|++
name|i
control|)
block|{
if|if
condition|(
name|fullspd
condition|)
name|out_dec
argument_list|(
literal|"&yy_transition[%d],\n"
argument_list|,
name|base
index|[
name|i
index|]
argument_list|)
expr_stmt|;
else|else
name|mkdata
argument_list|(
name|nultrans
index|[
name|i
index|]
argument_list|)
expr_stmt|;
block|}
name|dataend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|ddebug
condition|)
block|{
comment|/* Spit out table mapping rules to line numbers. */
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"extern int yy_flex_debug;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"int yy_flex_debug = 1;\n"
argument_list|)
expr_stmt|;
block|}
name|out_str_dec
argument_list|(
name|long_align
condition|?
name|C_long_decl
else|:
name|C_short_decl
argument_list|,
literal|"yy_rule_linenum"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<
name|num_rules
condition|;
operator|++
name|i
control|)
name|mkdata
argument_list|(
name|rule_linenum
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|dataend
argument_list|()
expr_stmt|;
block|}
if|if
condition|(
name|reject
condition|)
block|{
comment|/* Declare state buffer variables. */
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
name|outn
argument_list|(
literal|"static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static char *yy_full_match;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static int yy_lp;"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
name|outn
argument_list|(
literal|"static int yy_looking_for_trail_begin = 0;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static int yy_full_lp;"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"static int *yy_full_state;"
argument_list|)
expr_stmt|;
block|}
name|out_hex
argument_list|(
literal|"#define YY_TRAILING_MASK 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|YY_TRAILING_MASK
argument_list|)
expr_stmt|;
name|out_hex
argument_list|(
literal|"#define YY_TRAILING_HEAD_MASK 0x%x\n"
argument_list|,
operator|(
name|unsigned
name|int
operator|)
name|YY_TRAILING_HEAD_MASK
argument_list|)
expr_stmt|;
block|}
name|outn
argument_list|(
literal|"#define REJECT \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"{ \\"
argument_list|)
expr_stmt|;
comment|/* } for vi */
name|outn
argument_list|(
literal|"*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"yy_cp = yy_full_match; /* restore poss. backed-over text */ \\"
argument_list|)
expr_stmt|;
if|if
condition|(
name|variable_trailing_context_rules
condition|)
block|{
name|outn
argument_list|(
literal|"yy_lp = yy_full_lp; /* restore orig. accepting pos. */ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"yy_state_ptr = yy_full_state; /* restore orig. state */ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"yy_current_state = *yy_state_ptr; /* restore curr. state */ \\"
argument_list|)
expr_stmt|;
block|}
name|outn
argument_list|(
literal|"++yy_lp; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"goto find_rule; \\"
argument_list|)
expr_stmt|;
comment|/* { for vi */
name|outn
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outn
argument_list|(
literal|"/* The intent behind this definition is that it'll catch"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|" * any uses of REJECT which flex missed."
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|" */"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define REJECT reject_used_but_not_detected"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
name|yymore_used
condition|)
block|{
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
if|if
condition|(
name|yytext_is_array
condition|)
block|{
name|indent_puts
argument_list|(
literal|"static int yy_more_offset = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static int yy_prev_more_offset = 0;"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"static int yy_more_flag = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"static int yy_more_len = 0;"
argument_list|)
expr_stmt|;
block|}
block|}
if|if
condition|(
name|yytext_is_array
condition|)
block|{
name|indent_puts
argument_list|(
literal|"#define yymore() (yy_more_offset = yy_flex_strlen( yytext ))"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_NEED_STRLEN"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ 0"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_RESTORE_YY_MORE_OFFSET \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{ \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_more_offset = yy_prev_more_offset; \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyleng -= yy_more_offset; \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"#define yymore() (yy_more_flag = 1)"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ yy_more_len"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_RESTORE_YY_MORE_OFFSET"
argument_list|)
expr_stmt|;
block|}
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"#define yymore() yymore_used_but_not_detected"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_MORE_ADJ 0"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_RESTORE_YY_MORE_OFFSET"
argument_list|)
expr_stmt|;
block|}
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
if|if
condition|(
name|yytext_is_array
condition|)
block|{
name|outn
argument_list|(
literal|"#ifndef YYLMAX"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#define YYLMAX 8192"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"#endif\n"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"char yytext[YYLMAX];"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"char *yytext_ptr;"
argument_list|)
expr_stmt|;
block|}
else|else
name|outn
argument_list|(
literal|"char *yytext;"
argument_list|)
expr_stmt|;
block|}
name|out
argument_list|(
operator|&
name|action_array
index|[
name|defs1_offset
index|]
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
operator|!
name|C_plus_plus
condition|)
block|{
if|if
condition|(
name|use_read
condition|)
block|{
name|outn
argument_list|(
literal|"\tif ( (result = read( fileno(yyin), (char *) buf, max_size ))< 0 ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|outn
argument_list|(
literal|"\tif ( yy_current_buffer->yy_is_interactive ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t{ \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tint c = '*', n; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tfor ( n = 0; n< max_size&& \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\t     (c = getc( yyin )) != EOF&& c != '\\n'; ++n ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tbuf[n] = (char) c; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tif ( c == '\\n' ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tbuf[n++] = (char) c; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tif ( c == EOF&& ferror( yyin ) ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" ); \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tresult = n; \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t} \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\telse if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\t&& ferror( yyin ) ) \\"
argument_list|)
expr_stmt|;
name|outn
argument_list|(
literal|"\t\tYY_FATAL_ERROR( \"input in flex scanner failed\" );"
argument_list|)
expr_stmt|;
block|}
block|}
name|skelout
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"#define YY_RULE_SETUP \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|bol_needed
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yyleng> 0 ) \\"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_buffer->yy_at_bol = \\"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"\t\t(yytext[yyleng - 1] == '\\n'); \\"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|indent_puts
argument_list|(
literal|"YY_USER_ACTION"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
comment|/* Copy prolog to output file. */
name|out
argument_list|(
operator|&
name|action_array
index|[
name|prolog_offset
index|]
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
if|if
condition|(
name|yymore_used
operator|&&
operator|!
name|yytext_is_array
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_more_len = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_more_flag )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_more_len = yy_c_buf_p - yytext_ptr;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_more_flag = 0;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
name|gen_start_state
argument_list|()
expr_stmt|;
comment|/* Note, don't use any indentation. */
name|outn
argument_list|(
literal|"yy_match:"
argument_list|)
expr_stmt|;
name|gen_next_match
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|gen_find_action
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_act != YY_END_OF_BUFFER )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"int yyl;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"for ( yyl = 0; yyl< yyleng; ++yyl )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yytext[yyl] == '\\n' )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yylineno;"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|ddebug
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_flex_debug )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"{"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"if ( yy_act == 0 )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
name|C_plus_plus
condition|?
literal|"cerr<< \"--scanner backing up\\n\";"
else|:
literal|"fprintf( stderr, \"--scanner backing up\\n\" );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"else if ( yy_act< %d )\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"cerr<< \"--accepting rule at line \"<< yy_rule_linenum[yy_act]<<"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         \"(\\\"\"<< yytext<< \"\\\")\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--accepting rule at line %d (\\\"%s\\\")\\n\","
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         yy_rule_linenum[yy_act], yytext );"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"else if ( yy_act == %d )\n"
argument_list|,
name|num_rules
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"cerr<< \"--accepting default rule (\\\"\"<< yytext<< \"\\\")\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--accepting default rule (\\\"%s\\\")\\n\","
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"         yytext );"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|out_dec
argument_list|(
literal|"else if ( yy_act == %d )\n"
argument_list|,
name|num_rules
operator|+
literal|1
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
name|C_plus_plus
condition|?
literal|"cerr<< \"--(end of buffer or a NUL)\\n\";"
else|:
literal|"fprintf( stderr, \"--(end of buffer or a NUL)\\n\" );"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
name|do_indent
argument_list|()
expr_stmt|;
name|outn
argument_list|(
literal|"else"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
if|if
condition|(
name|C_plus_plus
condition|)
block|{
name|indent_puts
argument_list|(
literal|"cerr<< \"--EOF (start condition \"<< YY_START<< \")\\n\";"
argument_list|)
expr_stmt|;
block|}
else|else
block|{
name|indent_puts
argument_list|(
literal|"fprintf( stderr, \"--EOF (start condition %d)\\n\", YY_START );"
argument_list|)
expr_stmt|;
block|}
name|indent_down
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"}"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
comment|/* Copy actions to output file. */
name|skelout
argument_list|()
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|gen_bu_action
argument_list|()
expr_stmt|;
name|out
argument_list|(
operator|&
name|action_array
index|[
name|action_offset
index|]
argument_list|)
expr_stmt|;
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|0
argument_list|)
expr_stmt|;
comment|/* generate cases for any missing EOF rules */
for|for
control|(
name|i
operator|=
literal|1
init|;
name|i
operator|<=
name|lastsc
condition|;
operator|++
name|i
control|)
if|if
condition|(
operator|!
name|sceof
index|[
name|i
index|]
condition|)
block|{
name|do_indent
argument_list|()
expr_stmt|;
name|out_str
argument_list|(
literal|"case YY_STATE_EOF(%s):\n"
argument_list|,
name|scname
index|[
name|i
index|]
argument_list|)
expr_stmt|;
name|did_eof_rule
operator|=
name|true
expr_stmt|;
block|}
if|if
condition|(
name|did_eof_rule
condition|)
block|{
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yyterminate();"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
comment|/* Generate code for handling NUL's, if needed. */
comment|/* First, deal with backing up and setting up yy_cp if the scanner 	 * finds that it should JAM on the NUL. 	 */
name|skelout
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|4
argument_list|)
expr_stmt|;
if|if
condition|(
name|fullspd
operator|||
name|fulltbl
condition|)
name|indent_puts
argument_list|(
literal|"yy_cp = yy_c_buf_p;"
argument_list|)
expr_stmt|;
else|else
block|{
comment|/* compressed table */
if|if
condition|(
operator|!
name|reject
operator|&&
operator|!
name|interactive
condition|)
block|{
comment|/* Do the guaranteed-needed backing up to figure 			 * out the match. 			 */
name|indent_puts
argument_list|(
literal|"yy_cp = yy_last_accepting_cpos;"
argument_list|)
expr_stmt|;
name|indent_puts
argument_list|(
literal|"yy_current_state = yy_last_accepting_state;"
argument_list|)
expr_stmt|;
block|}
else|else
comment|/* Still need to initialize yy_cp, though 			 * yy_current_state was set up by 			 * yy_get_previous_state(). 			 */
name|indent_puts
argument_list|(
literal|"yy_cp = yy_c_buf_p;"
argument_list|)
expr_stmt|;
block|}
comment|/* Generate code for yy_get_previous_state(). */
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|gen_start_state
argument_list|()
expr_stmt|;
name|set_indent
argument_list|(
literal|2
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|gen_next_state
argument_list|(
name|true
argument_list|)
expr_stmt|;
name|set_indent
argument_list|(
literal|1
argument_list|)
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
name|gen_NUL_trans
argument_list|()
expr_stmt|;
name|skelout
argument_list|()
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
block|{
comment|/* update yylineno inside of unput() */
name|indent_puts
argument_list|(
literal|"if ( c == '\\n' )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"--yylineno;"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
comment|/* Update BOL and yylineno inside of input(). */
if|if
condition|(
name|bol_needed
condition|)
block|{
name|indent_puts
argument_list|(
literal|"yy_current_buffer->yy_at_bol = (c == '\\n');"
argument_list|)
expr_stmt|;
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( yy_current_buffer->yy_at_bol )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yylineno;"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
block|}
elseif|else
if|if
condition|(
name|do_yylineno
condition|)
block|{
name|indent_puts
argument_list|(
literal|"if ( c == '\\n' )"
argument_list|)
expr_stmt|;
name|indent_up
argument_list|()
expr_stmt|;
name|indent_puts
argument_list|(
literal|"++yylineno;"
argument_list|)
expr_stmt|;
name|indent_down
argument_list|()
expr_stmt|;
block|}
name|skelout
argument_list|()
expr_stmt|;
comment|/* Copy remainder of input to output. */
name|line_directive_out
argument_list|(
name|stdout
argument_list|,
literal|1
argument_list|)
expr_stmt|;
if|if
condition|(
name|sectnum
operator|==
literal|3
condition|)
operator|(
name|void
operator|)
name|flexscan
argument_list|()
expr_stmt|;
comment|/* copy remainder of input to output */
block|}
end_function

end_unit

