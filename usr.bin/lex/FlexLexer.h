begin_unit|revision:0.9.5;language:C;cregit-version:0.0.1
begin_comment
comment|// $Header: /pub/FreeBSD/FreeBSD-CVS/src/usr.bin/lex/FlexLexer.h,v 1.1.1.1 1994/08/24 13:10:33 csgr Exp $
end_comment

begin_comment
comment|// FlexLexer.h -- define classes for lexical analyzers generated by flex
end_comment

begin_comment
comment|// Copyright (c) 1993 The Regents of the University of California.
end_comment

begin_comment
comment|// All rights reserved.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// This code is derived from software contributed to Berkeley by
end_comment

begin_comment
comment|// Kent Williams and Tom Epperly.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// Redistribution and use in source and binary forms are permitted provided
end_comment

begin_comment
comment|// that: (1) source distributions retain this entire copyright notice and
end_comment

begin_comment
comment|// comment, and (2) distributions including binaries display the following
end_comment

begin_comment
comment|// acknowledgement:  ``This product includes software developed by the
end_comment

begin_comment
comment|// University of California, Berkeley and its contributors'' in the
end_comment

begin_comment
comment|// documentation or other materials provided with the distribution and in
end_comment

begin_comment
comment|// all advertising materials mentioning features or use of this software.
end_comment

begin_comment
comment|// Neither the name of the University nor the names of its contributors may
end_comment

begin_comment
comment|// be used to endorse or promote products derived from this software without
end_comment

begin_comment
comment|// specific prior written permission.
end_comment

begin_comment
comment|// THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR IMPLIED
end_comment

begin_comment
comment|// WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
end_comment

begin_comment
comment|// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
end_comment

begin_ifndef
ifndef|#
directive|ifndef
name|__FLEX_LEXER_H
end_ifndef

begin_define
define|#
directive|define
name|__FLEX_LEXER_H
end_define

begin_comment
comment|// This file defines two classes.  The first, FlexLexer, is an abstract
end_comment

begin_comment
comment|// class which specifies the external interface provided to flex C++
end_comment

begin_comment
comment|// lexer objects.  The second, yyFlexLexer, fills out most of the meat
end_comment

begin_comment
comment|// of the lexer class; its internals may vary from lexer to lexer
end_comment

begin_comment
comment|// depending on things like whether REJECT is used.
end_comment

begin_comment
comment|//
end_comment

begin_comment
comment|// If you want to create multiple lexer classes, you use the -P flag
end_comment

begin_comment
comment|// to rename each yyFlexLexer to some other xxFlexLexer.
end_comment

begin_include
include|#
directive|include
file|<iostream.h>
end_include

begin_extern
extern|extern
literal|"C++"
block|{
struct_decl|struct
name|yy_buffer_state
struct_decl|;
typedef|typedef
name|int
name|yy_state_type
typedef|;
name|class
name|FlexLexer
block|{
name|public
label|:
name|virtual
operator|~
name|FlexLexer
argument_list|()
block|{ }
specifier|const
name|char
operator|*
name|YYText
argument_list|()
block|{
return|return
name|yytext
return|;
block|}
name|int
name|YYLeng
parameter_list|()
block|{
return|return
name|yyleng
return|;
block|}
name|virtual
name|void
name|yy_switch_to_buffer
parameter_list|(
name|struct
name|yy_buffer_state
modifier|*
name|new_buffer
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|struct
name|yy_buffer_state
modifier|*
name|yy_create_buffer
parameter_list|(
name|istream
modifier|*
name|s
parameter_list|,
name|int
name|size
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|yy_delete_buffer
parameter_list|(
name|struct
name|yy_buffer_state
modifier|*
name|b
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|void
name|yyrestart
parameter_list|(
name|istream
modifier|*
name|s
parameter_list|)
init|=
literal|0
function_decl|;
name|virtual
name|int
name|yylex
parameter_list|()
init|=
literal|0
function_decl|;
name|protected
label|:
name|char
modifier|*
name|yytext
decl_stmt|;
name|int
name|yyleng
decl_stmt|;
block|}
empty_stmt|;
name|class
name|yyFlexLexer
range|:
name|public
name|FlexLexer
block|{
name|public
operator|:
comment|// arg_yyin and arg_yyout default to the cin and cout, but we
comment|// only make that assignment when initializing in yylex().
name|yyFlexLexer
argument_list|(
argument|istream* arg_yyin =
literal|0
argument_list|,
argument|ostream* arg_yyout =
literal|0
argument_list|)
block|{
name|yyin
operator|=
name|arg_yyin
block|;
name|yyout
operator|=
name|arg_yyout
block|;
name|yy_c_buf_p
operator|=
literal|0
block|;
name|yy_init
operator|=
literal|1
block|;
name|yy_start
operator|=
literal|0
block|;
name|yy_did_buffer_switch_on_eof
operator|=
literal|0
block|;
name|yy_looking_for_trail_begin
operator|=
literal|0
block|;
name|yy_more_flag
operator|=
literal|0
block|;
name|yy_more_len
operator|=
literal|0
block|;
name|yy_start_stack_ptr
operator|=
name|yy_start_stack_depth
operator|=
literal|0
block|;
name|yy_start_stack
operator|=
literal|0
block|;
name|yy_current_buffer
operator|=
literal|0
block|;
ifdef|#
directive|ifdef
name|YY_USES_REJECT
name|yy_state_buf
operator|=
name|new
name|yy_state_type
index|[
name|YY_BUF_SIZE
operator|+
literal|2
index|]
block|;
else|#
directive|else
name|yy_state_buf
operator|=
literal|0
block|;
endif|#
directive|endif
block|}
name|virtual
operator|~
name|yyFlexLexer
argument_list|()
block|{
name|delete
name|yy_state_buf
block|; 		}
name|void
name|yy_switch_to_buffer
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
name|new_buffer
argument_list|)
block|; 	struct
name|yy_buffer_state
operator|*
name|yy_create_buffer
argument_list|(
argument|istream* s
argument_list|,
argument|int size
argument_list|)
block|;
name|void
name|yy_delete_buffer
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
name|b
argument_list|)
block|;
name|void
name|yyrestart
argument_list|(
name|istream
operator|*
name|s
argument_list|)
block|;
name|virtual
name|int
name|yylex
argument_list|()
block|;
name|protected
operator|:
name|virtual
name|int
name|LexerInput
argument_list|(
argument|char* buf
argument_list|,
argument|int max_size
argument_list|)
block|;
name|virtual
name|void
name|LexerOutput
argument_list|(
argument|const char* buf
argument_list|,
argument|int size
argument_list|)
block|;
name|virtual
name|void
name|LexerError
argument_list|(
specifier|const
name|char
operator|*
name|msg
argument_list|)
block|;
name|void
name|yyunput
argument_list|(
argument|int c
argument_list|,
argument|char* buf_ptr
argument_list|)
block|;
name|int
name|yyinput
argument_list|()
block|;
name|void
name|yy_load_buffer_state
argument_list|()
block|;
name|void
name|yy_init_buffer
argument_list|(
expr|struct
name|yy_buffer_state
operator|*
name|b
argument_list|,
name|istream
operator|*
name|s
argument_list|)
block|;
name|int
name|yy_start_stack_ptr
block|;
name|int
name|yy_start_stack_depth
block|;
name|int
operator|*
name|yy_start_stack
block|;
name|void
name|yy_push_state
argument_list|(
argument|int new_state
argument_list|)
block|;
name|void
name|yy_pop_state
argument_list|()
block|;
name|int
name|yy_top_state
argument_list|()
block|;
name|yy_state_type
name|yy_get_previous_state
argument_list|()
block|;
name|yy_state_type
name|yy_try_NUL_trans
argument_list|(
argument|yy_state_type current_state
argument_list|)
block|;
name|int
name|yy_get_next_buffer
argument_list|()
block|;
name|istream
operator|*
name|yyin
block|;
comment|// input source for default LexerInput
name|ostream
operator|*
name|yyout
block|;
comment|// output sink for default LexerOutput
block|struct
name|yy_buffer_state
operator|*
name|yy_current_buffer
block|;
comment|// yy_hold_char holds the character lost when yytext is formed.
name|char
name|yy_hold_char
block|;
comment|// Number of characters read into yy_ch_buf.
name|int
name|yy_n_chars
block|;
comment|// Points to current character in buffer.
name|char
operator|*
name|yy_c_buf_p
block|;
name|int
name|yy_init
block|;
comment|// whether we need to initialize
name|int
name|yy_start
block|;
comment|// start state number
comment|// Flag which is used to allow yywrap()'s to do buffer switches
comment|// instead of setting up a fresh yyin.  A bit of a hack ...
name|int
name|yy_did_buffer_switch_on_eof
block|;
comment|// The following are not always needed, but may be depending
comment|// on use of certain flex features (like REJECT or yymore()).
name|yy_state_type
name|yy_last_accepting_state
block|;
name|char
operator|*
name|yy_last_accepting_cpos
block|;
name|yy_state_type
operator|*
name|yy_state_buf
block|;
name|yy_state_type
operator|*
name|yy_state_ptr
block|;
name|char
operator|*
name|yy_full_match
block|;
name|int
operator|*
name|yy_full_state
block|;
name|int
name|yy_full_lp
block|;
name|int
name|yy_lp
block|;
name|int
name|yy_looking_for_trail_begin
block|;
name|int
name|yy_more_flag
block|;
name|int
name|yy_more_len
block|; }
decl_stmt|;
block|}
end_extern

begin_endif
endif|#
directive|endif
end_endif

end_unit

